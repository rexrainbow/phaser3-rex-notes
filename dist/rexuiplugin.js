(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.rexuiplugin = factory());
})(this, (function () { 'use strict';

    class ObjectFactory {
        constructor(scene) {
            this.scene = scene;

            scene.events.once('destroy', this.destroy, this);
        }

        destroy() {
            this.scene = null;
        }

        static register(type, callback) {
            ObjectFactory.prototype[type] = callback;
        }
    }

    var SetGetFrameNameCallback = function(callback) {
        if (callback === undefined) {
            callback = DefaultGetFrameNameCallback;
        }
        this.getFrameNameCallback = callback;
        return this;
    };

    var DefaultGetFrameNameCallback = function (colIndex, rowIndex, baseFrameName) {
        if (baseFrameName === '__BASE') {
            return `${colIndex},${rowIndex}`;
        } else {
            return `${baseFrameName}:${colIndex},${rowIndex}`;
        }
    };

    function DeepClone(obj) {
        if (obj === null || typeof obj !== 'object') {
            // If obj is a primitive value or null, return it directly
            return obj;
        }

        if (Array.isArray(obj)) {
            // If obj is an array, create a new array and clone each element
            return obj.map(item => DeepClone(item));
        }

        if (obj instanceof Date) {
            // If obj is a Date object, create a new Date object with the same value
            return new Date(obj);
        }

        if (obj instanceof RegExp) {
            // If obj is a RegExp object, create a new RegExp object with the same pattern and flags
            return new RegExp(obj);
        }

        if (Object.getPrototypeOf(obj) !== Object.prototype) {
            // If obj is a custom object, return a reference to it
            return obj;
        }

        // If obj is a plain object, create a new object and clone each property
        const clonedObj = {};
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                clonedObj[key] = DeepClone(obj[key]);
            }
        }
        return clonedObj;
    }

    var SetBaseTexture = function (key, baseFrameName, columns, rows) {
        if (Array.isArray(baseFrameName)) {
            rows = columns;
            columns = baseFrameName;
            baseFrameName = undefined;
        }

        if (baseFrameName == null) {
            baseFrameName = '__BASE';
        }

        if ((typeof (columns) === 'number') && (arguments.length >= 6)) {
            columns = [arguments[2], undefined, arguments[3]];
            rows = [arguments[4], undefined, arguments[5]];
        } else if (
            (columns === undefined) &&
            (rows === undefined) &&
            (this.columns.data !== undefined) &&
            (this.rows.data !== undefined)
        ) {
            columns = this.columns.data;
            rows = this.rows.data;
        } else {
            columns = DeepClone(columns);
            rows = DeepClone(rows);
        }

        this.textureKey = key;
        this.baseFrameName = baseFrameName;
        this.columns.data = columns;
        this.columns.count = (columns) ? columns.length : 0;
        this.columns.stretch = 0;
        this.columns.minWidth = 0;
        this.columns.scale = 1;
        this.rows.data = rows;
        this.rows.count = (rows) ? rows.length : 0;
        this.rows.stretch = 0;
        this.rows.minHeight = 0;
        this.rows.scale = 1;

        var texture = this.scene.sys.textures.get(key);
        if (!texture) {
            this.clear();
            return this;
        }
        if (!columns || !rows) {
            this.clear();
            return this;
        }

        // Get remainder width/height for unknown width/height
        var baseFrame = texture.get(baseFrameName);
        var remainderTextureWidth = baseFrame.width;
        var unknownColumnWidthCount = 0;
        for (var i = 0, cnt = columns.length; i < cnt; i++) {
            if (columns[i] === undefined) {
                unknownColumnWidthCount++;
            } else if (typeof (columns[i]) === 'number') {
                remainderTextureWidth -= columns[i];
            } else {
                remainderTextureWidth -= columns[i].width;
            }
        }
        var unknownColumnWidth = (unknownColumnWidthCount > 0) ? (remainderTextureWidth / unknownColumnWidthCount) : 0;

        var remainderTextureHeight = baseFrame.height;
        var unknownRowHeightCount = 0;
        for (var i = 0, cnt = rows.length; i < cnt; i++) {
            if (rows[i] === undefined) {
                unknownRowHeightCount++;
            } else if (typeof (rows[i]) === 'number') {
                remainderTextureHeight -= rows[i];
            } else {
                remainderTextureHeight -= rows[i].width;
            }
        }
        var unknownRowHeight = (unknownRowHeightCount) ? (remainderTextureHeight / unknownRowHeightCount) : 0;

        var row, col, rowHeight, colWidth, frameName;
        var offsetX = 0, offsetY = 0;
        for (var j = 0, jcnt = rows.length; j < jcnt; j++) {
            // Unknown height
            if (rows[j] === undefined) {
                rows[j] = unknownRowHeight;
            }

            if (typeof (rows[j]) === 'number') {
                rows[j] = {
                    height: rows[j],
                    stretch: (j % 2),
                };
            }

            row = rows[j];
            rowHeight = row.height;

            this.rows.stretch += (row.stretch | 0);
            this.rows.minHeight += (row.stretch > 0) ? 0 : rowHeight;

            offsetX = 0;
            for (var i = 0, icnt = columns.length; i < icnt; i++) {
                // Unknown width
                if (columns[i] === undefined) {
                    columns[i] = unknownColumnWidth;
                }

                if (typeof (columns[i]) === 'number') {
                    columns[i] = {
                        width: columns[i],
                        stretch: (i % 2),
                    };
                }

                col = columns[i];
                colWidth = col.width;

                if (j === 0) {
                    this.columns.stretch += (col.stretch | 0);
                    this.columns.minWidth += (col.stretch > 0) ? 0 : colWidth;
                }

                if ((colWidth >= 1) && (rowHeight >= 1)) {
                    frameName = this.getFrameNameCallback(i, j, baseFrameName);
                    var frameNameType = typeof (frameName);
                    if ((frameNameType === 'string') || (frameNameType === 'number')) {
                        texture.add(
                            frameName, 0,
                            (offsetX + baseFrame.cutX), (offsetY + baseFrame.cutY),
                            colWidth, rowHeight
                        );
                        // Do nothing if frameName is existed
                    }
                }
                offsetX += colWidth;
            }
            offsetY += rowHeight;
        }

        this.updateTexture();
        return this;
    };

    var UpdateTexture = function () {
        this.clear();

        if (this.textureKey === undefined) {
            return this;
        }
        var texture = this.scene.sys.textures.get(this.textureKey);
        if (!texture) {
            return this;
        }

        var minWidth = this.columns.minWidth * this.maxFixedPartScaleX;  // Fixed-part width
        var minHeight = this.rows.minHeight * this.maxFixedPartScaleY;   // Fixed-part height
        var stretchWidth = this.width - minWidth;
        var stretchHeight = this.height - minHeight;
        var fixedPartScaleX = (stretchWidth >= 0) ? this.maxFixedPartScaleX : (this.width / minWidth);
        var fixedPartScaleY = (stretchHeight >= 0) ? this.maxFixedPartScaleY : (this.height / minHeight);

        if (this.preserveRatio) {
            var minScale = Math.min(fixedPartScaleX, fixedPartScaleY);
            if (fixedPartScaleX > minScale) {
                var compensationWidth = (fixedPartScaleX - minScale) * minWidth;
                if (stretchWidth >= 0) {
                    stretchWidth += compensationWidth;
                } else {
                    stretchWidth = compensationWidth;
                }
                fixedPartScaleX = minScale;
            }
            if (fixedPartScaleY > minScale) {
                var compensationHeight = (fixedPartScaleY - minScale) * minHeight;
                if (stretchHeight >= 0) {
                    stretchHeight += compensationHeight;
                } else {
                    stretchHeight = compensationHeight;
                }
                fixedPartScaleY = minScale;
            }
        }
        this.columns.scale = fixedPartScaleX;
        this.rows.scale = fixedPartScaleY;

        var proportionWidth;
        if (stretchWidth > 0) {
            proportionWidth = (this.columns.stretch > 0) ? (stretchWidth / this.columns.stretch) : 0;
        } else {
            proportionWidth = 0;
        }

        var proportionHeight;
        if (stretchHeight > 0) {
            proportionHeight = (this.rows.stretch > 0) ? (stretchHeight / this.rows.stretch) : 0;
        } else {
            proportionHeight = 0;
        }

        var frameName, col, row, colWidth, rowHeight;
        var offsetX = 0, offsetY = 0;
        var imageType;

        this._beginDraw();
        for (var j = 0, jcnt = this.rows.count; j < jcnt; j++) {
            row = this.rows.data[j];
            rowHeight = (row.stretch === 0) ? (row.height * fixedPartScaleY) : (proportionHeight * row.stretch);

            offsetX = 0;
            for (var i = 0, icnt = this.columns.count; i < icnt; i++) {
                col = this.columns.data[i];
                colWidth = (col.stretch === 0) ? (col.width * fixedPartScaleX) : (proportionWidth * col.stretch);

                frameName = this.getFrameNameCallback(i, j, this.baseFrameName);
                if (texture.has(frameName) && (colWidth > 0) && (rowHeight > 0)) {
                    if ((row.stretch === 0) && (col.stretch === 0)) { // Fixed parts
                        imageType = 0; // Draw image
                    } else { // Stretchable parts
                        if (this.getStretchMode(i, j) === 0) { // Scaled image
                            imageType = 0; // Draw scaled image
                        } else { // Repeat tile-sprite
                            imageType = 1; // Draw tile-sprite
                        }
                    }

                    if (imageType === 0) {
                        this._drawImage(
                            this.textureKey, frameName,
                            offsetX, offsetY,
                            colWidth, rowHeight
                        );
                    } else {
                        this._drawTileSprite(
                            this.textureKey, frameName,
                            offsetX, offsetY,
                            colWidth, rowHeight
                        );
                    }
                }

                offsetX += colWidth;
            }

            offsetY += rowHeight;
        }
        this._endDraw();
    };

    const IsPlainObject$W = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3Y = Phaser.Utils.Objects.GetValue;

    var SetStretchMode = function(mode) {
        if (IsPlainObject$W(mode)) {
            this.stretchMode.edge = parseMode(GetValue$3Y(mode, 'edge', 0));
            this.stretchMode.internal = parseMode(GetValue$3Y(mode, 'internal', 0));
        } else {
            mode = parseMode(mode);
            this.stretchMode.edge = mode;
            this.stretchMode.internal = mode;
        }
        return this;
    };

    var parseMode = function (mode) {
        if (typeof (mode) === 'string') {
            mode = EXTENDMODE[mode];
        }
        return mode;
    };

    const EXTENDMODE = {
        scale: 0,
        repeat: 1,
    };

    var IsEdge = function (colIndex, rowIndex) {
        return (colIndex === 0) || (colIndex === (this.columns.count - 1)) ||
            (rowIndex === 0) || (rowIndex === (this.rows.count - 1));
    };

    var GetStretchMode = function(colIndex, rowIndex) {
        return (IsEdge.call(this, colIndex, rowIndex)) ? this.stretchMode.edge : this.stretchMode.internal;
    };

    var SetPreserveRatio = function (enable) {
        if (enable == undefined) {
            enable = true;
        }

        this.preserveRatio = enable;
        return this;
    };

    var SetMaxFixedPartScale = function (scaleX, scaleY) {
        if (scaleY === undefined) {
            scaleY = scaleX;
        }

        this.maxFixedPartScaleX = scaleX;
        this.maxFixedPartScaleY = scaleY;
        return this;
    };

    var NOOP = function () {
        //  NOOP
    };

    var Methods$n = {
        _beginDraw: NOOP,
        _drawImage: NOOP,
        _drawTileSprite: NOOP,
        _endDraw: NOOP,

        setGetFrameNameCallback: SetGetFrameNameCallback,
        setBaseTexture: SetBaseTexture,
        updateTexture: UpdateTexture,
        setStretchMode: SetStretchMode,
        getStretchMode: GetStretchMode,
        setPreserveRatio: SetPreserveRatio,
        setMaxFixedPartScale: SetMaxFixedPartScale,
    };

    const IsPlainObject$V = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3X = Phaser.Utils.Objects.GetValue;

    var NinePatchBase = function (GOClass, type) {
        class NinePatch extends GOClass {
            constructor(scene, x, y, width, height, key, baseFrame, columns, rows, config) {
                if (IsPlainObject$V(x)) {
                    config = x;
                    x = GetValue$3X(config, 'x', 0);
                    y = GetValue$3X(config, 'y', 0);
                    width = GetValue$3X(config, 'width', 1);
                    height = GetValue$3X(config, 'height', 1);
                    key = GetValue$3X(config, 'key', undefined);
                    baseFrame = GetValue$3X(config, 'baseFrame', undefined);
                    columns = GetValue$3X(config, 'columns', undefined);
                    rows = GetValue$3X(config, 'rows', undefined);
                } else if (IsPlainObject$V(width)) {
                    config = width;
                    width = GetValue$3X(config, 'width', 1);
                    height = GetValue$3X(config, 'height', 1);
                    key = GetValue$3X(config, 'key', undefined);
                    baseFrame = GetValue$3X(config, 'baseFrame', undefined);
                    columns = GetValue$3X(config, 'columns', undefined);
                    rows = GetValue$3X(config, 'rows', undefined);
                } else if (IsPlainObject$V(key)) {
                    config = key;
                    key = GetValue$3X(config, 'key', undefined);
                    baseFrame = GetValue$3X(config, 'baseFrame', undefined);
                    columns = GetValue$3X(config, 'columns', undefined);
                    rows = GetValue$3X(config, 'rows', undefined);
                } else if (IsPlainObject$V(baseFrame)) {
                    config = baseFrame;
                    baseFrame = GetValue$3X(config, 'baseFrame', undefined);
                    columns = GetValue$3X(config, 'columns', undefined);
                    rows = GetValue$3X(config, 'rows', undefined);
                } else if (Array.isArray(baseFrame)) {
                    config = rows;
                    rows = columns;
                    columns = baseFrame;
                    baseFrame = GetValue$3X(config, 'baseFrame', undefined);
                } else if (IsPlainObject$V(columns)) {
                    config = columns;
                    columns = GetValue$3X(config, 'columns', undefined);
                    rows = GetValue$3X(config, 'rows', undefined);
                }

                if (baseFrame === undefined) {
                    baseFrame = GetValue$3X(config, 'frame', undefined);
                }

                if (columns === undefined) {
                    var leftWidth = GetValue$3X(config, 'leftWidth', undefined);
                    var rightWidth = GetValue$3X(config, 'rightWidth', undefined);
                    if ((leftWidth !== undefined) && (rightWidth !== undefined)) {
                        columns = [leftWidth, undefined, rightWidth];
                    }
                }

                if (rows === undefined) {
                    var topHeight = GetValue$3X(config, 'topHeight', undefined);
                    var bottomHeight = GetValue$3X(config, 'bottomHeight', undefined);
                    if ((topHeight !== undefined) && (bottomHeight !== undefined)) {
                        rows = [topHeight, undefined, bottomHeight];
                    }
                }

                super(scene);
                this.type = type;
                this
                    .setPosition(x, y)
                    .setSize(width, height)
                    .setOrigin(0.5, 0.5);

                this.columns = {};
                this.rows = {};
                this.stretchMode = {};
                this._tileSprite = undefined; // Reserved for drawing image
                this._image = undefined; // Reserved for drawing image

                this.setGetFrameNameCallback(GetValue$3X(config, 'getFrameNameCallback', undefined));
                this.setStretchMode(GetValue$3X(config, 'stretchMode', 0));
                this.setPreserveRatio(GetValue$3X(config, 'preserveRatio', true));

                var maxFixedPartScale = GetValue$3X(config, 'maxFixedPartScale', 1);
                var maxFixedPartScaleX = GetValue$3X(config, 'maxFixedPartScaleX', maxFixedPartScale);
                var maxFixedPartScaleY = GetValue$3X(config, 'maxFixedPartScaleY', undefined);
                this.setMaxFixedPartScale(maxFixedPartScaleX, maxFixedPartScaleY);

                this.setBaseTexture(key, baseFrame, columns, rows);
            }

            get minWidth() {
                return this.columns.minWidth;
            }

            get minHeight() {
                return this.rows.minHeight;
            }

            get fixedPartScaleX() {
                return this.columns.scale;
            }

            get fixedPartScaleY() {
                return this.rows.scale;
            }

            resize(width, height) {
                if ((this.width === width) && (this.height === height)) {
                    return this;
                }

                if (super.resize) {
                    super.resize(width, height);
                } else {
                    // Use setSize method for alternative 
                    super.setSize(width, height);
                }
                this.updateTexture();

                return this;
            }

            get leftWidth() {
                return this.columns.data[0];
            }

            get rightWidth() {
                return this.columns.data[this.columns.count - 1];
            }

            get topHeight() {
                return this.rows.data[0];
            }

            get bottomHeight() {
                return this.rows.data[this.rows.count - 1];
            }

        }

        Object.assign(
            NinePatch.prototype,
            Methods$n
        );

        return NinePatch;
    };

    const GameClass = Phaser.Game;
    var IsGame = function (object) {
        return (object instanceof GameClass);
    };

    const SceneClass = Phaser.Scene;
    var IsSceneObject = function (object) {
        return (object instanceof SceneClass);
    };

    var GetGame = function (object) {
        if ((object == null) || (typeof (object) !== 'object')) {
            return null;
        } else if (IsGame(object)) {
            return object;
        } else if (IsGame(object.game)) {
            return object.game;
        } else if (IsSceneObject(object)) { // object = scene object
            return object.sys.game;
        } else if (IsSceneObject(object.scene)) { // object = game object
            return object.scene.sys.game;
        }
    };

    const GameObjectClasses = Phaser.GameObjects;

    var GameObjects = undefined;

    var GetStampGameObject = function (gameObject, className) {
        if (!GameObjects) {
            GameObjects = {};

            GetGame(gameObject).events.once('destroy', function () {
                for (var name in GameObjects) {
                    GameObjects[name].destroy();
                }
                GameObjects = undefined;
            });
        }

        if (!GameObjects.hasOwnProperty(className)) {
            var scene = GetGame(gameObject).scene.systemScene;
            var gameObject = new GameObjectClasses[className](scene);
            gameObject.setOrigin(0);

            GameObjects[className] = gameObject;
        }

        return GameObjects[className];
    };

    var DrawImage$2 = function (key, frame, x, y, width, height) {
        var gameObject = GetStampGameObject(this, 'Image')
            .setTexture(key, frame)
            .setDisplaySize(width, height);

        this.draw(gameObject, x, y);
    };

    var DrawTileSprite$1 = function (key, frame, x, y, width, height) {
        var gameObject = GetStampGameObject(this, 'TileSprite')
            .setTexture(key, frame)
            .setSize(width, height);

        this.draw(gameObject, x, y);
    };

    const RenderTexture$2 = Phaser.GameObjects.RenderTexture;

    let NinePatch$1 = class NinePatch extends NinePatchBase(RenderTexture$2, 'rexNinePatch') {
    };

    var Methods$m = {
        _drawImage: DrawImage$2,
        _drawTileSprite: DrawTileSprite$1,
    };
    Object.assign(
        NinePatch$1.prototype,
        Methods$m
    );

    var IsInValidKey = function (keys) {
        return (keys == null) || (keys === '') || (keys.length === 0);
    };

    var GetEntry = function (target, keys, defaultEntry) {
        var entry = target;
        if (IsInValidKey(keys)) ; else {
            if (typeof (keys) === 'string') {
                keys = keys.split('.');
            }

            var key;
            for (var i = 0, cnt = keys.length; i < cnt; i++) {
                key = keys[i];
                if ((entry[key] == null) || (typeof (entry[key]) !== 'object')) {
                    var newEntry;
                    if (i === cnt - 1) {
                        if (defaultEntry === undefined) {
                            newEntry = {};
                        } else {
                            newEntry = defaultEntry;
                        }
                    } else {
                        newEntry = {};
                    }

                    entry[key] = newEntry;
                }

                entry = entry[key];
            }
        }

        return entry;
    };

    var SetValue = function (target, keys, value, delimiter) {
        if (delimiter === undefined) {
            delimiter = '.';
        }

        // no object
        if (typeof (target) !== 'object') {
            return;
        }

        // invalid key
        else if (IsInValidKey(keys)) {
            // don't erase target
            if (value == null) {
                return;
            }
            // set target to another object
            else if (typeof (value) === 'object') {
                target = value;
            }
        } else {
            if (typeof (keys) === 'string') {
                keys = keys.split(delimiter);
            }

            var lastKey = keys.pop();
            var entry = GetEntry(target, keys);
            entry[lastKey] = value;
        }

        return target;
    };

    ObjectFactory.register('ninePatch', function (x, y, width, height, key, columns, rows, config) {
        var gameObject = new NinePatch$1(this.scene, x, y, width, height, key, columns, rows, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.NinePatch', NinePatch$1);

    const GetCalcMatrix$2 = Phaser.GameObjects.GetCalcMatrix;

    var WebGLRenderer$3 = function (renderer, src, camera, parentMatrix) {
        var bobs = src.getRenderList();
        if (bobs.length === 0) {
            return;
        }

        camera.addToRenderList(src);

        var pipeline = renderer.pipelines.set(src.pipeline);

        var texture = src.frame.glTexture;

        var textureUnit = pipeline.setGameObject(src);

        var roundPixels = camera.roundPixels;

        var result = GetCalcMatrix$2(src, camera, parentMatrix);

        var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

        var dx = src._displayOriginX;
        var dy = src._displayOriginY;

        var alpha = camera.alpha * src.alpha;

        renderer.pipelines.preBatch(src);

        for (var i = 0, cnt = bobs.length; i < cnt; i++) {
            bobs[i].webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels);
        }

        renderer.pipelines.postBatch(src);
    };

    const SetTransform$2 = Phaser.Renderer.Canvas.SetTransform;

    var CanvasRenderer$3 = function (renderer, src, camera, parentMatrix) {
        var ctx = renderer.currentContext;

        var bobs = src.getRenderList();
        if ((bobs.length === 0) || (!SetTransform$2(renderer, ctx, src, camera, parentMatrix))) {
            return;
        }

        camera.addToRenderList(src);

        var roundPixels = camera.roundPixels;

        var dx = -src._displayOriginX,
            dy = -src._displayOriginY;

        ctx.translate(dx, dy);

        for (var i = 0, cnt = bobs.length; i < cnt; i++) {
            bobs[i].canvasRender(ctx, dx, dy, roundPixels);
        }

        //  Restore the context saved in SetTransform
        ctx.restore();
    };

    var Render$4 = {
        renderWebGL: WebGLRenderer$3,
        renderCanvas: CanvasRenderer$3

    };

    var SetTexture = function (key, frame) {
        this.texture = this.scene.sys.textures.get(key);
        this.frame = this.texture.get(frame);
        return this;
    };

    var Resize$2 = function (width, height) {
        if ((this.width === width) && (this.height === height)) {
            return this;
        }

        this.width = width;
        this.height = height;

        this.updateDisplayOrigin();

        var input = this.input;

        if (input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
        }

        return this;
    };

    var AddChild$4 = function (bob) {
        this.lastAppendedChildren.length = 0;

        if (Array.isArray(bob)) {
            this.children.add(bob);
            this.lastAppendedChildren.push(...bob);
        } else {
            this.children.add(bob);
            this.lastAppendedChildren.push(bob);
        }

        return this;
    };

    const RemoveItem$e = Phaser.Utils.Array.Remove;

    var RemoveChild$3 = function (bob) {
        if (this.poolManager) {
            // Free this bob (bob.onFree())
            this.poolManager.free(bob);
        }

        // Remove this bob from blitter
        RemoveItem$e(this.children.list, bob);
        this.lastAppendedChildren.length = 0;
        this.dirty = true;
        return this;
    };

    var RemoveChildren$1 = function () {
        if (this.poolManager) {
            // Free all bobs (bob.onFree())
            this.poolManager.freeMultiple(this.children.list);
        }

        // Remove all bobs from blitter
        this.children.list.length = 0;
        this.lastAppendedChildren.length = 0;
        this.dirty = true;
        return this;
    };

    var GetLastAppendedChildren$1 = function () {
        return this.lastAppendedChildren;
    };

    var GetChildren$1 = function () {
        return this.children.list;
    };

    var TintMethods = {
        setTint(tint) {
            // 0: Solid tint + texture alpha
            this.tint = tint;
            this.tintFill = false;
            return this;
        },

        setTintFill(tint) {
            // 1: Solid tint, no texture
            this.tint = tint;
            this.tintFill = true;
            return this;
        },

        clearTint() {
            this.setTint(0xffffff);
            return this;
        }
    };

    var methods$K = {
        setTexture: SetTexture,
        resize: Resize$2,
        setSize: Resize$2,
        addChild: AddChild$4,
        removeChild: RemoveChild$3,
        removeChildren: RemoveChildren$1,
        clear: RemoveChildren$1,
        getLastAppendedChildren: GetLastAppendedChildren$1,
        getChildren: GetChildren$1,
    };

    Object.assign(
        methods$K,
        TintMethods
    );

    class Stack {
        constructor() {
            this.items = [];
        }

        destroy() {
            this.clear();
            this.items = undefined;
        }

        pop() {
            return (this.items.length > 0) ? this.items.pop() : null;
        }

        push(l) {
            this.items.push(l);
            return this;
        }

        pushMultiple(arr) {
            this.items.push.apply(this.items, arr);
            arr.length = 0;
            return this;
        }

        clear() {
            this.items.length = 0;
            return this;
        }
    }

    const GetValue$3W = Phaser.Utils.Objects.GetValue;

    var Pools$1 = {};
    let PoolManager$1 = class PoolManager {
        constructor(config) {
            this.pools = GetValue$3W(config, 'pools', Pools$1);
        }

        destroy() {
            this.pools = undefined;
        }

        free(bob) {
            if (!this.pools) {
                return this;
            }

            var bobType = bob.type;
            if (!this.pools.hasOwnProperty(bobType)) {
                this.pools[bobType] = new Stack();
            }
            this.pools[bobType].push(bob);
            bob.onFree();
            return this;
        }

        freeMultiple(bobs) {
            if (!this.pools) {
                return this;
            }

            for (var i = 0, cnt = bobs.length; i < cnt; i++) {
                this.free(bobs[i]);
            }
            return this;
        }

        allocate(bobType) {
            if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
                return null;
            }
            return this.pools[bobType].pop();
        }
    };

    const MinVersion = 60;

    var IsChecked = false;

    var CheckP3Version = function (minVersion) {
        if (IsChecked) {
            return;
        }

        if (minVersion === undefined) {
            minVersion = MinVersion;
        }
        var version = Phaser.VERSION.split('.');
        var mainVersion = parseInt(version[0]);
        if (mainVersion === 3) {
            var currentVersion = parseInt(version[1]);
            if (currentVersion < minVersion) {
                console.error(`Minimum supported version : ${mainVersion}.${currentVersion}`);
            }
        } else {
            console.error(`Can't supported version : ${mainVersion}`);
        }

        IsChecked = true;
    };

    CheckP3Version();

    const GameObject$4 = Phaser.GameObjects.GameObject;
    const IsPlainObject$U = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3V = Phaser.Utils.Objects.GetValue;
    const List = Phaser.Structs.List;
    const StableSort = Phaser.Utils.Array.StableSort;

    class Blitter extends GameObject$4 {
        constructor(scene, x, y, texture, frame, config) {
            if (IsPlainObject$U(x)) {
                config = x;
                x = GetValue$3V(config, 'x', 0);
                y = GetValue$3V(config, 'y', 0);
                texture = GetValue$3V(config, 'texture');
                frame = GetValue$3V(config, 'frame');
            }

            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }

            super(scene, 'rexBlitter');

            this.children = new List();
            this.renderList = [];
            this.displayListDirty = false;
            this.lastAppendedChildren = [];

            var reuseBob = GetValue$3V(config, 'reuseBob', true);
            this.poolManager = (reuseBob) ? (new PoolManager$1(config)) : undefined;

            this.setTexture(texture, frame);
            this.setPosition(x, y);
            this.setOrigin(0, 0);
            this.clearTint();
            this.initPipeline();
            this.initPostPipeline();

        }

        preDestroy() {
            this.removeChildren();
            this.children.destroy();
            this.renderList.length = 0;

            if (this.poolManager) {
                this.poolManager.destroy();
            }
        }

        getRenderList() {
            if (this.displayListDirty) {
                this.renderList.length = 0;
                var needDepthSort = false;

                var children = this.children.list;
                for (var i = 0, cnt = children.length; i < cnt; i++) {
                    var child = children[i];
                    if (ChildCanRender(child)) {
                        this.renderList.push(child);

                        if (!needDepthSort) {
                            needDepthSort = (child.depth !== 0);
                        }
                    }
                }

                if (needDepthSort) {
                    StableSort(this.renderList, SortByDepth);
                }

                this.displayListDirty = false;
            }

            return this.renderList;
        }
    }

    var ChildCanRender = function (child) {
        return (child.active && child.visible && (child.alpha > 0));
    };

    var SortByDepth = function (childA, childB) {
        return childA._depth - childB._depth;
    };

    const Components$4 = Phaser.GameObjects.Components;
    Phaser.Class.mixin(Blitter,
        [
            Components$4.Alpha,
            Components$4.BlendMode,
            Components$4.ComputedSize,
            Components$4.Depth,
            Components$4.GetBounds,
            Components$4.Mask,
            Components$4.Origin,
            Components$4.Pipeline,
            Components$4.PostPipeline,
            Components$4.ScrollFactor,
            Components$4.Transform,
            Components$4.Visible,
            Render$4,

            methods$K
        ]
    );

    const ImageTypeName$1 = 'image';

    var GetValue$3U = function (source, key, defaultValue) {
        if (!source || typeof source === 'number') {
            return defaultValue;
        }

        if (typeof (key) === 'string') {
            if (source.hasOwnProperty(key)) {
                return source[key];
            }
            if (key.indexOf('.') !== -1) {
                key = key.split('.');
            } else {
                return defaultValue;
            }
        }

        var keys = key;
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            if (parent.hasOwnProperty(key)) {
                //  Yes it has a key property, let's carry on down
                value = parent[key];

                parent = value;
            }
            else {
                //  Can't go any further, so reset to default
                value = defaultValue;
                break;
            }
        }

        return value;
    };

    var Clear$1 = function (obj) {
        if ((typeof (obj) !== 'object') || (obj === null)) {
            return obj;
        }

        if (Array.isArray(obj)) {
            obj.length = 0;
        } else {
            for (var key in obj) {
                delete obj[key];
            }
        }

        return obj;
    };

    var DataMethods$2 = {
        enableData() {
            if (this.data === undefined) {
                this.data = {};
            }
            return this;
        },

        setData(key, value) {
            this.enableData();
            if (arguments.length === 1) {
                var data = key;
                for (key in data) {
                    this.data[key] = data[key];
                }
            } else {
                this.data[key] = value;
            }
            return this;
        },

        getData(key, defaultValue) {
            this.enableData();
            return (key === undefined) ? this.data : GetValue$3U(this.data, key, defaultValue);
        },

        incData(key, inc, defaultValue) {
            if (defaultValue === undefined) {
                defaultValue = 0;
            }
            this.enableData();
            this.setData(key, this.getData(key, defaultValue) + inc);
            return this;
        },

        mulData(key, mul, defaultValue) {
            if (defaultValue === undefined) {
                defaultValue = 0;
            }
            this.enableData();
            this.setData(key, this.getData(key, defaultValue) * mul);
            return this;
        },

        clearData() {
            if (this.data) {
                Clear$1(this.data);
            }
            return this;
        },
    };

    let Base$4 = class Base {
        constructor(parent, type) {
            this.type = type;

            this.data = undefined;

            this
                .setParent(parent)
                .reset()
                .setActive();

        }

        destroy() {
            if (this.parent) {
                this.parent.removeChild(this);
                // Remove this bob from blitter, and free it (bob.onFree())
                // Will set this.parent to undefined
            }
        }

        setParent(parent) {
            this.parent = parent;
            return this;
        }

        // get scene() {
        //     if (this.parent) {
        //         return this.parent.scene;
        //     } else {
        //         return null;
        //     }
        // }

        setDisplayListDirty(displayListDirty) {
            if (displayListDirty && this.parent) {
                this.parent.displayListDirty = true;
            }
            return this;
        }

        get active() {
            return this._active;
        }

        set active(value) {
            this.setDisplayListDirty(this._active != value);
            this._active = value;
        }

        setActive(active) {
            if (active === undefined) {
                active = true;
            }
            this.active = active;
            return this;
        }

        modifyPorperties(o) {
            return this;
        }

        // Override
        reset() {
            this.clearData();
        }

        // Override
        onFree() {
            this.reset().setActive(false).setParent();
        }
    };

    Object.assign(
        Base$4.prototype,
        DataMethods$2
    );

    const DegToRad$j = Phaser.Math.DegToRad;
    const RadToDeg$e = Phaser.Math.RadToDeg;
    const GetValue$3T = Phaser.Utils.Objects.GetValue;

    let RenderBase$1 = class RenderBase extends Base$4 {

        get visible() {
            return this._visible;
        }

        set visible(value) {
            this.setDisplayListDirty(this._visible != value);
            this._visible = value;
        }

        setVisible(visible) {
            if (visible === undefined) {
                visible = true;
            }

            this.visible = visible;
            return this;
        }

        get alpha() {
            return this._alpha;
        }

        set alpha(value) {
            this.setDisplayListDirty(!!this._alpha !== !!value);
            this._alpha = value;
        }

        setAlpha(alpha) {
            this.alpha = alpha;
            return this;
        }

        setX(x) {
            this.x = x;
            return this;
        }

        setY(y) {
            this.y = y;
            return this;
        }

        setPosition(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }

        setRotation(rotation) {
            this.rotation = rotation;
            return this;
        }

        get angle() {
            return RadToDeg$e(this.rotation);
        }

        set angle(value) {
            this.rotation = DegToRad$j(value);
        }

        setAngle(angle) {
            this.angle = angle;
            return this;
        }

        setScaleX(scaleX) {
            this.scaleX = scaleX;
            return this;
        }

        get width() {
            return this._width;
        }

        set width(value) {
            this._width = value;
        }

        setWidth(width, keepAspectRatio) {
            if (keepAspectRatio === undefined) {
                keepAspectRatio = false;
            }
            this.width = width;

            if (keepAspectRatio) {
                this.scaleY = this.scaleX;
            }
            return this;
        }

        setScaleY(scaleY) {
            this.scaleY = scaleY;
            return this;
        }

        setScale(scaleX, scaleY) {
            if (scaleY === undefined) {
                scaleY = scaleX;
            }
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            return this;
        }

        get height() {
            return this._height;
        }

        set height(value) {
            this._height = value;
        }

        setHeight(height, keepAspectRatio) {
            if (keepAspectRatio === undefined) {
                keepAspectRatio = false;
            }
            this.height = height;

            if (keepAspectRatio) {
                this.scaleX = this.scaleY;
            }
            return this;
        }

        setScale(scaleX, scaleY) {
            if (scaleY === undefined) {
                scaleY = scaleX;
            }

            this.scaleX = scaleX;
            this.scaleY = scaleY;
            return this;
        }

        get displayWidth() {
            return this._width * this.scaleX;
        }

        set displayWidth(value) {
            this.scaleX = value / this._width;
        }

        setDisplayWidth(width, keepAspectRatio) {
            if (keepAspectRatio === undefined) {
                keepAspectRatio = false;
            }

            this.displayWidth = width;

            if (keepAspectRatio) {
                this.scaleY = this.scaleX;
            }
            return this;
        }

        get displayHeight() {
            return this._height * this.scaleY;
        }

        set displayHeight(value) {
            this.scaleY = value / this._height;
        }

        setDisplayHeight(height, keepAspectRatio) {
            if (keepAspectRatio === undefined) {
                keepAspectRatio = false;
            }

            this.displayHeight = height;

            if (keepAspectRatio) {
                this.scaleX = this.scaleY;
            }
            return this;
        }

        setOriginX(originX) {
            this.originX = originX;
            this._displayOriginX = this.width * originX;
            return this;
        }

        setOriginY(originY) {
            this.originY = originY;
            this._displayOriginY = this.height * originY;
            return this;
        }

        setOrigin(originX, originY) {
            if (originY === undefined) {
                originY = originX;
            }
            this.setOriginX(originX).setOriginY(originY);
            return this;
        }

        get depth() {
            return this._depth;
        }

        set depth(value) {
            this.setDisplayListDirty(this._depth != value);
            this._depth = value;
        }

        setDepth(depth) {
            if (depth === undefined) {
                depth = 0;
            }

            this.depth = depth;
            return this;
        }

        modifyPorperties(o) {
            if (!o) {
                return this;
            }

            if (o.hasOwnProperty('x')) {
                this.setX(o.x);
            }
            if (o.hasOwnProperty('y')) {
                this.setY(o.y);
            }

            if (o.hasOwnProperty('rotation')) {
                this.setRotation(o.rotation);
            } else if (o.hasOwnProperty('angle')) {
                this.setAngle(o.angle);
            }

            if (o.hasOwnProperty('alpha')) {
                this.setAlpha(o.alpha);
            }

            // ScaleX, ScaleY
            var width = GetValue$3T(o, 'width', undefined);
            var height = GetValue$3T(o, 'height', undefined);
            var scale = GetValue$3T(o, 'scale', undefined);
            var scaleX = GetValue$3T(o, 'scaleX', scale);
            var scaleY = GetValue$3T(o, 'scaleY', scale);

            if (width !== undefined) {
                if ((height === undefined) && (scaleY === undefined)) {
                    this.setWidth(width, true);
                } else {
                    this.setWidth(width);
                }
            } else if (scaleX !== undefined) {
                this.setScaleX(scaleX);
            } else if (o.hasOwnProperty('displayWidth')) {
                this.setDisplayWidth(o.displayWidth);
            }

            if (height !== undefined) {
                if ((width === undefined) && (scaleX === undefined)) {
                    this.setHeight(height, true);
                } else {
                    this.setHeight(height);
                }
            } else if (scaleY !== undefined) {
                this.setScaleY(scaleY);
            } else if (o.hasOwnProperty('displayHeight')) {
                this.setDisplayHeight(o.displayHeight);
            }

            var origin = GetValue$3T(o, 'origin', undefined);
            if (origin !== undefined) {
                this.setOrigin(origin);
            } else {
                if (o.hasOwnProperty('originX')) {
                    this.setOriginX(o.originX);
                }
                if (o.hasOwnProperty('originY')) {
                    this.setOriginY(o.originY);
                }
            }

            if (o.hasOwnProperty('depth')) {
                this.setDepth(o.depth);
            }

            return this;
        }

        reset() {
            super.reset();

            this
                .setVisible()
                .setAlpha(1)
                .setPosition(0, 0)
                .setRotation(0)
                .setScale(1, 1)
                .setOrigin(0)
                .setDepth(0);

            return this;
        }

        // Override
        webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {
        }
        // Override
        canvasRender(ctx, dx, dy, roundPixels) {
        }
    };

    const TransformMatrix$2 = Phaser.GameObjects.Components.TransformMatrix;
    const GetTint$2 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;

    var FrameMatrix = new TransformMatrix$2();

    var WebglRender = function (pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {
        var frame = this.frame;
        if (!frame) {
            return;
        }

        var width = this._width,
            height = this._height;
        var displayOriginX = width * this.originX,
            displayOriginY = height * this.originY;
        var x = this.x - dx,
            y = this.y - dy;

        var u0, v0, u1, v1;
        var frameX, frameY;
        var frameWidth, frameHeight;
        if (this.isCropped) {
            var crop = this._crop;

            if (crop.flipX !== this.flipX || crop.flipY !== this.flipY) {
                frame.updateCropUVs(crop, this.flipX, this.flipY);
            }

            u0 = crop.u0;
            v0 = crop.v0;
            u1 = crop.u1;
            v1 = crop.v1;

            frameWidth = crop.width;
            frameHeight = crop.height;

            frameX = crop.x;
            frameY = crop.y;

        } else {
            u0 = this.frame.u0;
            v0 = this.frame.v0;
            u1 = this.frame.u1;
            v1 = this.frame.v1;

            frameWidth = width;
            frameHeight = height;

            frameX = 0;
            frameY = 0;
        }

        var flipX = 1;
        var flipY = 1;

        if (this.flipX) {
            x += width - (displayOriginX * 2);
            flipX = -1;
        }
        if (this.flipY) {
            y += height - (displayOriginY * 2);
            flipY = -1;
        }

        FrameMatrix.applyITRS(x, y, this.rotation, this.scaleX * flipX, this.scaleY * flipY);
        calcMatrix.multiply(FrameMatrix, FrameMatrix);

        var tx = -displayOriginX + frameX;
        var ty = -displayOriginY + frameY;
        var tw = tx + frameWidth;
        var th = ty + frameHeight;

        var quad = FrameMatrix.setQuad(tx, ty, tw, th, roundPixels);

        var tint = GetTint$2(this.tint, this.alpha * alpha);

        pipeline.batchQuad(
            this.parent,
            quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7],
            u0, v0,
            u1, v1,
            tint, tint, tint, tint,
            this.tintFill,
            texture,
            textureUnit
        );
    };

    var CanvasRender = function (ctx, dx, dy, roundPixels) {
        var frame = this.frame;
        if (!frame) {
            return;
        }

        ctx.save();

        var width = this._width,
            height = this._height;
        var displayOriginX = width * this.originX,
            displayOriginY = height * this.originY;
        var x = this.x - displayOriginX,
            y = this.y - displayOriginY;

        var frameX, frameY;
        var frameWidth, frameHeight;
        if (this.isCropped) {
            var crop = this._crop;

            if (crop.flipX !== this.flipX || crop.flipY !== this.flipY) {
                frame.updateCropUVs(crop, this.flipX, this.flipY);
            }

            frameWidth = crop.cw;
            frameHeight = crop.ch;

            frameX = crop.cx;
            frameY = crop.cy;
        } else {
            frameWidth = frame.cutWidth;
            frameHeight = frame.cutHeight;

            frameX = frame.cutX;
            frameY = frame.cutY;
        }

        var flipX = 1;
        var flipY = 1;

        if (this.flipX) {
            x += width;
            flipX = -1;
        }
        if (this.flipY) {
            y += height;
            flipY = -1;
        }

        var res = frame.source.resolution;
        var fw = frameWidth / res;
        var fh = frameHeight / res;

        if (roundPixels) {
            x = Math.floor(x + 0.5);
            y = Math.floor(y + 0.5);

            fw += 0.5;
            fh += 0.5;
        }

        ctx.translate(x, y);

        ctx.rotate(this.rotation);

        ctx.scale(this.scaleX * flipX, this.scaleY * flipY);

        ctx.drawImage(
            frame.source.image,
            frameX, frameY, frameWidth, frameHeight,
            0, 0, fw, fh,
        );

        ctx.restore();

    };

    const IsPlainObject$T = Phaser.Utils.Objects.IsPlainObject;

    let ImageData$1 = class ImageData extends RenderBase$1 {
        constructor(parent, frame) {
            super(parent, ImageTypeName$1);

            this._crop = ResetCropObject();
            this.setFrame(frame);
        }

        get width() {
            return this._width;
        }

        set width(value) {
        }

        get height() {
            return this._height;
        }

        set height(value) {
        }

        setFrame(frame) {
            if (arguments.length > 0 && !IsPlainObject$T(frame)) {
                frame = this.parent.texture.get(frame);
            }
            this.frame = frame;

            if (frame) {
                this._width = frame.realWidth;
                this._height = frame.realHeight;
            } else {
                this._width = 0;
                this._height = 0;
            }

            return this;
        }

        setFlipX(flipX) {
            if (flipX === undefined) {
                flipX = true;
            }
            this.flipX = flipX;
            return this;
        }

        setFlipY(flipY) {
            if (flipY === undefined) {
                flipY = true;
            }
            this.flipY = flipY;
            return this;
        }

        resetFlip() {
            this.flipX = false;
            this.flipY = false;
            return this;
        }

        get tint() {
            if (this._tint === undefined) {
                return this.parent.tint;
            } else {
                return this._tint;
            }
        }

        set tint(value) {
            this._tint = value;
        }


        setTint(value) {
            this.tint = value;
            this.tintFill = false;
            return this;
        }

        setTintFill(value) {
            this.tint = value;
            this.tintFill = true;
            return this;
        }

        clearTint() {
            this.setTint(0xffffff);
            return this;
        }

        resetTint() {
            this.tint = undefined;
            this.tintFill = undefined;
            return this;
        }

        get tintFill() {
            if (this._tintFill === undefined) {
                return this.parent.tintFill;
            } else {
                return this._tintFill;
            }
        }

        set tintFill(value) {
            this._tintFill = value;
        }

        setCrop(x, y, width, height) {
            if (x === undefined) {
                this.isCropped = false;
                return this;
            }

            if (!this.frame) {
                return this;
            }

            if ((x === 0) && (y === 0) && (width === this._width) && (height === this._height)) {
                this.isCropped = false;
                return this;
            }

            this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
            this.isCropped = true;

            return this;
        }

        reset() {
            super.reset();

            this
                .resetFlip()
                .resetTint()
                .setFrame()
                .setCrop();

            return this;
        }

        modifyPorperties(o) {
            if (!o) {
                return this;
            }

            // Size of Image is equal to frame size,
            // Move width, height properties to displayWidth,displayHeight
            if (o.hasOwnProperty('width')) {
                o.displayWidth = o.width;
                delete o.width;
            }
            if (o.hasOwnProperty('height')) {
                o.displayHeight = o.height;
                delete o.height;
            }

            if (o.hasOwnProperty('frame')) {
                this.setFrame(o.frame);
            }

            super.modifyPorperties(o);

            if (o.hasOwnProperty('flipX')) {
                this.setFlipX(o.flipX);
            }
            if (o.hasOwnProperty('flipY')) {
                this.setFlipY(o.flipY);
            }

            if (o.hasOwnProperty('tint')) {
                this.setTint(o.tint);
            }

            if (o.hasOwnProperty('tintFill')) {
                this.setTintFill(o.tintFill);
            }

            return this;
        }

    };

    var ResetCropObject = function (out) {
        if (out === undefined) {
            out = {};
        }
        out.u0 = 0; out.v0 = 0; out.u1 = 0; out.v1 = 0;
        out.x = 0; out.y = 0; out.width = 0; out.height = 0;
        out.flipX = false; out.flipY = false;
        out.cx = 0; out.cy = 0; out.cw = 0, out.ch = 0;
        return out;
    };

    var methods$J = {
        webglRender: WebglRender,
        canvasRender: CanvasRender,
    };

    Object.assign(
        ImageData$1.prototype,
        methods$J
    );

    var AddImage$2 = function (blitter, config) {
        if (typeof (config) === 'string') {
            config = {
                frame: config
            };
        }

        var bob = (blitter.poolManager) ? blitter.poolManager.allocate(ImageTypeName$1) : null;
        if (bob === null) {
            bob = new ImageData$1(blitter);
        } else {
            bob.setParent(blitter).setActive();
        }
        bob.modifyPorperties(config);

        blitter.addChild(bob);

        return bob;
    };

    var DrawImage$1 = function (key, frame, x, y, width, height) {
        AddImage$2(this, {
            frame: frame,
            x: x,
            y: y,
            width: width,
            height: height
        });
    };

    var DrawTileSprite = function (key, frame, x, y, width, height) {
        var frameObj = this.texture.get(frame);

        var frameWidth = frameObj.width,
            frameHeight = frameObj.height;

        var lastFrameWidth = width % frameWidth,
            lastFrameHeight = height % frameHeight;

        if (lastFrameWidth === 0) {
            lastFrameWidth = frameWidth;
        }
        if (lastFrameHeight === 0) {
            lastFrameHeight = frameHeight;
        }

        var colCount = Math.ceil(width / frameWidth),
            rowCount = Math.ceil(height / frameHeight);
        var lastColCount = colCount - 1,
            lastRowCount = rowCount - 1;

        for (var colIndex = 0; colIndex < colCount; colIndex++) {
            for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
                let bob = AddImage$2(this, {
                    frame: frame,
                    x: x + (colIndex * frameWidth),
                    y: y + (rowIndex * frameHeight),
                });

                var cropWidth = (colIndex === lastColCount) ? lastFrameWidth : frameWidth;
                var cropHeight = (rowIndex === lastRowCount) ? lastFrameHeight : frameHeight;
                if ((cropWidth !== frameWidth) || (cropHeight !== frameHeight)) {
                    bob.setCrop(0, 0, cropWidth, cropHeight);
                }
            }
        }

    };

    var Methods$l = {
        _drawImage: DrawImage$1,
        _drawTileSprite: DrawTileSprite,
    };

    class NinePatch extends NinePatchBase(Blitter, 'rexNinePatch2') {
        setBaseTexture(key, baseFrameName, columns, rows) {
            this.setTexture(key, baseFrameName);
            super.setBaseTexture(key, baseFrameName, columns, rows);
            return this;
        }
    }

    Object.assign(
        NinePatch.prototype,
        Methods$l
    );

    ObjectFactory.register('ninePatch2', function (x, y, width, height, key, columns, rows, config) {
        var gameObject = new NinePatch(this.scene, x, y, width, height, key, columns, rows, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.NinePatch2', NinePatch);

    /*
    src: {
        fillColor, 
        fillAlpha, 
        pathData, 
        pathIndexes  // Earcut(pathData)
    }
    */

    var Utils$3 = Phaser.Renderer.WebGL.Utils;

    var FillPathWebGL = function (pipeline, calcMatrix, src, alpha, dx, dy)
    {
        var fillTintColor = Utils$3.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);

        var path = src.pathData;
        var pathIndexes = src.pathIndexes;

        for (var i = 0; i < pathIndexes.length; i += 3)
        {
            var p0 = pathIndexes[i] * 2;
            var p1 = pathIndexes[i + 1] * 2;
            var p2 = pathIndexes[i + 2] * 2;

            var x0 = path[p0 + 0] - dx;
            var y0 = path[p0 + 1] - dy;
            var x1 = path[p1 + 0] - dx;
            var y1 = path[p1 + 1] - dy;
            var x2 = path[p2 + 0] - dx;
            var y2 = path[p2 + 1] - dy;

            var tx0 = calcMatrix.getX(x0, y0);
            var ty0 = calcMatrix.getY(x0, y0);
            var tx1 = calcMatrix.getX(x1, y1);
            var ty1 = calcMatrix.getY(x1, y1);
            var tx2 = calcMatrix.getX(x2, y2);
            var ty2 = calcMatrix.getY(x2, y2);

            pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
        }
    };

    /*
    src: {
        strokeColor,
        strokeAlpha,
        pathData,
        lineWidth,
        closePath
    }
    */
    var Utils$2 = Phaser.Renderer.WebGL.Utils;

    var StrokePathWebGL = function (pipeline, src, alpha, dx, dy)
    {
        var strokeTint = pipeline.strokeTint;
        var strokeTintColor = Utils$2.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);

        strokeTint.TL = strokeTintColor;
        strokeTint.TR = strokeTintColor;
        strokeTint.BL = strokeTintColor;
        strokeTint.BR = strokeTintColor;

        var path = src.pathData;
        var pathLength = path.length - 1;
        var lineWidth = src.lineWidth;
        var halfLineWidth = lineWidth / 2;

        var px1 = path[0] - dx;
        var py1 = path[1] - dy;

        if (!src.closePath)
        {
            pathLength -= 2;
        }

        for (var i = 2; i < pathLength; i += 2)
        {
            var px2 = path[i] - dx;
            var py2 = path[i + 1] - dy;

            pipeline.batchLine(
                px1,
                py1,
                px2,
                py2,
                halfLineWidth,
                halfLineWidth,
                lineWidth,
                i - 2,
                (src.closePath) ? (i === pathLength - 1) : false
            );

            px1 = px2;
            py1 = py2;
        }
    };

    const GetCalcMatrix$1 = Phaser.GameObjects.GetCalcMatrix;

    var PolygonWebGLRenderer = function (renderer, src, camera, parentMatrix) {    
        if (src.dirty) {
            src.updateData();
            src.dirty = false;
        }

        camera.addToRenderList(src);

        var pipeline = renderer.pipelines.set(src.pipeline);

        var result = GetCalcMatrix$1(src, camera, parentMatrix);

        var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

        var dx = src._displayOriginX;
        var dy = src._displayOriginY;

        var alpha = camera.alpha * src.alpha;

        renderer.pipelines.preBatch(src);

        if (src.isFilled) {
            FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
        }

        if (src.isStroked) {
            StrokePathWebGL(pipeline, src, alpha, dx, dy);
        }

        renderer.pipelines.postBatch(src);
    };

    var FillStyleCanvas = function (ctx, src, altColor, altAlpha)
    {
        var fillColor = (altColor) ? altColor : src.fillColor;
        var fillAlpha = (altAlpha) ? altAlpha : src.fillAlpha;

        var red = ((fillColor & 0xFF0000) >>> 16);
        var green = ((fillColor & 0xFF00) >>> 8);
        var blue = (fillColor & 0xFF);

        ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
    };

    var LineStyleCanvas = function (ctx, src, altColor, altAlpha)
    {
        var strokeColor = (altColor) ? altColor : src.strokeColor;
        var strokeAlpha = (altAlpha) ? altAlpha : src.strokeAlpha;

        var red = ((strokeColor & 0xFF0000) >>> 16);
        var green = ((strokeColor & 0xFF00) >>> 8);
        var blue = (strokeColor & 0xFF);

        ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';
        ctx.lineWidth = src.lineWidth;
    };

    const SetTransform$1 = Phaser.Renderer.Canvas.SetTransform;

    var PolygonCanvasRenderer = function (renderer, src, camera, parentMatrix) {
        if (src.dirty) {
            src.updateData();
            src.dirty = false;
        }

        camera.addToRenderList(src);

        var ctx = renderer.currentContext;

        if (SetTransform$1(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;

            var path = src.pathData;
            var pathLength = path.length - 1;

            var px1 = path[0] - dx;
            var py1 = path[1] - dy;

            ctx.beginPath();

            ctx.moveTo(px1, py1);

            if (!src.closePath) {
                pathLength -= 2;
            }

            for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;

                ctx.lineTo(px2, py2);
            }

            ctx.closePath();

            if (src.isFilled) {
                FillStyleCanvas(ctx, src);

                ctx.fill();
            }

            if (src.isStroked) {
                LineStyleCanvas(ctx, src);

                ctx.stroke();
            }

            //  Restore the context saved in SetTransform
            ctx.restore();
        }
    };

    var Render$3 = {
        renderWebGL: PolygonWebGLRenderer,
        renderCanvas: PolygonCanvasRenderer

    };

    const Shape$1 = Phaser.GameObjects.Shape;

    class PolygnBase extends Shape$1 {
        get fillColor() {
            return this._fillColor;
        }

        set fillColor(value) {
            this._fillColor = value;
            this.isFilled = (value != null) && (this._fillAlpha > 0);
        }

        get fillAlpha() {
            return this._fillAlpha;
        }

        set fillAlpha(value) {
            this._fillAlpha = value;
            this.isFilled = (value > 0) && (this._fillColor != null);
        }

        // Fully override setFillStyle method
        setFillStyle(color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }

            this.fillColor = color;
            this.fillAlpha = alpha;

            return this;
        }

        get strokeColor() {
            return this._strokeColor;
        }

        set strokeColor(value) {
            this._strokeColor = value;
            this.isStroked = (value != null) && (this._strokeAlpha > 0) && (this._lineWidth > 0);
        }

        get strokeAlpha() {
            return this._strokeAlpha;
        }

        set strokeAlpha(value) {
            this._strokeAlpha = value;
            this.isStroked = (value > 0) && (this._strokeColor != null) && (this._lineWidth > 0);
        }

        get lineWidth() {
            return this._lineWidth;
        }

        set lineWidth(value) {
            this._lineWidth = value;
            this.isStroked = (value > 0) && (this._strokeColor != null);
        }

        // Fully override setStrokeStyle method
        setStrokeStyle(lineWidth, color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }

            this.lineWidth = lineWidth;
            this.strokeColor = color;
            this.strokeAlpha = alpha;

            return this;
        }

        updateData() {
            return this;
        }

        get width() {
            return this.geom.width;
        }
        set width(value) {
            this.resize(value, this.height);
        }

        get height() {
            return this.geom.height;
        }
        set height(value) {
            this.resize(this.width, value);
        }

        setSize(width, height) {
            var input = this.input;
            if (input && !input.customHitArea) {
                input.hitArea.width = width;
                input.hitArea.height = height;
            }
            return this;
        }

        resize(width, height) {
            this.setSize(width, height);
            return this;
        }

    }

    Object.assign(
        PolygnBase.prototype,
        Render$3
    );

    const GetValue$3S = Phaser.Utils.Objects.GetValue;

    let RoundRectangle$3 = class RoundRectangle {
        constructor(x, y, width, height, radiusConfig) {
            if (x === undefined) { x = 0; }
            if (y === undefined) { y = x; }
            if (width === undefined) { width = 0; }
            if (height === undefined) { height = 0; }
            if (radiusConfig === undefined) { radiusConfig = 0; }

            this.cornerRadius = {};
            this._width = 0;
            this._height = 0;
            this.setTo(x, y, width, height, radiusConfig);
        }

        setTo(x, y, width, height, radiusConfig) {
            this.setPosition(x, y);
            this.setRadius(radiusConfig);
            this.setSize(width, height);
            return this;
        }

        setPosition(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }

        setRadius(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radius = value;
            return this;
        }

        setSize(width, height) {
            this.width = width;
            this.height = height;
            return this;
        }

        get minWidth() {
            var radius = this.cornerRadius;
            return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
        }

        get minHeight() {
            var radius = this.cornerRadius;
            return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
        }

        get width() {
            return this._width;
        }

        set width(value) {
            if (value == null) {
                value = 0;
            }
            this._width = Math.max(value, this.minWidth);
        }

        get height() {
            return this._height;
        }

        set height(value) {
            if (value == null) {
                value = 0;
            }
            this._height = Math.max(value, this.minHeight);
        }

        get radius() {
            var radius = this.cornerRadius;
            return Math.max(
                radius.tl.x, radius.tl.y,
                radius.tr.x, radius.tr.y,
                radius.bl.x, radius.bl.y,
                radius.br.x, radius.br.y
            );
        }

        set radius(value) {
            var defaultRadiusX, defaultRadiusY;
            if (typeof (value) === 'number') {
                defaultRadiusX = value;
                defaultRadiusY = value;
            } else {
                defaultRadiusX = GetValue$3S(value, 'x', 0);
                defaultRadiusY = GetValue$3S(value, 'y', 0);
            }

            var radius = this.cornerRadius;
            radius.tl = GetRadius(GetValue$3S(value, 'tl', undefined), defaultRadiusX, defaultRadiusY);
            radius.tr = GetRadius(GetValue$3S(value, 'tr', undefined), defaultRadiusX, defaultRadiusY);
            radius.bl = GetRadius(GetValue$3S(value, 'bl', undefined), defaultRadiusX, defaultRadiusY);
            radius.br = GetRadius(GetValue$3S(value, 'br', undefined), defaultRadiusX, defaultRadiusY);
        }

        get radiusTL() {
            var radius = this.cornerRadius.tl;
            return Math.max(radius.x, radius.y);
        }

        set radiusTL(value) {
            SetRadius(this.cornerRadius.tl, value);
        }

        get radiusTR() {
            var radius = this.cornerRadius.tr;
            return Math.max(radius.x, radius.y);
        }

        set radiusTR(value) {
            SetRadius(this.cornerRadius.tr, value);
        }

        get radiusBL() {
            var radius = this.cornerRadius.bl;
            return Math.max(radius.x, radius.y);
        }

        set radiusBL(value) {
            SetRadius(this.cornerRadius.bl, value);
        }

        get radiusBR() {
            var radius = this.cornerRadius.br;
            return Math.max(radius.x, radius.y);
        }

        set radiusBR(value) {
            SetRadius(this.cornerRadius.br, value);
        }
    };

    var GetRadius = function (radius, defaultRadiusX, defaultRadiusY) {
        if (radius === undefined) {
            radius = {
                x: defaultRadiusX,
                y: defaultRadiusY
            };
        } else if (typeof (radius) === 'number') {
            radius = {
                x: radius,
                y: radius
            };
        }

        SetConvex(radius);
        return radius;

    };

    var SetRadius = function (radius, value) {
        if (typeof (value) === 'number') {
            radius.x = value;
            radius.y = value;
        } else {
            radius.x = GetValue$3S(value, 'x', 0);
            radius.y = GetValue$3S(value, 'y', 0);
        }

        SetConvex(radius);
    };

    var SetConvex = function (radius) {
        radius.convex = (radius.x >= 0) || (radius.y >= 0);

        radius.x = Math.abs(radius.x);
        radius.y = Math.abs(radius.y);
    };

    var IsArcCorner$1 = function (radius) {
        return ((radius.x > 0) && (radius.y > 0));
    };

    var LineTo = function (x, y, pathData) {
        var cnt = pathData.length;
        if (cnt >= 2) {
            var lastX = pathData[cnt - 2];
            var lastY = pathData[cnt - 1];
            if ((x === lastX) && (y === lastY)) {
                return pathData;
            }
        }

        pathData.push(x, y);
        return pathData;
    };

    const DegToRad$i = Phaser.Math.DegToRad;

    var ArcTo$1 = function (centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, pathData) {
        // startAngle, endAngle: 0 ~ 360
        if (antiClockWise && (endAngle > startAngle)) {
            endAngle -= 360;
        } else if (!antiClockWise && (endAngle < startAngle)) {
            endAngle += 360;
        }

        var deltaAngle = endAngle - startAngle;
        var step = DegToRad$i(deltaAngle) / iteration;
        startAngle = DegToRad$i(startAngle);
        for (var i = 0; i <= iteration; i++) {
            var angle = startAngle + (step * i);
            var x = centerX + (radiusX * Math.cos(angle));
            var y = centerY + (radiusY * Math.sin(angle));
            LineTo(x, y, pathData);
        }
        return pathData;
    };

    const IsPlainObject$S = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3R = Phaser.Utils.Objects.GetValue;
    const Earcut$2 = Phaser.Geom.Polygon.Earcut;

    let RoundRectangle$2 = class RoundRectangle extends PolygnBase {
        constructor(scene, x, y, width, height, radiusConfig, fillColor, fillAlpha) {
            var strokeColor, strokeAlpha, strokeWidth, shapeType;
            if (IsPlainObject$S(x)) {
                var config = x;

                x = config.x;
                y = config.y;
                width = config.width;
                height = config.height;
                radiusConfig = config.radius;
                fillColor = config.color;
                fillAlpha = config.alpha;

                strokeColor = config.strokeColor;
                strokeAlpha = config.strokeAlpha;
                strokeWidth = config.strokeWidth;

                shapeType = config.shape;
            }

            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 1; }
            if (height === undefined) { height = width; }
            if (radiusConfig === undefined) { radiusConfig = 0; }
            if (shapeType === undefined) { shapeType = 0; }

            var geom = new RoundRectangle$3();  // Configurate it later
            super(scene, 'rexRoundRectangleShape', geom);

            this.setShapeType(shapeType);

            if (this.shapeType === 0) {
                var radius = GetValue$3R(radiusConfig, 'radius', radiusConfig);
                geom.setTo(0, 0, width, height, radius);
            } else {
                var radius = { x: (width / 2), y: (height / 2) };
                geom.setTo(0, 0, width, height, radius);
            }

            this.setIteration(GetValue$3R(radiusConfig, 'iteration', undefined));
            this.setPosition(x, y);

            this.setFillStyle(fillColor, fillAlpha);

            if (strokeWidth === undefined) {
                strokeWidth = 2;
            }
            this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);

            this.updateDisplayOrigin();
            this.dirty = true;
        }

        updateData() {
            var geom = this.geom;
            var pathData = this.pathData;

            pathData.length = 0;

            var width = geom.width,
                height = geom.height,
                cornerRadius = geom.cornerRadius,
                radius,
                iteration = this.iteration + 1;

            // Top-left
            radius = cornerRadius.tl;
            if (IsArcCorner$1(radius)) {
                if (radius.convex) {
                    var centerX = radius.x;
                    var centerY = radius.y;
                    ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 270, false, iteration, pathData);
                } else {
                    var centerX = 0;
                    var centerY = 0;
                    ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 0, true, iteration, pathData);
                }
            } else {
                LineTo(0, 0, pathData);
            }

            // Top-right
            radius = cornerRadius.tr;
            if (IsArcCorner$1(radius)) {
                if (radius.convex) {
                    var centerX = width - radius.x;
                    var centerY = radius.y;
                    ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 360, false, iteration, pathData);
                } else {
                    var centerX = width;
                    var centerY = 0;
                    ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 90, true, iteration, pathData);
                }
            } else {
                LineTo(width, 0, pathData);
            }

            // Bottom-right
            radius = cornerRadius.br;
            if (IsArcCorner$1(radius)) {
                if (radius.convex) {
                    var centerX = width - radius.x;
                    var centerY = height - radius.y;
                    ArcTo$1(centerX, centerY, radius.x, radius.y, 0, 90, false, iteration, pathData);
                } else {
                    var centerX = width;
                    var centerY = height;
                    ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 180, true, iteration, pathData);
                }
            } else {
                LineTo(width, height, pathData);
            }

            // Bottom-left
            radius = cornerRadius.bl;
            if (IsArcCorner$1(radius)) {
                if (radius.convex) {
                    var centerX = radius.x;
                    var centerY = height - radius.y;
                    ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 180, false, iteration, pathData);
                } else {
                    var centerX = 0;
                    var centerY = height;
                    ArcTo$1(centerX, centerY, radius.x, radius.y, 360, 270, true, iteration, pathData);
                }
            } else {
                LineTo(0, height, pathData);
            }

            pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
            this.pathIndexes = Earcut$2(pathData);
            return this;
        }

        setShapeType(shapeType) {
            if (typeof (shapeType) === 'string') {
                shapeType = ShapeTypeMap[shapeType];
            }

            this.shapeType = shapeType;
            return this;
        }

        setSize(width, height) {
            // Override Shape's setSize method
            if (height === undefined) {
                height = width;
            }
            if ((this.geom.width === width) && (this.geom.height === height)) {
                return this;
            }
            this.geom.setSize(width, height);

            if (this.shapeType === 1) {
                this.setRadius({ x: (width / 2), y: (height / 2) });
            }

            this.updateDisplayOrigin();
            this.dirty = true;

            super.setSize(width, height);
            return this;
        }

        get radius() {
            return this.geom.radius;
        }

        set radius(value) {
            this.geom.setRadius(value);
            this.updateDisplayOrigin();
            this.dirty = true;
        }

        get radiusTL() {
            return this.geom.radiusTL;
        }

        set radiusTL(value) {
            this.geom.radiusTL = value;
            this.dirty = true;
        }

        get radiusTR() {
            return this.geom.radiusTR;
        }

        set radiusTR(value) {
            this.geom.radiusTR = value;
            this.dirty = true;
        }

        get radiusBL() {
            return this.geom.radiusBL;
        }

        set radiusBL(value) {
            this.geom.radiusBL = value;
            this.dirty = true;
        }

        get radiusBR() {
            return this.geom.radiusBR;
        }

        set radiusBR(value) {
            this.geom.radiusBR = value;
            this.dirty = true;
        }

        setRadius(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radius = value;
            return this;
        }

        setRadiusTL(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radiusTL = value;
            return this;
        }

        setRadiusTR(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radiusTR = value;
            return this;
        }

        setRadiusBL(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radiusBL = value;
            return this;
        }

        setRadiusBR(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radiusBR = value;
            return this;
        }

        get cornerRadius() {
            return this.geom.cornerRadius;
        }

        set cornerRadius(value) {
            this.radius = value;
        }

        setCornerRadius(value) {
            return this.setRadius(value);
        }

        get iteration() {
            return this._iteration;
        }

        set iteration(value) {
            // Set iteration first time
            if (this._iteration === undefined) {
                this._iteration = value;
                return;
            }

            // Change iteration value
            if (this._iteration === value) {
                return;
            }

            this._iteration = value;
            this.dirty = true;
        }

        setIteration(iteration) {
            if (iteration === undefined) {
                iteration = 6;
            }
            this.iteration = iteration;
            return this;
        }

    };

    const ShapeTypeMap = {
        rectangle: 0,
        circle: 1
    };

    ObjectFactory.register('roundRectangle', function (x, y, width, height, radiusConfig, fillColor, fillAlpha) {
        var gameObject = new RoundRectangle$2(this.scene, x, y, width, height, radiusConfig, fillColor, fillAlpha);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.RoundRectangle', RoundRectangle$2);

    // copy from Phaser.GameObjects.Text

    const Utils$1 = Phaser.Renderer.WebGL.Utils;

    var WebGLRenderer$2 = function (renderer, src, camera, parentMatrix) {
        if (src.dirty) {
            src.updateTexture();
            src.dirty = false;
        }

        if ((src.width === 0) || (src.height === 0)) {
            return;
        }

        camera.addToRenderList(src);

        var frame = src.frame;
        var width = frame.width;
        var height = frame.height;
        var getTint = Utils$1.getTintAppendFloatAlpha;
        var pipeline = renderer.pipelines.set(src.pipeline, src);
        var textureUnit = pipeline.setTexture2D(frame.glTexture, src);

        renderer.pipelines.preBatch(src);

        pipeline.batchTexture(
            src,
            frame.glTexture,
            width, height,
            src.x, src.y,
            width / src.resolution, height / src.resolution,
            src.scaleX, src.scaleY,
            src.rotation,
            src.flipX, src.flipY,
            src.scrollFactorX, src.scrollFactorY,
            src.displayOriginX, src.displayOriginY,
            0, 0, width, height,
            getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
            getTint(src.tintTopRight, camera.alpha * src._alphaTR),
            getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
            getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
            src.tintFill,
            0, 0,
            camera,
            parentMatrix,
            false,
            textureUnit
        );

        renderer.pipelines.postBatch(src);
    };

    // copy from Phaser.GameObjects.Text

    var CanvasRenderer$2 = function (renderer, src, camera, parentMatrix) {
        if (src.dirty) {
            src.updateTexture();
            src.dirty = false;
        }

        if ((src.width === 0) || (src.height === 0)) {
            return;
        }

        camera.addToRenderList(src);

        renderer.batchSprite(src, src.frame, camera, parentMatrix);
    };

    var Render$2 = {
        renderWebGL: WebGLRenderer$2,
        renderCanvas: CanvasRenderer$2

    };

    const Color$4 = Phaser.Display.Color;

    var CanvasMethods = {
        clear() {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.dirty = true;
            return this;
        },

        fill(color) {
            this.context.fillStyle = color;
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.dirty = true;
            return this;
        },

        drawFrame(key, frame, dx, dy, dWidth, dHeight, sxOffset, syOffset, sWidth, sHeight) {

            var textureFrame = this.scene.sys.textures.getFrame(key, frame);
            if (!textureFrame) {
                return this;
            }

            var frameWidth = textureFrame.cutWidth,
                frameHeight = textureFrame.cutHeight;

            if (dx === undefined) { dx = 0; }
            if (dy === undefined) { dy = 0; }
            if (dWidth === undefined) { dWidth = frameWidth; }
            if (dHeight === undefined) { dHeight = frameHeight; }
            if (sxOffset === undefined) { sxOffset = 0; }
            if (syOffset === undefined) { syOffset = 0; }
            if (sWidth === undefined) { sWidth = frameWidth; }
            if (sHeight === undefined) { sHeight = frameHeight; }

            var sx = textureFrame.cutX + sxOffset;
            var sy = textureFrame.cutY + syOffset;

            this.context.drawImage(
                textureFrame.source.image,  // image
                sx, sy, sWidth, sHeight,
                dx, dy, dWidth, dHeight
            );

            this.dirty = true;

            return this;
        },

        getDataURL(type, encoderOptions) {
            return this.canvas.toDataURL(type, encoderOptions);
        },

        getPixel(x, y, out) {
            if (out === undefined) {
                out = new Color$4();
            }
            var rgb = this.context.getImageData(x, y, 1, 1);
            out.setTo(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
            return out;
        },

        setPixel(x, y, r, g, b, a) {
            if (typeof (r) !== 'number') {
                var color = r;
                r = color.red;
                g = color.green;
                b = color.blue;
                a = color.alpha;
            }

            if (a === undefined) {
                a = ((r !== 0) || (g !== 0) || (b !== 0)) ? 255 : 0;
            }

            var imgData = this.context.createImageData(1, 1);
            imgData.data[0] = r;
            imgData.data[1] = g;
            imgData.data[2] = b;
            imgData.data[3] = a;
            this.context.putImageData(imgData, x, y);
            this.dirty = true;
            return this;
        }
    };

    var CopyCanvasToTexture = function (scene, srcCanvas, key, x, y, width, height) {
        var textures = scene.sys.textures;
        var renderer = scene.renderer;

        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        if (width === undefined) {
            width = srcCanvas.width;
        }
        if (height === undefined) {
            height = srcCanvas.height;
        }

        var texture;
        if (textures.exists(key)) {
            texture = textures.get(key);
        } else {
            texture = textures.createCanvas(key, width, height);
        }

        var destCanvas = texture.getSourceImage();
        if (destCanvas.width !== width) {
            destCanvas.width = width;
        }
        if (destCanvas.height !== height) {
            destCanvas.height = height;
        }

        var destCtx = destCanvas.getContext('2d', { willReadFrequently: true });
        destCtx.clearRect(0, 0, width, height);
        destCtx.drawImage(srcCanvas, x, y, width, height);
        if (renderer.gl && texture) {
            renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);
        }
    };

    var TextureMethods = {
        updateTexture(callback, scope) {
            if (callback) {
                var scale = this.resolution;
                if (scale !== 1) {
                    this.context.save();
                    this.context.scale(scale, scale);
                }

                if (scope) {
                    callback.call(scope, this.canvas, this.context);
                } else {
                    callback(this.canvas, this.context);
                }

                if (scale !== 1) {
                    this.context.restore();
                }
            }

            if ((this.canvas.width !== this.frame.width) || (this.canvas.height !== this.frame.height)) {
                this.frame.setSize(this.canvas.width, this.canvas.height);
            }
            if (this.renderer && this.renderer.gl) {
                this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);
                if (typeof WEBGL_DEBUG) {
                    this.frame.glTexture.spectorMetadata = { textureKey: 'Canvas Game Object' };
                }
            }
            this.dirty = false;

            var input = this.input;
            if (input && !input.customHitArea) {
                input.hitArea.width = this.width;
                input.hitArea.height = this.height;
            }
            return this;
        },

        generateTexture(key, x, y, width, height) {
            var srcCanvas = this.canvas;
            if (width === undefined) {
                width = srcCanvas.width;
            } else {
                width *= this.resolution;
            }
            if (height === undefined) {
                height = srcCanvas.height;
            } else {
                height *= this.resolution;
            }

            CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);

            return this;
        },

        loadTexture(key, frame) {
            var textureFrame = this.scene.sys.textures.getFrame(key, frame);
            if (!textureFrame) {
                return this;
            }

            if ((this.width !== textureFrame.cutWidth) || (this.height !== textureFrame.cutHeight)) {
                this.setSize(textureFrame.cutWidth, textureFrame.cutHeight);
            } else {
                this.clear();
            }

            this.drawFrame(key, frame);
            this.dirty = true;
            return this;
        }

    };

    CheckP3Version();

    const CanvasPool$4 = Phaser.Display.Canvas.CanvasPool;
    const GameObject$3 = Phaser.GameObjects.GameObject;
    const UUID$5 = Phaser.Utils.String.UUID;

    let Canvas$1 = class Canvas extends GameObject$3 {
        constructor(scene, x, y, width, height, resolution) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (width === undefined) {
                width = 1;
            }
            if (height === undefined) {
                height = 1;
            }
            if (resolution === undefined) {
                resolution = 1;
            }

            super(scene, 'rexCanvas');

            this.renderer = scene.sys.game.renderer;

            this._width = width;
            this._height = height;
            this.resolution = resolution;

            width = Math.max(Math.ceil(width * this.resolution), 1);
            height = Math.max(Math.ceil(height * this.resolution), 1);
            this.canvas = CanvasPool$4.create(this, width, height);
            this.context = this.canvas.getContext('2d', { willReadFrequently: true });

            this.dirty = false;

            this.setPosition(x, y);
            this.setOrigin(0.5, 0.5);
            this.initPipeline();
            this.initPostPipeline(true);

            this._crop = this.resetCropObject();

            //  Create a Texture for this Text object
            this._textureKey = UUID$5();

            this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);

            //  Get the frame
            this.frame = this.texture.get();

            //  Set the resolution
            this.frame.source.resolution = this.resolution;

            if (this.renderer && this.renderer.gl) {
                //  Clear the default 1x1 glTexture, as we override it later
                this.renderer.deleteTexture(this.frame.source.glTexture);
                this.frame.source.glTexture = null;
            }

            this.dirty = true;
        }

        preDestroy() {
            CanvasPool$4.remove(this.canvas);

            this.canvas = null;
            this.context = null;

            var texture = this.texture;

            if (texture) {
                texture.destroy();
            }
        }

        setResolution(resolution) {
            if (this.resolution === resolution) {
                return this;
            }

            this.resolution = resolution;

            var width = Math.max(Math.ceil(this.width * resolution), 1);
            var height = Math.max(Math.ceil(this.height * resolution), 1);
            this.canvas.width = width;
            this.canvas.height = height;

            this.frame.source.resolution = resolution;
            this.dirty = true;

            return this;
        }

        get width() {
            return this._width;
        }

        set width(value) {
            this.setSize(value, this._height);
        }

        get height() {
            return this._height;
        }

        set height(value) {
            this.setSize(this._width, value);
        }

        setCanvasSize(width, height) {
            if ((this._width === width) && (this._height === height)) {
                return this;
            }

            this._width = width;
            this._height = height;

            this.updateDisplayOrigin();

            width = Math.max(Math.ceil(width * this.resolution), 1);
            height = Math.max(Math.ceil(height * this.resolution), 1);
            this.canvas.width = width;
            this.canvas.height = height;

            this.frame.setSize(width, height);

            this.dirty = true;
            return this;
        }

        // setSize might be override
        setSize(width, height) {
            this.setCanvasSize(width, height);
            return this;
        }

        get displayWidth() {
            return this.scaleX * this._width;
        }

        set displayWidth(value) {
            this.scaleX = value / this._width;
        }

        get displayHeight() {
            return this.scaleY * this._height;
        }

        set displayHeight(value) {
            this.scaleY = value / this._height;
        }

        setDisplaySize(width, height) {
            this.displayWidth = width;
            this.displayHeight = height;
            return this;
        }

        getCanvas(readOnly) {
            if (!readOnly) {
                this.dirty = true;
            }
            return this.canvas;
        }

        getContext(readOnly) {
            if (!readOnly) {
                this.dirty = true;
            }
            return this.context;
        }

        needRedraw() {
            this.dirty = true;
            return this;
        }

        resize(width, height) {
            this.setSize(width, height);
            return this;
        }
    };

    const Components$3 = Phaser.GameObjects.Components;
    Phaser.Class.mixin(Canvas$1,
        [
            Components$3.Alpha,
            Components$3.BlendMode,
            Components$3.Crop,
            Components$3.Depth,
            Components$3.Flip,
            Components$3.GetBounds,
            Components$3.Mask,
            Components$3.Origin,
            Components$3.Pipeline,
            Components$3.PostPipeline,
            Components$3.ScrollFactor,
            Components$3.Tint,
            Components$3.Transform,
            Components$3.Visible,
            Render$2,
            CanvasMethods,
            TextureMethods,
        ]
    );

    const Pad$1 = Phaser.Utils.String.Pad;
    var GetStyle = function (style, canvas, context) {
        if (style == null) {
            return style;
        }

        switch (typeof (style)) {
            case 'string': return style;
            case 'number': return `#${Pad$1(Math.floor(style).toString(16), 6, '0', 1)}`;
            case 'function': return style(canvas, context);
            case 'object':
                if (style.hasOwnProperty('r')) {
                    if (style.hasOwnProperty('a')) {  // rgba
                        return `rgba(${style.r},${style.g},${style.b},${style.a})`;
                    } else {  // rgb
                        return `rgb(${style.r},${style.g},${style.b})`;
                    }
                } else if (style.hasOwnProperty('h')) {
                    if (style.hasOwnProperty('a')) {  // hsla
                        return `hsla(${style.h},${style.s},${style.l},${style.a})`;
                    } else {  // hsl
                        return `hsl(${style.h},${style.s},${style.l})`;
                    }
                } else {
                    return style; // Not a valid input
                }
            default: return style;
        }
    };

    const DegToRad$h = Phaser.Math.DegToRad;

    var AddRoundRectanglePath = function (context, x, y, width, height, radiusConfig, iteration) {
        var geom = new RoundRectangle$3(x, y, width, height, radiusConfig),
            minWidth = geom.minWidth,
            minHeight = geom.minHeight,
            scaleRX = (width >= minWidth) ? 1 : (width / minWidth),
            scaleRY = (height >= minHeight) ? 1 : (height / minHeight);

        var cornerRadius = geom.cornerRadius;
        var radius, radiusX, radiusY, centerX, centerY;
        var startX, startY;

        context.save();
        context.beginPath();

        context.translate(x, y);

        // Top-left
        radius = cornerRadius.tl;
        if (IsArcCorner(radius)) {
            radiusX = radius.x * scaleRX;
            radiusY = radius.y * scaleRY;
            if (IsConvexArc(radius)) {
                centerX = radiusX;
                centerY = radiusY;
                ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 270, false, iteration);
            } else {
                centerX = 0;
                centerY = 0;
                ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 0, true, iteration);
            }

            startX = 0;
            startY = radiusY;
        } else {
            context.lineTo(0, 0);

            startX = 0;
            startY = 0;
        }

        // Top-right
        radius = cornerRadius.tr;
        if (IsArcCorner(radius)) {
            radiusX = radius.x * scaleRX;
            radiusY = radius.y * scaleRY;
            if (IsConvexArc(radius)) {
                centerX = width - radiusX;
                centerY = radiusY;
                ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 360, false, iteration);
            } else {
                centerX = width;
                centerY = 0;
                ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 90, true, iteration);
            }
        } else {
            context.lineTo(width, 0);
        }

        // Bottom-right
        radius = cornerRadius.br;
        if (IsArcCorner(radius)) {
            radiusX = radius.x * scaleRX;
            radiusY = radius.y * scaleRY;
            if (IsConvexArc(radius)) {
                centerX = width - radiusX;
                centerY = height - radiusY;
                ArcTo(context, centerX, centerY, radiusX, radiusY, 0, 90, false, iteration);
            } else {
                centerX = width;
                centerY = height;
                ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 180, true, iteration);
            }
        } else {
            context.lineTo(width, height);
        }

        // Bottom-left
        radius = cornerRadius.bl;
        if (IsArcCorner(radius)) {
            radiusX = radius.x * scaleRX;
            radiusY = radius.y * scaleRY;
            if (IsConvexArc(radius)) {
                centerX = radiusX;
                centerY = height - radiusY;
                ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 180, false, iteration);
            } else {
                centerX = 0;
                centerY = height;
                ArcTo(context, centerX, centerY, radiusX, radiusY, 360, 270, true, iteration);
            }
        } else {
            context.lineTo(0, height);
        }

        context.lineTo(startX, startY);
        context.closePath();
        context.restore();
    };

    var IsConvexArc = function (radius) {
        return (!radius.hasOwnProperty('convex')) ||  // radius does not have convex property
            radius.convex;
    };

    var IsArcCorner = function (radius) {
        return ((radius.x > 0) && (radius.y > 0));
    };

    var ArcTo = function (
        context,
        centerX, centerY,
        radiusX, radiusY,
        startAngle, endAngle,
        antiClockWise,
        iteration
    ) {

        // startAngle, endAngle: 0 ~ 360
        if (antiClockWise && (endAngle > startAngle)) {
            endAngle -= 360;
        } else if (!antiClockWise && (endAngle < startAngle)) {
            endAngle += 360;
        }

        startAngle = DegToRad$h(startAngle);
        endAngle = DegToRad$h(endAngle);

        if (iteration == null) {  // undefined, or null
            context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle, antiClockWise);
        } else {
            iteration += 1;
            var x, y, angle;
            var step = (endAngle - startAngle) / iteration;
            for (var i = 0; i <= iteration; i++) {
                angle = startAngle + (step * i);
                x = centerX + (radiusX * Math.cos(angle));
                y = centerY + (radiusY * Math.sin(angle));
                context.lineTo(x, y);
            }
        }
    };

    var DrawRoundRectangle = function (
        canvas, context,
        x, y,
        width, height, radiusConfig,
        fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient,
        iteration
    ) {

        AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration);

        if (fillStyle != null) {
            if (fillColor2 != null) {
                var grd;
                if (isHorizontalGradient) {
                    grd = context.createLinearGradient(0, 0, width, 0);
                } else {
                    grd = context.createLinearGradient(0, 0, 0, height);
                }
                grd.addColorStop(0, fillStyle);
                grd.addColorStop(1, fillColor2);
                fillStyle = grd;
            }

            context.fillStyle = fillStyle;
            context.fill();
        }

        if ((strokeStyle != null) && (lineWidth > 0)) {
            context.strokeStyle = strokeStyle;
            context.lineWidth = lineWidth;
            context.stroke();
        }
    };

    var DrawRoundRectangleBackground = function (
        canvasObject,
        color,
        strokeColor, strokeLineWidth,
        radius,
        color2, isHorizontalGradient,
        iteration
    ) {

        if ((color == null) && (strokeColor == null)) {
            return;
        }

        var width = canvasObject.canvas.width,
            height = canvasObject.canvas.height;

        if (strokeColor == null) {
            strokeLineWidth = 0;
        }
        var x = strokeLineWidth / 2;
        width = Math.max(1, width - strokeLineWidth);   // Min width is 1
        height = Math.max(1, height - strokeLineWidth); // Min height is 1
        DrawRoundRectangle(canvasObject.canvas, canvasObject.context,
            x, x,
            width, height,
            radius,
            color,
            strokeColor, strokeLineWidth,
            color2, isHorizontalGradient,
            iteration
        );
    };

    var DrawContent$2 = function () {
        DrawRoundRectangleBackground(
            this,
            this.fillStyle,
            this.strokeStyle,
            this.lineWidth,
            this.radius,
            this.fillColor2,
            this.isHorizontalGradient,
            this.iteration
        );
    };

    const GetValue$3Q = Phaser.Utils.Objects.GetValue;

    let RoundRectangle$1 = class RoundRectangle extends Canvas$1 {
        constructor(
            scene,
            x, y, width, height,
            radiusConfig,
            fillStyle, strokeStyle, lineWidth,
            fillColor2, isHorizontalGradient,
            resolution
        ) {

            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 1; }
            if (height === undefined) { height = width; }
            if (radiusConfig === undefined) { radiusConfig = 0; }
            if (resolution === undefined) { resolution = 1; }

            super(scene, x, y, width, height, resolution);
            this.type = 'rexRoundRectangleCanvas';

            var radius = GetValue$3Q(radiusConfig, 'radius', radiusConfig);
            var iteration = GetValue$3Q(radiusConfig, 'iteration', undefined);
            this.setRadius(radius);
            this.setIteration(iteration);
            this.setFillStyle(fillStyle, fillColor2, isHorizontalGradient);
            this.setStrokeStyle(strokeStyle, lineWidth);
        }

        get radius() {
            return this._radius;
        }

        set radius(value) {
            this.dirty |= (this._radius != value);
            this._radius = value;
        }

        setRadius(radius) {
            this.radius = radius;
            return this;
        }

        get iteration() {
            return this._iteration;
        }

        set iteration(value) {
            this.dirty |= (this._iteration != value);
            this._iteration = value;
        }

        setIteration(iteration) {
            this.iteration = iteration;
            return this;
        }

        get fillStyle() {
            return this._fillStyle;
        }

        set fillStyle(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty |= (this._fillStyle != value);
            this._fillStyle = value;
        }

        get fillColor2() {
            return this._fillColor2;
        }

        set fillColor2(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty |= (this._fillColor2 != value);
            this._fillColor2 = value;
        }

        get isHorizontalGradient() {
            return this._isHorizontalGradient;
        }

        set isHorizontalGradient(value) {
            this.dirty |= (this._isHorizontalGradient != value);
            this._isHorizontalGradient = value;
        }

        setFillStyle(fillStyle, fillColor2, isHorizontalGradient) {
            if (isHorizontalGradient === undefined) {
                isHorizontalGradient = true;
            }
            this.fillStyle = fillStyle;
            this.fillColor2 = fillColor2;
            this.isHorizontalGradient = isHorizontalGradient;
            return this;
        }

        get strokeStyle() {
            return this._strokeStyle;
        }

        set strokeStyle(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty |= (this._strokeStyle != value);
            this._strokeStyle = value;
        }

        get lineWidth() {
            return this._lineWidth;
        }

        set lineWidth(value) {
            this.dirty |= (this._lineWidth != value);
            this._lineWidth = value;
        }

        setStrokeStyle(strokeStyle, lineWidth) {
            this.strokeStyle = strokeStyle;
            this.lineWidth = lineWidth;
            return this;
        }

        updateTexture() {
            super.updateTexture(function () {
                this.clear();
                DrawContent$2.call(this);
            }, this);
            return this;
        }
    };

    ObjectFactory.register('roundRectangleCanvas', function (x, y, width, height, radius, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient) {
        var gameObject = new RoundRectangle$1(this.scene, x, y, width, height, radius, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.RoundRectangleCanvas', RoundRectangle$1);

    var HasProperty = function (obj, prop) {
        if (!obj) {
            return false;
        }

        if (obj.hasOwnProperty(prop)) {
            return true;
        }

        while (obj) {
            if (Object.getOwnPropertyDescriptor(obj, prop)) {
                return true;
            }
            obj = obj.__proto__;
        }

        return false;
    };

    var InjectPointAccessProperties = function (gameObject, key, point) {
        if (!key || HasProperty(gameObject, `${key}X`)) {
            return;
        }
        Object.defineProperty(gameObject, `${key}X`, {
            get: function () {
                return point.x;
            },
            set: function (value) {
                point.x = value;
                gameObject.dirty = true;
            },
        });
        Object.defineProperty(gameObject, `${key}Y`, {
            get: function () {
                return point.y;
            },
            set: function (value) {
                point.y = value;
                gameObject.dirty = true;
            },
        });
        Object.defineProperty(gameObject, `${key}T`, {
            get: function () {
                return point.t;
            },
            set: function (value) {
                point.t = value;
                gameObject.dirty = true;
            },
        });
    };

    var PointMethods = {
        setTLPosition(x, y) {
            this.geom.setTLPosition(x, y);
            this.dirty = true;
            return this;
        },

        setTRPosition(x, y) {
            this.geom.setTRPosition(x, y);
            this.dirty = true;
            return this;
        },

        setBLPosition(x, y) {
            this.geom.setBLPosition(x, y);
            this.dirty = true;
            return this;
        },

        setBRPosition(x, y) {
            this.geom.setBRPosition(x, y);
            this.dirty = true;
            return this;
        },

        resetCornerPosition() {
            this.geom.resetCornerPosition();
            this.dirty = true;
            return this;
        },

        insertTopSidePoint(t, x, y, key) {
            var points = this.geom.topSidePoints;
            if (Array.isArray(t)) {
                var points = t, point;
                for (var i = 0, cnt = points.length; i < cnt; i++) {
                    point = points[i];
                    this.geom.insertTopSidePoint(point.t, point.x, point.y);
                    InjectPointAccessProperties(this, point.key, points[points.length - 1]);
                }
            } else {
                this.geom.insertTopSidePoint(t, x, y);
                InjectPointAccessProperties(this, key, points[points.length - 1]);
            }
            this.dirty = true;
            return this;
        },

        insertRightSidePoint(t, x, y, key) {
            var points = this.geom.rightSidePoints;
            if (Array.isArray(t)) {
                var points = t, point;
                for (var i = 0, cnt = points.length; i < cnt; i++) {
                    point = points[i];
                    this.geom.insertRightSidePoint(point.t, point.x, point.y);
                    InjectPointAccessProperties(this, point.key, points[points.length - 1]);
                }
            } else {
                this.geom.insertRightSidePoint(t, x, y);
                InjectPointAccessProperties(this, key, points[points.length - 1]);
            }
            this.dirty = true;
            return this;
        },

        insertBottomSidePoint(t, x, y, key) {
            var points = this.geom.bottomSidePoints;
            if (Array.isArray(t)) {
                var points = t, point;
                for (var i = 0, cnt = points.length; i < cnt; i++) {
                    point = points[i];
                    this.geom.insertBottomSidePoint(point.t, point.x, point.y);
                    InjectPointAccessProperties(this, point.key, points[points.length - 1]);
                }
            } else {
                this.geom.insertBottomSidePoint(t, x, y);
                InjectPointAccessProperties(this, key, points[points.length - 1]);
            }
            this.dirty = true;
            return this;
        },

        insertLeftSidePoint(t, x, y, key) {
            var points = this.geom.leftSidePoints;
            if (Array.isArray(t)) {
                var points = t, point;
                for (var i = 0, cnt = points.length; i < cnt; i++) {
                    point = points[i];
                    this.geom.insertLeftSidePoint(point.t, point.x, point.y);
                    InjectPointAccessProperties(this, point.key, points[points.length - 1]);
                }
            } else {
                this.geom.insertLeftSidePoint(t, x, y);
                InjectPointAccessProperties(this, key, points[points.length - 1]);
            }
            this.dirty = true;
            return this;
        },

        clearTopSidePoints() {
            this.geom.clearTopSidePoints();
            this.dirty = true;
            return this;
        },

        clearRightSidePoints() {
            this.geom.clearRightSidePoints();
            this.dirty = true;
            return this;
        },

        clearBottomSidePoints() {
            this.geom.clearBottomSidePoints();
            this.dirty = true;
            return this;
        },

        clearLeftSidePoints() {
            this.geom.clearLeftSidePoints();
            this.dirty = true;
            return this;
        },

        clearAllSidesPoints() {
            this.geom.clearAllSidesPoints();
            this.dirty = true;
            return this;
        },

    };

    class QuadGeom {
        constructor(x, y, width, height) {
            if (x === undefined) { x = 0; }
            if (y === undefined) { y = x; }
            if (width === undefined) { width = 0; }
            if (height === undefined) { height = 0; }

            this.setTo(x, y, width, height);

            this.tlx = 0;
            this.tly = 0;
            this.trx = 0;
            this.try = 0;
            this.blx = 0;
            this.bly = 0;
            this.brx = 0;
            this.bry = 0;
            this.topSidePoints = [];
            this.rightSidePoints = [];
            this.bottomSidePoints = [];
            this.leftSidePoints = [];
        }

        setTo(x, y, width, height) {
            this.setPosition(x, y);
            this.setSize(width, height);
            return this;
        }

        setPosition(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }

        setSize(width, height) {
            this.width = width;
            this.height = height;
            return this;
        }

        setTLPosition(x, y) {
            this.tlx = x;
            this.tly = y;
            return this;
        }

        setTRPosition(x, y) {
            this.trx = x;
            this.try = y;
            return this;
        }

        setBLPosition(x, y) {
            this.blx = x;
            this.bly = y;
            return this;
        }

        setBRPosition(x, y) {
            this.brx = x;
            this.bry = y;
            return this;
        }

        resetCornerPosition() {
            this
                .setTLPosition(0, 0)
                .setTRPosition(0, 0)
                .setBLPosition(0, 0)
                .setBRPosition(0, 0);

            return this;
        }

        insertTopSidePoint(t, x, y) {
            AddPoint(this.topSidePoints, t, x, y);
            return this;
        }

        insertRightSidePoint(t, x, y) {
            AddPoint(this.rightSidePoints, t, x, y);
            return this;
        }

        insertBottomSidePoint(t, x, y) {
            AddPoint(this.bottomSidePoints, t, x, y);
            return this;
        }

        insertLeftSidePoint(t, x, y) {
            AddPoint(this.leftSidePoints, t, x, y);
            return this;
        }

        clearTopSidePoints() {
            this.topSidePoints.length = 0;
            return this;
        }

        clearRightSidePoints() {
            this.rightSidePoints.length = 0;
            return this;
        }

        clearBottomSidePoints() {
            this.bottomSidePoints.length = 0;
            return this;
        }

        clearLeftSidePoints() {
            this.leftSidePoints.length = 0;
            return this;
        }

        clearAllSidesPoints() {
            this
                .clearTopSidePoints()
                .clearRightSidePoints()
                .clearBottomSidePoints()
                .clearLeftSidePoints();

            return this;

        }
    }

    var AddPoint = function (points, t, x, y) {
        if (typeof (t) !== 'number') {
            var config = t;
            t = config.t;
            x = config.x;
            y = config.y;
        }
        points.push({ t: t, x: x, y: y });
    };

    const IsPlainObject$R = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3P = Phaser.Utils.Objects.GetValue;
    const Linear$q = Phaser.Math.Linear;
    const Earcut$1 = Phaser.Geom.Polygon.Earcut;

    class Quad extends PolygnBase {
        constructor(scene, x, y, width, height, fillColor, fillAlpha) {
            var strokeColor, strokeAlpha, strokeWidth;
            if (IsPlainObject$R(x)) {
                var config = x;

                x = config.x;
                y = config.y;
                width = config.width;
                height = config.height;
                fillColor = config.color;
                fillAlpha = config.alpha;

                strokeColor = config.strokeColor;
                strokeAlpha = config.strokeAlpha;
                strokeWidth = config.strokeWidth;
            }

            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 1; }
            if (height === undefined) { height = width; }

            var geom = new QuadGeom();  // Configurate it later
            super(scene, 'rexQuadShape', geom);

            geom.setTo(0, 0, width, height);

            this.setPosition(x, y);

            this.setFillStyle(fillColor, fillAlpha);

            if ((strokeColor !== undefined) && (strokeWidth === undefined)) {
                strokeWidth = 2;
            }
            this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);

            this
                .setTLPosition(GetValue$3P(config, 'tlx', 0), GetValue$3P(config, 'tly', 0))
                .setTRPosition(GetValue$3P(config, 'trx', 0), GetValue$3P(config, 'try', 0))
                .setBLPosition(GetValue$3P(config, 'blx', 0), GetValue$3P(config, 'bly', 0))
                .setBRPosition(GetValue$3P(config, 'brx', 0), GetValue$3P(config, 'bry', 0));

            var leftSidePoints = GetValue$3P(config, 'leftSidePoints');
            if (leftSidePoints) {
                this.insertLeftSidePoint(leftSidePoints);
            }
            var topSidePoints = GetValue$3P(config, 'topSidePoints');
            if (topSidePoints) {
                this.insertTopSidePoint(topSidePoints);
            }
            var rightSidePoints = GetValue$3P(config, 'rightSidePoints');
            if (rightSidePoints) {
                this.insertRightSidePoint(rightSidePoints);
            }
            var bottomSidePoints = GetValue$3P(config, 'bottomSidePoints');
            if (bottomSidePoints) {
                this.insertBottomSidePoint(bottomSidePoints);
            }


            this.updateDisplayOrigin();
            this.dirty = true;
        }

        updateData() {
            var geom = this.geom;
            var pathData = this.pathData;
            pathData.length = 0;

            var width = geom.width;
            var height = geom.height;
            var tlx = 0 + geom.tlx;
            var tly = 0 + geom.tly;
            var trx = width + geom.trx;
            var try_ = 0 + geom.try;
            var brx = width + geom.brx;
            var bry = height + geom.bry;
            var blx = 0 + geom.blx;
            var bly = height + geom.bly;
            var topSidePoints = geom.topSidePoints;
            var rightSidePoints = geom.rightSidePoints;
            var bottomSidePoints = geom.bottomSidePoints;
            var leftSidePoints = geom.leftSidePoints;

            // Top side
            LineTo(tlx, tly, pathData);
            SortPoints(topSidePoints);
            for (var i = 0, cnt = topSidePoints.length; i < cnt; i++) {
                var point = topSidePoints[i];
                var px = Linear$q(tlx, trx, point.t) + point.x;
                var py = Linear$q(tly, try_, point.t) + point.y;
                LineTo(px, py, pathData);
            }

            // Right side
            LineTo(trx, try_, pathData);
            SortPoints(rightSidePoints);
            for (var i = 0, cnt = rightSidePoints.length; i < cnt; i++) {
                var point = rightSidePoints[i];
                var px = Linear$q(trx, brx, point.t) + point.x;
                var py = Linear$q(try_, bry, point.t) + point.y;
                LineTo(px, py, pathData);
            }

            // Bottom side
            LineTo(brx, bry, pathData);
            SortPoints(bottomSidePoints);
            for (var i = bottomSidePoints.length - 1; i >= 0; i--) {
                var point = bottomSidePoints[i];
                var px = Linear$q(blx, brx, point.t) + point.x;
                var py = Linear$q(bly, bry, point.t) + point.y;
                LineTo(px, py, pathData);
            }

            // Left side
            LineTo(blx, bly, pathData);
            SortPoints(leftSidePoints);
            for (var i = leftSidePoints.length - 1; i >= 0; i--) {
                var point = leftSidePoints[i];
                var px = Linear$q(tlx, blx, point.t) + point.x;
                var py = Linear$q(tly, bly, point.t) + point.y;
                LineTo(px, py, pathData);
            }

            pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
            this.pathIndexes = Earcut$1(pathData);

            return this;
        }

        get tlx() {
            return this.geom.tlx;
        }

        set tlx(value) {
            this.geom.tlx = value;
            this.dirty = true;
        }

        get tly() {
            return this.geom.tly;
        }

        set tly(value) {
            this.geom.tly = value;
            this.dirty = true;
        }

        get trx() {
            return this.geom.trx;
        }

        set trx(value) {
            this.geom.trx = value;
            this.dirty = true;
        }

        get try() {
            return this.geom.try;
        }

        set try(value) {
            this.geom.try = value;
            this.dirty = true;
        }

        get blx() {
            return this.geom.blx;
        }

        set blx(value) {
            this.geom.blx = value;
            this.dirty = true;
        }

        get bly() {
            return this.geom.bly;
        }

        set bly(value) {
            this.geom.bly = value;
            this.dirty = true;
        }

        get brx() {
            return this.geom.brx;
        }

        set brx(value) {
            this.geom.brx = value;
            this.dirty = true;
        }

        get bry() {
            return this.geom.bry;
        }

        set bry(value) {
            this.geom.bry = value;
            this.dirty = true;
        }

        get leftSidePoints() {
            return this.geom.leftSidePoints;
        }

        get topSidePoints() {
            return this.geom.topSidePoints;
        }

        get bottomSidePoints() {
            return this.geom.bottomSidePoints;
        }

        get rightSidePoints() {
            return this.geom.rightSidePoints;
        }
    }

    var SortPoints = function (points) {
        if (points.length <= 1) {
            return;
        }
        points.sort(function (pointA, pointB) {
            return pointA.t - pointB.t;
        });
    };

    Object.assign(
        Quad.prototype,
        PointMethods,
    );

    ObjectFactory.register('QuadShape', function (x, y, width, height, fillColor, fillAlpha) {
        var gameObject = new Quad(this.scene, x, y, width, height, fillColor, fillAlpha);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.QuadShape', Quad);

    var Utils = Phaser.Renderer.WebGL.Utils;

    var WebGLRenderer$1 = function (renderer, src, camera, parentMatrix) {
        if ((src.width === 0) || (src.height === 0)) {
            return;
        }

        camera.addToRenderList(src);

        var frame = src.frame;
        var width = frame.width;
        var height = frame.height;
        var getTint = Utils.getTintAppendFloatAlpha;
        var pipeline = renderer.pipelines.set(src.pipeline, src);
        var textureUnit = pipeline.setTexture2D(frame.glTexture, src);

        renderer.pipelines.preBatch(src);

        pipeline.batchTexture(
            src,
            frame.glTexture,
            width, height,
            src.x, src.y,
            width / src.style.resolution, height / src.style.resolution,
            src.scaleX, src.scaleY,
            src.rotation,
            src.flipX, src.flipY,
            src.scrollFactorX, src.scrollFactorY,
            src.displayOriginX, src.displayOriginY,
            0, 0, width, height,
            getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
            getTint(src.tintTopRight, camera.alpha * src._alphaTR),
            getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
            getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
            src.tintFill,
            0, 0,
            camera,
            parentMatrix,
            false,
            textureUnit
        );

        renderer.pipelines.postBatch(src);
    };

    var CanvasRenderer$1 = function (renderer, src, camera, parentMatrix) {
        if ((src.width === 0) || (src.height === 0)) {
            return;
        }

        camera.addToRenderList(src);

        renderer.batchSprite(src, src.frame, camera, parentMatrix);
    };

    var Render$1 = {
        renderWebGL: WebGLRenderer$1,
        renderCanvas: CanvasRenderer$1

    };

    const CanvasPool$3 = Phaser.Display.Canvas.CanvasPool;

    var MeasureTextMargins = function (textStyle, testString, out) {
        if (out === undefined) {
            out = {};
        }

        var canvas = CanvasPool$3.create(this);
        var context = canvas.getContext('2d', { willReadFrequently: true });

        textStyle.syncFont(canvas, context);

        var metrics = context.measureText(testString);

        var width = Math.ceil(metrics.width * textStyle.baselineX);
        var baseline = width;
        var height = 2 * baseline;

        baseline = baseline * textStyle.baselineY | 0;

        canvas.width = width;
        canvas.height = height;

        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);

        context.font = textStyle._font;

        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(textStyle.testString, 0, baseline);

        out.left = 0;

        if ((width === 0) || (height === 0) || !context.getImageData(0, 0, width, height)) {
            CanvasPool$3.remove(canvas);
            return out;
        }

        var imagedata = context.getImageData(0, 0, width, height).data;
        var stop = false;
        for (var x = 0; x < width; x++) {
            for (var y = 0; y < height; y++) {
                var idx = (y * width + x) * 4;
                if (imagedata[idx] !== 255) {
                    out.left = x;
                    stop = true;
                    break;
                }
            }
            if (stop) {
                break;
            }
        }

        CanvasPool$3.remove(canvas);
        return out;
    };

    CheckP3Version();

    const GameObject$2 = Phaser.GameObjects.GameObject;

    class TextBase extends GameObject$2 {

        setStyle(style) {
            return this.style.setStyle(style);
        }

        setFont(font) {
            return this.style.setFont(font);
        }

        setFontFamily(family) {
            return this.style.setFontFamily(family);
        }

        setFontSize(size) {
            return this.style.setFontSize(size);
        }

        setFontStyle(style) {
            return this.style.setFontStyle(style);
        }

        setTestString(string) {
            return this.style.setTestString(string);
        }

        setFixedSize(width, height) {
            return this.style.setFixedSize(width, height);
        }

        setBackgroundColor(color, color2, isHorizontalGradient) {
            return this.style.setBackgroundColor(color, color2, isHorizontalGradient);
        }

        setBackgroundStrokeColor(color, lineWidth) {
            return this.style.setBackgroundStrokeColor(color, lineWidth);
        }

        setBackgroundCornerRadius(radius, iteration) {
            return this.style.setBackgroundCornerRadius(radius, iteration);
        }

        setFill(color) {
            return this.style.setFill(color);
        }

        setColor(color) {
            return this.style.setColor(color);
        }

        setStroke(color, thickness) {
            return this.style.setStroke(color, thickness);
        }

        setShadow(x, y, color, blur, shadowStroke, shadowFill) {
            return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
        }

        setShadowOffset(x, y) {
            return this.style.setShadowOffset(x, y);
        }

        setShadowColor(color) {
            return this.style.setShadowColor(color);
        }

        setShadowBlur(blur) {
            return this.style.setShadowBlur(blur);
        }

        setShadowStroke(enabled) {
            return this.style.setShadowStroke(enabled);
        }

        setShadowFill(enabled) {
            return this.style.setShadowFill(enabled);
        }

        setUnderline(color, thickness, offset) {
            return this.style.setUnderline(color, thickness, offset);
        }

        setUnderlineColor(color) {
            return this.style.setUnderlineColor(color);
        }

        setUnderlineThickness(thickness) {
            return this.style.setUnderlineThickness(thickness);
        }

        setUnderlineOffset(offset) {
            return this.style.setUnderlineOffset(offset);
        }

        setStrikethrough(color, thickness, offset) {
            return this.style.setStrikethrough(color, thickness, offset);
        }

        setStrikethroughColor(color) {
            return this.style.setStrikethroughColor(color);
        }

        setStrikethroughThickness(thickness) {
            return this.style.setStrikethroughThickness(thickness);
        }

        setStrikethroughOffset(offset) {
            return this.style.setStrikethroughOffset(offset);
        }

        setWrapMode(mode) {
            return this.style.setWrapMode(mode);
        }

        setWrapWidth(width) {
            return this.style.setWrapWidth(width);
        }

        // Align with built-in text game object
        setWordWrapWidth(width) {
            return this.style.setWrapWidth(width);
        }

        setAlign(align) {
            return this.style.setHAlign(align);
        }
        setHAlign(align) {
            return this.style.setHAlign(align);
        }
        setVAlign(align) {
            return this.style.setVAlign(align);
        }

        get lineSpacing() {
            return this.style.lineSpacing;
        }

        set lineSpacing(value) {
            this.style.lineSpacing = value;
        }

        setLineSpacing(value) {
            this.style.lineSpacing = value;
            this.updateText(true);
            return this;
        }

        setXOffset(value) {
            return this.style.setXOffset(value);
        }

        setMaxLines(max) {
            return this.style.setMaxLines(max);
        }

        setResolution(value) {
            return this.style.setResolution(value);
        }

        getTextMetrics() {
            return this.style.getTextMetrics();
        }

        setTextMetrics(metrics, font) {
            return this.style.setTextMetrics(metrics, font);
        }

        measureTextMargins(testString, out) {
            return MeasureTextMargins(this.style, testString, out);
        }

    }

    const Components$2 = Phaser.GameObjects.Components;
    Phaser.Class.mixin(TextBase,
        [
            Components$2.Alpha,
            Components$2.BlendMode,
            Components$2.ComputedSize,
            Components$2.Crop,
            Components$2.Depth,
            Components$2.Flip,
            Components$2.GetBounds,
            Components$2.Mask,
            Components$2.Origin,
            Components$2.Pipeline,
            Components$2.PostPipeline,
            Components$2.ScrollFactor,
            Components$2.Tint,
            Components$2.Transform,
            Components$2.Visible,
            Render$1
        ]
    );

    //  Key: [ Object Key, Default Value, postCallback ]

    var PropertyMap = {
        // background
        backgroundColor: ['backgroundColor', null, GetStyle],
        backgroundColor2: ['backgroundColor2', null, GetStyle],
        backgroundHorizontalGradient: ['backgroundHorizontalGradient', true, null],
        backgroundStrokeColor: ['backgroundStrokeColor', null, GetStyle],
        backgroundStrokeLineWidth: ['backgroundStrokeLineWidth', 2, null],
        backgroundCornerRadius: ['backgroundCornerRadius', 0, null],
        backgroundCornerIteration: ['backgroundCornerIteration', null, null],

        // font
        fontFamily: ['fontFamily', 'Courier', null],
        fontSize: ['fontSize', '16px', null],
        fontStyle: ['fontStyle', '', null],
        color: ['color', '#fff', GetStyle],
        stroke: ['stroke', '#fff', GetStyle],
        strokeThickness: ['strokeThickness', 0, null],
        shadowOffsetX: ['shadow.offsetX', 0, null],
        shadowOffsetY: ['shadow.offsetY', 0, null],
        shadowColor: ['shadow.color', '#000', GetStyle],
        shadowBlur: ['shadow.blur', 0, null],
        shadowStroke: ['shadow.stroke', false, null],
        shadowFill: ['shadow.fill', false, null],

        // underline
        underlineColor: ['underline.color', '#000', GetStyle],
        underlineThickness: ['underline.thickness', 0, null],
        underlineOffset: ['underline.offset', 0, null],

        // strikethrough
        strikethroughColor: ['strikethrough.color', '#000', GetStyle],
        strikethroughThickness: ['strikethrough.thickness', 0, null],
        strikethroughOffset: ['strikethrough.offset', 0, null],

        // align
        halign: ['halign', 'left', null],
        valign: ['valign', 'top', null],

        // size
        maxLines: ['maxLines', 0, null],
        fixedWidth: ['fixedWidth', 0, null],
        fixedHeight: ['fixedHeight', 0, null],
        resolution: ['resolution', 0, null],
        lineSpacing: ['lineSpacing', 0, null],
        xOffset: ['xOffset', 0, null],

        rtl: ['rtl', false, null],
        testString: ['testString', '|MÃ‰qgy', null],
        baselineX: ['baselineX', 1.2, null],
        baselineY: ['baselineY', 1.4, null],

        // wrap
        wrapMode: ['wrap.mode', 0, null],
        wrapWidth: ['wrap.width', 0, null],
        wrapCallback: ['wrap.callback', null],
        wrapCallbackScope: ['wrap.callbackScope', null],
    };

    /**
     * @author       Richard Davey <rich@photonstorm.com>
     * @copyright    2018 Photon Storm Ltd.
     * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
     */

    const CanvasPool$2 = Phaser.Display.Canvas.CanvasPool;

    /**
     * Calculates the ascent, descent and fontSize of a given font style.
     *
     * @function Phaser.GameObjects.MeasureText
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Text.TextStyle} textStyle - The TextStyle object to measure.
     *
     * @return {object} An object containing the ascent, descent and fontSize of the TextStyle.
     */
    var MeasureText = function (textStyle) {
        // @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
        var canvas = CanvasPool$2.create(this);

        // @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
        var context = canvas.getContext('2d', { willReadFrequently: true });

        textStyle.syncFont(canvas, context);

        var metrics = context.measureText(textStyle.testString);

        if ('actualBoundingBoxAscent' in metrics) {
            var ascent = metrics.actualBoundingBoxAscent;
            var descent = metrics.actualBoundingBoxDescent;

            var output = {
                ascent: ascent,
                descent: descent,
                fontSize: (ascent + descent)
            };

            CanvasPool$2.remove(canvas);

            return output;
        }

        var width = Math.ceil(metrics.width * textStyle.baselineX);
        var baseline = width;
        var height = 2 * baseline;

        baseline = baseline * textStyle.baselineY | 0;

        canvas.width = width;
        canvas.height = height;

        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);

        context.font = textStyle._font;

        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(textStyle.testString, 0, baseline);

        var output = {
            ascent: 0,
            descent: 0,
            fontSize: 0
        };

        if (!context.getImageData(0, 0, width, height)) {
            output.ascent = baseline;
            output.descent = baseline + 6;
            output.fontSize = output.ascent + output.descent;

            CanvasPool$2.remove(canvas);

            return output;
        }

        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i;
        var j;
        var idx = 0;
        var stop = false;

        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; i++) {
            for (j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }

            if (!stop) {
                idx += line;
            }
            else {
                break;
            }
        }

        output.ascent = baseline - i;

        idx = pixels - line;
        stop = false;

        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; i--) {
            for (j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }

            if (!stop) {
                idx -= line;
            }
            else {
                break;
            }
        }

        output.descent = (i - baseline);
        output.fontSize = output.ascent + output.descent;

        CanvasPool$2.remove(canvas);

        return output;
    };

    var CONST = {
        // new line mode
        NO_NEWLINE: 0,
        RAW_NEWLINE: 1,
        WRAPPED_NEWLINE: 2,

        // wrap mode
        NO_WRAP: 0,
        WORD_WRAP: 1,
        CHAR_WRAP: 2,
        MIX_WRAP: 3,

        // split lines
        SPLITREGEXP: /(?:\r\n|\r|\n)/
    };

    const WRAPMODE$1 = {
        none: CONST.NO_WRAP,
        word: CONST.WORD_WRAP,
        char: CONST.CHAR_WRAP,
        character: CONST.CHAR_WRAP,
        mix: CONST.MIX_WRAP
    };

    const GetAdvancedValue$6 = Phaser.Utils.Objects.GetAdvancedValue;
    const GetValue$3O = Phaser.Utils.Objects.GetValue;

    let TextStyle$1 = class TextStyle {
        constructor(text, style, propertyMap) {
            this.parent = text;
            // parent.updateText()
            // parent.width, parent.height

            if (propertyMap === undefined) {
                propertyMap = PropertyMap;
            }
            this.propertyMap = propertyMap;

            this.backgroundColor;
            this.backgroundColor2;
            this.backgroundHorizontalGradient;
            this.backgroundStrokeColor;
            this.backgroundStrokeLineWidth;
            this.backgroundCornerRadius;
            this.backgroundCornerIteration;

            this.fontFamily;
            this.fontSize;
            this.fontStyle;
            this.color;
            this.stroke;
            this.strokeThickness;
            this.shadowOffsetX;
            this.shadowOffsetY;
            this.shadowColor;
            this.shadowBlur;
            this.shadowStroke;
            this.shadowFill;

            this.underlineColor;
            this.underlineThickness;
            this.underlineOffset;

            this.strikethroughColor;
            this.strikethroughThickness;
            this.strikethroughOffset;

            this.halign;
            this.valign;

            this.maxLines;
            this.fixedWidth;
            this.fixedHeight;
            this.resolution;
            this.xOffset;

            this.rtl;
            this.testString;

            this.baselineX;
            this.baselineY;

            this.wrapMode;
            this.wrapWidth;
            this.wrapCallback;
            this.wrapCallbackScope;

            this._font;

            //  Set to defaults + user style
            this.setStyle(style, false, true);
        }

        get isWrapFitMode() {
            return (this.fixedWidth > 0) && (this.wrapMode !== CONST.NO_WRAP) && (this.wrapWidth === 0);
        }

        setStyle(style, updateText, setDefaults) {
            if (updateText === undefined) {
                updateText = true;
            }
            if (setDefaults === undefined) {
                setDefaults = false;
            }

            // Compatible with Text game object
            if (style && style.hasOwnProperty('wordWrap')) {
                var wordWrap = style.wordWrap;
                if (wordWrap.hasOwnProperty('width')) {
                    style.wrap = {
                        mode: 'word',
                        width: wordWrap.width,
                    };
                }
            }

            if (style && style.hasOwnProperty('wrap')) {
                var wrap = style.wrap;
                if (wrap.hasOwnProperty('mode')) {
                    var mode = wrap.mode;
                    if (typeof mode === 'string') {
                        wrap.mode = WRAPMODE$1[mode];
                    }
                } else {
                    if (wrap.hasOwnProperty('width')) {
                        wrap.mode = 1;
                    }
                }
            }

            // default halign of RTL is 'right'
            if (style && style.rtl && setDefaults && (!style.hasOwnProperty('halign'))) {
                style.halign = 'right';
            }

            //  Avoid type mutation
            if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {
                style.fontSize = style.fontSize.toString() + 'px';
            }

            var propertyMap = this.propertyMap;
            for (var key in propertyMap) {
                var prop = propertyMap[key];  // [ Object Key, Default Value, preCallback ]
                var objKey = prop[0];
                var defaultValue = (setDefaults) ? prop[1] : this[key];
                var postCallback = prop[2];


                if (key === 'wrapCallback' || key === 'wrapCallbackScope') {
                    // Callback & scope should be set without processing the values
                    this[key] = GetValue$3O(style, objKey, defaultValue);
                } else {
                    var value = GetAdvancedValue$6(style, objKey, defaultValue);
                    if (postCallback) {
                        value = postCallback(value);
                    }
                    this[key] = value;
                }

            }

            //  Allow for 'font' override
            var font = GetValue$3O(style, 'font', null);

            if (font === null) {
                this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;
            } else {
                this._font = font;
            }

            //  Allow for 'fill' to be used in place of 'color'
            var fill = GetValue$3O(style, 'fill', null);

            if (fill !== null) {
                this.color = GetStyle(fill);
            }

            var metrics = GetValue$3O(style, 'metrics', false);

            //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
            //  Doing this is reset if you then change the font of this TextStyle after creation
            if (metrics) {
                this.metrics = {
                    ascent: GetValue$3O(metrics, 'ascent', 0),
                    descent: GetValue$3O(metrics, 'descent', 0),
                    fontSize: GetValue$3O(metrics, 'fontSize', 0)
                };
            } else if (updateText || (!this.metrics)) {
                this.metrics = MeasureText(this);
            }

            if (updateText) {
                return this.parent.updateText();
            } else {
                return this.parent;
            }
        }

        syncFont(canvas, context) {
            context.font = this._font;
        }

        syncStyle(canvas, context) {
            context.textBaseline = 'alphabetic';

            context.fillStyle = this.color;
            context.strokeStyle = this.stroke;

            context.lineWidth = this.strokeThickness;
            context.lineCap = 'round';
            context.lineJoin = 'round';
        }

        syncShadow(context, enabled) {
            if (enabled) {
                context.shadowOffsetX = this.shadowOffsetX;
                context.shadowOffsetY = this.shadowOffsetY;
                context.shadowColor = this.shadowColor;
                context.shadowBlur = this.shadowBlur;
            } else {
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
                context.shadowColor = 0;
                context.shadowBlur = 0;
            }
        }

        update(recalculateMetrics) {
            if (recalculateMetrics) {
                this._font = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();

                this.metrics = MeasureText(this);
            }

            return this.parent.updateText(recalculateMetrics);
        }

        buildFont() {
            var newFont = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();
            if (newFont !== this._font) {
                this._font = newFont;
                //this.metrics = MeasureText(this);
            }
            return this;
        }

        setFont(font) {
            if (typeof font === 'string') {
                this.fontFamily = font;
                this.fontSize = '';
                this.fontStyle = '';
            } else {
                this.fontFamily = GetValue$3O(font, 'fontFamily', 'Courier');
                this.fontSize = GetValue$3O(font, 'fontSize', '16px');
                this.fontStyle = GetValue$3O(font, 'fontStyle', '');
            }

            return this.update(true);
        }

        setFontFamily(family) {
            this.fontFamily = family;

            return this.update(true);
        }

        setFontStyle(style) {
            this.fontStyle = style;

            return this.update(true);
        }

        setFontSize(size) {
            if (typeof size === 'number') {
                size = size.toString() + 'px';
            }

            this.fontSize = size;

            return this.update(true);
        }

        setTestString(string) {
            this.testString = string;

            return this.update(true);
        }

        setFixedSize(width, height) {
            this.fixedWidth = width;
            this.fixedHeight = height;

            if (width) {
                this.parent.width = width;
            }

            if (height) {
                this.parent.height = height;
            }

            return this.update(this.isWrapFitMode);
        }

        setResolution(value) {
            this.resolution = value;

            return this.update(false);
        }

        setXOffset(value) {
            this.xOffset = value;

            return this.update(false);
        }

        setBackgroundColor(color, color2, isHorizontalGradient) {
            if (isHorizontalGradient === undefined) {
                isHorizontalGradient = true;
            }

            this.backgroundColor = GetStyle(color, this.parent.canvas, this.parent.context);
            this.backgroundColor2 = GetStyle(color2, this.parent.canvas, this.parent.context);
            this.backgroundHorizontalGradient = isHorizontalGradient;

            return this.update(false);
        }

        setBackgroundStrokeColor(color, lineWidth) {
            this.backgroundStrokeColor = GetStyle(color, this.parent.canvas, this.parent.context);
            this.backgroundStrokeLineWidth = lineWidth;

            return this.update(false);
        }

        setBackgroundCornerRadius(radius, iteration) {
            this.backgroundCornerRadius = radius;
            this.backgroundCornerIteration = iteration;

            return this.update(false);
        }

        setFill(color) {
            this.color = GetStyle(color, this.parent.canvas, this.parent.context);

            return this.update(false);
        }

        setColor(color) {
            this.color = GetStyle(color, this.parent.canvas, this.parent.context);

            return this.update(false);
        }

        setStroke(color, thickness) {
            if (color === undefined) {
                //  Reset the stroke to zero (disabling it)
                this.strokeThickness = 0;
            } else {
                if (thickness === undefined) {
                    thickness = this.strokeThickness;
                }

                this.stroke = GetStyle(color, this.parent.canvas, this.parent.context);
                this.strokeThickness = thickness;
            }

            return this.update(true);
        }

        setShadow(x, y, color, blur, shadowStroke, shadowFill) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (color === undefined) {
                color = '#000';
            }
            if (blur === undefined) {
                blur = 0;
            }
            if (shadowStroke === undefined) {
                shadowStroke = false;
            }
            if (shadowFill === undefined) {
                shadowFill = true;
            }

            this.shadowOffsetX = x;
            this.shadowOffsetY = y;
            this.shadowColor = GetStyle(color, this.parent.canvas, this.parent.context);
            this.shadowBlur = blur;
            this.shadowStroke = shadowStroke;
            this.shadowFill = shadowFill;

            return this.update(false);
        }

        setShadowOffset(x, y) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = x;
            }

            this.shadowOffsetX = x;
            this.shadowOffsetY = y;

            return this.update(false);
        }

        setShadowColor(color) {
            if (color === undefined) {
                color = '#000';
            }

            this.shadowColor = GetStyle(color, this.parent.canvas, this.parent.context);

            return this.update(false);
        }

        setShadowBlur(blur) {
            if (blur === undefined) {
                blur = 0;
            }

            this.shadowBlur = blur;

            return this.update(false);
        }

        setShadowStroke(enabled) {
            this.shadowStroke = enabled;

            return this.update(false);
        }

        setShadowFill(enabled) {
            this.shadowFill = enabled;

            return this.update(false);
        }

        setUnderline(color, thickness, offset) {
            if (color === undefined) {
                color = '#000';
            }
            if (thickness === undefined) {
                thickness = 0;
            }
            if (offset === undefined) {
                offset = 0;
            }

            this.underlineColor = GetStyle(color, this.parent.canvas, this.parent.context);
            this.underlineThickness = thickness;
            this.underlineOffset = offset;

            return this.update(false);
        }

        setUnderlineColor(color) {
            if (color === undefined) {
                color = '#000';
            }

            this.underlineColor = GetStyle(color, this.parent.canvas, this.parent.context);
            return this.update(false);
        }

        setUnderlineThickness(thickness) {
            if (thickness === undefined) {
                thickness = 0;
            }

            this.underlineThickness = thickness;
            return this.update(false);
        }

        setUnderlineOffset(offset) {
            if (offset === undefined) {
                offset = 0;
            }

            this.underlineOffset = offset;
            return this.update(false);
        }

        setStrikethrough(color, thickness, offset) {
            if (color === undefined) {
                color = '#000';
            }
            if (thickness === undefined) {
                thickness = 0;
            }
            if (offset === undefined) {
                offset = 0;
            }

            this.strikethroughColor = GetStyle(color, this.parent.canvas, this.parent.context);
            this.strikethroughThickness = thickness;
            this.strikethroughOffset = offset;

            return this.update(false);
        }

        setStrikethroughColor(color) {
            if (color === undefined) {
                color = '#000';
            }

            this.strikethroughColor = GetStyle(color, this.parent.canvas, this.parent.context);
            return this.update(false);
        }

        setStrikethroughThickness(thickness) {
            if (thickness === undefined) {
                thickness = 0;
            }

            this.strikethroughThickness = thickness;
            return this.update(false);
        }

        setStrikethroughOffset(offset) {
            if (offset === undefined) {
                offset = 0;
            }

            this.strikethroughOffset = offset;
            return this.update(false);
        }

        setWrapMode(mode) {
            if (typeof mode === 'string') {
                mode = WRAPMODE$1[mode.toLowerCase()] || 0;
            }
            this.wrapMode = mode;
            return this.update(true);
        }

        setWrapWidth(width) {
            this.wrapWidth = width;
            return this.update(false);
        }

        setAlign(halign, valign) {
            if (halign === undefined) {
                halign = 'left';
            }
            if (valign === undefined) {
                valign = 'top';
            }
            this.halign = halign;
            this.valign = valign;

            return this.update(false);
        }

        setHAlign(halign) {
            if (halign === undefined) {
                halign = 'left';
            }
            this.halign = halign;

            return this.update(false);
        }

        setVAlign(valign) {
            if (valign === undefined) {
                valign = 'top';
            }
            this.valign = valign;

            return this.update(false);
        }

        setMaxLines(max) {
            if (max === undefined) {
                max = 0;
            }

            this.maxLines = max;

            return this.update(false);
        }

        getTextMetrics() {
            var metrics = this.metrics;

            return {
                ascent: metrics.ascent,
                descent: metrics.descent,
                fontSize: metrics.fontSize
            };
        }

        setTextMetrics(metrics, font) {
            this.metrics.ascent = metrics.ascent;
            this.metrics.descent = metrics.descent;
            this.metrics.fontSize = metrics.fontSize;

            if (font) {
                if (typeof font === 'string') {
                    this.fontFamily = font;
                    this.fontSize = '';
                    this.fontStyle = '';
                } else {
                    this.fontFamily = GetValue$3O(font, 'fontFamily', this.fontFamily);
                    this.fontSize = GetValue$3O(font, 'fontSize', this.fontSize);
                    this.fontStyle = GetValue$3O(font, 'fontStyle', this.fontStyle);
                }
            }

            return this.parent.updateText(true);
        }

        get lineHeight() {
            return this.metrics.fontSize + this.parent.lineSpacing;
        }

        toJSON() {
            var output = {};

            var propertyMap = this.propertyMap;
            for (var key in propertyMap) {
                output[key] = this[key];
            }

            output.metrics = this.getTextMetrics();

            return output;
        }

        destroy() {
            this.parent = undefined;
        }

    };

    var GetString = function (value) {
        if (value == null) {
            value = '';
        } else if (Array.isArray(value)) {
            value = value.join('\n');
        } else if (typeof (value) === 'number') {
            value = value.toString();
        }
        return value;
    };

    var DrawMethods = {
        draw(startX, startY, textWidth, textHeight) {
            var penManager = this.penManager;
            this.hitAreaManager.clear();

            var context = this.context;
            context.save();

            var defaultStyle = this.defaultStyle;

            this.clear();
            DrawRoundRectangleBackground(
                this,
                defaultStyle.backgroundColor,
                defaultStyle.backgroundStrokeColor,
                defaultStyle.backgroundStrokeLineWidth,
                defaultStyle.backgroundCornerRadius,
                defaultStyle.backgroundColor2,
                defaultStyle.backgroundHorizontalGradient,
                defaultStyle.backgroundCornerIteration
            );

            // draw lines
            startX += this.startXOffset;
            startY += this.startYOffset;
            var defaultHalign = defaultStyle.halign,
                valign = defaultStyle.valign;

            var lineWidth, lineHeight = defaultStyle.lineHeight;
            var lines = penManager.lines;
            var totalLinesNum = lines.length,
                maxLines = defaultStyle.maxLines;
            var drawLinesNum, drawLineStartIdx, drawLineEndIdx;
            if ((maxLines > 0) && (totalLinesNum > maxLines)) {
                drawLinesNum = maxLines;
                if (valign === 'center') { // center
                    drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
                } else if (valign === 'bottom') { // bottom
                    drawLineStartIdx = totalLinesNum - drawLinesNum;
                } else {
                    drawLineStartIdx = 0;
                }
            } else {
                drawLinesNum = totalLinesNum;
                drawLineStartIdx = 0;
            }
            drawLineEndIdx = drawLineStartIdx + drawLinesNum;

            var offsetX, offsetY;
            var rtl = this.rtl,
                rtlOffset = (rtl) ? this.parent.width : undefined;
            if (valign === 'center') { // center
                offsetY = Math.max((textHeight - (drawLinesNum * lineHeight)) / 2, 0);
            } else if (valign === 'bottom') { // bottom
                offsetY = Math.max(textHeight - (drawLinesNum * lineHeight) - 2, 0);
            } else {
                offsetY = 0;
            }
            offsetY += startY;
            for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
                lineWidth = penManager.getLineWidth(lineIdx);
                if (lineWidth === 0) {
                    continue;
                }

                var pens = lines[lineIdx],
                    penCount = pens.length;
                var halign = defaultHalign;
                // Seek if there has algin tag
                for (var penIdx = 0; penIdx < penCount; penIdx++) {
                    var penAlign = pens[penIdx].prop.align;
                    if (penAlign !== undefined) {
                        halign = penAlign;
                        break;
                    }
                }

                if (halign === 'center') { // center
                    offsetX = (textWidth - lineWidth) / 2;
                } else if (halign === 'right') { // right
                    offsetX = (!rtl) ? (textWidth - lineWidth) : 0;
                } else {
                    offsetX = (!rtl) ? 0 : (textWidth - lineWidth);
                }
                offsetX += startX;

                for (var penIdx = 0; penIdx < penCount; penIdx++) {
                    this.drawPen(pens[penIdx], offsetX, offsetY, rtlOffset);
                }
            }

            context.restore();
        },

        drawPen(pen, offsetX, offsetY, rtlOffset) {
            offsetX += pen.x;
            offsetY += pen.y + (pen.prop.y || 0);

            if (rtlOffset !== undefined) {
                offsetX = rtlOffset - offsetX;
            }

            var canvas = this.canvas;
            var context = this.context;
            context.save();

            var curStyle = this.parser.propToContextStyle(this.defaultStyle, pen.prop);

            // Background
            if ((curStyle.bgcolor !== null) && (pen.width > 0)) {
                var metrics = this.defaultStyle.metrics;
                var bgTLY = offsetY - metrics.ascent;
                var bgHeight = metrics.fontSize;
                this.drawRectangle(offsetX, bgTLY, pen.width, bgHeight, curStyle.bgcolor, curStyle);
            }

            // Underline
            if ((curStyle.underlineThickness > 0) && (pen.width > 0)) {
                var lineOffsetY = offsetY + curStyle.underlineOffset - (curStyle.underlineThickness / 2);
                this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.underlineThickness, curStyle.underlineColor, curStyle);
            }

            // Text
            if (pen.isTextPen) {
                curStyle.buildFont();
                curStyle.syncFont(canvas, context);
                curStyle.syncStyle(canvas, context);
                this.drawText(offsetX, offsetY, pen.text, curStyle);
            }

            // Image
            if (pen.isImagePen) {
                this.drawImage(offsetX, offsetY, pen.prop.img, pen.prop.color, curStyle);
            }

            // Strikethrough
            if ((curStyle.strikethroughThickness > 0) && (pen.width > 0)) {
                var lineOffsetY = offsetY + curStyle.strikethroughOffset - (curStyle.strikethroughThickness / 2);
                this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.strikethroughThickness, curStyle.strikethroughColor, curStyle);
            }

            context.restore();

            if (pen.hasAreaMarker && (pen.width > 0)) {
                var data;
                var areaKey = pen.prop.area;
                if (areaKey) {
                    data = {
                        key: areaKey
                    };
                } else {
                    var url = pen.prop.url;
                    data = {
                        key: `url:${url}`,
                        url: url
                    };
                }

                this.hitAreaManager.add(
                    offsetX,                       // x
                    (offsetY - this.startYOffset), // y
                    pen.width,                     // width
                    this.defaultStyle.lineHeight,  // height
                    data
                );
            }
        },

        clear() {
            var canvas = this.canvas;
            this.context.clearRect(0, 0, canvas.width, canvas.height);
        },

        drawRectangle(x, y, width, height, color, style) {
            if (this.autoRound) {
                x = Math.round(x);
                y = Math.round(y);
            }

            var context = this.context;
            context.fillStyle = color;
            context.fillRect(x, y, width, height);
        },

        drawLine(x, y, width, height, color, style) {
            if (this.autoRound) {
                x = Math.round(x);
                y = Math.round(y);
            }

            var context = this.context;
            style.syncShadow(context, style.shadowStroke);

            var savedLineCap = context.lineCap;
            context.lineCap = 'butt';
            context.strokeStyle = color;
            context.lineWidth = height;
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo((x + width), y);
            context.stroke();
            context.lineCap = savedLineCap;
        },

        drawText(x, y, text, style) {
            if (this.autoRound) {
                x = Math.round(x);
                y = Math.round(y);
            }

            var context = this.context;
            if (style.stroke && (style.stroke !== 'none') && (style.strokeThickness > 0)) {
                style.syncShadow(context, style.shadowStroke);
                context.strokeText(text, x, y);
            }

            if (style.color && (style.color !== 'none')) {
                style.syncShadow(context, style.shadowFill);
                context.fillText(text, x, y);
            }
        },

        drawImage(x, y, imgKey, color, style) {
            y -= this.startYOffset;
            this.parent.imageManager.draw(imgKey, this.context, x, y, color, this.autoRound);
        }

    };

    const GetValue$3N = Phaser.Utils.Objects.GetValue;
    const NO_NEWLINE$3 = CONST.NO_NEWLINE;
    const RAW_NEWLINE$1 = CONST.RAW_NEWLINE;

    class Pen {
        constructor(config) {
            this.prop = {};
            this.resetFromJSON(config);
        }

        resetFromJSON(o) { // (txt, x, y, width, prop, newLineMode, startIndex)
            this.text = GetValue$3N(o, 'text', '');
            this.x = GetValue$3N(o, 'x', 0);
            this.y = GetValue$3N(o, 'y', 0);
            this.width = GetValue$3N(o, 'width', 0);

            var prop = GetValue$3N(o, 'prop', null);
            if (prop === null) {
                prop = {};
            }
            this.prop = prop;
            this.newLineMode = GetValue$3N(o, 'newLineMode', 0);
            this.startIndex = GetValue$3N(o, 'startIndex', 0);
        }

        get plainText() {
            var txt = this.text;
            if (this.newLineMode === RAW_NEWLINE$1) {
                txt += "\n";
            }

            return txt;
        }

        get wrapText() {
            var txt = this.text;
            if (this.newLineMode !== NO_NEWLINE$3) {
                txt += "\n";
            }

            return txt;
        }

        get rawTextLength() {
            var len = this.text.length;
            if (this.newLineMode === RAW_NEWLINE$1) {
                len += 1;
            }
            return len;
        }

        get endIndex() {
            return this.startIndex + this.rawTextLength;
        }

        get lastX() {
            return this.x + this.width;
        }

        get isTextPen() {
            return (this.text !== '');
        }

        get isImagePen() {
            return !!this.prop.img;
        }

        get hasAreaMarker() {
            return !!this.prop.area || !!this.prop.url;
        }
    }

    /**
     * Shallow Object Clone. Will not out nested objects.
     * @param {object} obj JSON object
     * @param {object} ret JSON object to return, set null to return a new object
     * @returns {object} this object
     */
    var Clone$2 = function (obj, out) {
        var objIsArray = Array.isArray(obj);

        if (out === undefined) {
            out = (objIsArray) ? [] : {};
        } else {
            Clear$1(out);
        }

        if (objIsArray) {
            out.length = obj.length;
            for (var i = 0, cnt = obj.length; i < cnt; i++) {
                out[i] = obj[i];
            }
        } else {
            for (var key in obj) {
                out[key] = obj[key];
            }
        }

        return out;
    };

    const GetFastValue$2 = Phaser.Utils.Objects.GetFastValue;
    const NO_NEWLINE$2 = CONST.NO_NEWLINE;
    const WRAPPED_NEWLINE$2 = CONST.WRAPPED_NEWLINE;

    class PenManager {
        constructor(config) {
            this.pens = []; // all pens
            this.lines = []; // pens in lines [ [],[],[],.. ]
            this.maxLinesWidth = undefined;

            this.pensPool = config.pensPool;    // Required
            this.linesPool = config.linesPool;  // Required
            this.tagToText = GetFastValue$2(config, 'tagToText', NOOP);
            this.tagToTextScope = GetFastValue$2(config, 'tagToTextScope', undefined);
        }

        destroy() {
            this.clear();
            this.tagToText = undefined;
            this.tagToTextScope = undefined;
        }

        clear() {
            for (var i = 0, len = this.lines.length; i < len; i++) {
                this.lines[i].length = 0;
            }

            this.pensPool.pushMultiple(this.pens);
            this.linesPool.pushMultiple(this.lines);
            this.maxLinesWidth = undefined;
        }

        addTextPen(text, x, y, width, prop, newLineMode) {
            var pen = this.pensPool.pop();
            if (pen == null) {
                pen = new Pen();
            }
            PEN_CONFIG.text = text;
            PEN_CONFIG.x = x;
            PEN_CONFIG.y = y;
            PEN_CONFIG.width = width;
            PEN_CONFIG.prop = prop;
            PEN_CONFIG.newLineMode = newLineMode;
            pen.resetFromJSON(PEN_CONFIG);
            this.addPen(pen);
            return this;
        }

        addImagePen(x, y, width, prop) {
            this.addTextPen('', x, y, width, prop, NO_NEWLINE$2);
            return this;
        }

        addNewLinePen() {
            var previousPen = this.lastPen;
            var x = (previousPen) ? previousPen.lastX : 0;
            var y = (previousPen) ? previousPen.y : 0;
            var prop = (previousPen) ? Clone$2(previousPen.prop) : null;
            this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE$2);
            return this;
        }

        addPen(pen) {
            var previousPen = this.lastPen;
            if (previousPen == null) {
                pen.startIndex = 0;
            } else {
                pen.startIndex = previousPen.endIndex;
            }
            this.pens.push(pen);

            // maintan lines
            var line = this.lastLine;
            if (line == null) {
                line = this.linesPool.pop() || [];
                this.lines.push(line);
            }
            line.push(pen);

            // new line, add an empty line
            if (pen.newLineMode !== NO_NEWLINE$2) {
                line = this.linesPool.pop() || [];
                this.lines.push(line);
            }
            this.maxLinesWidth = undefined;
        }

        clone(targetPenManager) {
            if (targetPenManager == null)
                targetPenManager = new PenManager();

            targetPenManager.clear();

            for (var li = 0, llen = this.lines.length; li < llen; li++) {
                var pens = this.lines[li];
                for (var pi = 0, plen = pens.length; pi < plen; pi++) {
                    var pen = pens[pi];
                    targetPenManager.addPen(
                        pen.text,
                        pen.x,
                        pen.y,
                        pen.width,
                        Clone$2(pen.prop),
                        pen.newLineMode
                    );
                }
            }

            return targetPenManager;
        }

        get lastPen() {
            return this.pens[this.pens.length - 1];
        }

        get lastLine() {
            return this.lines[this.lines.length - 1];
        }

        getLineStartIndex(i) {
            if (i >= this.lines.length) {
                return this.getLineEndIndex(i);
            } else {
                var line = this.lines[i];
                return (line && line[0]) ? line[0].startIndex : 0;
            }
        }

        getLineEndIndex(i) {
            if (i >= this.lines.length) {
                i = this.lines.length - 1;
            }
            var li, hasLastPen = false,
                line;
            for (li = i; li >= 0; li--) {
                line = this.lines[li];
                hasLastPen = (line != null) && (line.length > 0);
                if (hasLastPen) {
                    break;
                }
            }
            if (!hasLastPen) {
                return 0;
            }

            var lastPen = line[line.length - 1];
            return lastPen.endIndex;
        }

        getLineWidth(i) {
            var line = this.lines[i];
            if (!line) {
                return 0;
            }

            var lastPen = line[line.length - 1];
            if (lastPen == null) {
                return 0;
            }

            var lineWidth = lastPen.lastX; // start from 0
            return lineWidth;
        }

        getMaxLineWidth() {
            if (this.maxLinesWidth !== undefined) {
                return this.maxLinesWidth;
            }
            var w, maxW = 0;
            for (var i = 0, len = this.lines.length; i < len; i++) {
                w = this.getLineWidth(i);
                if (w > maxW) {
                    maxW = w;
                }
            }
            this.maxLinesWidth = maxW;
            return maxW;
        }

        getLineWidths() {
            var result = [];
            for (var i = 0, len = this.lines.length; i < len; i++) {
                result.push(this.getLineWidth(i));
            }
            return result;
        }

        get linesCount() {
            return this.lines.length;
        }

        get plainText() {
            var txt = "",
                pens = this.pens;
            for (var i = 0, len = pens.length; i < len; i++) {
                txt += pens[i].plainText;
            }

            return txt;
        }

        get rawTextLength() {
            var l = 0,
                pens = this.pens;
            for (var i = 0, len = this.pens.length; i < len; i++) {
                l += pens[i].rawTextLength;
            }

            return l;
        }

        getSliceTagText(start, end, wrap) {
            var lastPen = this.lastPen;
            if (lastPen == null) {
                return '';
            }
            var lastPenEnd = lastPen.endIndex;

            if ((start === undefined) || (start === 0)) {
                // Image pen before first character
                start = -1;
            }

            if ((end === undefined) || (end === lastPenEnd)) {
                // Image pen after last character
                end = lastPenEnd + 1;
            }
            if (wrap === undefined) {
                wrap = false;
            }

            var txt = "",
                pen, penTxt, penStartIdx, penEndIdx, isInRange;
            var currentProp, previousProp;
            for (var i = 0, len = this.pens.length; i < len; i++) {
                pen = this.pens[i];
                penEndIdx = pen.endIndex;
                if (penEndIdx <= start) {
                    continue;
                }
                pen = this.pens[i];
                penTxt = (!wrap) ? pen.plainText : pen.wrapText;
                currentProp = pen.prop;
                penStartIdx = pen.startIndex;

                isInRange = (penStartIdx >= start) && (penEndIdx <= end);
                if (!isInRange) {
                    penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
                }

                if (this.tagToTextScope) {
                    txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
                } else {
                    txt += this.tagToText(penTxt, currentProp, previousProp);
                }

                previousProp = currentProp;
                if (penEndIdx >= end) {
                    break;
                }
            }

            return txt;
        }

        get length() {
            return this.lines.length;
        }

        set length(value) {
            // Only for set length to 0 (clear)
            this.clear();
        }
    }
    var PEN_CONFIG = {};

    const Rectangle$6 = Phaser.Geom.Rectangle;

    var RectanglePool = new Stack();
    class HitAreaManager {
        constructor() {
            this.hitAreas = [];
        }

        destroy() {
            this.clear();
        }

        clear() {
            // Reuse hitArea(rectangle) later
            for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
                this.hitAreas[i].data = null;
            }
            RectanglePool.pushMultiple(this.hitAreas);
            return this;
        }

        add(x, y, width, height, data) {
            if (data === undefined) {
                data = {};
            }

            var rectangle = RectanglePool.pop();
            if (rectangle === null) {
                rectangle = new Rectangle$6(x, y, width, height);
            } else {
                rectangle.setTo(x, y, width, height);
            }

            rectangle.data = data;

            this.hitAreas.push(rectangle);
            return this;
        }

        getFirst(x, y) {
            for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
                var hitArea = this.hitAreas[i];
                if (hitArea.contains(x, y)) {
                    return hitArea;
                }
            }
            return null;
        }

        getByKey(key) {
            for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
                var hitArea = this.hitAreas[i];
                if (hitArea.data.key === key) {
                    return hitArea;
                }
            }
            return null;
        }

        drawBounds(graphics, color, parent) {
            if (color === undefined) {
                color = 0xffffff;
            }

            if (parent) {
                graphics
                    .save()
                    .scaleCanvas(parent.scaleX, parent.scaleY)
                    .rotateCanvas(parent.rotation)
                    .translateCanvas(parent.x, parent.y);
            }

            for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
                var hitArea = this.hitAreas[i];
                graphics
                    .lineStyle(1, color)
                    .strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
            }

            if (parent) {
                graphics
                    .restore();
            }
            return this;
        }
    }

    var SetInteractive$1 = function () {
        this.parent

            .on('pointerdown', OnAreaDown, this)

            .on('pointerup', OnAreaUp, this)

            .on('pointermove', OnAreaOverOut, this)
            .on('pointerover', OnAreaOverOut, this)
            .on('pointerout', function (pointer, event) {
                OnAreaOverOut.call(this, pointer, null, null, event);
            }, this);
    };

    var OnAreaDown = function (pointer, localX, localY, event) {
        var area = this.hitAreaManager.getFirst(localX, localY);
        if (area === null) {
            return;
        }

        var key = area.data.key;
        FireEvent$2.call(this, 'areadown', key, pointer, localX, localY, event);

        // Removed by callback of previous event
        if (!area.data) {
            return;
        }

        area.data.isDown = true;
    };

    var OnAreaUp = function (pointer, localX, localY, event) {
        var area = this.hitAreaManager.getFirst(localX, localY);
        if (area === null) {
            return;
        }

        var key = area.data.key;
        FireEvent$2.call(this, 'areaup', key, pointer, localX, localY, event);

        // Removed by callback of previous event
        if (!area.data) {
            return;
        }

        if (area.data.isDown) {
            FireEvent$2.call(this, 'areaclick', key, pointer, localX, localY, event);

            // Removed by callback of previous event
            if (!area.data) {
                return;
            }

            var url = area.data.url;
            if (url) {
                window.open(url, '_blank');
            }
        }

        area.data.isDown = false;
    };

    var OnAreaOverOut = function (pointer, localX, localY, event) {
        if (localX === null) {  // Case of pointerout
            if (this.lastHitAreaKey !== null) {
                FireEvent$2.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);

                var area = this.hitAreaManager.getByKey(this.lastHitAreaKey);
                if (area && area.data) {
                    area.data.isDown = false;
                }

                this.lastHitAreaKey = null;
            }
            return;
        }

        var area = this.hitAreaManager.getFirst(localX, localY);
        var key = (area) ? area.data.key : null;
        if (this.lastHitAreaKey === key) {
            return;
        }

        if (this.lastHitAreaKey !== null) {
            FireEvent$2.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);

            var prevHitArea = this.hitAreaManager.getByKey(this.lastHitAreaKey);

            if (prevHitArea) {
                if (this.urlTagCursorStyle) {
                    SetCursorStyle(this.scene, prevHitArea, '');
                }

                prevHitArea.data.isDown = false;
            }
        }
        if (key !== null) {
            FireEvent$2.call(this, 'areaover', key, pointer, localX, localY, event);

            if (area.data) {
                if (this.urlTagCursorStyle) {
                    SetCursorStyle(this.scene, area, this.urlTagCursorStyle);
                }
            }
        }

        this.lastHitAreaKey = key;
    };

    var FireEvent$2 = function (eventName, key, pointer, localX, localY, event) {
        this.parent.emit(`${eventName}-${key}`, pointer, localX, localY, event);
        this.parent.emit(eventName, key, pointer, localX, localY, event);
    };

    var SetCursorStyle = function (scene, area, cursorStyle) {
        if (!area || !area.data || !area.data.url) {
            return;
        }

        scene.input.manager.canvas.style.cursor = cursorStyle;
    };

    var RE_ASCII = /^[\x00-\x7F]+$/;
    var IsASCIIString = function (s) {
        return RE_ASCII.test(s);
    };

    const NO_NEWLINE$1 = CONST.NO_NEWLINE;
    const RAW_NEWLINE = CONST.RAW_NEWLINE;
    const WRAPPED_NEWLINE$1 = CONST.WRAPPED_NEWLINE;
    const NO_WRAP$1 = CONST.NO_WRAP;
    const WORD_WRAP = CONST.WORD_WRAP;
    const CHAR_WRAP = CONST.CHAR_WRAP;
    const splitRegExp = CONST.SPLITREGEXP;

    var WrapText = function (text, context, wrapMode, wrapWidth, offset, wrapTextLinesPool) {
        if (wrapWidth <= 0) {
            wrapMode = NO_WRAP$1;
        }

        var retLines = [];
        if (!text || !text.length) {
            return retLines;
        }

        var isNoWrap = (wrapMode === NO_WRAP$1);

        var lines = text.split(splitRegExp),
            line, remainWidth, newLineMode;
        for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
            line = lines[i];
            newLineMode = (i === (linesLen - 1)) ? NO_NEWLINE$1 : RAW_NEWLINE;

            if (isNoWrap) {
                var textWidth = context.measureText(line).width;
                retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
                continue;
            }

            remainWidth = (i === 0) ? (wrapWidth - offset) : wrapWidth;

            // Short string testing
            if (line.length <= 100) {
                var textWidth = context.measureText(line).width;
                if (textWidth <= remainWidth) {
                    retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
                    continue;
                }
            }

            var tokenArray = ParseLine(line, wrapMode);
            var token, tokenWidth;
            var lineText = '', lineWidth = 0;
            var currLineWidth;
            for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
                token = tokenArray[j];
                tokenWidth = context.measureText(token).width;

                // Text width of single token is larger than a line width
                if ((tokenWidth > wrapWidth) && IsWord(token)) {
                    if (lineText !== '') {
                        // Has pending lineText, flush it out
                        retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE$1));

                    } else if ((j === 0) && (offset > 0)) {
                        // No pending lineText, but has previous text. Append a newline
                        retLines.push(wrapTextLinesPool.getLine('', 0, WRAPPED_NEWLINE$1));

                    }

                    // Word break
                    retLines.push(...WrapText(token, context, CHAR_WRAP, wrapWidth, 0, wrapTextLinesPool));
                    // Continue at last-wordBreak-line
                    var lastwordBreakLine = retLines.pop();
                    lineText = lastwordBreakLine.text;
                    lineWidth = lastwordBreakLine.width;
                    // Free this line
                    wrapTextLinesPool.freeLine(lastwordBreakLine);

                    // Special case : Start at a space character, discard it
                    if (lineText === ' ') {
                        lineText = '';
                        lineWidth = 0;
                    }
                    continue;
                }

                currLineWidth = lineWidth + tokenWidth;
                if (currLineWidth > remainWidth) {
                    // New line
                    retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE$1));
                    lineText = token;
                    lineWidth = tokenWidth;
                    remainWidth = wrapWidth;

                } else {
                    // Append token, continue
                    lineText += token;
                    lineWidth = currLineWidth;
                }

                if (j === (tokenLen - 1)) {
                    // Flush remain text
                    retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, newLineMode));
                }
            } // for token in tokenArray

        } // for each line in lines

        return retLines;
    };

    var ParseLine = function (s, mode) {
        var tokens;

        switch (mode) {
            case WORD_WRAP:
                tokens = [];
                s = s.split(' ');
                for (var i = 0, icnt = s.length; i < icnt; i++) {
                    var token = s[i];
                    if (i < (icnt - 1)) {
                        tokens.push(token + ' ');
                    } else { // The last token
                        if (token !== '') {
                            tokens.push(token);
                        }
                    }
                }
                break;

            case CHAR_WRAP:
                tokens = s.split('');
                break;

            default: // MIX_WRAP
                tokens = [];
                s = s.split(' ');
                for (var i = 0, icnt = s.length; i < icnt; i++) {
                    var token = s[i];
                    if (i < (icnt - 1)) {
                        if (IsASCIIString(token)) {
                            tokens.push(token + ' ');
                        } else {
                            tokens.push(...token.split(''));
                            // Add space as last token
                            tokens.push(' ');
                        }
                    } else { // The last token
                        if (token !== '') {
                            if (IsASCIIString(token)) {
                                tokens.push(token);
                            } else {
                                tokens.push(...token.split(''));
                            }
                        }
                    }

                }
                break;
        }

        return tokens;
    };

    var IsWord = function (s) {
        switch (s.length) {
            case 1: return false;
            case 2: return (s.charAt(1) !== ' ');
            default: return true;
        }
    };

    const GetValue$3M = Phaser.Utils.Objects.GetValue;
    const NO_WRAP = CONST.NO_WRAP;
    const NO_NEWLINE = CONST.NO_NEWLINE;
    const WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;

    class CanvasText {
        constructor(config) {
            this.parent = config.parent;
            this.scene = this.parent.scene;
            this.context = GetValue$3M(config, 'context', null);
            this.canvas = this.context.canvas;
            this.parser = GetValue$3M(config, 'parser', null);
            this.defaultStyle = GetValue$3M(config, 'style', null);
            this.autoRound = true;

            this.pensPool = config.pensPool;                     // Required
            this.linesPool = config.linesPool;                   // Required
            this.wrapTextLinesPool = config.wrapTextLinesPool;   // Required

            this.penManager = this.newPenManager();
            this._tmpPenManager = null;

            this.hitAreaManager = new HitAreaManager();
            this.lastHitAreaKey = null;
            this.urlTagCursorStyle = null;
        }

        destroy() {
            this.parent = undefined;
            this.scene = undefined;
            this.context = undefined;
            this.canvas = undefined;
            this.parser = undefined;
            this.defaultStyle = undefined;

            if (this.penManager) {
                this.penManager.destroy();
                this.penManager = undefined;
            }
            if (this._tmpPenManager) {
                this._tmpPenManager.destroy();
                this._tmpPenManager = undefined;
            }
            if (this.hitAreaManager) {
                this.hitAreaManager.destroy();
                this.hitAreaManager = undefined;
            }

            this.pensPool = undefined;
            this.linesPool = undefined;
            this.wrapTextLinesPool = undefined;
        }

        updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
            if (penManager === undefined) {
                penManager = this.penManager;
            }
            penManager.clear();
            if (text === "") {
                return penManager;
            }

            var textStyle = this.parent.style;
            if (textStyle.isWrapFitMode) {
                var padding = this.parent.padding;
                wrapWidth = textStyle.fixedWidth - padding.left - padding.right;
            }

            var canvas = this.canvas;
            var context = this.context;

            var cursorX = 0,
                cursorY = 0;

            var customTextWrapCallback = textStyle.wrapCallback,
                customTextWrapCallbackScope = textStyle.wrapCallbackScope;
            var reuseLines = true;

            var plainText, curProp, curStyle;
            var match = this.parser.splitText(text),
                result, wrapLines,
                wrapTextLinesPool = this.wrapTextLinesPool;
            for (var i = 0, len = match.length; i < len; i++) {
                result = this.parser.tagTextToProp(match[i], curProp);
                plainText = result.plainText;
                curProp = result.prop;

                if (curProp.img) { // Image tag                
                    var imgWidth = this.imageManager.getOuterWidth(curProp.img);
                    if ((wrapWidth > 0) && (wrapMode !== NO_WRAP)) {  // Wrap mode
                        if (wrapWidth < (cursorX + imgWidth)) {
                            penManager.addNewLinePen();
                            cursorY += lineHeight;
                            cursorX = 0;
                        }
                    }
                    penManager.addImagePen(cursorX, cursorY, imgWidth, Clone$2(curProp));
                    cursorX += imgWidth;

                } else if (plainText !== '') {
                    // wrap text to lines
                    // Save the current context.
                    context.save();
                    curStyle = this.parser.propToContextStyle(this.defaultStyle, curProp);
                    curStyle.buildFont();
                    curStyle.syncFont(canvas, context);
                    curStyle.syncStyle(canvas, context);

                    if (!customTextWrapCallback) {
                        wrapLines = WrapText(
                            plainText,
                            context,
                            wrapMode, wrapWidth,
                            cursorX,
                            wrapTextLinesPool
                        );

                    } else { // customTextWrapCallback
                        wrapLines = customTextWrapCallback.call(customTextWrapCallbackScope,
                            plainText,
                            context,
                            wrapWidth,
                            cursorX
                        );

                        if (typeof (wrapLines) === 'string') {
                            wrapLines = wrapLines.split('\n');
                        }

                        var segment;
                        for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                            segment = wrapLines[j];
                            if (typeof (segment) === 'string') {
                                wrapLines[j] = wrapTextLinesPool.getLine(
                                    segment,
                                    context.measureText(segment).width,
                                    (j < (jLen - 1)) ? WRAPPED_NEWLINE : NO_NEWLINE
                                );
                            } else {
                                reuseLines = false;
                            }
                        }
                    }  // customTextWrapCallback

                    // add pens
                    var segment;
                    for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                        segment = wrapLines[j];
                        penManager.addTextPen(
                            segment.text,
                            cursorX, cursorY,
                            segment.width,
                            Clone$2(curProp),
                            segment.newLineMode
                        );

                        if (segment.newLineMode !== NO_NEWLINE) {
                            cursorX = 0;
                            cursorY += lineHeight;
                        } else {
                            cursorX += segment.width;
                        }

                    }

                    if (reuseLines) {
                        wrapTextLinesPool.freeLines(wrapLines);
                    }
                    wrapLines = null;

                    context.restore();

                }

            }

            // Add strokeThinkness to last pen of each line
            for (var i = 0, len = this.lines.length; i < len; i++) {
                var line = this.lines[i];
                var lastPen = line[line.length - 1];
                if (lastPen) {
                    lastPen.width += this.parser.getStrokeThinkness(this.defaultStyle, lastPen.prop);
                }
            }

            return penManager;
        }

        get startXOffset() {
            return this.defaultStyle.xOffset;
        }

        get startYOffset() {
            return this.defaultStyle.metrics.ascent;
        }

        get lines() {
            return this.penManager.lines;
        }

        get displayLinesCount() {
            var linesCount = this.penManager.linesCount,
                maxLines = this.defaultStyle.maxLines;
            if ((maxLines > 0) && (linesCount > maxLines)) {
                linesCount = maxLines;
            }
            return linesCount;
        }

        get linesWidth() {
            return Math.ceil(this.penManager.getMaxLineWidth());
        }

        get linesHeight() {
            var linesCount = this.displayLinesCount;
            var linesHeight = (this.defaultStyle.lineHeight * linesCount);
            if (linesCount > 0) {
                linesHeight -= this.defaultStyle.lineSpacing;
            }
            return linesHeight;
        }

        get imageManager() {
            return this.parent.imageManager;
        }

        get rtl() {
            return this.parent.style.rtl;
        }

        newPenManager() {
            return new PenManager({
                pensPool: this.pensPool,
                linesPool: this.linesPool,
                tagToText: this.parser.propToTagText,
                tagToTextScope: this.parser
            });
        }

        get tmpPenManager() {
            if (this._tmpPenManager === null) {
                this._tmpPenManager = this.newPenManager();
            }
            return this._tmpPenManager;
        }

        getPlainText(text, start, end) {
            var plainText;
            if (text == null) {
                plainText = this.penManager.plainText;
            } else {
                var match = this.parser.splitText(text, 1); // PLAINTEXTONLY_MODE
                plainText = "";
                for (var i = 0, len = match.length; i < len; i++) {
                    plainText += match[i];
                }
            }

            if ((start != null) || (end != null)) {
                if (start == null) {
                    start = 0;
                }
                if (end == null) {
                    end = plainText.length;
                }
                plainText = plainText.substring(start, end);
            }

            return plainText;
        }

        getPenManager(text, retPenManager) {
            if (text === undefined) {
                return this.copyPenManager(retPenManager, this.penManager);
            }

            if (retPenManager === undefined) {
                retPenManager = this.newPenManager();
            }

            var defaultStyle = this.defaultStyle;
            this.updatePenManager(
                text,
                defaultStyle.wrapMode,
                defaultStyle.wrapWidth,
                defaultStyle.lineHeight,
                retPenManager
            );
            return retPenManager;
        }

        getText(text, start, end, wrap) {
            if (text == null) {
                return this.penManager.getSliceTagText(start, end, wrap);
            }

            var penManager = this.tmpPenManager;
            var defaultStyle = this.defaultStyle;
            this.updatePenManager(
                text,
                defaultStyle.wrapMode,
                defaultStyle.wrapWidth,
                defaultStyle.lineHeight,
                penManager
            );

            return penManager.getSliceTagText(start, end, wrap);
        }

        copyPenManager(ret, src) {
            if (src === undefined) {
                src = this.penManager;
            }
            return src.copy(ret);
        }

        getTextWidth(penManager) {
            if (penManager === undefined) {
                penManager = this.penManager;
            }

            return penManager.getMaxLineWidth();
        }

        getLastPen(penManager) {
            if (penManager === undefined) {
                penManager = this.penManager;
            }

            return penManager.lastPen;
        }
    }
    var methods$I = {
        setInteractive: SetInteractive$1,
    };

    Object.assign(
        CanvasText.prototype,
        DrawMethods,
        methods$I
    );

    class WrapTextLinesPool extends Stack {
        freeLine(line) {
            if (!line) {
                return;
            }
            this.push(line);
            return this;
        }

        freeLines(lines) {
            if (!lines) {
                return;
            }
            this.pushMultiple(lines);
            return this;
        }

        getLine(text, width, newLineMode) {
            var l = this.pop();
            if (l === null) {
                l = {};
            }
            l.text = text;
            l.width = width;
            l.newLineMode = newLineMode;
            return l;
        }

    }

    const IsPlainObject$Q = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3L = Phaser.Utils.Objects.GetValue;

    var AddImage$1 = function (key, config) {
        if (IsPlainObject$Q(key)) {
            config = key;
            key = config.key;
        } else if (config === undefined) {
            config = {
                key: key
            };
        }

        if (!config.hasOwnProperty('key')) {
            config.key = key;
        }

        var textureKey = config.key, frameKey = config.frame;
        var width = config.width, height = config.height;

        if ((width === undefined) || (height === undefined)) {
            var frame = this.textureManager.getFrame(textureKey, frameKey);
            var frameWidth = (frame) ? frame.cutWidth : 0;
            var frameHeight = (frame) ? frame.cutHeight : 0;
            if ((width === undefined) && (height === undefined)) {
                width = frameWidth;
                height = frameHeight;
            } else if (width === undefined) {
                width = frameWidth * (height / frameHeight);
            } else if (height === undefined) {
                height = frameHeight * (width / frameWidth);
            }
        }

        this.images[key] = {
            key: textureKey,
            frame: frameKey,
            width: width,
            height: height,
            y: GetValue$3L(config, 'y', 0),
            left: GetValue$3L(config, 'left', 0),
            right: GetValue$3L(config, 'right', 0),
            originX: GetValue$3L(config, 'originX', 0),
            originY: GetValue$3L(config, 'originY', 0),
            tintFill: GetValue$3L(config, 'tintFill', false),
        };
    };

    const CanvasPool$1 = Phaser.Display.Canvas.CanvasPool;

    var DrawFrameToCanvas = function (frame, canvas, x, y, width, height, color, autoRound) {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (width === undefined) { width = frame.cutWidth; }
        if (height === undefined) { height = frame.cutHeight; }
        if (autoRound === undefined) { autoRound = false; }
        if (autoRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        var context = canvas.getContext('2d', { willReadFrequently: true });

        if (color) {
            // Draw image at tempCanvas

            // Get tempCanvas
            var tempCanvas = CanvasPool$1.create(null, width, height, Phaser.CANVAS, true);

            var tempContext = tempCanvas.getContext('2d', { willReadFrequently: true });

            tempContext.drawImage(
                frame.source.image,
                frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight,
                0, 0, width, height
            );

            // Tint-fill
            tempContext.globalCompositeOperation = 'source-in';
            tempContext.fillStyle = color;
            tempContext.fillRect(0, 0, width, height);

            // Draw tempCanvas at context
            context.drawImage(
                tempCanvas,
                0, 0, width, height,
                x, y, width, height
            );

            // Release tempCanvas
            CanvasPool$1.remove(tempCanvas);
        } else {
            context.drawImage(
                frame.source.image,
                frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight,
                x, y, width, height
            );
        }
    };

    var DrawImage = function (key, context, x, y, color, autoRound) {
        var imgData = this.get(key);
        if (!imgData) {
            // Invalid key
            return;
        }

        var frame = this.textureManager.getFrame(imgData.key, imgData.frame);

        var width = imgData.width,
            height = imgData.height;
        x += imgData.left - (imgData.originX * width);
        y += imgData.y - (imgData.originY * height);

        if (!imgData.tintFill) {
            color = undefined;
        }

        DrawFrameToCanvas(
            frame, context.canvas,
            x, y, width, height,
            color, autoRound
        );
    };

    class ImageManager {
        constructor(scene) {
            this.textureManager = scene.sys.textures;
            this.images = {};
        }

        destroy() {
            this.textureManager = undefined;
            this.images = undefined;
        }

        add(key, config) {
            if (typeof (key) === 'string') {
                AddImage$1.call(this, key, config);
            } else if (Array.isArray(key)) {
                var data = key;
                for (var i = 0, cnt = data.length; i < cnt; i++) {
                    AddImage$1.call(this, data[i]);
                }
            } else {
                var data = key;
                for (var key in data) {
                    AddImage$1.call(this, key, data[key]);
                }
            }
            return this;
        }

        has(key) {
            return this.images.hasOwnProperty(key);
        }

        remove(key) {
            if (this.has(key)) {
                delete this.images[key];
            }
            return this;
        }

        get(key) {
            if (!this.has(key)) {
                if (this.textureManager.exists(key)) {
                    this.add(key);
                }
            }
            return this.images[key];
        }

        getOuterWidth(key) {
            var data = this.get(key);
            return (data) ? (data.width + data.left + data.right) : 0;
        }

        getFrame(key) {
            var data = this.get(key);
            return (data) ? this.textureManager.getFrame(data.key, data.frame) : undefined;
        }

        hasTexture(key) {
            return !!this.getFrame(key);
        }
    }

    var methods$H = {
        draw: DrawImage
    };

    Object.assign(
        ImageManager.prototype,
        methods$H
    );

    var AppendText$1 = function (value, addCR) {
        if (!value && value !== 0) {
            value = '';
        }

        if (addCR === undefined) {
            addCR = true;
        }

        if (Array.isArray(value)) {
            value = value.join('\n');
        }

        var newText;
        if (addCR) {
            newText = `${this.text}\n${value}`;
        } else {
            newText = `${this.text}${value}`;
        }

        if (newText != this.text) {
            this.setText(newText);
        }

        return this;
    };

    const IsPlainObject$P = Phaser.Utils.Objects.IsPlainObject;
    const AddToDOM = Phaser.DOM.AddToDOM;
    const CanvasPool = Phaser.Display.Canvas.CanvasPool;
    const GameObject$1 = Phaser.GameObjects.GameObject;
    const GetValue$3K = Phaser.Utils.Objects.GetValue;
    const RemoveFromDOM$1 = Phaser.DOM.RemoveFromDOM;
    const SPLITREGEXP = CONST.SPLITREGEXP;
    const UUID$4 = Phaser.Utils.String.UUID;

    // Reuse objects can increase performance
    var SharedPensPools = null;
    var SharedLinesPool = null;
    var SharedWrapTextLinesPool = null;

    class Text extends TextBase {
        constructor(scene, x, y, text, style, type, parser) {
            if (IsPlainObject$P(x)) {
                var config = x;
                x = GetValue$3K(config, 'x', 0);
                y = GetValue$3K(config, 'y', 0);
                text = GetValue$3K(config, 'text', '');
                style = GetValue$3K(config, 'style');
            }
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }

            super(scene, type);

            this.renderer = scene.sys.game.renderer;

            this.setPosition(x, y);
            this.setOrigin(0, 0);
            this.initPipeline();
            this.initPostPipeline(true);

            this.canvas = CanvasPool.create(this);

            this.context = this.canvas.getContext('2d', { willReadFrequently: true });

            this._imageManager = undefined;

            if (style) {
                // Override align
                if (style.hasOwnProperty('align')) {
                    var halign = style.align;
                    delete style.align;
                    style.halign = halign;
                }
                // Has Stroke color but stroke thinkness, set stroke thinkness to 1
                if (style.hasOwnProperty('stroke') && !style.hasOwnProperty('strokeThickness')) {
                    style.strokeThickness = 1;
                }
            }
            this.style = new TextStyle$1(this, style);

            var imageData = GetValue$3K(style, 'images', undefined);
            if (imageData) {
                this.addImage(imageData);
            }

            this.autoRound = true;

            this._text = undefined;

            this.padding = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };

            this.width = 1;

            this.height = 1;

            this.dirty = false;

            //  If resolution wasn't set, force it to 1
            if (this.style.resolution === 0) {
                this.style.resolution = 1;
            }

            this._crop = this.resetCropObject();

            //  Create a Texture for this Text object
            this._textureKey = UUID$4();

            this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);

            //  Get the frame
            this.frame = this.texture.get();

            //  Set the resolution
            this.frame.source.resolution = this.style.resolution;

            if (this.renderer && this.renderer.gl) {
                //  Clear the default 1x1 glTexture, as we override it later
                this.renderer.deleteTexture(this.frame.source.glTexture);
                this.frame.source.glTexture = null;
            }

            var sharedPoolMode = GetValue$3K(style, 'sharedPool', true);

            var pensPool, linesPool, wrapTextLinesPool;
            if (sharedPoolMode) {
                // Use pools first time
                if (!SharedPensPools) {
                    SharedPensPools = {};
                    SharedLinesPool = new Stack();
                    SharedWrapTextLinesPool = new WrapTextLinesPool();

                    // Remove cached data
                    this.scene.game.events.once('destroy', function () {
                        SharedPensPools = null;
                        SharedLinesPool = null;
                        SharedWrapTextLinesPool = null;
                    });
                }
                if (!SharedPensPools.hasOwnProperty(type)) {
                    SharedPensPools[type] = new Stack();
                }

                pensPool = SharedPensPools[type];
                linesPool = SharedLinesPool;
                wrapTextLinesPool = SharedWrapTextLinesPool;
            } else {
                pensPool = new Stack();
                linesPool = new Stack();
                wrapTextLinesPool = new WrapTextLinesPool();
            }

            this.canvasText = new CanvasText({
                parent: this,
                context: this.context,
                parser: parser,
                style: this.style,
                pensPool: pensPool,
                linesPool: linesPool,
                wrapTextLinesPool: wrapTextLinesPool,
            });
            this.parser = parser;

            this.initRTL();

            if (style && style.padding) {
                this.setPadding(style.padding);
            }

            this.setText(text);

            this.setUrlTagCursorStyle(GetValue$3K(style, 'urlTagCursorStyle', 'pointer'));

            if (GetValue$3K(style, 'interactive', false)) {
                this.setInteractive();
            }
        }

        preDestroy() {
            RemoveFromDOM$1(this.canvas);
            // Do nothing if canvas did not add to parent node before

            this.canvasText.destroy();
            this.canvasText = undefined;

            if (this._imageManager) {
                this._imageManager.destroy();
                this._imageManager = undefined;
            }

            CanvasPool.remove(this.canvas);

            var texture = this.texture;

            if (texture) {
                texture.destroy();
            }
        }

        set text(value) {
            this.setText(value);
        }
        get text() {
            return this._text;
        }

        initRTL() {
            if (!this.style.rtl) {
                return;
            }

            //  Here is where the crazy starts.
            //
            //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas
            //  that is not part of the DOM. It just completely ignores the direction property.

            this.canvas.dir = 'rtl';

            //  Experimental atm, but one day ...
            this.context.direction = 'rtl';

            //  Add it to the DOM, but hidden within the parent canvas.
            this.canvas.style.display = 'none';

            AddToDOM(this.canvas, this.scene.sys.canvas);

            //  And finally we set the x origin
            this.originX = 1;
        }

        setRTL(rtl) {
            if (rtl === undefined) {
                rtl = true;
            }

            var style = this.style;
            if (style.rtl === rtl) {
                return this;
            }

            style.rtl = rtl;

            if (rtl) {
                this.canvas.dir = 'rtl';
                this.context.direction = 'rtl';
                this.canvas.style.display = 'none';
                AddToDOM(this.canvas, this.scene.sys.canvas);
            } else {
                this.canvas.dir = 'ltr';
                this.context.direction = 'ltr';
            }

            if (style.halign === 'left') {
                style.halign = 'right';
            } else if (style.halign === 'right') {
                style.halign = 'left';
            }

            if (this._imageManager) {
                var images = this._imageManager.images;
                for (var key in images) {
                    images[key].originX = 1 - images[key].originX;
                }
            }

            return this;
        }

        setText(value) {
            value = GetString(value);

            if (value === this._text) {
                return this;
            }

            this._text = value;
            this.updateText();

            return this;
        }

        setPadding(left, top, right, bottom) {
            if (typeof left === 'object') {
                var config = left;

                //  If they specify x and/or y this applies to all
                var x = GetValue$3K(config, 'x', null);

                if (x !== null) {
                    left = x;
                    right = x;
                } else {
                    left = GetValue$3K(config, 'left', 0);
                    right = GetValue$3K(config, 'right', left);
                }

                var y = GetValue$3K(config, 'y', null);

                if (y !== null) {
                    top = y;
                    bottom = y;
                } else {
                    top = GetValue$3K(config, 'top', 0);
                    bottom = GetValue$3K(config, 'bottom', top);
                }
            } else {
                if (left === undefined) {
                    left = 0;
                }
                if (top === undefined) {
                    top = left;
                }
                if (right === undefined) {
                    right = left;
                }
                if (bottom === undefined) {
                    bottom = top;
                }
            }

            this.padding.left = left;
            this.padding.top = top;
            this.padding.right = right;
            this.padding.bottom = bottom;

            return this.updateText(false);
        }

        updateText(runWrap) {
            if (runWrap === undefined) {
                runWrap = true;
            }
            var canvasText = this.canvasText;

            // wrap text to pens
            var style = this.style;
            if (runWrap) {
                canvasText.updatePenManager(
                    this._text,
                    style.wrapMode,
                    style.wrapWidth,
                    style.lineHeight
                );
            }

            // resize
            var padding = this.padding;
            var textWidth, textHeight;
            var linesWidth = Math.ceil(canvasText.linesWidth);
            if (style.fixedWidth === 0) {
                this.width = linesWidth + padding.left + padding.right;
                textWidth = linesWidth;
            }
            else {
                this.width = style.fixedWidth;
                textWidth = this.width - padding.left - padding.right;
                if (textWidth < linesWidth) {
                    textWidth = linesWidth;
                }
            }
            if (style.fixedHeight === 0) {
                this.height = canvasText.linesHeight + padding.top + padding.bottom;
                textHeight = canvasText.linesHeight;
            }
            else {
                this.height = style.fixedHeight;
                textHeight = this.height - padding.top - padding.bottom;
                if (textHeight < canvasText.linesHeight) {
                    textHeight = canvasText.linesHeight;
                }
            }

            var w = this.width;
            var h = this.height;

            this.updateDisplayOrigin();

            var resolution = style.resolution;
            w *= resolution;
            h *= resolution;

            w = Math.max(Math.ceil(w), 1);
            h = Math.max(Math.ceil(h), 1);

            var canvas = this.canvas;
            var context = this.context;
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
                this.frame.setSize(w, h);
            } else {
                context.clearRect(0, 0, w, h);
            }

            context.save();
            context.scale(resolution, resolution);

            // draw
            var startX = (!this.style.rtl) ? padding.left : padding.right;
            var startY = padding.top;
            canvasText.draw(
                startX,
                startY,
                textWidth,
                textHeight,
            );

            context.restore();

            if (this.renderer && this.renderer.gl) {
                this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
                if (typeof WEBGL_DEBUG) {
                    this.frame.glTexture.spectorMetadata = { textureKey: 'BBCodeText Game Object' };
                }
            }

            this.dirty = true;

            var input = this.input;

            if (input && !input.customHitArea) {
                input.hitArea.width = this.width;
                input.hitArea.height = this.height;
            }

            return this;
        }

        toJSON() {
            var out = Components.ToJSON(this);

            //  Extra Text data is added here

            var data = {
                autoRound: this.autoRound,
                text: this._text,
                style: this.style.toJSON(),
                resolution: this.resolution,
                padding: {
                    left: this.padding.left,
                    right: this.padding.right,
                    top: this.padding.top,
                    bottom: this.padding.bottom
                }
            };

            out.data = data;

            return out;
        }

        setInteractive(hitArea, hitAreaCallback, dropZone) {
            var isInteractived = !!this.input;

            GameObject$1.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);

            if (!isInteractived) {
                this.canvasText.setInteractive();
            }

            return this;
        }

        setUrlTagCursorStyle(cursor) {
            this.urlTagCursorStyle = cursor;
            return this;
        }

        get urlTagCursorStyle() {
            return this.canvasText.urlTagCursorStyle;
        }

        set urlTagCursorStyle(value) {
            this.canvasText.urlTagCursorStyle = value;
        }

        getWrappedText(text, start, end) {
            if (typeof (text) === 'number') {
                end = start;
                start = text;
                text = undefined;
            }
            text = this.canvasText.getText(text, start, end, true);
            return text.split(SPLITREGEXP);
        }

        getPlainText(text, start, end) {
            if (typeof (text) === 'number') {
                end = start;
                start = text;
                text = undefined;
            }
            return this.canvasText.getPlainText(text, start, end);
        }

        getText(text, start, end, wrap) {
            if (typeof (text) === 'number') {
                wrap = end;
                end = start;
                start = text;
                text = undefined;
            }
            if (wrap === undefined) {
                wrap = false;
            }
            return this.canvasText.getText(text, start, end, wrap);
        }

        getSubString(text, start, end) {
            if (typeof (text) === 'number') {
                end = start;
                start = text;
                text = undefined;
            }
            return this.getText(text, start, end);
        }

        copyPenManager(penManager) {
            return this.canvasText.copyPenManager(penManager);
        }

        getPenManager(text, penManager) {
            return this.canvasText.getPenManager(text, penManager);
        }

        setSize(width, height) {
            return this.setFixedSize(width, height);
        }

        resize(width, height) {
            return this.setFixedSize(width, height);
        }

        get imageManager() {
            if (!this._imageManager) {
                this._imageManager = new ImageManager(this.scene);
            }
            return this._imageManager;
        }

        addImage(key, config) {
            this.imageManager.add(key, config);
            return this;
        }

        drawAreaBounds(graphics, color) {
            this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
            return this;
        }

        generateTexture(key, x, y, width, height) {
            var srcCanvas = this.canvas;
            if (width === undefined) {
                width = srcCanvas.width;
            } else {
                width *= this.resolution;
            }
            if (height === undefined) {
                height = srcCanvas.height;
            } else {
                height *= this.resolution;
            }

            CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
            return this;
        }
    }

    var methods$G = {
        appendText: AppendText$1,
    };

    Object.assign(
        Text.prototype,
        methods$G
    );

    var SplitText = function (text, mode) {
        var TagRegex = this.tagRegex;

        var result = [];
        var charIdx = 0;
        var rawMode = false,
            escMode = false;
        while (true) {
            var regexResult = TagRegex.RE_SPLITTEXT.exec(text);
            if (!regexResult) {
                break;
            }

            var match = regexResult[0];
            if (escMode) {
                if (TagRegex.RE_ESC_CLOSE.test(match)) {
                    escMode = false;
                } else {
                    continue; // Skip other tags
                }

            } else if (rawMode) {
                if (TagRegex.RE_RAW_CLOSE.test(match)) {
                    rawMode = false;
                } else {
                    continue; // Skip other tags
                }

            } else {
                if (TagRegex.RE_ESC_OPEN.test(match)) {
                    escMode = true;
                } else if (TagRegex.RE_RAW_OPEN.test(match)) {
                    rawMode = true;
                }
            }

            var matchEnd = TagRegex.RE_SPLITTEXT.lastIndex;
            var matchStart = matchEnd - match.length;

            if (charIdx < matchStart) {
                var content = text.substring(charIdx, matchStart);
                result.push(content);
            }

            if (mode === undefined) {
                result.push(match);
            }

            charIdx = matchEnd;
        }

        var totalLen = text.length;
        if (charIdx < totalLen) { // Push remainder string
            result.push(text.substring(charIdx, totalLen));
        }

        return result; // [text,...]
    };

    const PROP_REMOVE = false;
    const PROP_ADD = true;

    var GETPROP_RESULT$1 = {
        plainText: null,
        prevProp: null
    };

    var TagTextToProp = function (text, prevProp) {
        var TagRegex = this.tagRegex;

        // text : result of splitText()
        if (prevProp == null) {
            prevProp = {};
        }
        var plainText = '';

        // close image tag
        if (prevProp.img) {
            UpdateProp(prevProp, PROP_REMOVE, 'img');
        }

        if (prevProp.esc) {
            if (TagRegex.RE_ESC_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'esc');
            } else {
                plainText = text;
            }

        } else if (prevProp.raw) {
            if (TagRegex.RE_RAW_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'raw');
            } else {
                plainText = text;
            }

        } else {
            if (TagRegex.RE_ESC_OPEN.test(text)) {
                UpdateProp(prevProp, PROP_ADD, 'esc', true);
            } else if (TagRegex.RE_ESC_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'esc');

            } else if (TagRegex.RE_RAW_OPEN.test(text)) {
                UpdateProp(prevProp, PROP_ADD, 'raw', true);
            } else if (TagRegex.RE_RAW_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'raw');

            } else if (TagRegex.RE_BLOD_OPEN.test(text)) {
                UpdateProp(prevProp, PROP_ADD, 'b', true);
            } else if (TagRegex.RE_BLOD_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'b');

            } else if (TagRegex.RE_ITALICS_OPEN.test(text)) {
                UpdateProp(prevProp, PROP_ADD, 'i', true);
            } else if (TagRegex.RE_ITALICS_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'i');

            } else if (TagRegex.RE_WEIGHT_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_WEIGHT_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'weight', innerMatch[1]);
            } else if (TagRegex.RE_WEIGHT_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'weight');

            } else if (TagRegex.RE_SIZE_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_SIZE_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'size', `${innerMatch[1]}px`);
            } else if (TagRegex.RE_SIZE_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'size');

            } else if (TagRegex.RE_FAMILY_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_FAMILY_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'family', innerMatch[1]);
            } else if (TagRegex.RE_FAMILY_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'family');

            } else if (TagRegex.RE_COLOR_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_COLOR_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'color', innerMatch[1]);
            } else if (TagRegex.RE_COLOR_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'color');

            } else if (TagRegex.RE_UNDERLINE_OPEN.test(text)) {
                UpdateProp(prevProp, PROP_ADD, 'u', true);
            } else if (TagRegex.RE_UNDERLINE_OPENC.test(text)) {
                var innerMatch = text.match(TagRegex.RE_UNDERLINE_OPENC);
                UpdateProp(prevProp, PROP_ADD, 'u', innerMatch[1]);
            } else if (TagRegex.RE_UNDERLINE_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'u');

            } else if (TagRegex.RE_STRIKETHROUGH_OPEN.test(text)) {
                UpdateProp(prevProp, PROP_ADD, 's', true);
            } else if (TagRegex.RE_STRIKETHROUGH_OPENC.test(text)) {
                var innerMatch = text.match(TagRegex.RE_STRIKETHROUGH_OPENC);
                UpdateProp(prevProp, PROP_ADD, 's', innerMatch[1]);
            } else if (TagRegex.RE_STRIKETHROUGH_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 's');

            } else if (TagRegex.RE_SHADOW_OPEN.test(text)) {
                UpdateProp(prevProp, PROP_ADD, 'shadow', true);
            } else if (TagRegex.RE_SHADOW_OPENC.test(text)) {
                var innerMatch = text.match(TagRegex.RE_SHADOW_OPENC);
                UpdateProp(prevProp, PROP_ADD, 'shadow', innerMatch[1]);
            } else if (TagRegex.RE_SHADOW_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'shadow');

            } else if (TagRegex.RE_STROKE_OPEN.test(text)) {
                UpdateProp(prevProp, PROP_ADD, 'stroke', true);
            } else if (TagRegex.RE_STROKE_OPENC.test(text)) {
                var innerMatch = text.match(TagRegex.RE_STROKE_OPENC);
                UpdateProp(prevProp, PROP_ADD, 'stroke', innerMatch[1]);
            } else if (TagRegex.RE_STROKE_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'stroke');

            } else if (TagRegex.RE_BGCOLOR_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_BGCOLOR_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'bgcolor', innerMatch[1]);
            } else if (TagRegex.RE_BGCOLOR_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'bgcolor');

            } else if (TagRegex.RE_OFFSETY_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_OFFSETY_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'y', parseFloat(innerMatch[1]));
            } else if (TagRegex.RE_OFFSETY_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'y');

            } else if (TagRegex.RE_IMAGE_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_IMAGE_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'img', innerMatch[1]);
            } else if (TagRegex.RE_IMAGE_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'img');

            } else if (TagRegex.RE_AREA_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_AREA_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'area', innerMatch[1]);
            } else if (TagRegex.RE_AREA_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'area');

            } else if (TagRegex.RE_URL_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_URL_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'url', innerMatch[1]);
            } else if (TagRegex.RE_URL_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'url');

            } else if (TagRegex.RE_ALIGN_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_ALIGN_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'align', innerMatch[1]);
            } else if (TagRegex.RE_ALIGN_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'align');

            } else if (TagRegex.RE_ID_OPEN.test(text)) {
                var innerMatch = text.match(TagRegex.RE_ID_OPEN);
                UpdateProp(prevProp, PROP_ADD, 'id', innerMatch[1]);
            } else if (TagRegex.RE_ID_CLOSE.test(text)) {
                UpdateProp(prevProp, PROP_REMOVE, 'id');

            } else {
                plainText = text;
            }
        }

        var result = GETPROP_RESULT$1;
        result.plainText = plainText;
        result.prop = prevProp;
        return result;
    };

    var UpdateProp = function (prop, op, key, value) {
        if (op === PROP_ADD) {
            // PROP_ADD     
            prop[key] = value;
        } else {
            // PROP_REMOVE        
            if (prop.hasOwnProperty(key)) {
                delete prop[key];
            }
        }

        return prop;
    };

    var PropToContextStyle = function (defaultStyle, prop) {
        var result = STYLE_RESULT$1;
        if (!prop.hasOwnProperty('img')) {
            result.image = null;

            if (prop.hasOwnProperty('family')) {
                result.fontFamily = prop.family;
            } else {
                result.fontFamily = defaultStyle.fontFamily;
            }

            if (prop.hasOwnProperty('size')) {
                var size = prop.size;
                if (typeof (size) === 'number') {
                    size = `${size}px`;
                }
                result.fontSize = size;
            } else {
                result.fontSize = defaultStyle.fontSize;
            }
            result.fontStyle = GetFontStyle(prop);

            if (prop.hasOwnProperty('color')) {
                result.color = prop.color;
            } else {
                result.color = defaultStyle.color;
            }

            if (prop.hasOwnProperty('stroke')) {
                if (prop.stroke === true) {
                    result.stroke = defaultStyle.stroke;
                    result.strokeThickness = defaultStyle.strokeThickness;
                } else {
                    result.stroke = prop.stroke;
                    result.strokeThickness = defaultStyle.strokeThickness;
                }
            } else {
                result.stroke = defaultStyle.stroke;
                result.strokeThickness = 0;
            }
        } else {
            result.image = prop.img;
        }

        if (prop.hasOwnProperty('shadow')) {
            if (prop.shadow === true) {
                result.shadowColor = defaultStyle.shadowColor;
                result.shadowOffsetX = defaultStyle.shadowOffsetX;
                result.shadowOffsetY = defaultStyle.shadowOffsetY;
                result.shadowBlur = defaultStyle.shadowBlur;
                result.shadowStroke = true;
                result.shadowFill = true;
            } else {
                result.shadowColor = prop.shadow;
                result.shadowOffsetX = defaultStyle.shadowOffsetX;
                result.shadowOffsetY = defaultStyle.shadowOffsetY;
                result.shadowBlur = defaultStyle.shadowBlur;
                result.shadowStroke = true;
                result.shadowFill = true;
            }
        } else {
            result.shadowColor = '#000';
            result.shadowOffsetX = 0;
            result.shadowOffsetY = 0;
            result.shadowBlur = 0;
            result.shadowStroke = false;
            result.shadowFill = false;
        }

        if (prop.hasOwnProperty('u')) {
            if (prop.u === true) {
                result.underlineColor = defaultStyle.underlineColor;
                result.underlineThickness = defaultStyle.underlineThickness;
                result.underlineOffset = defaultStyle.underlineOffset;
            } else {
                result.underlineColor = prop.u;
                result.underlineThickness = defaultStyle.underlineThickness;
                result.underlineOffset = defaultStyle.underlineOffset;
            }
        } else {
            result.underlineColor = '#000';
            result.underlineThickness = 0;
            result.underlineOffset = 0;
        }

        if (prop.hasOwnProperty('s')) {
            if (prop.s === true) {
                result.strikethroughColor = defaultStyle.strikethroughColor;
                result.strikethroughThickness = defaultStyle.strikethroughThickness;
                result.strikethroughOffset = defaultStyle.strikethroughOffset;
            } else {
                result.strikethroughColor = prop.s;
                result.strikethroughThickness = defaultStyle.strikethroughThickness;
                result.strikethroughOffset = defaultStyle.strikethroughOffset;
            }
        } else {
            result.strikethroughColor = '#000';
            result.strikethroughThickness = 0;
            result.strikethroughOffset = 0;
        }

        if (prop.hasOwnProperty('bgcolor')) {
            result.bgcolor = prop.bgcolor;
        } else {
            result.bgcolor = null;
        }

        return result;
    };

    var GetFontStyle = function (prop) {
        var isBold = prop.b;
        var weight = prop.weight;
        var isItalic = prop.i;

        if (isBold || weight || isItalic) {
            if (isItalic) {
                if (isBold) {
                    return 'bold italic';
                } else if (weight) {
                    return `${weight} italic`;
                } else {
                    return 'italic';
                }
            } else {  // !isItalic
                if (isBold) {
                    return 'bold';
                } else {
                    return weight.toString();
                }
            }
        } else {
            return '';
        }
    };


    var STYLE_RESULT$1 = new TextStyle$1();

    var PropToTagText = function (text, prop, prevProp) {
        if (prevProp == null) {
            prevProp = EMPTYPROP;
        }

        var delimiterLeft = this.delimiters[0];
        var delimiterRight = this.delimiters[1];

        var headers = [];

        for (var k in prevProp) {
            if (!prop.hasOwnProperty(k)) {
                headers.push(`${delimiterLeft}/${k}${delimiterRight}`);
            }
        }

        for (var k in prop) {
            var value = prop[k];


            if (k === 'img') ; else {
                if (prevProp[k] === value) {
                    continue;
                }
            }

            switch (k) {
                case 'size':
                    headers.push(`${delimiterLeft}size=${value.replace('px', '')}${delimiterRight}`);
                    break;

                case 'color':
                case 'weight':
                case 'family':
                case 'stroke':
                case 'bgcolor':
                case 'y':
                case 'img':
                case 'area':
                case 'url':
                case 'align':
                case 'id':
                    headers.push(`${delimiterLeft}${k}=${value}${delimiterRight}`);
                    break;

                case 'u':
                case 's':
                    if (value === true) {
                        headers.push(`${delimiterLeft}${k}${delimiterRight}`);
                    } else {
                        headers.push(`${delimiterLeft}${k}=${value}${delimiterRight}`);
                    }
                    break;

                default:
                    headers.push(`${delimiterLeft}${k}${delimiterRight}`);
                    break;
            }
        }

        headers.push(text);

        return headers.join('');
    };

    var EMPTYPROP = {};

    // https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js

    var EscapeRegex = function (s) {
        return s
            .replace(re0, '\\$&')
            .replace(re1, '\\x2d');
    };

    var re0 = /[|\\{}()[\]^$+*?.]/g;
    var re1 = /-/g;

    var DelimiterLeftSave;
    var DelimiterRightSave;
    var TagRegexSave = {};

    var GetOpenTagRegString = function (delimiterLeft, delimiterRight, tagName, param) {
        if (param === undefined) {
            return `${delimiterLeft}${tagName}${delimiterRight}`;
        } else {
            return `${delimiterLeft}${tagName}=(${param})${delimiterRight}`;
        }
    };
    var GetCloseTagRegString = function (delimiterLeft, delimiterRight, tagName) {
        return `${delimiterLeft}\/${tagName}${delimiterRight}`;
    };

    var GenerateStringRegEx = function (delimiterRight) {
        return `[^${delimiterRight}]+`
    };
    var NUMBER_PARAM = '[-.0-9]+';

    var colorParameterList = [
        '[a-zA-Z]+',      // 'white'
        '#[0-9abcdef]+',  // '#FFFFFF'
        'rgba?\\(\s*[.0-9]+\s*(,\s*[.0-9]+\s*){2,3}\\)',  // rgb(255,255,255), or rgba(255,255,255,1)
    ];
    var COLOR_PARAM = colorParameterList.join('|');  // '[a-z]+|#[0-9abcdef]+'

    var SetDelimiters = function (delimiterLeft, delimiterRight) {
        if (delimiterRight === undefined) {
            var delimeters = delimiterLeft;
            delimiterLeft = delimeters[0];
            delimiterRight = delimeters[1];
        }

        if ((DelimiterLeftSave === delimiterLeft) && (DelimiterRightSave === delimiterRight)) {
            return false;
        }

        DelimiterLeftSave = delimiterLeft;
        DelimiterRightSave = delimiterRight;

        delimiterLeft = EscapeRegex(delimiterLeft);
        delimiterRight = EscapeRegex(delimiterRight);

        var STR_PARAM = GenerateStringRegEx(delimiterRight);

        var ESC = 'esc';
        var ESC_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ESC);
        var ESC_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ESC);

        var RAW = 'raw';
        var RAW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, RAW);
        var RAW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, RAW);

        var BLOD = 'b';
        var BLOD_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BLOD);
        var BLOD_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BLOD);

        var ITALICS = 'i';
        var ITALICS_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ITALICS);
        var ITALICS_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ITALICS);

        var WEIGHT = 'weight';
        var WEIGHT_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, WEIGHT, NUMBER_PARAM);
        var WEIGHT_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, WEIGHT);

        var SIZE = 'size';
        var SIZE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SIZE, NUMBER_PARAM);
        var SIZE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SIZE);

        var FAMILY = 'family';
        var FAMILY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, FAMILY, STR_PARAM);
        var FAMILY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, FAMILY);

        var COLOR = 'color';
        var COLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, COLOR, COLOR_PARAM);
        var COLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, COLOR);

        var UNDERLINE = 'u';
        var UNDERLINE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
        var UNDERLINE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE, COLOR_PARAM);
        var UNDERLINE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, UNDERLINE);

        var STRIKETHROUGH = 's';
        var STRIKETHROUGH_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
        var STRIKETHROUGH_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH, COLOR_PARAM);
        var STRIKETHROUGH_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);

        var SHADOW = 'shadow';
        var SHADOW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW);
        var SHADOW_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW, COLOR_PARAM);
        var SHADOW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SHADOW);

        var STROKE = 'stroke';
        var STROKE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE);
        var STROKE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE, COLOR_PARAM);
        var STROKE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STROKE);

        var BGCOLOR = 'bgcolor';
        var BGCOLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BGCOLOR, COLOR_PARAM);
        var BGCOLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BGCOLOR);

        var OFFSETY = 'y';
        var OFFSETY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, OFFSETY, NUMBER_PARAM);
        var OFFSETY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, OFFSETY);

        var IMAGE = 'img';
        var IMAGE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, IMAGE, STR_PARAM);
        var IMAGE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, IMAGE);

        var AREA = 'area';
        var AREA_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, AREA, STR_PARAM);
        var AREA_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, AREA);

        var URL = 'url';
        var URL_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, URL, STR_PARAM);
        var URL_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, URL);

        var ALIGN = 'align';
        var ALIGN_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ALIGN, STR_PARAM);
        var ALIGN_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ALIGN);

        var ID = 'id';
        var ID_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ID, STR_PARAM);
        var ID_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ID);

        TagRegexSave.RE_ESC_OPEN = new RegExp(ESC_OPEN, 'i');
        TagRegexSave.RE_ESC_CLOSE = new RegExp(ESC_CLOSE, 'i');

        TagRegexSave.RE_RAW_OPEN = new RegExp(RAW_OPEN, 'i');
        TagRegexSave.RE_RAW_CLOSE = new RegExp(RAW_CLOSE, 'i');

        TagRegexSave.RE_BLOD_OPEN = new RegExp(BLOD_OPEN, 'i');
        TagRegexSave.RE_BLOD_CLOSE = new RegExp(BLOD_CLOSE, 'i');

        TagRegexSave.RE_ITALICS_OPEN = new RegExp(ITALICS_OPEN, 'i');
        TagRegexSave.RE_ITALICS_CLOSE = new RegExp(ITALICS_CLOSE, 'i');

        TagRegexSave.RE_WEIGHT_OPEN = new RegExp(WEIGHT_OPEN, 'i');
        TagRegexSave.RE_WEIGHT_CLOSE = new RegExp(WEIGHT_CLOSE, 'i');

        TagRegexSave.RE_SIZE_OPEN = new RegExp(SIZE_OPEN, 'i');
        TagRegexSave.RE_SIZE_CLOSE = new RegExp(SIZE_CLOSE, 'i');

        TagRegexSave.RE_FAMILY_OPEN = new RegExp(FAMILY_OPEN, 'i');
        TagRegexSave.RE_FAMILY_CLOSE = new RegExp(FAMILY_CLOSE, 'i');

        TagRegexSave.RE_COLOR_OPEN = new RegExp(COLOR_OPEN, 'i');
        TagRegexSave.RE_COLOR_CLOSE = new RegExp(COLOR_CLOSE, 'i');

        TagRegexSave.RE_UNDERLINE_OPEN = new RegExp(UNDERLINE_OPEN, 'i');
        TagRegexSave.RE_UNDERLINE_OPENC = new RegExp(UNDERLINE_OPENC, 'i');
        TagRegexSave.RE_UNDERLINE_CLOSE = new RegExp(UNDERLINE_CLOSE, 'i');

        TagRegexSave.RE_STRIKETHROUGH_OPEN = new RegExp(STRIKETHROUGH_OPEN, 'i');
        TagRegexSave.RE_STRIKETHROUGH_OPENC = new RegExp(STRIKETHROUGH_OPENC, 'i');
        TagRegexSave.RE_STRIKETHROUGH_CLOSE = new RegExp(STRIKETHROUGH_CLOSE, 'i');

        TagRegexSave.RE_SHADOW_OPEN = new RegExp(SHADOW_OPEN, 'i');
        TagRegexSave.RE_SHADOW_OPENC = new RegExp(SHADOW_OPENC, 'i');
        TagRegexSave.RE_SHADOW_CLOSE = new RegExp(SHADOW_CLOSE, 'i');

        TagRegexSave.RE_STROKE_OPEN = new RegExp(STROKE_OPEN, 'i');
        TagRegexSave.RE_STROKE_OPENC = new RegExp(STROKE_OPENC, 'i');
        TagRegexSave.RE_STROKE_CLOSE = new RegExp(STROKE_CLOSE, 'i');

        TagRegexSave.RE_BGCOLOR_OPEN = new RegExp(BGCOLOR_OPEN, 'i');
        TagRegexSave.RE_BGCOLOR_CLOSE = new RegExp(BGCOLOR_CLOSE, 'i');

        TagRegexSave.RE_OFFSETY_OPEN = new RegExp(OFFSETY_OPEN, 'i');
        TagRegexSave.RE_OFFSETY_CLOSE = new RegExp(OFFSETY_CLOSE, 'i');

        TagRegexSave.RE_IMAGE_OPEN = new RegExp(IMAGE_OPEN, 'i');
        TagRegexSave.RE_IMAGE_CLOSE = new RegExp(IMAGE_CLOSE, 'i');

        TagRegexSave.RE_AREA_OPEN = new RegExp(AREA_OPEN, 'i');
        TagRegexSave.RE_AREA_CLOSE = new RegExp(AREA_CLOSE, 'i');

        TagRegexSave.RE_URL_OPEN = new RegExp(URL_OPEN, 'i');
        TagRegexSave.RE_URL_CLOSE = new RegExp(URL_CLOSE, 'i');

        TagRegexSave.RE_ALIGN_OPEN = new RegExp(ALIGN_OPEN, 'i');
        TagRegexSave.RE_ALIGN_CLOSE = new RegExp(ALIGN_CLOSE, 'i');

        TagRegexSave.RE_ID_OPEN = new RegExp(ID_OPEN, 'i');
        TagRegexSave.RE_ID_CLOSE = new RegExp(ID_CLOSE, 'i');

        TagRegexSave.RE_SPLITTEXT = new RegExp([
            RAW_OPEN, RAW_CLOSE,
            ESC_OPEN, ESC_CLOSE,

            BLOD_OPEN, BLOD_CLOSE,
            ITALICS_OPEN, ITALICS_CLOSE,
            WEIGHT_OPEN, WEIGHT_CLOSE,

            SIZE_OPEN, SIZE_CLOSE,
            FAMILY_OPEN, FAMILY_CLOSE,
            COLOR_OPEN, COLOR_CLOSE,
            UNDERLINE_OPEN, UNDERLINE_OPENC, UNDERLINE_CLOSE,
            STRIKETHROUGH_OPEN, STRIKETHROUGH_OPENC, STRIKETHROUGH_CLOSE,
            SHADOW_OPEN, SHADOW_OPENC, SHADOW_CLOSE,
            STROKE_OPEN, STROKE_OPENC, STROKE_CLOSE,
            BGCOLOR_OPEN, BGCOLOR_CLOSE,
            OFFSETY_OPEN, OFFSETY_CLOSE,
            IMAGE_OPEN, IMAGE_CLOSE,
            AREA_OPEN, AREA_CLOSE,
            URL_OPEN, URL_CLOSE,
            ALIGN_OPEN, ALIGN_CLOSE,
            ID_OPEN, ID_CLOSE
        ].join('|'), 'ig');

        return true;
    };

    var GetTagRegex = function (delimiterLeft, delimiterRight) {
        if (delimiterLeft !== undefined) {
            SetDelimiters(delimiterLeft, delimiterRight);
        }

        return Object.assign({}, TagRegexSave);
    };

    const GetValue$3J = Phaser.Utils.Objects.GetValue;

    let Parser$2 = class Parser {
        constructor(style) {
            var delimiters = GetValue$3J(style, 'delimiters', '[]');
            this.tagRegex = GetTagRegex(delimiters);
            this.delimiters = delimiters;
        }

        getStrokeThinkness(defaultStyle, prop) {
            var strokeThickness;
            if (prop.hasOwnProperty('stroke')) {
                strokeThickness = defaultStyle.strokeThickness;
            } else {
                strokeThickness = 0;
            }
            return strokeThickness;
        }

        setDelimiters(delimiterLeft, delimiterRight) {
            if (SetDelimiters(delimiterLeft, delimiterRight)) {
                this.tagRegex = GetTagRegex();
            }
            return this;
        }

    };

    var methods$F = {
        splitText: SplitText,
        tagTextToProp: TagTextToProp,
        propToContextStyle: PropToContextStyle,
        propToTagText: PropToTagText,
    };

    Object.assign(
        Parser$2.prototype,
        methods$F
    );

    class BBCodeText extends Text {
        constructor(scene, x, y, text, style) {
            var parser = new Parser$2(style);
            super(scene, x, y, text, style, 'rexBBCodeText', parser);
        }

        setDelimiters(delimiterLeft, delimiterRight) {
            this.parser.setDelimiters(delimiterLeft, delimiterRight);
            return this;
        }
    }

    ObjectFactory.register('BBCodeText', function (x, y, text, style) {
        var gameObject = new BBCodeText(this.scene, x, y, text, style);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.BBCodeText', BBCodeText);

    var GETPROP_RESULT = {
        plainText: null,
        prevProp: null
    };

    var STYLE_RESULT = new TextStyle$1();

    let Parser$1 = class Parser {
        constructor(tags) {
            if (tags === undefined) {
                tags = {};
            }
            this.tags = tags;
        }

        addTag(name, prop) {
            this.tags[name] = prop;
        }

        getTag(name) {
            return this.tags[name];
        }

        splitText(text, mode) {
            var result = [];
            var charIdx = 0;
            while (true) {
                var regexResult = RE_SPLITTEXT.exec(text);
                if (!regexResult) {
                    break;
                }

                var match = regexResult[0];
                var matchStart = RE_SPLITTEXT.lastIndex - match.length;

                if (charIdx < matchStart) {
                    result.push(text.substring(charIdx, matchStart));
                }
                if (mode === undefined) {
                    result.push(match);
                } else if (mode === 1) { // RAWTEXTONLY_MODE
                    if (RE_CLASS_HEADER.test(match)) {
                        var innerMatch = match.match(RE_CLASS);
                        result.push(innerMatch[2]);
                    } else if (RE_STYLE_HEADER.test(match)) {
                        var innerMatch = match.match(RE_STYLE);
                        result.push(innerMatch[2]);
                    }
                }

                charIdx = RE_SPLITTEXT.lastIndex;
            }

            var totalLen = text.length;
            if (charIdx < totalLen) {  // Push remainder string
                result.push(text.substring(charIdx, totalLen));
            }

            return result; // [text,...]         
        }

        tagTextToProp(text, prevProp) {
            var plainText, propOut;
            if (RE_CLASS_HEADER.test(text)) {
                var innerMatch = text.match(RE_CLASS);
                if (innerMatch != null) {
                    var name = innerMatch[1];
                    var tags = this.tags;
                    if (tags.hasOwnProperty(name)) {
                        propOut = tags[name];
                    } else {
                        propOut = {};
                    }
                    propOut._class = name;
                    plainText = innerMatch[2];
                }
            } else if (RE_STYLE_HEADER.test(text)) {
                var innerMatch = text.match(RE_STYLE);
                if (innerMatch != null) {
                    var style = innerMatch[1];
                    propOut = StyleToProp(style);
                    propOut._style = style;
                    plainText = innerMatch[2];
                }
            }

            if (plainText == null) {
                plainText = text;
            }

            if (propOut == null) {
                propOut = {};
            }

            var result = GETPROP_RESULT;
            result.plainText = plainText;
            result.prop = propOut;
            return result;
        }

        propToContextStyle(defaultStyle, prop) {
            var result = STYLE_RESULT;
            if (!prop.hasOwnProperty('img')) {
                result.image = null;

                if (prop.hasOwnProperty('family') || prop.hasOwnProperty('fontFamily') || prop.hasOwnProperty('font-family')) {
                    var family = (prop.hasOwnProperty('family')) ? prop.family :
                        (prop.hasOwnProperty('fontFamily')) ? prop.fontFamily :
                            prop['font-family'];
                    result.fontFamily = family;
                } else {
                    result.fontFamily = defaultStyle.fontFamily;
                }

                if (prop.hasOwnProperty('size') || prop.hasOwnProperty('fontSize') || prop.hasOwnProperty('font-size')) {
                    var size = (prop.hasOwnProperty('size')) ? prop.size :
                        (prop.hasOwnProperty('fontSize')) ? prop.fontSize :
                            prop['font-size'];
                    if (typeof (size) === 'number') {
                        size = `${size}px`;
                    }
                    result.fontSize = size;
                } else {
                    result.fontSize = defaultStyle.fontSize;
                }

                if (prop.hasOwnProperty('style') || prop.hasOwnProperty('fontStyle') || prop.hasOwnProperty('font-style')) {
                    var fontStyle = (prop.hasOwnProperty('style')) ? prop.style :
                        (prop.hasOwnProperty('fontStyle')) ? prop.fontStyle :
                            prop['font-style'];
                    result.fontStyle = fontStyle;
                } else {
                    result.fontStyle = defaultStyle.fontStyle;
                }

                if (prop.hasOwnProperty('color') || prop.hasOwnProperty('font-color')) {
                    var color = (prop.hasOwnProperty('color')) ? prop.color : prop['font-color'];
                    result.color = color;
                } else {
                    result.color = defaultStyle.color;
                }

                if (prop.hasOwnProperty('stroke')) {
                    var stroke = prop.stroke; // {color, thickness}
                    result.stroke = (stroke.hasOwnProperty('color')) ? stroke.color : defaultStyle.stroke;
                    result.strokeThickness = (stroke.hasOwnProperty('thickness')) ? stroke.thickness : defaultStyle.strokeThickness;
                } else {
                    result.stroke = defaultStyle.stroke;
                    result.strokeThickness = defaultStyle.strokeThickness;
                }
            } else {
                result.image = prop.img;
            }

            if (prop.hasOwnProperty('shadow')) {
                var shadow = prop.shadow; // {color, offsetX, offsetY, blur}
                result.shadowColor = (shadow.hasOwnProperty('color')) ? shadow.color : defaultStyle.shadowColor;
                result.shadowOffsetX = (shadow.hasOwnProperty('offsetX')) ? shadow.offsetX : defaultStyle.shadowOffsetX;
                result.shadowOffsetY = (shadow.hasOwnProperty('offsetY')) ? shadow.offsetY : defaultStyle.shadowOffsetY;
                result.shadowBlur = (shadow.hasOwnProperty('blur')) ? shadow.blur : defaultStyle.shadowBlur;
                result.shadowStroke = true;
                result.shadowFill = true;
            } else {
                result.shadowColor = defaultStyle.shadowColor;
                result.shadowOffsetX = defaultStyle.shadowOffsetX;
                result.shadowOffsetY = defaultStyle.shadowOffsetY;
                result.shadowBlur = defaultStyle.shadowBlur;
                result.shadowStroke = defaultStyle.shadowStroke;
                result.shadowFill = defaultStyle.shadowFill;
            }

            if (prop.hasOwnProperty('u') || prop.hasOwnProperty('underline')) {
                var u = (prop.hasOwnProperty('u')) ? prop.u : prop.underline; // {color, thickness, offset}
                result.underlineColor = (u.hasOwnProperty('color')) ? u.color : defaultStyle.underlineColor;
                result.underlineThickness = (u.hasOwnProperty('thickness')) ? u.thickness : defaultStyle.underlineThickness;
                result.underlineOffset = (u.hasOwnProperty('offset')) ? u.offset : defaultStyle.underlineOffset;
            } else {
                result.underlineColor = defaultStyle.underlineColor;
                result.underlineThickness = defaultStyle.underlineThickness;
                result.underlineOffset = defaultStyle.underlineOffset;
            }

            if (prop.hasOwnProperty('s') || prop.hasOwnProperty('strikethrough')) {
                var s = (prop.hasOwnProperty('s')) ? prop.s : prop.strikethrough; // {color, thickness, offset}
                result.strikethroughColor = (s.hasOwnProperty('color')) ? s.color : defaultStyle.strikethroughColor;
                result.strikethroughThickness = (s.hasOwnProperty('thickness')) ? s.thickness : defaultStyle.strikethroughThickness;
                result.strikethroughOffset = (s.hasOwnProperty('offset')) ? s.offset : defaultStyle.strikethroughOffset;
            } else {
                result.strikethroughColor = defaultStyle.strikethroughColor;
                result.strikethroughThickness = defaultStyle.strikethroughThickness;
                result.strikethroughOffset = defaultStyle.strikethroughOffset;
            }

            return result;
        }

        getStrokeThinkness(defaultStyle, prop) {
            var strokeThinkness;
            if (prop.hasOwnProperty('stroke')) {
                var stroke = prop.stroke; // {color, thickness}           
                strokeThinkness = (stroke.hasOwnProperty('thickness')) ? stroke.thickness : defaultStyle.strokeThickness;
            } else {
                strokeThinkness = defaultStyle.strokeThickness;
            }
            return strokeThinkness;
        }

        propToTagText(text, prop, prevProp) {
            if (prop.hasOwnProperty('_class')) { // class mode
                if (text === '') {
                    if (this.isTextTag(prop._class)) {
                        return '';
                    }
                }
                return `<class='${prop._class}'>${text}</class>`;
            } else if (prop.hasOwnProperty('_style')) { // class mode
                return `<style='${prop._style}'>${text}</style>`;
            } else {
                return text;
            }
        }

        destroy() {
            this.tags = undefined;
        }

        isTextTag(tagName) {
            var tag = this.tags[tagName];
            if (tag) {
                return (tag.img == null);
            } else { // tag not found
                return false;
            }
        }
    };
    var StyleToProp = function (s) {
        s = s.split(";");

        var result = {},
            prop, k, v;
        for (var i = 0, slen = s.length; i < slen; i++) {
            prop = s[i].split(":");
            k = prop[0], v = prop[1];
            if (isEmpty(k) || isEmpty(v)) {
                continue;
            }

            switch (k) {
                case 'stroke':
                    var params = v.split(' '); // stroke:blue 1px
                    var len = params.length;
                    v = {};
                    if (len >= 1) {
                        v.color = params[0];
                    }
                    if (len >= 2) {
                        v.thickness = parseInt(params[1].replace('px', ''));
                    }
                    break;

                case 'shadow':
                    var params = v.split(' '); // shadow:blue 2px 2px 2px
                    var len = params.length;
                    v = {};
                    if (len >= 1) {
                        v.color = params[0];
                    }
                    if (len >= 2) {
                        v.offsetX = parseInt(params[1].replace('px', ''));
                    }
                    if (len >= 3) {
                        v.offsetY = parseInt(params[2].replace('px', ''));
                    }
                    if (len >= 4) {
                        v.blur = parseInt(params[3].replace('px', ''));
                    }
                    break;

                case 'u':
                case 'underline':
                case 's':
                case 'strikethrough':  // underline:blue 3px -1px
                    var params = v.split(' ');
                    var len = params.length;
                    v = {};
                    if (len >= 1) {
                        v.color = params[0];
                    }
                    if (len >= 2) {
                        v.thickness = parseInt(params[1].replace('px', ''));
                    }
                    if (len >= 3) {
                        v.offset = parseInt(params[2].replace('px', ''));
                    }

                    if (k === 'underline') {
                        k = 'u';
                    } else if (k === 'strikethrough') {
                        k = 's';
                    }
                    break;

                case 'y':
                    v = parseFloat(v);
                    break;
            }
            result[k] = v;
        }
        return result;
    };

    var isEmpty = function (s) {
        // Remove white spaces.
        s = s.replace(RE_SPACE, '');
        return (s.length === 0);
    };

    var RE_SPLITTEXT = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>|<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/g;
    var RE_CLASS_HEADER = /<\s*class=/i;
    var RE_CLASS = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>/;
    var RE_STYLE_HEADER = /<\s*style=/i;
    var RE_STYLE = /<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/;
    var RE_SPACE = /^\s+|\s+$/;

    const GetValue$3I = Phaser.Utils.Objects.GetValue;

    class TagText extends Text {
        constructor(scene, x, y, text, style) {
            var tags = GetValue$3I(style, 'tags', undefined);
            var parser = new Parser$1(tags);
            super(scene, x, y, text, style, 'rexTagText', parser);
        }

        addTag(name, prop) {
            this.parser.addTag(name, prop);
            return this.updateText(true);
        }

        addTags(tags) {
            for (var name in tags) {
                this.parser.addTag(name, tags[name]);
            }
            return this.updateText(true);
        }

        getTag(name) {
            return this.parser.getTag(name);
        }

        preDestroy() {
            super.preDestroy();
            this.parser.destroy();
            this.parser = undefined;
        }
    }

    ObjectFactory.register('tagText', function (x, y, text, style) {
        var gameObject = new TagText(this.scene, x, y, text, style);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TagText', TagText);

    const GetValue$3H = Phaser.Utils.Objects.GetValue;

    var GetPadding$1 = function (padding, key) {
        if (key === undefined) {
            return padding;
        }
        return padding[key];
    };

    var SetPadding$1 = function (padding, key, value) {
        if (padding === undefined) {
            padding = {};
        }
        if (key === undefined) {
            key = 0;
        }

        var keyType = typeof (key);
        if (keyType === 'string') {
            padding[key] = value;
        } else if (keyType === 'number') {
            padding.left = key;
            padding.right = key;
            padding.top = key;
            padding.bottom = key;
        } else {
            padding.left = GetValue$3H(key, 'left', 0);
            padding.right = GetValue$3H(key, 'right', 0);
            padding.top = GetValue$3H(key, 'top', 0);
            padding.bottom = GetValue$3H(key, 'bottom', 0);
        }
        return padding;
    };

    let Base$3 = class Base {
        constructor(parent, type) {
            this.setParent(parent);
            this.type = type;
            this.renderable = false;

            this.reset().setActive();
        }

        destroy() {
            this.parent.removeChild(this);
        }

        setParent(parent) {
            this.parent = parent;
            return this;
        }

        get scene() {
            return this.parent.scene;
        }

        get canvas() {
            return (this.parent) ? this.parent.canvas : null;
        }

        get context() {
            return (this.parent) ? this.parent.context : null;
        }

        setDirty(dirty) {
            if (dirty && this.parent) {
                this.parent.dirty = true;
            }
            return this;
        }

        get active() {
            return this._active;
        }

        set active(value) {
            this.setDirty(this._active != value);
            this._active = value;
        }

        setActive(active) {
            if (active === undefined) {
                active = true;
            }
            this.active = active;
            return this;
        }

        modifyPorperties(o) {
            return this;
        }

        // Override
        onFree() {
            this.reset().setParent();
        }

        // Override
        reset() {
            return this;
        }

        // Override
        render() { }

        // Override
        contains(x, y) {
            return false;
        }
    };

    Object.assign(
        Base$3.prototype,
        DataMethods$2
    );

    var RenderMethods = {
        // Override
        renderContent() {

        },

        // Override
        render() {
            if (!this.willRender) {
                return this;
            }

            var context = this.context;
            context.save();
            context.globalAlpha = this.alpha;

            if (this.toLocalPosition) {
                var x = this.drawX, y = this.drawY;
                if (this.autoRound) {
                    x = Math.round(x);
                    y = Math.round(y);
                }

                context.translate(x, y);
                context.scale(this.scaleX, this.scaleY);
                context.rotate(this.rotation);
            }

            if (this.drawBelowCallback) {
                this.drawBelowCallback(this);
            }

            this.renderContent();

            if (this.drawAboveCallback) {
                this.drawAboveCallback(this);
            }

            context.restore();

            return this;
        },
    };

    const RotateAround$8 = Phaser.Math.RotateAround;

    var CanvasPositionToBobPosition = function (canvasX, canvasY, bob, out) {
        if (out === undefined) {
            out = {};
        } else if (out === true) {
            if (globPoint$1 === undefined) {
                globPoint$1 = {};
            }
            out = globPoint$1;
        }

        out.x = (canvasX - bob.drawX) / bob.scaleX;
        out.y = (canvasY - bob.drawY) / bob.scaleY;

        if (bob.rotation !== 0) {
            RotateAround$8(out, 0, 0, -bob.rotation);
        }
        return out;
    };

    var globPoint$1;

    const Rectangle$5 = Phaser.Geom.Rectangle;

    var Contains$2 = function (canvasX, canvasY) {
        if ((this.width === 0) || (this.height === 0)) {
            return false;
        }

        var bobPosition = CanvasPositionToBobPosition(canvasX, canvasY, this, true);
        return GetBobBounds(this).contains(bobPosition.x, bobPosition.y);
    };

    var GetBobBounds = function (bob) {
        if (bobBounds === undefined) {
            bobBounds = new Rectangle$5();
        }

        var x = bob.drawTLX,
            y = bob.drawTLY;
        bobBounds.setTo(x, y, (bob.drawTRX - x), (bob.drawBLY - y));

        return bobBounds;
    };

    var bobBounds;

    const RotateAround$7 = Phaser.Math.RotateAround;

    var BobPositionToCanvasPosition = function (bob, bobX, bobY, out) {
        if (out === undefined) {
            out = {};
        } else if (out === true) {
            if (globPoint === undefined) {
                globPoint = {};
            }
            out = globPoint;
        }

        out.x = bobX;
        out.y = bobY;

        if (bob.rotation !== 0) {
            RotateAround$7(out, 0, 0, bob.rotation);
        }

        out.x = (out.x * bob.scaleX) + bob.drawX;
        out.y = (out.y * bob.scaleY) + bob.drawY;

        return out;
    };

    var globPoint;

    const TransformMatrix$1 = Phaser.GameObjects.Components.TransformMatrix;

    var GameObjectLocalXYToWorldXY = function (gameObject, localX, localY, out) {
        if (out === undefined) {
            out = {};
        } else if (out === true) {
            out = globOut$2;
        }

        var px = localX - (gameObject.width * gameObject.originX);
        var py = localY - (gameObject.height * gameObject.originY);

        if (tempMatrix$2 === undefined) {
            tempMatrix$2 = new TransformMatrix$1();
            parentMatrix$1 = new TransformMatrix$1();
        }

        if (gameObject.parentContainer) {
            gameObject.getWorldTransformMatrix(tempMatrix$2, parentMatrix$1);
        }
        else {
            tempMatrix$2.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY);
        }

        tempMatrix$2.transformPoint(px, py, out);

        return out;
    };

    var tempMatrix$2, parentMatrix$1;
    var globOut$2 = {};

    var BobPositionToWorldPosition = function (dynamicText, bob, bobX, bobY, out) {
        var localXY = BobPositionToCanvasPosition(bob, bobX, bobY, true);
        var worldXY = GameObjectLocalXYToWorldXY(dynamicText, localXY.x, localXY.y, out);
        return worldXY;
    };

    var GetBobWorldPosition = function (dynamicText, bob, offsetX, offsetY, out) {
        if (typeof (offsetX) !== 'number') {
            out = offsetX;
            offsetX = 0;
            offsetY = 0;
        }
        var bobX = bob.drawCenterX + offsetX;
        var bobY = bob.drawCenterY + offsetY;
        return BobPositionToWorldPosition(dynamicText, bob, bobX, bobY, out);
    };

    var GetWorldPosition = function (offsetX, offsetY, out) {
        return GetBobWorldPosition(this.parent, this, offsetX, offsetY, out);
    };

    var Methods$k = {
        contains: Contains$2,
        getWorldPosition: GetWorldPosition,
    };

    Object.assign(
        Methods$k,
        RenderMethods
    );

    const DegToRad$g = Phaser.Math.DegToRad;
    const RadToDeg$d = Phaser.Math.RadToDeg;
    const GetValue$3G = Phaser.Utils.Objects.GetValue;

    class RenderBase extends Base$3 {
        constructor(parent, type) {
            super(parent, type);

            this.renderable = true;
            this.scrollFactorX = 1;
            this.scrollFactorY = 1;
            this.toLocalPosition = true;
            this.originX = 0;
            this.offsetX = 0;  // Override
            this.offsetY = 0;  // Override
        }

        get visible() {
            return this._visible;
        }

        set visible(value) {
            this.setDirty(this._visible != value);
            this._visible = value;
        }

        setVisible(visible) {
            if (visible === undefined) {
                visible = true;
            }

            this.visible = visible;
            return this;
        }

        get alpha() { return this._alpha; }

        set alpha(value) {
            this.setDirty(this._alpha != value);
            this._alpha = value;
        }

        setAlpha(alpha) {
            this.alpha = alpha;
            return this;
        }

        get x() { return this._x; }

        set x(value) {
            this.setDirty(this._x != value);
            this._x = value;
        }

        setX(x) {
            this.x = x;
            return this;
        }

        get y() { return this._y; }

        set y(value) {
            this.setDirty(this._y != value);
            this._y = value;
        }

        setY(y) {
            this.y = y;
            return this;
        }

        setPosition(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }

        setInitialPosition(x, y) {
            this.x0 = x;
            this.y0 = y;
            return this;
        }

        setScrollFactorX(x) {
            this.scrollFactorX = x;
            return this;
        }

        setScrollFactorY(y) {
            this.scrollFactorY = y;
            return this;
        }

        setScrollFactor(x, y) {
            if (y === undefined) {
                y = x;
            }
            this.scrollFactorX = x;
            this.scrollFactorY = y;
            return this;
        }

        get rotation() { return this._rotation; }

        set rotation(value) {
            this.setDirty(this._rotation != value);
            this._rotation = value;
        }

        setRotation(rotation) {
            this.rotation = rotation;
            return this;
        }

        get angle() { return RadToDeg$d(this._rotation); }

        set angle(value) {
            this.rotation = DegToRad$g(value);
        }

        setAngle(angle) {
            this.angle = angle;
            return this;
        }

        get scaleX() { return this._scaleX; }

        set scaleX(value) {
            this.setDirty(this._scaleX !== value);
            this._scaleX = value;
        }

        setScaleX(scaleX) {
            this.scaleX = scaleX;
            return this;
        }

        // Override
        get width() { return 0; }

        // Override
        set width(value) { }

        setWidth(width, keepAspectRatio) {
            if (keepAspectRatio === undefined) {
                keepAspectRatio = false;
            }
            this.width = width;

            if (keepAspectRatio) {
                this.scaleY = this.scaleX;
            }
            return this;
        }

        get leftSpace() { return this._leftSpace; }

        set leftSpace(value) {
            this.setDirty(this._leftSpace !== value);
            this._leftSpace = value;
        }

        setLeftSpace(value) {
            this.leftSpace = value;
            return this;
        }

        get rightSpace() { return this._rightSpace; }

        set rightSpace(value) {
            this.setDirty(this._rightSpace !== value);
            this._rightSpace = value;
        }

        setRightSpace(value) {
            this.rightSpace = value;
            return this;
        }

        get outerWidth() {
            return this.width + this.leftSpace + this.rightSpace;
        }

        get scaleY() { return this._scaleY; }

        set scaleY(value) {
            this.setDirty(this._scaleY !== value);
            this._scaleY = value;
        }

        setScaleY(scaleY) {
            this.scaleY = scaleY;
            return this;
        }

        // Override
        get height() { return 0; }

        // Override
        set height(value) { }

        setHeight(height, keepAspectRatio) {
            if (keepAspectRatio === undefined) {
                keepAspectRatio = false;
            }
            this.height = height;

            if (keepAspectRatio) {
                this.scaleX = this.scaleY;
            }
            return this;
        }

        setScale(scaleX, scaleY) {
            if (scaleY === undefined) {
                scaleY = scaleX;
            }

            this.scaleX = scaleX;
            this.scaleY = scaleY;
            return this;
        }

        setOrigin(x) {
            this.originX = x;
            return this;
        }

        setAlign(align) {
            this.align = align;
            return this;
        }

        modifyPorperties(o) {
            if (!o) {
                return this;
            }

            if (o.hasOwnProperty('x')) {
                this.setX(o.x);
            }
            if (o.hasOwnProperty('y')) {
                this.setY(o.y);
            }

            if (o.hasOwnProperty('rotation')) {
                this.setRotation(o.rotation);
            } else if (o.hasOwnProperty('angle')) {
                this.setAngle(o.angle);
            }

            if (o.hasOwnProperty('alpha')) {
                this.setAlpha(o.alpha);
            }

            // ScaleX, ScaleY
            var width = GetValue$3G(o, 'width', undefined);
            var height = GetValue$3G(o, 'height', undefined);
            var scaleX = GetValue$3G(o, 'scaleX', undefined);
            var scaleY = GetValue$3G(o, 'scaleY', undefined);

            if (width !== undefined) {
                if ((height === undefined) && (scaleY === undefined)) {
                    this.setWidth(width, true);
                } else {
                    this.setWidth(width);
                }
            } else if (scaleX !== undefined) {
                this.setScaleX(scaleX);
            }
            if (height !== undefined) {
                if ((width === undefined) && (scaleX === undefined)) {
                    this.setHeight(height, true);
                } else {
                    this.setHeight(height);
                }
            } else if (scaleY !== undefined) {
                this.setScaleY(scaleY);
            }

            if (o.hasOwnProperty('leftSpace')) {
                this.setLeftSpace(o.leftSpace);
            }
            if (o.hasOwnProperty('rightSpace')) {
                this.setRightSpace(o.rightSpace);
            }

            if (o.hasOwnProperty('align')) {
                this.setAlign(o.align);
            }

            return this;
        }

        setDrawBelowCallback(callback) {
            this.drawBelowCallback = callback;
            return this;
        }

        setDrawAboveCallback(callback) {
            this.drawAboveCallback = callback;
            return this;
        }

        reset() {
            this
                .setVisible()
                .setAlpha(1)
                .setPosition(0, 0)
                .setRotation(0)
                .setScale(1, 1)
                .setLeftSpace(0).setRightSpace(0)
                .setOrigin(0)
                .setAlign()
                .setDrawBelowCallback()
                .setDrawAboveCallback();
            return this;
        }

        // Override
        get willRender() {
            return this.visible && (this.alpha > 0);
        }

        get drawX() {
            var x = this.x + this.leftSpace + this.offsetX - (this.originX * this.width);
            return (this.parent._textOX * this.scrollFactorX) + x;
        }
        get drawY() {
            var y = this.y + this.offsetY;
            return (this.parent._textOY * this.scrollFactorY) + y;
        }

        // Override
        get drawTLX() { return 0; }
        get drawTLY() { return 0; }
        get drawBLX() { return 0; }
        get drawBLY() { return 0; }
        get drawTRX() { return 0; }
        get drawTRY() { return 0; }
        get drawBRX() { return 0; }
        get drawBRY() { return 0; }

        get drawCenterX() {
            return (this.drawTRX + this.drawTLX) / 2;
        }
        get drawCenterY() {
            return (this.drawBLY + this.drawTLY) / 2;
        }
    }

    Object.assign(
        RenderBase.prototype,
        Methods$k,
    );

    var GetProperty = function (name, config, defaultConfig) {
        if (config.hasOwnProperty(name)) {
            return config[name];
        } else {
            return defaultConfig[name];
        }
    };

    const GetValue$3F = Phaser.Utils.Objects.GetValue;

    class Background extends RenderBase {
        constructor(parent, config) {
            super(parent, 'background');

            this.setScrollFactor(0);

            this.setColor(
                GetValue$3F(config, 'color', null),
                GetValue$3F(config, 'color2', null),
                GetValue$3F(config, 'horizontalGradient', true)
            );

            this.setStroke(
                GetValue$3F(config, 'stroke', null),
                GetValue$3F(config, 'strokeThickness', 2)
            );

            this.setCornerRadius(
                GetValue$3F(config, 'cornerRadius', 0),
                GetValue$3F(config, 'cornerIteration', null)
            );
        }

        set color(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.setDirty(this._color != value);
            this._color = value;
        }

        get color() {
            return this._color;
        }

        set color2(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.setDirty(this._color2 != value);
            this._color2 = value;
        }

        get color2() {
            return this._color2;
        }

        set horizontalGradient(value) {
            this.setDirty(this._horizontalGradient != value);
            this._horizontalGradient = value;
        }

        get horizontalGradient() {
            return this._horizontalGradient;
        }

        setColor(color, color2, isHorizontalGradient) {
            if (isHorizontalGradient === undefined) {
                isHorizontalGradient = true;
            }

            this.color = color;
            this.color2 = color2;
            this.horizontalGradient = isHorizontalGradient;
            return this;
        }

        set stroke(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.setDirty(this._stroke != value);
            this._stroke = value;
        }

        get stroke() {
            return this._stroke;
        }

        set strokeThickness(value) {
            this.setDirty(this._strokeThickness != value);
            this._strokeThickness = value;
        }

        get strokeThickness() {
            return this._strokeThickness;
        }

        setStroke(color, lineWidth) {
            if (color != null) {
                if (lineWidth === undefined) {
                    lineWidth = 2;
                }
            }
            this.stroke = color;
            this.strokeThickness = lineWidth;
            return this;
        }

        set cornerRadius(value) {
            this.setDirty(this._cornerRadius != value);
            this._cornerRadius = value;
        }

        get cornerRadius() {
            return this._cornerRadius;
        }

        set cornerIteration(value) {
            this.setDirty(this._cornerIteration != value);
            this._cornerIteration = value;
        }

        get cornerIteration() {
            return this._cornerIteration;
        }

        modifyStyle(o) {
            if (o.hasOwnProperty('color')) {
                this.setColor(
                    o.color,
                    GetProperty('color2', o, this),
                    GetProperty('horizontalGradient', o, this),
                );
            }
            if (o.hasOwnProperty('stroke')) {
                this.setStroke(
                    o.stroke,
                    GetProperty('strokeThickness', o, this),
                );
            }
            if (o.hasOwnProperty('cornerRadius')) {
                this.setCornerRadius(
                    o.cornerRadius,
                    GetProperty('cornerIteration', o, this),
                );
            }

            return this;
        }

        modifyPorperties(o) {
            super.modifyPorperties(o);

            this.modifyStyle(o);

            return this;
        }

        setCornerRadius(radius, iteration) {
            this.cornerRadius = radius;
            this.cornerIteration = iteration;
            return this;
        }

        renderContent() {
            DrawRoundRectangleBackground(
                this.parent,
                this.color,
                this.stroke,
                this.strokeThickness,
                this.cornerRadius,
                this.color2,
                this.horizontalGradient,
                this.cornerIteration
            );
        }
    }

    const GetValue$3E = Phaser.Utils.Objects.GetValue;

    class InnerBounds extends RenderBase {
        constructor(parent, config) {
            super(parent, 'innerbounds');

            this.setScrollFactor(0);

            this.setColor(
                GetValue$3E(config, 'color', null),
                GetValue$3E(config, 'color2', null),
                GetValue$3E(config, 'horizontalGradient', true)
            );

            this.setStroke(
                GetValue$3E(config, 'stroke', null),
                GetValue$3E(config, 'strokeThickness', 2)
            );
        }

        set color(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.setDirty(this._color != value);
            this._color = value;
        }

        get color() {
            return this._color;
        }

        set color2(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.setDirty(this._color2 != value);
            this._color2 = value;
        }

        get color2() {
            return this._color2;
        }

        set horizontalGradient(value) {
            this.setDirty(this._horizontalGradient != value);
            this._horizontalGradient = value;
        }

        get horizontalGradient() {
            return this._horizontalGradient;
        }

        setColor(color, color2, isHorizontalGradient) {
            if (isHorizontalGradient === undefined) {
                isHorizontalGradient = true;
            }

            this.color = color;
            this.color2 = color2;
            this.horizontalGradient = isHorizontalGradient;
            return this;
        }

        set stroke(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.setDirty(this._stroke != value);
            this._stroke = value;
        }

        get stroke() {
            return this._stroke;
        }

        set strokeThickness(value) {
            this.setDirty(this._strokeThickness != value);
            this._strokeThickness = value;
        }

        get strokeThickness() {
            return this._strokeThickness;
        }

        setStroke(color, lineWidth) {
            if (color != null) {
                if (lineWidth === undefined) {
                    lineWidth = 2;
                }
            }
            this.stroke = color;
            this.strokeThickness = lineWidth;
            return this;
        }

        modifyPorperties(o) {
            super.modifyPorperties(o);

            if (o.hasOwnProperty('color')) {
                this.setColor(
                    o.color,
                    GetValue$3E(o, 'color2', null),
                    GetValue$3E(o, 'horizontalGradient', true)
                );
            }
            if (o.hasOwnProperty('stroke')) {
                this.setStroke(
                    o.stroke,
                    GetValue$3E(o, 'strokeThickness', 2)
                );
            }
        }

        renderContent() {
            var padding = this.parent.padding;
            var x = padding.left,
                y = padding.top,
                width = this.parent.width - padding.left - padding.right,
                height = this.parent.height - padding.top - padding.bottom;
            var context = this.context;
            if (this.color != null) {
                var fillStyle;
                if (this.color2 != null) {
                    var grd;
                    if (this.horizontalGradient) {
                        grd = context.createLinearGradient(0, 0, width, 0);
                    } else {
                        grd = context.createLinearGradient(0, 0, 0, height);
                    }
                    grd.addColorStop(0, this.color);
                    grd.addColorStop(1, this.color2);
                    fillStyle = grd;
                } else {
                    fillStyle = this.color;
                }

                context.fillStyle = fillStyle;
                context.fillRect(x, y, width, height);
            }

            if ((this.stroke != null) && (this.strokeThickness > 0)) {
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeThickness;
                context.strokeRect(x, y, width, height);
            }
        }
    }

    const GetValue$3D = Phaser.Utils.Objects.GetValue;

    class TextStyle {
        constructor(parent, config) {
            this.parent = parent;
            this.set(config);
        }

        toJSON() {
            return {
                bold: this.bold,
                italic: this.italic,
                fontSize: this.fontSize,
                fontFamily: this.fontFamily,
                color: this.color,
                stroke: this.stroke,
                strokeThickness: this.strokeThickness,
                shaodwColor: this.shadowColor,
                shadowBlur: this.shadowBlur,
                shadowOffsetX: this.shadowOffsetX,
                shadowOffsetY: this.shadowOffsetY,
                offsetX: this.offsetX,
                offsetY: this.offsetY,
                leftSpace: this.leftSpace,
                rightSpace: this.rightSpace,
                backgroundHeight: this.backgroundHeight,
                backgroundBottomY: this.backgroundBottomY,
                align: this.align
            }
        }

        set(o) {
            this.setBold(GetValue$3D(o, 'bold', false));
            this.setItalic(GetValue$3D(o, 'italic', false));
            this.setFontSize(GetValue$3D(o, 'fontSize', '16px'));
            this.setFontFamily(GetValue$3D(o, 'fontFamily', 'Courier'));
            this.setColor(GetValue$3D(o, 'color', '#fff'));
            this.setStrokeStyle(
                GetValue$3D(o, 'stroke', null),
                GetValue$3D(o, 'strokeThickness', 0)
            );
            this.setShadow(
                GetValue$3D(o, 'shadowColor', null),
                GetValue$3D(o, 'shadowOffsetX', 0),
                GetValue$3D(o, 'shadowOffsetY', 0),
                GetValue$3D(o, 'shadowBlur', 0)
            );
            this.setOffset(
                GetValue$3D(o, 'offsetX', 0),
                GetValue$3D(o, 'offsetY', 0)
            );
            this.setSpace(
                GetValue$3D(o, 'leftSpace', 0),
                GetValue$3D(o, 'rightSpace', 0)
            );
            this.setAlign(GetValue$3D(o, 'align', undefined));
            this.setBackgroundColor(GetValue$3D(o, 'backgroundColor', null));
            this.setBackgroundHeight(GetValue$3D(o, 'backgroundHeight', undefined));
            this.setBackgroundBottomY(GetValue$3D(o, 'backgroundBottomY', undefined));
            this.setBackgroundLeftX(GetValue$3D(o, 'backgroundLeftX', 0));
            this.setBackgroundRightX(GetValue$3D(o, 'backgroundRightX', 0));

            return this;
        }

        modify(o) {
            if (o.hasOwnProperty('bold')) {
                this.setBold(o.bold);
            }
            if (o.hasOwnProperty('italic')) {
                this.setItalic(o.italic);
            }
            if (o.hasOwnProperty('fontSize')) {
                this.setFontSize(o.fontSize);
            }
            if (o.hasOwnProperty('fontFamily')) {
                this.setFontFamily(o.fontFamily);
            }
            if (o.hasOwnProperty('color')) {
                this.setColor(o.color);
            }
            if (o.hasOwnProperty('stroke') || o.hasOwnProperty('strokeThickness')) {
                this.setStrokeStyle(
                    GetProperty('stroke', o, this),
                    GetProperty('strokeThickness', o, this)
                );
            }

            if (o.hasOwnProperty('shadowColor')) {
                this.setShadowColor(o.shadowColor);
            }

            if (o.hasOwnProperty('shadowOffsetX') || o.hasOwnProperty('shadowOffsetY')) {
                this.setShadowOffset(
                    GetProperty('shadowOffsetX', o, this),
                    GetProperty('shadowOffsetY', o, this),
                );
            }

            if (o.hasOwnProperty('shadowBlur')) {
                this.setShadowBlur(o.shaodwBlur);
            }

            if (o.hasOwnProperty('offsetX')) {
                this.setOffsetX(o.offsetX);
            }
            if (o.hasOwnProperty('offsetY')) {
                this.setOffsetY(o.offsetY);
            }

            if (o.hasOwnProperty('leftSpace')) {
                this.setLeftSpace(o.leftSpace);
            }
            if (o.hasOwnProperty('rightSpace')) {
                this.setRightSpace(o.rightSpace);
            }

            if (o.hasOwnProperty('align')) {
                this.setAlign(o.align);
            }

            if (o.hasOwnProperty('backgroundColor')) {
                this.setBackgroundColor(o.backgroundColor);
            }

            if (o.hasOwnProperty('backgroundHeight')) {
                this.setBackgroundHeight(o.backgroundHeight);
            }
            if (o.hasOwnProperty('backgroundBottomY')) {
                this.setBackgroundBottomY(o.backgroundBottomY);
            }
            if (o.hasOwnProperty('backgroundLeftX')) {
                this.setBackgroundLeftX(o.backgroundLeftX);
            }
            if (o.hasOwnProperty('backgroundRightX')) {
                this.setBackgroundRightX(o.backgroundRightX);
            }        

            return this;
        }

        setUpdateTextFlag() {
            if (this.parent) {
                this.parent.updateTextFlag = true;
            }
            return this;
        }

        clone() {
            return new TextStyle(null, this.toJSON());
        }

        copyFrom(sourceTextStyle) {
            this.set(sourceTextStyle.toJSON());
            return this;
        }

        copyTo(targetTextStyle) {
            targetTextStyle.set(this.toJSON());
            return this;
        }

        setBold(value) {
            if (value === undefined) {
                value = true;
            }
            this.bold = value;
            this.setUpdateTextFlag();
            return this;
        }

        setItalic(value) {
            if (value === undefined) {
                value = true;
            }
            this.italic = value;
            this.setUpdateTextFlag();
            return this;
        }

        get fontStyle() {
            if (this.bold && this.italic) {
                return 'bold italic';
            } else if (this.bold) {
                return 'bold';
            } else if (this.italic) {
                return 'italic';
            } else {
                return '';
            }
        }

        setFontSize(fontSize) {
            if (typeof (fontSize) === 'number') {
                fontSize = `${fontSize}px`;
            }
            this.fontSize = fontSize;
            this.setUpdateTextFlag();
            return this;
        }

        setFontFamily(fontFamily) {
            this.fontFamily = fontFamily;
            this.setUpdateTextFlag();
            return this;
        }

        get font() {
            return `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`;
        }

        setColor(color) {
            this.color = GetStyle(color);
            return this;
        }

        get hasFill() {
            return this.color != null;
        }

        setStrokeStyle(stroke, strokeThickness) {
            this.stroke = GetStyle(stroke);
            if (strokeThickness !== undefined) {
                this.strokeThickness = strokeThickness;
            }
            return this;
        }

        setStrokeThickness(strokeThickness) {
            this.strokeThickness = strokeThickness;
            return this;
        }

        get hasStroke() {
            return (this.stroke != null) && (this.strokeThickness > 0);
        }

        setShadowColor(color) {
            this.shadowColor = GetStyle(color);
            return this;
        }

        setShadowOffset(offsetX, offsetY) {
            if (offsetX === undefined) {
                offsetX = 0;
            }
            if (offsetY === undefined) {
                offsetY = 0;
            }

            this.shadowOffsetX = offsetX;
            this.shadowOffsetY = offsetY;
            return this;
        }

        setShadowBlur(blur) {
            if (blur === undefined) {
                blur = 0;
            }

            this.shaodwBlur = blur;
            return this;
        }

        setShadow(color, offsetX, offsetY, blur) {
            this
                .setShadowColor(color)
                .setShadowOffset(offsetX, offsetY)
                .setShadowBlur(blur);
            return this;
        }

        setBackgroundColor(color) {
            this.backgroundColor = GetStyle(color);
            return this;
        }

        get hasBackgroundColor() {
            return this.backgroundColor != null;
        }

        setBackgroundHeight(height) {
            this.backgroundHeight = height;
            return this;
        }

        setBackgroundBottomY(y) {
            this.backgroundBottomY = y;
            return this;
        }

        setBackgroundLeftX(x) {
            this.backgroundLeftX = x;
            return this;
        }

        setBackgroundRightX(x) {
            this.backgroundRightX = x;
            return this;
        }

        setOffsetX(offsetX) {
            if (offsetX === undefined) {
                offsetX = 0;
            }

            this.offsetX = offsetX;
            return this;
        }

        setOffsetY(offsetY) {
            if (offsetY === undefined) {
                offsetY = 0;
            }

            this.offsetY = offsetY;
            return this;
        }

        setOffset(offsetX, offsetY) {
            this
                .setOffsetX(offsetX)
                .setOffsetY(offsetY);
            return this;
        }

        setLeftSpace(space) {
            if (space === undefined) {
                space = 0;
            }

            this.leftSpace = space;
            return this;
        }

        setRightSpace(space) {
            if (space === undefined) {
                space = 0;
            }

            this.rightSpace = space;
            return this;
        }

        setSpace(leftSpace, rightSpace) {
            this
                .setLeftSpace(leftSpace)
                .setRightSpace(rightSpace);
            return this;
        }

        setAlign(align) {
            this.align = align;
            return this;
        }

        syncFont(context) {
            context.font = this.font;
            return this;
        }

        syncStyle(context) {
            context.textBaseline = 'alphabetic';

            var hasFill = this.hasFill;
            var hasStroke = this.hasStroke;
            context.fillStyle = (hasFill) ? this.color : '#000';

            context.strokeStyle = (hasStroke) ? this.stroke : '#000';
            context.lineWidth = (hasStroke) ? this.strokeThickness : 0;
            context.lineCap = 'round';
            context.lineJoin = 'round';

            return this;
        }

        syncShadow(context) {
            if (context.shadowColor != null) {
                context.shadowColor = this.shadowColor;
                context.shadowOffsetX = this.shadowOffsetX;
                context.shadowOffsetY = this.shadowOffsetY;
                context.shadowBlur = this.shadowBlur;
            } else {
                context.shadowColor = 0;
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
                context.shadowBlur = 0;
            }
        }

        getTextMetrics(context, text) {
            this.syncFont(context).syncStyle(context);
            return context.measureText(text);
        }

    }

    var SetFixedSize = function (width, height) {
        if (width === undefined) {
            width = 0;
        }
        if (height === undefined) {
            height = 0;
        }

        if ((this.fixedWidth === width) && (this.fixedHeight === height)) {
            return this;
        }

        this.fixedWidth = width;
        this.fixedHeight = height;
        this.dirty = true;  // -> this.updateTexture();

        this.setCanvasSize(
            (width > 0) ? width : this.width,
            (height > 0) ? height : this.height
        );

        return this;
    };

    var SetPadding = function (key, value) {
        var padding = this.padding;
        var paddingLeft = padding.left,
            paddingRight = padding.right,
            paddingTop = padding.top,
            paddingBottom = padding.bottom;

        SetPadding$1(padding, key, value);

        this.dirty = this.dirty ||
            (paddingLeft != padding.left) ||
            (paddingRight != padding.right) ||
            (paddingTop != padding.top) ||
            (paddingBottom != padding.bottom)
            ;
        return this;
    };

    var GetPadding = function (key) {
        return GetPadding$1(this.padding, key);
    };

    var ModifyTextStyle = function (style) {
        this.textStyle.modify(style);
        return this;
    };

    var ModifyDefaultTextStyle = function (style) {
        this.defaultTextStyle.modify(style);
        return this;
    };

    var ResetTextStyle = function () {
        this.textStyle.copyFrom(this.defaultTextStyle);
        return this;
    };

    var SetTestString = function (testString) {
        this.testString = testString;
        return this;
    };

    const RemoveItem$d = Phaser.Utils.Array.Remove;

    var RemoveChild$2 = function (child) {
        this.poolManager.free(child);
        RemoveItem$d(this.children, child);
        this.lastAppendedChildren.length = 0;
        this.lastOverChild = null;
        this.dirty = true;
        return this;
    };

    var RemoveChildren = function () {
        this.poolManager.freeMultiple(this.children);
        this.children.length = 0;
        this.lastAppendedChildren.length = 0;
        this.lastOverChild = null;
        this.dirty = true;
        return this;
    };

    const RemoveItem$c = Phaser.Utils.Array.Remove;

    var PopChild = function (child) {
        RemoveItem$c(this.children, child);
        this.lastAppendedChildren.length = 0;
        this.lastOverChild = null;
        this.dirty = true;
        return this;
    };

    var ClearContent = function() {
        this.setText();
        return this;
    };

    // const RemoveItem = Phaser.Utils.Array.Remove;

    var AddChild$3 = function (child, index) {
        var areChildren = Array.isArray(child);

        // Remove existed child(s)
        // RemoveItem(this.children, child);

        if ((index === undefined) || (index === this.children.length)) {
            if (areChildren) {
                this.children.push(...child);
            } else {
                this.children.push(child);
            }
        } else {
            if (areChildren) {
                this.children.splice(index, 0, ...child);
            } else {
                this.children.splice(index, 0, child);
            }
        }

        this.lastAppendedChildren.length = 0;
        if (areChildren) {
            this.lastAppendedChildren.push(...child);
        } else {
            this.lastAppendedChildren.push(child);
        }

        return this;
    };

    const CharTypeName = 'text';
    const ImageTypeName = 'image';
    const DrawerTypeName = 'drawer';
    const SpaceTypeName = 'space';
    const CmdTypeName = 'command';

    var IsNewLineChar = function (bob) {
        return (bob.type === CharTypeName) && (bob.text === '\n');
    };

    var IsPageBreakChar = function (bob) {
        return (bob.type === CharTypeName) && (bob.text === '\f');
    };

    var IsSpaceChar = function (bob) {
        return (bob.type === CharTypeName) && (bob.text === ' ');
    };

    var IsChar = function (bob) {
        return (bob.type === CharTypeName);
    };

    var IsCommand = function (bob) {
        return bob.type === CmdTypeName;
    };

    class CharData extends RenderBase {
        constructor(
            parent,
            text,
            style
        ) {
            super(parent, CharTypeName);
            this.updateTextFlag = false;
            this.style = new TextStyle(this, style);
            this.setText(text);
        }

        get autoRound() {
            return this.parent.autoRound;
        }

        get offsetX() {
            return this.style.offsetX;
        }

        set offsetX(value) {
            if (this.style) {
                this.style.offsetX = value;
            }
        }

        get offsetY() {
            return this.style.offsetY;
        }

        set offsetY(value) {
            if (this.style) {
                this.style.offsetY = value;
            }
        }

        get leftSpace() {
            return this.style.leftSpace * this.scaleX;
        }

        set leftSpace(value) {
            if (this.style) {
                this.style.leftSpace = value;
            }
            super.leftSpace = value;
        }

        get rightSpace() {
            return this.style.rightSpace * this.scaleX;
        }

        set rightSpace(value) {
            if (this.style) {
                this.style.rightSpace = value;
            }
            super.rightSpace = value;
        }

        get align() {
            return this.style.align;
        }

        set align(value) {
            if (this.style) {
                this.style.align = value;
            }
        }

        modifyStyle(style) {
            this.setDirty(true);
            this.style.modify(style);

            if (this.updateTextFlag) {
                this.updateTextSize();
            }
            return this;
        }

        modifyPorperties(o) {
            if (!o) {
                return this;
            }

            this.modifyStyle(o);
            super.modifyPorperties(o);
            return this;
        }

        setText(text) {
            this.setDirty(this.text != text);
            this.text = text;

            this.updateTextSize();

            return this;
        }

        updateTextSize() {
            var text = this.text;
            // Is new-line, page-break, or empty character
            if ((text === '\n') || (text === '\f') || (text === '')) {
                this.clearTextSize();

            } else {
                var metrics = this.style.getTextMetrics(this.context, this.text);
                this.textWidth = metrics.width;

                var ascent, descent;
                if ('actualBoundingBoxAscent' in metrics) {
                    ascent = metrics.actualBoundingBoxAscent;
                    descent = metrics.actualBoundingBoxDescent;
                } else {
                    ascent = 0;
                    descent = 0;
                }

                this.textHeight = ascent + descent;
                this.ascent = ascent;
                this.descent = descent;
            }

            this.updateTextFlag = false;
            return this;
        }

        clearTextSize() {
            this.textWidth = 0;
            this.textHeight = 0;
            this.ascent = 0;
            this.descent = 0;
            return this;
        }

        copyTextSize(child) {
            this.textWidth = child.textWidth;
            this.textHeight = child.textHeight;
            this.ascent = child.ascent;
            this.descent = child.descent;
            return this;
        }

        get width() {
            return this.textWidth * this.scaleX;
        }

        set width(value) {
            if (this.textWidth > 0) {
                this.scaleX = value / this.textWidth;
            } else {
                this.scaleX = 1;
            }
        }

        get height() {
            return this.textHeight * this.scaleY;
        }

        set height(value) {
            if (this.textHeight > 0) {
                this.scaleY = value / this.textHeight;
            } else {
                this.scaleY = 1;
            }
        }

        get willRender() {
            if (this.textWidth === 0) {
                return false;
            }

            return super.willRender;
        }

        renderContent() {
            var context = this.context;
            var textStyle = this.style;

            if (textStyle.hasBackgroundColor) {
                context.fillStyle = textStyle.backgroundColor;

                var leftX = this.drawTLX + textStyle.backgroundLeftX;
                var rightX = this.drawTRX + textStyle.backgroundRightX;
                var x = leftX;
                var width = rightX - leftX + 1; // Add extra 1 pixel width

                if (width > 0) {
                    var bottomY = textStyle.backgroundBottomY;
                    if (bottomY == null) {
                        bottomY = this.drawBLY;
                    }
                    var height = textStyle.backgroundHeight;
                    if (height == null) {
                        height = bottomY - this.drawTLY;
                    }
                    var y = bottomY - height;

                    context.fillRect(x, y, width, height);
                }
            }

            var hasFill = textStyle.hasFill,
                hasStroke = textStyle.hasStroke;

            if (!hasFill && !hasStroke) {
                return;
            }

            textStyle.syncFont(context).syncStyle(context);
            // textBaseline = 'alphabetic'

            if (hasStroke) {
                textStyle.syncShadow(context);
                context.strokeText(this.text, 0, 0);
            }

            if (hasFill) {
                textStyle.syncShadow(context);
                context.fillText(this.text, 0, 0);
            }
        }

        get drawTLX() { return -this.leftSpace; }
        get drawTLY() { return -this.ascent; }
        get drawBLX() { return -this.leftSpace; }
        get drawBLY() { return this.descent; }
        get drawTRX() { return this.textWidth + this.rightSpace; }
        get drawTRY() { return -this.ascent; }
        get drawBRX() { return this.textWidth + this.rightSpace; }
        get drawBRY() { return this.descent; }

    }

    var CreateCharChild = function (text, style) {
        if (style) {
            this.textStyle.modify(style);
        }

        var child = this.poolManager.allocate(CharTypeName);
        if (child === null) {
            child = new CharData(
                this,               // parent
                text,               // text
                this.textStyle,     // style
            );
        } else {
            child
                .setParent(this)
                .setActive()
                .modifyStyle(this.textStyle)
                .setText(text);
        }

        return child;
    };

    var CreateCharChildren = function (text, style) {
        if (style) {
            this.textStyle.modify(style);
        }

        var children = [];
        for (var i = 0, cnt = text.length; i < cnt; i++) {
            var char = text.charAt(i);
            var child = this.poolManager.allocate(CharTypeName);
            if (child === null) {
                child = new CharData(
                    this,               // parent
                    char,               // text
                    this.textStyle,     // style
                );
            } else {
                child
                    .setParent(this)
                    .setActive()
                    .modifyStyle(this.textStyle)
                    .setText(char);
            }
            // child.modifyPorperties(properties);  // Warning: Will modify text-style twice

            children.push(child);
        }

        return children;
    };

    var AppendText = function (text, style) {
        var children = this.createCharChildren(text, style);
        this.addChild(children);
        return this;
    };

    var SetText$2 = function (text, style) {
        if (text === undefined) {
            text = '';
        }

        this.removeChildren();
        AppendText.call(this, text, style);  // this.appendText might be override

        this.dirty = true;
        return this;
    };

    var InsertText = function (index, text, style) {
        var children = this.createCharChildren(text, style);
        index = this.getCharChildIndex(index, true);
        this.addChild(children, index);

        return this;
    };

    var RemoveText = function (index, length) {
        if (length === undefined) {
            length = 1;
        }

        for (var i = 0; i < length; i++) {
            var childIndex = this.getCharChildIndex(index, true);
            if (childIndex === undefined) {
                break;
            }
            this.removeChild(this.children[childIndex]);
        }
        return this;
    };

    var GetText = function (activeOnly) {
        var text = '';
        this.forEachCharChild(function (child) {
            text += child.text;
        }, undefined, activeOnly);
        return text;
    };

    Phaser.Display.Canvas.CanvasPool;

    class ImageData extends RenderBase {
        constructor(
            parent,
            key, frame
        ) {
            super(parent, ImageTypeName);
            this.setTexture(key, frame);
            this.color = undefined;
        }

        get frameWidth() {
            return (this.frameObj) ? this.frameObj.cutWidth : 0;
        }

        get frameHeight() {
            return (this.frameObj) ? this.frameObj.cutHeight : 0;
        }

        get offsetY() {
            return -this.height;
        }

        set offsetY(value) { }

        get key() {
            return this._key;
        }

        set key(value) {
            this.setDirty(this._key != value);
            this._key = value;
        }

        get frame() {
            return this._frame;
        }

        set frame(value) {
            this.setDirty(this._frame != value);
            this._frame = value;
        }

        setTexture(key, frame) {
            this.key = key;
            this.frame = frame;

            this.frameObj = this.scene.sys.textures.getFrame(key, frame);
            return this;
        }

        get width() {
            return this.frameWidth * this.scaleX;
        }

        set width(value) {
            this.setDirty(this.width !== value);
            this.scaleX = value / this.frameWidth;
        }

        get height() {
            return this.frameHeight * this.scaleY;
        }

        set height(value) {
            this.setDirty(this.height !== value);
            this.scaleY = value / this.frameHeight;
        }

        setHeight(height, keepAspectRatio) {
            if (keepAspectRatio === undefined) {
                keepAspectRatio = false;
            }
            this.height = height;

            if (keepAspectRatio) {
                this.scaleX = this.scaleY;
            }
            return this;
        }

        setColor(color) {
            this.color = color;
            return this;
        }

        modifyPorperties(o) {
            if (o.hasOwnProperty('color')) {
                this.setColor(o.color);
            }

            super.modifyPorperties(o);
            return this;
        }

        renderContent() {
            DrawFrameToCanvas(
                this.frameObj, this.canvas,
                0, 0, this.frameWidth, this.frameHeight,
                this.color, false
            );

        }

        get drawTLX() { return -this.leftSpace; }
        get drawTLY() { return 0; }
        get drawBLX() { return -this.leftSpace; }
        get drawBLY() { return this.frameHeight; }
        get drawTRX() { return this.frameWidth + this.rightSpace; }
        get drawTRY() { return 0; }
        get drawBRX() { return this.frameWidth + this.rightSpace; }
        get drawBRY() { return this.frameHeight; }
    }

    var CreateImageChild = function(key, frame, properties) {
        var child = this.poolManager.allocate(ImageTypeName);

        if (child === null) {
            child = new ImageData(
                this,               // parent
                key,
                frame
            );
        } else {
            child
                .setParent(this)
                .setActive()
                .setTexture(key, frame);
        }
        child.modifyPorperties(properties);

        return child;
    };

    var AppendImage = function (key, frame, properties) {
        var child = this.createImageChild(key, frame, properties);
        this.addChild(child);

        return this;
    };

    class Drawer extends RenderBase {
        constructor(parent, renderCallback, width, height) {
            super(parent, DrawerTypeName);

            this.setRenderCallback(renderCallback);
            this.setDrawerSize(width, height);
        }

        setRenderCallback(callback) {
            if (callback) {
                this.renderContent = callback.bind(this);
            } else {
                delete this.renderContent;
            }
            return this;
        }

        setDrawerSize(width, height) {
            // Whole canvas
            if (width === true) {
                this.toLocalPosition = false;
                width = undefined;
                height = undefined;
            } else {
                this.toLocalPosition = true;
            }

            if (width === undefined) {
                width = 0;
            }
            if (height === undefined) {
                height = width;
            }

            this.drawerWidth = width;
            this.drawerHeight = height;

            return this;
        }

        onFree() {
            super.onFree();
            this
                .setRenderCallback();
        }

        get width() {
            return this.drawerWidth * this.scaleX;
        }

        set width(value) {
            this.setDirty(this.width !== value);
            this.scaleX = (this.drawerWidth > 0) ? value / this.drawerWidth : 1;
        }

        get height() {
            return this.drawerHeight * this.scaleY;
        }

        set height(value) {
            this.setDirty(this.height !== value);
            this.scaleY = (this.drawerHeight > 0) ? value / this.drawerHeight : 1;
        }

        get offsetY() {
            return -this.height;
        }

        set offsetY(value) { }

        get drawTLX() { return -this.leftSpace; }
        get drawTLY() { return 0; }
        get drawBLX() { return -this.leftSpace; }
        get drawBLY() { return this.drawerHeight; }
        get drawTRX() { return this.drawerWidth + this.rightSpace; }
        get drawTRY() { return 0; }
        get drawBRX() { return this.drawerWidth + this.rightSpace; }
        get drawBRY() { return this.drawerHeight; }

    }

    var CreateDrawerChild = function (renderCallback, width, height) {
        var child = this.poolManager.allocate(DrawerTypeName);

        if (child === null) {
            child = new Drawer(
                this,               // parent
                renderCallback,
                width, height
            );
        } else {
            child
                .setParent(this)
                .setActive()
                .setRenderCallback(renderCallback)
                .setDrawerSize(width, height);
        }

        return child;
    };

    var AppendDrawer = function (renderCallback, width, height) {
        var child = this.createDrawerChild(renderCallback, width, height);
        this.addChild(child);

        return this;
    };

    let Space$1 = class Space extends RenderBase {
        constructor(
            parent,
            width
        ) {
            super(parent, SpaceTypeName);
            this.setSpaceWidth(width);
        }

        get width() {
            return this.spaceWidth * this.scaleX;
        }

        set width(value) {
            if (this.spaceWidth > 0) {
                this.scaleX = value / this.spaceWidth;
            } else {
                this.scaleX = 1;
            }
        }

        setSpaceWidth(width) {
            this.spaceWidth = width;
            return this;
        }

    };

    var CreateSpaceChild = function (width) {
        var child = this.poolManager.allocate(SpaceTypeName);

        if (child === null) {
            child = new Space$1(
                this,               // parent
                width
            );
        } else {
            child
                .setParent(this)
                .setActive()
                .setSpaceWidth(width);
        }
        return child;
    };

    var AppendSpace = function (width) {
        var child = this.createSpaceChild(width);
        this.addChild(child);

        return this;
    };

    class Command extends Base$3 {
        constructor(parent, name, callback, param, scope) {
            super(parent, CmdTypeName);

            this
                .setName(name)
                .setParameter(param)
                .setCallback(callback, scope);
        }

        setName(name) {
            this.name = name;
            return this;
        }

        setParameter(param) {
            this.param = param;
            return this;
        }

        setCallback(callback, scope) {
            this.callback = callback;
            this.scope = scope;
            return this;
        }

        exec() {
            var result;
            if (this.scope) {
                result = this.callback.call(this.scope, this.param, this.name);
            } else {
                result = this.callback(this.param, this.name);
            }
            return result;
        }

        onFree() {
            super.onFree();
            this
                .setName()
                .setCallback()
                .setParameter();
        }
    }

    var CreateCommandChild = function (name, callback, param, scope) {
        var child = this.poolManager.allocate(CmdTypeName);

        if (child === null) {
            child = new Command(
                this,               // parent
                name,
                callback, param, scope,
            );
        } else {
            child
                .setParent(this)
                .setActive()
                .setName(name)
                .setCallback(callback, scope)
                .setParameter(param);

        }

        return child;
    };

    var AppendCommand$3 = function (name, callback, param, scope) {
        var child = this.createCommandChild(name, callback, param, scope);
        this.addChild(child);

        return this;
    };

    var SetWrapConfig = function (config) {
        if (config === undefined) {
            config = {};
        } else if (typeof (config) === 'object') {
            config = DeepClone(config);
        }

        this.wrapConfig = config;
        return this;
    };

    var CreateWrapResultData = function (config) {
        var data = {
            callback: undefined,
            start: 0,  // Next start index
            isLastPage: false,  // Is last page
            maxLines: undefined,
            padding: undefined,
            letterSpacing: undefined,
            hAlign: undefined,
            vAlign: undefined,
            children: [],       // Wrap result
            lines: [],          // Wrap result in lines

            // WordWrap
            maxLineWidth: 0,
            linesHeight: 0,
            lineHeight: undefined,

            // VerticalWrap
            maxLineHeight: 0,
            linesWidth: 0,
            lineWidth: undefined,
        };

        return Object.assign(data, config);
    };

    const WRAPMODE = {
        none: 0,
        word: 1,
        char: 2,
        character: 2,
        mix: 3
    };

    var GetWord = function (children, startIndex, wrapMode, result) {
        if (result === undefined) {
            result = { word: [], width: 0 };
        }

        result.word.length = 0;

        var isCharWrap = (wrapMode === 2);
        var isMixWrap = (wrapMode === 3);
        var isWordWrap = !isCharWrap && !isMixWrap;

        var endIndex = children.length;
        var currentIndex = startIndex;
        var word = result.word;
        var wordWidth = 0;
        var hasAnyASCIICharacter = false;
        while (currentIndex < endIndex) {
            var child = children[currentIndex];
            // Can't render (command child), put into output directly
            if (!child.renderable) {
                word.push(child);
                currentIndex++;
                continue;
            }

            var text = (child.type === CharTypeName) ? child.text : null;
            // Get image child, a new-line, or page-break
            if ((text === null) || (text === '\n') || (text === '\f')) {
                if (currentIndex === startIndex) { // Single child
                    word.push(child);
                    wordWidth += child.outerWidth;
                }
                break;
            }

            if (isWordWrap) {
                word.push(child);
                wordWidth += child.outerWidth;
                if (text === ' ') { // Word is end with a space character
                    break;
                }

                currentIndex++;

            } else if (isCharWrap) {  // Word only contains 1 character
                word.push(child);
                wordWidth += child.outerWidth;
                // Flush this 1 character
                break;

            } else if (isMixWrap) {
                if (!IsASCIIString(text)) {
                    if (!hasAnyASCIICharacter) {
                        word.push(child);
                        wordWidth += child.outerWidth;

                        // Is next child a space character?
                        var nextChild = children[currentIndex + 1];
                        if (nextChild &&
                            (nextChild.type === CharTypeName) &&
                            (nextChild.text === ' ')) {
                            word.push(nextChild);
                            wordWidth += nextChild.outerWidth;
                            // Include this space character
                        }
                        // Flush this 1 non-ascii character
                        break;

                    } else {
                        // Flush remainder children (all ascii character), except current child
                        break;

                    }
                } else {
                    word.push(child);
                    wordWidth += child.outerWidth;
                    if (text === ' ') { // Word is end with a space character
                        break;
                    }

                    currentIndex++;
                    hasAnyASCIICharacter = true;
                    // Test next child until ...
                }

            }
        }

        result.width = wordWidth;
        return result;
    };

    var GetChildrenAlign = function (children) {
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (child.align !== undefined) {
                return child.align;
            }
        }

        return undefined;
    };

    var OffsetChildren = function (children, offsetX, offsetY) {
        if ((offsetX === 0) && (offsetY === 0)) {
            return;
        }

        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (!child.renderable) {
                continue;
            }

            child.x += offsetX;
            child.y += offsetY;
        }
    };

    var AlignLines$1 = function (result, width, height) {
        var hAlign = result.hAlign,
            vAlign = result.vAlign,
            justifyPercentage = result.justifyPercentage;

        var lines = result.lines;
        var offsetX, offsetY;
        for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
            var line = lines[li];
            var lineWidth = line.width,
                children = line.children;

            var lineHAlign = GetChildrenAlign(children);
            if (lineHAlign === undefined) {
                lineHAlign = hAlign;
            }

            switch (lineHAlign) {
                case 0:
                case 'left':
                    offsetX = 0;
                    break;

                case 1:  // center
                case 'center':
                    var remainderWidth = width - lineWidth;
                    offsetX = remainderWidth / 2;
                    break;

                case 2:  // right
                case 'right':
                    var remainderWidth = width - lineWidth;
                    offsetX = remainderWidth;
                    break;

                case 3:
                case 'justify':
                case 'justify-left':
                    var remainderWidth = width - lineWidth;
                    var remainderPercentage = remainderWidth / width;
                    if (remainderPercentage < justifyPercentage) {
                        JustifyChildren(children, remainderWidth);
                        offsetX = 0;
                    } else {
                        offsetX = 0;
                    }
                    break;

                case 4:
                case 'justify-center':
                    var remainderWidth = width - lineWidth;
                    var remainderPercentage = remainderWidth / width;
                    if (remainderPercentage < justifyPercentage) {
                        JustifyChildren(children, remainderWidth);
                        offsetX = 0;
                    } else {
                        offsetX = remainderWidth / 2;
                    }
                    break;

                case 5:
                case 'justify-right':
                    var remainderWidth = width - lineWidth;
                    var remainderPercentage = remainderWidth / width;
                    if (remainderPercentage < justifyPercentage) {
                        JustifyChildren(children, remainderWidth);
                        offsetX = 0;
                    } else {
                        offsetX = remainderWidth;
                    }
                    break;

                default:
                    offsetX = 0;
                    break;
            }

            var linesHeight = result.linesHeight;
            switch (vAlign) {
                case 1: // center
                case 'center':
                    offsetY = (height - linesHeight) / 2;
                    break;

                case 2: // bottom
                case 'bottom':
                    offsetY = height - linesHeight;
                    break;

                default:
                    offsetY = 0;
                    break;
            }

            OffsetChildren(children, offsetX, offsetY);

        }

    };

    var JustifyChildren = function (children, remainderWidth) {
        var offset = remainderWidth / children.length;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (!child.renderable) {
                continue;
            }

            child.x += offset * i;
        }
    };

    var GetDefaultTextHeight = function () {
        var metrics = this.defaultTextStyle.getTextMetrics(this.context, this.testString);
        var ascent, descent;
        if ('actualBoundingBoxAscent' in metrics) {
            ascent = metrics.actualBoundingBoxAscent;
            descent = metrics.actualBoundingBoxDescent;
        } else {
            ascent = 0;
            descent = 0;
        }
        
        Result.ascent = ascent;
        Result.descent = descent;
        Result.height = ascent + descent;

        return Result;
    };

    var Result = {};

    const GetValue$3C = Phaser.Utils.Objects.GetValue;

    var RunWordWrap$1 = function (config) {
        // Parse parameters
        var startIndex = GetValue$3C(config, 'start', 0);

        SetPadding$1(this.wrapPadding, GetValue$3C(config, 'padding', 0));
        var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
        var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;

        // Get lineHeight, maxLines
        var lineHeight = GetValue$3C(config, 'lineHeight');
        var ascent = GetValue$3C(config, 'ascent', lineHeight);
        var maxLines;
        if (lineHeight === undefined) {
            // Calculate lineHeight
            var useDefaultTextHeight = GetValue$3C(config, 'useDefaultTextHeight', false);
            maxLines = GetValue$3C(config, 'maxLines', 0);
            if ((this.fixedHeight > 0) && (!useDefaultTextHeight)) {
                var innerHeight = this.fixedHeight - paddingVertical;
                if (maxLines > 0) {
                    // Calculate lineHeight via maxLines, in fixedHeight mode
                    lineHeight = innerHeight / maxLines;
                } else {
                    var textHeightResult = GetDefaultTextHeight.call(this);
                    lineHeight = textHeightResult.height;
                    ascent = textHeightResult.ascent;
                    // Calculate maxLines via (ascent, lineHeight), in fixedHeight mode
                    maxLines = Math.floor((innerHeight - ascent) / lineHeight);
                }
            } else {
                var textHeightResult = GetDefaultTextHeight.call(this);
                lineHeight = textHeightResult.height;
                ascent = textHeightResult.ascent;
            }

        } else {
            // Calculate maxLines
            if (this.fixedHeight > 0) {
                // Calculate maxLines via lineHeight, in fixedHeight mode
                maxLines = GetValue$3C(config, 'maxLines');
                if (maxLines === undefined) {
                    var innerHeight = this.fixedHeight - paddingVertical;
                    maxLines = Math.floor(innerHeight / lineHeight);
                }
            } else {
                maxLines = GetValue$3C(config, 'maxLines', 0); // Default is show all lines
            }

        }

        // If ascent is undefined, assign to lineHeight
        if (ascent === undefined) {
            ascent = lineHeight;
        }

        var showAllLines = (maxLines === 0);

        var wrapMode = GetValue$3C(config, 'wrapMode');
        if (wrapMode === undefined) {
            var charWrap = GetValue$3C(config, 'charWrap', false);
            wrapMode = (charWrap) ? 'char' : 'word';
        }
        if (typeof (wrapMode) === 'string') {
            wrapMode = WRAPMODE[wrapMode];
        }

        // Get wrapWidth
        var wrapWidth = GetValue$3C(config, 'wrapWidth', undefined);
        if (wrapWidth === undefined) {
            if (this.fixedWidth > 0) {
                wrapWidth = this.fixedWidth - paddingHorizontal;
            } else {
                wrapWidth = Infinity; // No word-wrap
                wrapMode = 0;
            }
        }

        var letterSpacing = GetValue$3C(config, 'letterSpacing', 0);

        var hAlign = GetValue$3C(config, 'hAlign', 0);
        var vAlign = GetValue$3C(config, 'vAlign', 0);
        var justifyPercentage = GetValue$3C(config, 'justifyPercentage', 0.25);

        var result = CreateWrapResultData({
            // Override properties
            callback: 'runWordWrap',
            start: startIndex,  // Next start index
            padding: this.wrapPadding,
            letterSpacing: letterSpacing,
            maxLines: maxLines,
            hAlign: hAlign,
            vAlign: vAlign,
            justifyPercentage: justifyPercentage,

            // Specific properties
            ascent: ascent,
            lineHeight: lineHeight,
            wrapWidth: wrapWidth,
            wrapMode: wrapMode,
        });

        // Set all children to inactive
        var children = this.children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            children[i].setActive(false);
        }

        // Layout children
        wrapWidth += letterSpacing;
        var startX = this.padding.left + this.wrapPadding.left,
            startY = this.padding.top + this.wrapPadding.top + ascent,  // Start(baseline) from ascent, not 0
            x = startX,
            y = startY;
        var remainderWidth = wrapWidth,
            childIndex = startIndex,
            lastChildIndex = children.length;
        var resultChildren = result.children;
        var resultLines = result.lines,
            lastLine = [], lastLineWidth = 0, maxLineWidth = 0;
        var wordResult;
        var isPageBreakChar = false;
        while (childIndex < lastChildIndex) {
            wordResult = GetWord(children, childIndex, wrapMode, wordResult);
            var word = wordResult.word;
            var charCnt = word.length;
            var wordWidth = wordResult.width + (charCnt * letterSpacing);

            childIndex += charCnt;
            // Next line
            var isNewLineChar = IsNewLineChar(word[0]);
            isPageBreakChar = IsPageBreakChar(word[0]);
            var isControlChar = isNewLineChar || isPageBreakChar;
            if ((remainderWidth < wordWidth) || isControlChar) {
                // Add to result
                if (isControlChar) {
                    var char = word[0];
                    char.setActive().setPosition(x, y);
                    resultChildren.push(char);
                    lastLine.push(char);
                }

                // Move cursor
                x = startX;
                y += lineHeight;
                remainderWidth = wrapWidth;
                resultLines.push({ children: lastLine, width: lastLineWidth });
                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);

                lastLineWidth = 0;
                lastLine = [];

                var isPageEnd = isPageBreakChar ||
                    (!showAllLines && (resultLines.length === maxLines)); // Exceed maxLines
                if (isPageEnd) {
                    break;
                } else if (isControlChar) {  // Already add to result
                    continue;
                }
            }
            remainderWidth -= wordWidth;
            lastLineWidth += wordWidth;

            for (var i = 0, cnt = word.length; i < cnt; i++) {
                var child = word[i];
                child.setActive();
                resultChildren.push(child);
                lastLine.push(child);

                if (child.renderable) {
                    child.setPosition(x, y);
                    x += (child.outerWidth + letterSpacing);
                }
            }
        }

        if (lastLine.length > 0) {
            resultLines.push({ children: lastLine, width: lastLineWidth });
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        }

        result.start += resultChildren.length;
        result.isLastPage = (!isPageBreakChar) && (result.start === lastChildIndex);
        result.maxLineWidth = maxLineWidth;
        result.linesHeight = (resultLines.length * lineHeight);

        // Calculate size of game object
        var width = (this.fixedWidth > 0) ? this.fixedWidth : (result.maxLineWidth + paddingHorizontal);
        var height = (this.fixedHeight > 0) ? this.fixedHeight : (result.linesHeight + paddingVertical);

        // Size might be changed after wrapping
        var innerWidth = width - paddingHorizontal;
        var innerHeight = height - paddingVertical;
        AlignLines$1(result, innerWidth, innerHeight);

        // Resize
        this.setCanvasSize(width, height);

        // Set initial position
        for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
            var child = resultChildren[i];
            if (!child.renderable) {
                continue;
            }
            child.x0 = child.x;
            child.y0 = child.y;
        }

        return result;
    };

    const Merge$6 = Phaser.Utils.Objects.Merge;

    var RunWordWrap = function (config) {
        if (config === undefined) {
            config = {};
        }

        return RunWordWrap$1.call(this, Merge$6(config, this.wrapConfig));
    };

    var AlignLines = function (result, width, height) {
        var hAlign = result.hAlign,
            vAlign = result.vAlign;

        var offsetX, offsetY;

        var rtl = result.rtl;
        var lines = result.lines,
            lineWidth = result.lineWidth,
            linesWidth = result.linesWidth;
        switch (hAlign) {
            case 1:  // center
            case 'center':
                offsetX = (width - linesWidth) / 2;
                break;

            case 2:  // right
            case 'right':
                offsetX = width - linesWidth;
                break;

            default:  // left
                offsetX = 0;
                break;
        }
        if (rtl) {
            offsetX += lineWidth;
        }

        for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
            var line = lines[(rtl) ? (lcnt - li - 1) : li];
            var children = line.children;
            var lineHeight = line.height;

            var lineVAlign = GetChildrenAlign(children);
            if (lineVAlign === undefined) {
                lineVAlign = vAlign;
            }

            switch (lineVAlign) {
                case 1: // center
                case 'center':
                    offsetY = (height - lineHeight) / 2;
                    break;

                case 2: // bottom
                case 'bottom':
                    offsetY = height - lineHeight;
                    break;

                default: // top
                    offsetY = 0;
                    break;
            }

            OffsetChildren(children, offsetX, offsetY);

            offsetX += lineWidth;
        }
    };

    const GetValue$3B = Phaser.Utils.Objects.GetValue;

    var RunVerticalWrap$1 = function (config) {
        // Parse parameters
        var startIndex = GetValue$3B(config, 'start', 0);

        SetPadding$1(this.wrapPadding, GetValue$3B(config, 'padding', 0));
        var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
        var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;

        var lineWidth = GetValue$3B(config, 'lineWidth', undefined);
        var maxLines;
        if (lineWidth === undefined) {
            // Calculate lineWidth via maxLines, in fixedWidth mode
            maxLines = GetValue$3B(config, 'maxLines', 0);
            if (this.fixedWidth > 0) {
                var innerWidth = this.fixedWidth - paddingHorizontal;
                lineWidth = innerWidth / maxLines;
            } else {
                lineWidth = 0;
            }
        } else {
            if (this.fixedWidth > 0) {
                // Calculate maxLines via lineWidth, in fixedWidth mode
                maxLines = GetValue$3B(config, 'maxLines', undefined);
                if (maxLines === undefined) {
                    var innerWidth = this.fixedWidth - paddingHorizontal;
                    maxLines = Math.floor(innerWidth / lineWidth) + 1;
                }
            } else {
                maxLines = GetValue$3B(config, 'maxLines', 0); // Default is show all lines
            }

        }
        var showAllLines = (maxLines === 0);

        // Get fixedCharacterHeight
        var fixedCharacterHeight = GetValue$3B(config, 'fixedCharacterHeight', undefined);
        if (fixedCharacterHeight === undefined) {
            var charPerLine = GetValue$3B(config, 'charPerLine', undefined);
            if (charPerLine !== undefined) {
                var innerHeight = this.fixedHeight - paddingVertical;
                fixedCharacterHeight = Math.floor(innerHeight / charPerLine);
            }
        }

        // Get wrapHeight
        var wrapHeight = GetValue$3B(config, 'wrapHeight', undefined);
        if (wrapHeight === undefined) {
            if (this.fixedHeight > 0) {
                wrapHeight = this.fixedHeight - paddingVertical;
            } else {
                wrapHeight = Infinity; // No word-wrap
            }
        }

        var letterSpacing = GetValue$3B(config, 'letterSpacing', 0);

        var rtl = GetValue$3B(config, 'rtl', true);
        var hAlign = GetValue$3B(config, 'hAlign', rtl ? 2 : 0);
        var vAlign = GetValue$3B(config, 'vAlign', 0);

        var result = CreateWrapResultData({
            // Override properties
            callback: 'runVerticalWrap',
            start: startIndex,  // Next start index
            padding: this.wrapPadding,
            letterSpacing: letterSpacing,
            maxLines: maxLines,
            hAlign: hAlign,
            vAlign: vAlign,

            // Specific properties
            lineWidth: lineWidth,
            fixedCharacterHeight: fixedCharacterHeight,
            wrapHeight: wrapHeight,        
            rtl: rtl,
        });

        // Set all children to active
        var children = this.children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            children[i].setActive(false);
        }

        // Layout children
        wrapHeight += letterSpacing;
        var startX = this.padding.left + this.wrapPadding.left,  // Reset x of each character in AlignLines method
            startY = this.padding.top + this.wrapPadding.top,
            x = startX,
            y = startY;
        var remainderHeight = wrapHeight,
            childIndex = startIndex,
            lastChildIndex = children.length;
        var resultChildren = result.children;
        var resultLines = result.lines,
            lastLine = [], lastLineHeight = 0, maxLineHeight = 0;
        while (childIndex < lastChildIndex) {
            // Append non-typeable child directly
            var child = children[childIndex];
            childIndex++;
            if (!child.renderable) {
                child.setActive();
                resultChildren.push(child);
                lastLine.push(child);
                continue;
            }

            var childHeight = ((fixedCharacterHeight !== undefined) ? fixedCharacterHeight : child.height) + letterSpacing;
            // Next line
            var isNewLineChar = IsNewLineChar(child);
            var isPageBreakChar = IsPageBreakChar(child);
            var isControlChar = isNewLineChar || isPageBreakChar;
            if ((remainderHeight < childHeight) || isControlChar) {
                // Add to result
                if (isNewLineChar) {
                    child.setActive().setPosition(x, y).setOrigin(0.5);
                    resultChildren.push(child);
                    lastLine.push(child);
                }

                // Move cursor
                x = startX;
                y = startY;
                remainderHeight = wrapHeight;
                resultLines.push({ children: lastLine, height: lastLineHeight });
                maxLineHeight = Math.max(maxLineHeight, lastLineHeight);

                lastLineHeight = 0;
                lastLine = [];

                var isPageEnd = isPageBreakChar ||
                    (!showAllLines && (resultLines.length === maxLines)); // Exceed maxLines
                if (isPageEnd) {
                    break;
                } else if (isControlChar) {  // Already add to result                
                    continue;
                }
            }
            remainderHeight -= childHeight;
            lastLineHeight += childHeight;

            child.setActive().setPosition(x, y).setOrigin(0.5);
            resultChildren.push(child);
            lastLine.push(child);
            y += childHeight;
        }

        if (lastLine.length > 0) {
            resultLines.push({ children: lastLine, height: lastLineHeight });
            maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
        }

        result.start += resultChildren.length;
        result.isLastPage = (result.start === lastChildIndex);
        result.maxLineHeight = maxLineHeight;
        result.linesWidth = (resultLines.length * lineWidth);

        // Calculate size of game object
        var width = (this.fixedWidth > 0) ? this.fixedWidth : (result.linesWidth + paddingHorizontal);
        var height = (this.fixedHeight > 0) ? this.fixedHeight : (result.maxLineHeight + paddingVertical);

        // Size might be changed after wrapping
        var innerWidth = width - paddingHorizontal;
        var innerHeight = height - paddingVertical;
        AlignLines(result, innerWidth, innerHeight);

        // Resize
        this.setCanvasSize(width, height);

        // Set initial position
        for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
            var child = resultChildren[i];
            if (!child.renderable) {
                continue;
            }
            child.x0 = child.x;
            child.y0 = child.y;
        }

        return result;
    };

    const Merge$5 = Phaser.Utils.Objects.Merge;

    var RunVerticalWrap = function (config) {
        if (config === undefined) {
            config = {};
        }

        return RunVerticalWrap$1.call(this, Merge$5(config, this.wrapConfig));
    };

    const GetValue$3A = Phaser.Utils.Objects.GetValue;

    var RunWrap = function (config) {
        var wrapCallback = GetValue$3A(this.wrapConfig, 'callback');
        if (!wrapCallback) {
            wrapCallback = GetValue$3A(config, 'callback', this.runWordWrap);
        }
        if (typeof (wrapCallback) === 'string') {
            wrapCallback = this[wrapCallback];
        }

        return wrapCallback.call(this, config);
    };

    var SetAlignMethods = {
        setVAlign(align) {
            this.wrapConfig.vAlign = align;
            return this;
        },

        setHAlign(align) {
            this.wrapConfig.hAlign = align;
            return this;
        }
    };

    var SetTextOXYMethods$1 = {
        setTextOX(ox) {
            if (ox === this._textOX) {
                return this;
            }

            this._textOX = ox;
            return this;
        },

        setTextOY(oy) {
            if (oy === this._textOY) {
                return this;
            }

            this._textOY = oy;
            return this;
        },

        setTextOXY(ox, oy) {
            if ((ox === this._textOX) && (oy === this._textOY)) {
                return;
            }

            this._textOX = ox;
            this._textOY = oy;
            return this;
        },

        addTextOX(incX) {
            this.setTextOX(this._textOX + incX);
            return this;
        },

        addTextOY(incY) {
            this.setTextOY(this._textOY + incY);
            return this;
        },

        addTextOXY(incX, incY) {
            this.setTextOXY(this._textOX + incX, this._textOY + incY);
            return this;
        }

    };

    var RenderContent = function () {
        this.clear();

        this.setCanvasSize(this.width, this.height);

        if (this.background.active) {
            this.background.render();
        }

        var child;
        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
            child = this.children[i];
            if (child.active) {
                child.render();
            }
        }

        if (this.innerBounds.active) {
            this.innerBounds.render();
        }
    };

    var ForEachChild = function (callback, scope, activeOnly) {
        if (activeOnly === undefined) {
            activeOnly = true;
        }

        var children = this.children.filter(function (child) {
            if (activeOnly && !child.active) {
                return false;
            }
            return true;
        });

        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];

            var isBreak;
            if (scope) {
                isBreak = callback.call(this, child, i, children);
            } else {
                isBreak = callback(child, i, children);
            }

            if (isBreak) {
                break;
            }
        }

        return this;
    };

    var ForEachRenderableChild = function (callback, scope, activeOnly) {
        if (activeOnly === undefined) {
            activeOnly = true;
        }

        var children = this.children.filter(function (child) {
            if (activeOnly && !child.active) {
                return false;
            }
            if (!child.renderable || child.removed) {
                return false;
            }

            return true;
        });

        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];

            var isBreak;
            if (scope) {
                isBreak = callback.call(this, child, i, children);
            } else {
                isBreak = callback(child, i, children);
            }

            if (isBreak) {
                break;
            }
        }

        return this;
    };

    var ForEachCharChild = function (callback, scope, activeOnly) {
        if (activeOnly === undefined) {
            activeOnly = true;
        }

        var children = this.children.filter(function (child) {
            if (activeOnly && !child.active) {
                return false;
            }
            if (!IsChar(child) || child.removed) {
                return false;
            }

            return true;
        });

        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];

            var isBreak;
            if (scope) {
                isBreak = callback.call(this, child, i, children);
            } else {
                isBreak = callback(child, i, children);
            }

            if (isBreak) {
                break;
            }
        }

        return this;
    };

    var GetChildren = function () {
        return this.children;
    };

    const GetAll = Phaser.Utils.Array.GetAll;

    var GetActiveChildren = function () {
        return GetAll(this.children, 'active', true);
    };

    var GetCharChildren = function (activeOnly, out) {
        if (out === undefined) {
            out = [];
        }

        this.forEachCharChild(function (child) {
            out.push(child);
        }, undefined, activeOnly);

        return out;
    };

    var GetLastAppendedChildren = function () {
        return this.lastAppendedChildren;
    };

    var GetBobCenterPosition = function (bob, offsetX, offsetY, out) {
        if (typeof (offsetX) !== 'number') {
            out = offsetX;
            offsetX = 0;
            offsetY = 0;
        }
        var bobX = bob.drawCenterX + offsetX;
        var bobY = bob.drawCenterY + offsetY;
        return BobPositionToCanvasPosition(bob, bobX, bobY, out);
    };

    const GetDistance$1 = Phaser.Math.Distance.BetweenPointsSquared;

    var GetNearestChild = function (canvasX, canvasY) {
        var pointA = { x: canvasX, y: canvasY };

        var minDistance = Infinity;
        var nearestChild = null;
        this.forEachRenderableChild(function (child) {
            var distance = GetDistance$1(pointA, GetBobCenterPosition(child, true));
            if (minDistance > distance) {
                minDistance = distance;
                nearestChild = child;
            }
        });

        return nearestChild;
    };

    var GetCharWorldPosition = function (child, offsetX, offsetY, out) {
        if (typeof (child) === 'number') {
            child = this.getCharChild(child, true);
        }

        return GetBobWorldPosition(this, child, offsetX, offsetY, out);
    };

    var SetToMinSize = function () {
        var children = this.children;
        var maxX = 0,
            maxY = 0;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (!child.renderable || !child.active || !child.visible) {
                continue;
            }

            var x0 = (child.x0 !== undefined) ? child.x0 : child.x;
            var y0 = (child.y0 !== undefined) ? child.y0 : child.y;
            maxX = Math.max(maxX, x0);
            maxY = Math.max(maxY, y0);
        }

        var width = maxX + this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
        var height = maxY + this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;

        // Ignore fixedWidth, and fixedHeight
        if ((this.width !== width) || (this.height !== height)) {
            this.dirty = true;
            this.setCanvasSize(width, height);
        }
        return this;
    };

    var GetCharChildIndex = function (charIndex, activeOnly) {
        if (activeOnly === undefined) {
            activeOnly = true;
        }

        var children = this.children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (activeOnly && !child.active) {
                continue;
            }

            if (IsChar(child) && !child.removed) {
                if (charIndex === 0) {
                    return i;
                } else {
                    charIndex--;
                }
            }
        }

        return undefined;
    };

    var GetCharChild = function (charIndex, activeOnly) {
        if (activeOnly === undefined) {
            activeOnly = true;
        }

        var children = this.children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (activeOnly && !child.active) {
                continue;
            }

            if (IsChar(child) && !child.removed) {
                if (charIndex === 0) {
                    return child;
                } else {
                    charIndex--;
                }
            }
        }

        return undefined;
    };

    var GetCharIndex = function (childIndex, activeOnly) {
        if (typeof (childIndex) !== 'number') {
            childIndex = this.children.indexOf(childIndex);
            if (childIndex < 0) {
                return null;
            }
        }

        if (activeOnly === undefined) {
            activeOnly = true;
        }

        var children = this.children;
        if (childIndex >= children.length) {
            childIndex = children.length;
        }
        var charIndex = 0;
        for (var i = 0; i < childIndex; i++) {
            var child = children[i];
            if (activeOnly && !child.active) {
                continue;
            }

            if (IsChar(child) && !child.removed) {
                charIndex++;
            }
        }

        return charIndex;
    };

    var SetChildrenInteractiveEnable = function (enable) {
        if (enable === undefined) {
            enable = true;
        }

        if (this.childrenInteractiveEnable !== enable) {
            this.lastOverChild = null;
        }

        this.childrenInteractiveEnable = enable;

        return this;
    };

    var GetFirstChildContains = function (children, x, y) {
        var children = children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (!child.active || !child.renderable) {
                continue;
            }
            if (child.contains(x, y)) {
                return child;
            }
        }
        return null;
    };

    var SetChildrenInteractive$2 = function () {
        this
            .on('pointerdown', OnPointerDown$1, this)

            .on('pointerdown', OnPointerUp$1, this)

            .on('pointermove', OnPointOverOut, this)
            .on('pointerover', OnPointOverOut, this)
            .on('pointerout', function (pointer, event) {
                OnPointOverOut.call(this, pointer, null, null, event);
            }, this);

        return this;
    };

    var OnPointerDown$1 = function (pointer, localX, localY, event) {
        if (!this.childrenInteractiveEnable) {
            return;
        }

        var child = GetFirstChildContains(this.children, localX, localY);
        if (!child) {
            return;
        }

        this.emit('child.pointerdown', child, pointer, localX, localY, event);
    };

    var OnPointerUp$1 = function (pointer, localX, localY, event) {
        if (!this.childrenInteractiveEnable) {
            return;
        }

        var child = GetFirstChildContains(this.children, localX, localY);
        if (!child) {
            return;
        }

        this.emit('child.pointerup', child, pointer, localX, localY, event);
    };

    var OnPointOverOut = function (pointer, localX, localY, event) {
        if (!this.childrenInteractiveEnable) {
            return;
        }

        if (localX === null) {  // Case of pointerout
            if (this.lastOverChild !== null) {
                this.emit('child.pointerout', this.lastOverChild, pointer, localX, localY, event);
                this.lastOverChild = null;
            }
            return;
        }

        var child = GetFirstChildContains(this.children, localX, localY);
        if (child === this.lastOverChild) {
            return;
        }

        if (this.lastOverChild !== null) {
            this.emit('child.pointerout', this.lastOverChild, pointer, localX, localY, event);
        }

        if (child !== null) {
            this.emit('child.pointerover', child, pointer, localX, localY, event);
        }

        this.lastOverChild = child;
    };

    const GameObject = Phaser.GameObjects.GameObject;

    var SetInteractive = function (hitArea, hitAreaCallback, dropZone) {
        var isInteractived = !!this.input;

        GameObject.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);

        if (!isInteractived) {
            SetChildrenInteractive$2.call(this);
        }

        return this;
    };

    const BringToTop = Phaser.Utils.Array.BringToTop;
    const SendToBack = Phaser.Utils.Array.SendToBack;
    const MoveUp = Phaser.Utils.Array.MoveUp;
    const MoveDown = Phaser.Utils.Array.MoveDown;
    const MoveAbove = Phaser.Utils.Array.MoveAbove;
    const MoveBelow = Phaser.Utils.Array.MoveBelow;

    var MoveChildMethods = {
        moveChildToFist(child) {
            SendToBack(this.children, child);
            return this;
        },

        moveChildToLast(child) {
            BringToTop(this.children, child);
            return this;
        },
        movechildUp(child) {
            MoveUp(this.children, child);
            return this;
        },

        movechildDown(child) {
            MoveDown(this.children, child);
            return this;
        },

        movechildAbove(child, baseChild) {
            MoveAbove(this.children, child, baseChild);
            return this;
        },

        movechildBelow(child, baseChild) {
            MoveBelow(this.children, child, baseChild);
            return this;
        },

    };

    var BackgroundMethods = {
        setBackgroundColor(color, color2, isHorizontalGradient) {
            this.background.setColor(color, color2, isHorizontalGradient);
            return this;
        },

        setBackgroundStroke(color, lineWidth) {
            this.background.setStroke(color, lineWidth);
            return this;
        },

        setBackgroundCornerRadius(radius, iteration) {
            this.background.setCornerRadius(radius, iteration);
            return this;
        }
    };

    var InnerBoundsMethods = {
        setInnerBoundsColor(color, color2, isHorizontalGradient) {
            this.innerBounds.setColor(color, color2, isHorizontalGradient);
            return this;
        },

        setInnerBoundsStroke(color, lineWidth) {
            this.innerBounds.setStroke(color, lineWidth);
            return this;
        },
    };

    var Methods$j = {
        setFixedSize: SetFixedSize,
        setPadding: SetPadding,
        getPadding: GetPadding,
        modifyTextStyle: ModifyTextStyle,
        modifyDefaultTextStyle: ModifyDefaultTextStyle,
        resetTextStyle: ResetTextStyle,
        setTestString: SetTestString,

        removeChild: RemoveChild$2,
        removeChildren: RemoveChildren,
        popChild: PopChild,
        clearContent: ClearContent,
        addChild: AddChild$3,
        createCharChild: CreateCharChild,
        createCharChildren: CreateCharChildren,
        setText: SetText$2,
        appendText: AppendText,
        insertText: InsertText,
        removeText: RemoveText,
        getText: GetText,
        createImageChild: CreateImageChild,
        appendImage: AppendImage,
        createDrawerChild: CreateDrawerChild,
        appendDrawer: AppendDrawer,
        createSpaceChild: CreateSpaceChild,
        appendSpace: AppendSpace,
        createCommandChild: CreateCommandChild,
        appendCommand: AppendCommand$3,

        setWrapConfig: SetWrapConfig,
        runWordWrap: RunWordWrap,
        runVerticalWrap: RunVerticalWrap,
        runWrap: RunWrap,
        renderContent: RenderContent,

        forEachChild: ForEachChild,
        forEachRenderableChild: ForEachRenderableChild,
        forEachCharChild: ForEachCharChild,
        getChildren: GetChildren,
        getActiveChildren: GetActiveChildren,
        getCharChildren: GetCharChildren,
        getLastAppendedChildren: GetLastAppendedChildren,
        getNearestChild: GetNearestChild,
        getCharWorldPosition: GetCharWorldPosition,

        setToMinSize: SetToMinSize,

        getCharChildIndex: GetCharChildIndex,
        getCharChild: GetCharChild,
        getCharIndex: GetCharIndex,


        setChildrenInteractiveEnable: SetChildrenInteractiveEnable,
        setInteractive: SetInteractive,
    };

    Object.assign(
        Methods$j,

        MoveChildMethods,
        BackgroundMethods,
        InnerBoundsMethods,
        SetAlignMethods,
        SetTextOXYMethods$1,

    );

    const GetFastValue$1 = Phaser.Utils.Objects.GetFastValue;

    var Pools = {};
    class PoolManager {
        constructor(config) {
            this.pools = GetFastValue$1(config, 'pools', Pools);
        }

        free(bob) {
            if (!this.pools) {
                return this;
            }

            var bobType = bob.type;
            if (!this.pools.hasOwnProperty(bobType)) {
                this.pools[bobType] = new Stack();
            }
            this.pools[bobType].push(bob);
            bob.onFree();
            return this;
        }

        freeMultiple(arr) {
            if (!this.pools) {
                return this;
            }

            for (var i = 0, cnt = arr.length; i < cnt; i++) {
                this.free(arr[i]);
            }
            return this;
        }

        allocate(bobType) {
            if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
                return null;
            }
            return this.pools[bobType].pop();
        }
    }

    const IsPlainObject$O = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3z = Phaser.Utils.Objects.GetValue;

    class DynamicText extends Canvas$1 {
        constructor(scene, x, y, fixedWidth, fixedHeight, resolution, config) {
            if (IsPlainObject$O(x)) {
                config = x;
                x = GetValue$3z(config, 'x', 0);
                y = GetValue$3z(config, 'y', 0);
                fixedWidth = GetValue$3z(config, 'width', 0);
                fixedHeight = GetValue$3z(config, 'height', 0);
                resolution = GetValue$3z(config, 'resolution', 1);
            } else if (IsPlainObject$O(fixedWidth)) {
                config = fixedWidth;
                fixedWidth = GetValue$3z(config, 'width', 0);
                fixedHeight = GetValue$3z(config, 'height', 0);
                resolution = GetValue$3z(config, 'resolution', 1);
            } else if (IsPlainObject$O(resolution)) {
                config = resolution;
                resolution = GetValue$3z(config, 'resolution', 1);
            }

            var width = (fixedWidth === 0) ? 1 : fixedWidth;
            var height = (fixedHeight === 0) ? 1 : fixedHeight;
            super(scene, x, y, width, height, resolution);
            this.type = 'rexDynamicText';
            this.autoRound = true;
            this.padding = SetPadding$1();
            this.wrapPadding = SetPadding$1();

            var textStyleConfig = GetValue$3z(config, 'style', undefined);
            this.defaultTextStyle = new TextStyle(null, textStyleConfig);
            this.textStyle = this.defaultTextStyle.clone();
            this.setTestString(GetValue$3z(config, 'testString', '|MÉqgy'));

            this._textOX = 0;
            this._textOY = 0;
            this.background = new Background(this, GetValue$3z(config, 'background', undefined));
            this.innerBounds = new InnerBounds(this, GetValue$3z(config, 'innerBounds', undefined));
            this.children = [];
            this.lastAppendedChildren = [];
            this.lastOverChild = null;
            this.poolManager = new PoolManager(config);

            this.setFixedSize(fixedWidth, fixedHeight);
            this.setPadding(GetValue$3z(config, 'padding', 0));
            this.setWrapConfig(GetValue$3z(config, 'wrap', undefined));
            this.setChildrenInteractiveEnable(GetValue$3z(config, 'childrenInteractive', false));

            var text = GetValue$3z(config, 'text', undefined);
            if (text) {
                this.setText(text);
            }
        }

        updateTexture() {
            super.updateTexture(function () {
                this.renderContent();
            }, this);
            return this;
        }

        get text() {
            return this.getText(true);
        }

        set text(value) {
            this.setText(value);
        }

        setSize(width, height) {
            this.setFixedSize(width, height);
            return this;
        }

        get textOX() {
            return this._textOX;
        }

        set textOX(value) {
            this.setTextOX(value);
        }

        get textOY() {
            return this._textOY;
        }

        set textOY(value) {
            this.setTextOY(value);
        }
    }

    Object.assign(
        DynamicText.prototype,
        Methods$j
    );

    ObjectFactory.register('dynamicText', function (x, y, width, height, config) {
        var gameObject = new DynamicText(this.scene, x, y, width, height, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.DynamicText', DynamicText);

    var EventEmitterMethods$1 = {
        setEventEmitter(eventEmitter, EventEmitterClass) {
            if (EventEmitterClass === undefined) {
                EventEmitterClass = Phaser.Events.EventEmitter; // Use built-in EventEmitter class by default
            }
            this._privateEE = (eventEmitter === true) || (eventEmitter === undefined);
            this._eventEmitter = (this._privateEE) ? (new EventEmitterClass()) : eventEmitter;
            return this;
        },

        destroyEventEmitter() {
            if (this._eventEmitter && this._privateEE) {
                this._eventEmitter.shutdown();
            }
            return this;
        },

        getEventEmitter() {
            return this._eventEmitter;
        },

        on() {
            if (this._eventEmitter) {
                this._eventEmitter.on.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        once() {
            if (this._eventEmitter) {
                this._eventEmitter.once.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        off() {
            if (this._eventEmitter) {
                this._eventEmitter.off.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        emit(event) {
            if (this._eventEmitter && event) {
                this._eventEmitter.emit.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        addListener() {
            if (this._eventEmitter) {
                this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        removeListener() {
            if (this._eventEmitter) {
                this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        removeAllListeners() {
            if (this._eventEmitter) {
                this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        listenerCount() {
            if (this._eventEmitter) {
                return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
            }
            return 0;
        },

        listeners() {
            if (this._eventEmitter) {
                return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
            }
            return [];
        },

        eventNames() {
            if (this._eventEmitter) {
                return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
            }
            return [];
        },
    };

    var PropertyMethods$1 = {
        hasProperty(property) {
            var gameObject = this.gameObject;
            if (gameObject.hasOwnProperty(property)) {
                return true;
            } else {
                var value = gameObject[property];
                return (value !== undefined);
            }
        },

        getProperty(property) {
            return this.gameObject[property];
        },

        setProperty(property, value) {
            this.gameObject[property] = value;
            return this;
        },

        easeProperty(config) {
            var property = config.property;
            var value = config.value;
            var duration = config.duration;
            var delay = config.delay;
            var ease = config.ease;
            var repeat = config.repeat;
            var isYoyo = config.yoyo;
            var isFrom = config.from;
            var onComplete = config.complete;
            var target = config.target;

            if (duration === undefined) {
                duration = 1000;
            }
            if (delay === undefined) {
                delay = 0;
            }
            if (ease === undefined) {
                ease = 'Linear';
            }
            if (repeat === undefined) {
                repeat = 0;
            }
            if (isYoyo === undefined) {
                isYoyo = false;
            }
            if (target === undefined) {
                target = this.gameObject;
            }
            if (isFrom) {
                var startValue = value;
                value = target[property];
                target[property] = startValue;
            }

            var config = {
                targets: target,
                duration: duration,
                delay: delay,
                ease: ease,
                repeat: repeat,
                yoyo: isYoyo,
                onComplete: onComplete,
            };
            config[property] = value;

            this.addTweenTask(property, config);

            return this;
        },

        addTweenTask(name, config) {
            var tweenTasks = this.tweens;
            var tweenTask = tweenTasks[name];
            if (tweenTask) {
                tweenTask.remove();
            }

            var onComplete = config.onComplete;
            config.onComplete = function () {
                tweenTasks[name].remove();
                tweenTasks[name] = null;
                if (onComplete) {
                    onComplete(config.targets, name);
                }
            };

            tweenTask = this.scene.tweens.add(config);
            tweenTask.timeScale = this.timeScale;
            tweenTasks[name] = tweenTask;
            return this;
        },

        getTweenTask(property) {
            return this.tweens[property];
        },

        freeTweens() {
            var tweenTasks = this.tweens,
                tweenTask;
            for (var propName in tweenTasks) {
                tweenTask = tweenTasks[propName];
                if (tweenTask) {
                    tweenTask.remove();
                }
                tweenTasks[propName] = null;
            }
            return this;
        }

    };

    var CallMethods$1 = {
        hasMethod(methodName) {
            return typeof (this.gameObject[methodName]) === 'function';
        },

        call(methodName, ...parameters) {
            if (!this.hasMethod(methodName)) {
                console.warn(`[GameObjectManager] Game object '${this.name}' does not have method '${methodName}'`);
                return this;
            }

            var gameObject = this.gameObject;
            gameObject[methodName].apply(gameObject, parameters);

            return this;
        }
    };

    var DataMethods$1 = {
        hasData(dataKey) {
            var gameObject = this.gameObject;
            return (gameObject.data) ? gameObject.data.has(dataKey) : false;
        },

        getData(dataKey) {
            return this.gameObject.getData(dataKey);
        },

        setData(dataKey, value) {
            this.gameObject.setData(dataKey, value);
            return this;
        },
    };

    class BobBase {
        constructor(GOManager, gameObject, name) {
            this.GOManager = GOManager;
            this.tweens = {};
            this.effects = {};
            this.setGO(gameObject, name);
        }

        get scene() {
            return this.GOManager.scene;
        }

        get timeScale() {
            return this.GOManager.timeScale;
        }

        destroy() {
            this.freeGO();
            this.GOManager = undefined;
        }

        freeGO() {
            this.freeTweens();
            this.gameObject.bob = undefined;
            this.gameObject.destroy();
            this.gameObject = undefined;
            return this;
        }

        setGO(gameObject, name) {
            gameObject.goName = name;
            gameObject.goType = this.GOManager.name;
            gameObject.bob = this;
            this.gameObject = gameObject;
            this.name = name;
            this.freeTweens();
            return this;
        }

        setTimeScale(timeScale) {
            var tweenTasks = this.tweens;
            for (var key in tweenTasks) {
                var tweenTask = tweenTasks[key];
                if (tweenTask) {
                    tweenTask.timeScale = timeScale;
                }
            }

            return this;
        }

    }

    Object.assign(
        BobBase.prototype,
        PropertyMethods$1,
        CallMethods$1,
        DataMethods$1,
    );

    var IsEmpty = function (source) {
        for (var k in source) {
            return false;
        }
        return true;
    };

    var IsSingleBob = function (name) {
        return name && (name.charAt(0) !== '!');
    };

    var GetMethods = {
        has(name) {
            return this.bobs.hasOwnProperty(name);
        },

        exists(name) {
            return this.bobs.hasOwnProperty(name);
        },

        get(name, out) {
            if (IsSingleBob(name)) {
                return this.bobs[name];

            } else {
                if (out === undefined) {
                    out = [];
                }

                if (name) {
                    name = name.substring(1);
                }

                for (var key in this.bobs) {
                    if (name && (key === name)) {
                        continue;
                    }

                    out.push(this.bobs[key]);
                }

                return out;
            }
        },

        getFitst(excluded) {
            if (excluded && (excluded.charAt(0) === '!')) {
                excluded = excluded.substring(1);
            }

            for (var name in this.bobs) {
                if (excluded && (excluded === name)) {
                    continue;
                }

                return this.bobs[name];
            }
            return null;
        },

        getGO(name, out) {
            var bob = this.get(name);
            if (!bob) {
                return null;

            } else if (!Array.isArray(bob)) {
                return bob.gameObject;

            } else {
                if (out === undefined) {
                    out = [];
                }
                var bobs = bob;
                bobs.forEach(function (bob) {
                    out.push(bob.gameObject);
                });

                return out;

            }
        },

        forEachGO(callback, scope) {
            for (var name in this.bobs) {
                var gameObject = this.bobs[name].gameObject;
                var stopLoop;
                if (scope) {
                    stopLoop = callback.call(scope, gameObject, name, this);
                } else {
                    stopLoop = callback(gameObject, name, this);
                }

                if (stopLoop) {
                    break;
                }
            }
            return this;
        },

        getAllGO(out) {
            if (out === undefined) {
                out = [];
            }

            for (var name in this.bobs) {
                var gameObject = this.bobs[name].gameObject;
                out.push(gameObject);
            }

            return out;
        }
    };

    var GetR = function (colorInt) {
        return (colorInt >> 16) & 0xff;
    };

    var GetG = function (colorInt) {
        return (colorInt >> 8) & 0xff;
    };

    var GetB = function (colorInt) {
        return (colorInt) & 0xff;
    };

    var GetRGB = function (colorInt, out) {
        if (out === undefined) {
            out = {};
        }

        out.r = (colorInt >> 16) & 0xff;
        out.g = (colorInt >> 8) & 0xff;
        out.b = (colorInt) & 0xff;

        return out;

    };

    const MaskR = (~(0xff << 16) & 0xffffff);
    const MaskG = (~(0xff << 8) & 0xffffff);
    const MaskB = (~(0xff) & 0xffffff);

    var SetR = function (colorInt, r) {
        return ((r & 0xff) << 16) | (colorInt & MaskR);
    };

    var SetG = function (colorInt, g) {
        return ((g & 0xff) << 8) | (colorInt & MaskG);
    };

    var SetB = function (colorInt, b) {
        return (b & 0xff) | (colorInt & MaskB);
    };

    var SetRGB = function (colorInt, r, g, b) {
        return ((r & 0xff) << 16) | ((g & 0xff) << 8) | ((b & 0xff));
    };

    var AddTintRGBProperties = function (gameObject, tintRGB) {
        // Don't attach properties again
        if (gameObject.hasOwnProperty('tintR')) {
            return gameObject;
        }

        if (tintRGB === undefined) {
            tintRGB = 0xffffff;
        }

        var tintR = GetR(tintRGB);
        var tintG = GetG(tintRGB);
        var tintB = GetB(tintRGB);

        // Override tint property
        Object.defineProperty(gameObject, 'tint', {
            get: function () {
                return tintRGB;
            },
            set: function (value) {
                value = Math.floor(value) & 0xffffff;
                if (gameObject.setTint) {
                    gameObject.setTint(value);
                }
                if (tintRGB !== value) {
                    tintRGB = value;
                    tintR = GetR(tintRGB);
                    tintG = GetG(tintRGB);
                    tintB = GetB(tintRGB);
                    // gameObject.emit('_tintchange', value, tintR, tintG, tintB);
                }
            }
        });

        Object.defineProperty(gameObject, 'tintR', {
            get: function () {
                return tintR;
            },
            set: function (value) {
                value = Math.floor(value) & 0xff;
                if (tintR !== value) {
                    tintR = value;
                    gameObject.tint = SetR(tintRGB, value);
                }
            },
        });
        Object.defineProperty(gameObject, 'tintG', {
            get: function () {
                return tintG;
            },
            set: function (value) {
                value = Math.floor(value) & 0xff;
                if (tintG !== value) {
                    tintG = value;
                    gameObject.tint = SetG(tintRGB, value);
                }
            },
        });
        Object.defineProperty(gameObject, 'tintB', {
            get: function () {
                return tintB;
            },
            set: function (value) {
                value = Math.floor(value) & 0xff;
                if (tintB !== value) {
                    tintB = value;
                    gameObject.tint = SetB(tintRGB, value);
                }
            },
        });
        Object.defineProperty(gameObject, 'tintGray', {
            get: function () {
                return Math.floor((tintR + tintG + tintB) / 3);
            },
            set: function (value) {
                value = Math.floor(value) & 0xff;
                if ((tintR !== value) || (tintG !== value) || (tintB !== value)) {
                    tintR = value;
                    tintG = value;
                    tintB = value;
                    gameObject.tint = SetRGB(tintRGB, value, value, value);
                }
            },
        });

        gameObject.tint = tintRGB;

        return gameObject;
    };

    const EventEmitter$1 = Phaser.Events.EventEmitter;

    var MonitorViewport = function (viewport) {
        // Don't monitor properties again
        if (viewport.events) {
            return viewport;
        }

        var events = new EventEmitter$1();

        var x = viewport.x;
        Object.defineProperty(viewport, 'x', {
            get: function () {
                return x;
            },

            set: function (value) {
                if (x !== value) {
                    x = value;
                    events.emit('update', viewport);
                }
            },
        });

        var y = viewport.y;
        Object.defineProperty(viewport, 'y', {
            get: function () {
                return y;
            },

            set: function (value) {
                if (y !== value) {
                    y = value;
                    events.emit('update', viewport);
                }
            },
        });

        var width = viewport.width;
        Object.defineProperty(viewport, 'width', {
            get: function () {
                return width;
            },

            set: function (value) {
                if (width !== value) {
                    width = value;
                    events.emit('update', viewport);
                }
            },
        });

        var height = viewport.height;
        Object.defineProperty(viewport, 'height', {
            get: function () {
                return height;
            },

            set: function (value) {
                if (height !== value) {
                    height = value;
                    events.emit('update', viewport);
                }
            },
        });

        viewport.events = events;

        return viewport;
    };

    var VPXYToXY = function (vpx, vpy, vpxOffset, vpyOffset, viewport, out) {
        if (out === undefined) {
            out = {};
        } else if (out === true) {
            out = GlobXY;
        }

        if (typeof (vpxOffset) !== 'number') {
            vpxOffset = 0;
            vpyOffset = 0;
        }

        out.x = viewport.x + (viewport.width * vpx) + vpxOffset;
        out.y = viewport.y + (viewport.height * vpy) + vpyOffset;
        return out;
    };

    var GlobXY = {};

    var AddViewportCoordinateProperties = function (gameObject, viewport, vpx, vpy, vpxOffset, vpyOffset, transformCallback) {
        // Don't attach properties again
        if (gameObject.hasOwnProperty('vp')) {
            return gameObject;
        }

        if (typeof (vpx) === 'function') {
            transformCallback = vpx;
            vpx = undefined;
        }

        if (typeof (vpxOffset) === 'function') {
            transformCallback = vpxOffset;
            vpxOffset = undefined;
        }


        if (vpx === undefined) { vpx = 0.5; }
        if (vpy === undefined) { vpy = 0.5; }
        if (vpxOffset === undefined) { vpxOffset = 0; }
        if (vpyOffset === undefined) { vpyOffset = 0; }

        if (transformCallback === undefined) {
            transformCallback = VPXYToXY;
        }

        MonitorViewport(viewport);
        var events = viewport.events;

        gameObject.vp = viewport;

        // Set position of game object when view-port changed.
        var Transform = function () {
            transformCallback(vpx, vpy, vpxOffset, vpyOffset, viewport, gameObject);
        };

        events.on('update', Transform);
        gameObject.once('destroy', function () {
            events.off('update', Transform);
            gameObject.vp = undefined;
        });

        Object.defineProperty(gameObject, 'vpx', {
            get: function () {
                return vpx;
            },
            set: function (value) {
                if (vpx !== value) {
                    vpx = value;
                    Transform();
                }
            },
        });

        Object.defineProperty(gameObject, 'vpy', {
            get: function () {
                return vpy;
            },
            set: function (value) {
                if (vpy !== value) {
                    vpy = value;
                    Transform();
                }
            },
        });

        Object.defineProperty(gameObject, 'vpxOffset', {
            get: function () {
                return vpxOffset;
            },
            set: function (value) {
                if (vpxOffset !== value) {
                    vpxOffset = value;
                    Transform();
                }
            },
        });

        Object.defineProperty(gameObject, 'vpyOffset', {
            get: function () {
                return vpyOffset;
            },
            set: function (value) {
                if (vpyOffset !== value) {
                    vpyOffset = value;
                    Transform();
                }
            },
        });

        Transform();
    };

    var GetFXFactory = function (gameObject) {
        if (gameObject.preFX) {
            return gameObject.preFX;
        }
        if (gameObject.postFX) {
            return gameObject.postFX;
        }
        return null;
    };

    var AddClearEffectCallback = function (gameObject, effectSwitchName) {
        if (!gameObject._effectSwitchNames) {
            gameObject._effectSwitchNames = [];

            gameObject.clearAllEffects = function () {
                var effectSwitchNames = gameObject._effectSwitchNames;
                for (var i = 0, cnt = effectSwitchNames.length; i < cnt; i++) {
                    gameObject[effectSwitchNames[i]] = null;
                }

                return gameObject;
            };
            gameObject.on('destroy', gameObject.clearAllEffects, gameObject);
        }

        gameObject._effectSwitchNames.push(effectSwitchName);
    };

    var AddBarrelProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'barrel')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var barrel;
        Object.defineProperty(gameObject, 'barrel', {
            get: function () {
                return barrel;
            },
            set: function (value) {
                if (barrel === value) {
                    return;
                }

                barrel = value;

                if ((barrel === null) || (barrel === false)) {
                    if (gameObject._barrelEffect) {
                        fxFactory.remove(gameObject._barrelEffect);
                        gameObject._barrelEffect = undefined;
                    }
                } else {
                    if (!gameObject._barrelEffect) {
                        gameObject._barrelEffect = fxFactory.addBarrel();
                    }
                    gameObject._barrelEffect.amount = barrel;
                }

            },
        });

        gameObject.barrel = null;

        AddClearEffectCallback(gameObject, 'barrel');

        return gameObject;
    };

    var AddColorMatrixEffectPropertiesBase = function (gameObject, effectName, inputMode) {
        // Don't attach properties again
        if (HasProperty(gameObject, effectName)) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var EffectInstancePropertyName = `_${effectName}Effect`;

        var currentValue;
        Object.defineProperty(gameObject, effectName, {
            get: function () {
                return currentValue;
            },
            set: function (value) {
                if (currentValue === value) {
                    return;
                }

                currentValue = value;

                if ((currentValue === null) || (currentValue === false)) {
                    if (gameObject[EffectInstancePropertyName]) {
                        fxFactory.remove(gameObject[EffectInstancePropertyName]);
                        gameObject[EffectInstancePropertyName] = undefined;
                    }
                } else {
                    if (!gameObject[EffectInstancePropertyName]) {
                        gameObject[EffectInstancePropertyName] = fxFactory.addColorMatrix();
                    }
                    var effectInstance = gameObject[EffectInstancePropertyName];
                    effectInstance[effectName]((inputMode === 1) ? value : undefined);
                }

            },
        });

        gameObject[effectName] = null;

        AddClearEffectCallback(gameObject, effectName);

        return gameObject;
    };

    var AddBlackWhiteProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'blackWhite');
        return gameObject;
    };

    var AddBloomProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'bloomColor')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var bloomColor,
            bloomOffsetX = 1,
            bloomOffsetY = 1,
            bloomBlurStrength = 1,
            bloomStrength = 1,
            bloomSteps = 4;
        Object.defineProperty(gameObject, 'bloomColor', {
            get: function () {
                return bloomColor;
            },
            set: function (value) {
                if (bloomColor === value) {
                    return;
                }

                bloomColor = value;

                if ((bloomColor === null) || (bloomColor === false)) {
                    if (gameObject._bloom) {
                        fxFactory.remove(gameObject._bloom);
                        gameObject._bloom = undefined;
                        fxFactory.setPadding(0);
                    }
                } else {
                    if (!gameObject._bloom) {
                        gameObject._bloom = fxFactory.addBloom(bloomColor, bloomOffsetX, bloomOffsetY, bloomBlurStrength, bloomStrength, bloomSteps);
                        fxFactory.setPadding(Math.max(bloomOffsetX, bloomOffsetY) + 1);
                    }

                    gameObject._bloom.color = bloomColor;
                }

            },
        });

        Object.defineProperty(gameObject, 'bloomOffsetX', {
            get: function () {
                return bloomOffsetX;
            },
            set: function (value) {
                if (bloomOffsetX === value) {
                    return;
                }

                bloomOffsetX = value;

                if (gameObject._bloom) {
                    var offset = Math.max(bloomOffsetX, bloomOffsetY);
                    fxFactory.setPadding(offset + 1);
                    gameObject._bloom.offsetX = bloomOffsetX;
                }
            },
        });

        Object.defineProperty(gameObject, 'bloomOffsetY', {
            get: function () {
                return bloomOffsetY;
            },
            set: function (value) {
                if (bloomOffsetY === value) {
                    return;
                }

                bloomOffsetY = value;

                if (gameObject._bloom) {
                    var offset = Math.max(bloomOffsetX, bloomOffsetY);
                    fxFactory.setPadding(offset + 1);
                    gameObject._bloom.offsetY = bloomOffsetY;
                }
            },
        });

        Object.defineProperty(gameObject, 'bloomBlurStrength', {
            get: function () {
                return bloomBlurStrength;
            },
            set: function (value) {
                if (bloomBlurStrength === value) {
                    return;
                }

                bloomBlurStrength = value;

                if (gameObject._bloom) {
                    gameObject._bloom.blurStrength = bloomBlurStrength;
                }
            },
        });

        Object.defineProperty(gameObject, 'bloomStrength', {
            get: function () {
                return bloomStrength;
            },
            set: function (value) {
                if (bloomStrength === value) {
                    return;
                }

                bloomStrength = value;

                if (gameObject._bloom) {
                    gameObject._bloom.strength = bloomStrength;
                }
            },
        });

        Object.defineProperty(gameObject, 'bloomSteps', {
            get: function () {
                return bloomSteps;
            },
            set: function (value) {
                if (bloomSteps === value) {
                    return;
                }

                bloomSteps = value;

                if (gameObject._bloom) {
                    gameObject._bloom.steps = bloomSteps;
                }
            },
        });

        gameObject.bloomColor = null;

        AddClearEffectCallback(gameObject, 'bloomColor');

        return gameObject;
    };

    var AddBlurProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'blurColor')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var blurColor,
            blurQuality = 0,
            blurX = 1,
            blurY = 1,
            blurStrength = 1,
            blurSteps = 4;
        Object.defineProperty(gameObject, 'blurColor', {
            get: function () {
                return blurColor;
            },
            set: function (value) {
                if (blurColor === value) {
                    return;
                }

                blurColor = value;

                if ((blurColor === null) || (blurColor === false)) {
                    if (gameObject._blur) {
                        fxFactory.remove(gameObject._blur);
                        gameObject._blur = undefined;
                        fxFactory.setPadding(0);
                    }
                } else {
                    if (!gameObject._blur) {
                        gameObject._blur = fxFactory.addBlur(blurQuality, blurX, blurY, blurStrength, blurColor, blurSteps);
                        fxFactory.setPadding(Math.max(blurX, blurY) + 1);
                    }

                    gameObject._blur.color = blurColor;
                }

            },
        });

        Object.defineProperty(gameObject, 'blurQuality', {
            get: function () {
                return blurQuality;
            },
            set: function (value) {
                if (blurQuality === value) {
                    return;
                }

                blurQuality = value;

                if (gameObject._blur) {
                    gameObject._blur.quality = blurQuality;
                }

            },
        });

        Object.defineProperty(gameObject, 'blurX', {
            get: function () {
                return blurX;
            },
            set: function (value) {
                if (blurX === value) {
                    return;
                }

                blurX = value;

                if (gameObject._blur) {
                    var offset = Math.max(blurX, blurY);
                    fxFactory.setPadding(offset + 1);
                    gameObject._blur.x = blurX;
                }
            },
        });

        Object.defineProperty(gameObject, 'blurY', {
            get: function () {
                return blurY;
            },
            set: function (value) {
                if (blurY === value) {
                    return;
                }

                blurY = value;

                if (gameObject._blur) {
                    var offset = Math.max(blurX, blurY);
                    fxFactory.setPadding(offset + 1);
                    gameObject._blur.y = blurY;
                }
            },
        });

        Object.defineProperty(gameObject, 'blurStrength', {
            get: function () {
                return blurStrength;
            },
            set: function (value) {
                if (blurStrength === value) {
                    return;
                }

                blurStrength = value;

                if (gameObject._blur) {
                    gameObject._blur.strength = blurStrength;
                }
            },
        });

        Object.defineProperty(gameObject, 'blurSteps', {
            get: function () {
                return blurSteps;
            },
            set: function (value) {
                if (blurSteps === value) {
                    return;
                }

                blurSteps = value;

                if (gameObject._blur) {
                    gameObject._blur.steps = blurSteps;
                }
            },
        });

        gameObject.blurColor = null;

        AddClearEffectCallback(gameObject, 'blurColor');

        return gameObject;
    };

    var AddBokehProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'bokehRadius')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var bokehRadius,
            bokehAmount = 1,
            bokehContrast = 0.2;
        Object.defineProperty(gameObject, 'bokehRadius', {
            get: function () {
                return bokehRadius;
            },
            set: function (value) {
                if (bokehRadius === value) {
                    return;
                }

                bokehRadius = value;

                if ((bokehRadius === null) || (bokehRadius === false)) {
                    if (gameObject._bokeh) {
                        fxFactory.remove(gameObject._bokeh);
                        gameObject._bokeh = undefined;
                    }
                } else {
                    if (!gameObject._bokeh) {
                        gameObject._bokeh = fxFactory.addBokeh(bokehRadius, bokehAmount, bokehContrast);
                    }

                    gameObject._bokeh.radius = bokehRadius;
                }

            },
        });

        Object.defineProperty(gameObject, 'bokehAmount', {
            get: function () {
                return bokehAmount;
            },
            set: function (value) {
                if (bokehAmount === value) {
                    return;
                }

                bokehAmount = value;

                if (gameObject._bokeh) {
                    gameObject._bokeh.amount = bokehAmount;
                }
            },
        });

        Object.defineProperty(gameObject, 'bokehContrast', {
            get: function () {
                return bokehContrast;
            },
            set: function (value) {
                if (bokehContrast === value) {
                    return;
                }

                bokehContrast = value;

                if (gameObject._bokeh) {
                    gameObject._bokeh.contrast = bokehContrast;
                }
            },
        });

        gameObject.bokehRadius = null;

        AddClearEffectCallback(gameObject, 'bokehRadius');

        return gameObject;
    };

    var AddBrightnessProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'brightness', 1);
        return gameObject;
    };

    var AddBrownProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'brown');
        return gameObject;
    };

    var AddCircleProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'circleColor')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var circleColor,
            circleThickness = 8,
            circleBackgroundColor = 0x000000,
            circleBackgroundAlpha = 0.4,
            circleScale = 1,
            circleFeather = 0.005;
        Object.defineProperty(gameObject, 'circleColor', {
            get: function () {
                return circleColor;
            },
            set: function (value) {
                if (circleColor === value) {
                    return;
                }

                circleColor = value;

                if ((circleColor === null) || (circleColor === false)) {
                    if (gameObject._circle) {
                        fxFactory.remove(gameObject._circle);
                        gameObject._circle = undefined;
                    }
                } else {
                    if (!gameObject._circle) {
                        gameObject._circle = fxFactory.addCircle(circleThickness, circleColor, circleBackgroundColor, circleScale, circleFeather);
                        gameObject.circleBackgroundAlpha = circleBackgroundAlpha;
                    }

                    gameObject._circle.color = circleColor;
                }

            },
        });

        Object.defineProperty(gameObject, 'circleThickness', {
            get: function () {
                return circleThickness;
            },
            set: function (value) {
                if (circleThickness === value) {
                    return;
                }

                circleThickness = value;

                if (gameObject._circle) {
                    gameObject._circle.thickness = circleThickness;
                }
            },
        });

        Object.defineProperty(gameObject, 'circleBackgroundColor', {
            get: function () {
                return circleBackgroundColor;
            },
            set: function (value) {
                if (circleBackgroundColor === value) {
                    return;
                }

                circleBackgroundColor = value;

                if (gameObject._circle) {
                    gameObject._circle.backgroundColor = circleBackgroundColor;
                }
            },
        });

        Object.defineProperty(gameObject, 'circleBackgroundAlpha', {
            get: function () {
                return circleBackgroundAlpha;
            },
            set: function (value) {
                if (circleBackgroundAlpha === value) {
                    return;
                }

                circleBackgroundAlpha = value;

                if (gameObject._circle) {
                    gameObject._circle.glcolor2[3] = circleBackgroundAlpha;
                }
            },
        });


        Object.defineProperty(gameObject, 'circleScale', {
            get: function () {
                return circleScale;
            },
            set: function (value) {
                if (circleScale === value) {
                    return;
                }

                circleScale = value;

                if (gameObject._circle) {
                    gameObject._circle.scale = circleScale;
                }
            },
        });

        Object.defineProperty(gameObject, 'circleFeather', {
            get: function () {
                return circleFeather;
            },
            set: function (value) {
                if (circleFeather === value) {
                    return;
                }

                circleFeather = value;

                if (gameObject._circle) {
                    gameObject._circle.feather = circleFeather;
                }
            },
        });

        gameObject.circleColor = null;

        AddClearEffectCallback(gameObject, 'circleColor');

        return gameObject;
    };

    var AddContrastProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'contrast', 1);
        return gameObject;
    };

    var AddDesaturateProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'desaturate', 1);
        return gameObject;
    };

    var AddDesaturateLuminanceProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'desaturateLuminance');
        return gameObject;
    };

    var AddDisplacementProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'displacementKey')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var displacementKey,
            displacementX = 0.005,
            displacementY = 0.005;
        Object.defineProperty(gameObject, 'displacementKey', {
            get: function () {
                return displacementKey;
            },
            set: function (value) {
                if (displacementKey === value) {
                    return;
                }

                displacementKey = value;

                if ((displacementKey === null) || (displacementKey === false)) {
                    if (gameObject._displacement) {
                        fxFactory.remove(gameObject._displacement);
                        gameObject._displacement = undefined;
                    }
                } else {
                    if (!gameObject._displacement) {
                        gameObject._displacement = fxFactory.addDisplacement(displacementKey, displacementX, displacementY);
                    }

                    gameObject._displacement.setTexture(displacementKey);
                }

            },
        });

        Object.defineProperty(gameObject, 'displacementX', {
            get: function () {
                return displacementX;
            },
            set: function (value) {
                if (displacementX === value) {
                    return;
                }

                displacementX = value;

                if (gameObject._displacement) {
                    gameObject._displacement.x = displacementX;
                }
            },
        });

        Object.defineProperty(gameObject, 'displacementY', {
            get: function () {
                return displacementY;
            },
            set: function (value) {
                if (displacementY === value) {
                    return;
                }

                displacementY = value;

                if (gameObject._displacement) {
                    gameObject._displacement.y = displacementY;
                }
            },
        });

        gameObject.displacementKey = null;

        AddClearEffectCallback(gameObject, 'displacementKey');

        return gameObject;
    };

    var AddGlowProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'glowColor')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var glowColor,
            glowOuterStrength = 4,
            glowInnerStrength = 0;
        Object.defineProperty(gameObject, 'glowColor', {
            get: function () {
                return glowColor;
            },
            set: function (value) {
                if (glowColor === value) {
                    return;
                }

                glowColor = value;

                if ((glowColor === null) || (glowColor === false)) {
                    if (gameObject._glow) {
                        fxFactory.remove(gameObject._glow);
                        gameObject._glow = undefined;
                        fxFactory.setPadding(0);
                    }
                } else {
                    if (!gameObject._glow) {
                        gameObject._glow = fxFactory.addGlow(glowColor, glowOuterStrength, glowInnerStrength);
                        fxFactory.setPadding(glowOuterStrength + 1);
                    }

                    gameObject._glow.color = glowColor;
                }

            },
        });

        Object.defineProperty(gameObject, 'glowOuterStrength', {
            get: function () {
                return glowOuterStrength;
            },
            set: function (value) {
                if (glowOuterStrength === value) {
                    return;
                }

                glowOuterStrength = value;

                if (gameObject._glow) {
                    fxFactory.setPadding(glowOuterStrength + 1);
                    gameObject._glow.outerStrength = glowOuterStrength;
                }
            },
        });

        Object.defineProperty(gameObject, 'glowInnerStrength', {
            get: function () {
                return glowInnerStrength;
            },
            set: function (value) {
                if (glowInnerStrength === value) {
                    return;
                }

                glowInnerStrength = value;

                if (gameObject._glow) {
                    gameObject._glow.innerStrength = glowInnerStrength;
                }
            },
        });

        gameObject.glowColor = null;

        AddClearEffectCallback(gameObject, 'glowColor');

        return gameObject;
    };

    var AddGradientProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'gradientColor')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var gradientColor1,
            gradientColor2,
            gradientAlpha = 0.5,
            gradientFromX = 0,
            gradientFromY = 0,
            gradientToX = 0,
            gradientToY = 1,
            gradientSize = 0;
        Object.defineProperty(gameObject, 'gradientColor', {
            get: function () {
                return [gradientColor1, gradientColor2];
            },

            set: function (value) {
                var color1, color2;
                if ((value === null) || (value === false)) {
                    color1 = null;
                    color2 = null;
                } else {
                    color1 = value[0];
                    color2 = value[1];
                }

                if ((gradientColor1 === color1) && (gradientColor2 === color2)) {
                    return;
                }

                gradientColor1 = color1;
                gradientColor2 = color2;

                if ((gradientColor1 === null) || (gradientColor1 === false)) {
                    if (gameObject._gradient) {
                        fxFactory.remove(gameObject._gradient);
                        gameObject._gradient = undefined;
                    }
                } else {
                    if (!gameObject._gradient) {
                        gameObject._gradient = fxFactory.addGradient(gradientColor1, gradientColor2, gradientAlpha, gradientFromX, gradientFromY, gradientToX, gradientToY, gradientSize);
                    }

                    gameObject._gradient.color1 = gradientColor1;
                    gameObject._gradient.color2 = gradientColor2;
                }

            },
        });

        Object.defineProperty(gameObject, 'gradientColor1', {
            get: function () {
                return gradientColor1;
            },
            set: function (value) {
                if ((value === null) || (value === false)) {
                    gameObject.gradientColor = value;
                    return;
                }

                if (gradientColor1 === value) {
                    return;
                }

                gradientColor1 = value;

                if (gameObject._gradient) {
                    gameObject._gradient.color1 = gradientColor1;
                }
            },
        });

        Object.defineProperty(gameObject, 'gradientColor2', {
            get: function () {
                return gradientColor2;
            },
            set: function (value) {
                if ((value === null) || (value === false)) {
                    gameObject.gradientColor = value;
                    return;
                }

                if (gradientColor2 === value) {
                    return;
                }

                gradientColor2 = value;

                if (gameObject._gradient) {
                    gameObject._gradient.color2 = gradientColor2;
                }
            },
        });

        Object.defineProperty(gameObject, 'gradientAlpha', {
            get: function () {
                return gradientAlpha;
            },
            set: function (value) {
                if (gradientAlpha === value) {
                    return;
                }

                gradientAlpha = value;

                if (gameObject._gradient) {
                    gameObject._gradient.alpha = gradientAlpha;
                }
            },
        });

        Object.defineProperty(gameObject, 'gradientFromX', {
            get: function () {
                return gradientFromX;
            },
            set: function (value) {
                if (gradientFromX === value) {
                    return;
                }

                gradientFromX = value;

                if (gameObject._gradient) {
                    gameObject._gradient.fromX = gradientFromX;
                }
            },
        });

        Object.defineProperty(gameObject, 'gradientFromY', {
            get: function () {
                return gradientFromY;
            },
            set: function (value) {
                if (gradientFromY === value) {
                    return;
                }

                gradientFromY = value;

                if (gameObject._gradient) {
                    gameObject._gradient.fromY = gradientFromY;
                }
            },
        });


        Object.defineProperty(gameObject, 'gradientToX', {
            get: function () {
                return gradientToX;
            },
            set: function (value) {
                if (gradientToX === value) {
                    return;
                }

                gradientToX = value;

                if (gameObject._gradient) {
                    gameObject._gradient.toX = gradientToX;
                }
            },
        });

        Object.defineProperty(gameObject, 'gradientToY', {
            get: function () {
                return gradientToY;
            },
            set: function (value) {
                if (gradientToY === value) {
                    return;
                }

                gradientToY = value;

                if (gameObject._gradient) {
                    gameObject._gradient.toY = gradientToY;
                }
            },
        });

        Object.defineProperty(gameObject, 'gradientSize', {
            get: function () {
                return gradientSize;
            },
            set: function (value) {
                if (gradientSize === value) {
                    return;
                }

                gradientSize = value;

                if (gameObject._gradient) {
                    gameObject._gradient.size = gradientSize;
                }
            },
        });

        gameObject.gradientColor = null;

        AddClearEffectCallback(gameObject, 'gradientColor');

        return gameObject;
    };

    var AddGrayscaleProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'grayscale', 1);
        return gameObject;
    };

    var AddHueProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'hue', 1);
        return gameObject;
    };

    var AddKodachromeProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'kodachrome');
        return gameObject;
    };

    var AddLSDProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'lsd');
        return gameObject;
    };

    var AddNegativeProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'negative');
        return gameObject;
    };

    var AddPixelateProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'pixelate')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var pixelate;
        Object.defineProperty(gameObject, 'pixelate', {
            get: function () {
                return pixelate;
            },
            set: function (value) {
                if (pixelate === value) {
                    return;
                }

                pixelate = value;

                if ((pixelate === null) || (pixelate === false)) {
                    if (gameObject._pixelateEffect) {
                        fxFactory.remove(gameObject._pixelateEffect);
                        gameObject._pixelateEffect = undefined;
                    }
                } else {
                    if (!gameObject._pixelateEffect) {
                        gameObject._pixelateEffect = fxFactory.addPixelate();
                    }
                    gameObject._pixelateEffect.amount = pixelate;
                }

            },
        });

        gameObject.pixelate = null;

        AddClearEffectCallback(gameObject, 'pixelate');

        return gameObject;
    };

    var AddPolaroidProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'polaroid');
        return gameObject;
    };

    var AddRevealProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'revealLeft')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var revealLeft,
            revealRight,
            revealUp,
            revealDown,
            revealWidth = 0.1;

        var ClearRevealFlags = function () {
            revealLeft = null;
            revealRight = null;
            revealUp = null;
            revealDown = null;
        };

        var RemoveEffect = function (gameObject) {
            if (gameObject._revealEffect) {
                fxFactory.remove(gameObject._revealEffect);
                gameObject._revealEffect = undefined;
            }
        };

        Object.defineProperty(gameObject, 'revealLeft', {
            get: function () {
                return revealLeft;
            },
            set: function (value) {
                if (revealLeft === value) {
                    return;
                }

                ClearRevealFlags();

                revealLeft = value;

                if ((revealLeft === null) || (revealLeft === false)) {
                    RemoveEffect(gameObject);
                } else {
                    if (!gameObject._revealEffect) {
                        gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
                    }

                    gameObject._revealEffect.direction = 1;
                    gameObject._revealEffect.axis = 0;
                    gameObject._revealEffect.progress = revealLeft;
                }

            },
        });

        Object.defineProperty(gameObject, 'revealRight', {
            get: function () {
                return revealRight;
            },
            set: function (value) {
                if (revealRight === value) {
                    return;
                }

                ClearRevealFlags();

                revealRight = value;

                if ((revealRight === null) || (revealRight === false)) {
                    RemoveEffect(gameObject);
                } else {
                    if (!gameObject._revealEffect) {
                        gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
                    }
                    gameObject._revealEffect.direction = 0;
                    gameObject._revealEffect.axis = 0;
                    gameObject._revealEffect.progress = revealRight;
                }

            },
        });

        Object.defineProperty(gameObject, 'revealUp', {
            get: function () {
                return revealUp;
            },
            set: function (value) {
                if (revealUp === value) {
                    return;
                }

                ClearRevealFlags();

                revealUp = value;

                if ((revealUp === null) || (revealUp === false)) {
                    RemoveEffect(gameObject);
                } else {
                    if (!gameObject._revealEffect) {
                        gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
                    }
                    gameObject._revealEffect.direction = 1;
                    gameObject._revealEffect.axis = 1;
                    gameObject._revealEffect.progress = revealUp;
                }

            },
        });

        Object.defineProperty(gameObject, 'revealDown', {
            get: function () {
                return revealDown;
            },
            set: function (value) {
                if (revealDown === value) {
                    return;
                }

                ClearRevealFlags();

                revealDown = value;

                if ((revealDown === null) || (revealDown === false)) {
                    RemoveEffect(gameObject);
                } else {
                    if (!gameObject._revealEffect) {
                        gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
                    }
                    gameObject._revealEffect.direction = 0;
                    gameObject._revealEffect.axis = 1;
                    gameObject._revealEffect.progress = revealDown;
                }

            },
        });

        Object.defineProperty(gameObject, 'revealWidth', {
            get: function () {
                return revealWidth;
            },
            set: function (value) {
                if (revealWidth === value) {
                    return;
                }

                revealWidth = value;

                if (gameObject._revealEffect) {
                    gameObject._revealEffect.wipeWidth = revealWidth;
                }
            },
        });

        gameObject.revealLeft = null;

        AddClearEffectCallback(gameObject, 'revealLeft');
        AddClearEffectCallback(gameObject, 'revealRight');
        AddClearEffectCallback(gameObject, 'revealUp');
        AddClearEffectCallback(gameObject, 'revealDown');

        return gameObject;
    };

    var AddSaturateProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'saturate', 1);
        return gameObject;
    };

    var AddSepiaProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'sepia');
        return gameObject;
    };

    var AddShadowProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'shadowColor')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var shadowColor,
            shadowX = 0,
            shadowY = 0,
            shadowDecay = 0.1,
            shadowPower = 1,
            shadowSamples = 6,
            shadowIntensity = 1;
        Object.defineProperty(gameObject, 'shadowColor', {
            get: function () {
                return shadowColor;
            },
            set: function (value) {
                if (shadowColor === value) {
                    return;
                }

                shadowColor = value;

                if ((shadowColor === null) || (shadowColor === false)) {
                    if (gameObject._shadow) {
                        fxFactory.remove(gameObject._shadow);
                        gameObject._shadow = undefined;
                    }
                } else {
                    if (!gameObject._shadow) {
                        gameObject._shadow = fxFactory.addShadow(shadowX, shadowY, shadowDecay, shadowPower, shadowColor, shadowSamples, shadowIntensity);
                    }

                    gameObject._shadow.color = shadowColor;
                }

            },
        });

        Object.defineProperty(gameObject, 'shadowX', {
            get: function () {
                return shadowX;
            },
            set: function (value) {
                if (shadowX === value) {
                    return;
                }

                shadowX = value;

                if (gameObject._shadow) {
                    gameObject._shadow.x = shadowX;
                }
            },
        });

        Object.defineProperty(gameObject, 'shadowY', {
            get: function () {
                return shadowY;
            },
            set: function (value) {
                if (shadowY === value) {
                    return;
                }

                shadowY = value;

                if (gameObject._shadow) {
                    gameObject._shadow.y = shadowY;
                }
            },
        });

        Object.defineProperty(gameObject, 'decay', {
            get: function () {
                return shadowDecay;
            },
            set: function (value) {
                if (shadowDecay === value) {
                    return;
                }

                shadowDecay = value;

                if (gameObject._shadow) {
                    gameObject._shadow.decay = shadowDecay;
                }
            },
        });

        Object.defineProperty(gameObject, 'shadowPower', {
            get: function () {
                return shadowPower;
            },
            set: function (value) {
                if (shadowPower === value) {
                    return;
                }

                shadowPower = value;

                if (gameObject._shadow) {
                    gameObject._shadow.power = shadowPower;
                }
            },
        });

        Object.defineProperty(gameObject, 'shadowSamples', {
            get: function () {
                return shadowSamples;
            },
            set: function (value) {
                if (shadowSamples === value) {
                    return;
                }

                shadowSamples = value;

                if (gameObject._shadow) {
                    gameObject._shadow.samples = shadowSamples;
                }
            },
        });

        Object.defineProperty(gameObject, 'shadowIntensity', {
            get: function () {
                return shadowIntensity;
            },
            set: function (value) {
                if (shadowIntensity === value) {
                    return;
                }

                shadowIntensity = value;

                if (gameObject._shadow) {
                    gameObject._shadow.intensity = shadowIntensity;
                }
            },
        });

        gameObject.shadowColor = null;

        AddClearEffectCallback(gameObject, 'shadowColor');

        return gameObject;
    };

    var AddShiftToBGRProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'shiftToBGR');
        return gameObject;
    };

    var AddShineProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'shineSpeed')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var shineSpeed,
            shineLineWidth = 0.5,
            shineGradient = 3;
        Object.defineProperty(gameObject, 'shineSpeed', {
            get: function () {
                return shineSpeed;
            },
            set: function (value) {
                if (shineSpeed === value) {
                    return;
                }

                shineSpeed = value;

                if ((shineSpeed === null) || (shineSpeed === false)) {
                    if (gameObject._shine) {
                        fxFactory.remove(gameObject._shine);
                        gameObject._shine = undefined;
                    }
                } else {
                    if (!gameObject._shine) {
                        gameObject._shine = fxFactory.addShine(shineSpeed, shineLineWidth, shineGradient);
                    }

                    gameObject._shine.speed = shineSpeed;
                }

            },
        });

        Object.defineProperty(gameObject, 'shineLineWidth', {
            get: function () {
                return shineLineWidth;
            },
            set: function (value) {
                if (shineLineWidth === value) {
                    return;
                }

                shineLineWidth = value;

                if (gameObject._shine) {
                    gameObject._shine.lineWidth = shineLineWidth;
                }
            },
        });

        Object.defineProperty(gameObject, 'shineGradient', {
            get: function () {
                return shineGradient;
            },
            set: function (value) {
                if (shineGradient === value) {
                    return;
                }

                shineGradient = value;

                if (gameObject._shine) {
                    gameObject._shine.gradient = shineGradient;
                }
            },
        });

        gameObject.shineSpeed = null;

        AddClearEffectCallback(gameObject, 'shineSpeed');

        return gameObject;
    };

    var AddTechnicolorProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'technicolor');
        return gameObject;
    };

    var AddTiltShiftProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'tiltShiftRadius')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var tiltShiftRadius,
            tiltShiftAmount = 1,
            tiltShiftContrast = 0.2,
            tiltShiftBlurX = 1,
            tiltShiftBlurY = 1,
            tiltShiftStrength = 1;
        Object.defineProperty(gameObject, 'tiltShiftRadius', {
            get: function () {
                return tiltShiftRadius;
            },
            set: function (value) {
                if (tiltShiftRadius === value) {
                    return;
                }

                tiltShiftRadius = value;

                if ((tiltShiftRadius === null) || (tiltShiftRadius === false)) {
                    if (gameObject._tiltShift) {
                        fxFactory.remove(gameObject._tiltShift);
                        gameObject._tiltShift = undefined;
                    }
                } else {
                    if (!gameObject._tiltShift) {
                        gameObject._tiltShift = fxFactory.addTiltShift(tiltShiftRadius, tiltShiftAmount, tiltShiftContrast, tiltShiftBlurX, tiltShiftBlurY, tiltShiftStrength);
                    }

                    gameObject._tiltShift.radius = tiltShiftRadius;
                }

            },
        });

        Object.defineProperty(gameObject, 'tiltShiftAmount', {
            get: function () {
                return tiltShiftAmount;
            },
            set: function (value) {
                if (tiltShiftAmount === value) {
                    return;
                }

                tiltShiftAmount = value;

                if (gameObject._tiltShift) {
                    gameObject._tiltShift.amount = tiltShiftAmount;
                }
            },
        });

        Object.defineProperty(gameObject, 'tiltShiftContrast', {
            get: function () {
                return tiltShiftContrast;
            },
            set: function (value) {
                if (tiltShiftContrast === value) {
                    return;
                }

                tiltShiftContrast = value;

                if (gameObject._tiltShift) {
                    gameObject._tiltShift.contrast = tiltShiftContrast;
                }
            },
        });

        Object.defineProperty(gameObject, 'tiltShiftBlurX', {
            get: function () {
                return tiltShiftBlurX;
            },
            set: function (value) {
                if (tiltShiftBlurX === value) {
                    return;
                }

                tiltShiftBlurX = value;

                if (gameObject._tiltShift) {
                    gameObject._tiltShift.blurX = tiltShiftBlurX;
                }
            },
        });

        Object.defineProperty(gameObject, 'tiltShiftBlurY', {
            get: function () {
                return tiltShiftBlurY;
            },
            set: function (value) {
                if (tiltShiftBlurY === value) {
                    return;
                }

                tiltShiftBlurY = value;

                if (gameObject._tiltShift) {
                    gameObject._tiltShift.blurY = tiltShiftBlurY;
                }
            },
        });

        Object.defineProperty(gameObject, 'tiltShiftStrength', {
            get: function () {
                return tiltShiftStrength;
            },
            set: function (value) {
                if (tiltShiftStrength === value) {
                    return;
                }

                tiltShiftStrength = value;

                if (gameObject._tiltShift) {
                    gameObject._tiltShift.strength = tiltShiftStrength;
                }
            },
        });

        gameObject.tiltShiftRadius = null;

        AddClearEffectCallback(gameObject, 'tiltShiftRadius');

        return gameObject;
    };

    var AddVignetteProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'vignetteRadius')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var vignetteRadius,
            vignetteX = 0.5,
            vignetteY = 0.5,
            vignetteStrength = 0.5;
        Object.defineProperty(gameObject, 'vignetteRadius', {
            get: function () {
                return vignetteRadius;
            },
            set: function (value) {
                if (vignetteRadius === value) {
                    return;
                }

                vignetteRadius = value;

                if ((vignetteRadius === null) || (vignetteRadius === false)) {
                    if (gameObject._vignette) {
                        fxFactory.remove(gameObject._vignette);
                        gameObject._vignette = undefined;
                    }
                } else {
                    if (!gameObject._vignette) {
                        gameObject._vignette = fxFactory.addVignette(vignetteX, vignetteY, vignetteRadius, vignetteStrength);
                    }

                    gameObject._vignette.radius = vignetteRadius;
                }

            },
        });

        Object.defineProperty(gameObject, 'vignetteX', {
            get: function () {
                return vignetteX;
            },
            set: function (value) {
                if (vignetteX === value) {
                    return;
                }

                vignetteX = value;

                if (gameObject._vignette) {
                    gameObject._vignette.x = vignetteX;
                }
            },
        });

        Object.defineProperty(gameObject, 'vignetteY', {
            get: function () {
                return vignetteY;
            },
            set: function (value) {
                if (vignetteY === value) {
                    return;
                }

                vignetteY = value;

                if (gameObject._vignette) {
                    gameObject._vignette.y = vignetteY;
                }
            },
        });

        Object.defineProperty(gameObject, 'vignetteStrength', {
            get: function () {
                return vignetteStrength;
            },
            set: function (value) {
                if (vignetteStrength === value) {
                    return;
                }

                vignetteStrength = value;

                if (gameObject._vignette) {
                    gameObject._vignette.strength = vignetteStrength;
                }
            },
        });

        gameObject.vignetteRadius = null;

        AddClearEffectCallback(gameObject, 'vignetteRadius');

        return gameObject;
    };

    var AddVintagePinholeProperties = function (gameObject) {
        AddColorMatrixEffectPropertiesBase(gameObject, 'vintagePinhole');
        return gameObject;
    };

    var AddWipeProperties = function (gameObject) {
        // Don't attach properties again
        if (HasProperty(gameObject, 'wipeLeft')) {
            return gameObject;
        }

        var fxFactory = GetFXFactory(gameObject);
        if (!fxFactory) {
            return gameObject;
        }

        var wipeLeft,
            wipeRight,
            wipeUp,
            wipeDown,
            wipeWidth = 0.1;

        var ClearWipeFlags = function () {
            wipeLeft = null;
            wipeRight = null;
            wipeUp = null;
            wipeDown = null;
        };

        var RemoveEffect = function (gameObject) {
            if (gameObject._wipeEffect) {
                fxFactory.remove(gameObject._wipeEffect);
                gameObject._wipeEffect = undefined;
            }
        };

        Object.defineProperty(gameObject, 'wipeLeft', {
            get: function () {
                return wipeLeft;
            },
            set: function (value) {
                if (wipeLeft === value) {
                    return;
                }

                ClearWipeFlags();

                wipeLeft = value;

                if ((wipeLeft === null) || (wipeLeft === false)) {
                    RemoveEffect(gameObject);
                } else {
                    if (!gameObject._wipeEffect) {
                        gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
                    }

                    gameObject._wipeEffect.direction = 1;
                    gameObject._wipeEffect.axis = 0;
                    gameObject._wipeEffect.progress = wipeLeft;
                }

            },
        });

        Object.defineProperty(gameObject, 'wipeRight', {
            get: function () {
                return wipeRight;
            },
            set: function (value) {
                if (wipeRight === value) {
                    return;
                }

                ClearWipeFlags();

                wipeRight = value;

                if ((wipeRight === null) || (wipeRight === false)) {
                    RemoveEffect(gameObject);
                } else {
                    if (!gameObject._wipeEffect) {
                        gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
                    }
                    gameObject._wipeEffect.direction = 0;
                    gameObject._wipeEffect.axis = 0;
                    gameObject._wipeEffect.progress = wipeRight;
                }

            },
        });

        Object.defineProperty(gameObject, 'wipeUp', {
            get: function () {
                return wipeUp;
            },
            set: function (value) {
                if (wipeUp === value) {
                    return;
                }

                ClearWipeFlags();

                wipeUp = value;

                if ((wipeUp === null) || (wipeUp === false)) {
                    RemoveEffect(gameObject);
                } else {
                    if (!gameObject._wipeEffect) {
                        gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
                    }
                    gameObject._wipeEffect.direction = 1;
                    gameObject._wipeEffect.axis = 1;
                    gameObject._wipeEffect.progress = wipeUp;
                }

            },
        });

        Object.defineProperty(gameObject, 'wipeDown', {
            get: function () {
                return wipeDown;
            },
            set: function (value) {
                if (wipeDown === value) {
                    return;
                }

                ClearWipeFlags();

                wipeDown = value;

                if ((wipeDown === null) || (wipeDown === false)) {
                    RemoveEffect(gameObject);
                } else {
                    if (!gameObject._wipeEffect) {
                        gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
                    }
                    gameObject._wipeEffect.direction = 0;
                    gameObject._wipeEffect.axis = 1;
                    gameObject._wipeEffect.progress = wipeDown;
                }

            },
        });

        Object.defineProperty(gameObject, 'wipeWidth', {
            get: function () {
                return wipeWidth;
            },
            set: function (value) {
                if (wipeWidth === value) {
                    return;
                }

                wipeWidth = value;

                if (gameObject._wipeEffect) {
                    gameObject._wipeEffect.wipeWidth = wipeWidth;
                }
            },
        });

        gameObject.wipeLeft = null;

        AddClearEffectCallback(gameObject, 'wipeLeft');
        AddClearEffectCallback(gameObject, 'wipeRight');
        AddClearEffectCallback(gameObject, 'wipeUp');
        AddClearEffectCallback(gameObject, 'wipeDown');

        return gameObject;
    };

    const EffectMap = {
        barrel: AddBarrelProperties,
        blackWhite: AddBlackWhiteProperties,
        bloom: AddBloomProperties,
        blur: AddBlurProperties,
        bokeh: AddBokehProperties,
        brightness: AddBrightnessProperties,
        brown: AddBrownProperties,
        circle: AddCircleProperties,
        contrast: AddContrastProperties,
        desaturate: AddDesaturateProperties,
        desaturateLuminance: AddDesaturateLuminanceProperties,
        displacement: AddDisplacementProperties,
        glow: AddGlowProperties,
        gradient: AddGradientProperties,
        grayscale: AddGrayscaleProperties,
        hue: AddHueProperties,
        kodachrome: AddKodachromeProperties,
        lsd: AddLSDProperties,
        negative: AddNegativeProperties,
        pixelate: AddPixelateProperties,
        polaroid: AddPolaroidProperties,
        reveal: AddRevealProperties,
        saturate: AddSaturateProperties,
        sepia: AddSepiaProperties,
        shadow: AddShadowProperties,
        shiftToBGR: AddShiftToBGRProperties,
        shine: AddShineProperties,
        technicolor: AddTechnicolorProperties,
        tiltShift: AddTiltShiftProperties,
        vignette: AddVignetteProperties,
        vintagePinhole: AddVintagePinholeProperties,
        wipe: AddWipeProperties
    };

    var AddEffectProperties = function (gameObject, config) {
        if (config === undefined) {
            config = true;
        } else if (typeof (config) === 'string') {
            config = { config: true };
        } else if (Array.isArray(config)) {
            var nameList = config;
            var config = {};
            for (var i = 0, cnt = nameList.length; i < cnt; i++) {
                config[nameList[i]] = true;
            }
        }

        if (config === true) {
            // Enable all effect properties
            for (var name in EffectMap) {
                EffectMap[name](gameObject);
            }
        } else {
            for (var name in config) {
                if (config[name] && EffectMap[name]) {
                    EffectMap[name](gameObject);
                }
            }
        }

        return gameObject;
    };

    const RemoveItem$b = Phaser.Utils.Array.Remove;

    var AddMethods$1 = {
        addGO(name, gameObject) {
            this.remove(name, true);

            if (this.useTintFadeEffect(gameObject)) {
                AddTintRGBProperties(gameObject);
            }

            if (this.viewportCoordinateEnable) {
                AddViewportCoordinateProperties(gameObject, this.viewport);
            }

            if (this.effectPropertiesConfig) {
                AddEffectProperties(gameObject, this.effectPropertiesConfig);
            }

            gameObject
                .setName(name)
                .once('destroy', function () {
                    RemoveItem$b(this.removedGOs, gameObject);
                    if (this.isEmpty) {
                        this.emit('empty');
                    }
                }, this);

            var bob = new this.BobClass(this, gameObject, name);
            this.bobs[name] = bob;

            return this;
        },

        add(name, ...args) {
            var callback = this.createGameObjectCallback;
            var scope = this.createGameObjectScope;
            var gameObject = callback.call(scope, this.scene, ...args);
            this.addGO(name, gameObject);

            if (this.gameObjectDepth != null) { // Not undefined, null
                gameObject.setDepth(this.gameObjectDepth);
            }

            var bob = this.get(name);
            this.fadeBob(bob, 0, 1);

            return this;
        },
    };

    var RemoveMethods$1 = {
        remove(name, ignoreFade) {
            var bobs = this.get(name);
            if (!bobs) {
                return this;
            } else if (!Array.isArray(bobs)) {
                bobs = [bobs];
            }

            var self = this;
            bobs.forEach(function (bob) {
                delete self.bobs[bob.name];

                var gameObject = bob.gameObject;
                self.removedGOs.push(gameObject);
                gameObject.setName();

                if (!ignoreFade) {
                    self.fadeBob(
                        bob,                  // bob
                        undefined,            // fromValue
                        0,                    // toValue
                        function () {         // onComplete
                            bob.destroy();
                        }
                    );
                } else {
                    bob.destroy();
                }
            });

            return this;
        },

        removeAll() {
            var bobs = this.bobs;
            for (var name in bobs) {
                this.remove(name);
            }
            return this;
        },

        clear(destroyChild) {
            if (destroyChild === undefined) {
                destroyChild = true;
            }
            var bobs = this.bobs;
            for (var name in bobs) {
                if (destroyChild) {
                    bobs[name].destroy();
                }
                delete bobs[name];
            }
            this.removedGOs.length = 0;
            return this;
        }
    };

    var PropertyMethods = {
        hasProperty(name, property) {
            var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
            if (!bob) {
                return false;
            }

            return bob.hasProperty(property);
        },

        getProperty(name, property) {
            var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
            if (!bob) {
                return undefined;
            }

            return bob.getProperty(property);
        },

        isNumberProperty(name, property) {
            var value = this.getProperty(name, property);
            return typeof (value) === 'number';
        },

        setProperty(name, property, value) {
            var bobs = this.get(name);
            if (!bobs) {
                return this;
            } else if (!Array.isArray(bobs)) {
                bobs = [bobs];
            }

            if (this.symbols &&
                (typeof (value) === 'string') &&
                this.isNumberProperty(name, property)
            ) {
                if (value in this.symbols) {
                    value = this.symbols[value];
                } else {
                    console.warn(`Can't find symbol ${value}`);
                }
            }

            bobs.forEach(function (bob) {
                bob.setProperty(property, value);
            });

            return this;
        },

        easeProperty(name, config) {
            var bobs = this.get(name);
            if (!bobs) {
                return this;
            } else if (!Array.isArray(bobs)) {
                bobs = [bobs];
            }

            var value = config.value;
            var property = config.property;

            if (this.symbols &&
                (typeof (value) === 'string') &&
                this.isNumberProperty(name, property) &&
                (value in this.symbols)
            ) {
                config.value = this.symbols[value];
            }

            bobs.forEach(function (bob) {
                bob.easeProperty(config);
            });

            return this;
        },

        hasTweenTask(name, property) {
            var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
            if (!bob) {
                return false;
            }

            return bob.tweens.hasOwnProperty(property);
        },

        getTweenTask(name, property) {
            var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
            if (!bob) {
                return null;
            }

            return bob.tweens[property] || null;
        }
    };

    var CallMethods = {
        hasMethod(name, methodName) {
            var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
            if (!bob) {
                return false;
            }

            return bob.hasMethod(methodName);
        },


        call(name, methodName, ...parameters) {
            var bobs = this.get(name);
            if (!bobs) {
                return this;
            } else if (!Array.isArray(bobs)) {
                bobs = [bobs];
            }

            bobs.forEach(function (bob) {
                bob.call(methodName, ...parameters);
            });

            return this;
        },
    };

    var DataMethods = {
        hasData(name, dataKey) {
            var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
            if (!bob) {
                return false;
            }

            return bob.hasData(dataKey);
        },

        getData(name, dataKey) {
            if (!this.has(name)) {
                return undefined;
            }
            return this.get(name).getData(dataKey);
        },

        setData(name, dataKey, value) {
            var bobs = this.get(name);
            if (!bobs) {
                return this;
            } else if (!Array.isArray(bobs)) {
                bobs = [bobs];
            }

            bobs.forEach(function (bob) {
                bob.setData(dataKey, value);
            });

            return this;
        },
    };

    const FadeTint = 0;
    const FadeAlpha = 1;
    const FadeRevealUp = 2;
    const FadeRevealDown = 3;
    const FadeRevealLeft = 4;
    const FadeRevealRight = 5;

    const FadeMode = {
        tint: FadeTint,
        alpha: FadeAlpha,
        revealUp: FadeRevealUp,
        revealDown: FadeRevealDown,
        revealLeft: FadeRevealLeft,
        revealRight: FadeRevealRight,
    };

    var FadeMethods$1 = {
        setGOFadeMode(fadeMode) {
            if (typeof (fadeMode) === 'string') {
                fadeMode = FadeMode[fadeMode];
            }

            this.fadeMode = fadeMode;
            return this;
        },

        setGOFadeTime(time) {
            this.fadeTime = time;
            return this;
        },

        useTintFadeEffect(gameObject) {
            return ((this.fadeMode === undefined) || (this.fadeMode === FadeTint)) &&
                (this.fadeTime > 0) && (gameObject.setTint !== undefined);
        },

        useAlphaFadeEffect(gameObject) {
            return ((this.fadeMode === undefined) || (this.fadeMode === FadeAlpha)) &&
                (this.fadeTime > 0) && (gameObject.setAlpha !== undefined);
        },

        useRevealEffect(gameObject) {
            return ((this.fadeMode >= FadeRevealUp) && (this.fadeMode <= FadeRevealRight)) &&
                (this.fadeTime > 0) && (gameObject.preFX || gameObject.postFX);
        },

        fadeBob(bob, fromValue, toValue, onComplete) {
            var gameObject = bob.gameObject;
            if (this.useTintFadeEffect(gameObject)) {
                if (fromValue !== undefined) {
                    bob.setProperty('tintGray', 255 * fromValue);
                }
                bob.easeProperty({
                    property: 'tintGray',
                    value: Math.floor(255 * toValue),
                    duration: this.fadeTime,
                    delay: 0,
                    ease: 'Linear',
                    repeat: 0,
                    yoyo: false,
                    from: false,
                    complete: onComplete
                });

            } else if (this.useAlphaFadeEffect(gameObject)) {
                if (fromValue !== undefined) {
                    bob.setProperty('alpha', fromValue);
                }
                bob.easeProperty({
                    property: 'alpha',
                    value: toValue,
                    duration: this.fadeTime,
                    delay: 0,
                    ease: 'Linear',
                    repeat: 0,
                    yoyo: false,
                    from: false,
                    complete: onComplete
                });

            } else if (this.useRevealEffect(gameObject)) {
                AddEffectProperties(gameObject, 'reveal');
                var propertyName;
                switch (this.fadeMode) {
                    case FadeRevealUp: propertyName = 'revealUp'; break;
                    case FadeRevealDown: propertyName = 'revealDown'; break;
                    case FadeRevealLeft: propertyName = 'revealLeft'; break;
                    case FadeRevealRight: propertyName = 'revealRight'; break;
                }

                if (fromValue === undefined) {
                    fromValue = 0;
                }
                gameObject[propertyName] = fromValue;
                bob.easeProperty({
                    property: propertyName,
                    value: toValue,
                    duration: this.fadeTime,
                    delay: 0,
                    ease: 'Linear',
                    repeat: 0,
                    yoyo: false,
                    from: false,
                    complete: onComplete
                });

                bob.getTweenTask(propertyName).once('complete', function () {
                    gameObject[propertyName] = null;
                });

            } else {
                if (onComplete) {
                    onComplete(gameObject);
                }

            }

            return this;
        }

    };

    var GetDisplayWidth = function (gameObject) {
        if (gameObject.displayWidth !== undefined) {
            return gameObject.displayWidth;
        } else {
            return gameObject.width;
        }
    };

    var GetDisplayHeight = function (gameObject) {
        if (gameObject.displayHeight !== undefined) {
            return gameObject.displayHeight;
        } else {
            return gameObject.height;
        }
    };

    const Rectangle$4 = Phaser.Geom.Rectangle;
    const Vector2 = Phaser.Math.Vector2;
    const RotateAround$6 = Phaser.Math.RotateAround;
    const P3Container$2 = Phaser.GameObjects.Container;

    var GetBounds = function (gameObject, output) {
        if (output === undefined) {
            output = new Rectangle$4();
        } else if (output === true) {
            if (GlobRect$2 === undefined) {
                GlobRect$2 = new Rectangle$4();
            }
            output = GlobRect$2;
        }

        if (gameObject.getBounds && !(gameObject instanceof P3Container$2)) {
            return gameObject.getBounds(output);
        }

        //  We can use the output object to temporarily store the x/y coords in:

        var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;

        // Instead of doing a check if parent container is
        // defined per corner we only do it once.
        if (gameObject.parentContainer) {
            var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();

            GetTopLeft(gameObject, output);
            parentMatrix.transformPoint(output.x, output.y, output);

            TLx = output.x;
            TLy = output.y;

            GetTopRight(gameObject, output);
            parentMatrix.transformPoint(output.x, output.y, output);

            TRx = output.x;
            TRy = output.y;

            GetBottomLeft(gameObject, output);        parentMatrix.transformPoint(output.x, output.y, output);

            BLx = output.x;
            BLy = output.y;

            GetBottomRight(gameObject, output);
            parentMatrix.transformPoint(output.x, output.y, output);

            BRx = output.x;
            BRy = output.y;
        }
        else {
            GetTopLeft(gameObject, output);

            TLx = output.x;
            TLy = output.y;

            GetTopRight(gameObject, output);
            TRx = output.x;
            TRy = output.y;

            GetBottomLeft(gameObject, output);
            BLx = output.x;
            BLy = output.y;

            GetBottomRight(gameObject, output);

            BRx = output.x;
            BRy = output.y;
        }

        output.x = Math.min(TLx, TRx, BLx, BRx);
        output.y = Math.min(TLy, TRy, BLy, BRy);
        output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
        output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;

        return output;
    };

    var GlobRect$2 = undefined;

    var GetTopLeft = function (gameObject, output, includeParent) {
        if (output === undefined) {
            output = new Vector2();
        } else if (output === true) {
            if (GlobVector === undefined) {
                GlobVector = new Vector2();
            }
            output = GlobVector;
        }

        if (gameObject.getTopLeft) {
            return gameObject.getTopLeft(output);
        }

        output.x = gameObject.x - (GetDisplayWidth(gameObject) * gameObject.originX);
        output.y = gameObject.y - (GetDisplayHeight(gameObject) * gameObject.originY);

        return PrepareBoundsOutput(gameObject, output, includeParent);
    };

    var GetTopRight = function (gameObject, output, includeParent) {
        if (output === undefined) {
            output = new Vector2();
        } else if (output === true) {
            if (GlobVector === undefined) {
                GlobVector = new Vector2();
            }
            output = GlobVector;
        }

        if (gameObject.getTopRight) {
            return gameObject.getTopRight(output);
        }

        output.x = (gameObject.x - (GetDisplayWidth(gameObject) * gameObject.originX)) + GetDisplayWidth(gameObject);
        output.y = gameObject.y - (GetDisplayHeight(gameObject) * gameObject.originY);

        return PrepareBoundsOutput(gameObject, output, includeParent);
    };

    var GetBottomLeft = function (gameObject, output, includeParent) {
        if (output === undefined) {
            output = new Vector2();
        } else if (output === true) {
            if (GlobVector === undefined) {
                GlobVector = new Vector2();
            }
            output = GlobVector;
        }

        if (gameObject.getBottomLeft) {
            return gameObject.getBottomLeft(output);
        }

        output.x = gameObject.x - (GetDisplayWidth(gameObject) * gameObject.originX);
        output.y = (gameObject.y - (GetDisplayHeight(gameObject) * gameObject.originY)) + GetDisplayHeight(gameObject);

        return PrepareBoundsOutput(gameObject, output, includeParent);
    };

    var GetBottomRight = function (gameObject, output, includeParent) {
        if (output === undefined) {
            output = new Vector2();
        } else if (output === true) {
            if (GlobVector === undefined) {
                GlobVector = new Vector2();
            }
            output = GlobVector;
        }

        if (gameObject.getBottomRight) {
            return gameObject.getBottomRight(output);
        }

        output.x = (gameObject.x - (GetDisplayWidth(gameObject) * gameObject.originX)) + GetDisplayWidth(gameObject);
        output.y = (gameObject.y - (GetDisplayHeight(gameObject) * gameObject.originY)) + GetDisplayHeight(gameObject);

        return PrepareBoundsOutput(gameObject, output, includeParent);
    };

    var GetCenter = function (gameObject, output, includeParent) {
        if (output === undefined) {
            output = new Vector2();
        } else if (output === true) {
            if (GlobVector === undefined) {
                GlobVector = new Vector2();
            }
            output = GlobVector;
        }

        var displayWidth = GetDisplayWidth(gameObject);
        var displayHeight = GetDisplayHeight(gameObject);
        output.x = gameObject.x + (displayWidth * (0.5 - gameObject.originX));
        output.y = gameObject.y + (displayHeight * (0.5 - gameObject.originY));

        return PrepareBoundsOutput(gameObject, output, includeParent);
    };

    var GlobVector = undefined;

    var PrepareBoundsOutput = function (gameObject, output, includeParent) {
        if (includeParent === undefined) { includeParent = false; }

        if (gameObject.rotation !== 0) {
            RotateAround$6(output, gameObject.x, gameObject.y, gameObject.rotation);
        }

        if (includeParent && gameObject.parentContainer) {
            var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();

            parentMatrix.transformPoint(output.x, output.y, output);
        }

        return output;
    };

    const GetValue$3y = Phaser.Utils.Objects.GetValue;

    var DrawBounds$2 = function (gameObjects, graphics, config) {
        var strokeColor, lineWidth, fillColor, fillAlpha, padding;
        if (typeof (config) === 'number') {
            strokeColor = config;
        } else {
            strokeColor = GetValue$3y(config, 'color');
            lineWidth = GetValue$3y(config, 'lineWidth');
            fillColor = GetValue$3y(config, 'fillColor');
            fillAlpha = GetValue$3y(config, 'fillAlpha', 1);
            padding = GetValue$3y(config, 'padding', 0);
        }

        if (Array.isArray(gameObjects)) {
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Draw(gameObjects[i], graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
            }
        } else {
            Draw(gameObjects, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
        }
    };

    var Draw = function (gameObject, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding) {
        var canDrawBound = gameObject.getBounds ||
            ((gameObject.width !== undefined) && (gameObject.height !== undefined));
        if (!canDrawBound) {
            return;
        }

        if (strokeColor === undefined) { strokeColor = 0xffffff; }
        if (lineWidth === undefined) { lineWidth = 1; }
        if (fillColor === undefined) { fillColor = null; }    if (fillAlpha === undefined) { fillAlpha = 1; }    if (padding === undefined) { padding = 0; }

        var p0 = GetTopLeft(gameObject, Points[0]);
        p0.x -= padding;
        p0.y -= padding;

        var p1 = GetTopRight(gameObject, Points[1]);
        p1.x += padding;
        p1.y -= padding;

        var p2 = GetBottomRight(gameObject, Points[2]);
        p2.x += padding;
        p2.y += padding;

        var p3 = GetBottomLeft(gameObject, Points[3]);
        p3.x -= padding;
        p3.y += padding;

        if (fillColor !== null) {
            graphics
                .fillStyle(fillColor, fillAlpha)
                .fillPoints(Points, true, true);
        }
        if (strokeColor !== null) {
            graphics
                .lineStyle(lineWidth, strokeColor)
                .strokePoints(Points, true, true);
        }

    };

    var Points = [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }];

    var DrawGameObjectsBounds = function (graphics, config) {
        this.forEachGO(function (gameObject) {
            if (gameObject.drawBounds) {
                gameObject.drawBounds(graphics, config);
            } else {
                DrawBounds$2(gameObject, graphics, config);
            }
        });
        return this;
    };

    var GetCameraByName = function (scene, name) {
        var cameraManager = scene.cameras;
        var camera;
        if (name === undefined) {
            camera = cameraManager.main;
        } else {
            var cameraNameType = typeof (name);
            switch (cameraNameType) {
                case 'string':
                    camera = cameraManager.getCamera(name);
                    break;

                case 'number':
                    camera = cameraManager.cameras[name];
                    break;

                default:
                    camera = name;
                    break;
            }
        }

        return camera;
    };

    var CameraMethods$1 = {
        setCamera(goName, cameraName) {
            var bob = this.get(goName);
            if (!bob) {
                return this;
            }

            var camera = GetCameraByName(this.scene, cameraName);
            if (!camera) {
                return this;
            }

            bob.gameObject.cameraFilter = 0xffffffff ^ camera.id;
            bob.camera = camera;

            return this;
        },

        getCamera(goName) {
            var bob = this.get(goName);
            if (!bob) {
                return null;
            }

            return bob.camera;
        }
    };

    var Methods$i = {
        drawGameObjectsBounds: DrawGameObjectsBounds,
    };

    Object.assign(
        Methods$i,
        GetMethods,
        AddMethods$1,
        RemoveMethods$1,
        PropertyMethods,
        CallMethods,
        DataMethods,
        FadeMethods$1,
        CameraMethods$1,
    );

    const CameraClass = Phaser.Cameras.Scene2D.BaseCamera;

    var IsCameraObject = function (object) {
        return (object instanceof CameraClass);
    };

    const Rectangle$3 = Phaser.Geom.Rectangle;

    var GetViewport = function (scene, camera, out) {
        if (!IsCameraObject(camera)) {
            out = camera;
            camera = undefined;
        }

        if (out === undefined) {
            out = new Rectangle$3();
        } else if (out === true) {
            out = globRect;
        }

        if (camera) {
            return scene.scale.getViewPort(camera, out);
        } else {
            return scene.scale.getViewPort(out);
        }
    };

    var globRect = new Rectangle$3();

    const GetValue$3x = Phaser.Utils.Objects.GetValue;

    class GOManager {
        constructor(scene, config) {
            this.scene = scene;

            this.BobClass = GetValue$3x(config, 'BobClass', BobBase);
            this.setCreateGameObjectCallback(
                GetValue$3x(config, 'createGameObject'),
                GetValue$3x(config, 'createGameObjectScope')
            );
            this.setEventEmitter(GetValue$3x(config, 'eventEmitter', undefined));

            this.setGameObjectDepth(GetValue$3x(config, 'depth', undefined));

            var fadeConfig = GetValue$3x(config, 'fade', 500);
            if (typeof (fadeConfig) === 'number') {
                this.setGOFadeMode();
                this.setGOFadeTime(fadeConfig);
            } else {
                this.setGOFadeMode(GetValue$3x(fadeConfig, 'mode'));
                this.setGOFadeTime(GetValue$3x(fadeConfig, 'time', 500));
            }

            var viewportCoordinateConfig = GetValue$3x(config, 'viewportCoordinate', false);
            if (viewportCoordinateConfig !== false) {
                this.setViewportCoordinateEnable(GetValue$3x(config, 'enable', true));
                this.setViewport(GetValue$3x(viewportCoordinateConfig, 'viewport'));
            } else {
                this.setViewportCoordinateEnable(false);
            }

            var effectPropertiesConfig = GetValue$3x(config, 'effectProperties', false);
            this.setEffectPropertiesConfig(effectPropertiesConfig);

            this.setSymbols(GetValue$3x(config, 'symbols'));

            this.bobs = {};
            this.removedGOs = [];
            this._timeScale = 1;

            this.name = GetValue$3x(config, 'name');
        }

        destroy(fromScene) {
            this.clear(!fromScene);
            this.createGameObjectCallback = undefined;
            this.viewport = undefined;
            this.scene = undefined;
        }

        set timeScale(timeScale) {
            if (this._timeScale === timeScale) {
                return;
            }

            this._timeScale = timeScale;

            var bobs = this.bobs;
            for (var name in bobs) {
                bobs[name].setTimeScale(timeScale);
            }
        }

        get timeScale() {
            return this._timeScale;
        }

        setTimeScale(timeScale) {
            this.timeScale = timeScale;
            return this;
        }

        setCreateGameObjectCallback(callback, scope) {
            this.createGameObjectCallback = callback;
            this.createGameObjectScope = scope;
            return this;
        }

        setGameObjectDepth(depth) {
            this.gameObjectDepth = depth;
            return this;
        }

        setViewportCoordinateEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            this.viewportCoordinateEnable = enable;
            return this;
        }

        setEffectPropertiesConfig(config) {
            if (config === undefined) {
                config = true;
            }

            this.effectPropertiesConfig = config;
            return this;
        }

        setViewport(viewport) {
            if (viewport === undefined) {
                viewport = GetViewport(this.scene, this.scene.cameras.main);
            }

            this.viewport = viewport;
            return this;
        }

        setSymbols(symbols) {
            this.symbols = symbols;
            return this;
        }

        get isEmpty() {
            return IsEmpty(this.bobs) && (this.removedGOs.length === 0);
        }

    }

    Object.assign(
        GOManager.prototype,
        EventEmitterMethods$1,
        Methods$i
    );

    const GameObjectClass = Phaser.GameObjects.GameObject;
    const LayerClass$1 = Phaser.GameObjects.Layer;

    var IsGameObject = function (object) {
        return (object instanceof GameObjectClass) || (object instanceof LayerClass$1);
    };

    const LayerClass = Phaser.GameObjects.Layer;

    var IsLayerGameObject = function (gameObject) {
        return (gameObject instanceof LayerClass);
    };

    var GetLayer = function (gameObject) {
        var layer = gameObject.displayList;
        if (!IsLayerGameObject(layer)) {
            return null;
        }

        return layer;

    };

    var SortGameObjectsByDepth = function (gameObjects, descending) {
        if (gameObjects.length <= 1) {
            return gameObjects;
        }

        if (descending === undefined) {
            descending = false;
        }

        var itemList;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            var gameObject = gameObjects[i];
            if (gameObject.displayList) {
                // Inside a scene or a layer
                itemList = gameObject.displayList; // displayList
            } else if (gameObject.parentContainer) {
                // Inside a container
                itemList = gameObject.parentContainer.list; // array
            }

            if (itemList) {
                break;
            }
        }

        if (!itemList) {
            itemList = gameObject.scene.sys.displayList;  // displayList
            // ??
        }

        if (itemList.depthSort) {
            // Is a displayList object
            itemList.depthSort();
            itemList = itemList.list;
            // itemList is an array now
        }

        // itemList is an array
        if (descending) {
            gameObjects.sort(function (childA, childB) {
                return itemList.indexOf(childB) - itemList.indexOf(childA);
            });

        } else {
            gameObjects.sort(function (childA, childB) {
                return itemList.indexOf(childA) - itemList.indexOf(childB);
            });

        }

        return gameObjects;
    };

    var LayerMethods = {
        getLayer(name) {
            return this.getGO(name);
        },

        getLayers(out) {
            if (out === undefined) {
                out = [];
            }
            this.forEachGO(function (gameObject) {
                out.push(gameObject);
            });
            SortGameObjectsByDepth(out, false);
            return out;
        },

        addToLayer(name, gameObjects) {
            var layer = this.getGO(name);
            if (!layer) {
                console.warn(`[LayerManager] Can't get layer "${name}"`);
                return;
            }

            if (!Array.isArray(gameObjects)) {
                gameObjects = [gameObjects];
            }

            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                var gameObject = gameObjects[i];
                if (gameObject.isRexContainerLite) {
                    gameObject.addToLayer(layer);
                } else {
                    layer.add(gameObject);
                }
            }

            if (layer.scrollFactorX !== undefined) {
                gameObject.setScrollFactor(layer.scrollFactorX, layer.scrollFactorY);
            }

            return this;
        },

        addToBottomLayer(gameObjects) {
            var bottomLayer = this.getLayers()[0];
            this.addToLayer(bottomLayer.goName, gameObjects);
            return this;
        },

        addToTopLayer(gameObjects) {
            var layers = this.getLayers();
            var topLayer = layers[layers.length - 1];
            this.addToLayer(topLayer.goName, gameObjects);
            return this;
        },

        removeFromLayer(name, gameObject, addToScene) {
            var layer = this.getGO(name);
            if (!layer) {
                console.warn(`[LayerManager] Can't get layer "${name}"`);
                return;
            }

            if (addToScene === undefined) {
                addToScene = true;
            }

            if (gameObject.isRexContainerLite) {
                gameObject.removeFromLayer(layer, addToScene);
            } else {
                layer.remove(gameObject);
                if (addToScene) {
                    gameObject.addToDisplayList();
                }
            }

            return this;
        },

        clearLayer(name, destroyChildren) {
            if (destroyChildren === undefined) {
                destroyChildren = true;
            }

            var layer = this.getGO(name);
            if (!layer) {
                console.warn(`Can't get layer "${name}"`);
                return;
            }

            if (destroyChildren) {
                var children = layer.getAll();
                for (var i = 0, cnt = children.length; i < cnt; i++) {
                    children[i].destroy();
                }
            } else {
                layer.removeAll();
            }

            return this;
        },

    };

    var ScrollFactorMethods = {
        setScrollFactor(name, scrollFactorX, scrollFactorY) {
            if (scrollFactorY === undefined) {
                scrollFactorY = scrollFactorX;
            }

            var layer = this.getLayer(name);
            if (!layer) {
                return this;
            }
            layer.scrollFactorX = scrollFactorX;
            layer.scrollFactorY = scrollFactorY;
            var children = layer.getAll();
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].setScrollFactor(scrollFactorX, scrollFactorY);
            }

            return this;
        }
    };

    const ArrayUtils$1 = Phaser.Utils.Array;

    const BringMeToTop = function () {
        var list;
        if (this.parentContainer) {
            list = this.parentContainer.list;
        } else if (this.displayList) {
            list = this.displayList.list;
        }
        if (!list) {
            return this;
        }

        ArrayUtils$1.BringToTop(list, this);

        return this;
    };

    const SendMeToBack = function () {
        var list;
        if (this.parentContainer) {
            list = this.parentContainer.list;
        } else if (this.displayList) {
            list = this.displayList.list;
        }
        if (!list) {
            return this;
        }

        ArrayUtils$1.SendToBack(list, this);

        return this;
    };

    const MoveMyDepthBelow = function (gameObject) {
        var list;
        if (gameObject.parentContainer) {
            list = gameObject.parentContainer.list;
            if (list.indexOf(this) === -1) {
                gameObject.parentContainer.add(this);
            }
        } else if (gameObject.displayList) {
            list = gameObject.displayList.list;
            if (list.indexOf(this) === -1) {
                gameObject.displayList.add(this);
            }
        }
        if (!list) {
            return this;
        }

        ArrayUtils$1.MoveBelow(list, this, gameObject);

        return this;
    };

    const MoveMyDepthAbove = function (gameObject) {
        var list;
        if (gameObject.parentContainer) {
            list = gameObject.parentContainer.list;
            if (list.indexOf(this) === -1) {
                if (gameObject.isRexContainerLite) {
                    gameObject.addToContainer(gameObject.parentContainer);
                } else {
                    gameObject.parentContainer.add(gameObject);
                }
            }
        } else if (gameObject.displayList) {
            list = gameObject.displayList.list;
            if (list.indexOf(this) === -1) {
                if (gameObject.isRexContainerLite) {
                    gameObject.addToLayer(gameObject.displayList);
                } else {
                    gameObject.displayList.add(gameObject);
                }
            }
        }
        if (!list) {
            return this;
        }

        ArrayUtils$1.MoveAbove(list, this, gameObject);

        return this;
    };

    var DisplayListMethods = {
        bringMeToTop: BringMeToTop,

        sendMeToBack: SendMeToBack,

        moveMyDepthBelow: MoveMyDepthBelow,

        moveMyDepthAbove: MoveMyDepthAbove,
    };

    var DepthMethods = {

        bringLayerToTop(layerName) {
            var layer = this.getLayer(layerName);
            if(!layer) {
                return this;
            }

            DisplayListMethods.bringMeToTop.call(layer);

            return this;
        },

        sendLayerToBack(layerName) {
            var layer = this.getLayer(layerName);
            if(!layer) {
                return this;
            }

            DisplayListMethods.sendMeToBack.call(layer);

            return this;
        },

        moveLayerBelow(layerName, baseLayerName) {
            if (layerName === baseLayerName) {
                return this;
            }

            var layer = this.getLayer(layerName);
            var baseLayer = this.getLayer(baseLayerName);
            if (!layer || !baseLayer) {
                return this;
            }

            DisplayListMethods.moveMyDepthBelow.call(layer, baseLayer);

            return this;
        },

        moveLayerAbove(layerName, baseLayerName) {
            if (layerName === baseLayerName) {
                return this;
            }

            var layer = this.getLayer(layerName);
            var baseLayer = this.getLayer(baseLayerName);
            if (!layer || !baseLayer) {
                return this;
            }

            DisplayListMethods.moveMyDepthAbove.call(layer, baseLayer);

            return this;
        },

    };

    const SetCamera = GOManager.prototype.setCamera;
    var CameraMethods = {
        setCamera(layerName, cameraName) {
            // Add a new camera if target camera is not existing
            var camera = GetCameraByName(this.scene, cameraName);
            if (!camera) {
                camera = this.scene.cameras.add(undefined, undefined, undefined, undefined, false, cameraName);
            }
            SetCamera.call(this, layerName, camera);
            return this;
        },
    };

    var methods$E = {

    };

    Object.assign(
        methods$E,
        LayerMethods,
        ScrollFactorMethods,
        DepthMethods,
        CameraMethods,
    );

    const GetValue$3w = Phaser.Utils.Objects.GetValue;

    class LayerManager extends GOManager {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            } else if (Array.isArray(config)) {
                config = {
                    layers: config
                };
            }

            if (!config.hasOwnProperty('fade')) {
                config.fade = 0;
            }

            config.viewportCoordinate = false;

            super(scene, config);

            var rootLayer = GetValue$3w(config, 'rootLayer');
            this.setRootLayer(rootLayer);

            var initLayers = GetValue$3w(config, 'layers');
            if (initLayers) {
                for (var i = 0, cnt = initLayers.length; i < cnt; i++) {
                    var layerConfig = initLayers[i];
                    if (typeof (layerConfig) === 'string') {
                        this.add(layerConfig);
                    } else {
                        var layerName = layerConfig.name;

                        this.add(layerName);

                        var scrollFactor = layerConfig.scrollFactor;
                        var scrollFactorX = GetValue$3w(layerConfig, 'scrollFactorX', scrollFactor);
                        var scrollFactorY = GetValue$3w(layerConfig, 'scrollFactorY', scrollFactor);
                        if (scrollFactorX !== undefined) {
                            this.setScrollFactor(layerName, scrollFactorX, scrollFactorY);
                        }

                        this.setCamera(layerName, layerConfig.cameraName);

                    }
                }
            }
        }

        setCreateGameObjectCallback(callback, scope) {
            if (!callback) {
                callback = CreateLayer;
            }
            super.setCreateGameObjectCallback(callback, scope);
            return this;
        }

        setRootLayer(rootLayer) {
            if (rootLayer === this.rootLayer) {
                return this;
            }

            var currentLayers = this.getAllGO();
            if (rootLayer) {
                rootLayer.add(currentLayers);
            } else {
                this.scene.displayList.add(currentLayers);
            }

            this.rootLayer = rootLayer;

            return this;
        }

        // Override
        addGO(name, gameObject) {
            super.addGO(name, gameObject);
            gameObject.name = name;

            if (this.rootLayer) {
                this.rootLayer.add(gameObject);
            }

            return this;
        }

        // Override
        get(name, out) {
            if (IsGameObject(name)) {
                var layer = GetLayer(name);
                if (!layer) {
                    return undefined;
                }
                name = layer.name;
                if (!name) {
                    return undefined;
                }
            }

            return super.get(name, out);
        }

    }

    var CreateLayer = function (scene, depth) {
        var layer = scene.add.layer();
        if (depth !== undefined) {
            layer.setDepth(depth);
        }
        return layer;
    };

    Object.assign(
        LayerManager.prototype,
        methods$E
    );

    var GetSoundManager = function (game) {
        if (IsSceneObject(game)) {
            return game.sys.sound;
        }
        return game.sound;
    };

    var HasaAudio = function (key) {
        return this.sound.game.cache.audio.has(key);
    };

    var GetSceneObject = function (object) {
        if ((object == null) || (typeof (object) !== 'object')) {
            return null;
        } else if (IsSceneObject(object)) { // object = scene
            return object;
        } else if (object.scene && IsSceneObject(object.scene)) { // object = game object
            return object.scene;
        } else if (object.parent && object.parent.scene && IsSceneObject(object.parent.scene)) { // parent = bob object
            return object.parent.scene;
        } else {
            return null;
        }
    };

    const GetValue$3v = Phaser.Utils.Objects.GetValue;

    class ComponentBase {
        constructor(parent, config) {
            this.setParent(parent);  // gameObject, scene, or game

            this.isShutdown = false;

            // Event emitter, default is private event emitter
            this.setEventEmitter(GetValue$3v(config, 'eventEmitter', true));

            // Register callback of parent destroy event, also see `shutdown` method
            if (this.parent) {
                if (this.parent === this.scene) { // parent is a scene
                    this.scene.sys.events.once('shutdown', this.onEnvDestroy, this);

                } else if (this.parent === this.game) { // parent is game
                    this.game.events.once('shutdown', this.onEnvDestroy, this);

                } else if (this.parent.once) { // parent is game object or something else
                    this.parent.once('destroy', this.onParentDestroy, this);
                }

                // bob object does not have event emitter
            }

        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            // parent might not be shutdown yet
            if (this.parent) {
                if (this.parent === this.scene) { // parent is a scene
                    this.scene.sys.events.off('shutdown', this.onEnvDestroy, this);

                } else if (this.parent === this.game) { // parent is game
                    this.game.events.off('shutdown', this.onEnvDestroy, this);

                } else if (this.parent.once) { // parent is game object or something else
                    this.parent.off('destroy', this.onParentDestroy, this);
                }

                // bob object does not have event emitter
            }


            this.destroyEventEmitter();

            this.parent = undefined;
            this.scene = undefined;
            this.game = undefined;

            this.isShutdown = true;
        }

        destroy(fromScene) {
            this.shutdown(fromScene);
        }

        onEnvDestroy() {
            this.destroy(true);
        }

        onParentDestroy(parent, fromScene) {
            this.destroy(fromScene);
        }

        setParent(parent) {
            this.parent = parent;  // gameObject, scene, or game

            this.scene = GetSceneObject(parent);
            this.game = GetGame(parent);

            return this;
        }

    }
    Object.assign(
        ComponentBase.prototype,
        EventEmitterMethods$1
    );

    const GetValue$3u = Phaser.Utils.Objects.GetValue;

    class TickTask extends ComponentBase {
        constructor(parent, config) {
            super(parent, config);

            this._isRunning = false;
            this.isPaused = false;
            this.tickingState = false;
            this.setTickingMode(GetValue$3u(config, 'tickingMode', 1));
            // boot() later
        }

        // override
        boot() {
            if ((this.tickingMode === 2) && (!this.tickingState)) {
                this.startTicking();
            }
        }

        // override
        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            this.stop();
            if (this.tickingState) {
                this.stopTicking();
            }
            super.shutdown(fromScene);
        }

        setTickingMode(mode) {
            if (typeof (mode) === 'string') {
                mode = TICKINGMODE[mode];
            }
            this.tickingMode = mode;
        }

        // override
        startTicking() {
            this.tickingState = true;
        }

        // override
        stopTicking() {
            this.tickingState = false;
        }

        get isRunning() {
            return this._isRunning;
        }

        set isRunning(value) {
            if (this._isRunning === value) {
                return;
            }

            this._isRunning = value;
            if ((this.tickingMode === 1) && (value != this.tickingState)) {
                if (value) {
                    this.startTicking();
                } else {
                    this.stopTicking();
                }
            }
        }

        start() {
            this.isPaused = false;
            this.isRunning = true;
            return this;
        }

        pause() {
            // Only can ba paused in running state
            if (this.isRunning) {
                this.isPaused = true;
                this.isRunning = false;
            }
            return this;
        }

        resume() {
            // Only can ba resumed in paused state (paused from running state)
            if (this.isPaused) {
                this.isPaused = false;
                this.isRunning = true;
            }
            return this;
        }

        stop() {
            this.isPaused = false;
            this.isRunning = false;
            return this;
        }

        complete() {
            this.isPaused = false;
            this.isRunning = false;
            this.emit('complete', this.parent, this);
        }
    }

    const TICKINGMODE = {
        'no': 0,
        'lazy': 1,
        'always': 2
    };

    const GetValue$3t = Phaser.Utils.Objects.GetValue;

    class SceneUpdateTickTask extends TickTask {
        constructor(parent, config) {
            super(parent, config);

            // scene update : update, preupdate, postupdate, prerender, render
            // game update : step, poststep, 

            // If this.scene is not available, use game's 'step' event
            var defaultEventName = (this.scene) ? 'update' : 'step';
            this.tickEventName = GetValue$3t(config, 'tickEventName', defaultEventName);
            this.isSceneTicker = !IsGameUpdateEvent(this.tickEventName);

        }

        startTicking() {
            super.startTicking();

            if (this.isSceneTicker) {
                this.scene.sys.events.on(this.tickEventName, this.update, this);
            } else {
                this.game.events.on(this.tickEventName, this.update, this);
            }

        }

        stopTicking() {
            super.stopTicking();

            if (this.isSceneTicker && this.scene) { // Scene might be destoryed
                this.scene.sys.events.off(this.tickEventName, this.update, this);
            } else if (this.game) {
                this.game.events.off(this.tickEventName, this.update, this);
            }
        }

        // update(time, delta) {
        //     
        // }

    }

    var IsGameUpdateEvent = function (eventName) {
        return (eventName === 'step') || (eventName === 'poststep');
    };

    const GetValue$3s = Phaser.Utils.Objects.GetValue;
    const Clamp$g = Phaser.Math.Clamp;

    let Timer$1 = class Timer {
        constructor(config) {
            this.resetFromJSON(config);
        }

        resetFromJSON(o) {
            this.state = GetValue$3s(o, 'state', IDLE$8);
            this.timeScale = GetValue$3s(o, 'timeScale', 1);
            this.delay = GetValue$3s(o, 'delay', 0);
            this.repeat = GetValue$3s(o, 'repeat', 0);
            this.repeatCounter = GetValue$3s(o, 'repeatCounter', 0);
            this.repeatDelay = GetValue$3s(o, 'repeatDelay', 0);
            this.duration = GetValue$3s(o, 'duration', 0);
            this.nowTime = GetValue$3s(o, 'nowTime', 0);
            this.justRestart = GetValue$3s(o, 'justRestart', false);
        }

        toJSON() {
            return {
                state: this.state,
                timeScale: this.timeScale,
                delay: this.delay,
                repeat: this.repeat,
                repeatCounter: this.repeatCounter,
                repeatDelay: this.repeatDelay,
                duration: this.duration,
                nowTime: this.nowTime,
                justRestart: this.justRestart,
            }
        }

        destroy() {

        }

        setTimeScale(timeScale) {
            this.timeScale = timeScale;
            return this;
        }

        setDelay(delay) {
            if (delay === undefined) {
                delay = 0;
            }
            this.delay = delay;
            return this;
        }

        setDuration(duration) {
            this.duration = duration;
            return this;
        }

        setRepeat(repeat) {
            this.repeat = repeat;
            return this;
        }

        setRepeatInfinity() {
            this.repeat = -1;
            return this;
        }

        setRepeatDelay(repeatDelay) {
            this.repeatDelay = repeatDelay;
            return this;
        }

        start() {
            this.nowTime = (this.delay > 0) ? -this.delay : 0;
            this.state = (this.nowTime >= 0) ? COUNTDOWN : DELAY;
            this.repeatCounter = 0;
            return this;
        }

        stop() {
            this.state = IDLE$8;
            return this;
        }

        update(time, delta) {
            if (this.state === IDLE$8 || this.state === DONE ||
                delta === 0 || this.timeScale === 0
            ) {
                return;
            }

            this.nowTime += (delta * this.timeScale);
            this.justRestart = false;
            if (this.nowTime >= this.duration) {
                if ((this.repeat === -1) || (this.repeatCounter < this.repeat)) {
                    this.repeatCounter++;
                    this.justRestart = true;
                    this.nowTime -= this.duration;
                    if (this.repeatDelay > 0) {
                        this.nowTime -= this.repeatDelay;
                        this.state = REPEATDELAY;
                    }
                } else {
                    this.nowTime = this.duration;
                    this.state = DONE;
                }
            } else if (this.nowTime >= 0) {
                this.state = COUNTDOWN;
            }
        }

        get t() {
            var t;
            switch (this.state) {
                case IDLE$8:
                case DELAY:
                case REPEATDELAY:
                    t = 0;
                    break;

                case COUNTDOWN:
                    t = this.nowTime / this.duration;
                    break;

                case DONE:
                    t = 1;
                    break;
            }
            return Clamp$g(t, 0, 1);
        }

        set t(value) {
            value = Clamp$g(value, -1, 1);
            if (value < 0) {
                this.state = DELAY;
                this.nowTime = -this.delay * value;
            } else {
                this.state = COUNTDOWN;
                this.nowTime = this.duration * value;

                if ((value === 1) && (this.repeat !== 0)) {
                    this.repeatCounter++;
                }
            }
        }

        setT(t) {
            this.t = t;
            return this;
        }

        get isIdle() {
            return this.state === IDLE$8;
        }

        get isDelay() {
            return this.state === DELAY;
        }

        get isCountDown() {
            return this.state === COUNTDOWN;
        }

        get isRunning() {
            return this.state === DELAY || this.state === COUNTDOWN;
        }

        get isDone() {
            return this.state === DONE;
        }

        get isOddIteration() {
            return (this.repeatCounter & 1) === 1;
        }

        get isEvenIteration() {
            return (this.repeatCounter & 1) === 0;
        }

    };

    const IDLE$8 = 0;
    const DELAY = 1;
    const COUNTDOWN = 2;
    const REPEATDELAY = 3;
    const DONE = -1;

    class TimerTickTask extends SceneUpdateTickTask {
        constructor(parent, config) {
            super(parent, config);
            this.timer = new Timer$1();
            // boot() later 
        }

        // override
        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            super.shutdown(fromScene);
            this.timer.destroy();
            this.timer = undefined;
        }

        start() {
            this.timer.start();
            super.start();
            return this;
        }

        stop() {
            this.timer.stop();
            super.stop();
            return this;
        }

        complete() {
            this.timer.stop();
            super.complete();
            return this;
        }

    }

    const GetValue$3r = Phaser.Utils.Objects.GetValue;
    const GetAdvancedValue$5 = Phaser.Utils.Objects.GetAdvancedValue;
    const GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;

    class EaseValueTaskBase extends TimerTickTask {
        resetFromJSON(o) {
            this.timer.resetFromJSON(GetValue$3r(o, 'timer'));
            this.setEnable(GetValue$3r(o, 'enable', true));
            this.setTarget(GetValue$3r(o, 'target', this.parent));
            this.setDelay(GetAdvancedValue$5(o, 'delay', 0));
            this.setDuration(GetAdvancedValue$5(o, 'duration', 1000));
            this.setEase(GetValue$3r(o, 'ease', 'Linear'));
            this.setRepeat(GetValue$3r(o, 'repeat', 0));

            return this;
        }

        setEnable(e) {
            if (e == undefined) {
                e = true;
            }
            this.enable = e;
            return this;
        }

        setTarget(target) {
            if (target === undefined) {
                target = this.parent;
            }
            this.target = target;
            return this;
        }

        setDelay(time) {
            this.delay = time;
            // Assign `this.timer.setRepeat(repeat)` manually
            return this;
        }

        setDuration(time) {
            this.duration = time;
            return this;
        }

        setRepeat(repeat) {
            this.repeat = repeat;
            // Assign `this.timer.setRepeat(repeat)` manually
            return this;
        }

        setRepeatDelay(repeatDelay) {
            this.repeatDelay = repeatDelay;
            // Assign `this.timer.setRepeatDelay(repeatDelay)` manually
            return this;
        }

        setEase(ease) {
            if (ease === undefined) {
                ease = 'Linear';
            }
            this.ease = ease;
            this.easeFn = GetEaseFunction(ease);
            return this;
        }

        // Override
        start() {
            // Ignore start if timer is running, i.e. in DELAY, o RUN state
            if (this.timer.isRunning) {
                return this;
            }

            super.start();
            return this;
        }

        restart() {
            this.timer.stop();
            this.start.apply(this, arguments);
            return this;
        }

        stop(toEnd) {
            if (toEnd === undefined) {
                toEnd = false;
            }

            super.stop();

            if (toEnd) {
                this.timer.setT(1);
                this.updateTarget(this.target, this.timer);
                this.complete();
            }

            return this;
        }

        update(time, delta) {
            if (
                (!this.isRunning) ||
                (!this.enable) ||
                (this.parent.hasOwnProperty('active') && !this.parent.active)
            ) {
                return this;
            }

            var target = this.target,
                timer = this.timer;

            timer.update(time, delta);

            // isDelay, isCountDown, isDone
            if (!timer.isDelay) {
                this.updateTarget(target, timer);
            }

            this.emit('update', target, this);

            if (timer.isDone) {
                this.complete();
            }

            return this;
        }

        // Override
        updateTarget(target, timer) {

        }
    }

    const SoundObjectClass = Phaser.Sound.BaseSound;
    var IsSoundObject = function (object) {
        return (object instanceof SoundObjectClass);
    };

    const GetValue$3q = Phaser.Utils.Objects.GetValue;
    const GetAdvancedValue$4 = Phaser.Utils.Objects.GetAdvancedValue;
    const Linear$p = Phaser.Math.Linear;

    let Fade$3 = class Fade extends EaseValueTaskBase {
        constructor(scene, sound, config) {
            if (IsSoundObject(scene)) {
                config = sound;
                sound = scene;
                scene = undefined;
            }

            sound.active = true;
            sound.scene = scene;
            sound.game = sound.manager.game;

            super(sound, config);
            // this.parent = parent
            // this.timer

            this.volume = {};
            this.resetFromJSON(config);
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setMode(GetValue$3q(o, 'mode', 0));
            this.setEnable(GetValue$3q(o, 'enable', true));
            this.setVolumeRange(
                GetAdvancedValue$4(o, 'volume.start', this.parent.volume),
                GetAdvancedValue$4(o, 'volume.end', 0)
            );
            return this;
        }

        setMode(m) {
            if (typeof (m) === 'string') {
                m = MODE$4[m];
            }
            this.mode = m;
            return this;
        }

        setVolumeRange(start, end) {
            this.volume.start = start;
            this.volume.end = end;
            return this;
        }

        start() {
            if (this.timer.isRunning) {
                return this;
            }

            this.parent.setVolume(this.volume.start);

            this.timer
                .setDelay(this.delay)
                .setDuration(this.duration);

            super.start();
            return this;
        }

        updateTarget(parent, timer) {
            parent.volume = Linear$p(this.volume.start, this.volume.end, timer.t);
        }

        complete() {
            super.complete();

            switch (this.mode) {
                case 1:
                    this.parent.stop();
                    break;
                case 2:
                    this.parent.stop();
                    this.parent.destroy();
                    break;
            }

            return this;
        }
    };

    const MODE$4 = {
        stop: 1,
        destroy: 2
    };

    var FadeIn$1 = function (scene, sound, duration, endVolume, startVolume) {
        if (IsSoundObject(scene)) {
            startVolume = endVolume;
            endVolume = duration;
            duration = sound;
            sound = scene;
            scene = undefined;
        }

        if (endVolume === undefined) {
            endVolume = 1;
        }
        if (startVolume === undefined) {
            startVolume = 0;
        }

        var config = {
            mode: 0,
            volume: {
                start: startVolume,
                end: endVolume
            },
            duration: duration
        };

        // create sound instance by key
        if (typeof (sound) === 'string') {
            sound = scene.sys.sound.add(sound);
        }

        var fade;
        if (sound.hasOwnProperty('_fade')) {
            fade = sound._fade;
            fade.stop().resetFromJSON(config);
        } else {
            fade = new Fade$3(scene, sound, config);
            sound._fade = fade;
        }

        fade.start();
        if (!sound.isPlaying) {
            sound.setVolume(startVolume).play();
        }
        return sound;
    };

    var FadeOut = function (scene, sound, duration, destroy) {
        if (IsSoundObject(scene)) {
            destroy = duration;
            duration = sound;
            sound = scene;
            scene = undefined;
        }

        if (destroy === undefined) {
            destroy = true;
        }

        var config = {
            mode: ((destroy) ? 2 : 1), // 1: stop, 2: destroy
            volume: {
                start: sound.volume,
                end: 0
            },
            duration: duration
        };

        var fade;
        if (sound.hasOwnProperty('_fade')) {
            fade = sound._fade;
            fade.stop().resetFromJSON(config);
        } else {
            fade = new Fade$3(scene, sound, config);
            sound._fade = fade;
        }

        fade.start();
        if (!sound.isPlaying) {
            sound.play();
        }
        return sound;
    };

    const GetValue$3p = Phaser.Utils.Objects.GetValue;

    var BackgroundMusicMethods = {
        setBackgroundMusicLoop(value) {
            if (value === undefined) {
                value = true;
            }

            this.backgroundMusicLoop = value;
            return this;
        },

        setBackgroundMusicFadeTime(time) {
            this.backgroundMusicFadeTime = time;
            return this;
        },

        getBackgroundMusic() {
            return this.backgroundMusic;
        },

        // Internal method
        setCurrentBackgroundMusic(music) {
            this.backgroundMusic = music;

            if (music) {
                music
                    .once('complete', function () {
                        if (this.backgroundMusic === music) {
                            this.backgroundMusic.destroy();
                            this.backgroundMusic = undefined;
                        }
                    }, this)
                    .once('destroy', function () {
                        if (this.backgroundMusic === music) {
                            this.backgroundMusic = undefined;
                        }
                    }, this);

                if (!music.isPlaying) {
                    music.play();
                }
            }
            return this;
        },

        playBackgroundMusic(key, config) {
            if (!this.hasAudio(key)) {
                console.error(`[Sound manager] Audio key'${key}' is not existed`);
                return this;
            }

            // Don't re-play the same background music
            if (this.backgroundMusic && (this.backgroundMusic.key === key)) {
                return this;
            }

            this.stopBackgroundMusic(); // Stop previous background music

            var music = this.sound.add(key, {
                loop: GetValue$3p(config, 'loop', this.backgroundMusicLoop),
                mute: GetValue$3p(config, 'mute', this.backgroundMusicMute),
                volume: GetValue$3p(config, 'volume', this.backgroundMusicVolume),
                detune: GetValue$3p(config, 'detune', 0),
                rate: GetValue$3p(config, 'rate', 1),
            });

            this.setCurrentBackgroundMusic(music);

            // Fade volume
            if (this.backgroundMusicFadeTime > 0) {
                this.fadeInBackgroundMusic(this.backgroundMusicFadeTime);
            }
            return this;
        },

        pauseBackgroundMusic() {
            if (this.backgroundMusic) {
                this.backgroundMusic.pause();
            }
            return this;
        },

        resumeBackgroundMusic() {
            if (this.backgroundMusic) {
                this.backgroundMusic.resume();
            }
            return this;
        },

        stopBackgroundMusic() {
            if (this.backgroundMusic) {
                if (this.backgroundMusicFadeTime > 0) {
                    this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, true);

                } else {
                    this.backgroundMusic.stop();
                    this.backgroundMusic.destroy();
                    this.backgroundMusic = undefined;
                }
            }
            return this;
        },

        fadeInBackgroundMusic(time) {
            if (this.backgroundMusic) {
                FadeIn$1(this.backgroundMusic, time, this.backgroundMusicVolume, 0);
            }

            return this;
        },

        fadeOutBackgroundMusic(time, isStopped) {
            if (this.backgroundMusic) {
                FadeOut(this.backgroundMusic, time, isStopped);
            }

            return this;
        },

        crossFadeBackgroundMusic(key, time) {
            if (!this.hasAudio(key)) {
                console.error(`[Sound manager] Audio key'${key}' is not existed`);
                return this;
            }

            var backgroundMusicFadeTimeSave = this.backgroundMusicFadeTime;
            this.backgroundMusicFadeTime = 0;

            this
                .fadeOutBackgroundMusic(time, true)
                .playBackgroundMusic(key)
                .fadeInBackgroundMusic(time);

            this.backgroundMusicFadeTime = backgroundMusicFadeTimeSave;

            return this;
        },

        setBackgroundMusicMute(mute) {
            if (mute === undefined) {
                mute = true;
            }

            this.backgroundMusicMute = mute;
            return this;
        },


        setBackgroundMusicVolume(volume) {
            this.backgroundMusicVolume = volume;
            return this;
        },

        setBackgroundMusicRate(rate) {
            if (this.backgroundMusic) {
                this.backgroundMusic.setRate(rate);
            }
            return this;
        },

        setBackgroundMusicDetune(detune) {
            if (this.backgroundMusic) {
                this.backgroundMusic.setDetune(detune);
            }
            return this;
        },



    };

    const GetValue$3o = Phaser.Utils.Objects.GetValue;

    var BackgroundMusic2Methods = {
        setBackgroundMusic2Loop(value) {
            if (value === undefined) {
                value = true;
            }

            this.backgroundMusic2Loop = value;
            return this;
        },

        setBackgroundMusic2FadeTime(time) {
            this.backgroundMusic2FadeTime = time;
            return this;
        },

        getBackgroundMusic2() {
            return this.backgroundMusic2;
        },

        // Internal method
        setCurrentBackgroundMusic2(music) {
            this.backgroundMusic2 = music;

            if (music) {
                music
                    .once('complete', function () {
                        if (this.backgroundMusic2 === music) {
                            this.backgroundMusic2.destroy();
                            this.backgroundMusic2 = undefined;
                        }
                    }, this)
                    .once('destroy', function () {
                        if (this.backgroundMusic2 === music) {
                            this.backgroundMusic2 = undefined;
                        }
                    }, this);

                if (!music.isPlaying) {
                    music.play();
                }
            }
            return this;
        },

        playBackgroundMusic2(key, config) {
            if (!this.hasAudio(key)) {
                console.error(`[Sound manager] Audio key'${key}' is not existed`);
                return this;
            }

            // Don't re-play the same background music
            if (this.backgroundMusic2 && (this.backgroundMusic2.key === key)) {
                return this;
            }

            this.stopBackgroundMusic2(); // Stop previous background music

            var music = this.sound.add(key, {
                loop: GetValue$3o(config, 'loop', this.backgroundMusicLoop),
                mute: GetValue$3o(config, 'mute', this.backgroundMusic2Mute),
                volume: GetValue$3o(config, 'volume', this.backgroundMusic2Volume),
                detune: GetValue$3o(config, 'detune', 0),
                rate: GetValue$3o(config, 'rate', 1),
            });

            this.setCurrentBackgroundMusic2(music);

            // Fade volume
            if (this.backgroundMusic2FadeTime > 0) {
                this.fadeInBackgroundMusic2(this.backgroundMusic2FadeTime);
            }
            return this;
        },

        pauseBackgroundMusic2() {
            if (this.backgroundMusic2) {
                this.backgroundMusic2.pause();
            }
            return this;
        },

        resumeBackgroundMusic2() {
            if (this.backgroundMusic2) {
                this.backgroundMusic2.resume();
            }
            return this;
        },

        stopBackgroundMusic2() {
            if (this.backgroundMusic2) {
                if (this.backgroundMusic2FadeTime > 0) {
                    this.fadeOutBackgroundMusic2(this.backgroundMusic2FadeTime, true);

                } else {
                    this.backgroundMusic2.stop();
                    this.backgroundMusic2.destroy();
                    this.backgroundMusic2 = undefined;
                }
            }
            return this;
        },

        fadeInBackgroundMusic2(time) {
            if (this.backgroundMusic2) {
                FadeIn$1(this.backgroundMusic2, time, this.backgroundMusic2Volume, 0);
            }

            return this;
        },

        fadeOutBackgroundMusic2(time, isStopped) {
            if (this.backgroundMusic2) {
                FadeOut(this.backgroundMusic2, time, isStopped);
            }

            return this;
        },

        crossFadeBackgroundMusic2(key, time) {
            if (!this.hasAudio(key)) {
                console.error(`[Sound manager] Audio key'${key}' is not existed`);
                return this;
            }

            var backgroundMusic2FadeTimeSave = this.backgroundMusic2FadeTime;
            this.backgroundMusic2FadeTime = 0;

            this
                .fadeOutBackgroundMusic2(time, true)
                .playBackgroundMusic2(key)
                .fadeInBackgroundMusic2(time);

            this.backgroundMusic2FadeTime = backgroundMusic2FadeTimeSave;

            return this;
        },

        setBackgroundMusic2Mute(mute) {
            if (mute === undefined) {
                mute = true;
            }

            this.backgroundMusic2Mute = mute;
            return this;
        },

        setBackgroundMusic2Volume(volume) {
            this.backgroundMusic2Volume = volume;
            return this;
        },

        setBackgroundMusic2Rate(rate) {
            if (this.backgroundMusic2) {
                this.backgroundMusic2.setRate(rate);
            }
            return this;
        },

        setBackgroundMusic2Detune(detune) {
            if (this.backgroundMusic2) {
                this.backgroundMusic2.setDetune(detune);
            }
            return this;
        },

    };

    const RemoveItem$a = Phaser.Utils.Array.Remove;
    const GetValue$3n = Phaser.Utils.Objects.GetValue;

    var SoundEffectsMethods = {

        getSoundEffects() {
            return this.soundEffects;
        },

        getLastSoundEffect() {
            return this.soundEffects[this.soundEffects.length - 1];
        },

        playSoundEffect(key, config) {
            if (!this.hasAudio(key)) {
                console.error(`[Sound manager] Audio key'${key}' is not existed`);
                return this;
            }

            var music = this.sound.add(key, {
                mute: GetValue$3n(config, 'mute', this.soundEffectsMute),
                volume: GetValue$3n(config, 'volume', this.soundEffectsVolume),
                detune: GetValue$3n(config, 'detune', 0),
                rate: GetValue$3n(config, 'rate', 1),
            });


            this.soundEffects.push(music);

            music
                .once('complete', function () {
                    music.destroy();

                    // SoundManager has been destroyed
                    if (!this.sound) {
                        return;
                    }
                    RemoveItem$a(this.soundEffects, music);
                }, this)
                .once('destroy', function () {
                    // SoundManager has been destroyed
                    if (!this.sound) {
                        return;
                    }
                    RemoveItem$a(this.soundEffects, music);
                }, this)
                .play();

            return this;
        },

        stopAllSoundEffects() {
            for (var i = this.soundEffects.length - 1; i >= 0; i--) {
                var soundEffect = this.soundEffects[i];
                soundEffect.stop();
                soundEffect.destroy();
            }

            return this;
        },

        fadeInSoundEffect(time) {
            var soundEffect = this.getLastSoundEffect();
            if (soundEffect) {
                FadeIn$1(soundEffect, time, this.soundEffectsVolume, 0);
            }

            return this;
        },

        fadeOutSoundEffect(time, isStopped) {
            var soundEffect = this.getLastSoundEffect();
            if (soundEffect) {
                FadeOut(soundEffect, time, isStopped);
            }

            return this;
        },

        fadeOutAllSoundEffects(time, isStopped) {
            for (var i = this.soundEffects.length - 1; i >= 0; i--) {
                FadeOut(this.soundEffects[i], time, isStopped);
            }

            return this;
        },

        setSoundEffectMute(mute, lastSoundEffect) {
            if (mute === undefined) {
                mute = true;
            }
            if (lastSoundEffect === undefined) {
                lastSoundEffect = false;
            }

            if (lastSoundEffect) {
                // Set volume of last sound effect
                var soundEffect = this.getLastSoundEffect();
                if (soundEffect) {
                    soundEffect.setMute(mute);
                }

            } else {
                // Set volume of all sound effects
                this.soundEffectsMute = mute;
            }

            return this;
        },

        setSoundEffectVolume(volume, lastSoundEffect) {
            if (lastSoundEffect === undefined) {
                lastSoundEffect = false;
            }

            if (lastSoundEffect) {
                // Set volume of last sound effect
                var soundEffect = this.getLastSoundEffect();
                if (soundEffect) {
                    soundEffect.setVolume(volume);
                }

            } else {
                // Set volume of all sound effects
                this.soundEffectsVolume = volume;
            }

            return this;
        },

        setSoundEffectDetune(detune, lastSoundEffect) {
            if (lastSoundEffect === undefined) {
                lastSoundEffect = false;
            }

            var soundEffects;
            if (lastSoundEffect) {
                soundEffects = [this.getLastSoundEffect()];
            } else {
                soundEffects = this.soundEffects;
            }

            for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
                soundEffects[i].setDetune(detune);
            }

            return this;
        },

        setSoundEffectRate(rate, lastSoundEffect) {
            if (lastSoundEffect === undefined) {
                lastSoundEffect = false;
            }

            var soundEffects;
            if (lastSoundEffect) {
                soundEffects = [this.getLastSoundEffect()];
            } else {
                soundEffects = this.soundEffects;
            }

            for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
                soundEffects[i].setRate(rate);
            }

            return this;
        },
    };

    const RemoveItem$9 = Phaser.Utils.Array.Remove;
    const GetValue$3m = Phaser.Utils.Objects.GetValue;

    var SoundEffects2Methods = {

        getSoundEffects2() {
            return this.soundEffects2;
        },

        getLastSoundEffect2() {
            return this.soundEffects2[this.soundEffects2.length - 1];
        },

        playSoundEffect2(key, config) {
            if (!this.hasAudio(key)) {
                console.error(`[Sound manager] Audio key'${key}' is not existed`);
                return this;
            }

            var music = this.sound.add(key, {
                mute: GetValue$3m(config, 'mute', this.soundEffects2Mute),
                volume: GetValue$3m(config, 'volume', this.soundEffects2Volume),
                detune: GetValue$3m(config, 'detune', 0),
                rate: GetValue$3m(config, 'rate', 1),
            });

            this.soundEffects2.push(music);

            music
                .once('complete', function () {
                    music.destroy();

                    // SoundManager has been destroyed
                    if (!this.sound) {
                        return;
                    }
                    RemoveItem$9(this.soundEffects2, music);
                }, this)
                .once('destroy', function () {
                    // SoundManager has been destroyed
                    if (!this.sound) {
                        return;
                    }
                    RemoveItem$9(this.soundEffects2, music);
                }, this)
                .play();

            return this;
        },

        stopAllSoundEffects2() {
            for (var i = this.soundEffects.length - 1; i >= 0; i--) {
                var soundEffect = this.soundEffects[i];
                soundEffect.stop();
                soundEffect.destroy();
            }

            return this;
        },

        fadeInSoundEffect2(time) {
            var soundEffect = this.getLastSoundEffect2();
            if (soundEffect) {
                FadeIn$1(soundEffect, time, this.soundEffects2Volume, 0);
            }

            return this;
        },

        fadeOutSoundEffect2(time, isStopped) {
            var soundEffect = this.getLastSoundEffect2();
            if (soundEffect) {
                FadeOut(soundEffect, time, isStopped);
            }

            return this;
        },

        fadeOutAllSoundEffects2(time, isStopped) {
            for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
                FadeOut(this.soundEffects2[i], time, isStopped);
            }

            return this;
        },

        setSoundEffect2Mute(mute, lastSoundEffect) {
            if (mute === undefined) {
                mute = true;
            }
            if (lastSoundEffect === undefined) {
                lastSoundEffect = false;
            }

            if (lastSoundEffect) {
                // Set volume of last sound effect
                var soundEffect = this.getLastSoundEffect2();
                if (soundEffect) {
                    soundEffect.setMute(mute);
                }

            } else {
                // Set volume of all sound effects
                this.soundEffects2Mute = mute;
            }

            return this;
        },

        setSoundEffect2Volume(volume, lastSoundEffect) {
            if (lastSoundEffect === undefined) {
                lastSoundEffect = false;
            }

            if (lastSoundEffect) {
                // Set volume of last sound effect
                var soundEffect = this.getLastSoundEffect2();
                if (soundEffect) {
                    soundEffect.setVolume(volume);
                }

            } else {
                // Set volume of all sound effects
                this.soundEffects2Volume = volume;
            }

            return this;
        },

        setSoundEffect2Detune(detune, lastSoundEffect) {
            if (lastSoundEffect === undefined) {
                lastSoundEffect = false;
            }

            var soundEffects;
            if (lastSoundEffect) {
                soundEffects = [this.getLastSoundEffect2()];
            } else {
                soundEffects = this.soundEffects2;
            }

            for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
                soundEffects[i].setDetune(detune);
            }

            return this;
        },

        setSoundEffect2Rate(rate, lastSoundEffect) {
            if (lastSoundEffect === undefined) {
                lastSoundEffect = false;
            }

            var soundEffects;
            if (lastSoundEffect) {
                soundEffects = [this.getLastSoundEffect2()];
            } else {
                soundEffects = this.soundEffects2;
            }

            for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
                soundEffects[i].setRate(rate);
            }

            return this;
        },
    };

    var Methods$h = {
        hasAudio: HasaAudio
    };

    Object.assign(
        Methods$h,
        BackgroundMusicMethods,
        BackgroundMusic2Methods,
        SoundEffectsMethods,
        SoundEffects2Methods,
    );

    const GetValue$3l = Phaser.Utils.Objects.GetValue;

    class SoundManager {
        constructor(game, config) {
            this.sound = GetSoundManager(game);

            // Background music will be (fade out)destroyed when play next one.
            this.backgroundMusic = undefined;
            this._backgroundMusicVolume = GetValue$3l(config, 'bgm.volume', 1);
            this._backgroundMusicMute = GetValue$3l(config, 'bgm.mute', false);

            this.setBackgroundMusicLoop(GetValue$3l(config, 'bgm.loop', true));
            this.setBackgroundMusicFadeTime(GetValue$3l(config, 'bgm.fade', 500));

            this.backgroundMusic2 = undefined;
            this._backgroundMusic2Volume = GetValue$3l(config, 'bgm2.volume', 1);
            this._backgroundMusic2Mute = GetValue$3l(config, 'bgm2.mute', false);

            this.setBackgroundMusic2Loop(GetValue$3l(config, 'bgm2.loop', true));
            this.setBackgroundMusic2FadeTime(GetValue$3l(config, 'bgm2.fade', 500));

            // Sound effect will be destroyed when completed
            this.soundEffects = [];
            this._soundEffectsVolume = GetValue$3l(config, 'soundEffect.volume', 1);

            this.soundEffects2 = [];
            this._soundEffects2Volume = GetValue$3l(config, 'soundEffect2.volume', 1);


            var initialBackgroundMusic = GetValue$3l(config, 'bgm.initial', undefined);
            if (initialBackgroundMusic) {
                this.setCurrentBackgroundMusic(initialBackgroundMusic);
            }

            var initialBackgroundMusic2 = GetValue$3l(config, 'bgm2.initial', undefined);
            if (initialBackgroundMusic2) {
                this.setCurrentBackgroundMusic2(initialBackgroundMusic2);
            }
        }

        destroy() {
            if (this.backgroundMusic) {
                this.backgroundMusic.destroy();
            }
            this.backgroundMusic = undefined;

            if (this.backgroundMusic2) {
                this.backgroundMusic2.destroy();
            }
            this.backgroundMusic2 = undefined;

            if (this.soundEffects.length) {
                for (var i = this.soundEffects.length - 1; i >= 0; i--) {
                    this.soundEffects[i].destroy();
                }
            }
            this.soundEffects.length = 0;

            if (this.soundEffects2.length) {
                for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
                    this.soundEffects2[i].destroy();
                }
            }
            this.soundEffects2.length = 0;

            this.sound = undefined;

            return this;
        }

        // backgroundMusic
        // mute
        get backgroundMusicMute() {
            return this._backgroundMusicMute;
        }

        set backgroundMusicMute(value) {
            this._backgroundMusicMute = value;
            if (this.backgroundMusic) {
                this.backgroundMusic.setMute(mute);
            }
        }

        // volume
        get backgroundMusicVolume() {
            return this._backgroundMusicVolume;
        }

        set backgroundMusicVolume(value) {
            this._backgroundMusicVolume = value;
            if (this.backgroundMusic) {
                this.backgroundMusic.setVolume(value);
            }
        }

        // backgroundMusic2
        // mute
        get backgroundMusic2Mute() {
            return this._backgroundMusic2Mute;
        }

        set backgroundMusic2Mute(value) {
            this._backgroundMusic2Mute = value;
            if (this.backgroundMusic2) {
                this.backgroundMusic2.setMute(mute);
            }
        }

        // volume
        get backgroundMusic2Volume() {
            return this._backgroundMusic2Volume;
        }

        set backgroundMusic2Volume(value) {
            this._backgroundMusic2Volume = value;
            if (this.backgroundMusic2) {
                this.backgroundMusic2.setVolume(value);
            }
        }

        // soundEffects
        // mute
        get soundEffectsMute() {
            return this._soundEffectsMute;
        }

        set soundEffectsMute(value) {
            this._soundEffectsMute = value;
            var soundEffects = this.soundEffects;
            for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
                soundEffects[i].setMute(value);
            }
        }

        // volume
        get soundEffectsVolume() {
            return this._soundEffectsVolume;
        }

        set soundEffectsVolume(value) {
            this._soundEffectsVolume = value;
            var soundEffects = this.soundEffects;
            for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
                soundEffects[i].setVolume(value);
            }
        }

        // soundEffects2
        // mute
        get soundEffects2Mute() {
            return this._soundEffects2Mute;
        }

        set soundEffects2Mute(value) {
            this._soundEffects2Mute = value;
            var soundEffects = this.soundEffects;
            for (var i = 0, cnt = soundEffects2.length; i < cnt; i++) {
                soundEffects[i].setMute(value);
            }
        }

        // volume
        get soundEffects2Volume() {
            return this._soundEffects2Volume;
        }

        set soundEffects2Volume(value) {
            this._soundEffects2Volume = value;
            var soundEffects = this.soundEffects2;
            for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
                soundEffects[i].setVolume(value);
            }
        }

    }

    Object.assign(
        SoundManager.prototype,
        Methods$h
    );

    const GetValue$3k = Phaser.Utils.Objects.GetValue;

    class BaseClock extends TickTask {
        constructor(parent, config) {
            super(parent, config);

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.isRunning = GetValue$3k(o, 'isRunning', false);
            this.timeScale = GetValue$3k(o, 'timeScale', 1);
            this.now = GetValue$3k(o, 'now', 0);
            return this;
        }

        toJSON() {
            return {
                isRunning: this.isRunning,
                timeScale: this.timeScale,
                now: this.now,
                tickingMode: this.tickingMode
            };
        }

        // Override
        // startTicking() { }

        // Override
        // stopTicking() {}

        start(startAt) {
            if (startAt === undefined) {
                startAt = 0;
            }
            this.delta = 0;
            this.now = startAt;
            super.start();
            return this;
        }

        seek(time) {
            this.now = time;
            return this;
        }

        setTimeScale(value) {
            this.timeScale = value;
            return this;
        }

        tick(delta) {
            delta *= this.timeScale;
            this.now += delta;
            this.delta = delta;
            this.emit('update', this.now, this.delta);
            return this;
        }
    }

    class Clock extends BaseClock {
        startTicking() {
            super.startTicking();
            this.scene.sys.events.on('update', this.update, this);
        }

        stopTicking() {
            super.stopTicking();
            if (this.scene) { // Scene might be destoryed
                this.scene.sys.events.off('update', this.update, this);
            }
        }

        update(time, delta) {
            if ((!this.isRunning) || (this.timeScale === 0)) {
                return this;
            }
            this.tick(delta);
            return this;
        }
    }

    var Yoyo$1 = function (t, threshold) {
        if (threshold === undefined) {
            threshold = 0.5;
        }
        if (t <= threshold) {
            t = t / threshold;
        } else {
            t = 1 - ((t - threshold) / (1 - threshold));
        }

        return t;
    };

    const Clamp$f = Phaser.Math.Clamp;

    class Timer {
        constructor(timeline, config) {
            this
                .setTimeline(timeline)
                .reset(config);
        }

        setTimeline(timeline) {
            this.timeline = timeline;
            return this;
        }

        setName(name) {
            this.name = name;
            return this;
        }

        setCallbacks(target, onStart, onProgress, onComplete) {
            this.target = target;
            this.onStart = onStart;
            this.onProgress = onProgress;
            this.onComplete = onComplete;
            return this;
        }

        setDuration(duration, yoyo) {
            if (yoyo === undefined) {
                yoyo = false;
            }
            this.duration = duration;
            this.remainder = duration;
            this.t = 0;
            this.yoyo = yoyo;
            return this;
        }

        setPaused(state) {
            this.isPaused = state;
            return this;
        }

        pause() {
            this.isPaused = true;
            return this;
        }

        resume() {
            this.isPaused = false;
            return this;
        }

        setRemoved(state) {
            this.removed = state;
            return this;
        }

        remove() {
            this.removed = true;
            return this;
        }

        seek(t) {
            this.remainder = this.duration * (1 - t);
            return this;
        }

        reset(o) {
            this
                .setName(o.name)
                .setDuration(o.duration, o.yoyo)
                .setCallbacks(o.target, o.onStart, o.onProgress, o.onComplete)
                .setPaused(false)
                .setRemoved(false);
            return this;
        }

        onFree() {
            this
                .setTimeline()
                .setCallbacks();
        }

        getProgress() {
            var value = 1 - (this.remainder / this.duration);
            value = Clamp$f(value, 0, 1);
            if (this.yoyo) {
                value = Yoyo$1(value);
            }
            return value;
        }

        setProgress(value) {
            value = Clamp$f(value, 0, 1);
            this.remainder = this.duration * (1 - value);
        }

        runCallback(callback) {
            if (!callback) {
                return;
            }
            callback(this.target, this.t, this);
        }

        update(time, delta) {
            if (this.removed) {
                return true;
            } else if (this.isPaused) {
                return false;
            }

            this.remainder -= delta;
            this.t = this.getProgress();
            this.runCallback(this.onProgress);

            var isCompleted = (this.remainder <= 0);
            if (isCompleted) {
                this.runCallback(this.onComplete);
            }
            return isCompleted;
        }
    }

    let TimerPool$1 = class TimerPool extends Stack {
        allocate() {
            return this.pop();
        }

        free(timer) {
            timer.onFree();
            this.push(timer);
        }

        freeMultiple(arr) {
            for (var i = 0, cnt = arr.length; i < cnt; i++) {
                this.free(arr[i]);
            }
            return this;
        }
    };

    const GetValue$3j = Phaser.Utils.Objects.GetValue;
    const TimerPool = new TimerPool$1();

    class Timeline extends Clock {
        constructor(parent, config) {
            super(parent, config);

            this.addedTimers = [];
            this.timers = [];
            this.timerPool = GetValue$3j(config, 'pool', TimerPool);
        }

        shutdown() {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            this.timerPool
                .freeMultiple(this.addedTimers)
                .freeMultiple(this.timers);

            this.timerPool = undefined;
            this.addedTimers = undefined;
            this.timers = undefined;

            super.shutdown();
        }

        addTimer(config) {
            var timer = this.timerPool.allocate();
            if (!timer) {
                timer = new Timer(this, config);
            } else {
                timer
                    .setTimeline(this)
                    .reset(config);
            }
            this.addedTimers.push(timer);
            timer.runCallback(timer.onStart);

            if (!this.isRunning) {
                this.start();
            }
            return timer;
        }

        delayCall(delay, callback, args, scope) {
            var timer = this.addTimer({
                duration: delay,
                onComplete: function (target, t, timer) {
                    if (args === undefined) {
                        args = [];
                    }
                    args.push(timer);
                    callback.apply(scope, args);
                }
            });
            return timer;
        }

        delayEvent(delay, eventName) {       
            this.removeDelayEvent(eventName);
            // Clear existed event

            var timer = this.delayCall(delay, function () {
                this.removeDelayEvent(eventName);  // Clear this timer
                this.emit(eventName);           
            }, [], this);

            this.once(`_remove.${eventName}`, function () {
                timer.remove();
                timer = undefined;
            });
            return this;
        }

        removeDelayEvent(eventName) {
            this.emit(`_remove.${eventName}`);
            return this;
        }

        getTimers(name) {
            var timers = [];

            var timerQueues = [this.addedTimers, this.timers];
            for (var ti = 0, tcnt = timerQueues.length; ti < tcnt; ti++) {
                var timerQueue = timerQueues[ti];
                for (var i = 0, cnt = timerQueue.length; i < cnt; i++) {
                    var timer = timerQueue[i];
                    if (timer.name === name) {
                        timers.push(timer);
                    }
                }
            }
            return timers;
        }

        update(time, delta) {
            super.update(time, delta);

            if (!this.isRunning) {
                return;
            }

            this.timers.push(...this.addedTimers);
            this.addedTimers.length = 0;
            var pendingTimers = [];
            for (var i = 0, cnt = this.timers.length; i < cnt; i++) {
                var timer = this.timers[i];
                var isStopped = timer.update(this.now, this.delta);
                if (isStopped) {
                    this.timerPool.free(timer);  // Free timer
                } else {
                    pendingTimers.push(timer);  // Add to timer queue
                }
            }
            this.timers = pendingTimers;

            if ((this.timers.length === 0) && (this.addedTimers.length === 0)) {
                this.complete(); // Emit 'complete' event
            }
        }
    }

    const WaitCompleteEvent = '_wait.complete';
    const RemoveWaitEvents = '_remove.wait';

    var PreUpdateDelayCall = function (gameObject, delay, callback, scope, args) {
        // Invoke callback under scene's 'preupdate' event
        var scene = GetSceneObject(gameObject);
        var timer = scene.time.delayedCall(delay, function () {
            scene.sys.events.once('preupdate', function () {
                callback.call(scope, args);
            });
        });
        return timer;
    };

    let WaitEvent$1 = class WaitEvent {
        constructor(parent) {
            if (!parent) {
                this.setEventEmitter(true);
                parent = this;
            }
            this.parent = parent;

            this.waitId = 0;

            // Override it
            this.waitCompleteEventName = WaitCompleteEvent;
            this.removeWaitEventsEventName = RemoveWaitEvents;
        }

        destroy() {
            this.removeWaitEvents();
            this.clearWaitCompleteCallbacks();
            this.parent = null;
        }

        // Emit completeEvent (default value is 'complete') when eventEmitter firing eventName
        waitEvent(eventEmitter, eventName, completeNextTick) {
            var callback = this.getWaitCompleteTriggerCallback(completeNextTick);
            eventEmitter.once(eventName, callback, this);
            // Once completeEvent firing, remove pending eventName from eventEmitter
            this.parent.once(this.removeWaitEventsEventName, function () {
                eventEmitter.off(eventName, callback, this);
            });
            // All pending eventName from eventEmitter will be removed at last
            return this.parent;
        }

        getWaitCompleteTriggerCallback(completeNextTick) {
            if (completeNextTick === undefined) {
                completeNextTick = true;
            }

            var waitId = this.waitId;
            var self = this;
            var completeCallback = function () {
                if (waitId < self.waitId) {
                    return;
                }
                self.waitId++;
                self.removeWaitEvents();
                self.parent.emit(self.waitCompleteEventName);
            };

            if (completeNextTick) {
                var completeCallbackNextTick = function () {
                    PreUpdateDelayCall(self.parent, 0, completeCallback);
                };
                return completeCallbackNextTick;
            } else {
                return completeCallback;
            }
        }

        removeWaitEvents() {
            this.parent.emit(this.removeWaitEventsEventName);
            return this;
        }

        addWaitCompleteCallback(callback, scope) {
            this.parent.on(this.waitCompleteEventName, callback, scope);
            return this;
        }

        clearWaitCompleteCallbacks() {
            this.parent.off(this.waitCompleteEventName);
            return this;
        }
    };

    Object.assign(
        WaitEvent$1.prototype,
        EventEmitterMethods$1
    );

    var WaitTimeMethods = {
        waitTime(duration) {
            var timeline = this.parent.timeline;
            timeline.delayEvent(duration, 'delay');

            // Clear delay event on timeline manually
            this.parent.once(this.removeWaitEventsEventName, function () {
                timeline.removeDelayEvent('delay');
            });
            return this.waitEvent(timeline, 'delay');
        },
    };

    var Split = function (s, delimiter) {
        var regexString = `(?<!\\\\)\\${delimiter}`;
        var escapeString = `\\${delimiter}`;
        return s.split(new RegExp(regexString, 'g')).map(function (s) {
            return s.replace(escapeString, delimiter);
        })
    };

    var WaitInputMethods = {
        setClickTarget(target) {
            this.clickTarget = target;

            if (!target) {
                this.touchEE = null;
            } else if (IsSceneObject(target)) {
                this.touchEE = target.input;
            } else {  // Assume that target is a gameObject
                this.touchEE = target.setInteractive();
            }
            return this;
        },

        clearClickTarget() {
            this.setClickTarget();
            return this;
        },

        setClickShortcutKeys(keys) {
            this.clickShortcutKeys = keys;
            return this;
        },

        clearClickShortcutKeys() {
            this.setClickShortcutKeys();
            return this;
        },

        waitClick() {
            var touchEE = this.touchEE;
            var clickShortcutKeys = this.clickShortcutKeys;
            if (touchEE || clickShortcutKeys) {
                if (touchEE) {
                    this.waitEvent(touchEE, 'pointerdown');
                }
                if (clickShortcutKeys) {
                    this.waitKeyDown(clickShortcutKeys);
                }
            } else {
                this.waitTime(0);
            }

            return this;
        },

        waitKeyDown(key) {
            var eventEmitter = this.scene.input.keyboard;
            if (typeof (key) === 'string') {
                if (key.indexOf('|') === -1) {
                    return this.waitEvent(eventEmitter, `keydown-${key.toUpperCase()}`)
                } else {
                    var keys = Split(key, '|');
                    for (var i = 0, cnt = keys.length; i < cnt; i++) {
                        this.waitEvent(eventEmitter, `keydown-${keys[i].toUpperCase()}`);
                    }
                    return this.parent;
                }
            } else {
                return this.waitEvent(eventEmitter, 'keydown');
            }
        }
    };

    var WaitGameObjectMethods = {
        waitGameObjectTweenComplete(goType, name, property) {
            var tweenTask = this.parent.getGameObjectTweenTask(goType, name, property);
            if (tweenTask) {
                return this.waitEvent(tweenTask, 'complete');
            }
            return this.waitTime(0);
        },

        waitGameObjectDataFlag(goType, name, dataKey, trueFlag) {
            var gameObject = this.parent.getGameObject(goType, name);
            if (!gameObject) {
                return this.waitTime(0);
            }

            if (gameObject.getData(dataKey) === trueFlag) {
                return this.waitTime(0);
            }

            var eventName = `changedata-${dataKey}`;
            var callback = function (gameObject, value, previousValue) {
                value = !!value;
                if (value === trueFlag) {
                    gameObject.emit('_dataFlagMatch');
                }
            };
            gameObject.on(eventName, callback);
            // Clear changedata event on gameobject manually
            this.parent.once(this.removeWaitEventsEventName, function () {
                gameObject.off(eventName, callback);
            });

            return this.waitEvent(gameObject, '_dataFlagMatch');
        },

        waitGameObjectDestroy(goType, name) {
            var gameObject = this.parent.getGameObject(goType, name);
            if (!gameObject) {
                return this.waitTime(0);
            }
            return this.waitEvent(gameObject, 'destroy');
        },

        waitGameObjectManagerEmpty(goType) {
            if (goType) {
                var gameObjectManager = this.parent.getGameObjectManager(goType);
                if (!gameObjectManager) {
                    return this.waitTime(0);
                }
                return this.waitEvent(gameObjectManager, 'empty');

            } else {
                var gameObjectManagers = this.parent.gameObjectManagers;
                var hasAnyWaitEvent = false;
                for (var name in gameObjectManagers) {
                    hasAnyWaitEvent = true;
                    this.waitEvent(gameObjectManagers[name], 'empty');
                }
                if (!hasAnyWaitEvent) {
                    return this.waitTime(0);
                }
                return this.parent;
            }
        }
    };

    var WaitCameraMethods = {
        setCameraTarget(camera) {
            this.cameraTarget = camera;
            return this;
        },

        clearCameraTarget() {
            this.setCameraTarget();
            return this;
        },

        waitCameraEffectComplete(effectName, cameraName) {
            var camera;
            if (cameraName) {
                camera = this.scene.cameras.getCamera(cameraName);
            } else {
                camera = this.cameraTarget;
            }

            if (!camera) {
                return this.waitTime(0);
            }

            var effect, completeEventName;
            switch (effectName) {
                case 'camera.fadein':
                    effect = camera.fadeEffect;
                    completeEventName = 'camerafadeincomplete';
                    break;

                case 'camera.fadeout':
                    effect = camera.fadeEffect;
                    completeEventName = 'camerafadeoutcomplete';
                    break;

                case 'camera.flash':
                    effect = camera.flashEffect;
                    completeEventName = 'cameraflashcomplete';
                    break;

                case 'camera.shake':
                    effect = camera.shakeEffect;
                    completeEventName = 'camerashakecomplete';
                    break;

                case 'camera.zoom':
                    effect = camera.zoomEffect;
                    completeEventName = 'camerazoomcomplete';
                    break;

                case 'camera.rotate':
                    effect = camera.rotateToEffect;
                    completeEventName = 'camerarotatecomplete';
                    break;

                case 'camera.scroll':
                    effect = camera.panEffect;
                    completeEventName = 'camerapancomplete';
                    break;
            }

            if (!effect.isRunning) {
                return this.waitTime(0);
            }

            return this.waitEvent(camera, completeEventName);
        },
    };

    var WaitMusicMethods = {
        waitSoundEffectComplete() {
            if (!this.parent.soundManager) {
                return this.waitTime(0);
            }
            var music = this.parent.soundManager.getLastSoundEffect();
            if (!music) {
                return this.waitTime(0);
            }
            return this.waitEvent(music, 'complete');
        },

        waitSoundEffect2Complete() {
            if (!this.parent.soundManager) {
                return this.waitTime(0);
            }
            var music = this.parent.soundManager.getLastSoundEffect2();
            if (!music) {
                return this.waitTime(0);
            }
            return this.waitEvent(music, 'complete');
        },

        waitBackgroundMusicComplete() {
            if (!this.parent.soundManager) {
                return this.waitTime(0);
            }
            var music = this.parent.soundManager.getBackgroundMusic();
            if (!music) {
                return this.waitTime(0);
            }
            return this.waitEvent(music, 'complete');
        },

        waitBackgroundMusic2Complete() {
            if (!this.parent.soundManager) {
                return this.waitTime(0);
            }
            var music = this.parent.soundManager.getBackgroundMusic2();
            if (!music) {
                return this.waitTime(0);
            }
            return this.waitEvent(music, 'complete');
        },
    };

    var WaitAny$1 = function (config) {
        if (!config) {
            return this.waitTime(0);
        }

        var hasAnyWaitEvent = false;
        for (var name in config) {
            switch (name) {
                case 'time':
                    hasAnyWaitEvent = true;
                    this.waitTime(config.time);
                    break;

                case 'click':
                    hasAnyWaitEvent = true;
                    this.waitClick();
                    break;


                case 'key':
                    hasAnyWaitEvent = true;
                    this.waitKeyDown(config.key);
                    break;

                case 'bgm':
                    hasAnyWaitEvent = true;
                    this.waitBackgroundMusicComplete();
                    break;

                case 'bgm2':
                    hasAnyWaitEvent = true;
                    this.waitBackgroundMusic2Complete();
                    break;

                case 'se':
                    hasAnyWaitEvent = true;
                    this.waitSoundEffectComplete();
                    break;

                case 'se2':
                    hasAnyWaitEvent = true;
                    this.waitSoundEffect2Complete();
                    break;

                case 'camera':
                    hasAnyWaitEvent = true;
                    this.waitCameraEffectComplete(`camera.${config.camera.toLowerCase()}`, config.cameraName);
                    break;

                default:
                    var names = name.split('.');
                    if (names.length === 2) {
                        // GONAME.destroy, GONAME.PROPNAME, GONAME.DATAKEY, GONAME.EVTNAME

                        var gameObjectName = names[0];
                        var propName = names[1];
                        var gameObjectManager = this.parent.getGameObjectManager(undefined, gameObjectName);
                        if (!gameObjectManager) {
                            continue;
                        }

                        // GONAME.destroy
                        if (propName === 'destroy') {
                            return this.waitGameObjectDestroy(undefined, gameObjectName);
                        }

                        // GONAME.PROPNAME (tween.complete)
                        var value = gameObjectManager.getProperty(gameObjectName, propName);
                        if (typeof (value) === 'number') {
                            hasAnyWaitEvent = true;
                            this.waitGameObjectTweenComplete(undefined, gameObjectName, propName);
                            continue;

                        }

                        // GONAME.DATAKEY (boolean)
                        var dataKey = propName;
                        var matchFalseFlag = dataKey.startsWith('!');
                        if (matchFalseFlag) {
                            dataKey = dataKey.substring(1);
                        }
                        if (gameObjectManager.hasData(gameObjectName, propName)) {
                            hasAnyWaitEvent = true;
                            this.waitGameObjectDataFlag(undefined, gameObjectName, dataKey, !matchFalseFlag);
                            continue;
                        }

                        // GONAME.EVTNAME
                        this.waitEvent(gameObject, propName);
                        continue;

                    } else if (names.length === 1) ;

                    break;

            }
        }

        if (!hasAnyWaitEvent) {
            this.waitTime(0);
        }

        return this.parent;
    };

    var methods$D = {
        waitAny: WaitAny$1,
    };
    Object.assign(
        methods$D,
        WaitTimeMethods,
        WaitInputMethods,
        WaitGameObjectMethods,
        WaitCameraMethods,
        WaitMusicMethods,
    );

    class WaitEventManager extends WaitEvent$1 {
        constructor(parent, config) {
            super(parent);

            this.waitCompleteEventName = GetValue$3U(config, 'completeEventName', this.waitCompleteEventName);

            this.setClickTarget(GetValue$3U(config, 'clickTarget', this.scene));
            this.setClickShortcutKeys(GetValue$3U(config, 'clickShortcutKeys', undefined));
            this.setCameraTarget(GetValue$3U(config, 'camera', this.scene.cameras.main));
        }

        get clickTarget() {
            return this.parent.clickTarget;
        }

        set clickTarget(value) {
            this.parent.clickTarget = value;
        }

        get clickShortcutKeys() {
            return this.parent.clickShortcutKeys;
        }

        set clickShortcutKeys(value) {
            this.parent.clickShortcutKeys = value;
        }

        get cameraTarget() {
            return this.parent.cameraTarget;
        }

        set cameraTarget(value) {
            this.parent.cameraTarget = value;
        }

        destroy() {
            this.clearClickTarget();
            this.clearClickShortcutKeys();
            this.clearCameraTarget();
            super.destroy();
        }

        get scene() {
            return this.parent.managersScene;
        }
    }

    Object.assign(
        WaitEventManager.prototype,
        methods$D,
    );

    const GetValue$3i = Phaser.Utils.Objects.GetValue;

    var InitManagers = function (scene, config) {
        this.clickTarget = undefined;
        this.clickShortcutKeys = undefined;
        this.cameraTarget = undefined;

        this.managersScene = scene;

        this.gameObjectManagers = {};

        var layerNames = GetValue$3i(config, 'layers', false);
        if (layerNames !== false) {
            var layerManager = new LayerManager(scene, {
                name: 'LAYER',
                layers: layerNames,
                rootLayer: GetValue$3i(config, 'rootLayer', undefined),
                depth: GetValue$3i(config, 'layerDepth', undefined)
            });
            this.addGameObjectManager(layerManager);
            this.layerManager = layerManager;
        }

        var soundManagerConfig = GetValue$3i(config, 'sounds');
        if (soundManagerConfig !== false) {
            this.soundManager = new SoundManager(scene, soundManagerConfig);
        }

        this.timeline = new Timeline(this);

        this.waitEventManager = new WaitEventManager(this, config);

        return this;
    };

    var SetTimeScale = function (value) {
        this.timeline.timeScale = value;
        for (var name in this.gameObjectManagers) {
            this.gameObjectManagers[name].setTimeScale(value);
        }
        return this;
    };

    var GetTimeScale = function () {
        return this.timeline.timeScale;
    };

    var DestroyManagers = function (fromScene) {
        this.waitEventManager.destroy();
        this.waitEventManager = undefined;

        // Destroy layerManager at last
        delete this.gameObjectManagers.layer;

        for (var name in this.gameObjectManagers) {
            this.gameObjectManagers[name].destroy(fromScene);
            delete this.gameObjectManagers[name];
        }

        if (this.layerManager) {
            this.layerManager.destroy(fromScene);
            this.layerManager = undefined;
        }

        if (this.soundManager) {
            this.soundManager.destroy();
            this.soundManager = undefined;
        }

        if (this.timeline) {
            this.timeline.destroy();
            this.timeline = undefined;
        }

        this.clickTarget = undefined;
        this.clickShortcutKeys = undefined;
        this.cameraTarget = undefined;
        this.managersScene = undefined;
    };

    var GameObjectManagerMethods$1 = {
        addGameObjectManager(config, GameObjectManagerClass) {
            var gameobjectManager;

            if (config instanceof (GOManager)) {
                gameobjectManager = config;

            } else if (typeof (config) === 'string') {
                gameobjectManager = GameObjectManagerClass;
                gameobjectManager.name = config;

            } else {
                if (config === undefined) {
                    config = {};
                }
                if (GameObjectManagerClass === undefined) {
                    GameObjectManagerClass = GOManager;
                }

                if (!config.createGameObjectScope) {
                    config.createGameObjectScope = this;
                }

                gameobjectManager = new GameObjectManagerClass(this.managersScene, config);
            }


            this.gameObjectManagers[gameobjectManager.name] = gameobjectManager;

            return this;
        },

        getGameObjectManager(managerName, gameObjectName) {
            if (managerName) {
                var manager = this.gameObjectManagers[managerName];
                return manager;
            } else {
                if (gameObjectName && (gameObjectName.charAt(0) === '!')) {
                    gameObjectName = gameObjectName.substring(1);
                }

                for (var managerName in this.gameObjectManagers) {
                    var manager = this.gameObjectManagers[managerName];
                    if (manager.has(gameObjectName)) {
                        return manager;
                    }
                }
            }
        },

        getGameObjectManagerNames() {
            var names = [];
            for (var name in this.gameObjectManagers) {
                names.push(name);
            }
            return names;
        },

        getGameObjectManagerName(gameObjectName) {
            var gameObjectManager = this.getGameObjectManager(undefined, gameObjectName);
            if (!gameObjectManager) {
                return undefined;
            }
            return gameObjectManager.name;
        },

        hasGameObjectMananger(managerName) {
            return managerName in this.gameObjectManagers;
        }
    };

    var GameObjectMethods = {
        createGameObject(goType, name, ...params) {
            this.getGameObjectManager(goType, name).add(name, ...params);
            return this;
        },

        destroyGameObject(goType, name) {
            var gameObjectManager = this.getGameObjectManager(goType, name);
            if (name === undefined) {
                gameObjectManager.removeAll();
            } else {
                gameObjectManager.remove(name);
            }
            return this;
        },

        hasGameObject(goType, name) {
            return !!this.getGameObjectManager(goType, name);
        },

        callGameObjectMethod(goType, name, methodName, ...params) {
            this.getGameObjectManager(goType, name).call(name, methodName, ...params);
            return this;
        },

        setGameObjectProperty(goType, name, prop, value) {
            this.getGameObjectManager(goType, name).setProperty(name, prop, value);
            return this;
        },

        easeGameObjectProperty(goType, name, config) {
            this.getGameObjectManager(goType, name).easeProperty(name, config);
            return this;
        },

        getGameObjectTweenTask(goType, name, property) {
            return this.getGameObjectManager(goType, name).getTweenTask(name, property);
        },

        getGameObject(goType, name, out) {
            var gameobjectManager = this.getGameObjectManager(goType, name);
            if (!gameobjectManager) {
                return out;
            }
            if (typeof (name) === 'string') {
                return gameobjectManager.getGO(name);
            } else {
                if (out === undefined) {
                    out = [];
                }

                var names = name;
                if (names === undefined) {
                    names = Object.keys(gameobjectManager.bobs);
                }

                var isArrayOutput = Array.isArray(out);
                for (var i = 0, cnt = names.length; i < cnt; i++) {
                    name = names[i];
                    var gameObject = gameobjectManager.getGO(name);
                    if (!gameObject) {
                        continue;
                    }

                    if (isArrayOutput) {
                        out.push(gameObject);
                    } else {
                        out[name] = gameObject;
                    }

                }

                return out;
            }
        },

        addGameObject(goType, name, gameObject) {
            var gameobjectManager = this.getGameObjectManager(goType, name);
            if (typeof (name) === 'string') {
                gameobjectManager.addGO(name, gameObject);
            } else {
                var names = name;
                for (name in names) {
                    gameobjectManager.addGO(name, names[name]);
                }
            }
            return this;
        },

        drawGameObjectsBounds(goTypes, graphics, config) {
            if (goTypes instanceof Phaser.GameObjects.Graphics) {
                config = graphics;
                graphics = goTypes;
                goTypes = undefined;
            }

            if (goTypes === undefined) {
                goTypes = this.getGameObjectManagerNames();
            }

            if (!Array.isArray(goTypes)) {
                goTypes = [goTypes];
            }
            for (var i = 0, cnt = goTypes.length; i < cnt; i++) {
                this.getGameObjectManager(goTypes[i]).drawGameObjectsBounds(graphics, config);
            }

            return this;
        }

    };

    var Extend = function (BaseClass) {
        class Managers extends BaseClass { }

        var Methods = {
            initManagers: InitManagers,
            setTimeScale: SetTimeScale,
            getTimeScale: GetTimeScale,
            destroyManagers: DestroyManagers,
        };

        Object.assign(
            Managers.prototype,
            Methods,
            GameObjectManagerMethods$1,
            GameObjectMethods,
        );

        return Managers;
    };

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var eventemitter3 = {exports: {}};

    (function (module) {

    	var has = Object.prototype.hasOwnProperty
    	  , prefix = '~';

    	/**
    	 * Constructor to create a storage for our `EE` objects.
    	 * An `Events` instance is a plain object whose properties are event names.
    	 *
    	 * @constructor
    	 * @private
    	 */
    	function Events() {}

    	//
    	// We try to not inherit from `Object.prototype`. In some engines creating an
    	// instance in this way is faster than calling `Object.create(null)` directly.
    	// If `Object.create(null)` is not supported we prefix the event names with a
    	// character to make sure that the built-in object properties are not
    	// overridden or used as an attack vector.
    	//
    	if (Object.create) {
    	  Events.prototype = Object.create(null);

    	  //
    	  // This hack is needed because the `__proto__` property is still inherited in
    	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    	  //
    	  if (!new Events().__proto__) prefix = false;
    	}

    	/**
    	 * Representation of a single event listener.
    	 *
    	 * @param {Function} fn The listener function.
    	 * @param {*} context The context to invoke the listener with.
    	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
    	 * @constructor
    	 * @private
    	 */
    	function EE(fn, context, once) {
    	  this.fn = fn;
    	  this.context = context;
    	  this.once = once || false;
    	}

    	/**
    	 * Add a listener for a given event.
    	 *
    	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
    	 * @param {(String|Symbol)} event The event name.
    	 * @param {Function} fn The listener function.
    	 * @param {*} context The context to invoke the listener with.
    	 * @param {Boolean} once Specify if the listener is a one-time listener.
    	 * @returns {EventEmitter}
    	 * @private
    	 */
    	function addListener(emitter, event, fn, context, once) {
    	  if (typeof fn !== 'function') {
    	    throw new TypeError('The listener must be a function');
    	  }

    	  var listener = new EE(fn, context || emitter, once)
    	    , evt = prefix ? prefix + event : event;

    	  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    	  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    	  else emitter._events[evt] = [emitter._events[evt], listener];

    	  return emitter;
    	}

    	/**
    	 * Clear event by name.
    	 *
    	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
    	 * @param {(String|Symbol)} evt The Event name.
    	 * @private
    	 */
    	function clearEvent(emitter, evt) {
    	  if (--emitter._eventsCount === 0) emitter._events = new Events();
    	  else delete emitter._events[evt];
    	}

    	/**
    	 * Minimal `EventEmitter` interface that is molded against the Node.js
    	 * `EventEmitter` interface.
    	 *
    	 * @constructor
    	 * @public
    	 */
    	function EventEmitter() {
    	  this._events = new Events();
    	  this._eventsCount = 0;
    	}

    	/**
    	 * Return an array listing the events for which the emitter has registered
    	 * listeners.
    	 *
    	 * @returns {Array}
    	 * @public
    	 */
    	EventEmitter.prototype.eventNames = function eventNames() {
    	  var names = []
    	    , events
    	    , name;

    	  if (this._eventsCount === 0) return names;

    	  for (name in (events = this._events)) {
    	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    	  }

    	  if (Object.getOwnPropertySymbols) {
    	    return names.concat(Object.getOwnPropertySymbols(events));
    	  }

    	  return names;
    	};

    	/**
    	 * Return the listeners registered for a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @returns {Array} The registered listeners.
    	 * @public
    	 */
    	EventEmitter.prototype.listeners = function listeners(event) {
    	  var evt = prefix ? prefix + event : event
    	    , handlers = this._events[evt];

    	  if (!handlers) return [];
    	  if (handlers.fn) return [handlers.fn];

    	  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    	    ee[i] = handlers[i].fn;
    	  }

    	  return ee;
    	};

    	/**
    	 * Return the number of listeners listening to a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @returns {Number} The number of listeners.
    	 * @public
    	 */
    	EventEmitter.prototype.listenerCount = function listenerCount(event) {
    	  var evt = prefix ? prefix + event : event
    	    , listeners = this._events[evt];

    	  if (!listeners) return 0;
    	  if (listeners.fn) return 1;
    	  return listeners.length;
    	};

    	/**
    	 * Calls each of the listeners registered for a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @returns {Boolean} `true` if the event had listeners, else `false`.
    	 * @public
    	 */
    	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    	  var evt = prefix ? prefix + event : event;

    	  if (!this._events[evt]) return false;

    	  var listeners = this._events[evt]
    	    , len = arguments.length
    	    , args
    	    , i;

    	  if (listeners.fn) {
    	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    	    switch (len) {
    	      case 1: return listeners.fn.call(listeners.context), true;
    	      case 2: return listeners.fn.call(listeners.context, a1), true;
    	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
    	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
    	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
    	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    	    }

    	    for (i = 1, args = new Array(len -1); i < len; i++) {
    	      args[i - 1] = arguments[i];
    	    }

    	    listeners.fn.apply(listeners.context, args);
    	  } else {
    	    var length = listeners.length
    	      , j;

    	    for (i = 0; i < length; i++) {
    	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

    	      switch (len) {
    	        case 1: listeners[i].fn.call(listeners[i].context); break;
    	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
    	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
    	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
    	        default:
    	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
    	            args[j - 1] = arguments[j];
    	          }

    	          listeners[i].fn.apply(listeners[i].context, args);
    	      }
    	    }
    	  }

    	  return true;
    	};

    	/**
    	 * Add a listener for a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @param {Function} fn The listener function.
    	 * @param {*} [context=this] The context to invoke the listener with.
    	 * @returns {EventEmitter} `this`.
    	 * @public
    	 */
    	EventEmitter.prototype.on = function on(event, fn, context) {
    	  return addListener(this, event, fn, context, false);
    	};

    	/**
    	 * Add a one-time listener for a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @param {Function} fn The listener function.
    	 * @param {*} [context=this] The context to invoke the listener with.
    	 * @returns {EventEmitter} `this`.
    	 * @public
    	 */
    	EventEmitter.prototype.once = function once(event, fn, context) {
    	  return addListener(this, event, fn, context, true);
    	};

    	/**
    	 * Remove the listeners of a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @param {Function} fn Only remove the listeners that match this function.
    	 * @param {*} context Only remove the listeners that have this context.
    	 * @param {Boolean} once Only remove one-time listeners.
    	 * @returns {EventEmitter} `this`.
    	 * @public
    	 */
    	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    	  var evt = prefix ? prefix + event : event;

    	  if (!this._events[evt]) return this;
    	  if (!fn) {
    	    clearEvent(this, evt);
    	    return this;
    	  }

    	  var listeners = this._events[evt];

    	  if (listeners.fn) {
    	    if (
    	      listeners.fn === fn &&
    	      (!once || listeners.once) &&
    	      (!context || listeners.context === context)
    	    ) {
    	      clearEvent(this, evt);
    	    }
    	  } else {
    	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
    	      if (
    	        listeners[i].fn !== fn ||
    	        (once && !listeners[i].once) ||
    	        (context && listeners[i].context !== context)
    	      ) {
    	        events.push(listeners[i]);
    	      }
    	    }

    	    //
    	    // Reset the array, or remove it completely if we have no more listeners.
    	    //
    	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    	    else clearEvent(this, evt);
    	  }

    	  return this;
    	};

    	/**
    	 * Remove all listeners, or those of the specified event.
    	 *
    	 * @param {(String|Symbol)} [event] The event name.
    	 * @returns {EventEmitter} `this`.
    	 * @public
    	 */
    	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    	  var evt;

    	  if (event) {
    	    evt = prefix ? prefix + event : event;
    	    if (this._events[evt]) clearEvent(this, evt);
    	  } else {
    	    this._events = new Events();
    	    this._eventsCount = 0;
    	  }

    	  return this;
    	};

    	//
    	// Alias methods names because people roll like that.
    	//
    	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    	//
    	// Expose the prefix.
    	//
    	EventEmitter.prefixed = prefix;

    	//
    	// Allow `EventEmitter` to be imported as module namespace.
    	//
    	EventEmitter.EventEmitter = EventEmitter;

    	//
    	// Expose the module.
    	//
    	{
    	  module.exports = EventEmitter;
    	} 
    } (eventemitter3));

    var eventemitter3Exports = eventemitter3.exports;
    var EE = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

    class EventEmitter extends EE {
        shutdown() {
            this.removeAllListeners();
        }
        destroy() {
            this.removeAllListeners();
        }
    }

    var EventEmitterMethods = {
        setEventEmitter(eventEmitter, EventEmitterClass) {
            if (EventEmitterClass === undefined) {
                EventEmitterClass = EventEmitter;
            }
            this._privateEE = (eventEmitter === true) || (eventEmitter === undefined);
            this._eventEmitter = (this._privateEE) ? (new EventEmitterClass()) : eventEmitter;
            return this;
        },

        destroyEventEmitter() {
            if (this._eventEmitter && this._privateEE) {
                this._eventEmitter.shutdown();
            }
            return this;
        },

        getEventEmitter() {
            return this._eventEmitter;
        },

        on: function () {
            if (this._eventEmitter) {
                this._eventEmitter.on.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        once: function () {
            if (this._eventEmitter) {
                this._eventEmitter.once.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        off: function () {
            if (this._eventEmitter) {
                this._eventEmitter.off.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        emit: function (event) {
            if (this._eventEmitter && event) {
                this._eventEmitter.emit.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        addListener: function () {
            if (this._eventEmitter) {
                this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        removeListener: function () {
            if (this._eventEmitter) {
                this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        removeAllListeners: function () {
            if (this._eventEmitter) {
                this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
            }
            return this;
        },

        listenerCount: function () {
            if (this._eventEmitter) {
                return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
            }
            return 0;
        },

        listeners: function () {
            if (this._eventEmitter) {
                return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
            }
            return [];
        },

        eventNames: function () {
            if (this._eventEmitter) {
                return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
            }
            return [];
        },
    };

    var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
    var HEX = /^0x[0-9A-F]+$/i;

    var TypeConvert = function (s) {
        if (typeof (s) !== 'string') {
            return s;
        }

        if (s === '') {
            s = null;

        } else if (FLOAT.test(s)) {
            s = parseFloat(s);

        } else if (HEX.test(s)) {
            s = parseInt(s, 16);

        } else {
            switch (s) {
                case 'false': s = false; break;
                case 'true': s = true; break;
                case 'null': s = null; break;
                case 'undefined': s = undefined; break;
            }
        }

        return s;
    };

    // This class might be used standalone

    let BracketParser$1 = class BracketParser {
        constructor(config) {
            // Event emitter
            this.setEventEmitter(GetValue$3U(config, 'eventEmitter', undefined));

            // Value convert
            this.setValueConverter(GetValue$3U(config, 'valueConvert', true));
            // Loop
            this.setLoopEnable(GetValue$3U(config, 'loop', false));

            // Brackets and generate regex
            this.setMultipleLinesTagEnable(GetValue$3U(config, 'multipleLinesTag', false));
            var delimiters = GetValue$3U(config, 'delimiters', '<>');
            this.setDelimiters(delimiters[0], delimiters[1]);

            // Translate tagName callback
            this.setTranslateTagNameCallback(GetValue$3U(config, 'translateTagNameCallback'));

            this.isRunning = false;
            this.isPaused = false;
            this.skipEventFlag = false;
            this.justCompleted = false;
            this.lastTagStart = null;
            this.lastTagEnd = null;
            this.lastContent = null;
        }

        shutdown() {
            this.destroyEventEmitter();
        }

        destroy() {
            this.shutdown();
        }

        setMultipleLinesTagEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.multipleLinesTagEnable = enable;
            return this;
        }

        // Override
        setDelimiters(delimiterLeft, delimiterRight) {
            if (delimiterRight === undefined) {
                delimiterRight = delimiterLeft[1];
                delimiterLeft = delimiterLeft[0];
            }
            this.delimiterLeft = delimiterLeft;
            this.delimiterRight = delimiterRight;

            delimiterLeft = EscapeRegex(this.delimiterLeft);
            delimiterRight = EscapeRegex(this.delimiterRight);

            var flag = (this.multipleLinesTagEnable) ? 'gs' : 'gi';
            this.reSplit = RegExp(`${delimiterLeft}(.+?)${delimiterRight}`, flag);

            return this;
        }

        setTranslateTagNameCallback(callback) {
            this.translateTagNameCallback = callback;
            return this;
        }

        setValueConverter(converter) {
            if (converter === true) {
                converter = TypeConvert;
            } else if (!converter) {
                converter = BypassValueConverter;
            }
            this.valueConverter = converter;
            return this;
        }

        setLoopEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.loopEnable = enable;
            return this;
        }

        setSource(source) {
            this.source = source;
            return this;
        }

        resetIndex(index) {
            if (index === undefined) {
                index = 0;
            }
            this.progressIndex = index;
            this.reSplit.lastIndex = index;
            this.lastTagStart = null;
            this.lastTagEnd = null;
            this.lastContent = null;
            this.justCompleted = false;
            this.isRunning = false;
            return this;
        }

        start(source) {
            this
                .setSource(source)
                .restart();
            return this;
        }

        restart() {
            this
                .resetIndex()
                .next();
        }

        next() {
            if (this.isPaused) {
                this.onResume();
            }

            // Don't re-enter this method
            if (this.isRunning) {
                return this;
            }

            this.isRunning = true;

            if (this.justCompleted) {
                this.isRunning = false;
                return this;
            }

            if (this.reSplit.lastIndex === 0) {
                this.onStart();
            }

            var text = this.source,
                lastIndex = text.length;

            this.reSplit.lastIndex = this.progressIndex;
            while (true) {
                var regexResult = this.reSplit.exec(text);
                // No tag found, complete
                if (!regexResult) {
                    if (this.progressIndex < lastIndex) {
                        this.onContent(text.substring(this.progressIndex, lastIndex));
                        // Might pause here
                        if (this.isPaused) {
                            this.progressIndex = lastIndex;
                            break;
                        }
                    }
                    this.onComplete();
                    this.isRunning = false;
                    return;
                }

                var matchEnd = this.reSplit.lastIndex;
                var matchStart = matchEnd - regexResult[0].length;

                // Process content between previous tag and current tag            
                if (this.progressIndex < matchStart) {
                    this.onContent(text.substring(this.progressIndex, matchStart));
                    // Might pause here
                    if (this.isPaused) {
                        this.progressIndex = matchStart;
                        break;
                    }
                }

                // Process current tag
                this.lastTagSource = regexResult[0];
                this.onTag(regexResult[1]);
                this.lastTagSource = undefined;

                this.progressIndex = matchEnd;
                // Might pause here
                if (this.isPaused) {
                    break;
                }

            }

            this.isRunning = false;
            return this;
        }

        skipEvent() {
            this.skipEventFlag = true;
            return this;
        }

        pause() {
            if (!this.isPaused) {
                this.onPause();
            }
            return this;
        }

        pauseUntilEvent(eventEmitter, eventName) {
            if (this.isPaused) {
                return this;
            }

            this.pause();
            eventEmitter.once(eventName, function () {
                this.next();
            }, this);
            return this;
        }

        onContent(content) {
            this.skipEventFlag = false;
            this.emit('content', content);
            this.lastContent = content;
        }

        // Override
        onTag(tagContent) {

        }

        onStart() {
            this.isRunning = true;
            this.emit('start', this);
        }

        onComplete() {
            this.isRunning = false;
            this.justCompleted = true;
            this.emit('complete', this);
            if (this.loopEnable) {
                this.resetIndex();
            }
        }

        onPause() {
            this.isPaused = true;
            this.emit('pause', this);
        }

        onResume() {
            this.isPaused = false;
            this.emit('resume', this);
        }

    };

    const BypassValueConverter = function (s) { return s; };

    Object.assign(
        BracketParser$1.prototype,
        EventEmitterMethods,
    );

    var StringToValues = function (text, valueConverter, delimiter) {
        if (text == null) {
            return [];
        }
        if (valueConverter === undefined) {
            valueConverter = TypeConvert;
        }
        if (delimiter === undefined) {
            delimiter = ',';
        }

        var values = text.split(delimiter);
        for (var i = 0, cnt = values.length; i < cnt; i++) {
            values[i] = valueConverter(values[i]);
        }
        return values;
    };

    class BracketParser extends BracketParser$1 {
        constructor(config) {
            if (config === undefined) {
                config = {};
            }

            if (!config.hasOwnProperty('multipleLinesTag')) {
                config.multipleLinesTag = false;
            }

            super(config);

            // Parameters for regex
            this.setTagExpression(GetValue$3U(config, 'regex.tag', undefined));
            this.setValueExpression(GetValue$3U(config, 'regex.value', undefined));
            // Brackets and generate regex
            var delimiters = GetValue$3U(config, 'delimiters', '<>');
            this.setDelimiters(delimiters[0], delimiters[1]);
        }

        setTagExpression(express) {
            if (!express) {
                express = DefaultTokenExpression;
            }
            this.tagExpression = express;
            return this;
        }

        setValueExpression(express) {
            if (!express) {
                express = DefaultTokenExpression;
            }
            this.valueExpression = express;
            return this;
        }

        setDelimiters(delimiterLeft, delimiterRight) {
            super.setDelimiters(delimiterLeft, delimiterRight);

            var tag = `(${this.tagExpression})(=(${this.valueExpression}))?`;
            this.reTag = RegExp(tag, 'i');

            if ((this.tagExpression !== DefaultTokenExpression) || (this.valueExpression !== DefaultTokenExpression)) {
                var startTagExpression = `${this.tagExpression}(=${this.valueExpression})?`;
                var endTagExpression = `/${this.tagExpression}`;

                delimiterLeft = EscapeRegex(this.delimiterLeft);
                delimiterRight = EscapeRegex(this.delimiterRight);

                var flag = (this.multipleLinesTagEnable) ? 'gs' : 'gi';
                this.reSplit = RegExp(`${delimiterLeft}((${startTagExpression})|(${endTagExpression}))${delimiterRight}`, flag);
            }

            return this;
        }

        onTag(tagContent) {
            var regexResult = tagContent.match(this.reTag);
            var tagName = regexResult[1];
           
            var isEndTag = (tagName.charAt(0) === '/');
            if (isEndTag) {
                tagName = tagName.substring(1, tagName.length);
            }

            if (this.translateTagNameCallback) {
                tagName = this.translateTagNameCallback(tagName);
            }

            this.skipEventFlag = false;
            if (!isEndTag) {
                var values = StringToValues(regexResult[3], this.valueConverter);
                this.emit(`+${tagName}`, ...values);
                if (!this.skipEventFlag) {
                    this.emit('+', tagName, ...values);
                }
                this.lastTagStart = tagName;
            } else {
                this.emit(`-${tagName}`);
                if (!this.skipEventFlag) {
                    this.emit('-', tagName);
                }
                this.lastTagEnd = tagName;
            }
        }
    }

    const DefaultTokenExpression = `[^=]+`;

    var OnParseColorTag = function (textPlayer, parser, config) {
        var tagName = 'color';
        var defaultColor;
        parser
            .on('start', function () {
                defaultColor = textPlayer.textStyle.color;
            })
            .on(`+${tagName}`, function (color) {
                textPlayer.textStyle.setColor(color);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setColor(defaultColor);
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setColor(defaultColor);
            });
    };

    var OnParseStrokeColorTag = function (textPlayer, parser, config) {
        var tagName = 'stroke';
        var defaultStroke;
        parser
            .on('start', function () {
                defaultStroke = textPlayer.textStyle.stroke;
                textPlayer.textStyle.setStrokeStyle(null);
            })
            .on(`+${tagName}`, function (color) {
                if (color === undefined) {
                    color = defaultStroke;
                }
                textPlayer.textStyle.setStrokeStyle(color);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setStrokeStyle(null);
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setStrokeStyle(defaultStroke);
            });
    };

    var OnParseBoldTag = function (textPlayer, parser, config) {
        var tagName = 'b';
        parser
            .on('start', function () {
                textPlayer.textStyle.setBold(false);
            })
            .on(`+${tagName}`, function () {
                textPlayer.textStyle.setBold(true);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setBold(false);
                parser.skipEvent();
            });
    };

    var OnParseItalicTag = function (textPlayer, parser, config) {
        var tagName = 'i';
        parser
            .on('start', function () {
                textPlayer.textStyle.setItalic(false);
            })
            .on(`+${tagName}`, function () {
                textPlayer.textStyle.setItalic(true);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setItalic(false);
                parser.skipEvent();
            });
    };

    var OnParseFontSizeTag = function (textPlayer, parser, config) {
        var tagName = 'size';
        var defaultFontSize;
        parser
            .on('start', function () {
                defaultFontSize = textPlayer.textStyle.fontSize;
            })
            .on(`+${tagName}`, function (fontSize) {
                textPlayer.textStyle.setFontSize(fontSize);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setFontSize(defaultFontSize);
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setFontSize(defaultFontSize);
            });
    };

    var OnParseOffsetYTag = function (textPlayer, parser, config) {
        var tagName = 'y';
        var defaultOffsetY;
        parser
            .on('start', function () {
                defaultOffsetY = textPlayer.textStyle.offsetY;
                textPlayer.textStyle.setOffsetY(0);
            })
            .on(`+${tagName}`, function (y) {
                if (y === undefined) {
                    y = defaultOffsetY;
                }
                textPlayer.textStyle.setOffsetY(y);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setOffsetY(0);
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setOffsetY(0);
            });
    };

    var OnParseOffsetXTag = function (textPlayer, parser, config) {
        var tagName = 'x';
        var defaultOffsetX;
        parser
            .on('start', function () {
                defaultOffsetX = textPlayer.textStyle.offsetY;
                textPlayer.textStyle.setOffsetX(0);
            })
            .on(`+${tagName}`, function (y) {
                if (y === undefined) {
                    y = defaultOffsetX;
                }
                textPlayer.textStyle.setOffsetX(y);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setOffsetX(0);
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setOffsetX(0);
            });
    };

    var OnParseLeftSpaceTag = function (textPlayer, parser, config) {
        var tagName = 'left';
        var defaultLeftSpace;
        parser
            .on('start', function () {
                defaultLeftSpace = textPlayer.textStyle.leftSpace;
                textPlayer.textStyle.setLeftSpace(0);
            })
            .on(`+${tagName}`, function (space) {
                if (space === undefined) {
                    space = defaultLeftSpace;
                }
                textPlayer.textStyle.setLeftSpace(space);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setLeftSpace(0);
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setLeftSpace(0);
            });
    };

    var OnParseRightSpaceTag = function (textPlayer, parser, config) {
        var tagName = 'right';
        var defaultRightSpace;
        parser
            .on('start', function () {
                defaultRightSpace = textPlayer.textStyle.rightSpace;
                textPlayer.textStyle.setRightSpace(0);
            })
            .on(`+${tagName}`, function (space) {
                if (space === undefined) {
                    space = defaultRightSpace;
                }
                textPlayer.textStyle.setRightSpace(space);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setRightSpace(0);
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setRightSpace(0);
            });
    };

    var OnParseShadowColorTag = function (textPlayer, parser, config) {
        var tagName = 'shadow';
        var defaultShadowColor;
        parser
            .on('start', function () {
                defaultShadowColor = textPlayer.textStyle.shadowColor;
                textPlayer.textStyle.setShadowColor(null);
            })
            .on(`+${tagName}`, function (color) {
                if (color === undefined) {
                    color = defaultShadowColor;
                }
                textPlayer.textStyle.setShadowColor(color);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setShadowColor(null);
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setShadowColor(defaultShadowColor);
            });
    };

    var OnParseAlignTag = function (textPlayer, parser, config) {
        var tagName = 'align';
        parser
            .on(`+${tagName}`, function (align) {
                textPlayer.textStyle.setAlign(align);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                textPlayer.textStyle.setAlign();
                parser.skipEvent();
            })
            .on('complete', function () {
                textPlayer.textStyle.setAlign();
            });
    };

    var OnParseImageTag$1 = function (textPlayer, parser, config) {
        var tagName = 'img';
        parser
            .on(`+${tagName}`, function (name) {
                var imgData = textPlayer.imageManager.get(name);
                if (imgData) {
                    AppendImage.call(textPlayer,
                        imgData.key, imgData.frame,
                        {
                            width: imgData.width,
                            hieght: imgData.height,
                            leftSpace: imgData.left,
                            rightSpace: imgData.right,
                            color: (imgData.tintFill) ? textPlayer.textStyle.color : undefined,
                        }
                    );
                }
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var OnParseImageTag = function (textPlayer, parser, config) {
        var tagName = 'space';
        parser
            .on(`+${tagName}`, function (width) {
                AppendSpace.call(textPlayer,
                    width
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var OnParseTypingSpeedTag = function (textPlayer, parser, config) {
        var tagName = 'speed';
        parser
            .on(`+${tagName}`, function (speed) {
                AppendCommand$2(textPlayer, speed);
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                AppendCommand$2(textPlayer, undefined);
                parser.skipEvent();
            });
    };

    var SetTypingSpeed = function (speed) {
        this.typeWriter.setTypingSpeed(speed);  // this: textPlayer
    };

    var AppendCommand$2 = function (textPlayer, speed) {
        AppendCommand$3.call(textPlayer,
            'speed',         // name
            SetTypingSpeed,  // callback
            speed,           // params
            textPlayer,      // scope
        );
    };

    var OnParsePlaySoundEffectTag = function (textPlayer, parser, config) {
        var tagName = 'se';
        parser
            .on(`+${tagName}`, function (name, fadeInTime) {
                AppendCommand$3.call(textPlayer,
                    tagName,              // name
                    PlaySoundEffect,      // callback
                    [name, fadeInTime],   // params
                    textPlayer,           // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'se2';
        parser
            .on(`+${tagName}`, function (name, fadeInTime) {
                AppendCommand$3.call(textPlayer,
                    tagName,              // name
                    PlaySoundEffect2,      // callback
                    [name, fadeInTime],   // params
                    textPlayer,           // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var PlaySoundEffect = function (params) {
        if (this.skipSoundEffect) {
            return;
        }

        var name = params[0];
        var fadeInTime = params[1];

        this.soundManager.playSoundEffect(name);  // this: textPlayer
        if (fadeInTime) {
            this.soundManager.fadeInSoundEffect(fadeInTime);
        }
    };

    var PlaySoundEffect2 = function (params) {
        if (this.skipSoundEffect) {
            return;
        }

        var name = params[0];
        var fadeInTime = params[1];

        this.soundManager.playSoundEffect2(name);  // this: textPlayer
        if (fadeInTime) {
            this.soundManager.fadeInSoundEffect2(fadeInTime);
        }
    };

    var OnParseFadeInSoundEffectTag = function (textPlayer, parser, config) {
        var tagName = 'se.fadein';
        parser
            .on(`+${tagName}`, function (time) {
                AppendCommand$3.call(textPlayer,
                    tagName,             // name
                    FadeInSoundEffect,   // callback
                    time,                // params
                    textPlayer,          // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'se2.fadein';
        parser
            .on(`+${tagName}`, function (time) {
                AppendCommand$3.call(textPlayer,
                    tagName,             // name
                    FadeInSoundEffect2,  // callback
                    time,                // params
                    textPlayer,          // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var FadeInSoundEffect = function (time) {
        // this: textPlayer
        this.soundManager.fadeInSoundEffect(time);
    };

    var FadeInSoundEffect2 = function (time) {
        // this: textPlayer
        this.soundManager.fadeInSoundEffect2(time);
    };

    var OnParseFadeOutSoundEffectTag = function (textPlayer, parser, config) {
        var tagName = 'se.fadeout';
        parser
            .on(`+${tagName}`, function (time, isStopped) {
                isStopped = (isStopped === 'stop');
                AppendCommand$3.call(textPlayer,
                    tagName,             // name
                    FadeOutSoundEffect,  // callback
                    [time, isStopped],   // params
                    textPlayer,          // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'se2.fadeout';
        parser
            .on(`+${tagName}`, function (time, isStopped) {
                isStopped = (isStopped === 'stop');
                AppendCommand$3.call(textPlayer,
                    tagName,             // name
                    FadeOutSoundEffect2,  // callback
                    [time, isStopped],   // params
                    textPlayer,          // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var FadeOutSoundEffect = function (params) {
        // this: textPlayer
        this.soundManager.fadeOutSoundEffect(...params);
    };

    var FadeOutSoundEffect2 = function (params) {
        // this: textPlayer
        this.soundManager.fadeOutSoundEffect2(...params);
    };

    var OnParseSetSoundEffectVolumeTag = function (textPlayer, parser, config) {
        var tagName = 'se.volume';
        parser
            .on(`+${tagName}`, function (volume) {
                AppendCommand$3.call(textPlayer,
                    tagName,               // name
                    SetSoundEffectVolume,  // callback
                    volume,                // params
                    textPlayer,            // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'se2.volume';
        parser
            .on(`+${tagName}`, function (volume) {
                AppendCommand$3.call(textPlayer,
                    tagName,               // name
                    SetSoundEffectVolume2,  // callback
                    volume,                // params
                    textPlayer,            // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var SetSoundEffectVolume = function (volume) {
        // this: textPlayer
        this.soundManager.setSoundEffectVolume(volume, true);
    };

    var SetSoundEffectVolume2 = function (volume) {
        // this: textPlayer
        this.soundManager.setSoundEffectVolume2(volume, true);
    };

    var OnParseSetSoundEffectMuteTag = function (textPlayer, parser, config) {
        var tagName = 'se.mute';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetSoundEffectMute,        // callback
                    undefined,                 // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'se2.mute';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetSoundEffect2Mute,       // callback
                    undefined,                 // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });

        var tagName = 'se.unmute';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetSoundEffectUnMute,      // callback
                    undefined,                 // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'se2.unmute';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetSoundEffect2UnMute,     // callback
                    undefined,                 // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var SetSoundEffectMute = function () {
        // this: textPlayer
        this.soundManager.setSoundEffectMute(true);
    };

    var SetSoundEffect2Mute = function () {
        // this: textPlayer
        this.soundManager.setSoundEffect2Mute(true);
    };

    var SetSoundEffectUnMute = function () {
        // this: textPlayer
        this.soundManager.setSoundEffectMute(false);
    };

    var SetSoundEffect2UnMute = function () {
        // this: textPlayer
        this.soundManager.setSoundEffect2Mute(false);
    };

    var OnParsePlayBackgroundMusicTag = function (textPlayer, parser, config) {
        var tagName = 'bgm';
        parser
            .on(`+${tagName}`, function (name, fadeInTime) {
                AppendCommand$3.call(textPlayer,
                    tagName,              // name
                    PlayBackgroundMusic,  // callback
                    [name, fadeInTime],   // params
                    textPlayer,           // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    'bgm.stop',           // name
                    StopBackgroundMusic,  // callback
                    undefined,            // params
                    textPlayer,           // scope
                );
                parser.skipEvent();
            });


        var tagName = 'bgm2';
        parser
            .on(`+${tagName}`, function (name, fadeInTime) {
                AppendCommand$3.call(textPlayer,
                    tagName,              // name
                    PlayBackgroundMusic2, // callback
                    [name, fadeInTime],   // params
                    textPlayer,           // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    'bgm2.stop',          // name
                    StopBackgroundMusic2, // callback
                    undefined,            // params
                    textPlayer,           // scope
                );
                parser.skipEvent();
            });
    };

    var PlayBackgroundMusic = function (params) {
        var name = params[0];
        var fadeInTime = params[1];

        // this: textPlayer
        this.soundManager.playBackgroundMusic(name);
        if (fadeInTime) {
            this.soundManager.fadeInBackgroundMusic(fadeInTime);
        }
    };

    var StopBackgroundMusic = function () {
        // this: textPlayer
        this.soundManager.stopBackgroundMusic();
    };

    var PlayBackgroundMusic2 = function (params) {
        var name = params[0];
        var fadeInTime = params[1];

        // this: textPlayer
        this.soundManager.playBackgroundMusic2(name);
        if (fadeInTime) {
            this.soundManager.fadeInBackgroundMusic2(fadeInTime);
        }
    };

    var StopBackgroundMusic2 = function () {
        // this: textPlayer
        this.soundManager.stopBackgroundMusic2();
    };

    var OnParseFadeInBackgroundMusicTag = function (textPlayer, parser, config) {
        var tagName = 'bgm.fadein';
        parser
            .on(`+${tagName}`, function (time) {
                AppendCommand$3.call(textPlayer,
                    tagName,                 // name
                    FadeInBackgroundMusic,   // callback
                    time,                    // params
                    textPlayer,              // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'bgm2.fadein';
        parser
            .on(`+${tagName}`, function (time) {
                AppendCommand$3.call(textPlayer,
                    tagName,                 // name
                    FadeInBackgroundMusic2,  // callback
                    time,                    // params
                    textPlayer,              // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var FadeInBackgroundMusic = function (time) {
        // this: textPlayer
        this.soundManager.fadeInBackgroundMusic(time);
    };

    var FadeInBackgroundMusic2 = function (time) {
        // this: textPlayer
        this.soundManager.fadeInBackgroundMusic2(time);
    };

    var OnParseFadeOutBackgroundMusicTag = function (textPlayer, parser, config) {
        var tagName = 'bgm.fadeout';
        parser
            .on(`+${tagName}`, function (time, isStopped) {
                isStopped = (isStopped === 'stop');
                AppendCommand$3.call(textPlayer,
                    tagName,                 // name
                    FadeOutBackgroundMusic,  // callback
                    [time, isStopped],       // params
                    textPlayer,              // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'bgm2.fadeout';
        parser
            .on(`+${tagName}`, function (time, isStopped) {
                isStopped = (isStopped === 'stop');
                AppendCommand$3.call(textPlayer,
                    tagName,                 // name
                    FadeOutBackgroundMusic2, // callback
                    [time, isStopped],       // params
                    textPlayer,              // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var FadeOutBackgroundMusic = function (params) {
        // this: textPlayer
        this.soundManager.fadeOutBackgroundMusic(...params);
    };

    var FadeOutBackgroundMusic2 = function (params) {
        // this: textPlayer
        this.soundManager.fadeOutBackgroundMusic2(...params);
    };

    var OnParseCrossFadeBackgroundMusicTag = function (textPlayer, parser, config) {
        var tagName = 'bgm.cross';
        parser
            .on(`+${tagName}`, function (name, fadeTime) {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    CrossFadeBackgroundMusic,  // callback
                    [name, fadeTime],          // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'bgm2.cross';
        parser
            .on(`+${tagName}`, function (name, fadeTime) {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    CrossFadeBackgroundMusic2, // callback
                    [name, fadeTime],          // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var CrossFadeBackgroundMusic = function (params) {
        // this: textPlayer
        this.soundManager.crossFadeBackgroundMusic(...params);
    };

    var CrossFadeBackgroundMusic2 = function (params) {
        // this: textPlayer
        this.soundManager.crossFadeBackgroundMusic2(...params);
    };

    var OnParsePauseBackgroundMusicTag = function (textPlayer, parser, config) {
        var tagName = 'bgm.pause';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,               // name
                    PauseBackgroundMusic,  // callback
                    undefined,             // params
                    textPlayer,            // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    'bgm.resume',           // name
                    ResumeBackgroundMusic,  // callback
                    undefined,              // params
                    textPlayer,             // scope
                );
                parser.skipEvent();
            });


        var tagName = 'bgm2.pause';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,               // name
                    PauseBackgroundMusic2, // callback
                    undefined,             // params
                    textPlayer,            // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    'bgm2.resume',          // name
                    ResumeBackgroundMusic2, // callback
                    undefined,              // params
                    textPlayer,             // scope
                );
                parser.skipEvent();
            });
    };

    var PauseBackgroundMusic = function () {
        // this: textPlayer
        this.soundManager.pauseBackgroundMusic();
    };

    var ResumeBackgroundMusic = function () {
        // this: textPlayer
        this.soundManager.resumeBackgroundMusic();
    };

    var PauseBackgroundMusic2 = function () {
        // this: textPlayer
        this.soundManager.pauseBackgroundMusic2();
    };

    var ResumeBackgroundMusic2 = function () {
        // this: textPlayer
        this.soundManager.resumeBackgroundMusic2();
    };

    var OnParseSetBackgroundMusicVolumeTag = function (textPlayer, parser, config) {
        var tagName = 'bgm.volume';
        parser
            .on(`+${tagName}`, function (volume) {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetBackgroundMusicVolume,  // callback
                    volume,                    // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'bgm2.volume';
        parser
            .on(`+${tagName}`, function (volume) {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetBackgroundMusicVolume2, // callback
                    volume,                    // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var SetBackgroundMusicVolume = function (volume) {
        // this: textPlayer
        this.soundManager.setBackgroundMusicVolume(volume);
    };

    var SetBackgroundMusicVolume2 = function (volume) {
        // this: textPlayer
        this.soundManager.setBackgroundMusicVolume2(volume);
    };

    var OnParseSetBackgroundMusicMuteTag = function (textPlayer, parser, config) {
        var tagName = 'bgm.mute';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetBackgroundMusicMute,    // callback
                    undefined,                 // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'bgm2.mute';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetBackgroundMusic2Mute,   // callback
                    undefined,                 // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });

        var tagName = 'bgm.unmute';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetBackgroundMusicUnMute,  // callback
                    undefined,                 // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });


        var tagName = 'bgm2.unmute';
        parser
            .on(`+${tagName}`, function () {
                AppendCommand$3.call(textPlayer,
                    tagName,                   // name
                    SetBackgroundMusic2UnMute, // callback
                    undefined,                 // params
                    textPlayer,                // scope
                );
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var SetBackgroundMusicMute = function () {
        // this: textPlayer
        this.soundManager.setBackgroundMusicMute(true);
    };

    var SetBackgroundMusic2Mute = function () {
        // this: textPlayer
        this.soundManager.setBackgroundMusic2Mute(true);
    };

    var SetBackgroundMusicUnMute = function () {
        // this: textPlayer
        this.soundManager.setBackgroundMusicMute(false);
    };

    var SetBackgroundMusic2UnMute = function () {
        // this: textPlayer
        this.soundManager.setBackgroundMusic2Mute(false);
    };

    var OnParseFadeInCameraTag = function (textPlayer, parser, config) {
        var tagName = 'camera.fadein';
        parser
            .on(`+${tagName}`, function (duration, red, green, blue) {
                AppendCommand$3.call(textPlayer,
                    tagName,                       // name
                    PlayFadeInEffect,              // callback
                    [duration, red, green, blue],  // params
                    textPlayer,                    // scope
                );
                parser.skipEvent();
            });
    };

    var PlayFadeInEffect = function (params) {
        // this: textPlayer
        this.cameraTarget.fadeIn(...params);
    };

    var OnParseFadeOutCameraTag = function (textPlayer, parser, config) {
        var tagName = 'camera.fadeout';
        parser
            .on(`+${tagName}`, function (duration, red, green, blue) {
                AppendCommand$3.call(textPlayer,
                    tagName,                       // name
                    PlayFadeOutEffect,             // callback
                    [duration, red, green, blue],  // params
                    textPlayer,                    // scope
                );
                parser.skipEvent();
            });
    };

    var PlayFadeOutEffect = function (params) {
        // this: textPlayer
        this.cameraTarget.fadeOut(...params);
    };

    var OnParseShakeCameraTag = function (textPlayer, parser, config) {
        var tagName = 'camera.shake';
        parser
            .on(`+${tagName}`, function (duration, intensity) {
                AppendCommand$3.call(textPlayer,
                    tagName,                // name
                    PlayShakeEffect,        // callback
                    [duration, intensity],  // params
                    textPlayer,             // scope
                );
                parser.skipEvent();
            });
    };

    var PlayShakeEffect = function (params) {
        // this: textPlayer
        this.cameraTarget.shake(...params);
    };

    var OnParseFlashCameraTag = function (textPlayer, parser, config) {
        var tagName = 'camera.flash';
        parser
            .on(`+${tagName}`, function (duration, red, green, blue) {
                AppendCommand$3.call(textPlayer,
                    tagName,                       // name
                    PlayFlashEffect,               // callback
                    [duration, red, green, blue],  // params
                    textPlayer,                    // scope
                );
                parser.skipEvent();
            });
    };

    var PlayFlashEffect = function (params) {
        // this: textPlayer
        this.cameraTarget.flash(...params);
    };

    var OnParseZoomCameraTag = function (textPlayer, parser, config) {
        var tagName = 'camera.zoom';
        parser
            .on(`+${tagName}`, function (value) {
                AppendCommand$3.call(textPlayer,
                    tagName,         // name
                    Zoom,            // callback
                    value,           // params
                    textPlayer,      // scope
                );
                parser.skipEvent();
            })
            .on(`+${tagName}.to`, function (value, duration, ease) {
                AppendCommand$3.call(textPlayer,
                    'camera.zoom.to',         // name
                    ZoomTo,                   // callback
                    [value, duration, ease],  // params
                    textPlayer,               // scope
                );
                parser.skipEvent();
            });
    };

    var Zoom = function (value) {
        // this: textPlayer
        this.cameraTarget.setZoom(value);
    };

    var ZoomTo = function (params) {
        // this: textPlayer
        this.cameraTarget.zoomTo(...params);
    };

    const DegToRad$f = Phaser.Math.DegToRad;

    var OnParseRotateCameraTag = function (textPlayer, parser, config) {
        var tagName = 'camera.rotate';
        parser
            .on(`+${tagName}`, function (value) {
                value = DegToRad$f(value);
                AppendCommand$3.call(textPlayer,
                    tagName,          // name
                    Rotate$1,           // callback
                    value,            // params
                    textPlayer,       // scope
                );
                parser.skipEvent();
            })
            .on(`+${tagName}.to`, function (value, duration, ease) {
                value = DegToRad$f(value);
                AppendCommand$3.call(textPlayer,
                    'camera.rotate.to',       // name
                    RotateTo,                 // callback
                    [value, duration, ease],  // params
                    textPlayer,               // scope
                );
                parser.skipEvent();
            });
    };

    var Rotate$1 = function (value) {
        // this: textPlayer
        this.cameraTarget.setRotation(value);
    };

    var RotateTo = function (params) {
        var value = params[0];
        var duration = params[1];
        var ease = params[2];

        // this: textPlayer
        this.cameraTarget.rotateTo(value, false, duration, ease);
    };

    var OnParseScrollCameraTag = function (textPlayer, parser, config) {
        var tagName = 'camera.scroll';
        parser
            .on(`+${tagName}`, function (x, y) {
                AppendCommand$3.call(textPlayer,
                    tagName,          // name
                    Scroll,           // callback
                    [x, y],           // params
                    textPlayer,       // scope
                );
                parser.skipEvent();
            })
            .on(`+${tagName}.to`, function (x, y, duration, ease) {
                AppendCommand$3.call(textPlayer,
                    'camera.scroll.to',       // name
                    ScrollTo,                 // callback
                    [x, y, duration, ease],   // params
                    textPlayer,               // scope
                );
                parser.skipEvent();
            });
    };

    var Scroll = function (params) {
        // this: textPlayer
        this.cameraTarget.setScroll(...params);
    };

    var ScrollTo = function (params) {
        var x = params[0];
        var y = params[1];
        var duration = params[2];
        var ease = params[3];

        // this: textPlayer
        var camera = this.cameraTarget;
        var xSave = camera.scrollX;
        var ySave = camera.scrollY;
        camera.setScroll(x, y);
        x += camera.centerX;
        y += camera.centerY;
        camera.setScroll(xSave, ySave);

        // x,y in pan() is the centerX, centerY
        camera.pan(x, y, duration, ease);
    };

    var OnParseWaitTag = function (textPlayer, parser, config) {
        var tagWait = 'wait';
        var tagClick = 'click';
        parser
            .on(`+${tagWait}`, function (name) {
                AppendCommand$1(textPlayer, name);
                parser.skipEvent();
            })
            .on(`-${tagWait}`, function () {
                parser.skipEvent();
            })
            .on(`+${tagClick}`, function () {  // Equal to [wait=click]
                AppendCommand$1(textPlayer, 'click');
                parser.skipEvent();
            })
            .on(`-${tagClick}`, function () {  // Equal to [/wait]
                parser.skipEvent();
            });
    };

    var Wait$2 = function (name) {
        this.typeWriter.wait(name);  // this: textPlayer
    };

    var AppendCommand$1 = function (textPlayer, name) {
        AppendCommand$3.call(textPlayer,
            'wait',       // name
            Wait$2,         // callback
            name,         // params
            textPlayer,   // scope
        );
    };

    var OnParseNewLineTag = function (textPlayer, parser, config) {
        var tagName = 'r';
        parser
            .on(`+${tagName}`, function () {
                AppendText.call(textPlayer, '\n');
                parser.skipEvent();
            })
            .on(`-${tagName}`, function () {
                parser.skipEvent();
            });
    };

    var OnParsePageBreakTag = function (textPlayer, parser, config) {
        var tagNames = ['pagebreak', 'pb'];
        for (var i = 0, cnt = tagNames.length; i < cnt; i++) {
            var tagName = tagNames[i];
            parser
                .on(`+${tagName}`, function () {
                    AppendText.call(textPlayer, '\f');
                    parser.skipEvent();
                })
                .on(`-${tagName}`, function () {
                    parser.skipEvent();
                });
        }

    };

    var OnParseContentOff = function (textPlayer, parser, config) {
        var tagName = 'content.off';
        parser
            .on(`+${tagName}`, function () {
                parser.setContentOutputEnable(false);
                parser.skipEvent();
            });
    };

    var OnParseContentOn = function (textPlayer, parser, config) {
        var tagName = 'content.on';
        parser
            .on(`+${tagName}`, function () {
                parser.setContentOutputEnable();
                parser.skipEvent();
            });
    };

    var OnParseContent = function (textPlayer, parser, config) {
        parser
            .on('content', function (content) {
                if (parser.contentOutputEnable) {
                    AppendText.call(textPlayer, content);
                } else {
                    var startTag = `+${parser.lastTagStart}`;
                    textPlayer.emit(`parser.${startTag}#content`, parser, content);
                }
            });
    };

    var OnParseCustomTag = function (textPlayer, parser, config) {
        parser
            .on('start', function () {
                textPlayer.emit('parser.start', parser);
            })
            .on('+', function (tagName, ...value) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                var startTag = `+${tagName}`;
                var param = value;
                textPlayer.emit(`parser.${startTag}`, parser, ...value, param);
                AppendCommand(textPlayer, startTag, param);
            })
            .on('-', function (tagName) {
                if (parser.skipEventFlag) {
                    return;
                }

                var endTag = `-${tagName}`;
                var param = [];
                textPlayer.emit(`parser.${endTag}`, parser, param);
                AppendCommand(textPlayer, endTag, param);
            })
            .on('complete', function () {
                textPlayer.emit('parser.complete', parser);
            });
    };

    var FireEvent$1 = function (param, tagName) {
        var eventName = `tag.${tagName}`;
        // this: textPlayer
        if (param == null) {
            this.emit(eventName);
        } else {
            this.emit(eventName, ...param);
        }

    };

    var AppendCommand = function (textPlayer, name, param) {
        AppendCommand$3.call(textPlayer,
            name,         // name
            FireEvent$1,    // callback
            param,        // params
            textPlayer,   // scope
        );
    };

    const ParseCallbacks$2 = [
        OnParseColorTag, OnParseStrokeColorTag,
        OnParseBoldTag, OnParseItalicTag,
        OnParseFontSizeTag, OnParseShadowColorTag, OnParseAlignTag,
        OnParseOffsetYTag, OnParseOffsetXTag, OnParseLeftSpaceTag, OnParseRightSpaceTag,
        OnParseImageTag$1,
        OnParseImageTag,

        OnParseTypingSpeedTag,

        OnParsePlaySoundEffectTag, OnParseFadeInSoundEffectTag, OnParseFadeOutSoundEffectTag,
        OnParseSetSoundEffectVolumeTag, OnParseSetSoundEffectMuteTag,
        OnParsePlayBackgroundMusicTag, OnParseFadeInBackgroundMusicTag, OnParseFadeOutBackgroundMusicTag, OnParseCrossFadeBackgroundMusicTag, OnParsePauseBackgroundMusicTag,
        OnParseSetBackgroundMusicVolumeTag, OnParseSetBackgroundMusicMuteTag,

        OnParseFadeInCameraTag, OnParseFadeOutCameraTag, OnParseShakeCameraTag, OnParseFlashCameraTag, OnParseZoomCameraTag, OnParseRotateCameraTag, OnParseScrollCameraTag,

        OnParseWaitTag,

        OnParseNewLineTag, OnParsePageBreakTag,
        OnParseContentOff, OnParseContentOn,
        OnParseContent,

        OnParseCustomTag,
    ];

    var AddParseCallbacks = function (textPlayer, parser, config) {
        for (var i = 0, cnt = ParseCallbacks$2.length; i < cnt; i++) {
            ParseCallbacks$2[i](textPlayer, parser, config);
        }
    };

    /*
    Skip line
    - An empty line, only has space
    - A comment line, start with commentLineStart ('//')
    */

    var PreProcess = function (parser, source) {
        var comentLineStart = parser.commentLineStart;
        var lines = source.split('\n');
        for (var i = 0, cnt = lines.length; i < cnt; i++) {
            var line = lines[i];
            if (line === '') ; else if (line.trim().length === 0) {
                // An empty line, only has space
                lines[i] = '';

            } else if (comentLineStart && line.startsWith(comentLineStart)) {
                // A comment line, start with commentLineStart ('//')
                lines[i] = '';
            }
        }
        // Use [r] to put \n
        return lines.join('');
    };

    const GetValue$3h = Phaser.Utils.Objects.GetValue;

    class Parser extends BracketParser {
        constructor(textPlayer, config) {
            if (config === undefined) {
                config = {};
            }
            if (!config.hasOwnProperty('delimiters')) {
                config.delimiters = '[]';
            }
            super(config);

            AddParseCallbacks(textPlayer, this, config);

            this.setCommentLineStartSymbol(GetValue$3h(config, 'comment', '//'));
            this.setContentOutputEnable();
        }

        setCommentLineStartSymbol(symbol) {
            this.commentLineStart = symbol;
            return this;
        }

        setContentOutputEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.contentOutputEnable = enable;
            return this;
        }

        start(source) {
            super.start(PreProcess(this, source));
            return this;
        }
    }

    var TypingSpeedMethods$1 = {
        setDefaultTypingSpeed(speed) {
            this.defaultSpeed = speed;
            return this;
        },

        setTypingSpeed(speed) {
            if (speed === undefined) {
                speed = this.defaultSpeed;
            }
            this.speed = speed;
            return this;
        },
    };

    // Internal events

    const PageFadeOutCompleteEvent = 'page.fadeout';
    const StopPlayEvent = '_remove.play';

    const ClearEvents$1 = [
        PageFadeOutCompleteEvent,
        StopPlayEvent
    ];

    var FadeOutPage = function () {
        if (!this.fadeOutPageCallback || !this.children) {
            this.emit(PageFadeOutCompleteEvent);
            return this;
        }

        var renderableChildren = this.children.filter(function (child) { return child.renderable });
        var waitObject = this.fadeOutPageCallback(renderableChildren, this.fadeOutPageDuration);
        if (!waitObject) {
            this.emit(PageFadeOutCompleteEvent);
        } else if (waitObject.once) {
            waitObject.once('complete', function () {
                this.emit(PageFadeOutCompleteEvent);
            }, this);
        } else if (waitObject.then) {
            var self = this;
            waitObject.then(function () {
                self.emit(PageFadeOutCompleteEvent);
            });
        } else {
            this.emit(PageFadeOutCompleteEvent);
        }

        return this;
    };

    var WaitEvent = function (eventEmitter, eventName) {
        return new Promise(function (resolve, reject) {
            eventEmitter.once(eventName, function () {
                resolve();
            });
        });
    };

    var WaitComplete = function (eventEmitter) {
        return WaitEvent(eventEmitter, 'complete');
    };

    var Start$1 = function (children) {
        this.children = children;
        this.index = 0;
        this.isPageTyping = true;

        if (this.onTypeStart) {
            this.onTypeStart(children);
        }
        this.typing();

        return WaitComplete(this);  // Promise
    };

    const TypingDelayTimerType = 'delay';
    const TypingAnimationTimerType = 'anim';

    var Typing = function (offsetTime) {
        if (offsetTime === undefined) {
            offsetTime = 0;
        }

        var delay = 0;
        this.inTypingProcessLoop = true;
        while (this.inTypingProcessLoop) {
            var child = this.getNextChild();
            if (!child) {
                if (this.timeline.isRunning) {
                    // Wait until last animationConfig is end
                    this.timeline.once('complete', function () {
                        this.isPageTyping = false;
                        this.emit('complete');
                    }, this);
                } else {
                    this.isPageTyping = false;
                    this.emit('complete');
                }
                break;  // Leave this typing loop
            }

            if (child.renderable) {
                // Typing this char
                var animationConfig = this.animationConfig;
                if (animationConfig.duration > 0) {
                    var animationTimer = this.timeline.addTimer({
                        name: TypingAnimationTimerType,
                        target: child,
                        duration: animationConfig.duration,
                        yoyo: animationConfig.yoyo,
                        onStart: animationConfig.onStart,
                        onProgress: animationConfig.onProgress,
                        onComplete: animationConfig.onComplete,
                    });
                    if (this.skipTypingAnimation) {
                        animationTimer.seek(1);
                    }
                } else {  // No animationConfig, only invoke onStart callback
                    if (animationConfig.onStart) {
                        animationConfig.onStart(child, 0);
                    }
                }

                // Set to min size
                if (this.minSizeEnable) {
                    this.textPlayer.setToMinSize();
                }

                this.textPlayer.emit('typing', child);

                var nextChild = this.nextChild;
                if (nextChild) {
                    if (this.skipSpaceEnable && IsSpaceChar(nextChild)) ; else {
                        delay += (this.speed + offsetTime);
                        offsetTime = 0;
                        if (delay > 0) {
                            // Process next character later
                            this.typingTimer = this.timeline.addTimer({
                                name: TypingDelayTimerType,
                                target: this,
                                duration: delay,
                                onComplete: function (target, t, timer) {
                                    target.typingTimer = undefined;
                                    Typing.call(target, timer.remainder);
                                }
                            });
                            break;  // Leave this typing loop     
                        }
                    }
                }
                // Process next child
            } else if (IsCommand(child)) {
                child.exec();
                // Process next child
            }

        }

        // Set to min size
        if (this.minSizeEnable) {
            this.textPlayer.setToMinSize();
        }

        this.inTypingProcessLoop = false;
    };

    var Pause$1 = function () {
        // Pause typing timer and animation progresses
        this.timeline.pause(); 
        return this;
    };

    var Resume$1 = function () {
        // Resume typing timer and animation progresses
        this.timeline.resume();
        return this;
    };

    var PauseTyping$1 = function () {
        // Already in typingPaused state
        if (this.isTypingPaused) {
            return this;
        }

        if (this.typingTimer) {  // Pause when typing timer is counting
            this.typingTimer.pause();
            this.isTypingPaused = true;
        } else if (this.inTypingProcessLoop) {  // Pause in loop of typing(), by tag
            this.inTypingProcessLoop = false;
            this.isTypingPaused = true;
        }
        return this;
    };

    var ResumeTyping$1 = function (offsetTime) {
        // Already not in typingPaused state
        if (!this.isTypingPaused) {
            return this;
        }
        if (offsetTime === undefined) {
            offsetTime = 0;
        }

        if (this.typingTimer) {  // Pause when typing timer is paused
            this.isTypingPaused = false;
            this.typingTimer.resume();
            this.typingTimer.remainder += offsetTime;
        } else if (this.isTypingPaused) {  // Resume paused by tag
            this.isTypingPaused = false;
            this.typing(offsetTime);
        }
        return this;
    };

    var IsWaitCameraEffect = function (name) {
        switch (name) {
            case 'camera.fadein':
            case 'camera.fadeout':
            case 'camera.flash':
            case 'camera.shake':
            case 'camera.zoom':
            case 'camera.rotate':
            case 'camera.scroll':
                return true;
            default:
                return false;
        }
    };

    var IsWaitGameObject = function (textPlayer, name) {
        var names = name.split('.');
        return textPlayer.gameObjectManagers.hasOwnProperty(names[0]);
    };

    var WaitGameObject = function (textPlayer, tag, callback, scope) {
        var waitEventManager = textPlayer.waitEventManager;
        var tags = tag.split('.');
        var goType = tags[0];
        var gameObjectManager = textPlayer.getGameObjectManager(goType);
        var waitEventName = `wait.${goType}`;
        switch (tags.length) {
            case 1:  // 'goType' : wait all sprites has beeen destroyed
                waitEventManager.waitGameObjectManagerEmpty(goType);
                textPlayer.emit(waitEventName);
                return;

            case 2:  // 'goType.name' : wait goType.name has been destroyed
                var name = tags[1];
                waitEventManager.waitGameObjectDestroy(goType, name);
                textPlayer.emit(waitEventName, name);
                return;

            case 3:  // 'goType.name.prop' : wait ease goType.name.prop has been completed
                var name = tags[1],
                    prop = tags[2];

                var value = gameObjectManager.getProperty(name, prop);
                // Can start tween task for a number property
                if (typeof (value) === 'number') {
                    waitEventManager.waitGameObjectTweenComplete(goType, name, prop);
                    textPlayer.emit(waitEventName, name, prop);
                    return;
                }

                var dataKey = prop;
                var matchFalseFlag = dataKey.startsWith('!');
                if (matchFalseFlag) {
                    dataKey = dataKey.substring(1);
                }
                // Wait until flag is true/false
                if (gameObjectManager.hasData(name, dataKey)) {
                    waitEventManager.waitGameObjectDataFlag(goType, name, dataKey, !matchFalseFlag);
                    textPlayer.emit(waitEventName, name, dataKey);
                    return;
                } else {
                    waitEventManager.waitTime(0);
                    return;
                }

        }

    };

    const KeyCodes = Phaser.Input.Keyboard.KeyCodes;

    var WaitAny = function (textPlayer, names, callback, scope) {
        var waitEventManager = textPlayer.waitEventManager;
        waitEventManager
            .clearWaitCompleteCallbacks()
            .addWaitCompleteCallback(callback, scope);

        if ((typeof (names) === 'string') && (names.length > 1) && (names.indexOf('|') !== -1)) {
            names = names.split('|');
        } else {
            names = [names];
        }

        for (var i = 0, cnt = names.length; i < cnt; i++) {
            var name = names[i];

            if ((name == null) || (name === 'wait')) {  // Wait event
                var waitCompleteTriggerCallback = textPlayer.waitEventManager.getWaitCompleteTriggerCallback();
                textPlayer.emit('wait', waitCompleteTriggerCallback);

            } else if ((typeof (name) === 'number') || !isNaN(name)) { // A number, or a number string
                var time = parseFloat(name);
                waitEventManager.waitTime(time);
                textPlayer.emit('wait.time', time);

            } else if (name === 'click') {  // 'click'
                waitEventManager.waitClick();
                textPlayer.emit('wait.click');

            } else if (name === 'se') {
                waitEventManager.waitSoundEffectComplete();
                var music = textPlayer.soundManager.getLastSoundEffect();
                textPlayer.emit('wait.music', music);

            } else if (name === 'se2') {
                waitEventManager.waitSoundEffect2Complete();
                var music = textPlayer.soundManager.getLastSoundEffect2();
                textPlayer.emit('wait.music', music);

            } else if (name === 'bgm') {
                waitEventManager.waitBackgroundMusicComplete();
                var music = textPlayer.soundManager.getBackgroundMusic();
                textPlayer.emit('wait.music', music);

            } else if (name === 'bgm2') {
                waitEventManager.waitBackgroundMusic2Complete();
                var music = textPlayer.soundManager.getBackgroundMusic2();
                textPlayer.emit('wait.music', music);

            } else if (KeyCodes.hasOwnProperty(name.toUpperCase())) {
                waitEventManager.waitKeyDown(name);
                textPlayer.emit('wait.keydown', name);

            } else if (IsWaitCameraEffect(name)) {
                waitEventManager.waitCameraEffectComplete(name);
                textPlayer.emit('wait.camera', name);

            } else if (IsWaitGameObject(textPlayer, name)) {
                WaitGameObject(textPlayer, name);

            } else {
                var waitCompleteTriggerCallback = textPlayer.waitEventManager.getWaitCompleteTriggerCallback();
                textPlayer.emit(`wait.${name}`, waitCompleteTriggerCallback);

            }
        }
    };

    var Wait$1 = function (name) {
        // Already in typingPaused state, or ignore any wait
        if (this.ignoreWait) {
            return this;
        }

        this.pauseTyping();
        WaitAny(this.textPlayer, name, this.resumeTyping, this);

        return this;
    };

    var SetIgnoreWait$1 = function (value) {
        if (value === undefined) {
            value = true;
        }
        this.ignoreWait = value;
        return this;
    };

    var SetSkipSpaceEnable = function (enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.skipSpaceEnable = enable;
        return this;
    };

    var SetSkipTypingAnimation = function (value) {
        if (value === undefined) {
            value = true;
        }
        this.skipTypingAnimation = value;

        if (value) {
            // Skip current playing typing-animation
            var timers = this.timeline.getTimers(TypingAnimationTimerType);
            for (var i = 0, cnt = timers.length; i < cnt; i++) {
                timers[i].seek(1);
            }
        }
        return this;
    };

    var SetSkipSoundEffect = function (value) {
        if (value === undefined) {
            value = true;
        }
        this.skipSoundEffect = value;

        if (value) {
            var soundManager = this.textPlayer._soundManager;
            if (soundManager) {
                soundManager.fadeOutAllSoundEffects(100, true);
            }
        }
        return this;
    };

    var SkipCurrentTypingDelay = function () {
        if (this.typingTimer) {
            this.typingTimer.seek(1);
        }
        return this;
    };

    var Methods$g = {
        fadeOutPage: FadeOutPage,
        start: Start$1,
        typing: Typing,
        pause: Pause$1,
        resume: Resume$1,
        pauseTyping: PauseTyping$1,
        resumeTyping: ResumeTyping$1,
        wait: Wait$1,
        setIgnoreWait: SetIgnoreWait$1,
        setSkipSpaceEnable: SetSkipSpaceEnable,
        setSkipTypingAnimation: SetSkipTypingAnimation,
        setSkipSoundEffect: SetSkipSoundEffect,
        skipCurrentTypingDelay: SkipCurrentTypingDelay,
    };

    Object.assign(
        Methods$g,
        TypingSpeedMethods$1
    );

    const GetValue$3g = Phaser.Utils.Objects.GetValue;

    class TypeWriter {
        constructor(textPlayer, config) {
            this.setEventEmitter();
            this.textPlayer = textPlayer;
            this.isPageTyping = false;
            this.typingTimer = undefined;  // Typing delay
            this.pauseTypingTimer = undefined;  // Wait time
            this.inTypingProcessLoop = false;  // Used in this.typing()
            this.isTypingPaused = false;  // Used in this.wait(), this.pauseTyping(), this.resumeTyping()
            this.setIgnoreWait(false);
            this.setSkipTypingAnimation(false);

            this.setTypingStartCallback(GetValue$3g(config, 'onTypingStart', SetChildrenInvisible));
            this.setDefaultTypingSpeed(GetValue$3g(config, 'speed', 250));
            this.setTypingSpeed();
            this.setSkipSpaceEnable(GetValue$3g(config, 'skipSpace', false));
            this.setAnimationConfig(GetValue$3g(config, 'animation', undefined));
            this.setMinSizeEnable(GetValue$3g(config, 'minSizeEnable', false));

            this.setFadeOutPageCallback(GetValue$3g(config, 'fadeOutPage'));

        }

        destroy() {
            this.destroyEventEmitter();

            this.textPlayer = undefined;

            this.typingTimer = undefined;

            this.pauseTypingTimer = undefined;

            this.onTypeStart = undefined;

            this.animationConfig = undefined;
        }

        get timeline() {
            return this.textPlayer.timeline;
        }

        setTypingStartCallback(callback) {
            this.onTypeStart = callback;
            return this;
        }

        setAnimationConfig(config) {
            if (!config) {
                config = {};
            }

            if (!config.hasOwnProperty('duration')) {
                config.duration = 0;
            }

            if (!config.hasOwnProperty('onStart')) {
                // Apply default onStart callback
                config.onStart = SetChildVisible;
            }

            this.animationConfig = config;
            return this;
        }

        setFadeOutPageCallback(callback) {
            this.fadeOutPageCallback = callback;
            return this;
        }

        setMinSizeEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            this.minSizeEnable = enable;
            return this;
        }

        getNextChild() {
            var child = this.nextChild;
            this.index = Math.min(this.index + 1, this.children.length);  // Point to next child
            this._nextChild = undefined;
            return child;
        }

        get nextChild() {
            if (!this._nextChild) {
                this._nextChild = this.children[this.index];
            }
            return this._nextChild;
        }
    }

    var SetChildVisible = function (child) {
        if (child.setVisible) {
            child.setVisible();
        }
    };

    var SetChildrenInvisible = function (children) {
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (child.setVisible) {
                child.setVisible(false);
            }
        }
    };

    Object.assign(
        TypeWriter.prototype,
        EventEmitterMethods$1,
        Methods$g,
    );

    class SpriteBob extends BobBase {
        playAnimation(key) {
            this.gameObject.anims.timeScale = this.timeScale;
            this.gameObject.play(key);
            return this;
        }

        stopAnimation() {
            this.gameObject.stop();
            return this;
        }

        chainAnimation(keys) {
            this.gameObject.chain(keys);
            return this;
        }

        pauseAnimation() {
            this.gameObject.anims.pause();
            return this;
        }

        setTimeScale(timeScale) {
            super.setTimeScale(timeScale);

            if (this.gameObject.anims) {
                this.gameObject.anims.timeScale = timeScale;
            }

            return this;
        }
    }

    var AnimationMethods = {
        playAnimation(name, key) {
            if (!this.has(name)) {
                this.add(name);
            }

            this.get(name).playAnimation(key);
            return this;
        },

        stopAnimation(name) {
            if (!this.has(name)) {
                return this;
            }

            this.get(name).stopAnimation();
            return this;
        },

        chainAnimation(name, keys) {
            if (!this.has(name)) {
                return this;
            }

            this.get(name).chainAnimation(keys);
            return this;
        },

        pauseAnimation(name) {
            if (!this.has(name)) {
                return this;
            }

            this.get(name).pauseAnimation();
            return this;
        },
    };

    var Methods$f = {};
    Object.assign(
        Methods$f,
        AnimationMethods
    );

    var GetCreateGameObjectCallback = function (callback) {
        if (!callback || (callback === 'sprite')) {
            callback = CreateSprite;
        } else if (callback === 'image') {
            callback = CreateImage$1;
        }
        return callback;
    };

    var CreateSprite = function (scene, textureKey, frameName) {
        if ((typeof (frameName) !== 'string') && (typeof (frameName) !== 'number')) {
            frameName = undefined;
        }
        return scene.add.sprite(0, 0, textureKey, frameName);
    };

    var CreateImage$1 = function (scene, textureKey, frameName) {
        if ((typeof (frameName) !== 'string') && (typeof (frameName) !== 'number')) {
            frameName = undefined;
        }
        return scene.add.image(0, 0, textureKey, frameName);
    };

    class SpriteManager extends GOManager {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            config.BobClass = SpriteBob;

            super(scene, config);
        }

        setCreateGameObjectCallback(callback, scope) {
            callback = GetCreateGameObjectCallback(callback);
            super.setCreateGameObjectCallback(callback, scope);
            return this;
        }

    }

    Object.assign(
        SpriteManager.prototype,
        Methods$f
    );

    var IsPlayAnimationTag = function (tags, goType) {
        // goType.name.play
        return (tags.length === 3) && (tags[0] === goType) && (tags[2] === 'play');
    };

    var IsStopAnimationTag = function (tags, goType) {
        // goType.name.stop
        return (tags.length === 3) && (tags[0] === goType) && (tags[2] === 'stop');
    };

    var OnParsePlayAnimationTag = function (textPlayer, parser, config) {
        var goType = config.name;
        parser
            .on('+', function (tag, ...keys) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [goType.name.play=key], or [goType.name.play=key0,key1,...]
                var tags = tag.split('.');
                var name;
                if (IsPlayAnimationTag(tags, goType)) {
                    name = tags[1];
                } else {
                    return;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.play`,       // name
                    PlayAnimation,          // callback
                    [goType, name, keys],   // params
                    textPlayer,             // scope
                );

                parser.skipEvent();
            })
            .on('+', function (tag) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [goType.name.stop]
                var tags = tag.split('.');
                var name;
                if (IsStopAnimationTag(tags, goType)) {
                    name = tags[1];
                } else {
                    return;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.stop`,   // name
                    StopAnimation,      // callback
                    [goType, name],     // params
                    textPlayer,         // scope
                );

                parser.skipEvent();
            })
            .on('-', function (tag) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [/goType.name.play]
                var tags = tag.split('.');
                var name;
                if (IsPlayAnimationTag(tags, goType)) {
                    name = tags[1];
                } else {
                    return;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.stop`,    // name
                    StopAnimation,       // callback
                    [goType, name],      // params
                    textPlayer,          // scope
                );

                parser.skipEvent();
            });
    };

    var PlayAnimation = function (params) {
        var goType, name, keys;
        [goType, name, keys] = params;
        var key = keys.shift();

        // this: textPlayer
        var gameObjectManager = this.getGameObjectManager(goType);
        gameObjectManager.playAnimation(name, key);
        if (keys.length > 0) {
            gameObjectManager.chainAnimation(name, keys);
        }
    };

    var StopAnimation = function (params) {
        var goType, args;
        [goType, ...args] = params;
        // this: textPlayer
        var gameObjectManager = this.getGameObjectManager(goType);
        gameObjectManager.stopAnimation(...args);
    };

    var IsPauseAnimationTag = function (tags, goType) {
        // goType.name.pause 
        return (tags.length === 3) && (tags[0] === goType) && (tags[2] === 'pause');
    };

    var OnParsePauseAnimationTag = function (textPlayer, parser, config) {
        var goType = config.name;
        parser
            .on('+', function (tag) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [goType.name.pause=key]
                var tags = tag.split('.');
                var name;
                if (IsPauseAnimationTag(tags, goType)) {
                    name = tags[1];
                } else {
                    return;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.pause`,  // name
                    PauseAnimation,     // callback
                    [goType, name],     // params
                    textPlayer,         // scope
                );

                parser.skipEvent();
            });
    };

    var PauseAnimation = function (params) {
        var goType, args;
        [goType, ...args] = params;
        // this: textPlayer
        var gameObjectManager = this.getGameObjectManager(goType);
        gameObjectManager.pauseAnimation(...args);
    };

    var IsChainAnimationTag = function (tags, goType) {
        // goType.name.chain 
        return (tags.length === 3) && (tags[0] === goType) && (tags[2] === 'chain');
    };

    var OnParseChainAnimationTag = function (textPlayer, parser, config) {
        var goType = config.name;
        parser
            .on('+', function (tag) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [goType.name.chain=key]
                var tags = tag.split('.');
                var name;
                if (IsChainAnimationTag(tags, goType)) {
                    name = tags[1];
                } else {
                    return;
                }

                var keys = Array.prototype.slice.call(arguments, 1);
                AppendCommand$3.call(textPlayer,
                    `${goType}.chain`,     // name
                    ChainAnimation,        // callback
                    [goType, name, keys],  // params
                    textPlayer,            // scope
                );

                parser.skipEvent();
            });
    };

    var ChainAnimation = function (params) {
        var goType, args;
        [goType, ...args] = params;
        // this: textPlayer
        var gameObjectManager = this.getGameObjectManager(goType);
        gameObjectManager.chainAnimation(...args);
    };

    const ParseCallbacks$1 = [
        OnParsePlayAnimationTag,
        OnParsePauseAnimationTag,
        OnParseChainAnimationTag,
    ];

    var AddSpriteManager = function (config) {
        if (config === undefined) {
            config = {};
        }

        config.name = 'sprite';
        config.parseCallbacks = ParseCallbacks$1;
        config.createGameObject = GetCreateGameObjectCallback(config.createGameObject);

        this.addGameObjectManager(config, SpriteManager);
    };

    var IsAddGameObjectTag = function (tags, goType) {
        // goType.name
        return (tags.length === 2) && (tags[0] === goType)
    };

    var OnParseAddGameObjectTag = function (textPlayer, parser, config) {
        var goType = config.name;
        parser
            .on('+', function (tag, ...args) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [goType.name=key,frame], or [goType.name]
                var tags = tag.split('.');
                var name;
                if (IsAddGameObjectTag(tags, goType)) {
                    name = tags[1];
                } else {
                    return;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.add`,          // name
                    AddGameObject,            // callback
                    [goType, name, ...args],  // params
                    textPlayer,               // scope
                );

                parser.skipEvent();
            })
            .on('-', function (tag) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [/goType.name]
                var tags = tag.split('.');
                var name;
                if (IsAddGameObjectTag(tags, goType)) {
                    name = tags[1];
                } else {
                    return;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.remove`, // name
                    RemoveGameObject,   // callback
                    [goType, name],     // params
                    textPlayer,         // scope
                );

                parser.skipEvent();
            });
    };

    var AddGameObject = function (params) {
        var goType, args;
        [goType, ...args] = params;
        // this: textPlayer
        var gameObjectManager = this.getGameObjectManager(goType);
        gameObjectManager.add(...args);
    };

    var RemoveGameObject = function (params) {
        var goType, args;
        [goType, ...args] = params;
        // this: textPlayer
        var gameObjectManager = this.getGameObjectManager(goType);
        gameObjectManager.remove(...args);
    };

    var OnParseRemoveAllGameObjectsTag = function (textPlayer, parser, config) {
        var goType = config.name;
        parser
            .on('-', function (tag) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [/goType]
                if (tag === goType) ; else {
                    return;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.removeall`,   // name
                    RemoveAllSprites,        // callback
                    goType,                  // params
                    textPlayer,              // scope
                );
                parser.skipEvent();
            });
    };

    var RemoveAllSprites = function (goType) {
        // this: textPlayer
        var gameObjectManager = this.getGameObjectManager(goType);
        gameObjectManager.removeAll();
    };

    var IsPropTag = function (tags, goType) {
        // goType.name.prop
        return (tags.length === 3) && (tags[0] === goType);
    };

    var OnParseCallGameObjectMethodTag = function (textPlayer, parser, config) {
        var goType = config.name;
        parser
            .on(`+`, function (tag, ...parameters) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [goType.name.methodName=value0,value1,value2...]
                // [goType.name.prop=value]
                var tags = tag.split('.');
                var name, prop;
                if (IsPropTag(tags, goType)) {
                    name = tags[1];
                    prop = tags[2];
                } else {
                    return;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.call`,                    // name
                    CallMethod,                          // callback
                    [goType, name, prop, ...parameters], // params
                    textPlayer,                          // scope
                );

                parser.skipEvent();
            });
    };

    var CallMethod = function (params) {
        var goType, name, prop, args;
        [goType, name, prop, ...args] = params;
        // this: textPlayer

        var eventName = `${goType}.${prop}`;
        this.emit(
            eventName,
            name, ...args
        );
        if (this.listenerCount(eventName) > 0) {
            return;
        }

        var gameObjectManager = this.getGameObjectManager(goType);
        if (gameObjectManager.hasMethod(name, prop)) {
            // Is method
            gameObjectManager.call(name, prop, ...args);
        } else {
            // Is property
            gameObjectManager.setProperty(name, prop, args[0]);
        }

    };

    var EaseMode = {
        to: true, yoyo: true, from: true,
        toLeft: true, toRight: true, toUp: true, toDown: true,
        yoyoLeft: true, yoyoRight: true, yoyoUp: true, yoyoDown: true,
        fromLeft: true, fromRight: true, fromUp: true, fromDown: true,
    };
    var IsEasePropertyTag = function (tags, goType) {
        // goType.name.prop.to
        return (tags.length === 4) && (tags[0] === goType) && EaseMode[tags[3]];
    };

    var OnParseEaseGameObjectPropertyTag = function (textPlayer, parser, config) {
        var goType = config.name;
        textPlayer.getGameObjectManager(goType);
        parser
            .on(`+`, function (tag, value, duration, ease, repeat) {
                if (parser.skipEventFlag) {  // Has been processed before
                    return;
                }

                // [goType.name.prop.to=value,duration]
                // [goType.name.prop.to=value,duration,ease,repeat]
                // [goType.name.prop.to=value,duration,repeat]
                var tags = tag.split('.');
                var name, property, easeMode;
                if (IsEasePropertyTag(tags, goType)) {
                    name = tags[1];
                    property = tags[2];
                    easeMode = tags[3];
                } else {
                    return;
                }

                if (typeof (ease) === 'number') {
                    repeat = ease;
                    ease = undefined;
                }

                AppendCommand$3.call(textPlayer,
                    `${goType}.ease`,                    // name
                    EaseProperty,                        // callback
                    [
                        goType,
                        name, property, value,
                        duration, ease, repeat, easeMode
                    ],                                    // params
                    textPlayer,                           // scope
                );

                parser.skipEvent();
            });
    };

    var EaseProperty = function (params) {
        var goType, name, property, value, duration, ease, repeat, easeMode;
        [
            goType,
            name, property, value,
            duration, ease, repeat, easeMode
        ] = params;
        // this: textPlayer
        var gameObjectManager = this.getGameObjectManager(goType);

        var currentValue = gameObjectManager.getProperty(name, property);
        // Only can tween number property
        if (typeof (currentValue) !== 'number') {
            return;
        }

        if (easeMode.endsWith('Left') || easeMode.endsWith('Up')) {
            if (easeMode.startsWith('to') || easeMode.startsWith('yoyo')) {
                value = currentValue - value;
            } else if (easeMode.startsWith('from')) {
                gameObjectManager.setProperty(name, property, (currentValue - value));
                value = currentValue;
            }
        } else if (easeMode.endsWith('Right') || easeMode.endsWith('Down')) {
            if (easeMode.startsWith('to') || easeMode.startsWith('yoyo')) {
                value = currentValue + value;
            } else if (easeMode.startsWith('from')) {
                gameObjectManager.setProperty(name, property, (currentValue + value));
                value = currentValue;
            }
        } else if (easeMode === 'from') {
            gameObjectManager.setProperty(name, property, value);
            value = currentValue;
        }

        var isYoyo = easeMode.startsWith('yoyo');

        gameObjectManager.easeProperty(
            name,
            {
                property: property,
                value: value,
                duration: duration,
                ease: ease,
                repeat: repeat,
                yoyo: isYoyo
            }
        );
    };

    const ParseCallbacks = [
        OnParseAddGameObjectTag, OnParseRemoveAllGameObjectsTag,
        OnParseCallGameObjectMethodTag,
        OnParseEaseGameObjectPropertyTag
    ];

    const AddGameObjectManager = GameObjectManagerMethods$1.addGameObjectManager;

    var GameObjectManagerMethods = {
        addGameObjectManager(config, GameObjectManagerClass) {
            config = (config) ? Clone$2(config) : {};

            var name = config.name;
            if (!name) {
                console.warn(`[TextPlayer] Parameter 'name' is required in addGameObjectManager(config) method`);
            }

            var defaultLayer = config.defaultLayer;
            var createGameObject = config.createGameObject;
            var layerManager = this.layerManager;
            config.createGameObject = function (scene, ...args) {
                var gameObject = createGameObject.call(this, scene, ...args);
                // this: config.createGameObjectScope

                if (defaultLayer && layerManager) {
                    layerManager.addToLayer(defaultLayer, gameObject);
                }

                return gameObject;
            };

            AddGameObjectManager.call(this, config, GameObjectManagerClass);

            // Register parse callbacks
            var customParseCallbacks = config.parseCallbacks;
            if (!customParseCallbacks) {
                customParseCallbacks = ParseCallbacks;
            } else {
                customParseCallbacks = [
                    ...customParseCallbacks, // customParseCallbacks have higher priority
                    ...ParseCallbacks
                ];
            }
            for (var i = 0, cnt = customParseCallbacks.length; i < cnt; i++) {
                customParseCallbacks[i](this, this.parser, config);
            }

            return this;
        },
    };

    var SetClickTarget = function (target) {
        this.waitEventManager.setClickTarget(target);
        return this;
    };

    var SetCameraTarget = function (camera) {
        this.waitEventManager.setCameraTarget(camera);
        return this;
    };

    var SetNextPageInput = function (input) {
        var textPlayer = this;
        if (!input) {
            this.nextPageInput = null;

        } else if (typeof (input) === 'function') {
            this.nextPageInput = function (callback, scope) {
                var waitEventManager = textPlayer.waitEventManager;
                waitEventManager
                    .clearWaitCompleteCallbacks()
                    .addWaitCompleteCallback(callback, scope);

                var waitCompleteTriggerCallback = waitEventManager.getWaitCompleteTriggerCallback();
                input.call(textPlayer, waitCompleteTriggerCallback);
            };

        } else {
            this.nextPageInput = function (callback, scope) {
                WaitAny(textPlayer, input, callback, scope);
            };
        }
    };

    var AddImage = function (key, config) {
        this.imageManager.add(key, config);
        return this;
    };

    var PlayMethods = {
        play(content) {
            if (this.isPlaying) {
                return this;
            }

            this.removeChildren();
            this.parser.start(content); // Parse bbcode-content

            this.isPlaying = true;
            this.once('complete', function () {
                this.isPlaying = false;
            }, this);

            this.lastWrapResult = undefined;
            this.typingNextPage();
            return this;
        },

        playPromise(content) {
            var promise = WaitComplete(this);
            this.play(content);
            return promise;
        }
    };

    var TypingNextPage = function () {
        if (!this.isPlaying || this.isPageTyping) {
            return this;
        }

        this.typeWriter
            .once(PageFadeOutCompleteEvent, _TypingNextPage, this)
            .fadeOutPage();
        return this;
    };

    var _TypingNextPage = function () {
        var result = this.runWrap(this.lastWrapResult);
        this.lastWrapResult = result;

        this.emit('page.start');

        var OnTypingPageComplete = function () {
            this.emit(StopPlayEvent);  // Clear registed StopPlayEvent
            if (result.isLastPage) {
                this.emit('complete');
            } else {
                this.emit('page.complete');

                if (this.ignoreNextPageInput) {
                    TypingNextPage.call(this);
                } else if (this.nextPageInput) {
                    this.nextPageInput(TypingNextPage, this);
                } else ;

            }
        };

        // Remove event when typing pages has been canceled
        this.once(StopPlayEvent, function () {
            this.typeWriter.off('complete', OnTypingPageComplete, this);
        }, this);

        this.typeWriter
            .once('complete', OnTypingPageComplete, this)
            .start(result.children);
    };

    var PauseMethods = {
        pauseTyping() {
            // Pause typing
            this.typeWriter.pauseTyping();

            return this;
        },

        pause() {
            this.pauseTyping();
            
            // Pause typing, typing timer and animation progresses
            this.timeline.pause();

            return this;
        },

    };

    var ResumeMethods = {
        resumeTyping(offsetTime) {
            // Resume typing
            this.typeWriter.resumeTyping(offsetTime);

            return this;
        },

        resume() {
            this.resumeTyping();

            // Resume typing timer, animation progresses and typing
            this.timeline.resume();

            return this;
        },

    };

    var Wait = function (name) {
        this.typeWriter.wait(name);
        return this;
    };

    var TypingSpeedMethods = {
        setDefaultTypingSpeed(speed) {
            this.defaultTypingSpeed = speed;
            return this;
        },

        setTypingSpeed(speed) {
            this.typingSpeed = speed;
            return this;
        }
    };

    var SetIgnoreWait = function (value) {
        this.typeWriter.setIgnoreWait(value);
        return this;
    };

    var SetIgnoreNextPageInput = function (enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.ignoreNextPageInput = enable;
        return this;
    };

    var ShowPage = function () {
        // Only can work after playing, and before processing last child
        if (!this.isPlaying || !this.isPageTyping) {
            return this;
        }

        // Save parameters
        var typingSpeedSave = this.typeWriter.speed;
        var ignoreWaitSave = this.typeWriter.ignoreWait;
        var skipTypingAnimationSave = this.typeWriter.skipTypingAnimation;
        var skipSoundEffectSave = this.typeWriter.skipSoundEffect;

        this.typeWriter
            .once('complete', function () {
                // Recover parameters
                this.typeWriter
                    .setTypingSpeed(typingSpeedSave)
                    .setIgnoreWait(ignoreWaitSave)
                    .setSkipTypingAnimation(skipTypingAnimationSave)
                    .setSkipSoundEffect(skipSoundEffectSave);

            }, this)

            .setTypingSpeed(0)
            .skipCurrentTypingDelay()
            .setIgnoreWait(true)
            .setSkipTypingAnimation(true)
            .setSkipSoundEffect(true);

        return this;
    };

    var SpriteMethods = {
        getSprite(name) {
            return this.getGameObject('sprite', name);
        },

        addSprite(name, gameObject) {
            this.addGameObject('sprite', name, gameObject);
            return this;
        }

    };

    var ContentMethods = {
        setContentOutputEnable(enable) {
            this.parser.setContentOutputEnable(enable);
            return this;
        },

        setContentCallback(callback, scope) {
            this.contentCallback = callback;
            this.contentCallbackScope = scope;
            return this;
        },
    };

    var Methods$e = {
        setClickTarget: SetClickTarget,
        setCameraTarget: SetCameraTarget,
        setNextPageInput: SetNextPageInput,
        addImage: AddImage,
        typingNextPage: TypingNextPage,
        wait: Wait,
        setIgnoreWait: SetIgnoreWait,
        setIgnoreNextPageInput: SetIgnoreNextPageInput,
        showPage: ShowPage,
    };

    Object.assign(
        Methods$e,
        GameObjectManagerMethods,
        PlayMethods,
        PauseMethods,
        ResumeMethods,
        TypingSpeedMethods,
        SpriteMethods,
        ContentMethods,
    );

    var ClearEvents = function (textPlayer) {
        for (var i = 0, cnt = ClearEvents$1.length; i < cnt; i++) {
            textPlayer.emit(ClearEvents$1[i]);
        }
    };

    const IsPlainObject$N = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3f = Phaser.Utils.Objects.GetValue;

    class TextPlayer extends Extend(DynamicText) {
        constructor(scene, x, y, fixedWidth, fixedHeight, config) {
            if (IsPlainObject$N(x)) {
                config = x;
            } else if (IsPlainObject$N(fixedWidth)) {
                config = fixedWidth;
            }
            if (config === undefined) {
                config = {};
            }

            // Don't set text in DynamicText's constructor
            var content = config.text;
            delete config.text;

            super(scene, x, y, fixedWidth, fixedHeight, config);
            this.type = 'rexTextPlayer';

            this.initManagers(scene, config);

            this.parser = new Parser(this, GetValue$3f(config, 'parser', undefined));

            this.typeWriter = new TypeWriter(this, GetValue$3f(config, 'typing', undefined));

            this._imageManager = undefined;
            var imageData = GetValue$3f(config, 'images', undefined);
            if (imageData) {
                this.addImage(imageData);
            }

            var spriteManagerConfig = GetValue$3f(config, 'sprites');
            if ((spriteManagerConfig !== false) && (spriteManagerConfig !== null)) {
                AddSpriteManager.call(this, spriteManagerConfig);
            }

            this.setIgnoreNextPageInput(GetValue$3f(config, 'ignoreNextPageInput', false));
            this.setNextPageInput(GetValue$3f(config, 'nextPageInput', null));

            this.isPlaying = false;

            if (content) {
                this.play(content);
            }
        }

        get imageManager() {
            if (this._imageManager === undefined) {
                this._imageManager = new ImageManager(this.scene);
            }
            return this._imageManager;
        }

        get spriteManager() {
            return this.getGameObjectManager('sprite');
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            ClearEvents(this);

            this.parser.destroy();
            this.parser = undefined;

            this.typeWriter.destroy(fromScene);
            this.typeWriter = undefined;

            if (this._imageManager) {
                this._imageManager.destroy(fromScene);
            }
            this._imageManager = undefined;

            this.destroyManagers(fromScene);

            super.destroy(fromScene);
        }

        get isPageTyping() {
            return this.typeWriter.isPageTyping;
        }

        set defaultTypingSpeed(speed) {
            this.typeWriter.setDefaultTypingSpeed(speed);
        }

        get defaultTypingSpeed() {
            return this.typeWriter.defaultTypingSpeed;
        }

        set typingSpeed(speed) {
            this.typeWriter.setTypingSpeed(speed);
        }

        get typingSpeed() {
            return this.typeWriter.speed;
        }

        set timeScale(value) {
            this.setTimeScale(value);
        }

        get timeScale() {
            return this.getTimeScale();
        }
    }

    Object.assign(
        TextPlayer.prototype,
        Methods$e
    );

    ObjectFactory.register('textPlayer', function (x, y, width, height, config) {
        var gameObject = new TextPlayer(this.scene, x, y, width, height, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TextPlayer', TextPlayer);

    const ElementProperties$1 = {
        maxLength: ['maxLength', undefined],
        minLength: ['minLength', undefined],
        readOnly: ['readOnly', false],
    };

    const StyleProperties$1 = {
        direction: ['direction', undefined]
    };

    var CopyProperty = function (from, to, key) {
        if (typeof (key) === 'string') {
            if (from.hasOwnProperty(key)) {
                to[key] = from[key];
            }
        } else {
            var keys = key;
            if (Array.isArray(keys)) {
                for (var i = 0, cnt = keys.length; i < cnt; i++) {
                    CopyProperty(from, to, keys[i]);
                }
            } else {
                for (var key in keys) {
                    CopyProperty(from, to, key);
                }
            }
        }
    };

    var CopyElementConfig = function (from) {
        if (from === undefined) {
            from = {};
        }
        var to = {};

        CopyProperty(from, to, 'inputType');
        CopyProperty(from, to, 'type');
        CopyProperty(from, to, 'style');
        CopyProperty(from, to, StyleProperties$1);
        CopyProperty(from, to, ElementProperties$1);

        return to;
    };

    var IsPointerInHitArea = function (gameObject, pointer, preTest, postTest, returnFirstPointer) {
        if (pointer) {
            if (preTest && !preTest(gameObject, pointer)) {
                return false;
            }
            if (!HitTest(gameObject, pointer)) {
                return false;
            }
            if (postTest && !postTest(gameObject, pointer)) {
                return false;
            }
            return true;

        } else {
            if (returnFirstPointer === undefined) {
                returnFirstPointer = false;
            }

            var inputManager = gameObject.scene.input.manager;
            var pointersTotal = inputManager.pointersTotal;
            var pointers = inputManager.pointers,
                pointer;
            for (var i = 0; i < pointersTotal; i++) {
                pointer = pointers[i];
                if (preTest && !preTest(gameObject, pointer)) {
                    continue;
                }
                if (!HitTest(gameObject, pointer)) {
                    continue;
                }
                if (postTest && !postTest(gameObject, pointer)) {
                    continue;
                }

                if (returnFirstPointer) {
                    return pointer;
                }

                return true;
            }

            return false;
        }
    };

    var HitTest = function (gameObject, pointer) {
        var scene = gameObject.scene;
        var cameras = scene.input.cameras.getCamerasBelowPointer(pointer);
        var inputManager = scene.input.manager;
        var gameObjects = [gameObject];

        for (var i = 0, len = cameras.length; i < len; i++) {
            inputManager.hitTest(pointer, gameObjects, cameras[i], HitTestResult);
            if (HitTestResult.length > 0) {
                HitTestResult.length = 0;
                return true;
            }
        }

        HitTestResult.length = 0;
        return false;
    };

    var HitTestResult = [];

    var LastOpenedEditor$1 = undefined;

    var SetLastOpenedEditor$1 = function (editor) {
        if (editor === LastOpenedEditor$1) {
            return;
        }

        if (LastOpenedEditor$1 !== undefined) {
            LastOpenedEditor$1.close();
        }

        LastOpenedEditor$1 = editor;
    };

    var CloseLastOpenEditor$1 = function (editor) {
        if (editor !== LastOpenedEditor$1) {
            return;
        }

        // Don't call `LastOpenedEditor.close()`
        LastOpenedEditor$1 = undefined;
    };

    const GetValue$3e = Phaser.Utils.Objects.GetValue;

    var SetProperties = function (properties, config, out) {
        if (out === undefined) {
            out = {};
        }

        var property, value;
        for (var key in properties) {
            property = properties[key];  // [propName, defaultValue]
            value = GetValue$3e(config, key, property[1]);
            if (value !== undefined) {
                out[property[0]] = value;
            }
        }

        return out;
    };

    var StopPropagationTouchEvents = function (element) {
        // Don't propagate touch/mouse events to parent(game canvas)
        element.addEventListener('touchstart', callback, false);
        element.addEventListener('touchmove', callback, false);
        element.addEventListener('touchend', callback, false);
        element.addEventListener('mousedown', callback, false);
        element.addEventListener('mouseup', callback, false);
        element.addEventListener('mousemove', callback, false);
    };

    var callback = function (e) {
        e.stopPropagation();
    };

    var EnterClose = function () {
        this.close();
        this.emit('keydown-ENTER', this.parent, this);
        return this;
    };

    var OnOpen = function () {
        this.isOpened = true;

        this.initText();

        if (this.enterCloseEnable) {
            this.scene.input.keyboard.once('keydown-ENTER', EnterClose, this);
        }

        // There is no cursor-position-change event, 
        // so updating cursor position every tick
        this.scene.sys.events.on('postupdate', this.updateText, this);

        if (this.clickOutSideTarget) {
            MoveMyDepthAbove.call(this.clickOutSideTarget, this.parent);
            MoveMyDepthBelow.call(this.clickOutSideTarget, this.parent);

            this.clickOutSideTarget
                .setInteractive()
                .on('pointerdown', this.onClickOutside, this);

        } else {
            this.scene.input.on('pointerdown', this.onClickOutside, this);
        }

        if (this.onOpenCallback) {
            this.onOpenCallback(this.parent, this);
        }

        this.emit('open', this);
    };

    var RemoveElement = function (element) {
        if (!element) {
            return;
        }

        var parentElement = element.parentElement;
        if (parentElement) {
            parentElement.removeChild(element);
        }
    };

    var OnClose = function () {

        this.isOpened = false;

        this.updateText();

        if (this.enterCloseEnable) {
            this.scene.input.keyboard.off('keydown-ENTER', EnterClose, this);
        }

        this.scene.sys.events.off('postupdate', this.updateText, this);

        if (this.clickOutSideTarget) {
            this.clickOutSideTarget
                .disableInteractive()
                .off('pointerdown', this.onClickOutside, this);

        } else {
            this.scene.input.off('pointerdown', this.onClickOutside, this);

        }

        if (this.onCloseCallback) {
            this.onCloseCallback(this.parent, this);
        }

        // Remove input text element when closing editor
        RemoveElement(this.node);
        this.node = undefined;

        this.emit('close', this);

    };

    const GetValue$3d = Phaser.Utils.Objects.GetValue;

    var CreateElement = function (parent, config) {
        var element;
        var textType = GetValue$3d(config, 'inputType', undefined);
        if (textType === undefined) {
            textType = GetValue$3d(config, 'type', 'text');
        }
        if (textType === 'textarea') {
            element = document.createElement('textarea');
            element.style.resize = 'none';
        } else {
            element = document.createElement('input');
            element.type = textType;
        }

        var style = GetValue$3d(config, 'style', undefined);
        // Apply other style properties
        var elementStyle = element.style;
        SetProperties(StyleProperties$1, style, elementStyle);
        // Set style
        elementStyle.position = 'absolute';
        elementStyle.opacity = 0;
        elementStyle.pointerEvents = 'none';
        elementStyle.zIndex = 0;
        // hide native blue text cursor on iOS
        elementStyle.transform = 'scale(0)';

        SetProperties(ElementProperties$1, config, element);

        // Don't propagate touch/mouse events to parent(game canvas)
        StopPropagationTouchEvents(element);

        // Attach element to fullscreenTarget in full screen mode
        var scaleManager = parent.scene.sys.scale;
        var parentElement = (scaleManager.isFullscreen) ? scaleManager.fullscreenTarget : document.body;
        parentElement.appendChild(element);

        // open() -> 'focus' -> OnOpen
        element.addEventListener('focus', function (e) {
            OnOpen.call(parent);
        });

        // close() -> 'blur' -> OnClose
        element.addEventListener('blur', function (e) {
            OnClose.call(parent);
        });

        return element;
    };

    var Open$2 = function () {
        // Already opened
        if (this.isOpened) {
            return this;
        }
        // Read only
        if (this.readOnly) {
            return this;
        }

        SetLastOpenedEditor$1(this);

        if (!this.node) {
            // Create input text element when opening editor
            this.node = CreateElement(this, this.nodeConfig);
            // Register 'focus', 'blur' events
        }

        this.setFocus();

        // 'focus' event -> OnOpen

        return this;
    };

    var Close$1 = function () {
        // Already closed
        if (!this.isOpened) {
            return this;
        }

        CloseLastOpenEditor$1(this);

        this.setBlur();

        // 'blur' event -> OnOpen

        return this;
    };

    var Methods$d = {
        open: Open$2,
        close: Close$1,
    };

    const GetValue$3c = Phaser.Utils.Objects.GetValue;

    class HiddenTextEditBase extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject);
            // this.parent = gameObject;

            var textType = GetValue$3c(config, 'inputType', undefined);
            if (textType === undefined) {
                textType = GetValue$3c(config, 'type', 'text');
            }

            this.setEnterCloseEnable(GetValue$3c(config, 'enterClose', (textType !== 'textarea')));

            var onOpen = GetValue$3c(config, 'onOpen', undefined);
            if (!onOpen) {
                onOpen = GetValue$3c(config, 'onFocus', undefined);
            }
            this.onOpenCallback = onOpen;

            this.clickOutSideTarget = GetValue$3c(config, 'clickOutSideTarget', undefined);

            var onClose = GetValue$3c(config, 'onClose', undefined);
            if (!onClose) {
                onClose = GetValue$3c(config, 'onBlur', undefined);
            }
            this.onCloseCallback = onClose;

            this.onUpdateCallback = GetValue$3c(config, 'onUpdate', undefined);

            this.isOpened = false;

            gameObject
                .on('pointerdown', function () {
                    this.open();
                }, this)
                .setInteractive();

            this.nodeConfig = CopyElementConfig(config);
            // Create/remove input text element when opening/closing editor
            this.node = undefined;
        }

        destroy() {
            // this.parent.off('pointerdown', this.open, this);

            this.close();

            if (this.clickOutSideTarget) {
                this.clickOutSideTarget.destroy();
            }

            super.destroy();
        }

        onClickOutside(pointer) {
            if (!IsPointerInHitArea(this.parent, pointer)) {
                this.close();
            }
        }

        setEnterCloseEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.enterCloseEnable = enable;
            return this;
        }

        // Override
        initText() {
        }

        // Override, invoking under 'postupdate' event of scene
        updateText() {
        }

        // Copy from InputText class
        get text() {
            if (!this.node) {
                return '';
            }
            return this.node.value;
        }

        set text(value) {
            if (!this.node) {
                return;
            }
            this.node.value = value;
        }

        setText(value) { // Override
            this.text = value;
            return this;
        }

        get maxLength() {
            return this.nodeConfig.maxLength;
        }

        set maxLength(value) {
            this.nodeConfig.maxLength = value;

            if (this.node) {
                this.node.maxLength = value;
            }
        }

        setMaxLength(value) {
            this.maxLength = value;
            return this;
        }

        get minLength() {
            return this.nodeConfig.minLength;
        }

        set minLength(value) {
            this.nodeConfig.minLength = value;

            if (this.node) {
                this.node.minLength = value;
            }
        }

        setMinLength(value) {
            this.minLength = value;
            return this;
        }

        get placeholder() {
            return this.node.placeholder;
        }

        set placeholder(value) {
            if (!this.node) {
                return;
            }
            this.node.placeholder = value;
        }

        setPlaceholder(value) {
            this.placeholder = value;
            return this;
        }

        selectText(selectionStart, selectionEnd) {
            if (!this.node) {
                return this;
            }
            if (selectionStart === undefined) {
                this.node.select();
            } else {
                this.node.setSelectionRange(selectionStart, selectionEnd);
            }
            return this;
        }

        selectAll() {
            this.selectText();
            return this;
        }

        get selectionStart() {
            if (!this.node) {
                return 0;
            }
            return this.node.selectionStart;
        }

        get selectionEnd() {
            if (!this.node) {
                return 0;
            }
            return this.node.selectionEnd;
        }

        get selectedText() {
            if (!this.node) {
                return '';
            }
            var node = this.node;
            return node.value.substring(node.selectionStart, node.selectionEnd);
        }

        get cursorPosition() {
            if (!this.node) {
                return 0;
            }
            return this.node.selectionStart;
        }

        set cursorPosition(value) {
            if (!this.node) {
                return;
            }
            this.node.setSelectionRange(value, value);
        }

        setCursorPosition(value) {
            if (value === undefined) {
                value = this.text.length;
            } else if (value < 0) {
                value = this.text.length + value;
            }

            this.cursorPosition = value;
            return this;
        }

        get tooltip() {
            if (!this.node) {
                return '';
            }
            return this.node.title;
        }

        set tooltip(value) {
            if (!this.node) {
                return this;
            }
            this.node.title = value;
        }

        setTooltip(value) {
            this.tooltip = value;
            return this;
        }

        setTextChangedCallback(callback) {
            this.onTextChanged = callback;
            return this;
        }

        get readOnly() {
            return this.nodeConfig.readOnly;
        }

        set readOnly(value) {
            this.nodeConfig.readOnly = value;

            if (this.node) {
                this.node.readOnly = value;
            }
        }

        setReadOnly(value) {
            if (value === undefined) {
                value = true;
            }
            this.readOnly = value;
            return this;
        }

        get spellCheck() {
            if (!this.node) {
                return '';
            }
            return this.node.spellcheck;
        }

        set spellCheck(value) {
            if (!this.node) {
                return;
            }
            this.node.spellcheck = value;
        }

        setSpellCheck(value) {
            this.spellCheck = value;
            return this;
        }

        get fontColor() {
            if (!this.node) {
                return undefined;
            }
            return this.node.style.color;
        }

        set fontColor(value) {
            if (!this.node) {
                return;
            }
            this.node.style.color = value;
        }

        setFontColor(value) {
            this.fontColor = value;
            return this;
        }

        setStyle(key, value) {
            if (!this.node) {
                return this;
            }
            this.node.style[key] = value;
            return this;
        }

        getStyle(key) {
            if (!this.node) {
                return undefined;
            }
            return this.node.style[key];
        }

        scrollToBottom() {
            if (!this.node) {
                return this;
            }
            this.node.scrollTop = this.node.scrollHeight;
            return this;
        }

        setEnabled(enabled) {
            if (!this.node) {
                return this;
            }
            if (enabled === undefined) {
                enabled = true;
            }
            this.node.disabled = !enabled;
            return this;
        }

        setBlur() {
            if (!this.node) {
                return this;
            }
            this.node.blur();
            return this;
        }

        setFocus() {
            if (!this.node) {
                return this;
            }
            this.node.focus();
            return this;
        }

        get isFocused() {
            return this.isOpened;
        }
    }

    Object.assign(
        HiddenTextEditBase.prototype,
        Methods$d,
    );

    var NumberInputUpdateCallback = function (text, textObject, hiddenInputText) {
        text = text.replace(' ', '');
        var previousText = hiddenInputText.previousText;
        if (text === previousText) {
            return text;
        }

        if (isNaN(text)) {
            // Enter a NaN character, back to previous text
            hiddenInputText.emit('nan', text, hiddenInputText);

            text = previousText;
            var cursorPosition = hiddenInputText.cursorPosition - 1;
            hiddenInputText.setText(text);
            hiddenInputText.setCursorPosition(cursorPosition);
        } else {
            // New number text, update previous texr
            hiddenInputText.previousText = text;
        }

        return text;
    };

    var SelectRange = function (hiddenTextEdit) {
        var textObject = hiddenTextEdit.parent;
        // var text = textObject.text;
        var selectionStart = (hiddenTextEdit.isOpened) ? hiddenTextEdit.selectionStart : null;
        var selectionEnd = (hiddenTextEdit.isOpened) ? hiddenTextEdit.selectionEnd : null;
        var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
        var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;

        if ((prevSelectionStart === selectionStart) && (prevSelectionEnd === selectionEnd)) {
            return;
        }

        var min, max;
        if (prevSelectionStart === null) {
            min = selectionStart;
            max = selectionEnd;
        } else if (selectionStart === null) {
            min = prevSelectionStart;
            max = prevSelectionEnd;
        } else {
            min = Math.min(prevSelectionStart, selectionStart);
            max = Math.max(prevSelectionEnd, selectionEnd);
        }

        for (var i = min; i < max; i++) {
            var inPrevSelectionRange;
            if (prevSelectionStart === null) {
                inPrevSelectionRange = false;
            } else {
                inPrevSelectionRange = (i >= prevSelectionStart) && (i < prevSelectionEnd);
            }

            var inSelectionRange;
            if (selectionStart === null) {
                inSelectionRange = false;
            } else {
                inSelectionRange = (i >= selectionStart) && (i < selectionEnd);
            }

            if (inPrevSelectionRange === inSelectionRange) {
                continue;
            }

            var child = textObject.getCharChild(i);
            if (child) {
                var eventName = (inPrevSelectionRange) ? 'rangeout' : 'rangein';
                textObject.emit(eventName, child, i, textObject);
            }
        }

        hiddenTextEdit.prevSelectionStart = selectionStart;
        hiddenTextEdit.prevSelectionEnd = selectionEnd;
    };

    var ScrollToBob = function (bob) {
        var textObject = bob.parent;
        var textObjectLeftX = 0,
            textObjectRightX = textObject.width,
            textObjectTopY = 0,
            textObjectBottomY = textObject.height;

        var childX = bob.drawX,
            childY = bob.drawY;
        var childLeftX = childX + bob.drawTLX,
            childRightX = childX + bob.drawTRX,
            childTopY = childY + bob.drawTLY,
            childBottomY = childY + bob.drawBLY;

        var dx;
        if (childLeftX < textObjectLeftX) {
            dx = textObjectLeftX - childLeftX;
        } else if (childRightX > textObjectRightX) {
            dx = textObjectRightX - childRightX;
        } else {
            dx = 0;
        }

        var dy;
        if (childTopY < textObjectTopY) {
            dy = textObjectTopY - childTopY;
        } else if (childBottomY > textObjectBottomY) {
            dy = textObjectBottomY - childBottomY;
        } else {
            dy = 0;
        }

        textObject._textOX += dx;
        textObject._textOY += dy;

    };

    var MoveCursor = function (hiddenTextEdit) {
        var textObject = hiddenTextEdit.parent;
        var text = textObject.text;

        if (hiddenTextEdit.requestCursorPosition !== null) {
            hiddenTextEdit.setCursorPosition(hiddenTextEdit.requestCursorPosition);
            hiddenTextEdit.requestCursorPosition = null;
        }

        var cursorPosition = hiddenTextEdit.cursorPosition;
        if (hiddenTextEdit.prevCursorPosition === cursorPosition) {
            return;
        }

        if (hiddenTextEdit.prevCursorPosition !== null) {
            if (hiddenTextEdit.prevCursorPosition > text.length) {
                hiddenTextEdit.prevCursorPosition = null;
            }
        }

        if (hiddenTextEdit.prevCursorPosition !== null) {
            var child = textObject.getCharChild(hiddenTextEdit.prevCursorPosition);
            if (child) {
                // Rollback size of new line child
                if (child.text === '\n') {
                    child.clearTextSize();
                }
                textObject.emit('cursorout', child, hiddenTextEdit.prevCursorPosition, textObject);
            }
        }
        if (cursorPosition != null) {
            var child = textObject.getCharChild(cursorPosition);
            if (child) {
                // Display new line child
                if (child.text === '\n') {
                    child.copyTextSize(textObject.lastInsertCursor);
                }

                ScrollToBob(child);

                textObject.emit('cursorin', child, cursorPosition, textObject);
            }
        }
        textObject.emit('movecursor', cursorPosition, hiddenTextEdit.prevCursorPosition, textObject);

        hiddenTextEdit.prevCursorPosition = cursorPosition;
    };

    var ClearSelectRange = function (hiddenTextEdit) {
        var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
        if (prevSelectionStart === null) {
            return;
        }

        var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;

        var textObject = hiddenTextEdit.parent;
        for (var i = prevSelectionStart; i < prevSelectionEnd; i++) {
            var child = textObject.getCharChild(i);
            if (child) {
                textObject.emit('cursorout', child, i, textObject);
            }
        }

        hiddenTextEdit.prevSelectionStart = null;
        hiddenTextEdit.prevSelectionEnd = null;
    };

    var ClearCursor = function (hiddenTextEdit) {
        var prevCursorPosition = hiddenTextEdit.prevCursorPosition;
        if (prevCursorPosition === null) {
            return;
        }

        var textObject = hiddenTextEdit.parent;

        var child = textObject.getCharChild(prevCursorPosition);
        if (child) {
            textObject.emit('cursorout', child, prevCursorPosition, textObject);
        }

        hiddenTextEdit.prevCursorPosition = null;
    };

    const GetValue$3b = Phaser.Utils.Objects.GetValue;

    let HiddenTextEdit$1 = class HiddenTextEdit extends HiddenTextEditBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            this.setSelectAllWhenFocusEnable(GetValue$3b(config, 'selectAll', false));

            this.cursorMoveStartIndex = null;
            this.prevCursorPosition = null;
            this.prevSelectionStart = null;
            this.prevSelectionEnd = null;
            this.firstClickAfterOpen = false;
            this.requestCursorPosition = null;


            gameObject
                // Open editor by 'pointerdown' event
                // Then set cursor position to nearest char
                .on('pointerdown', function (pointer, localX, localY, event) {
                    var child = gameObject.getNearestChild(localX, localY);
                    var charIndex = gameObject.getCharIndex(child);

                    if (!this.selectAllWhenFocus || !this.firstClickAfterOpen) {
                        this.setCursorPosition(charIndex);
                    }

                    this.cursorMoveStartIndex = charIndex;
                    this.firstClickAfterOpen = false;
                }, this)
                .on('pointermove', function (pointer, localX, localY, event) {
                    if (!pointer.isDown) {
                        return;
                    }
                    var child = gameObject.getNearestChild(localX, localY);
                    var charIndex = gameObject.getCharIndex(child);
                    if (this.cursorMoveStartIndex < charIndex) {
                        this.selectText(this.cursorMoveStartIndex, charIndex + 1);
                    } else {
                        this.selectText(charIndex, this.cursorMoveStartIndex + 1);
                    }
                }, this);

            this
                .on('open', function () {
                    if (this.selectAllWhenFocus) {
                        this.selectAll();
                    }
                    this.firstClickAfterOpen = true;

                    gameObject.emit('open');
                }, this)
                .on('close', function () {
                    // Route 'close' event
                    gameObject.emit('close');
                })
                .on('keydown-ENTER', function () {
                    // Route 'keydown-ENTER' event
                    gameObject.emit('keydown-ENTER');
                });

        }

        initText() {
            var textObject = this.parent;
            this.prevCursorPosition = null;
            this.setText(textObject.text);
            return this;
        }

        updateText() {
            var textObject = this.parent;

            var text = this.text;
            if (this.onUpdateCallback) {
                var newText = this.onUpdateCallback(text, textObject, this);
                if (newText != null) {
                    text = newText;
                }
            }

            if (textObject.text !== text) {
                textObject.setText(text);
            }

            if (this.isOpened) {
                if (this.selectionStart !== this.selectionEnd) {
                    ClearCursor(this);
                    SelectRange(this);
                } else {
                    ClearSelectRange(this);
                    MoveCursor(this);
                }
            } else {
                ClearSelectRange(this);
                ClearCursor(this);
            }

            return this;
        }

        setNumberInput() {
            this.onUpdateCallback = NumberInputUpdateCallback;
            return this;
        }

        setSelectAllWhenFocusEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            this.selectAllWhenFocus = enable;
            return this;
        }

        setRequestCursorPosition(value) {
            if (!this.isOpened) {
                return this;
            }

            this.requestCursorPosition = value;
            return this;
        }
    };

    const GetValue$3a = Phaser.Utils.Objects.GetValue;
    const PropertiesList = [
        'inputType',
        'onOpen', 'clickOutSideTarget', 'onFocus', 'onClose', 'onBlur', 'onUpdate',
        'enterClose',
        'readOnly', 'maxLength', 'minLength', 'selectAll'
    ];

    var CreateHiddenTextEdit = function (parent, parentConfig) {
        var config = GetValue$3a(parentConfig, 'edit');
        if (config === undefined) {
            config = {};
        }

        CopyProperty(parentConfig, config, PropertiesList);

        return new HiddenTextEdit$1(parent, config);
    };

    var HasValue = function (source, key) {
        if (!source || typeof source === 'number') {
            return false;
        }
        else if (source.hasOwnProperty(key)) {
            return true;
        }
        else if (key.indexOf('.') !== -1) {
            var keys = key.split('.');
            var parent = source;

            //  Use for loop here so we can break early
            for (var i = 0; i < keys.length; i++) {
                if (parent.hasOwnProperty(keys[i])) {
                    parent = parent[keys[i]];
                }
                else {
                    //  Can't go any further
                    return false;
                }
            }

            return true;
        }
        else {
            return false;
        }
    };

    var GetRootGameObject = function (gameObject) {
        if (gameObject.parentContainer) {  // At a container
            return GetRootGameObject(gameObject.parentContainer);
        }

        var layer = GetLayer(gameObject);
        if (layer) {  // At a layer
            return GetRootGameObject(layer);
        }

        return gameObject;
    };

    var GetFirstRenderCamera = function (gameObject) {
        var cameraFilter = GetRootGameObject(gameObject).cameraFilter;
        var cameras = gameObject.scene.sys.cameras.cameras;
        var camera, isCameraIgnore;
        for (var i = 0, cnt = cameras.length; i < cnt; i++) {
            camera = cameras[i];

            isCameraIgnore = (cameraFilter & camera.id) > 0;
            if (!isCameraIgnore) {
                return camera;
            }
        }

        return null;
    };

    class FullWindow extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject);
            // this.parent = gameObject;

            this.targetCamera = undefined;
            this.boot();
        }

        boot() {
            this.scene.sys.events.on('prerender', this.resize, this);
        }

        destroy() {
            if (!this.scene) {
                return;
            }

            this.scene.sys.events.off('prerender', this.resize, this);

            super.destroy();
        }


        resize() {
            var scene = this.scene;
            var gameObject = this.parent;

            var camera = GetFirstRenderCamera(gameObject);
            if (!camera) {
                return;
            }

            gameObject
                .setScrollFactor(0)
                .setOrigin(0.5);

            var gameSize = scene.sys.scale.gameSize;
            var gameWidth = gameSize.width,
                gameHeight = gameSize.height,
                scale = 1 / camera.zoom;

            // Origin is fixed to (0.5,0.5)
            var x = gameWidth / 2,
                y = gameHeight / 2;

            var width = gameWidth * scale,
                height = gameHeight * scale;

            if ((gameObject.x !== x) || (gameObject.y !== y)) {
                gameObject.setPosition(x, y);
            }

            if ((gameObject.width !== width) || (gameObject.height !== height)) {
                gameObject.setSize(width, height);
            }

        }


    }

    const Zone$2 = Phaser.GameObjects.Zone;

    let FullWindowRectangle$1 = class FullWindowRectangle extends Zone$2 {
        constructor(scene) {
            super(scene, 0, 0, 2, 2);

            this.fullWindow = new FullWindow(this);
        }
    };

    var InjectDefaultConfig = function (scene, config) {
        var isSingleLineMode = !config.textArea;

        if (!HasValue(config, 'wrap.vAlign')) {
            var defaultValue = (isSingleLineMode) ? 'center' : 'top';
            SetValue(config, 'wrap.vAlign', defaultValue);
        }

        if (!HasValue(config, 'wrap.wrapMode')) {
            SetValue(config, 'wrap.wrapMode', 'char');
        }

        if (!HasValue(config, 'wrap.maxLines')) {
            var defaultValue = (isSingleLineMode) ? 1 : undefined;
            SetValue(config, 'wrap.maxLines', defaultValue);
        }

        if (isSingleLineMode) {
            SetValue(config, 'wrap.wrapWidth', Infinity);
        }

        if (!HasValue(config, 'wrap.useDefaultTextHeight')) {
            SetValue(config, 'wrap.useDefaultTextHeight', true);
        }

        if (!config.edit) {
            config.edit = {};
        }
        if (!HasValue(config.edit, 'inputType')) {
            var defaultValue = (isSingleLineMode) ? 'text' : 'textarea';
            SetValue(config.edit, 'inputType', defaultValue);
        }

        if (config.clickOutSideTarget === true) {
            var clickOutSideTarget = new FullWindowRectangle$1(scene);
            scene.add.existing(clickOutSideTarget);

            config.clickOutSideTarget = clickOutSideTarget;
        }

        return config;
    };

    var ExtractByPrefix = function (obj, prefix, delimiter, out) {
        if (delimiter === undefined) {
            delimiter = '.';
        }

        if (out === undefined) {
            out = {};
        }

        if (!obj) {
            return out;
        }

        if (prefix in obj) {
            return Object.assign(out, obj[prefix])
        }

        prefix += delimiter;

        for (var key in obj) {
            if (!key.startsWith(prefix)) {
                continue;
            }

            out[key.replace(prefix, '')] = obj[key];
        }

        return out;
    };

    var RegisterArrowKeysEvent = function () {
        var keyEventManager = this.scene.input.keyboard;
        this.textEdit
            .on('open', function () {
                keyEventManager
                    .on('keydown-UP', this.cursorMoveUp, this)
                    .on('keydown-DOWN', this.cursorMoveDown, this);
            }, this)
            .on('close', function () {
                keyEventManager
                    .off('keydown-UP', this.cursorMoveUp, this)
                    .off('keydown-DOWN', this.cursorMoveDown, this);
            }, this);

    };

    var GetPartialData = function (obj, keys, out) {
        if (out === undefined) {
            out = {};
        }

        if (Array.isArray(keys)) {
            var key;
            for (var i = 0, cnt = keys.length; i < cnt; i++) {
                key = keys[i];
                out[key] = obj[key];
            }
        } else {
            for (var key in keys) {
                out[key] = obj[key];
            }
        }

        return out;
    };

    var IsKeyValueEqual = function (objA, objB) {
        for (var key in objA) {
            if (!(key in objB)) {
                return false;
            }

            if (objA[key] !== objB[key]) {
                return false;
            }
        }

        for (var key in objB) {
            if (!(key in objA)) {
                return false;
            }
        }

        return true;
    };

    var RegisterCursorStyle = function (cursorStyle) {
        if (IsEmpty(cursorStyle)) {
            return;
        }

        this
            .setCursorStyle(cursorStyle)
            .on('cursorin', function (child) {
                var cursorStyle = this.cursorStyle;
                var styleSave = GetPartialData(child.style, cursorStyle);
                if (IsKeyValueEqual(cursorStyle, styleSave)) {
                    return;
                }

                child.styleSave = styleSave;
                child.modifyStyle(cursorStyle);
            }, this)
            .on('cursorout', function (child) {
                if (!child.styleSave) {
                    return;
                }

                child.modifyStyle(child.styleSave);
                child.styleSave = undefined;
            }, this);
    };

    var RegisterRangeStyle = function (rangeStyle) {
        if (IsEmpty(rangeStyle)) {
            return;
        }

        this
            .setRangeStyle(rangeStyle)
            .on('rangein', function (child) {
                var rangeStyle = this.rangeStyle;
                var styleSave = GetPartialData(child.style, rangeStyle);
                if (IsKeyValueEqual(rangeStyle, styleSave)) {
                    return;
                }

                child.styleSave = styleSave;
                child.modifyStyle(rangeStyle);
            }, this)
            .on('rangeout', function (child) {
                if (!child.styleSave) {
                    return;
                }

                child.modifyStyle(child.styleSave);
                child.styleSave = undefined;
            }, this);
    };

    var RegisterFocusStyle = function (focusStyle) {
        if (IsEmpty(focusStyle)) {
            return;
        }

        this
            .setFocusStyle(focusStyle)
            .on('open', function () {
                var child = this.background;
                var focusStyle = this.focusStyle;
                var styleSave = GetPartialData(child, focusStyle);
                if (IsKeyValueEqual(focusStyle, styleSave)) {
                    return;
                }

                child.styleSave = styleSave;
                child.modifyStyle(focusStyle);
            }, this)
            .on('close', function () {
                var child = this.background;

                if (!child.styleSave) {
                    return;
                }

                child.modifyStyle(child.styleSave);
                child.styleSave = undefined;
            }, this);
    };

    var CreateInsertCursorChild = function (textObject) {
        var child = textObject.createCharChild('|');  // Use '|' to update render size
        child.text = '';  // Render empty string ''

        return child;
    };

    function Diff() {}

    Diff.prototype = {
      diff(oldString, newString, options = {}) {
        let callback = options.callback;
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        this.options = options;

        let self = this;

        function done(value) {
          if (callback) {
            setTimeout(function() { callback(undefined, value); }, 0);
            return true;
          } else {
            return value;
          }
        }

        // Allow subclasses to massage the input prior to running
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);

        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));

        let newLen = newString.length, oldLen = oldString.length;
        let editLength = 1;
        let maxEditLength = newLen + oldLen;
        if(options.maxEditLength) {
          maxEditLength = Math.min(maxEditLength, options.maxEditLength);
        }

        let bestPath = [{ newPos: -1, components: [] }];

        // Seed editLength = 0, i.e. the content starts with the same values
        let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          // Identity per the equality and tokenizer
          return done([{value: this.join(newString), count: newString.length}]);
        }

        // Main worker method. checks all permutations of a given edit length for acceptance.
        function execEditLength() {
          for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            let basePath;
            let addPath = bestPath[diagonalPath - 1],
                removePath = bestPath[diagonalPath + 1],
                oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              // No one else is going to attempt to use this value, clear it
              bestPath[diagonalPath - 1] = undefined;
            }

            let canAdd = addPath && addPath.newPos + 1 < newLen,
                canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
            if (!canAdd && !canRemove) {
              // If this path is a terminal then prune
              bestPath[diagonalPath] = undefined;
              continue;
            }

            // Select the diagonal that we want to branch from. We select the prior
            // path whose position in the new string is the farthest from the origin
            // and does not pass the bounds of the diff graph
            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
              basePath = clonePath(removePath);
              self.pushComponent(basePath.components, undefined, true);
            } else {
              basePath = addPath; // No need to clone, we've pulled it from the list
              basePath.newPos++;
              self.pushComponent(basePath.components, true, undefined);
            }

            oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

            // If we have hit the end of both strings, then we are done
            if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
              return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
            } else {
              // Otherwise track this path as a potential candidate and continue.
              bestPath[diagonalPath] = basePath;
            }
          }

          editLength++;
        }

        // Performs the length of edit iteration. Is a bit fugly as this has to support the
        // sync and async mode which is never fun. Loops over execEditLength until a value
        // is produced, or until the edit length exceeds options.maxEditLength (if given),
        // in which case it will return undefined.
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) {
                return callback();
              }

              if (!execEditLength()) {
                exec();
              }
            }, 0);
          }());
        } else {
          while (editLength <= maxEditLength) {
            let ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },

      pushComponent(components, added, removed) {
        let last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          // We need to clone here as the component clone operation is just
          // as shallow array clone
          components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };
        } else {
          components.push({count: 1, added: added, removed: removed });
        }
      },
      extractCommon(basePath, newString, oldString, diagonalPath) {
        let newLen = newString.length,
            oldLen = oldString.length,
            newPos = basePath.newPos,
            oldPos = newPos - diagonalPath,

            commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }

        if (commonCount) {
          basePath.components.push({count: commonCount});
        }

        basePath.newPos = newPos;
        return oldPos;
      },

      equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right
            || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());
        }
      },
      removeEmpty(array) {
        let ret = [];
        for (let i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      castInput(value) {
        return value;
      },
      tokenize(value) {
        return value.split('');
      },
      join(chars) {
        return chars.join('');
      }
    };

    function buildValues(diff, components, newString, oldString, useLongestToken) {
      let componentPos = 0,
          componentLen = components.length,
          newPos = 0,
          oldPos = 0;

      for (; componentPos < componentLen; componentPos++) {
        let component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            let value = newString.slice(newPos, newPos + component.count);
            value = value.map(function(value, i) {
              let oldValue = oldString[oldPos + i];
              return oldValue.length > value.length ? oldValue : value;
            });

            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;

          // Common case
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;

          // Reverse add and remove so removes are output first to match common convention
          // The diffing algorithm is tied to add then remove output and this is the simplest
          // route to get the desired output with minimal overhead.
          if (componentPos && components[componentPos - 1].added) {
            let tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }

      // Special case handle for when one terminal is ignored (i.e. whitespace).
      // For this case we merge the terminal into the prior string and drop the change.
      // This is only available for string mode.
      let lastComponent = components[componentLen - 1];
      if (componentLen > 1
          && typeof lastComponent.value === 'string'
          && (lastComponent.added || lastComponent.removed)
          && diff.equals('', lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }

      return components;
    }

    function clonePath(path) {
      return { newPos: path.newPos, components: path.components.slice(0) };
    }

    const characterDiff = new Diff();
    function diffChars(oldStr, newStr, options) { return characterDiff.diff(oldStr, newStr, options); }

    // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
    //
    // Ranges and exceptions:
    // Latin-1 Supplement, 0080–00FF
    //  - U+00D7  × Multiplication sign
    //  - U+00F7  ÷ Division sign
    // Latin Extended-A, 0100–017F
    // Latin Extended-B, 0180–024F
    // IPA Extensions, 0250–02AF
    // Spacing Modifier Letters, 02B0–02FF
    //  - U+02C7  ˇ &#711;  Caron
    //  - U+02D8  ˘ &#728;  Breve
    //  - U+02D9  ˙ &#729;  Dot Above
    //  - U+02DA  ˚ &#730;  Ring Above
    //  - U+02DB  ˛ &#731;  Ogonek
    //  - U+02DC  ˜ &#732;  Small Tilde
    //  - U+02DD  ˝ &#733;  Double Acute Accent
    // Latin Extended Additional, 1E00–1EFF
    const extendedWordChars = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;

    const reWhitespace = /\S/;

    const wordDiff = new Diff();
    wordDiff.equals = function(left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }
      return left === right || (this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));
    };
    wordDiff.tokenize = function(value) {
      // All whitespace symbols except newline group into one token, each newline - in separate token
      let tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);

      // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
      for (let i = 0; i < tokens.length - 1; i++) {
        // If we have an empty string in the next field and we have only word chars before and after, merge
        if (!tokens[i + 1] && tokens[i + 2]
              && extendedWordChars.test(tokens[i])
              && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }

      return tokens;
    };

    const lineDiff = new Diff();
    lineDiff.tokenize = function(value) {
      let retLines = [],
          linesAndNewlines = value.split(/(\n|\r\n)/);

      // Ignore the final empty token that occurs if the string ends with a new line
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }

      // Merge the content and line separators into single tokens
      for (let i = 0; i < linesAndNewlines.length; i++) {
        let line = linesAndNewlines[i];

        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }
          retLines.push(line);
        }
      }

      return retLines;
    };

    const sentenceDiff = new Diff();
    sentenceDiff.tokenize = function(value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };

    const cssDiff = new Diff();
    cssDiff.tokenize = function(value) {
      return value.split(/([{}:;,]|\s+)/);
    };

    const objectPrototypeToString = Object.prototype.toString;


    const jsonDiff = new Diff();
    // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
    // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
    jsonDiff.useLongestToken = true;

    jsonDiff.tokenize = lineDiff.tokenize;
    jsonDiff.castInput = function(value) {
      const {undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v} = this.options;

      return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
    };
    jsonDiff.equals = function(left, right) {
      return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
    };

    // This function handles the presence of circular references by bailing out when encountering an
    // object that is already on the "stack" of items being processed. Accepts an optional replacer
    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];

      if (replacer) {
        obj = replacer(key, obj);
      }

      let i;

      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }

      let canonicalizedObj;

      if ('[object Array]' === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }

      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }

      if (typeof obj === 'object' && obj !== null) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        let sortedKeys = [],
            key;
        for (key in obj) {
          /* istanbul ignore else */
          if (obj.hasOwnProperty(key)) {
            sortedKeys.push(key);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          key = sortedKeys[i];
          canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }

    const arrayDiff = new Diff();
    arrayDiff.tokenize = function(value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function(value) {
      return value;
    };

    const RemoveItem$8 = Phaser.Utils.Array.Remove;

    var SetText$1 = function (textObject, newText) {
        var text = textObject.text;
        if (newText === text) {
            return;
        }

        if (text == null) {
            text = '';
        }

        // textObject.setText(newText);

        // Remove lastInsertCursor directly 
        RemoveItem$8(textObject.children, textObject.lastInsertCursor);

        if (newText === '') {
            textObject.removeChildren();
        } else {
            var results = diffChars(text, newText);
            var charIndex = 0;
            for (var i = 0, cnt = results.length; i < cnt; i++) {
                var result = results[i];
                if (result.removed) {
                    // Remove character at charIndex
                    textObject.removeText(charIndex, result.count);
                } else if (result.added) {
                    textObject.insertText(charIndex, result.value);
                    charIndex += result.count;
                } else {
                    charIndex += result.count;
                }
            }
        }

        // Push back lastInsertCursor directly
        textObject.children.push(textObject.lastInsertCursor);

        textObject.runWrap();

        if (textObject.isOpened) {
            textObject.textEdit.setText(newText);
        }

        textObject.emit('textchange', newText, textObject);

    };

    var SetTextOXYMethods = {
        setTextOYByPercentage(percentage) {
            this.setTextOY(-this.textVisibleHeight * percentage);
            return this;
        },

        getTextOYPercentage() {
            var textVisibleHeight = this.textVisibleHeight;
            if (textVisibleHeight === 0) {
                return 0;
            }
            return (this._textOY / -textVisibleHeight);
        },

        setTextOXByPercentage(percentage) {
            this.setTextOX(-this.textVisibleWidth * percentage);
            return this;
        },

        getTextOXPercentage() {
            var textVisibleWidth = this.textVisibleWidth;
            if (textVisibleWidth === 0) {
                return 0;
            }
            return (this._textOX / -textVisibleWidth);
        }

    };

    const Clamp$e = Phaser.Math.Clamp;

    var GetIndex = function (characterCountOfLines, position) {
        var result = { lineIndex: 0, position: 0 };

        if (position < 0) {
            return result;
        }

        for (var li = 0, lcnt = characterCountOfLines.length; li < lcnt; li++) {
            var characterCount = characterCountOfLines[li];
            if (position <= characterCount) {
                result.lineIndex = li;
                break;
            }
            position -= characterCount;
        }
        result.position = position;

        return result;
    };

    var GetPosition = function (characterCountOfLines, index) {
        var position = 0;
        var lineIndex = index.lineIndex;
        if (lineIndex < 0) {
            return position;
        }

        for (var li = 0, lcnt = characterCountOfLines.length; li < lcnt; li++) {
            var characterCount = characterCountOfLines[li];
            if (lineIndex > li) {
                position += characterCount;
            } else if (lineIndex === li) {
                position += Math.min(index.position, characterCount);
            } else {
                break;
            }
        }

        return position;
    };

    var MoveCursorMethods = {
        cursorMoveLeft() {
            if (!this.isOpened) {
                return this;
            }

            // Move cursor to previous character
            var position = Clamp$e(this.cursorPosition - 1, 0, this.inputText.length);
            this.setCursorPosition(position);

            return this;
        },

        cursorMoveRight() {
            if (!this.isOpened) {
                return this;
            }

            // Move cursor to next character
            var position = Clamp$e(this.cursorPosition + 1, 0, this.inputText.length);
            this.setCursorPosition(position);

            return this;
        },

        cursorMoveUp() {
            if (!this.isOpened) {
                return this;
            }

            var result = GetIndex(this.characterCountOfLines, this.cursorPosition);
            result.lineIndex -= 1;

            var position = Clamp$e(GetPosition(this.characterCountOfLines, result), 0, this.inputText.length);
            this.setCursorPosition(position);

            return this;
        },

        cursorMoveDown() {
            if (!this.isOpened) {
                return this;
            }

            var result = GetIndex(this.characterCountOfLines, this.cursorPosition);
            result.lineIndex += 1;

            var position = Clamp$e(GetPosition(this.characterCountOfLines, result), 0, this.inputText.length);
            this.setCursorPosition(position);

            return this;
        },
    };

    const IsPlainObject$M = Phaser.Utils.Objects.IsPlainObject;

    class CanvasInput extends DynamicText {
        constructor(scene, x, y, fixedWidth, fixedHeight, config) {
            if (IsPlainObject$M(x)) {
                config = x;
            } else if (IsPlainObject$M(fixedWidth)) {
                config = fixedWidth;
            }

            if (config === undefined) {
                config = {};
            }

            InjectDefaultConfig(scene, config);

            // Set text later
            var text = config.text;
            if (text) {
                delete config.text;
            }

            var focusStyle = ExtractByPrefix(config.background, 'focus');
            var cursorStyle = ExtractByPrefix(config.style, 'cursor');
            var rangeStyle = ExtractByPrefix(config.style, 'range');

            super(scene, x, y, fixedWidth, fixedHeight, config);
            this.type = 'rexCanvasInput';

            // readonly
            this.contentWidth = undefined;
            this.contentHeight = undefined;
            this.lineHeight = undefined;
            this.linesCount = undefined;
            this.characterCountOfLines = [];

            this._text;

            this.textEdit = CreateHiddenTextEdit(this, config);

            RegisterArrowKeysEvent.call(this);

            if (config.focusStyle) {
                Object.assign(focusStyle, config.focusStyle);
            }
            RegisterFocusStyle.call(this, focusStyle);

            if (config.cursorStyle) {
                Object.assign(cursorStyle, config.cursorStyle);
            }
            RegisterCursorStyle.call(this, cursorStyle);

            if (config.rangeStyle) {
                Object.assign(rangeStyle, config.rangeStyle);
            }
            if (IsEmpty(rangeStyle)) {
                Object.assign(rangeStyle, cursorStyle);
            }
            RegisterRangeStyle.call(this, rangeStyle);


            var addCharCallback = config.onAddChar;
            if (addCharCallback) {
                this.on('addchar', addCharCallback);
            }

            var cursorInCallback = config.onCursorIn;
            if (cursorInCallback) {
                this.on('cursorin', cursorInCallback);
            }

            var cursorOutCallback = config.onCursorOut;
            if (cursorOutCallback) {
                this.on('cursorout', cursorOutCallback);
            }

            var useCursorCallback = !config.onRangeIn && !config.onRangeOut;
            var rangeInCallback = (!useCursorCallback) ? config.onRangeIn : config.onCursorIn;
            if (rangeInCallback) {
                this.on('rangein', rangeInCallback);
            }

            var rangeOutCallback = (!useCursorCallback) ? config.onRangeOut : config.onCursorOut;
            if (rangeOutCallback) {
                this.on('rangeout', rangeOutCallback);
            }

            var moveCursorCallback = config.onMoveCursor;
            if (moveCursorCallback) {
                this.on('movecursor', moveCursorCallback);
            }

            this.setParseTextCallback(config.parseTextCallback);

            this.lastInsertCursor = CreateInsertCursorChild(this);

            if (!text) {
                text = '';
            }
            this.setText(text);
        }

        addChild(child, index) {
            super.addChild(child, index);

            if (Array.isArray(child)) {
                var children = child;
                for (var i = 0, cnt = children.length; i < cnt; i++) {
                    var child = children[i];
                    if (IsChar(child)) {
                        this.emit('addchar', child, index + i, this);
                    }
                }
            } else {
                if (IsChar(child)) {
                    this.emit('addchar', child, index, this);
                }
            }

            return this;
        }

        get text() {
            return this._text;
        }

        set text(value) {
            if (value == null) {
                value = '';
            } else {
                value = value.toString();
            }
            if (this._text === value) {
                return;
            }

            SetText$1(this, value);

            this._text = value;
        }

        setText(text) {
            this.text = text;
            return this;
        }

        appendText(text) {
            this.setText(this.text + text);
            return this;
        }

        runWrap(config) {
            var result = super.runWrap(config);
            // Save content size
            this.contentWidth = result.maxLineWidth;
            this.contentHeight = result.linesHeight;
            this.lineHeight = result.lineHeight;
            this.linesCount = result.lines.length;

            this.characterCountOfLines.length = 0;
            var wrapLines = result.lines;
            for (var li = 0, lcnt = wrapLines.length; li < lcnt; li++) {
                var line = wrapLines[li].children;
                var characterCount = 0;
                for (var ci = 0, ccnt = line.length; ci < ccnt; ci++) {
                    var child = line[ci];
                    if (child.active && !child.removed && IsChar(child)) {
                        characterCount++;
                    }
                }

                this.characterCountOfLines.push(characterCount);
            }

            return result;
        }

        setSize(width, height) {
            if ((this.width === width) && (this.height === height)) {
                return this;
            }

            super.setSize(width, height);

            // Run wrap again since fixedWidth and fixedHeight are changed
            this.runWrap();

            return this;
        }

        get displayText() {
            return this.text;
        }

        set displayText(value) {
            this.text = value;
        }

        setDisplayText(value) {
            this.displayText = value;
            return this;
        }

        get inputText() {
            return this.textEdit.text;
        }

        set inputText(value) {
            this.textEdit.text = value;
        }

        setInputText(value) {
            this.inputText = value;
            return this;
        }

        setParseTextCallback(callback) {
            if (!callback) {
                callback = DefaultParseTextCallback;
            }
            this.parseTextCallback = callback;
            return this;
        }

        get value() {
            return this.parseTextCallback(this.text);
        }

        set value(value) {
            this.setText(value);
        }

        getValue() {
            return this.value;
        }

        setValue(value) {
            this.value = value;
            return this;
        }

        get readOnly() {
            return this.textEdit.readOnly;
        }

        set readOnly(value) {
            this.textEdit.readOnly = value;
        }

        setReadOnly(value) {
            this.textEdit.setReadOnly(value);
            return this;
        }

        open(onCloseCallback) {
            if (onCloseCallback) {
                this.textEdit.once('close', onCloseCallback);
            }
            this.textEdit.open();
            return this;
        }

        close() {
            this.textEdit.close();
            return this;
        }

        get isOpened() {
            return this.textEdit.isOpened;
        }

        setFocusStyle(style) {
            this.focusStyle = style;
            return this;
        }

        setCursorStyle(style) {
            this.cursorStyle = style;
            return this;
        }

        setRangeStyle(style) {
            this.rangeStyle = style;
            return this;
        }

        setNumberInput() {
            this.textEdit
                .setNumberInput()
                .setSelectAllWhenFocusEnable();

            this.parseTextCallback = Number;
            return this;
        }

        get maxLength() {
            return this.textEdit.maxLength;
        }

        set maxLength(value) {
            this.textEdit.maxLength = value;
        }

        setMaxLength(value) {
            this.maxLength = value;
            return this;
        }

        get minLength() {
            return this.textEdit.minLength;
        }

        set minLength(value) {
            this.textEdit.minLength = value;
        }

        setMinLength(value) {
            this.minLength = value;
            return this;
        }

        get cursorPosition() {
            return this.textEdit.cursorPosition;
        }

        set cursorPosition(value) {
            if (!this.isOpened) {
                return;
            }

            this.textEdit.cursorPosition = value;
            this.textEdit.requestCursorPosition = value;
        }

        setCursorPosition(value) {
            this.cursorPosition = value;
            return this;
        }

        get topTextOY() {
            return 0;
        }

        get bottomTextOY() {
            return -this.tableVisibleHeight;
        }

        get leftTextOX() {
            return 0;
        }

        get rightTextOX() {
            return -this.textVisibleWidth;
        }

        get textVisibleHeight() {
            var h = this.contentHeight - this.height;
            if (h < 0) {
                h = 0;
            }
            return h;
        }

        get textVisibleWidth() {
            var w = this.contentWidth - this.width;
            if (w < 0) {
                w = 0;
            }
            return w;
        }

        set t(value) {
            this.setTextOYByPercentage(value).updateTexture();
        }

        get t() {
            return this.getTextOYPercentage();
        }

        set s(value) {
            this.setTextOXByPercentage(value).updateTexture();
        }

        get s() {
            return this.getTextOXPercentage();
        }

    }

    var DefaultParseTextCallback = function (text) {
        return text;
    };

    Object.assign(
        CanvasInput.prototype,
        SetTextOXYMethods,
        MoveCursorMethods,
    );

    ObjectFactory.register('canvasInput', function (x, y, fixedWidth, fixedHeight, config) {
        var gameObject = new CanvasInput(this.scene, x, y, fixedWidth, fixedHeight, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.CanvasInput', CanvasInput);

    var GetTickDelta = function (game) {
        return GetGame(game).loop.delta;
    };

    const GetValue$39 = Phaser.Utils.Objects.GetValue;
    const Wrap$3 = Phaser.Math.Wrap;

    class HiddenTextEdit extends HiddenTextEditBase {
        constructor(gameObject, config) {
            if (config === undefined) {
                config = {};
            }

            if (config.onUpdate === 'number') {
                config.onUpdate = NumberInputUpdateCallback;
            }

            super(gameObject, config);
            // this.parent = gameObject;

            this.setCursor(GetValue$39(config, 'cursor', '|'));
            this.setCursorFlashDuration(GetValue$39(config, 'cursorFlashDuration', 1000));
            this.cursorFlashTimer = 0;

        }

        initText() {
            this.cursorFlashTimer = 0;
            this.prevCursorPosition = undefined;
            this.setText(this.parent.text);
            this.setCursorPosition();

            return this;
        }

        updateText() {
            var textObject = this.parent;
            var text = this.text;

            if (this.onUpdateCallback) {
                var newText = this.onUpdateCallback(text, textObject, this);
                if (newText != null) {
                    text = newText;
                }
            }

            if (this.isOpened && this.hasCursor) {
                // Insert Cursor
                var cursorPosition = this.cursorPosition;
                text = text.substring(0, cursorPosition) + this.cursor + text.substring(cursorPosition);

                if (this.prevCursorPosition !== cursorPosition) {
                    // console.log(cursorPosition);
                    this.prevCursorPosition = cursorPosition;
                }
            }

            if (textObject.text !== text) {
                textObject.setText(text);
                this.emit('textchange', text, textObject, this);
            }

            return this;
        }

        setCursor(s) {
            this._cursor = s;
            this.hasCursor = s && (s !== '');
            return s;
        }

        setCursorFlashDuration(duration) {
            this.cursorFlashDuration = duration;
            return this;
        }

        get cursor() {
            if (!this._isFocused) {
                return this._cursor;
            }

            // Flash Cursor
            var cursor;
            if (this.cursorFlashTimer < (this.cursorFlashDuration / 2)) {
                cursor = this._cursor;
            } else {
                cursor = ' ';
            }

            var timerValue = this.cursorFlashTimer + GetTickDelta(this.scene);
            this.cursorFlashTimer = Wrap$3(timerValue, 0, this.cursorFlashDuration);
            return cursor;
        }

    }

    ObjectFactory.register('hiddenEdit', function (textObject, config) {
        var gameObject = new HiddenTextEdit(textObject, config);
        // Note: Don't add this game object into scene
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.HiddenEdit', HiddenTextEdit);

    const GetCalcMatrix = Phaser.GameObjects.GetCalcMatrix;

    var WebGLRenderer = function (renderer, src, camera, parentMatrix) {
        src.updateData();
        camera.addToRenderList(src);

        var pipeline = renderer.pipelines.set(src.pipeline);

        var result = GetCalcMatrix(src, camera, parentMatrix);

        var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

        var dx = src._displayOriginX;
        var dy = src._displayOriginY;

        var alpha = camera.alpha * src.alpha;

        renderer.pipelines.preBatch(src);

        var shapes = src.geom,
            shape;
        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
            shape = shapes[i];
            if (shape.visible) {
                shape.webglRender(pipeline, calcMatrix, alpha, dx, dy);
            }
        }

        renderer.pipelines.postBatch(src);
    };

    const SetTransform = Phaser.Renderer.Canvas.SetTransform;

    var CanvasRenderer = function (renderer, src, camera, parentMatrix) {
        src.updateData();
        camera.addToRenderList(src);

        var ctx = renderer.currentContext;

        if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;

            var shapes = src.geom,
                shape;
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                shape = shapes[i];
                if (shape.visible) {
                    shape.canvasRender(ctx, dx, dy);
                }
            }

            //  Restore the context saved in SetTransform
            ctx.restore();
        }
    };

    var Render = {
        renderWebGL: WebGLRenderer,
        renderCanvas: CanvasRenderer

    };

    const Shape = Phaser.GameObjects.Shape;
    const RemoveItem$7 = Phaser.Utils.Array.Remove;

    class BaseShapes extends Shape {
        constructor(scene, x, y, width, height) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (width === undefined) {
                width = 2;
            }
            if (height === undefined) {
                height = width;
            }

            super(scene, 'rexShapes', []);

            this._width = -1;
            this._height = -1;
            this.dirty = true;
            this.isSizeChanged = true;
            this.shapes = {};

            this.setPosition(x, y);
            this.setSize(width, height);

            this.updateDisplayOrigin();
        }

        get width() {
            return this._width;
        }

        set width(value) {
            this.setSize(value, this._height);
        }

        get height() {
            return this._height;
        }

        set height(value) {
            this.setSize(this._width, value);
        }

        setDirty(value) {
            if (value === undefined) {
                value = true;
            }
            this.dirty = value;
            return this;
        }

        setSize(width, height) {
            this.isSizeChanged = this.isSizeChanged || (this._width !== width) || (this._height !== height);
            this.dirty = this.dirty || this.isSizeChanged;
            this._width = width;
            this._height = height;
            this.updateDisplayOrigin();
            var input = this.input;
            if (input && !input.customHitArea) {
                input.hitArea.width = width;
                input.hitArea.height = height;
            }
            return this;
        }

        resize(width, height) {
            this.setSize(width, height);
            return this;
        }

        get fillColor() {
            return this._fillColor;
        }

        set fillColor(value) {
            this.setFillStyle(value, this._fillAlpha);
        }

        get fillAlpha() {
            return this._fillAlpha;
        }

        set fillAlpha(value) {
            this.setFillStyle(this._fillColor, value);
        }

        setFillStyle(color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }

            this.dirty = this.dirty ||
                (this.fillColor !== color) ||
                (this.fillAlpha !== alpha);

            this._fillColor = color;
            this._fillAlpha = alpha;

            return this;
        }

        get lineWidth() {
            return this._lineWidth;
        }

        set lineWidth(value) {
            this.setStrokeStyle(value, this._strokeColor, this._strokeAlpha);
        }

        get strokeColor() {
            return this._strokeColor;
        }

        set strokeColor(value) {
            this.setStrokeStyle(this._lineWidth, value, this._strokeAlpha);
        }

        get strokeAlpha() {
            return this._strokeAlpha;
        }

        set strokeAlpha(value) {
            this.setStrokeStyle(this._lineWidth, this._strokeColor, value);
        }

        setStrokeStyle(lineWidth, color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }

            this.dirty = this.dirty ||
                (this.lineWidth !== lineWidth) ||
                (this.strokeColor !== color) ||
                (this.strokeAlpha !== alpha);

            this._lineWidth = lineWidth;
            this._strokeColor = color;
            this._strokeAlpha = alpha;

            return this;
        }

        updateShapes() {

        }

        updateData() {
            if (!this.dirty) {
                return this;
            }

            this.updateShapes();
            var shapes = this.geom;
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var shape = shapes[i];
                if (shape.dirty) {
                    shape.updateData();
                }
            }

            this.isSizeChanged = false;
            this.dirty = false;


            return this;
        }

        clear() {
            this.geom.length = 0;
            Clear$1(this.shapes);
            this.dirty = true;
            return this;
        }

        getShape(name) {
            return this.shapes[name];
        }

        getShapes() {
            return this.geom;
        }

        addShape(shape) {
            this.geom.push(shape);
            var name = shape.name;
            if (name) {
                this.shapes[name] = shape;
            }
            this.dirty = true;
            return this;
        }

        deleteShape(name) {
            var shape = this.getShape(name);
            if (shape) {
                delete this.shapes[name];
                RemoveItem$7(this.geom, shape);
            }
            return this;
        }
    }

    Object.assign(
        BaseShapes.prototype,
        Render
    );

    var StyleMethods$2 = {
        setBoxFillStyle(color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.dirty = this.dirty ||
                (this.boxFillColor !== color) ||
                (this.boxFillAlpha !== alpha);

            this.boxFillColor = color;
            this.boxFillAlpha = alpha;
            return this;
        },

        setUncheckedBoxFillStyle(color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.dirty = this.dirty ||
                (this.uncheckedBoxFillColor !== color) ||
                (this.uncheckedBoxFillAlpha !== alpha);

            this.uncheckedBoxFillColor = color;
            this.uncheckedBoxFillAlpha = alpha;
            return this;
        },

        setBoxStrokeStyle(lineWidth, color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.dirty = this.dirty ||
                (this.boxLineWidth !== lineWidth) ||
                (this.boxStrokeColor !== color) ||
                (this.boxStrokeAlpha !== alpha);

            this.boxLineWidth = lineWidth;
            this.boxStrokeColor = color;
            this.boxStrokeAlpha = alpha;
            return this;
        },

        setUncheckedBoxStrokeStyle(lineWidth, color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.dirty = this.dirty ||
                (this.uncheckedBoxLineWidth !== lineWidth) ||
                (this.uncheckedBoxStrokeColor !== color) ||
                (this.uncheckedBoxStrokeAlpha !== alpha);

            this.uncheckedBoxLineWidth = lineWidth;
            this.uncheckedBoxStrokeColor = color;
            this.uncheckedBoxStrokeAlpha = alpha;
            return this;
        },

        setCheckerStyle(color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.dirty = this.dirty ||
                (this.checkerColor !== color) ||
                (this.checkAlpha !== alpha);

            this.checkerColor = color;
            this.checkAlpha = alpha;
            return this;
        },

        setBoxShape(isCircleShape) {
            if (isCircleShape === undefined) {
                isCircleShape = false;
            }
            if (this.isCircleShape === isCircleShape) {
                return this;
            }

            this.isCircleShape = isCircleShape;
            this.isSizeChanged = true;
            this.dirty = true;
            return this;
        }
    };

    var SizeMethods$1 = {
        setBoxSize(size) {
            this.dirty = this.dirty ||
                (this.boxSize !== size);

            this.boxSize = size;
            return this;
        },

        setCheckerSize(size) {
            this.dirty = this.dirty ||
                (this.checkerSize !== size);

            this.checkerSize = size;
            return this;
        }
    };

    var FillStyle = function (color, alpha) {
        if (color == null) {
            this.isFilled = false;
        } else {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.isFilled = true;
            this.fillColor = color;
            this.fillAlpha = alpha;
        }
        return this;
    };

    var LineStyle = function (lineWidth, color, alpha) {
        if ((lineWidth == null) || (color == null)) {
            this.isStroked = false;
        } else {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.isStroked = true;
            this.lineWidth = lineWidth;
            this.strokeColor = color;
            this.strokeAlpha = alpha;
        }
        return this;
    };

    var StyleMethods$1 = {
        fillStyle: FillStyle,
        lineStyle: LineStyle
    };

    class BaseGeom {
        constructor() {
            this.name = undefined;
            this.dirty = true;
            this.visible = true;
            this.data = undefined;

            this.isFilled = false;
            this.fillColor = undefined;
            this.fillAlpha = 1;

            this.isStroked = false;
            this.lineWidth = 1;
            this.strokeColor = undefined;
            this.strokeAlpha = 1;
        }

        setName(name) {
            this.name = name;
            return this;
        }

        setVisible(visible) {
            if (visible === undefined) {
                visible = true;
            }
            this.visible = visible;
            return this;
        }

        reset() {
            this
                .setVisible()
                .fillStyle()
                .lineStyle();

            return this;
        }

        webglRender(pipeline, calcMatrix, alpha, dx, dy) {

        }

        canvasRender(ctx, dx, dy) {

        }

        updateData() {
            this.dirty = false;
        }
    }

    Object.assign(
        BaseGeom.prototype,
        StyleMethods$1,
        DataMethods$2
    );

    const Earcut = Phaser.Geom.Polygon.Earcut;

    class PathBase extends BaseGeom {
        constructor() {
            super();

            this.pathData = [];
            this.pathIndexes = [];
            this.closePath = false;
        }

        updateData() {
            this.pathIndexes = Earcut(this.pathData);

            super.updateData();
            return this;
        }

        webglRender(pipeline, calcMatrix, alpha, dx, dy) {
            if (this.isFilled) {
                FillPathWebGL(pipeline, calcMatrix, this, alpha, dx, dy);
            }

            if (this.isStroked) {
                StrokePathWebGL(pipeline, this, alpha, dx, dy);
            }
        }

        canvasRender(ctx, dx, dy) {
            var path = this.pathData;
            var pathLength = path.length - 1;

            var px1 = path[0] - dx;
            var py1 = path[1] - dy;

            ctx.beginPath();

            ctx.moveTo(px1, py1);

            if (!this.closePath) {
                pathLength -= 2;
            }

            for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
            }

            if (this.closePath) {
                ctx.closePath();
            }


            if (this.isFilled) {
                FillStyleCanvas(ctx, this);
                ctx.fill();
            }

            if (this.isStroked) {
                LineStyleCanvas(ctx, this);
                ctx.stroke();
            }
        }
    }

    const DegToRad$e = Phaser.Math.DegToRad;

    class Arc extends PathBase {
        constructor(x, y, radiusX, radiusY, startAngle, endAngle, anticlockwise, pie) {
            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (radiusX === undefined) { radiusX = 0; }
            if (radiusY === undefined) { radiusY = 0; }
            if (startAngle === undefined) { startAngle = 0; }
            if (endAngle === undefined) { endAngle = 360; }
            if (anticlockwise === undefined) { anticlockwise = false; }
            if (pie === undefined) { pie = false; }

            super();

            this.setCenterPosition(x, y);
            this.setRadius(radiusX, radiusY);
            this.setAngle(startAngle, endAngle, anticlockwise);
            this.setPie(pie);
            this.setIterations(32);
        }

        get x() {
            return this._x;
        }

        set x(value) {
            this.dirty = this.dirty || (this._x !== value);
            this._x = value;
        }

        get y() {
            return this._y;
        }

        set y(value) {
            this.dirty = this.dirty || (this._y !== value);
            this._y = value;
        }

        setCenterPosition(x, y) {
            if (y === undefined) {
                y = x;
            }
            this.x = x;
            this.y = y;
            return this;
        }

        get radiusX() {
            return this._radiusX;
        }

        set radiusX(value) {
            this.dirty = this.dirty || (this._radiusX !== value);
            this._radiusX = value;
        }

        get radiusY() {
            return this._radiusY;
        }

        set radiusY(value) {
            this.dirty = this.dirty || (this._radiusY !== value);
            this._radiusY = value;
        }

        setRadius(radiusX, radiusY) {
            if (radiusY === undefined) {
                radiusY = radiusX;
            }
            this.radiusX = radiusX;
            this.radiusY = radiusY;
            return this;
        }

        get startAngle() {
            return this._startAngle;
        }

        set startAngle(value) {
            this.dirty = this.dirty || (this._startAngle !== value);
            this._startAngle = value;
        }

        get endAngle() {
            return this._endAngle;
        }

        set endAngle(value) {
            this.dirty = this.dirty || (this._endAngle !== value);
            this._endAngle = value;
        }

        get anticlockwise() {
            return this._anticlockwise;
        }

        set anticlockwise(value) {
            this.dirty = this.dirty || (this._anticlockwise !== value);
            this._anticlockwise = value;
        }

        setAngle(startAngle, endAngle, anticlockwise) {
            // startAngle, endAngle in degrees
            if (anticlockwise === undefined) {
                anticlockwise = false;
            }

            this.startAngle = startAngle;
            this.endAngle = endAngle;
            this.anticlockwise = anticlockwise;
            return this;
        }

        get pie() {
            return this._pie;
        }

        set pie(value) {
            this.dirty = this.dirty || (this._pie !== value);
            this._pie = value;
        }

        setPie(pie) {
            if (pie === undefined) {
                pie = true;
            }
            this.pie = pie;
            return this;
        }

        get iterations() {
            return this._iterations;
        }

        set iterations(value) {
            this.dirty = this.dirty || (this._iterations !== value);
            this._iterations = value;
        }

        setIterations(iterations) {
            this.iterations = iterations;
            return this;
        }

        updateData() {
            this.pathData.length = 0;
            if (this.pie) {
                this.pathData.push(this.x, this.y);
            }
            ArcTo$1(
                this.x, this.y,
                this.radiusX, this.radiusY,
                this.startAngle, this.endAngle, this.anticlockwise,
                this.iterations,
                this.pathData
            );
            if (this.pie) {
                this.pathData.push(this.x, this.y);
            }
            // Close
            this.pathData.push(this.pathData[0], this.pathData[1]);

            super.updateData();
            return this;
        }

        canvasRender(ctx, dx, dy) {
            ctx.beginPath();
            var x = this.x - dx,
                y = this.y - dy,
                startAngle = DegToRad$e(this.startAngle),
                endAngle = DegToRad$e(this.endAngle);
            if (this.pie) {
                ctx.moveTo(x, y);
                ctx.lineTo(
                    x + Math.cos(startAngle) * this.radiusX,
                    y + Math.sin(startAngle) * this.radiusY
                );
            }
            ctx.ellipse(
                x, y,
                this.radiusX, this.radiusY,
                0,
                startAngle, endAngle, this.anticlockwise
            );
            if (this.pie) {
                ctx.lineTo(x, y);
            }
            if (this.isFilled) {
                FillStyleCanvas(ctx, this);
                ctx.fill();
            }
            if (this.isStroked) {
                LineStyleCanvas(ctx, this);
                ctx.stroke();
            }
        }
    }

    class Circle extends Arc {
        constructor(x, y, radius) {
            super(x, y, radius, radius, 0, 360);
        }
    }

    class Curve extends PathBase {
        constructor(curve) {
            super();
            this.setCurve(curve);
            this.setIterations(32);
        }

        get curve() {
            return this._curve;
        }

        set curve(value) {
            this.dirty = this.dirty || (this._curve !== value);
            this._curve = value;
        }

        setCurve(curve) {
            this.curve = curve;
            return this;
        }

        get iterations() {
            return this._iterations;
        }

        set iterations(value) {
            this.dirty = this.dirty || (this._iterations !== value);
            this._iterations = value;
        }

        setIterations(iterations) {
            this.iterations = iterations;
            return this;
        }

        updateData() {
            this.pathData.length = 0;
            var points = this.curve.getPoints(this.iterations);
            for (var i = 0, cnt = points.length; i < cnt; i++) {
                this.pathData.push(points[i].x, points[i].y);
            }
            this.pathData.push(points[0].x, points[0].y);

            super.updateData();
            return this;
        }

    }

    class Ellipse extends Arc {
        constructor(x, y, radiusX, radiusY) {
            super(x, y, radiusX, radiusY, 0, 360);
        }
    }

    class Line extends PathBase {
        constructor(x0, y0, x1, y1) {
            if (x0 === undefined) { x0 = 0; }
            if (y0 === undefined) { y0 = 0; }
            if (x1 === undefined) { x1 = 0; }
            if (y1 === undefined) { y1 = 0; }

            super();

            this.setP0(x0, y0);
            this.setP1(x1, y1);
        }

        get x0() {
            return this._x0;
        }

        set x0(value) {
            this.dirty = this.dirty || (this._x0 !== value);
            this._x0 = value;
        }

        get y0() {
            return this._y0;
        }

        set y0(value) {
            this.dirty = this.dirty || (this._y0 !== value);
            this._y0 = value;
        }

        setP0(x, y) {
            this.x0 = x;
            this.y0 = y;
            return this;
        }

        get x1() {
            return this._x1;
        }

        set x1(value) {
            this.dirty = this.dirty || (this._x1 !== value);
            this._x1 = value;
        }

        get y1() {
            return this._y1;
        }

        set y1(value) {
            this.dirty = this.dirty || (this._y1 !== value);
            this._y1 = value;
        }

        setP1(x, y) {
            this.x1 = x;
            this.y1 = y;
            return this;
        }

        updateData() {
            this.pathData.length = 0;
            this.pathData.push(this.x0, this.y0);
            this.pathData.push(this.x1, this.y1);
            this.pathData.push(this.x0, this.y0);

            super.updateData();
            return this;
        }
    }

    var StartAt = function (x, y, pathData) {
        pathData.length = 0;

        if (x != null) {
            pathData.push(x, y);
        }

        return pathData;
    };

    //import QuadraticBezierInterpolation from '../../utils/math/interpolation/QuadraticBezierInterpolation.js';

    const QuadraticBezierInterpolation = Phaser.Math.Interpolation.QuadraticBezier;

    var QuadraticBezierTo = function (cx, cy, x, y, iterations, pathData) {
        var pathDataCnt = pathData.length;
        var p0x = pathData[pathDataCnt - 2];
        var p0y = pathData[pathDataCnt - 1];
        for (var i = 1, last = iterations - 1; i <= last; i++) {
            var t = i / last;
            pathData.push(
                QuadraticBezierInterpolation(t, p0x, cx, x),
                QuadraticBezierInterpolation(t, p0y, cy, y)
            );
        }
        return pathData;
    };

    // import CubicBezierInterpolation from '../../utils/math/interpolation/CubicBezierInterpolation.js';

    const CubicBezierInterpolation = Phaser.Math.Interpolation.CubicBezier;

    var CubicBezierCurveTo = function (cx0, cy0, cx1, cy1, x, y, iterations, pathData) {
        var pathDataCnt = pathData.length;
        var p0x = pathData[pathDataCnt - 2];
        var p0y = pathData[pathDataCnt - 1];
        for (var i = 1, last = iterations - 1; i <= last; i++) {
            var t = i / last;
            pathData.push(
                CubicBezierInterpolation(t, p0x, cx0, cx1, x),
                CubicBezierInterpolation(t, p0y, cy0, cy1, y)
            );
        }
        return pathData;
    };

    //import CatmullRomInterpolation from '../../utils/math/interpolation/CatmullRomInterpolation.js';

    const CatmullRomInterpolation = Phaser.Math.Interpolation.CatmullRom;

    var CatmullRomTo = function (points, iterations, pathData) {
        var pathDataCnt = pathData.length;
        var p0x = pathData[pathDataCnt - 2];
        var p0y = pathData[pathDataCnt - 1];

        var xList = [p0x];
        var yList = [p0y];
        for (var i = 0, cnt = points.length; i < cnt; i += 2) {
            xList.push(points[i]);
            yList.push(points[i + 1]);
        }

        for (var i = 1, last = iterations - 1; i <= last; i++) {
            var t = i / last;
            pathData.push(
                CatmullRomInterpolation(xList, t),
                CatmullRomInterpolation(yList, t)
            );
        }
        return pathData;
    };

    var DuplicateLast = function (pathData) {
        var len = pathData.length;
        if (len < 2) {
            return pathData;
        }

        var lastX = pathData[len - 2];
        var lastY = pathData[len - 1];
        pathData.push(lastX);
        pathData.push(lastY);

        return pathData;
    };

    var AddPathMethods = {
        clear() {
            this.start();
            return this;
        },

        start() {
            this.startAt();
            return this;
        },

        startAt(x, y) {
            this.restorePathData();
            this.accumulationLengths = undefined;

            StartAt(x, y, this.pathData);
            this.firstPointX = x;
            this.firstPointY = y;
            this.lastPointX = x;
            this.lastPointY = y;

            return this;
        },

        lineTo(x, y, relative) {
            if (relative === undefined) {
                relative = false;
            }
            if (relative) {
                x += this.lastPointX;
                y += this.lastPointY;
            }

            LineTo(x, y, this.pathData);

            this.lastPointX = x;
            this.lastPointY = y;
            return this;
        },

        verticalLineTo(x, relative) {
            this.lineTo(x, this.lastPointY, relative);
            return this;
        },

        horizontalLineTo(y, relative) {
            this.lineTo(this.lastPointX, y, relative);
            return this;
        },

        ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
            if (anticlockwise === undefined) {
                anticlockwise = false;
            }

            ArcTo$1(
                centerX, centerY,
                radiusX, radiusY,
                startAngle, endAngle, anticlockwise,
                this.iterations,
                this.pathData
            );

            this.lastPointX = this.pathData[this.pathData.length - 2];
            this.lastPointY = this.pathData[this.pathData.length - 1];
            return this;
        },

        arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
            this.ellipticalArc(centerX, centerY, radius, radius, startAngle, endAngle, anticlockwise);
            return this;
        },

        quadraticBezierTo(cx, cy, x, y) {
            QuadraticBezierTo(
                cx, cy, x, y,
                this.iterations,
                this.pathData
            );

            this.lastPointX = x;
            this.lastPointY = y;
            return this;
        },

        cubicBezierTo(cx0, cy0, cx1, cy1, x, y) {
            CubicBezierCurveTo(
                cx0, cy0, cx1, cy1, x, y,
                this.iterations,
                this.pathData
            );

            this.lastPointX = x;
            this.lastPointY = y;
            return this;
        },

        catmullRomTo(...points) {
            CatmullRomTo(
                points,
                this.iterations,
                this.pathData
            );

            this.lastPointX = points[points.length-2];
            this.lastPointY = points[points.length-1];
            return this;
        },

        close() {
            // Line to first point        
            var startX = this.pathData[0],
                startY = this.pathData[1];
            if ((startX !== this.lastPointX) || (startY !== this.lastPointY)) {
                this.lineTo(startX, startY);
            }

            this.closePath = true;
            return this;
        },

        end() {
            DuplicateLast(this.pathData);
            return this;
        },

    };

    //import PointRotateAround from '../../utils/math/RotateAround.js';

    const PointRotateAround = Phaser.Math.RotateAround;

    var RotateAround$5 = function (centerX, centerY, angle, pathData) {
        var point = { x: 0, y: 0 };
        for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
            point.x = pathData[i];
            point.y = pathData[i + 1];
            PointRotateAround(point, centerX, centerY, angle);
            pathData[i] = point.x;
            pathData[i + 1] = point.y;
        }
        return pathData;
    };

    var Scale$2 = function (centerX, centerY, scaleX, scaleY, pathData) {
        for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
            var x = pathData[i] - centerX;
            var y = pathData[i + 1] - centerY;
            x *= scaleX;
            y *= scaleY;
            pathData[i] = x + centerX;
            pathData[i + 1] = y + centerY;
        }
        return pathData;
    };

    var Offset = function (x, y, pathData) {
        for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
            pathData[i] += x;
            pathData[i + 1] += y;
        }
        return pathData;
    };

    const DegToRad$d = Phaser.Math.DegToRad;
    Phaser.Math.RotateAround;

    var TransformPointsMethods = {
        rotateAround(centerX, centerY, angle) {
            if (this.pathData.length === 0) {
                return this;
            }

            angle = DegToRad$d(angle);

            RotateAround$5(centerX, centerY, angle, this.pathData);

            var pathDataCnt = this.pathData.length;
            this.lastPointX = this.pathData[pathDataCnt - 2];
            this.lastPointY = this.pathData[pathDataCnt - 1];
            return this;
        },

        scale(centerX, centerY, scaleX, scaleY) {
            if (this.pathData.length === 0) {
                return this;
            }

            Scale$2(centerX, centerY, scaleX, scaleY, this.pathData);
            this.lastPointX = this.pathData[pathDataCnt - 2];
            this.lastPointY = this.pathData[pathDataCnt - 1];
            return this;
        },

        offset(x, y) {
            Offset(x, y, this.pathData);
            return this;
        }

    };

    var Copy = function (dest, src, startIdx, endIdx) {
        if (startIdx === undefined) {
            startIdx = 0;
        }    if (endIdx === undefined) {
            endIdx = src.length;
        }
        dest.length = endIdx - startIdx;
        for (var i = 0, len = dest.length; i < len; i++) {
            dest[i] = src[i + startIdx];
        }
        return dest;
    };

    var SavePathDataMethods = {
        savePathData() {
            if (this.pathDataSaved) {
                return this;
            }

            this.pathDataSave = [...this.pathData];
            this.pathData.length = 0;
            this.pathDataSaved = true;
            return this;
        },

        restorePathData() {
            if (!this.pathDataSaved) {
                return this;
            }

            Copy(this.pathData, this.pathDataSave);
            this.pathDataSave = undefined;
            this.pathDataSaved = false;
            return this;
        },
    };

    const DistanceBetween$7 = Phaser.Math.Distance.Between;
    const Wrap$2 = Phaser.Math.Wrap;
    const Linear$o = Phaser.Math.Linear;

    var AppendFromPathSegment = function (srcPathData, accumulationLengths, startT, endT, destPathData) {
        if (endT === undefined) {
            endT = startT;
            startT = 0;
        }

        startT = WrapT(startT);
        endT = WrapT(endT);

        if (startT === endT) {
            return;
        }

        var totalPathLength = accumulationLengths[accumulationLengths.length - 1];
        var startL = totalPathLength * startT;
        var endL = totalPathLength * endT;
        if (startT < endT) {
            AddPathSegment(srcPathData, accumulationLengths, startL, endL, destPathData);
        } else {
            AddPathSegment(srcPathData, accumulationLengths, startL, totalPathLength, destPathData);
            AddPathSegment(srcPathData, accumulationLengths, 0, endL, destPathData);
        }

        DuplicateLast(destPathData);
    };

    var AddPathSegment = function (srcPathData, accumulationLengths, startL, endL, destPathData) {
        var skipState = (startL > 0);
        for (var i = 0, cnt = accumulationLengths.length; i < cnt; i++) {
            var pIdx = i * 2;
            var d = accumulationLengths[i];

            if (skipState) {
                if (d < startL) {
                    continue;
                } else if (d == startL) {
                    skipState = false;
                } else { // d > startL
                    var deltaD = d - accumulationLengths[i - 1];
                    var t = 1 - ((d - startL) / deltaD);
                    destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
                    destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
                    skipState = false;
                }
            }

            if (d <= endL) {
                destPathData.push(srcPathData[pIdx]);
                destPathData.push(srcPathData[pIdx + 1]);
                if (d === endL) {
                    break;
                }
            } else { // d > endL
                var deltaD = d - accumulationLengths[i - 1];
                var t = 1 - ((d - endL) / deltaD);
                destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
                destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
                break;
            }
        }
    };

    var GetInterpolation = function (pathData, i0, i1, t) {
        var p0 = pathData[i0], p1 = pathData[i1];
        return Linear$o(p0, p1, t);
    };

    var WrapT = function (t) {
        if (t === 0) {
            return 0;
        } else if ((t % 1) === 0) {
            return 1;
        }
        return Wrap$2(t, 0, 1);
    };

    var PathSegmentMethods = {
        updateAccumulationLengths() {
            if (this.accumulationLengths == null) {
                this.accumulationLengths = [];
            } else if (this.accumulationLengths.length === (this.pathData.length / 2)) {
                return this;
            }

            var accumulationLengths = this.accumulationLengths;
            var pathData = this.pathData;
            var prevX, prevY, x, y;
            var d, accumulationLength = 0;
            for (var i = 0, cnt = pathData.length; i < cnt; i += 2) {
                x = pathData[i];
                y = pathData[i + 1];

                d = (prevX === undefined) ? 0 : DistanceBetween$7(prevX, prevY, x, y);
                accumulationLength += d;
                accumulationLengths.push(accumulationLength);

                prevX = x;
                prevY = y;
            }

            this.totalPathLength = accumulationLength;

            return this;
        },

        setDisplayPathSegment(startT, endT) {
            if (!this.pathDataSaved) {
                this.updateAccumulationLengths();
                this.savePathData();
            }

            this.pathData.length = 0;
            AppendFromPathSegment(this.pathDataSave, this.accumulationLengths, startT, endT, this.pathData);

            return this;
        },

        appendFromPathSegment(src, startT, endT) {
            if (startT === undefined) {
                this.pathData.push(...src.pathData);
            } else {
                src.updateAccumulationLengths();
                AppendFromPathSegment(src.pathData, src.accumulationLengths, startT, endT, this.pathData);
            }

            this.firstPointX = this.pathData[0];
            this.firstPointY = this.pathData[1];
            this.lastPointX = this.pathData[this.pathData.length - 2];
            this.lastPointY = this.pathData[this.pathData.length - 1];
            return this;
        },
    };

    var GraphicsMethods = {
        draw(graphics, isFill, isStroke) {
            var points = this.toPoints();
            if (isFill) {
                graphics.fillPoints(points, this.closePath, this.closePath);
            }
            if (isStroke) {
                graphics.strokePoints(points, this.closePath, this.closePath);
            }

            return this;
        }
    };

    var ToPoints = function (pathData, points) {
        if (points === undefined) {
            points = [];
        }
        for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
            points.push({
                x: pathData[i],
                y: pathData[i + 1]
            });
        }
        return points;
    };

    //import Polygon from '../../utils/geom/polygon/Polygon.js';

    const Polygon = Phaser.Geom.Polygon;

    var ToPolygon = function (pathData, polygon) {
        if (polygon === undefined) {
            polygon = new Polygon();
        }
        polygon.setTo(pathData);
        return polygon;
    };

    class PathDataBuilder {
        constructor(pathData) {
            if (pathData === undefined) {
                pathData = [];
            }

            this.pathData = pathData;
            this.closePath = false;
            this.setIterations(32);

            this.firstPointX = undefined;
            this.firstPointY = undefined;
            this.lastPointX = undefined;
            this.lastPointY = undefined;
            this.accumulationLengths = undefined;
        }

        setIterations(iterations) {
            this.iterations = iterations;
            return this;
        }

        toPoints() {
            return ToPoints(this.pathData);
        }

        toPolygon(polygon) {
            return ToPolygon(this.pathData, polygon);
        }

    }

    Object.assign(
        PathDataBuilder.prototype,
        AddPathMethods,
        TransformPointsMethods,
        SavePathDataMethods,
        PathSegmentMethods,
        GraphicsMethods,
    );

    class Lines extends PathBase {
        constructor() {
            super();
            this.builder = new PathDataBuilder(this.pathData);
        }

        get iterations() {
            return this.builder.iterations;
        }

        set iterations(value) {
            this.dirty = this.dirty || (this.builder.iterations !== value);
            this.builder.setIterations(value);
        }

        setIterations(iterations) {
            this.iterations = iterations;
            return this;
        }

        get lastPointX() {
            return this.builder.lastPointX;
        }

        get lastPointY() {
            return this.builder.lastPointY;
        }

        start() {
            this.builder.start();

            this.dirty = true;
            return this;
        }

        startAt(x, y) {
            this.builder.startAt(x, y);

            this.dirty = true;
            return this;
        }

        lineTo(x, y, relative) {
            this.builder.lineTo(x, y, relative);

            this.dirty = true;
            return this;
        }

        verticalLineTo(x, relative) {
            this.builder.verticalLineTo(x, relative);

            this.dirty = true;
            return this;
        }

        horizontalLineTo(y, relative) {
            this.builder.horizontalLineTo(y, relative);

            this.dirty = true;
            return this;
        }

        ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
            this.builder.ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise);

            this.dirty = true;
            return this;
        }

        arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
            this.builder.arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise);

            this.dirty = true;
            return this;
        }

        quadraticBezierTo(cx, cy, x, y) {
            this.builder.quadraticBezierTo(cx, cy, x, y);

            this.dirty = true;
            return this;
        }

        cubicBezierTo(cx0, cy0, cx1, cy1, x, y) {
            this.builder.cubicBezierTo(cx0, cy0, cx1, cy1, x, y);

            this.dirty = true;
            return this;
        }

        catmullRomTo(...points) {
            this.builder.catmullRomTo(...points);

            this.dirty = true;
            return this;
        }

        close() {
            this.builder.close();

            this.closePath = this.builder.closePath;
            this.dirty = true;
            return this;
        }

        end() {
            this.builder.end();
            this.dirty = true;
            return this;
        }

        rotateAround(centerX, centerY, angle) {
            this.builder.rotateAround(centerX, centerY, angle);

            this.dirty = true;
            return this;
        }

        scale(centerX, centerY, scaleX, scaleY) {
            this.builder.scale(centerX, centerY, scaleX, scaleY);

            this.dirty = true;
            return this;
        }

        offset(x, y) {
            this.builder.offset(x, y);

            this.dirty = true;
            return this;
        }

        toPolygon(polygon) {
            return this.builder.toPolygon(polygon);
        }

        appendPathFrom(src, startT, endT) {
            this.builder.appendFromPathSegment(src.builder, startT, endT);
            return this;
        }

        copyPathFrom(src, startT, endT) {
            this.builder.clear().appendFromPathSegment(src.builder, startT, endT);
            return this;
        }

        setDisplayPathSegment(startT, endT) {
            this.builder.setDisplayPathSegment(startT, endT);
            return this;
        }
    }

    const GetTint$1 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;

    let Rectangle$2 = class Rectangle extends BaseGeom {
        constructor(x, y, width, height) {
            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 0; }
            if (height === undefined) { height = width; }

            super();

            this.pathData = [];
            this.closePath = true;

            this.setTopLeftPosition(x, y);
            this.setSize(width, height);
        }

        get x() {
            return this._x;
        }

        set x(value) {
            this.dirty = this.dirty || (this._x !== value);
            this._x = value;
        }

        get y() {
            return this._y;
        }

        set y(value) {
            this.dirty = this.dirty || (this._y !== value);
            this._y = value;
        }

        setTopLeftPosition(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }

        get width() {
            return this._width;
        }

        set width(value) {
            this.dirty = this.dirty || (this._width !== value);
            this._width = value;
        }

        get height() {
            return this._height;
        }

        set height(value) {
            this.dirty = this.dirty || (this._height !== value);
            this._height = value;
        }

        setSize(width, height) {
            this.width = width;
            this.height = height;
            return this;
        }

        get centerX() {
            return this.x + (this.width / 2);
        }

        set centerX(value) {
            this.x = value - (this.width / 2);
        }

        get centerY() {
            return this.y + (this.height / 2);
        }

        set centerY(value) {
            this.y = value - (this.height / 2);
        }

        setCenterPosition(x, y) {
            this.centerX = x;
            this.centerY = y;
            return this;
        }

        updateData() {
            this.pathData.length = 0;
            var x0 = this.x,
                x1 = x0 + this.width,
                y0 = this.y,
                y1 = y0 + this.height;
            this.pathData.push(x0, y0);
            this.pathData.push(x1, y0);
            this.pathData.push(x1, y1);
            this.pathData.push(x0, y1);
            this.pathData.push(x0, y0);

            super.updateData();
            return this;
        }

        webglRender(pipeline, calcMatrix, alpha, dx, dy) {
            if (this.isFilled) {
                var fillTint = pipeline.fillTint;
                var fillTintColor = GetTint$1(this.fillColor, this.fillAlpha * alpha);

                fillTint.TL = fillTintColor;
                fillTint.TR = fillTintColor;
                fillTint.BL = fillTintColor;
                fillTint.BR = fillTintColor;

                pipeline.batchFillRect(-dx + this.x, -dy + this.y, this.width, this.height);
            }

            if (this.isStroked) {
                StrokePathWebGL(pipeline, this, alpha, dx, dy);
            }
        }

        canvasRender(ctx, dx, dy) {
            if (this.isFilled) {
                FillStyleCanvas(ctx, this);
                ctx.fillRect(-dx, -dy, this.width, this.height);
            }

            if (this.isStroked) {
                LineStyleCanvas(ctx, this);
                ctx.beginPath();
                ctx.rect(-dx, -dy, this.width, this.height);
                ctx.stroke();
            }
        }
    };

    const GetValue$38 = Phaser.Utils.Objects.GetValue;

    class RoundRectangle extends PathBase {
        constructor(x, y, width, height, radius, iterations) {
            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 0; }
            if (height === undefined) { height = width; }
            if (radius === undefined) { radius = 0; }
            if (iterations === undefined) { iterations = 6; }

            super();

            this.setTopLeftPosition(x, y);
            this.setSize(width, height);
            this.setRadius(radius);
            this.setIterations(iterations);
            this.closePath = true;
        }

        get x() {
            return this._x;
        }

        set x(value) {
            this.dirty = this.dirty || (this._x !== value);
            this._x = value;
        }

        get y() {
            return this._y;
        }

        set y(value) {
            this.dirty = this.dirty || (this._y !== value);
            this._y = value;
        }

        setTopLeftPosition(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }

        get width() {
            return this._width;
        }

        set width(value) {
            this.dirty = this.dirty || (this._width !== value);
            this._width = value;
        }

        get height() {
            return this._height;
        }

        set height(value) {
            this.dirty = this.dirty || (this._height !== value);
            this._height = value;
        }

        setSize(width, height) {
            this.width = width;
            this.height = height;
            return this;
        }

        get centerX() {
            return this.x + (this.width / 2);
        }

        set centerX(value) {
            this.x = value - (this.width / 2);
        }

        get centerY() {
            return this.y + (this.height / 2);
        }

        set centerY(value) {
            this.y = value - (this.height / 2);
        }

        setCenterPosition(x, y) {
            this.centerX = x;
            this.centerY = y;
            return this;
        }

        get radiusTL() {
            return this._radiusTL;
        }

        set radiusTL(value) {
            var isConvex = (value > 0);
            this.dirty = this.dirty || (this._radiusTL !== value) || (this._convexTL !== isConvex);
            this._convexTL = isConvex;
            this._radiusTL = Math.abs(value);

        }

        get radiusTR() {
            return this._radiusTR;
        }

        set radiusTR(value) {
            var isConvex = (value > 0);
            this.dirty = this.dirty || (this._radiusTR !== value) || (this._convexTR !== isConvex);
            this._convexTR = isConvex;
            this._radiusTR = Math.abs(value);
        }

        get radiusBL() {
            return this._radiusBL;
        }

        set radiusBL(value) {
            var isConvex = (value > 0);
            this.dirty = this.dirty || (this._radiusBL !== value) || (this._convexBL !== isConvex);
            this._convexBL = isConvex;
            this._radiusBL = Math.abs(value);
        }

        get radiusBR() {
            return this._radiusBR;
        }

        set radiusBR(value) {
            var isConvex = (value > 0);
            this.dirty = this.dirty || (this._radiusBR !== value) || (this._convexBR !== isConvex);
            this._convexBR = isConvex;
            this._radiusBR = Math.abs(value);
        }

        get radius() {
            return Math.max(this.radiusTL, this.radiusTR, this.radiusBL, this.radiusBR,);
        }

        set radius(value) {
            if (typeof (value) === 'number') {
                this.radiusTL = value;
                this.radiusTR = value;
                this.radiusBL = value;
                this.radiusBR = value;
            } else {
                this.radiusTL = GetValue$38(value, 'tl', 0);
                this.radiusTR = GetValue$38(value, 'tr', 0);
                this.radiusBL = GetValue$38(value, 'bl', 0);
                this.radiusBR = GetValue$38(value, 'br', 0);
            }
        }

        setRadius(radius) {
            if (radius === undefined) {
                radius = 0;
            }
            this.radius = radius;
            return this;
        }

        get iterations() {
            return this._iterations;
        }

        set iterations(value) {
            this.dirty = this.dirty || (this._iterations !== value);
            this._iterations = value;
        }

        setIterations(iterations) {
            this.iterations = iterations;
            return this;
        }

        updateData() {
            var pathData = this.pathData;
            pathData.length = 0;

            var width = this.width, height = this.height,
                radius,
                iterations = this.iterations + 1;

            // top-left
            radius = this.radiusTL;
            if (radius > 0) {
                if (this._convexTL) {
                    var centerX = radius;
                    var centerY = radius;
                    ArcTo$1(centerX, centerY, radius, radius, 180, 270, false, iterations, pathData);
                } else {
                    var centerX = 0;
                    var centerY = 0;
                    ArcTo$1(centerX, centerY, radius, radius, 90, 0, true, iterations, pathData);
                }
            } else {
                LineTo(0, 0, pathData);
            }

            // top-right
            radius = this.radiusTR;
            if (radius > 0) {
                if (this._convexTR) {
                    var centerX = width - radius;
                    var centerY = radius;
                    ArcTo$1(centerX, centerY, radius, radius, 270, 360, false, iterations, pathData);
                } else {
                    var centerX = width;
                    var centerY = 0;
                    ArcTo$1(centerX, centerY, radius, radius, 180, 90, true, iterations, pathData);
                }
            } else {
                LineTo(width, 0, pathData);
            }

            // bottom-right
            radius = this.radiusBR;
            if (radius > 0) {
                if (this._convexBR) {
                    var centerX = width - radius;
                    var centerY = height - radius;
                    ArcTo$1(centerX, centerY, radius, radius, 0, 90, false, iterations, pathData);
                } else {
                    var centerX = width;
                    var centerY = height;
                    ArcTo$1(centerX, centerY, radius, radius, 270, 180, true, iterations, pathData);
                }
            } else {
                LineTo(width, height, pathData);
            }

            // bottom-left
            radius = this.radiusBL;
            if (radius > 0) {
                if (this._convexBL) {
                    var centerX = radius;
                    var centerY = height - radius;
                    ArcTo$1(centerX, centerY, radius, radius, 90, 180, false, iterations, pathData);
                } else {
                    var centerX = 0;
                    var centerY = height;
                    ArcTo$1(centerX, centerY, radius, radius, 360, 270, true, iterations, pathData);
                }
            } else {
                LineTo(0, height, pathData);
            }

            pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
            Offset(this.x, this.y, pathData);

            super.updateData();
            return this;
        }
    }

    const GetTint = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;

    let Triangle$1 = class Triangle extends BaseGeom {
        constructor(x0, y0, x1, y1, x2, y2) {
            if (x0 === undefined) { x0 = 0; }
            if (y0 === undefined) { y0 = 0; }
            if (x1 === undefined) { x1 = 0; }
            if (y1 === undefined) { y1 = 0; }
            if (x2 === undefined) { x2 = 0; }
            if (y2 === undefined) { y2 = 0; }

            super();

            this.pathData = [];
            this.closePath = true;

            this.setP0(x0, y0);
            this.setP1(x1, y1);
            this.setP2(x2, y2);
        }

        get x0() {
            return this._x0;
        }

        set x0(value) {
            this.dirty = this.dirty || (this._x0 !== value);
            this._x0 = value;
        }

        get y0() {
            return this._y0;
        }

        set y0(value) {
            this.dirty = this.dirty || (this._y0 !== value);
            this._y0 = value;
        }

        setP0(x, y) {
            this.x0 = x;
            this.y0 = y;
            return this;
        }

        get x1() {
            return this._x1;
        }

        set x1(value) {
            this.dirty = this.dirty || (this._x1 !== value);
            this._x1 = value;
        }

        get y1() {
            return this._y1;
        }

        set y1(value) {
            this.dirty = this.dirty || (this._y1 !== value);
            this._y1 = value;
        }

        setP1(x, y) {
            this.x1 = x;
            this.y1 = y;
            return this;
        }

        get x2() {
            return this._x2;
        }

        set x2(value) {
            this.dirty = this.dirty || (this._x2 !== value);
            this._x2 = value;
        }

        get y2() {
            return this._y2;
        }

        set y2(value) {
            this.dirty = this.dirty || (this._y2 !== value);
            this._y2 = value;
        }

        setP2(x, y) {
            this.dirty = this.dirty || (this.x2 !== x) || (this.y2 !== y);
            this.x2 = x;
            this.y2 = y;
            return this;
        }

        updateData() {
            this.pathData.length = 0;
            this.pathData.push(this.x0, this.y0);
            this.pathData.push(this.x1, this.y1);
            this.pathData.push(this.x2, this.y2);
            this.pathData.push(this.x0, this.y0);

            super.updateData();
            return this;
        }

        webglRender(pipeline, calcMatrix, alpha, dx, dy) {
            if (this.isFilled) {
                var fillTintColor = GetTint(this.fillColor, this.fillAlpha * alpha);

                var x0 = this.x0 - dx;
                var y0 = this.y0 - dy;
                var x1 = this.x1 - dx;
                var y1 = this.y1 - dy;
                var x2 = this.x2 - dx;
                var y2 = this.y2 - dy;

                var tx0 = calcMatrix.getX(x0, y0);
                var ty0 = calcMatrix.getY(x0, y0);
                var tx1 = calcMatrix.getX(x1, y1);
                var ty1 = calcMatrix.getY(x1, y1);
                var tx2 = calcMatrix.getX(x2, y2);
                var ty2 = calcMatrix.getY(x2, y2);

                pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
            }

            if (this.isStroked) {
                StrokePathWebGL(pipeline, this, alpha, dx, dy);
            }
        }

        canvasRender(ctx, dx, dy) {
            var x1 = this.x1 - dx;
            var y1 = this.y1 - dy;
            var x2 = this.x2 - dx;
            var y2 = this.y2 - dy;
            var x3 = this.x3 - dx;
            var y3 = this.y3 - dy;

            ctx.beginPath();

            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);

            ctx.closePath();

            if (this.isFilled) {
                FillStyleCanvas(ctx, this);
                ctx.fill();
            }

            if (this.isStroked) {
                LineStyleCanvas(ctx, this);
                ctx.stroke();
            }
        }
    };

    var ShapesUpdateMethods$4 = {
        buildShapes() {
            this
                .addShape(new RoundRectangle().setName('box'))
                .addShape(new Lines().setName('checker'));
        },

        updateShapes() {
            var centerX = this.width / 2,
                centerY = this.height / 2,
                radius = Math.min(centerX, centerY);
            var width = radius * 2;
            var x = centerX - radius,
                y = centerY - radius;

            var boxLineWidth = this.boxLineWidth;
            var checkLineWidth = Math.max(width / 10, 2);

            var boxShape = this.getShape('box');
            var checkerShape = this.getShape('checker');

            // Setup shapes
            if (this.isSizeChanged) {
                // Box
                var posOffset = width * (1 - this.boxSize) / 2;
                var halfBoxLineWidth = boxLineWidth / 2;
                var boxInnerWidth = (width * this.boxSize) - boxLineWidth;
                boxShape
                    .setTopLeftPosition(x + halfBoxLineWidth + posOffset, y + halfBoxLineWidth + posOffset)
                    .setSize(boxInnerWidth, boxInnerWidth);

                if (this.isCircleShape) {
                    boxShape.setRadius(boxInnerWidth / 2);
                } else {
                    boxShape.setRadius(0);
                }

                // Checker
                var posOffset = width * (1 - this.checkerSize) / 2;
                var unit = (width * this.checkerSize) / 4;
                var u1 = unit * 1, u2 = unit * 2, u3 = unit * 3;
                checkerShape
                    .startAt(u1, u2)
                    .lineTo(u2, u3)
                    .lineTo(u3, u1)
                    .offset(x + posOffset, y + posOffset)
                    .end();
            }

            // Set styles
            if (this.checked) {
                boxShape
                    .fillStyle(this.boxFillColor, this.boxFillAlpha)
                    .lineStyle(boxLineWidth, this.boxStrokeColor, this.boxStrokeAlpha);

                checkerShape
                    .lineStyle(checkLineWidth, this.checkerColor);
            } else {
                boxShape
                    .fillStyle(this.uncheckedBoxFillColor, this.uncheckedBoxFillAlpha)
                    .lineStyle(boxLineWidth, this.uncheckedBoxStrokeColor, this.uncheckedBoxStrokeAlpha);

                checkerShape
                    .lineStyle();
            }

            // Play checker animation
            if (this.checked) {
                checkerShape.setDisplayPathSegment(this.checkerAnimProgress);
            }
        }
    };

    const GetValue$37 = Phaser.Utils.Objects.GetValue;
    const Linear$n = Phaser.Math.Linear;

    class EaseValueTask extends EaseValueTaskBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;
            // this.timer

            this.resetFromJSON();
            this.boot();
        }

        start(config) {
            if (this.timer.isRunning) {
                return this;
            }

            var target = this.target;
            this.propertyKey = GetValue$37(config, 'key', 'value');
            var currentValue = target[this.propertyKey];
            this.fromValue = GetValue$37(config, 'from', currentValue);
            this.toValue = GetValue$37(config, 'to', currentValue);

            this.setEase(GetValue$37(config, 'ease', this.ease));
            this.setDuration(GetValue$37(config, 'duration', this.duration));
            this.setRepeat(GetValue$37(config, 'repeat', 0));
            this.setDelay(GetValue$37(config, 'delay', 0));
            this.setRepeatDelay(GetValue$37(config, 'repeatDelay', 0));

            this.timer
                .setDuration(this.duration)
                .setRepeat(this.repeat)
                .setDelay(this.delay)
                .setRepeatDelay(this.repeatDelay);

            target[this.propertyKey] = this.fromValue;

            super.start();
            return this;
        }

        updateTarget(target, timer) {
            var t = timer.t;
            t = this.easeFn(t);

            target[this.propertyKey] = Linear$n(this.fromValue, this.toValue, t);
        }
    }

    var CheckerAnimationMethods = {
        setCheckerAnimationDuration(duration) {
            if (duration === undefined) {
                duration = 0;
            }
            this.checkerAnimDuration = duration;
            return this;
        },

        playCheckerAnimation() {
            if (this.checkerAnimProgressTask === undefined) {
                this.checkerAnimProgressTask = new EaseValueTask(this, { eventEmitter: null });
            }

            this.checkerAnimProgressTask.restart({
                key: 'checkerAnimProgress',
                from: 0,
                to: 1,
                duration: this.checkerAnimDuration,
            });

            return this;
        },

        stopCheckerAnimation() {
            if (this.checkerAnimProgressTask === undefined) {
                return this;
            }

            this.checkerAnimProgressTask.stop();
            return this;
        },

    };

    var methods$C = {

    };
    Object.assign(
        methods$C,
        StyleMethods$2,
        SizeMethods$1,
        ShapesUpdateMethods$4,
        CheckerAnimationMethods,
    );

    const DefaultBoxFillColor = 0x005cb2;
    const DefaultCheckerColor = 0xffffff;

    const GetValue$36 = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$L = Phaser.Utils.Objects.IsPlainObject;

    class CheckboxShape extends BaseShapes {
        constructor(scene, x, y, width, height, color, config) {
            if (IsPlainObject$L(x)) {
                config = x;
                x = GetValue$36(config, 'x', 0);
                y = GetValue$36(config, 'y', 0);
                width = GetValue$36(config, 'width', 2);
                height = GetValue$36(config, 'height', 2);
                color = GetValue$36(config, 'color', DefaultBoxFillColor);
            } else if (IsPlainObject$L(color)) {
                config = color;
                color = GetValue$36(config, 'color', DefaultBoxFillColor);
            }

            super(scene, x, y, width, height);
            this.type = 'rexCheckbox';

            if (color === undefined) {
                color = DefaultBoxFillColor;
            }

            this.setBoxShape(
                GetValue$36(config, 'circleBox', false),
            );

            this.setBoxFillStyle(
                color,
                GetValue$36(config, 'boxFillAlpha', 1)
            );

            this.setUncheckedBoxFillStyle(
                GetValue$36(config, 'uncheckedColor', null),
                GetValue$36(config, 'uncheckedBoxFillAlpha', 1)
            );

            this.setBoxStrokeStyle(
                GetValue$36(config, 'boxLineWidth', 4),
                GetValue$36(config, 'boxStrokeColor', color),
                GetValue$36(config, 'boxStrokeAlpha', 1)
            );

            this.setUncheckedBoxStrokeStyle(
                this.boxLineWidth,
                GetValue$36(config, 'uncheckedBoxStrokeColor', this.boxStrokeColor),
                GetValue$36(config, 'uncheckedBoxStrokeAlpha', this.boxStrokeAlpha)
            );


            this.setCheckerStyle(
                GetValue$36(config, 'checkerColor', DefaultCheckerColor),
                GetValue$36(config, 'checkerAlpha', 1)
            );

            this.setBoxSize(
                GetValue$36(config, 'boxSize', 1)
            );

            this.setCheckerSize(
                GetValue$36(config, 'checkerSize', 1)
            );

            this.setCheckerAnimationDuration(
                GetValue$36(config, 'animationDuration', 150)
            );

            this.buildShapes();

            var value = GetValue$36(config, 'checked');
            if (value === undefined) {
                value = GetValue$36(config, 'value', false);
            }
            this.setValue(value);
        }

        get value() {
            return this._value;
        }

        set value(value) {
            value = !!value;

            if (this._value === value) {
                return;
            }

            this.dirty = true;
            this._value = value;

            if (value) {
                this.playCheckerAnimation();
            } else {
                this.stopCheckerAnimation();
            }

            this.emit('valuechange', value);
        }

        setValue(value) {
            this.value = value;
            return this;
        }

        toggleValue() {
            this.setValue(!this.value);
            return this;
        }

        get checked() {
            return this.value;
        }

        set checked(value) {
            this.value = value;
        }

        setChecked(checked) {
            if (checked === undefined) {
                checked = true;
            }
            this.setValue(checked);
            return this;
        }

        toggleChecked() {
            this.toggleValue();
            return this;
        }

        get checkerAnimProgress() {
            return this._checkerAnimProgress;
        }

        set checkerAnimProgress(value) {
            if (this._checkerAnimProgress === value) {
                return;
            }

            this._checkerAnimProgress = value;
            this.dirty = true;
        }
    }

    Object.assign(
        CheckboxShape.prototype,
        methods$C,
    );

    const GetValue$35 = Phaser.Utils.Objects.GetValue;

    class Button extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            this._enable = undefined;
            gameObject.setInteractive(GetValue$35(config, "inputConfig", undefined));
            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.pointer = undefined;
            this.lastClickTime = undefined;
            this.isDown = false;
            this.isOver = false;
            this.setEnable(GetValue$35(o, "enable", true));
            this.setMode(GetValue$35(o, "mode", 1));
            this.setClickInterval(GetValue$35(o, "clickInterval", 100));
            this.setDragThreshold(GetValue$35(o, 'threshold', undefined));
            return this;
        }

        boot() {
            var gameObject = this.parent;
            gameObject.on('pointerdown', this.onPress, this);
            gameObject.on('pointerup', this.onRelease, this);
            gameObject.on('pointerout', this.onPointOut, this);
            gameObject.on('pointermove', this.onMove, this);

            gameObject.on('pointerover', this.onOver, this);
            gameObject.on('pointerout', this.onOut, this);
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            // GameObject events will be removed when this gameObject destroyed 
            // this.parent.on('pointerdown', this.onPress, this);
            // this.parent.on('pointerup', this.onRelease, this);
            // this.parent.on('pointerout', this.onPointOut, this);
            // this.parent.on('pointermove', this.onMove, this);
            this.pointer = null;

            super.shutdown(fromScene);
        }

        get enable() {
            return this._enable;
        }

        set enable(e) {
            if (this._enable === e) {
                return;
            }

            if (!e) {
                this.cancel();
            }
            this._enable = e;

            var eventName = (e) ? 'enable' : 'disable';
            this.emit(eventName, this, this.parent);
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        setMode(m) {
            if (typeof (m) === 'string') {
                m = CLICKMODE$1[m];
            }
            this.mode = m;
            return this;
        }

        setClickInterval(interval) {
            this.clickInterval = interval; // ms
            return this;
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }

        // internal
        onPress(pointer, localX, localY, event) {
            if (this.pointer !== undefined) {
                return;
            }

            this.pointer = pointer;

            this.isDown = true;
            this.emit('down', this, this.parent, pointer, event);

            if (this.mode === 0) {
                this.click(pointer.downTime, pointer, event);
            }

        }

        onRelease(pointer, localX, localY, event) {
            if (this.pointer !== pointer) {
                return;
            }

            this.isDown = false;
            this.emit('up', this, this.parent, pointer, event);

            if (this.mode === 1) {
                this.click(pointer.upTime, pointer, event);
            }

            this.pointer = undefined;
        }

        onPointOut(pointer, event) {
            if (this.pointer !== pointer) {
                return;
            }

            this.cancel();
        }

        onMove(pointer, localX, localY, event) {
            if (this.pointer !== pointer) {
                return;
            }

            if (this.dragThreshold === undefined) {
                return;
            }

            if (this.mode === 1) {
                if (pointer.getDistance() >= this.dragThreshold) {
                    this.cancel();
                }
            }
        }

        onOver(pointer, localX, localY, event) {
            if (!this.enable) {
                return this;
            }

            this.isOver = true;
            this.emit('over', this, this.parent, pointer, event);

            return this;
        }

        onOut(pointer, event) {
            if (!this.enable) {
                return this;
            }

            this.isOver = false;
            this.emit('out', this, this.parent, pointer, event);

            return this;
        }

        click(nowTime, pointer, event) {
            if (!this.enable) {
                return this;
            }

            if (nowTime === undefined) {
                // fires 'click' event manually
                this.emit('click', this, this.parent, pointer, event);
                return this;
            }

            this.pointer = undefined;
            var lastClickTime = this.lastClickTime;
            if ((lastClickTime !== undefined) &&
                ((nowTime - lastClickTime) <= this.clickInterval)) {
                return this;
            }
            this.lastClickTime = nowTime;
            this.emit('click', this, this.parent, pointer, event);
            return this;
        }

        cancel() {
            this.pointer = undefined;
            return this;
        }

    }

    const CLICKMODE$1 = {
        press: 0,
        pointerdown: 0,
        release: 1,
        pointerup: 1,
    };

    const GetValue$34 = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$K = Phaser.Utils.Objects.IsPlainObject;

    class Checkbox extends CheckboxShape {
        constructor(scene, x, y, width, height, color, config) {
            if (IsPlainObject$K(x)) {
                config = x;
                x = GetValue$34(config, 'x', 0);
                y = GetValue$34(config, 'y', 0);
                width = GetValue$34(config, 'width', 2);
                height = GetValue$34(config, 'height', 2);
                color = GetValue$34(config, 'color', DefaultBoxFillColor);
            } else if (IsPlainObject$K(color)) {
                config = color;
                color = GetValue$34(config, 'color', DefaultBoxFillColor);
            }

            super(scene, x, y, width, height, color, config);

            this._click = new Button(this, GetValue$34(config, 'click'));
            this._click.on('click', function () {
                this.toggleValue();
            }, this);

            this.setReadOnly(GetValue$34(config, 'readOnly', false));
        }

        get readOnly() {
            return !this._click.enable;
        }

        set readOnly(value) {
            this._click.enable = !value;
        }

        setReadOnly(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.readOnly = enable;
            return this;
        }
    }

    ObjectFactory.register('checkbox', function (x, y, width, height, color, config) {
        var gameObject = new Checkbox(this.scene, x, y, width, height, color, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Checkbox', Checkbox);

    var StyleMethods = {
        setTrackFillStyle(color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.dirty = this.dirty ||
                (this.trackFillColor !== color) ||
                (this.trackFillAlpha !== alpha);

            this.trackFillColor = color;
            this.trackFillAlpha = alpha;
            return this;
        },

        setFalseValueTrackFillStyle(color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.dirty = this.dirty ||
                (this.falseValueTrackColor !== color) ||
                (this.uncheckedTrackFillAlpha !== alpha);

            this.falseValueTrackColor = color;
            this.falseValueTrackFillAlpha = alpha;
            return this;
        },

        setThumbStyle(color, alpha) {
            if (alpha === undefined) {
                alpha = 1;
            }
            this.dirty = this.dirty ||
                (this.thumbColor !== color) ||
                (this.checkAlpha !== alpha);

            this.thumbColor = color;
            this.thumbAlpha = alpha;
            return this;
        },

    };

    var SizeMethods = {
        setTrackSize(width, height) {
            this.dirty = this.dirty ||
                (this.trackWidth !== width) ||
                (this.trackHeight !== height);

            this.trackWidth = width;
            this.trackHeight = height;
            return this;
        },

        setTrackRadius(radius) {
            this.dirty = this.dirty ||
                (this.trackRadius !== radius);

            this.trackRadius = radius;
            return this;
        },

        setThumbSize(width, height) {
            if (height === undefined) {
                height = width;
            }
            this.dirty = this.dirty ||
                (this.thumbWidth !== width) ||
                (this.thumbHeight !== height);

            this.thumbWidth = width;
            this.thumbHeight = height;
            return this;
        },

        setThumbRadius(radius) {       
            this.dirty = this.dirty ||
                (this.thumbRadius !== radius);

            this.thumbRadius = radius;
            return this;
        },

    };

    var PositionMethods = {
        setThumbPosition(left, right) {
            if (right === undefined) {
                right = 1 - left;
            }

            this.thumbLeftX = left;
            this.thumbRightX = right;
            return this;
        },

        setRTL(rtl) {
            if (rtl === undefined) {
                rtl = true;
            }
            this.rtl = rtl;
            return this;
        }
    };

    /**
     * @author       Richard Davey <rich@photonstorm.com>
     * @copyright    2019 Photon Storm Ltd.
     * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
     */

    /**
     * Calculates a linear (interpolation) value over t.
     *
     * @function Phaser.Math.Linear
     * @since 3.0.0
     *
     * @param {number} p0 - The first point.
     * @param {number} p1 - The second point.
     * @param {number} t - The percentage between p0 and p1 to return, represented as a number between 0 and 1.
     *
     * @return {number} The step t% of the way between p0 and p1.
     */
    var Linear$m = function (p0, p1, t)
    {
        return (p1 - p0) * t + p0;
    };

    var MixColor = function (color0, color1, t) {
        var r = Linear$m(GetR(color0), GetR(color1), t);
        var g = Linear$m(GetG(color0), GetG(color1), t);
        var b = Linear$m(GetB(color0), GetB(color1), t);
        return ((r & 0xff) << 16) | ((g & 0xff) << 8) | ((b & 0xff));
    };

    const Linear$l = Phaser.Math.Linear;

    var ShapesUpdateMethods$3 = {
        buildShapes() {
            this
                .addShape(new RoundRectangle().setName('track'))
                .addShape(new RoundRectangle().setName('thumb'));
        },

        updateShapes() {
            var width = this.width,
                height = this.height;

            var toggleAnimProgress = (this.value) ? this.toggleAnimProgress : (1 - this.toggleAnimProgress);

            // Track
            var trackShape = this.getShape('track');
            if (this.isSizeChanged) {
                var trackWidth = width * this.trackWidth,
                    trackHeight = height * this.trackHeight,
                    trackX = (width - trackWidth) / 2,
                    trackY = (height - trackHeight) / 2,
                    trackRadius = height * this.trackRadius;

                trackShape
                    .setTopLeftPosition(trackX, trackY)
                    .setSize(trackWidth, trackHeight)
                    .setRadius(trackRadius);

            }

            var trackFillColor = MixColor(this.falseValueTrackColor, this.trackFillColor, toggleAnimProgress);
            var trackFillAlpha = Linear$l(this.falseValueTrackFillAlpha, this.trackFillAlpha, toggleAnimProgress);
            trackShape
                .fillStyle(trackFillColor, trackFillAlpha);

            // Thumb
            var thumbShape = this.getShape('thumb');
            if (this.isSizeChanged) {
                var thumbWidth = width * this.thumbWidth,
                    thumbHeight = height * this.thumbHeight,
                    thumbRadius = height * this.thumbRadius;

                thumbShape
                    .setSize(thumbWidth, thumbHeight)
                    .setRadius(thumbRadius);
            }

            var thumbX = Linear$l(this.thumbLeftX, this.thumbRightX, toggleAnimProgress) * width;
            if (this.rtl) {
                thumbX = width - thumbX;
            }
            var thumbY = height / 2;
            thumbShape
                .setCenterPosition(thumbX, thumbY);

            thumbShape
                .fillStyle(this.thumbColor, this.thumbAlpha);
        }


    };

    var ToggleAnimationMethods = {
        setToggleAnimationDuration(duration) {
            if (duration === undefined) {
                duration = 0;
            }
            this.toggleAnimDuration = duration;
            return this;
        },

        playToggleAnimation() {
            if (this.toggleAnimProgressTask === undefined) {
                this.toggleAnimProgressTask = new EaseValueTask(this, { eventEmitter: null });
            }

            this.toggleAnimProgressTask.restart({
                key: 'toggleAnimProgress',
                from: 0,
                to: 1,
                duration: this.toggleAnimDuration,
            });

            return this;
        },

        stopToggleAnimation() {
            if (this.toggleAnimProgressTask === undefined) {
                return this;
            }

            this.toggleAnimProgressTask.stop();
            return this;
        },

    };

    var methods$B = {

    };
    Object.assign(
        methods$B,
        StyleMethods,
        SizeMethods,
        PositionMethods,
        ShapesUpdateMethods$3,
        ToggleAnimationMethods,
    );

    var GrayScale = function (color) {
        var shade = 0.3 * GetR(color) + 0.59 * GetG(color) + 0.11 * GetB(color);
        return ((shade & 0xff) << 16) | ((shade & 0xff) << 8) | ((shade & 0xff));
    };

    const GetValue$33 = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$J = Phaser.Utils.Objects.IsPlainObject;
    const DefaultTrackFillColor = 0x005cb2;
    const DefaultThumbFillColor = 0xffffff;

    class ToggleSwitchShape extends BaseShapes {
        constructor(scene, x, y, width, height, color, config) {
            if (IsPlainObject$J(x)) {
                config = x;
                x = GetValue$33(config, 'x', 0);
                y = GetValue$33(config, 'y', 0);
                width = GetValue$33(config, 'width', 2);
                height = GetValue$33(config, 'height', 2);
                color = GetValue$33(config, 'color', DefaultTrackFillColor);
            } else if (IsPlainObject$J(color)) {
                config = color;
                color = GetValue$33(config, 'color', DefaultTrackFillColor);
            }

            super(scene, x, y, width, height);
            this.type = 'rexToggleSwitch';

            if (color === undefined) {
                color = DefaultTrackFillColor;
            }

            this.setTrackFillStyle(
                color,
                GetValue$33(config, 'trackFillAlpha', 1)
            );

            this.setFalseValueTrackFillStyle(
                GetValue$33(config, 'falseValueTrackColor', GrayScale(color)),
                GetValue$33(config, 'falseValueTrackFillAlpha', 1)
            );

            this.setThumbStyle(
                GetValue$33(config, 'thumbColor', DefaultThumbFillColor),
                GetValue$33(config, 'thumbAlpha', 1)
            );

            this.setTrackSize(
                GetValue$33(config, 'trackWidth', 0.9),
                GetValue$33(config, 'trackHeight', 0.5),
            );

            this.setTrackRadius(
                GetValue$33(config, 'trackRadius', this.trackHeight * 0.5)
            );

            var thumbHeight = GetValue$33(config, 'thumbHeight', undefined);
            var thumbWidth = GetValue$33(config, 'thumbWidth', thumbHeight);
            if (thumbWidth === undefined) {
                thumbWidth = this.trackHeight * 0.9;
            }
            this.setThumbSize(thumbWidth, thumbHeight);

            this.setThumbRadius(
                GetValue$33(config, 'thumbRadius', this.thumbHeight * 0.5)
            );

            this.setThumbPosition(
                GetValue$33(config, 'thumbLeft', 0.3),
                GetValue$33(config, 'thumbRight', undefined),
            );

            this.setRTL(GetValue$33(config, 'rtl', false));

            this.setToggleAnimationDuration(
                GetValue$33(config, 'animationDuration', 150)
            );

            this.buildShapes();

            this.setValue(GetValue$33(config, 'value', false), 0);

        }

        get value() {
            return this._value;
        }

        set value(value) {
            value = !!value;

            if (this._value === value) {
                return;
            }

            this.dirty = true;
            this._value = value;

            this.playToggleAnimation();

            this.emit('valuechange', value);
        }

        setValue(value, duration) {
            if (duration === undefined) {
                duration = this.toggleAnimDuration;
            }

            var durationSave = this.toggleAnimDuration;
            this.toggleAnimDuration = duration;

            this.value = value;

            this.toggleAnimDuration = durationSave;
            return this;
        }

        toggleValue(duration) {
            this.setValue(!this.value, duration);
            return this;
        }

        get toggleAnimProgress() {
            return this._toggleAnimProgress;
        }

        set toggleAnimProgress(value) {
            if (this._toggleAnimProgress === value) {
                return;
            }

            this._toggleAnimProgress = value;
            this.dirty = true;
        }
    }

    Object.assign(
        ToggleSwitchShape.prototype,
        methods$B,
    );

    const GetValue$32 = Phaser.Utils.Objects.GetValue;

    class ToggleSwitch extends ToggleSwitchShape {
        constructor(scene, x, y, width, height, color, config) {
            super(scene, x, y, width, height, color, config);

            this._click = new Button(this, GetValue$32(config, 'click'));
            this._click.on('click', function () {
                this.toggleValue();
            }, this);

            this.setReadOnly(GetValue$32(config, 'readOnly', false));
        }

        get readOnly() {
            return !this._click.enable;
        }

        set readOnly(value) {
            this._click.enable = !value;
        }

        setReadOnly(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.readOnly = enable;
            return this;
        }
    }

    ObjectFactory.register('toggleSwitch', function (x, y, width, height, color, config) {
        var gameObject = new ToggleSwitch(this.scene, x, y, width, height, color, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ToggleSwitch', ToggleSwitch);

    var LoadImageMethods = {
        loadFromURL(url, callback) {
            var self = this;
            var img = new Image();
            img.onload = function () {
                if ((self.width !== img.width) || (self.height !== img.height)) {
                    self.resize(img.width, img.height);
                } else {
                    self.clear();
                }
                self.context.drawImage(img, 0, 0);
                self.updateTexture();

                if (callback) {
                    callback();
                }

                img.onload = null;
                img.src = '';
                img.remove();
            };
            img.src = url;
            return this;
        },

        loadFromURLPromise(url) {
            var self = this;
            return new Promise(function (resolve, reject) {
                self.loadFromURL(url, resolve);
            });
        },

        loadFromFile(file, callback) {
            var url = URL.createObjectURL(file);
            this.loadFromURL(url, function () {
                URL.revokeObjectURL(url);
                if (callback) {
                    callback();
                }
            });

            return this;
        },

        loadFromFilePromise(file) {
            var self = this;
            return new Promise(function (resolve, reject) {
                self.loadFromFile(file, resolve);
            });
        }
    };

    class Canvas extends Canvas$1 {

    }

    Object.assign(
        Canvas.prototype,
        LoadImageMethods,
    );

    ObjectFactory.register('canvas', function (x, y, width, height) {
        var gameObject = new Canvas(this.scene, x, y, width, height);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Canvas', Canvas);

    const GetValue$31 = Phaser.Utils.Objects.GetValue;

    class CircleMaskImage extends Canvas$1 {
        constructor(scene, x, y, key, frame, config) {
            super(scene, x, y);

            this.type = 'rexCircleMaskImage';
            this.setTexture(key, frame, config);
        }

        setTexture(key, frame, config) {
            if (typeof (frame) === 'object') {
                config = frame;
                frame = undefined;
            }

            if (typeof (config) === 'string') {
                config = {
                    maskType: config
                };
            }

            var maskType = GetValue$31(config, 'maskType', 0);
            var backgroundColor = GetValue$31(config, 'backgroundColor', undefined);
            var strokeColor = GetValue$31(config, 'strokeColor', undefined);

            var defaultStrokeWidth = (strokeColor != null) ? 10 : 0;
            var strokeWidth = GetValue$31(config, 'strokeWidth', defaultStrokeWidth);

            if (maskType === undefined) {
                maskType = 0;
            } else if (typeof (maskType) === 'string') {
                maskType = MASKTYPE[maskType];
            }

            this._textureKey = key;
            this._frameName = frame;

            if (maskType === null) {
                this.loadTexture(key, frame);
                this.dirty = true;
                return this;
            }

            var textureFrame = this.scene.sys.textures.getFrame(key, frame);
            if (!textureFrame) {
                return this;
            }
            // Resize to frame size
            if ((textureFrame.cutWidth !== this.width) || (textureFrame.cutHeight !== this.height)) {
                this.setCanvasSize(textureFrame.cutWidth, textureFrame.cutHeight);
            } else {
                this.clear();
            }

            var canvas = this.canvas,
                ctx = this.context;
            var width = canvas.width,
                height = canvas.height;

            // Fill background
            if (backgroundColor != null) {
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, width, height);
            }

            ctx.save();
            ctx.beginPath();

            // Build clip path 
            var halfStrokeLineWidth = strokeWidth / 2;
            switch (maskType) {
                case 1:  // ellipse
                    var centerX = Math.floor(width / 2);
                    var centerY = Math.floor(height / 2);
                    var radiusX = centerX - halfStrokeLineWidth;
                    var radiusY = centerY - halfStrokeLineWidth;
                    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, (2 * Math.PI));
                    break;

                case 2:
                    var radiusConfig = GetValue$31(config, 'radius', 0);
                    var iteration = GetValue$31(config, 'iteration', undefined);

                    AddRoundRectanglePath(
                        ctx,
                        halfStrokeLineWidth, halfStrokeLineWidth,
                        width - strokeWidth, height - strokeWidth,
                        radiusConfig,
                        iteration
                    );
                    break;

                default: // circle
                    var centerX = Math.floor(width / 2);
                    var centerY = Math.floor(height / 2);
                    var radius = Math.min(centerX, centerY) - halfStrokeLineWidth;
                    ctx.arc(centerX, centerY, radius, 0, (2 * Math.PI));
                    break;
            }

            // Draw stroke line
            if (strokeColor != null) {
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = strokeWidth;
                ctx.stroke();
            }

            // Clip frame image
            ctx.clip();
            this.loadTexture(key, frame);
            ctx.restore();

            this.dirty = true;
            return this;
        }

        resize(width, height) {
            // Don't draw content again.
            this.setDisplaySize(width, height);
            return this;
        }
    }

    const MASKTYPE = {
        circle: 0,
        ellipse: 1,
        roundRectangle: 2
    };

    ObjectFactory.register('circleMaskImage', function (x, y, key, frame, config) {
        var gameObject = new CircleMaskImage(this.scene, x, y, key, frame, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.CircleMaskImage', CircleMaskImage);

    const GetValue$30 = Phaser.Utils.Objects.GetValue;

    class AlphaMaskImage extends Canvas$1 {
        constructor(scene, x, y, key, frame, config) {
            super(scene, x, y);

            this.type = 'rexAlphaMaskImage';
            this.maskFrame = null;
            this.setTexture(key, frame, config);
        }

        setTexture(key, frame, config) {
            if (typeof (frame) === 'object') {
                config = frame;
                frame = undefined;
            }

            if (typeof (config) === 'string') {
                config = {
                    mask: {
                        key: config
                    }
                };
            }

            var maskKey = GetValue$30(config, 'mask.key');
            var maskFrame = GetValue$30(config, 'mask.frame');
            var invertMaskAlpha = GetValue$30(config, 'mask.invertAlpha', false);
            var maskScale = GetValue$30(config, 'mask.scale');
            var backgroundColor = GetValue$30(config, 'backgroundColor');

            if (maskKey) {
                this._maskKey = maskKey;
                this._maskFrame = maskFrame;
                this._maskScale = maskScale;

                var texture = (maskKey) ? this.scene.sys.textures.get(maskKey) : null;
                this.maskFrame = (texture) ? texture.get(maskFrame) : null;
            }

            this._textureKey = key;
            this._frameName = frame;

            var maskTextureFrame = this.maskFrame;
            if (maskTextureFrame === null) {
                this.loadTexture(key, frame);
                this.dirty = true;
                return this;
            }

            var hasBackgroundColor = (backgroundColor != null);
            this.loadTexture(key, frame);

            // Draw mask
            var canvas = this.canvas,
                ctx = this.context;
            var width = canvas.width,
                height = canvas.height;

            ctx.save();
            ctx.globalCompositeOperation = (invertMaskAlpha) ? 'destination-out' : 'destination-in';

            var maskWidth, maskHeight;
            if (this._maskScale != null) {
                maskWidth = maskTextureFrame.cutWidth * this._maskScale;
                maskHeight = maskTextureFrame.cutHeight * this._maskScale;
            } else {
                maskWidth = width;
                maskHeight = height;
            }
            var maskX = (width - maskWidth) / 2;
            var maskY = (height - maskHeight) / 2;

            this.drawFrame(
                this._maskKey, this._maskFrame,
                maskX, maskY, maskWidth, maskHeight
            );

            ctx.restore();

            if (hasBackgroundColor) {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, width, height);
                ctx.restore();
            }

            this.dirty = true;
            return this;
        }

        resize(width, height) {
            // Don't draw content again.
            this.setDisplaySize(width, height);
            return this;
        }
    }

    ObjectFactory.register('alphaMaskImage', function (x, y, key, frame, config) {
        var gameObject = new AlphaMaskImage(this.scene, x, y, key, frame, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.AlphaMaskImage', AlphaMaskImage);

    const Linear$k = Phaser.Math.Linear;
    const Percent$5 = Phaser.Math.Percent;

    var ProgressValueMethods = {
        setValue(value, min, max) {
            if ((value === undefined) || (value === null)) {
                return this;
            }

            if (min !== undefined) {
                value = Percent$5(value, min, max);
            }
            this.value = value;
            return this;
        },

        addValue(inc, min, max) {
            if (min !== undefined) {
                inc = Percent$5(inc, min, max);
            }
            this.value += inc;
            return this;
        },

        getValue(min, max) {
            var value = this.value;
            if ((min !== undefined) && (max !== undefined)) {
                value = Linear$k(min, max, value);
            }
            return value;
        }
    };

    const Percent$4 = Phaser.Math.Percent;

    var EaseValueMethods$1 = {
        setEaseValuePropName(name) {
            this.easeValuePropName = name;
            return this;
        },

        setEaseValueDuration(duration) {
            this.easeValueDuration = duration;
            return this;
        },

        setEaseValueFunction(ease) {
            this.easeFunction = ease;
            return this;
        },

        stopEaseValue() {
            if (this.easeValueTask) {
                this.easeValueTask.stop();
            }
            return this;
        },

        easeValueTo(value, min, max) {
            if ((value === undefined) || (value === null)) {
                return this;
            }

            if (min !== undefined) {
                value = Percent$4(value, min, max);
            }

            if (this.easeValueTask === undefined) {
                this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
            }

            this.easeValueTask.restart({
                key: this.easeValuePropName,
                to: value,
                duration: this.easeValueDuration,
                ease: this.easeFunction,
            });

            return this;
        },

        easeValueRepeat(from, to, repeat, repeatDelay) {
            if (repeat === undefined) {
                repeat = -1;
            }
            if (repeatDelay === undefined) {
                repeatDelay = 0;
            }

            if (this.easeValueTask === undefined) {
                this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
            }

            this.easeValueTask.restart({
                key: this.easeValuePropName,
                from: from, to: to,
                duration: this.easeValueDuration,
                ease: this.easeFunction,
                repeat: repeat, repeatDelay: repeatDelay,
            });

            return this;
        },
    };

    const GetValue$2$ = Phaser.Utils.Objects.GetValue;
    const Clamp$d = Phaser.Math.Clamp;

    function ProgressBase (BaseClass) {
        class ProgressBase extends BaseClass {
            bootProgressBase(config) {
                this.eventEmitter = GetValue$2$(config, 'eventEmitter', this);

                var callback = GetValue$2$(config, 'valuechangeCallback', null);
                if (callback !== null) {
                    var scope = GetValue$2$(config, 'valuechangeCallbackScope', undefined);
                    this.eventEmitter.on('valuechange', callback, scope);
                }

                this
                    .setEaseValuePropName('value')
                    .setEaseValueDuration(GetValue$2$(config, 'easeValue.duration', 0))
                    .setEaseValueFunction(GetValue$2$(config, 'easeValue.ease', 'Linear'));

                return this;
            }

            get value() {
                return this._value;
            }

            set value(value) {
                value = Clamp$d(value, 0, 1);

                var oldValue = this._value;
                var valueChanged = (oldValue != value);
                this.dirty = this.dirty || valueChanged;
                this._value = value;

                if (valueChanged) {
                    this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
                }
            }
        }

        Object.assign(
            ProgressBase.prototype,
            ProgressValueMethods,
            EaseValueMethods$1
        );

        return ProgressBase;
    }

    const RadToDeg$c = Phaser.Math.RadToDeg;
    const DegToRad$c = Phaser.Math.DegToRad;

    var FillArc = function (shape, x, y, outerRadius, innerRadius, startAngle, endAngle, anticlockwise) {
        var isCircle = Math.abs(endAngle - startAngle) === 360;
        var radStartAngle = DegToRad$c(startAngle),
            radEndAngle = DegToRad$c(endAngle);
        var cosStartAngle = Math.cos(radStartAngle),
            sinStartAngle = Math.sin(radStartAngle),
            cosEndAngle = Math.cos(radEndAngle),
            sinEndAngle = Math.sin(radEndAngle);

        shape.startAt(x + (cosStartAngle * outerRadius), y + (sinStartAngle * outerRadius));
        shape.arc(x, y, outerRadius, startAngle, endAngle, anticlockwise);

        if (isCircle && (innerRadius === 0)) ; else {
            shape.lineTo(x + (cosEndAngle * innerRadius), y + (sinEndAngle * innerRadius));

            if (innerRadius > 0) {
                shape.arc(x, y, innerRadius, endAngle, startAngle, !anticlockwise);
            }
        }

        shape.close();
        return shape;
    };

    var ShapesUpdateMethods$2 = {
        buildShapes() {
            var iterations = this.iterations;

            this
                .addShape((new Lines()).setIterations(iterations).setName('track'))
                .addShape((new Lines()).setIterations(iterations).setName('bar'))
                .addShape((new Circle()).setIterations(iterations).setName('center'));
        },

        updateShapes() {
            var x = this.radius;
            var barWidth = this.thickness * this.radius;
            var barOuterRadius = this.radius;
            var barInnerRadius = barOuterRadius - barWidth;

            // Track shape
            var trackShape = this.getShape('track');
            if ((this.trackColor != null) && (this.thickness > 0)) {
                trackShape.fillStyle(this.trackColor);
                FillArc(trackShape, x, x, barOuterRadius, barInnerRadius, 0, 360, false);
            } else {
                trackShape.reset();
            }

            // Bar shape
            var barShape = this.getShape('bar');
            if ((this.barColor != null) && (this.thickness > 0)) {
                var anticlockwise, startAngle, endAngle;
                if (this.value === 1) {
                    anticlockwise = false;
                    startAngle = 0;
                    endAngle = 360;
                } else {
                    anticlockwise = this.anticlockwise;
                    startAngle = RadToDeg$c(this.startAngle);
                    var deltaAngle = 360 * ((anticlockwise) ? (1 - this.value) : this.value);
                    endAngle = deltaAngle + startAngle;
                }

                barShape.fillStyle(this.barColor);
                FillArc(barShape, x, x, barOuterRadius + 1, barInnerRadius - 1, startAngle, endAngle, false);

            } else {
                barShape.reset();
            }

            // Center shape
            var centerShape = this.getShape('center');
            if (this.centerColor && (barInnerRadius > 0)) {
                centerShape
                    .setCenterPosition(x, x)
                    .setRadius(barInnerRadius)
                    .fillStyle(this.centerColor);
            } else {
                centerShape.reset();
            }
        }
    };

    const GetValue$2_ = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$I = Phaser.Utils.Objects.IsPlainObject;
    const Clamp$c = Phaser.Math.Clamp;

    const DefaultStartAngle$1 = Phaser.Math.DegToRad(270);

    let CircularProgress$1 = class CircularProgress extends ProgressBase(BaseShapes) {
        constructor(scene, x, y, radius, barColor, value, config) {
            if (IsPlainObject$I(x)) {
                config = x;
                x = GetValue$2_(config, 'x', 0);
                y = GetValue$2_(config, 'y', 0);
                radius = GetValue$2_(config, 'radius', 1);
                barColor = GetValue$2_(config, 'barColor', undefined);
                value = GetValue$2_(config, 'value', 0);
            }

            if (radius === undefined) { radius = 1; }

            var width = radius * 2;
            super(scene, x, y, width, width);
            this.type = 'rexCircularProgress';

            this.bootProgressBase(config);

            this.setRadius(radius);
            this.setTrackColor(GetValue$2_(config, 'trackColor', undefined));
            this.setBarColor(barColor);
            this.setCenterColor(GetValue$2_(config, 'centerColor', undefined));

            this.setThickness(GetValue$2_(config, 'thickness', 0.2));
            this.setStartAngle(GetValue$2_(config, 'startAngle', DefaultStartAngle$1));
            this.setAnticlockwise(GetValue$2_(config, 'anticlockwise', false));

            this.iterations = GetValue$2_(config, 'iterations', 128);

            this.buildShapes();

            this.setValue(value);
        }

        resize(width, height) {
            width = Math.floor(Math.min(width, height));
            if (width === this.width) {
                return this;
            }

            super.resize(width, width);
            this.setRadius(width / 2);
            return this;
        }

        get radius() {
            return this._radius;
        }

        set radius(value) {
            this.dirty = this.dirty || (this._radius != value);
            this._radius = value;
            var width = value * 2;
            this.resize(width, width);
        }

        setRadius(radius) {
            this.radius = radius;
            return this;
        }

        get trackColor() {
            return this._trackColor;
        }

        set trackColor(value) {
            this.dirty = this.dirty || (this._trackColor != value);
            this._trackColor = value;
        }

        setTrackColor(color) {
            this.trackColor = color;
            return this;
        }

        get barColor() {
            return this._barColor;
        }

        set barColor(value) {
            this.dirty = this.dirty || (this._barColor != value);
            this._barColor = value;
        }

        setBarColor(color) {
            this.barColor = color;
            return this;
        }

        get startAngle() {
            return this._startAngle;
        }

        set startAngle(value) {
            this.dirty = this.dirty || (this._startAngle != value);
            this._startAngle = value;
        }

        setStartAngle(angle) {
            this.startAngle = angle;
            return this;
        }

        get anticlockwise() {
            return this._anticlockwise;
        }

        set anticlockwise(value) {
            this.dirty = this.dirty || (this._anticlockwise != value);
            this._anticlockwise = value;
        }

        setAnticlockwise(anticlockwise) {
            if (anticlockwise === undefined) {
                anticlockwise = true;
            }
            this.anticlockwise = anticlockwise;
            return this;
        }

        get thickness() {
            return this._thickness;
        }

        set thickness(value) {
            value = Clamp$c(value, 0, 1);
            this.dirty = this.dirty || (this._thickness != value);
            this._thickness = value;
        }

        setThickness(thickness) {
            this.thickness = thickness;
            return this;
        }

        get centerColor() {
            return this._centerColor;
        }

        set centerColor(value) {
            this.dirty = this.dirty || (this._centerColor != value);
            this._centerColor = value;
        }

        setCenterColor(color) {
            this.centerColor = color;
            return this;
        }

    };

    Object.assign(
        CircularProgress$1.prototype,
        ShapesUpdateMethods$2,
    );

    ObjectFactory.register('circularProgress', function (x, y, radius, barColor, value, config) {
        var gameObject = new CircularProgress$1(this.scene, x, y, radius, barColor, value, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.CircularProgress', CircularProgress$1);

    var DrawCircle = function (
        canvas, context,
        x, y,
        rx, ry,
        fillStyle, strokeStyle, lineWidth,
        startAngle, endAngle, anticlockwise
    ) {

        if (startAngle === undefined) {
            startAngle = 0;
        }
        if (endAngle === undefined) {
            endAngle = 2 * Math.PI;
        }
        if (anticlockwise === undefined) {
            anticlockwise = false;
        }

        context.beginPath();

        context.ellipse(x, y, rx, ry, 0, startAngle, endAngle, anticlockwise);

        if (fillStyle != null) {
            context.fillStyle = fillStyle;
            context.fill();
        }

        if (strokeStyle != null) {
            context.strokeStyle = strokeStyle;
            context.lineWidth = lineWidth;
            context.stroke();
        }
    };

    const ColorNames = ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGrey', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkSlateGrey', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DimGrey', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Grey', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGrey', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSlateGrey', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'RebeccaPurple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'SlateGrey', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];
    const ColorValues = [0xf0f8ff, 0xfaebd7, 0x00ffff, 0x7fffd4, 0xf0ffff, 0xf5f5dc, 0xffe4c4, 0x000000, 0xffebcd, 0x0000ff, 0x8a2be2, 0xa52a2a, 0xdeb887, 0x5f9ea0, 0x7fff00, 0xd2691e, 0xff7f50, 0x6495ed, 0xfff8dc, 0xdc143c, 0x00ffff, 0x00008b, 0x008b8b, 0xb8860b, 0xa9a9a9, 0xa9a9a9, 0x006400, 0xbdb76b, 0x8b008b, 0x556b2f, 0xff8c00, 0x9932cc, 0x8b0000, 0xe9967a, 0x8fbc8f, 0x483d8b, 0x2f4f4f, 0x2f4f4f, 0x00ced1, 0x9400d3, 0xff1493, 0x00bfff, 0x696969, 0x696969, 0x1e90ff, 0xb22222, 0xfffaf0, 0x228b22, 0xff00ff, 0xdcdcdc, 0xf8f8ff, 0xffd700, 0xdaa520, 0x808080, 0x808080, 0x008000, 0xadff2f, 0xf0fff0, 0xff69b4, 0xcd5c5c, 0x4b0082, 0xfffff0, 0xf0e68c, 0xe6e6fa, 0xfff0f5, 0x7cfc00, 0xfffacd, 0xadd8e6, 0xf08080, 0xe0ffff, 0xfafad2, 0xd3d3d3, 0xd3d3d3, 0x90ee90, 0xffb6c1, 0xffa07a, 0x20b2aa, 0x87cefa, 0x778899, 0x778899, 0xb0c4de, 0xffffe0, 0x00ff00, 0x32cd32, 0xfaf0e6, 0xff00ff, 0x800000, 0x66cdaa, 0x0000cd, 0xba55d3, 0x9370db, 0x3cb371, 0x7b68ee, 0x00fa9a, 0x48d1cc, 0xc71585, 0x191970, 0xf5fffa, 0xffe4e1, 0xffe4b5, 0xffdead, 0x000080, 0xfdf5e6, 0x808000, 0x6b8e23, 0xffa500, 0xff4500, 0xda70d6, 0xeee8aa, 0x98fb98, 0xafeeee, 0xdb7093, 0xffefd5, 0xffdab9, 0xcd853f, 0xffc0cb, 0xdda0dd, 0xb0e0e6, 0x800080, 0x663399, 0xff0000, 0xbc8f8f, 0x4169e1, 0x8b4513, 0xfa8072, 0xf4a460, 0x2e8b57, 0xfff5ee, 0xa0522d, 0xc0c0c0, 0x87ceeb, 0x6a5acd, 0x708090, 0x708090, 0xfffafa, 0x00ff7f, 0x4682b4, 0xd2b48c, 0x008080, 0xd8bfd8, 0xff6347, 0x40e0d0, 0xee82ee, 0xf5deb3, 0xffffff, 0xf5f5f5, 0xffff00, 0x9acd32];

    var ColorNameToIntegerDict = {}, name$1;
    for (var i = 0, cnt = ColorNames.length; i < cnt; i++) {
        name$1 = ColorNames[i].toLowerCase();
        ColorNameToIntegerDict[name$1] = ColorValues[i];
    }

    var ColorNameToInteger = function (colorName) {
        colorName = colorName.toLowerCase();
        if (ColorNameToIntegerDict.hasOwnProperty(colorName)) {
            return ColorNameToIntegerDict[colorName];
        } else {
            return null;
        }
    };

    var ColorStringToInteger = function (value) {
        if (typeof (value) !== 'string') {
            return value;
        }

        if (value.startsWith('#')) {
            value = parseInt(value.substring(1), 16);
        } else if (value.startsWith('0x')) {
            value = parseInt(value.substring(2), 16);
        } else {
            value = ColorNameToInteger(value);
        }
        return value;
    };

    const DegToRad$b = Phaser.Math.DegToRad;
    const Linear$j = Phaser.Math.Linear;

    var DrawGradientArc = function (
        canvas, context,
        x, y,
        rx, ry,
        startColor, endColor, lineWidth,
        startAngle, endAngle, anticlockwise, AngleStepDeg
    ) {

        if (startAngle === undefined) {
            startAngle = 0;
        }
        if (endAngle === undefined) {
            endAngle = 2 * Math.PI;
        }
        if (anticlockwise === undefined) {
            anticlockwise = false;
        }
        if (AngleStepDeg === undefined) {
            AngleStepDeg = 2;
        }

        startColor = ColorStringToInteger(startColor);
        endColor = ColorStringToInteger(endColor);

        StartRGB = GetRGB(startColor, StartRGB);
        EndRGB = GetRGB(endColor, EndRGB);

        var angleStep = DegToRad$b(AngleStepDeg);

        var totalAngle;
        if (anticlockwise) {
            totalAngle = startAngle - endAngle;
        } else {
            totalAngle = endAngle - startAngle;
        }
        if (totalAngle < 0) {
            totalAngle += 2 * Math.PI;
        }
        var segments = Math.ceil(totalAngle / angleStep);
        var deltaAngle = totalAngle / segments;
        if (anticlockwise) {
            deltaAngle = -deltaAngle;
        }

        for (var i = 0; i < segments; i++) {
            var t = i / segments;
            var r = Math.round(Linear$j(StartRGB.r, EndRGB.r, t));
            var g = Math.round(Linear$j(StartRGB.g, EndRGB.g, t));
            var b = Math.round(Linear$j(StartRGB.b, EndRGB.b, t));
            var segmentStartAngle = startAngle + (i * deltaAngle);
            var segmentEndAngle = segmentStartAngle + deltaAngle;

            // Overlap segment except last segment
            if (i < segments - 1) {
                segmentEndAngle += (deltaAngle / 2);
            }

            context.beginPath();
            context.ellipse(x, y, rx, ry, 0, segmentStartAngle, segmentEndAngle, anticlockwise);
            context.strokeStyle = `rgb(${r},${g},${b})`;
            context.lineWidth = lineWidth;
            context.stroke();
        }
    };

    var StartRGB;
    var EndRGB;

    var DrawText = function (
        canvas, context,
        x, y,
        text, font,
        fillStyle, strokeStyle, lineWidth,
        textAlign, textBaseline
    ) {

        if ((lineWidth === undefined) && (strokeStyle != null)) {
            lineWidth = 2;
        }

        if (textAlign === undefined) {
            textAlign = 'start';
        }

        if (textBaseline === undefined) {
            textBaseline = 'alphabetic';
        }

        context.font = font;
        context.textAlign = textAlign;
        context.textBaseline = textBaseline;

        context.fillStyle = fillStyle;
        context.strokeStyle = strokeStyle;

        context.lineWidth = lineWidth;
        context.lineCap = 'round';
        context.lineJoin = 'round';

        if ((strokeStyle != null) && (strokeStyle !== 'none') && (lineWidth > 0)) {
            context.strokeText(text, x, y);
        }

        if ((fillStyle != null) && (fillStyle !== 'none')) {
            context.fillText(text, x, y);
        }

    };

    const PI2$1 = Phaser.Math.PI2;

    var DrawContent$1 = function () {
        var x = this.radius;
        var lineWidth = this.thickness * this.radius;
        var barRadius = this.radius - (lineWidth / 2);
        var centerRadius = this.radius - lineWidth;
        var canvas = this.canvas,
            context = this.context;

        var anticlockwise = this.anticlockwise,
            startAngle = this.startAngle,
            endAngle = this.endAngle,
            deltaAngle = this._deltaAngle;

        // Draw track
        if (this.trackColor && (lineWidth > 0)) {
            context.save();

            DrawCircle(
                canvas, context,
                x, x,
                barRadius, barRadius,
                undefined,
                this.trackColor,
                lineWidth,
                startAngle, endAngle, anticlockwise
            );

            context.restore();
        }

        // Draw bar
        if ((this.barColor) && (barRadius > 0)) {
            var barEndAngle;

            if (this.value >= 1) {
                barEndAngle = endAngle;
            } else {
                if (anticlockwise) {
                    barEndAngle = (startAngle - (deltaAngle * this.value) + PI2$1) % PI2$1;
                } else {
                    barEndAngle = (startAngle + deltaAngle * this.value) % PI2$1;
                }
            }

            context.save();

            if (this.barColor2) {
                DrawGradientArc(
                    canvas, context,
                    x, x,
                    barRadius, barRadius,
                    this.barColor2, this.barColor, lineWidth,
                    startAngle, barEndAngle, anticlockwise
                );

            } else {
                DrawCircle(
                    canvas, context,
                    x, x,
                    barRadius, barRadius,
                    undefined,
                    this.barColor,
                    lineWidth,
                    startAngle, barEndAngle, anticlockwise
                );
            }

            context.restore();
        }

        // Draw center
        if (this.centerColor && (centerRadius > 0)) {
            var fillStyle;
            if (this.centerColor2) {
                fillStyle = this.context.createRadialGradient(x, x, 0, x, x, centerRadius);
                fillStyle.addColorStop(0, this.centerColor);
                fillStyle.addColorStop(1, this.centerColor2);
            } else {
                fillStyle = this.centerColor;
            }

            context.save();

            DrawCircle(
                canvas, context,
                x, x,
                centerRadius, centerRadius,
                fillStyle
            );

            context.restore();
        }

        // Draw text
        if (this.textFormatCallback && (this.textColor || this.textStrokeColor)) {

            context.save();

            DrawText(
                canvas, context,
                x, x,
                this.getFormatText(), this.textFont,
                this.textColor, this.textStrokeColor, this.textStrokeThickness,
                'center',  // textAlign
                'middle'   // textBaseline
            );

            context.restore();
        }
    };

    const GetValue$2Z = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$H = Phaser.Utils.Objects.IsPlainObject;
    const Clamp$b = Phaser.Math.Clamp;

    const DefaultStartAngle = Phaser.Math.DegToRad(270);
    const PI2 = Phaser.Math.PI2;

    class CircularProgress extends ProgressBase(Canvas$1) {
        constructor(scene, x, y, radius, barColor, value, config) {
            if (IsPlainObject$H(x)) {
                config = x;
                x = GetValue$2Z(config, 'x', 0);
                y = GetValue$2Z(config, 'y', 0);
                radius = GetValue$2Z(config, 'radius', 1);
                barColor = GetValue$2Z(config, 'barColor', undefined);
                value = GetValue$2Z(config, 'value', 0);
            }

            var width = radius * 2;
            var resolution = GetValue$2Z(config, 'resolution', 1);

            super(scene, x, y, width, width, resolution);
            this.type = 'rexCircularProgressCanvas';

            this.bootProgressBase(config);

            this.setRadius(radius);
            this.setTrackColor(GetValue$2Z(config, 'trackColor', undefined));
            this.setBarColor(barColor);
            this.setBarColor2(GetValue$2Z(config, 'barColor2', undefined));
            this.setCenterColor(GetValue$2Z(config, 'centerColor', undefined));

            this.setThickness(GetValue$2Z(config, 'thickness', 0.2));

            this.setAnticlockwise(GetValue$2Z(config, 'anticlockwise', false));

            this.setStartAngle(GetValue$2Z(config, 'startAngle', DefaultStartAngle));

            var endAngle = GetValue$2Z(config, 'endAngle');
            if (endAngle === undefined) {
                if (this.anticlockwise) {
                    endAngle = this.startAngle - PI2;
                } else {
                    endAngle = this.startAngle + PI2;
                }
            }
            this.setEndAngle(GetValue$2Z(config, 'endAngle', endAngle));

            this.setTextColor(GetValue$2Z(config, 'textColor', undefined));
            this.setTextStrokeColor(
                GetValue$2Z(config, 'textStrokeColor', undefined),
                GetValue$2Z(config, 'textStrokeThickness', undefined)
            );

            var textFont = GetValue$2Z(config, 'textFont', undefined);
            if (textFont) {
                this.setTextFont(textFont);
            } else {
                this.setTextFont(
                    GetValue$2Z(config, 'textSize', '16px'),
                    GetValue$2Z(config, 'textFamily', 'Courier'),
                    GetValue$2Z(config, 'textStyle', '')
                );
            }
            this.setTextFormatCallback(
                GetValue$2Z(config, 'textFormatCallback', undefined),
                GetValue$2Z(config, 'textFormatCallbackScope', undefined)
            );

            this.setValue(value);
        }

        resize(width, height) {
            width = Math.floor(Math.min(width, height));
            if (width === this.width) {
                return this;
            }

            super.resize(width, width);
            this.setRadius(width / 2);
            return this;
        }

        get radius() {
            return this._radius;
        }

        set radius(value) {
            this.dirty = this.dirty || (this._radius != value);
            this._radius = value;
            var width = value * 2;
            this.resize(width, width);
        }

        setRadius(radius) {
            this.radius = radius;
            return this;
        }

        get trackColor() {
            return this._trackColor;
        }

        set trackColor(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._trackColor != value);
            this._trackColor = value;
        }

        setTrackColor(color) {
            this.trackColor = color;
            return this;
        }

        get barColor() {
            return this._barColor;
        }

        set barColor(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._barColor != value);
            this._barColor = value;
        }

        setBarColor(color) {
            this.barColor = color;
            return this;
        }

        get barColor2() {
            return this._barColor2;
        }

        set barColor2(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._barColor2 != value);
            this._barColor2 = value;
        }

        setBarColor2(color) {
            this.barColor2 = color;
            return this;
        }

        get startAngle() {
            return this._startAngle;
        }

        set startAngle(value) {
            this.dirty = this.dirty || (this._startAngle != value);
            this._startAngle = value;
            this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
        }

        setStartAngle(angle) {
            this.startAngle = angle;
            return this;
        }

        get endAngle() {
            return this._endAngle;
        }

        set endAngle(value) {
            this.dirty = this.dirty || (this._endAngle != value);
            this._endAngle = value;
            this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
        }

        setEndAngle(angle) {
            this.endAngle = angle;
            return this;
        }

        get anticlockwise() {
            return this._anticlockwise;
        }

        set anticlockwise(value) {
            this.dirty = this.dirty || (this._anticlockwise != value);
            this._anticlockwise = value;
            this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
        }

        setAnticlockwise(anticlockwise) {
            if (anticlockwise === undefined) {
                anticlockwise = true;
            }
            this.anticlockwise = anticlockwise;
            return this;
        }

        get thickness() {
            return this._thickness;
        }

        set thickness(value) {
            value = Clamp$b(value, 0, 1);
            this.dirty = this.dirty || (this._thickness != value);
            this._thickness = value;
        }

        setThickness(thickness) {
            this.thickness = thickness;
            return this;
        }

        get centerColor() {
            return this._centerColor;
        }

        set centerColor(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._centerColor != value);
            this._centerColor = value;
        }

        get centerColor2() {
            return this._centerColor2;
        }

        set centerColor2(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._centerColor2 != value);
            this._centerColor2 = value;
        }

        setCenterColor(color, color2) {
            this.centerColor = color;
            this.centerColor2 = color2;
            return this;
        }

        get textColor() {
            return this._textColor;
        }

        set textColor(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._textColor != value);
            this._textColor = value;
        }

        setTextColor(color) {
            this.textColor = color;
            return this;
        }

        get textStrokeColor() {
            return this._textStrokeColor;
        }

        set textStrokeColor(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._textStrokeColor != value);
            this._textStrokeColor = value;
        }

        get textStrokeThickness() {
            return this._textStrokeThickness;
        }

        set textStrokeThickness(value) {
            this.dirty = this.dirty || (this._textStrokeThickness != value);
            this._textStrokeThickness = value;
        }

        setTextStrokeColor(color, thickness) {
            if (thickness === undefined) {
                thickness = 2;
            }
            this.textStrokeColor = color;
            this.textStrokeThickness = thickness;
            return this;
        }

        get textFont() {
            return this._textFont;
        }

        set textFont(value) {
            this.dirty = this.dirty || (this._textFont != value);
            this._textFont = value;
        }

        setTextFont(fontSize, fontFamily, fontStyle) {
            var font;
            if (fontFamily === undefined) {
                font = fontSize;
            } else {
                font = fontStyle + ' ' + fontSize + ' ' + fontFamily;
            }
            this.textFont = font;
            return this;
        }

        setTextFormatCallback(callback, scope) {
            this.textFormatCallback = callback;
            this.textFormatCallbackScope = scope;
            return this;
        }

        updateTexture() {
            super.updateTexture(function () {
                this.clear();
                DrawContent$1.call(this);
            }, this);
            return this;
        }

        getFormatText(value) {
            if (value === undefined) {
                value = this.value;
            }

            var text;
            if (this.textFormatCallbackScope) {
                text = this.textFormatCallback(value);
            } else {
                text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
            }
            return text;
        }
    }

    var GetDeltaAngle = function (startAngle, endAngle, anticlockwise) {
        if (anticlockwise) {
            if (startAngle <= endAngle) {
                return (PI2 + startAngle) - endAngle;
            } else {
                return startAngle - endAngle;
            }
        } else {
            if (startAngle >= endAngle) {
                return (PI2 + endAngle) - startAngle;
            } else {
                return endAngle - startAngle;
            }
        }
    };

    ObjectFactory.register('circularProgressCanvas', function (x, y, radius, barColor, value, config) {
        var gameObject = new CircularProgress(this.scene, x, y, radius, barColor, value, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.CircularProgressCanvas', CircularProgress);

    var UpdateShapes$1 = function () {
        var skewX = this.skewX;
        var width = this.width - Math.abs(skewX);
        var height = this.height;

        var trackFill = this.getShape('trackFill');
        trackFill.fillStyle(this.trackColor);
        if (trackFill.isFilled) {
            BuildRectangle(
                trackFill,      // lines
                0, 0,           // x0, y0
                width, height,  // x1, y1
                skewX           // skewX
            );
        }

        var bar = this.getShape('bar');
        bar.fillStyle(this.barColor);
        if (bar.isFilled) {
            var barX0, barX1;
            if (!this.rtl) {
                barX0 = 0;
                barX1 = width * this.value;
            } else {
                barX0 = width * (1 - this.value);
                barX1 = width;
            }

            BuildRectangle(
                bar,            // lines
                barX0, 0,       // x0, y0
                barX1, height,  // x1, y1
                skewX           // skew
            );
        }

        var trackStroke = this.getShape('trackStroke');
        trackStroke.lineStyle(this.trackStrokeThickness, this.trackStrokeColor);
        if (trackStroke.isStroked) {
            BuildRectangle(
                trackStroke,     // lines            
                0, 0,           // x0, y0
                width, height,  // x1, y1
                skewX           // skewX
            );
        }
    };

    var BuildRectangle = function (lines, x0, y0, x1, y1, skewX) {
        var startX = (x0 + x1) / 2;  // Start x from middle
        if (skewX >= 0) {
            lines
                .startAt(startX + skewX, y0).lineTo(x1 + skewX, y0)
                .lineTo(x1, y1)
                .lineTo(x0, y1)
                .lineTo(x0 + skewX, y0).lineTo(startX + skewX, y0);
        } else {
            lines
                .startAt(startX, y0).lineTo(x1, y0)
                .lineTo(x1 - skewX, y1)
                .lineTo(x0 - skewX, y1)
                .lineTo(x0, y0).lineTo(startX, y0);
        }

        lines.close();

        return lines;
    };

    const GetValue$2Y = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$G = Phaser.Utils.Objects.IsPlainObject;

    let LineProgress$1 = class LineProgress extends ProgressBase(BaseShapes) {
        constructor(scene, x, y, width, height, barColor, value, config) {
            if (IsPlainObject$G(x)) {
                config = x;

                x = config.x;
                y = config.y;
                width = config.width;
                height = config.height;
                barColor = config.barColor;
                value = config.value;
            } else if (IsPlainObject$G(width)) {
                config = width;

                width = config.width;
                height = config.height;
                barColor = config.barColor;
                value = config.value;
            } else if (IsPlainObject$G(barColor)) {
                config = barColor;

                barColor = config.barColor;
                value = config.value;
            }

            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 2; }
            if (height === undefined) { height = width; }
            if (value === undefined) { value = 0; }

            super(scene, x, y, width, height, config);
            this.type = 'rexLineProgress';

            this.bootProgressBase(config);

            this
                .addShape((new Lines()).setName('trackFill'))
                .addShape((new Lines()).setName('bar'))
                .addShape((new Lines()).setName('trackStroke'));

            this.setTrackColor(GetValue$2Y(config, 'trackColor', undefined));
            this.setBarColor(barColor);
            this.setTrackStroke(GetValue$2Y(config, 'trackStrokeThickness', 2), GetValue$2Y(config, 'trackStrokeColor', undefined));

            this.setSkewX(GetValue$2Y(config, 'skewX', 0));

            this.setRTL(GetValue$2Y(config, 'rtl', false));

            this.setValue(value);
        }

        get trackColor() {
            return this._trackColor;
        }

        set trackColor(value) {
            this.dirty = this.dirty || (this._trackColor != value);
            this._trackColor = value;
        }

        setTrackColor(color) {
            this.trackColor = color;
            return this;
        }

        get trackStrokeColor() {
            return this._trackStrokeColor;
        }

        set trackStrokeColor(value) {
            this.dirty = this.dirty || (this._trackStrokeColor != value);
            this._trackStrokeColor = value;
        }

        get trackStrokeThickness() {
            return this._trackStrokeThickness;
        }

        set trackStrokeThickness(value) {
            this.dirty = this.dirty || (this._trackStrokeThickness != value);
            this._trackStrokeThickness = value;
        }

        setTrackStroke(lineWidth, color) {
            this.trackStrokeThickness = lineWidth;
            this.trackStrokeColor = color;
            return this;
        }

        get barColor() {
            return this._barColor;
        }

        set barColor(value) {
            this.dirty = this.dirty || (this._barColor != value);
            this._barColor = value;
        }

        setBarColor(color) {
            this.barColor = color;
            return this;
        }

        get skewX() {
            return this._skewX;
        }

        set skewX(value) {
            this.dirty = this.dirty || (this._skewX != value);
            this._skewX = value;
        }

        setSkewX(value) {
            this.skewX = value;
            return this;
        }

        get rtl() {
            return this._rtl;
        }

        set rtl(value) {
            value = !!value;
            this.dirty = this.dirty || (this._rtl != value);
            this._rtl = value;
        }

        setRTL(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.rtl = enable;
            return this;
        }

    };

    var Methods$c = {
        updateShapes: UpdateShapes$1,
    };

    Object.assign(
        LineProgress$1.prototype,
        Methods$c,
    );

    ObjectFactory.register('lineProgress', function (x, y, width, height, barColor, value, config) {
        var gameObject = new LineProgress$1(this.scene, x, y, width, height, barColor, value, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.LineProgress', LineProgress$1);

    var BuildRoundRectangle = function (
        lines,
        width, height, cornerRadius,
        iteration
    ) {

        lines
            .setIterations(iteration)
            .start();

        // Top-left
        var radius = cornerRadius.tl;
        if (IsArcCorner$1(radius)) {
            if (radius.convex) {
                var centerX = radius.x;
                var centerY = radius.y;
                lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180, 270, false);
            } else {
                var centerX = 0;
                var centerY = 0;
                lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90, 0, true);
            }
        } else {
            lines.lineTo(0, 0);
        }

        // Top-right
        var radius = cornerRadius.tr;
        if (IsArcCorner$1(radius)) {
            if (radius.convex) {
                var centerX = width - radius.x;
                var centerY = radius.y;
                lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270, 360, false);
            } else {
                var centerX = width;
                var centerY = 0;
                lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180, 90, true);
            }
        } else {
            lines.lineTo(width, 0);
        }

        // Bottom-right
        var radius = cornerRadius.br;
        if (IsArcCorner$1(radius)) {
            if (radius.convex) {
                var centerX = width - radius.x;
                var centerY = height - radius.y;
                lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 0, 90, false);
            } else {
                var centerX = width;
                var centerY = height;
                lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270, 180, true);
            }
        } else {
            lines.lineTo(width, height);
        }

        // Bottom-left
        var radius = cornerRadius.bl;
        if (IsArcCorner$1(radius)) {
            if (radius.convex) {
                var centerX = radius.x;
                var centerY = height - radius.y;
                lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90, 180, false);
            } else {
                var centerX = 0;
                var centerY = height;
                lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 360, 270, true);
            }
        } else {
            lines.lineTo(0, height);
        }

        lines.close();

        return lines;
    };

    var RadToDeg$b = Phaser.Math.RadToDeg;

    var BuildRoundRectangleBarDirection0 = function (
        lines,
        width, height, cornerRadius,
        value,
    ) {
        var barWidth = width * value;

        // Top-left
        var radius = cornerRadius.tl;
        if (IsArcCorner$1(radius)) {
            var theta;
            if (barWidth > radius.x) {
                theta = 90;
            } else {
                theta = RadToDeg$b(Math.acos((radius.x - barWidth) / radius.x));
            }
            var centerX = radius.x;
            var centerY = radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180, 180 + theta, false);
        } else {
            lines.lineTo(0, 0);
        }

        // Top-right
        var radius = cornerRadius.tr;
        if (IsArcCorner$1(radius) && (barWidth > (width - radius.x))) {
            var theta = 90 - RadToDeg$b(Math.acos((barWidth - (width - radius.x)) / radius.x));
            var centerX = width - radius.x;
            var centerY = radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270, 270 + theta, false);
        } else {
            lines.lineTo(barWidth, 0);
        }

        // Bottom-right
        var radius = cornerRadius.br;
        if (IsArcCorner$1(radius) && (barWidth > (width - radius.x))) {
            var theta = 90 - RadToDeg$b(Math.acos((barWidth - (width - radius.x)) / radius.x));
            var centerX = width - radius.x;
            var centerY = height - radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90 - theta, 90, false);
        } else {
            lines.lineTo(barWidth, height);
        }

        // Bottom-left
        var radius = cornerRadius.bl;
        if (IsArcCorner$1(radius)) {
            var theta;
            if (barWidth > radius.x) {
                theta = 90;
            } else {
                theta = RadToDeg$b(Math.acos((radius.x - barWidth) / radius.x));
            }
            var centerX = radius.x;
            var centerY = height - radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180 - theta, 180, false);
        } else {
            lines.lineTo(0, height);
        }
    };

    var RadToDeg$a = Phaser.Math.RadToDeg;

    var BuildRoundRectangleBarDirection1 = function (
        lines,
        width, height, cornerRadius,
        value,
    ) {
        var barHeight = height * value;

        // Top-left
        var radius = cornerRadius.tl;
        if (IsArcCorner$1(radius)) {
            var theta;
            if (barHeight > radius.y) {
                theta = 90;
            } else {
                theta = RadToDeg$a(Math.acos((radius.y - barHeight) / radius.y));
            }
            var centerX = radius.x;
            var centerY = radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270 - theta, 270, false);
        } else {
            lines.lineTo(0, 0);
        }

        // Top-right
        var radius = cornerRadius.tr;
        if (IsArcCorner$1(radius)) {
            var theta;
            if (barHeight > radius.y) {
                theta = 90;
            } else {
                theta = RadToDeg$a(Math.acos((radius.y - barHeight) / radius.y));
            }
            var centerX = width - radius.x;
            var centerY = radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270, 270 + theta, false);
        } else {
            lines.lineTo(width, 0);
        }

        // Bottom-right
        var radius = cornerRadius.br;
        if (IsArcCorner$1(radius) && (barHeight > (height - radius.y))) {
            var theta = 90 - RadToDeg$a(Math.acos((barHeight - (height - radius.y)) / radius.y));
            var centerX = width - radius.x;
            var centerY = height - radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 0, 0 + theta, false);
        } else {
            lines.lineTo(width, barHeight);
        }

        // Bottom-left
        var radius = cornerRadius.bl;
        if (IsArcCorner$1(radius) && (barHeight > (height - radius.y))) {
            var theta = 90 - RadToDeg$a(Math.acos((barHeight - (height - radius.y)) / radius.y));
            var centerX = radius.x;
            var centerY = height - radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180 - theta, 180, false);
        } else {
            lines.lineTo(0, barHeight);
        }
    };

    var RadToDeg$9 = Phaser.Math.RadToDeg;

    var BuildRoundRectangleBarDirection2 = function (
        lines,
        width, height, cornerRadius,
        value,
    ) {
        var barWidth = width * value;

        // Top-right
        var radius = cornerRadius.tr;
        if (IsArcCorner$1(radius)) {
            var theta;
            if (barWidth > radius.x) {
                theta = 90;
            } else {
                theta = RadToDeg$9(Math.acos((radius.x - barWidth) / radius.x));
            }
            var centerX = width - radius.x;
            var centerY = radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 360 - theta, 360, false);
        } else {
            lines.lineTo(width, 0);
        }

        // Bottom-right
        var radius = cornerRadius.br;
        if (IsArcCorner$1(radius)) {
            var theta;
            if (barWidth > radius.x) {
                theta = 90;
            } else {
                theta = RadToDeg$9(Math.acos((radius.x - barWidth) / radius.x));
            }
            var centerX = width - radius.x;
            var centerY = height - radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 0, 0 + theta, false);
        } else {
            lines.lineTo(width, height);
        }

        // Bottom-left
        var radius = cornerRadius.bl;
        if (IsArcCorner$1(radius) && (barWidth > (width - radius.x))) {
            var theta = 90 - RadToDeg$9(Math.acos((barWidth - (width - radius.x)) / radius.x));
            var centerX = radius.x;
            var centerY = height - radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90, 90 + theta, false);
        } else {
            lines.lineTo(width - barWidth, height);
        }

        // Top-left
        var radius = cornerRadius.tl;
        if (IsArcCorner$1(radius) && (barWidth > (width - radius.x))) {
            var theta = 90 - RadToDeg$9(Math.acos((barWidth - (width - radius.x)) / radius.x));
            var centerX = radius.x;
            var centerY = radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270 - theta, 270, false);
        } else {
            lines.lineTo(width - barWidth, 0);
        }

    };

    var RadToDeg$8 = Phaser.Math.RadToDeg;

    var BuildRoundRectangleBarDirection3 = function (
        lines,
        width, height, cornerRadius,
        value,
    ) {
        var barHeight = height * value;

        // Bottom-right
        var radius = cornerRadius.br;
        if (IsArcCorner$1(radius)) {
            if (barHeight > radius.y) {
                theta = 90;
            } else {
                theta = RadToDeg$8(Math.acos((radius.y - barHeight) / radius.y));
            }
            var centerX = width - radius.x;
            var centerY = height - radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90 - theta, 90, false);
        } else {
            lines.lineTo(width, height);
        }

        // Bottom-left
        var radius = cornerRadius.bl;
        if (IsArcCorner$1(radius)) {
            if (barHeight > radius.y) {
                theta = 90;
            } else {
                theta = RadToDeg$8(Math.acos((radius.y - barHeight) / radius.y));
            }
            var centerX = radius.x;
            var centerY = height - radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90, 90 + theta, false);
        } else {
            lines.lineTo(0, height);
        }

        // Top-left
        var radius = cornerRadius.tl;
        if (IsArcCorner$1(radius) && (barHeight > (height - radius.y))) {
            var theta = 90 - RadToDeg$8(Math.acos((barHeight - (height - radius.y)) / radius.y));
            var centerX = radius.x;
            var centerY = radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180, 180 + theta, false);
        } else {
            lines.lineTo(0, height - barHeight);
        }

        // Top-right
        var radius = cornerRadius.tr;
        if (IsArcCorner$1(radius) && (barHeight > (height - radius.y))) {
            var theta = 90 - RadToDeg$8(Math.acos((barHeight - (height - radius.y)) / radius.y));
            var centerX = width - radius.x;
            var centerY = radius.y;
            lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 360 - theta, 360, false);
        } else {
            lines.lineTo(width, height - barHeight);
        }

    };

    var BuildRoundRectangleBar = function (
        lines,
        width, height, cornerRadius,
        value, orientation, rtl,
        iteration
    ) {

        lines
            .setIterations(iteration)
            .start();

        if (value === 0) {
            return lines;
        } else if (value === 1) {
            return BuildRoundRectangle(lines, width, height, cornerRadius, iteration);
        }

        var callback;
        if (orientation === 0) {
            callback = (rtl) ? BuildRoundRectangleBarDirection2 : BuildRoundRectangleBarDirection0;
        } else {
            callback = (rtl) ? BuildRoundRectangleBarDirection3 : BuildRoundRectangleBarDirection1;
        }

        callback(lines, width, height, cornerRadius, value);

        lines.close();

        return lines;
    };

    var UpdateShapes = function () {
        var width = this.width;
        var height = this.height;
        var cornerRadius = this.rrGeom.cornerRadius;
        var value = this.value;
        var orientation = this.orientation;
        var rtl = this.rtl;
        var iteration = this.iteration + 1;

        var trackFill = this.getShape('trackFill');
        trackFill.fillStyle(this.trackColor);
        if (trackFill.isFilled) {
            BuildRoundRectangle(
                trackFill,
                width, height, cornerRadius,
                iteration
            );
        }

        var bar = this.getShape('bar');
        bar.fillStyle(this.barColor);
        if (bar.isFilled) {
            BuildRoundRectangleBar(
                bar,
                width, height, cornerRadius,
                value, orientation, rtl,
                iteration
            );
        }

        var trackStroke = this.getShape('trackStroke');
        trackStroke.lineStyle(this.trackStrokeThickness, this.trackStrokeColor);
        if (trackStroke.isStroked) {
            BuildRoundRectangle(
                trackStroke,     // lines  
                width, height, cornerRadius,
                iteration
            );
        }
    };

    var OrientationMode = {
        x: 0,
        h: 0,
        horizontal: 0,
        'left-to-right': 0,

        y: 1,
        v: 1,
        vertical: 1,
        'top-to-bottom': 1
    };

    var GetOrientationMode = function (orientation) {
        if (typeof (orientation) === 'string') {
            orientation = OrientationMode[orientation];
        }
        return orientation;
    };

    const GetValue$2X = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$F = Phaser.Utils.Objects.IsPlainObject;

    class RoundRectangleProgress extends ProgressBase(BaseShapes) {
        constructor(scene, x, y, width, height, radiusConfig, barColor, value, config) {
            if (IsPlainObject$F(x)) {
                config = x;

                x = config.x;
                y = config.y;
                width = config.width;
                height = config.height;
                radiusConfig = config.radius;
                barColor = config.barColor;
                value = config.value;
            } else if (IsPlainObject$F(width)) {
                config = width;

                width = config.width;
                height = config.height;
                radiusConfig = config.radius;
                barColor = config.barColor;
                value = config.value;
            } else if (IsPlainObject$F(radiusConfig)) {
                config = radiusConfig;

                radiusConfig = config.radius;
                barColor = config.barColor;
                value = config.value;
            }

            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 1; }
            if (height === undefined) { height = width; }
            if (radiusConfig === undefined) { radiusConfig = 0; }
            if (value === undefined) { value = 0; }

            super(scene, x, y, width, height, config);
            this.type = 'rexRoundRectangleProgress';
            this.rrGeom = new RoundRectangle$3();  // For radiusConfig only

            this.bootProgressBase(config);

            this
                .addShape((new Lines()).setName('trackFill'))
                .addShape((new Lines()).setName('bar'))
                .addShape((new Lines()).setName('trackStroke'));

            this.setTrackColor(GetValue$2X(config, 'trackColor', undefined));
            this.setBarColor(barColor);
            this.setTrackStroke(GetValue$2X(config, 'trackStrokeThickness', 2), GetValue$2X(config, 'trackStrokeColor', undefined));

            this.setOrientation(GetValue$2X(config, 'orientation', 0));
            this.setRTL(GetValue$2X(config, 'rtl', false));

            this.setRadius(radiusConfig);

            this.setIteration(GetValue$2X(radiusConfig, 'iteration', undefined));

            this.setValue(value);
        }

        get trackColor() {
            return this._trackColor;
        }

        set trackColor(value) {
            this.dirty = this.dirty || (this._trackColor != value);
            this._trackColor = value;
        }

        setTrackColor(color) {
            this.trackColor = color;
            return this;
        }

        get trackStrokeColor() {
            return this._trackStrokeColor;
        }

        set trackStrokeColor(value) {
            this.dirty = this.dirty || (this._trackStrokeColor != value);
            this._trackStrokeColor = value;
        }

        get trackStrokeThickness() {
            return this._trackStrokeThickness;
        }

        set trackStrokeThickness(value) {
            this.dirty = this.dirty || (this._trackStrokeThickness != value);
            this._trackStrokeThickness = value;
        }

        setTrackStroke(lineWidth, color) {
            this.trackStrokeThickness = lineWidth;
            this.trackStrokeColor = color;
            return this;
        }

        get barColor() {
            return this._barColor;
        }

        set barColor(value) {
            this.dirty = this.dirty || (this._barColor != value);
            this._barColor = value;
        }

        setBarColor(color) {
            this.barColor = color;
            return this;
        }

        get orientation() {
            return this._orientation;
        }

        set orientation(value) {
            value = GetOrientationMode(value);
            this.dirty = this.dirty || (this._orientation != value);
            this._orientation = value;
        }

        setOrientation(value) {
            this.orientation = value;
            return this;
        }

        get rtl() {
            return this._rtl;
        }

        set rtl(value) {
            value = !!value;
            this.dirty = this.dirty || (this._rtl != value);
            this._rtl = value;
        }

        setRTL(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.rtl = enable;
            return this;
        }

        get radius() {
            return this.rrGeom.radius;
        }

        set radius(value) {
            this.rrGeom.setRadius(value);
            this.dirty = true;
        }

        get radiusTL() {
            return this.rrGeom.radiusTL;
        }

        set radiusTL(value) {
            this.rrGeom.radiusTL = value;
            this.dirty = true;
        }

        get radiusTR() {
            return this.rrGeom.radiusTR;
        }

        set radiusTR(value) {
            this.rrGeom.radiusTR = value;
            this.dirty = true;
        }

        get radiusBL() {
            return this.rrGeom.radiusBL;
        }

        set radiusBL(value) {
            this.rrGeom.radiusBL = value;
            this.dirty = true;
        }

        get radiusBR() {
            return this.rrGeom.radiusBR;
        }

        set radiusBR(value) {
            this.rrGeom.radiusBR = value;
            this.dirty = true;
        }

        setRadius(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radius = value;
            return this;
        }

        setRadiusTL(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radiusTL = value;
            return this;
        }

        setRadiusTR(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radiusTR = value;
            return this;
        }

        setRadiusBL(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radiusBL = value;
            return this;
        }

        setRadiusBR(value) {
            if (value === undefined) {
                value = 0;
            }
            this.radiusBR = value;
            return this;
        }

        get cornerRadius() {
            return this.rrGeom.cornerRadius;
        }

        set cornerRadius(value) {
            this.radius = value;
        }

        setCornerRadius(value) {
            return this.setRadius(value);
        }

        get iteration() {
            return this._iteration;
        }

        set iteration(value) {
            // Set iteration first time
            if (this._iteration === undefined) {
                this._iteration = value;
                return;
            }

            // Change iteration value
            if (this._iteration === value) {
                return;
            }

            this._iteration = value;
            this.dirty = true;
        }

        setIteration(iteration) {
            if (iteration === undefined) {
                iteration = 6;
            }
            this.iteration = iteration;
            return this;
        }
    }

    var Methods$b = {
        updateShapes: UpdateShapes,
    };

    Object.assign(
        RoundRectangleProgress.prototype,
        Methods$b,
    );

    ObjectFactory.register('roundRectanleProgress', function (x, y, width, height, radiusConfig, barColor, value, config) {
        var gameObject = new RoundRectangleProgress(this.scene, x, y, width, height, radiusConfig, barColor, value, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.RoundRectangleProgress', RoundRectangleProgress);

    var AddPolygonPath = function (context, points) {
        context.save();
        context.beginPath();

        var point = points[0];

        context.moveTo(point.x, point.y);

        for (var i = 1, cnt = points.length; i < cnt; i++) {
            point = points[i];
            context.lineTo(point.x, point.y);
        }

        context.closePath();
        context.restore();
    };

    var DrawPolygon = function (
        canvas, context,
        points,
        fillStyle,
        strokeStyle, lineWidth,
        lineJoin
    ) {

        if (lineJoin === undefined) {
            lineJoin = 'round';
        }

        AddPolygonPath(context, points);

        context.lineJoin = lineJoin;

        if (fillStyle != null) {
            context.fillStyle = fillStyle;
            context.fill();
        }

        if (strokeStyle != null) {
            context.strokeStyle = strokeStyle;
            context.lineWidth = lineWidth;
            context.stroke();
        }
    };

    var DrawContent = function () {
        var skewX = this.skewX;
        var width = this.width - Math.abs(skewX);
        var height = this.height;
        var canvas = this.canvas,
            context = this.context;

        // Has track
        if (this.trackColor || this.trackStrokeColor) {
            BuildPolygon(
                0, 0,           // x0, y0
                width, height,  // x1, y1
                skewX,          // skewX
                this.trackPoints
            );
        }

        // Has bar
        var barX0, barX1;
        if (this.barColor) {
            if (!this.rtl) {
                barX0 = 0;
                barX1 = width * this.value;
            } else {
                barX0 = width * (1 - this.value);
                barX1 = width;
            }

            BuildPolygon(
                barX0, 0,       // x0, y0
                barX1, height,  // x1, y1
                skewX,          // skewX
                this.barPoints
            );
        }

        if (this.trackColor) {
            context.save();

            DrawPolygon(
                canvas, context,
                this.trackPoints,
                this.trackColor,
            );

            context.restore();
        }

        if (this.barColor) {
            context.save();

            var style;
            if (this.barColor2) {
                var grd;
                if (this.isHorizontalGradient) {
                    var helfHeight = height / 2;
                    grd = context.createLinearGradient(barX0, helfHeight, barX1, helfHeight);
                } else {
                    var helfWidth = width / 2;
                    grd = context.createLinearGradient(helfWidth, 0, helfWidth, height);
                }
                grd.addColorStop(0, (this.rtl) ? this.barColor : this.barColor2);
                grd.addColorStop(1, (this.rtl) ? this.barColor2 : this.barColor);
                style = grd;
            } else {
                style = this.barColor;
            }

            DrawPolygon(
                canvas, context,
                this.barPoints,
                style,
            );

            context.restore();
        }

        if (this.trackStrokeColor && this.trackStrokeThickness > 0) {
            context.save();

            DrawPolygon(
                canvas, context,
                this.trackPoints,
                undefined,
                this.trackStrokeColor, this.trackStrokeThickness,
            );

            context.restore();
        }
    };

    var BuildPolygon = function (x0, y0, x1, y1, skewX, out) {
        if (out === undefined) {
            out = [];
        }
        out.length = 4;

        for (var i = 0; i < 4; i++) {
            if (!out[i]) {
                out[i] = {};
            }
        }

        var p;
        if (skewX >= 0) {
            p = out[0];
            p.x = x0 + skewX;
            p.y = y0;

            p = out[1];
            p.x = x1 + skewX;
            p.y = y0;

            p = out[2];
            p.x = x1;
            p.y = y1;

            p = out[3];
            p.x = x0;
            p.y = y1;
        } else {
            p = out[0];
            p.x = x0;
            p.y = y0;

            p = out[1];
            p.x = x1;
            p.y = y0;

            p = out[2];
            p.x = x1 - skewX;
            p.y = y1;

            p = out[3];
            p.x = x0 - skewX;
            p.y = y1;
        }

        return out;
    };

    const GetValue$2W = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$E = Phaser.Utils.Objects.IsPlainObject;

    class LineProgress extends ProgressBase(Canvas$1) {
        constructor(scene, x, y, width, height, barColor, value, config) {
            if (IsPlainObject$E(x)) {
                config = x;
                x = GetValue$2W(config, 'x', 0);
                y = GetValue$2W(config, 'y', 0);
                width = GetValue$2W(config, 'width', 2);
                height = GetValue$2W(config, 'height', 2);
                barColor = GetValue$2W(config, 'barColor', undefined);
                value = GetValue$2W(config, 'value', 0);
            } else if (IsPlainObject$E(width)) {
                config = width;
                width = GetValue$2W(config, 'width', 2);
                height = GetValue$2W(config, 'height', 2);
                barColor = GetValue$2W(config, 'barColor', undefined);
                value = GetValue$2W(config, 'value', 0);
            } else if (IsPlainObject$E(barColor)) {
                config = barColor;
                barColor = GetValue$2W(config, 'barColor', undefined);
                value = GetValue$2W(config, 'value', 0);
            }

            var resolution = GetValue$2W(config, 'resolution', 1);

            super(scene, x, y, width, height, resolution);
            this.type = 'rexLineProgressCanvas';
            this.trackPoints = [];
            this.barPoints = [];

            this.bootProgressBase(config);

            this.setTrackColor(GetValue$2W(config, 'trackColor', undefined));
            this.setBarColor(
                barColor,
                GetValue$2W(config, 'barColor2', undefined),
                GetValue$2W(config, 'isHorizontalGradient', undefined)
            );
            this.setTrackStroke(GetValue$2W(config, 'trackStrokeThickness', 2), GetValue$2W(config, 'trackStrokeColor', undefined));

            this.setSkewX(GetValue$2W(config, 'skewX', 0));

            this.setRTL(GetValue$2W(config, 'rtl', false));

            this.setValue(value);
        }

        get trackColor() {
            return this._trackColor;
        }

        set trackColor(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._trackColor != value);
            this._trackColor = value;
        }

        setTrackColor(color) {
            this.trackColor = color;
            return this;
        }

        get trackStrokeColor() {
            return this._trackStrokeColor;
        }

        set trackStrokeColor(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._trackStrokeColor != value);
            this._trackStrokeColor = value;
        }

        get trackStrokeThickness() {
            return this._trackStrokeThickness;
        }

        set trackStrokeThickness(value) {
            this.dirty = this.dirty || (this._trackStrokeThickness != value);
            this._trackStrokeThickness = value;
        }

        setTrackStroke(lineWidth, color) {
            this.trackStrokeThickness = lineWidth;
            this.trackStrokeColor = color;
            return this;
        }

        get barColor() {
            return this._barColor;
        }

        set barColor(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._barColor != value);
            this._barColor = value;
        }

        get barColor2() {
            return this._barColor2;
        }

        set barColor2(value) {
            value = GetStyle(value, this.canvas, this.context);
            this.dirty = this.dirty || (this._barColor2 != value);
            this._barColor2 = value;
        }

        get isHorizontalGradient() {
            return this._isHorizontalGradient;
        }

        set isHorizontalGradient(value) {
            this.dirty |= (this._isHorizontalGradient != value);
            this._isHorizontalGradient = value;
        }

        setBarColor(color, color2, isHorizontalGradient) {
            if (isHorizontalGradient === undefined) {
                isHorizontalGradient = true;
            }

            this.barColor = color;
            this.barColor2 = color2;
            this.isHorizontalGradient = isHorizontalGradient;
            return this;
        }

        get skewX() {
            return this._skewX;
        }

        set skewX(value) {
            this.dirty = this.dirty || (this._skewX != value);
            this._skewX = value;
        }

        setSkewX(value) {
            this.skewX = value;
            return this;
        }

        get rtl() {
            return this._rtl;
        }

        set rtl(value) {
            value = !!value;
            this.dirty = this.dirty || (this._rtl != value);
            this._rtl = value;
        }

        setRTL(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.rtl = enable;
            return this;
        }

        updateTexture() {
            super.updateTexture(function () {
                this.clear();
                DrawContent.call(this);
            }, this);
            return this;
        }
    }

    ObjectFactory.register('circularProgressCanvas', function (x, y, width, height, barColor, value, config) {
        var gameObject = new LineProgress(this.scene, x, y, width, height, barColor, value, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.LineProgressCanvas', LineProgress);

    Phaser.Math.Wrap;
    const Linear$i = Phaser.Math.Linear;

    var DrawFitTriangle = function () {
        var triangle = this.getShape('triangle');

        var padding = this.padding;
        var right = this.width - padding.right;
        var left = 0 + padding.left;
        var bottom = this.height - padding.bottom;
        var top = 0 + padding.top;
        var centerX = (left + right) / 2;
        var centerY = (top + bottom) / 2;

        var points = {
            0: {  // right
                a: { x: left, y: top }, b: { x: right, y: centerY }, c: { x: left, y: bottom },
            },
            1: {  // down
                a: { x: left, y: top }, b: { x: centerX, y: bottom }, c: { x: right, y: top },
            },
            2: {  // left
                a: { x: right, y: top }, b: { x: left, y: centerY }, c: { x: right, y: bottom },
            },
            3: {  // up
                a: { x: left, y: bottom }, b: { x: centerX, y: top }, c: { x: right, y: bottom },
            }
        };

        var pax, pay, pbx, pby, pcx, pcy;
        if (this.previousDirection === undefined) {
            var currentTrianglePoints = points[this.direction];
            var pa = currentTrianglePoints.a,
                pb = currentTrianglePoints.b,
                pc = currentTrianglePoints.c;

            pax = pa.x; pay = pa.y;
            pbx = pb.x; pby = pb.y;
            pcx = pc.x; pcy = pc.y;

        } else {
            var p0 = points[this.previousDirection];
            var p1 = points[this.direction];
            var t = this.easeDirectionProgress;
            pax = Linear$i(p0.a.x, p1.a.x, t);
            pay = Linear$i(p0.a.y, p1.a.y, t);
            pbx = Linear$i(p0.b.x, p1.b.x, t);
            pby = Linear$i(p0.b.y, p1.b.y, t);
            pcx = Linear$i(p0.c.x, p1.c.x, t);
            pcy = Linear$i(p0.c.y, p1.c.y, t);
        }

        triangle.startAt(pax, pay).lineTo(pbx, pby).lineTo(pcx, pcy);

        if (!this.arrowOnly) {
            triangle.close();
        } else {
            triangle.end();
        }

    };

    const DegToRad$a = Phaser.Math.DegToRad;
    const Rad120 = DegToRad$a(120);

    var DrawCircleVerticesTriangle = function (triangle) {
        var triangle = this.getShape('triangle');

        var centerX = this.width / 2,
            centerY = this.height / 2;

        var radius = Math.min(centerX, centerY) * this.radius,
            verticeRotation = this.verticeRotation;

        triangle
            .startAt(
                centerX + radius * Math.cos(verticeRotation + Rad120),
                centerY + radius * Math.sin(verticeRotation + Rad120)
            )
            .lineTo(
                centerX + radius * Math.cos(verticeRotation),
                centerY + radius * Math.sin(verticeRotation)
            )
            .lineTo(
                centerX + radius * Math.cos(verticeRotation - Rad120),
                centerY + radius * Math.sin(verticeRotation - Rad120)
            );

        if (!this.arrowOnly) {
            triangle.close();
        } else {
            triangle.end();
        }

    };

    var ShapesUpdateMethods$1 = {
        buildShapes() {
            this
                .addShape(new Lines().setName('triangle'));
        },

        updateShapes() {
            // Set style
            var triangle = this.getShape('triangle');

            if (!this.arrowOnly) {
                triangle
                    .fillStyle(this.fillColor, this.fillAlpha)
                    .lineStyle(this.lineWidth, this.strokeColor, this.strokeAlpha);
            } else {
                triangle
                    .fillStyle()
                    .lineStyle(this.lineWidth, this.strokeColor, this.strokeAlpha);
            }

            // Set points
            if (this.shapeMode === 0) {
                DrawFitTriangle.call(this);
            } else {
                DrawCircleVerticesTriangle.call(this);
            }

        }
    };

    var EaseDirectionMethods = {
        setEaseDuration(duration) {
            if (duration === undefined) {
                duration = 0;
            }
            this.easeDuration = duration;
            return this;
        },

        playEaseDirectionation() {
            if (this.easeDirectionProgressTask === undefined) {
                this.easeDirectionProgressTask = new EaseValueTask(this, { eventEmitter: null });
            }

            this.easeDirectionProgressTask.restart({
                key: 'easeDirectionProgress',
                from: 0,
                to: 1,
                duration: this.easeDuration,
            });

            return this;
        },

        stopEaseDirection() {
            if (this.easeDirectionProgressTask === undefined) {
                return this;
            }

            this.easeDirectionProgressTask.stop();
            return this;
        },

    };

    const GetValue$2V = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$D = Phaser.Utils.Objects.IsPlainObject;
    const DegToRad$9 = Phaser.Math.DegToRad;
    const RadToDeg$7 = Phaser.Math.RadToDeg;

    class Triangle extends BaseShapes {
        constructor(scene, x, y, width, height, fillColor, fillAlpha) {
            var strokeColor, strokeAlpha, strokeWidth, arrowOnly;
            var direction, easeDuration, padding;
            var radius;
            if (IsPlainObject$D(x)) {
                var config = x;

                x = config.x;
                y = config.y;
                width = config.width;
                height = config.height;

                fillColor = config.color;
                fillAlpha = config.alpha;

                strokeColor = config.strokeColor;
                strokeAlpha = config.strokeAlpha;
                strokeWidth = config.strokeWidth;
                arrowOnly = config.arrowOnly;

                direction = config.direction;
                easeDuration = config.easeDuration;
                padding = config.padding;

                radius = config.radius;
            }

            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 1; }
            if (height === undefined) { height = width; }

            if (arrowOnly === undefined) { arrowOnly = false; }
            if (direction === undefined) { direction = 0; }
            if (easeDuration === undefined) { easeDuration = 0; }
            if (padding === undefined) { padding = 0; }
            if (radius === undefined) { radius = undefined; }

            super(scene, x, y, width, height);
            this.type = 'rexTriangle';

            this.setFillStyle(fillColor, fillAlpha);

            if ((strokeColor !== undefined) && (strokeWidth === undefined)) {
                strokeWidth = 2;
            }
            this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);

            this.setArrowOnly(arrowOnly);

            this.setDirection(direction, easeDuration);

            this.setPadding(padding);

            this.setRadius(radius);

            this.buildShapes();

        }

        get arrowOnly() {
            return this._arrowOnly;
        }

        set arrowOnly(value) {
            this.dirty = this.dirty || (this._arrowOnly != value);
            this._arrowOnly = value;
        }

        setArrowOnly(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.arrowOnly = enable;
            return this;
        }

        get direction() {
            return this._direction;
        }

        set direction(value) {
            value = ParseDirection(value);
            if (this._direction === value) {
                return;
            }

            if ((this.easeDuration > 0) && (this._direction !== undefined)) {
                this.previousDirection = this._direction;
            } else {
                this.previousDirection = undefined;
            }

            this._direction = value;
            this.verticeAngle = value * 90;
            this.dirty = true;

            if (this.previousDirection !== undefined) {
                this.playEaseDirectionation();
            } else {
                this.stopEaseDirection();
            }
        }

        setDirection(direction, easeDuration) {
            if (easeDuration !== undefined) {
                this.setEaseDuration(easeDuration);
            }

            this.direction = direction;
            return this;
        }

        toggleDirection(easeDuration) {
            this.setDirection((this.direction + 2), easeDuration);
            return this;
        }

        get easeDirectionProgress() {
            return this._easeDirectionProgress;
        }

        set easeDirectionProgress(value) {
            if (this._easeDirectionProgress === value) {
                return;
            }

            this._easeDirectionProgress = value;
            this.dirty = true;
        }

        setPadding(left, top, right, bottom) {
            if (typeof left === 'object') {
                var config = left;

                //  If they specify x and/or y this applies to all
                var x = GetValue$2V(config, 'x', null);

                if (x !== null) {
                    left = x;
                    right = x;
                }
                else {
                    left = GetValue$2V(config, 'left', 0);
                    right = GetValue$2V(config, 'right', left);
                }

                var y = GetValue$2V(config, 'y', null);

                if (y !== null) {
                    top = y;
                    bottom = y;
                }
                else {
                    top = GetValue$2V(config, 'top', 0);
                    bottom = GetValue$2V(config, 'bottom', top);
                }
            }
            else {
                if (left === undefined) { left = 0; }
                if (top === undefined) { top = left; }
                if (right === undefined) { right = left; }
                if (bottom === undefined) { bottom = top; }
            }

            if (this.padding === undefined) {
                this.padding = {};
            }

            this.dirty = this.dirty ||
                (this.padding.left != left) ||
                (this.padding.top != top) ||
                (this.padding.right != right) ||
                (this.padding.bottom != bottom);

            this.padding.left = left;
            this.padding.top = top;
            this.padding.right = right;
            this.padding.bottom = bottom;

            // Switch to fit mode
            this.setRadius();

            return this;
        }

        get radius() {
            return this._radius;
        }

        set radius(value) {
            this.dirty = this.dirty || (this._radius != value);
            this._radius = value;
        }

        setRadius(radius) {
            this.radius = radius;

            // 0: fit mode
            // 1: circle mode
            this.shapeMode = (radius == null) ? 0 : 1;
            return this;
        }

        get verticeRotation() {
            return this._verticeRotation;
        }

        set verticeRotation(value) {
            this.dirty = this.dirty || (this._verticeRotation != value);
            this._verticeRotation = value;
        }

        setVerticeRotation(rotation) {
            this.verticeRotation = rotation;
            return this;
        }

        get verticeAngle() {
            return RadToDeg$7(this.verticeRotation);
        }

        set verticeAngle(value) {
            this.verticeRotation = DegToRad$9(value);
        }

        setVerticeAngle(angle) {
            this.verticeAngle = angle;
            return this;
        }

    }

    const DirectionNameMap = {
        right: 0, down: 1, left: 2, up: 3
    };
    var ParseDirection = function (direction) {
        if (typeof (direction) === 'string') {
            direction = DirectionNameMap[direction];
        }
        direction = direction % 4;
        return direction;
    };

    Object.assign(
        Triangle.prototype,
        ShapesUpdateMethods$1,
        EaseDirectionMethods,
    );

    ObjectFactory.register('triangle', function (x, y, width, height, fillColor, fillAlpha) {
        var gameObject = new Triangle(this.scene, x, y, width, height, fillColor, fillAlpha);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Triangle', Triangle);

    CheckP3Version();

    const Zone$1 = Phaser.GameObjects.Zone;
    const AddItem = Phaser.Utils.Array.Add;
    const RemoveItem$6 = Phaser.Utils.Array.Remove;

    let Base$2 = class Base extends Zone$1 {
        constructor(scene, x, y, width, height) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (width === undefined) {
                width = 1;
            }
            if (height === undefined) {
                height = 1;
            }
            super(scene, x, y, width, height);
            this.children = [];
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            if (fromScene) {
                // Stop scene
                var child;
                for (var i = this.children.length - 1; i >= 0; i--) {
                    child = this.children[i];
                    if (!child.parentContainer &&  // Not in container
                        !child.displayList         // Not in scene, neither in layer
                    ) {
                        // Destroy child which is not in scene, container, or layer manually
                        child.destroy(fromScene);
                    }
                }
            }

            // Destroy/remove children
            this.clear(!fromScene);
            super.destroy(fromScene);
        }

        contains(gameObject) {
            return (this.children.indexOf(gameObject) !== -1);
        }

        add(gameObjects) {
            var parent = this;
            AddItem(this.children, gameObjects, 0,
                // Callback of item added
                function (gameObject) {
                    gameObject.once('destroy', parent.onChildDestroy, parent);
                }, this);
            return this;
        }

        remove(gameObjects, destroyChild) {
            var parent = this;
            RemoveItem$6(this.children, gameObjects,
                // Callback of item removed
                function (gameObject) {
                    gameObject.off('destroy', parent.onChildDestroy, parent);
                    if (destroyChild) {
                        gameObject.destroy();
                    }
                }
            );
            return this;
        }

        onChildDestroy(child, fromScene) {
            // Only remove reference
            this.remove(child, false);
        }

        clear(destroyChild) {
            var parent = this;
            var gameObject;
            for (var i = 0, cnt = this.children.length; i < cnt; i++) {
                gameObject = this.children[i];
                gameObject.off('destroy', parent.onChildDestroy, parent);
                if (destroyChild) {
                    gameObject.destroy();
                }
            }
            this.children.length = 0;
            return this;
        }
    };

    const Components$1 = Phaser.GameObjects.Components;
    Phaser.Class.mixin(Base$2,
        [
            Components$1.Alpha,
            Components$1.Flip
        ]
    );

    var GetParent$1 = function (gameObject, name) {
        var parent;
        if (name === undefined) {
            if (gameObject.hasOwnProperty('rexContainer')) {
                parent = gameObject.rexContainer.parent;
            }
        } else {
            parent = GetParent$1(gameObject);
            while (parent) {
                if (parent.name === name) {
                    break;
                }
                parent = GetParent$1(parent);
            }
        }
        return parent;
    };

    var GetTopmostParent$1 = function (gameObject) {
        var parent = GetParent$1(gameObject);
        while (parent) {
            gameObject = parent;
            parent = GetParent$1(parent);
        }
        return gameObject;
    };

    const DegToRad$8 = Phaser.Math.DegToRad;
    const RadToDeg$6 = Phaser.Math.RadToDeg;

    var GetLocalState = function (gameObject) {
        if (!gameObject.hasOwnProperty('rexContainer')) {
            var rexContainer = {
                parent: null, self: null, layer: null,
                x: 0, y: 0, syncPosition: true,
                rotation: 0, syncRotation: true,
                scaleX: 0, scaleY: 0, syncScale: true,
                alpha: 0, syncAlpha: true,
                syncScrollFactor: true,
                syncCameraFilter: true,
                syncDisplayList: true,
                visible: true,
                active: true,
            };

            Object.defineProperty(rexContainer, 'angle', {
                get: function () {
                    return RadToDeg$6(this.rotation);
                },
                set: function (value) {
                    this.rotation = DegToRad$8(value);
                }
            });
            Object.defineProperty(rexContainer, 'displayWidth', {
                get: function () {
                    return gameObject.width * this.scaleX;
                },
                set: function (width) {
                    this.scaleX = width / gameObject.width;
                }
            });
            Object.defineProperty(rexContainer, 'displayHeight', {
                get: function () {
                    return gameObject.height * this.scaleY;
                },
                set: function (height) {
                    this.scaleY = height / gameObject.height;
                }
            });

            gameObject.rexContainer = rexContainer;
        }
        return gameObject.rexContainer;
    };

    var Parent = {
        setParent(gameObject, parent) {
            if (parent === undefined) {
                parent = this;
            }
            var localState = GetLocalState(gameObject);
            if (parent) { // Add to parent
                localState.parent = parent;
                localState.self = gameObject;
            } else { // Remove from parent
                localState.parent = null;
                localState.self = null;
            }
            return this;
        },

        getParent(gameObject, name) {
            if (typeof (gameObject) === 'string') {
                name = gameObject;
                gameObject = undefined;
            }
            if (gameObject === undefined) {
                gameObject = this;
            }
            return GetParent$1(gameObject, name);
        },

        getTopmostParent(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }
            return GetTopmostParent$1(gameObject);
        }
    };

    const GetValue$2U = Phaser.Utils.Objects.GetValue;
    const BaseAdd = Base$2.prototype.add;

    var Add$8 = function (gameObject, config) {
        this.setParent(gameObject);

        var state = GetLocalState(gameObject);
        SetupSyncFlags(state, config);

        this
            .resetChildState(gameObject)           // Reset local state of child
            .updateChildVisible(gameObject)        // Apply parent's visible to child
            .updateChildActive(gameObject)         // Apply parent's active to child
            .updateChildScrollFactor(gameObject)   // Apply parent's scroll factor to child
            .updateChildMask(gameObject)           // Apply parent's mask to child
            .updateCameraFilter(gameObject);       // Apply parent's cameraFilter to child

        BaseAdd.call(this, gameObject);

        SyncDisplayList$1.call(this, gameObject, state);

        return this;
    };

    var AddLocal = function (gameObject, config) {
        this.setParent(gameObject);

        // Set local state from child directly
        var state = GetLocalState(gameObject);
        SetupSyncFlags(state, config);
        // Position
        state.x = gameObject.x;
        state.y = gameObject.y;
        state.rotation = gameObject.rotation;
        state.scaleX = gameObject.scaleX;
        state.scaleY = gameObject.scaleY;
        // Alpha
        state.alpha = gameObject.alpha;
        // Visible
        state.visible = gameObject.visible;
        // Active
        state.active = gameObject.active;

        this
            .updateChildPosition(gameObject)
            .updateChildAlpha(gameObject)
            .updateChildVisible(gameObject)        // Apply parent's visible to child
            .updateChildActive(gameObject)         // Apply parent's active to child
            .updateChildScrollFactor(gameObject)   // Apply parent's scroll factor to child
            .updateChildMask(gameObject);          // Apply parent's mask to child

        BaseAdd.call(this, gameObject);

        SyncDisplayList$1.call(this, gameObject, state);

        return this;
    };

    var SetupSyncFlags = function (state, config) {
        if (config === undefined) {
            config = true;
        }

        if (typeof (config) === 'boolean') {
            state.syncPosition = config;
            state.syncRotation = config;
            state.syncScale = config;
            state.syncAlpha = config;
            state.syncScrollFactor = config;
            state.syncCameraFilter = config;
            state.syncDisplayList = config;
        } else {
            state.syncPosition = GetValue$2U(config, 'syncPosition', true);
            state.syncRotation = GetValue$2U(config, 'syncRotation', true);
            state.syncScale = GetValue$2U(config, 'syncScale', true);
            state.syncAlpha = GetValue$2U(config, 'syncAlpha', true);
            state.syncScrollFactor = GetValue$2U(config, 'syncScrollFactor', true);
            state.syncCameraFilter = GetValue$2U(config, 'syncCameraFilter', true);
            state.syncDisplayList = GetValue$2U(config, 'syncDisplayList', true);
        }

    };

    var SyncDisplayList$1 = function (gameObject, state) {
        this.addToParentContainer(gameObject);     // Sync parent's container to child

        if (state.syncDisplayList) {
            this.addToPatentLayer(gameObject);     // Sync parent's layer to child
        }

        this.addToRenderLayer(gameObject);         // Sync parent's render-layer
    };

    var AddChild$2 = {
        // Can override this method
        add(gameObject) {
            if (Array.isArray(gameObject)) {
                this.addMultiple(gameObject);
            } else {
                Add$8.call(this, gameObject);
            }
            return this;
        },

        // Don't override this method
        pin(gameObject, config) {
            if (Array.isArray(gameObject)) {
                this.addMultiple(gameObject, config);
            } else {
                Add$8.call(this, gameObject, config);
            }
            return this;
        },

        // Can override this method
        addMultiple(gameObjects) {
            var args = Array.from(arguments);
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                args[0] = gameObjects[i];
                this.add.apply(this, args);
            }
            return this;
        },

        addLocal(gameObject) {
            if (Array.isArray(gameObject)) {
                this.addMultiple(gameObject);
            } else {
                AddLocal.call(this, gameObject);
            }
            return this;
        },

        // Don't override this method
        pinLocal(gameObject, config) {
            if (Array.isArray(gameObject)) {
                this.addMultiple(gameObject, config);
            } else {
                AddLocal.call(this, gameObject, config);
            }
            return this;
        },

        addLocalMultiple(gameObjects) {
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                AddLocal.call(this, gameObjects[i]);
            }
            return this;
        }
    };

    const BaseRemove = Base$2.prototype.remove;
    const BaseClear = Base$2.prototype.clear;

    var RemoveChild$1 = {
        // Can override this method
        remove(gameObject, destroyChild) {
            if (GetParent$1(gameObject) !== this) {
                return this;
            }
            this.setParent(gameObject, null);

            if (!destroyChild) {
                this.removeFromRenderLayer(gameObject);
            }

            BaseRemove.call(this, gameObject, destroyChild);
            return this;
        },

        // Don't override this method
        unpin(gameObject, destroyChild) {
            if (GetParent$1(gameObject) !== this) {
                return this;
            }
            this.setParent(gameObject, null);

            if (!destroyChild) {
                this.removeFromRenderLayer(gameObject);
            }

            BaseRemove.call(this, gameObject, destroyChild);
            return this;
        },

        clear(destroyChild) {
            var children = this.children;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                var child = children[i];
                this.setParent(child, null);

                if (!destroyChild) {
                    this.removeFromRenderLayer(child);
                }
            }
            BaseClear.call(this, destroyChild);
            return this;
        },
    };

    var ChildState = {
        getLocalState(gameObject) {
            return GetLocalState(gameObject);
        },

        resetChildState(gameObject) {
            this
                .resetChildPositionState(gameObject)
                .resetChildVisibleState(gameObject)
                .resetChildAlphaState(gameObject)
                .resetChildActiveState(gameObject);
            return this;
        },

        resetChildrenState(gameObjects) {
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                this.resetChildState(gameObjects[i]);
            }
            return this;
        },

        syncProperties() {
            this
                .syncPosition()
                .syncVisible()
                .syncAlpha()
                .syncActive()
                .syncScrollFactor()
                .syncMask();
            return this;
        }
    };

    var Transform$1 = {
        worldToLocal(point) {
            // Transform
            point.x -= this.x;
            point.y -= this.y;

            // Rotate
            var c = Math.cos(-this.rotation);
            var s = Math.sin(-this.rotation);
            var tx = point.x;
            var ty = point.y;
            point.x = tx * c - ty * s;
            point.y = tx * s + ty * c;

            // Scale
            point.x /= this.scaleX;
            point.y /= this.scaleY;
            return point;
        },

        localToWorld(point) {
            // Scale
            point.x *= this.scaleX;
            point.y *= this.scaleY;

            // Rotate
            var c = Math.cos(this.rotation);
            var s = Math.sin(this.rotation);
            var tx = point.x;
            var ty = point.y;
            point.x = tx * c - ty * s;
            point.y = tx * s + ty * c;

            // Transform
            point.x += this.x;
            point.y += this.y;
            return point;
        }
    };

    var GetScale = function (a, b) {
        if (a === b) {
            return 1;
        } else {
            return a / b;
        }
    };

    var Position = {
        updateChildPosition(child) {
            if (child.isRexContainerLite) {
                child.syncChildrenEnable = false;
            }
            var localState = GetLocalState(child);
            var parent = localState.parent;

            if (localState.syncPosition) {
                child.x = localState.x;
                child.y = localState.y;
                parent.localToWorld(child);
            }

            if (localState.syncRotation) {
                child.rotation = localState.rotation + parent.rotation;
            }

            if (localState.syncScale) {
                child.scaleX = localState.scaleX * parent.scaleX;
                child.scaleY = localState.scaleY * parent.scaleY;
            }

            if (child.isRexContainerLite) {
                child.syncChildrenEnable = true;
                child.syncPosition();
            }
            return this;
        },

        syncPosition() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateChildPosition, this);
            }
            return this;
        },

        resetChildPositionState(child) {
            var localState = GetLocalState(child);
            var parent = localState.parent;
            localState.x = child.x;
            localState.y = child.y;
            parent.worldToLocal(localState);

            localState.scaleX = GetScale(child.scaleX, parent.scaleX);
            localState.scaleY = GetScale(child.scaleY, parent.scaleY);

            localState.rotation = child.rotation - parent.rotation;
            return this;
        },

        setChildPosition(child, x, y) {
            child.x = x;
            child.y = y;
            this.resetChildPositionState(child);
            return this;
        },

        setChildLocalPosition(child, x, y) {
            var localState = GetLocalState(child);
            localState.x = x;
            localState.y = y;
            this.updateChildPosition(child);
            return this;
        },

        resetLocalPositionState() {
            var parent = GetLocalState(this).parent;
            if (parent) {
                parent.resetChildPositionState(this);
            }
            return this;
        },

        getChildLocalX(child) {
            var localState = GetLocalState(child);
            return localState.x;
        },

        getChildLocalY(child) {
            var localState = GetLocalState(child);
            return localState.y;
        },

    };

    const DegToRad$7 = Phaser.Math.DegToRad;

    var Rotation = {
        updateChildRotation(child) {
            var localState = GetLocalState(child);
            var parent = localState.parent;
            if (localState.syncRotation) {
                child.rotation = parent.rotation + localState.rotation;
            }
            return this;
        },

        syncRotation() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateChildRotation, this);
            }
            return this;
        },

        resetChildRotationState(child) {
            var localState = GetLocalState(child);
            var parent = localState.parent;
            localState.rotation = child.rotation - parent.rotation;
            return this;
        },

        setChildRotation(child, rotation) {
            child.rotation = rotation;
            this.resetChildRotationState(child);
            return this;
        },

        setChildAngle(child, angle) {
            child.angle = angle;
            this.resetChildRotationState(child);
            return this;
        },

        setChildLocalRotation(child, rotation) {
            var localState = GetLocalState(child);
            localState.rotation = rotation;
            this.updateChildRotation(child);
            return this;
        },

        setChildLocalAngle(child, angle) {
            var localState = GetLocalState(child);
            localState.rotation = DegToRad$7(angle);
            this.updateChildRotation(child);
            return this;
        },

        resetLocalRotationState() {
            var parent = GetLocalState(this).parent;
            if (parent) {
                parent.resetChildRotationState(this);
            }
            return this;
        },

        getChildLocalRotation(child) {
            var localState = GetLocalState(child);
            return localState.rotation;
        },

    };

    var Scale$1 = {
        updateChildScale(child) {
            var state = GetLocalState(child);
            var parent = state.parent;
            if (state.syncScale) {
                child.scaleX = parent.scaleX * state.scaleX;
                child.scaleY = parent.scaleY * state.scaleY;
            }
            return this;
        },

        syncScale() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateChildScale, this);
            }
            return this;
        },

        resetChildScaleState(child) {
            var state = GetLocalState(child);
            var parent = state.parent;
            state.scaleX = GetScale(child.scaleX, parent.scaleX);
            state.scaleY = GetScale(child.scaleY, parent.scaleY);
            return this;
        },

        setChildScale(child, scaleX, scaleY) {
            if (scaleY === undefined) {
                scaleY = scaleX;
            }
            child.scaleX = scaleX;
            child.scaleY = scaleY;
            this.resetChildScaleState(child);
            return this;
        },

        setChildLocalScale(child, scaleX, scaleY) {
            if (scaleY === undefined) {
                scaleY = scaleX;
            }
            var state = GetLocalState(child);
            state.scaleX = scaleX;
            state.scaleY = scaleY;
            this.updateChildScale(child);
            return this;
        },

        setChildDisplaySize(child, width, height) {
            child.setDisplaySize(width, height);
            this.resetChildScaleState(child);
            return this;
        },

        resetLocalScaleState() {
            var parent = GetLocalState(this).parent;
            if (parent) {
                parent.resetChildScaleState(this);
            }
            return this;
        },

        getChildLocalScaleX(child) {
            var localState = GetLocalState(child);
            return localState.scaleX;
        },

        getChildLocalScaleY(child) {
            var localState = GetLocalState(child);
            return localState.scaleY;
        },
    };

    /*

    Visible in localState:

      - visible: original visible of child
      - maskVisible: invisible by parent mask, see MaskChildren.js
          - undefined (not in masking) : Equal to mask visible
          - true (mask visible) : Inside, or across parent's visible area
          - false (maske invisible) : Out of parent's visible area

    Visible result of child = (parent visible) && (child visible) && (mask visible)
    */


    var Visible$1 = {
        updateChildVisible(child) {
            var localState = GetLocalState(child);
            var parent = localState.parent;
            var maskVisible = (localState.hasOwnProperty('maskVisible')) ? localState.maskVisible : true;
            var parentVisible = (parent) ? parent.visible : true;
            child.visible = parentVisible && localState.visible && maskVisible;
            return this;
        },

        syncVisible() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateChildVisible, this);
            }
            return this;
        },

        resetChildVisibleState(child) {
            var localState = GetLocalState(child);
            // Delete maskVisible property
            if (localState.hasOwnProperty('maskVisible')) {
                delete localState.maskVisible;
            }
            localState.visible = child.visible;
            return this;
        },

        setChildVisible(child, visible) {
            // Visible of child will be affect by parent's visible, and mask visible
            this.setChildLocalVisible(child, visible);
            return this;
        },

        // Internal method
        setChildLocalVisible(child, visible) {
            if (visible === undefined) {
                visible = true;
            }
            var localState = GetLocalState(child);
            localState.visible = visible;
            this.updateChildVisible(child);
            return this;
        },

        // Internal method
        setChildMaskVisible(child, visible) {
            if (visible === undefined) {
                visible = true;
            }
            var localState = GetLocalState(child);
            localState.maskVisible = visible;
            this.updateChildVisible(child);
            return this;
        },

        resetLocalVisibleState() {
            var parent = GetLocalState(this).parent;
            if (parent) {
                parent.resetChildVisibleState(this);
            }
            return this;
        },

        getChildLocalVisible(child) {
            var localState = GetLocalState(child);
            return localState.visible;
        },
    };

    var Alpha = {
        updateChildAlpha(child) {
            var state = GetLocalState(child);
            var parent = state.parent;
            if (state.syncAlpha) {
                child.alpha = parent.alpha * state.alpha;
            }
            return this;
        },

        syncAlpha() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateChildAlpha, this);
            }
            return this;
        },

        resetChildAlphaState(child) {
            var state = GetLocalState(child);
            var parent = state.parent;
            state.alpha = GetScale(child.alpha, parent.alpha);
            return this;
        },

        setChildAlpha(child, alpha) {
            child.alpha = alpha;
            this.resetChildAlphaState(child);
            return this;
        },

        setChildLocalAlpha(child, alpha) {
            var state = GetLocalState(child);
            state.alpha = alpha;
            this.updateChildAlpha(child);
            return this;
        },

        resetLocalAlphaState() {
            var parent = GetLocalState(this).parent;
            if (parent) {
                parent.resetChildAlphaState(this);
            }
            return this;
        },

        getChildLocalAlpha(child) {
            var localState = GetLocalState(child);
            return localState.alpha;
        },
    };

    var Active = {
        updateChildActive(child) {
            var localState = GetLocalState(child);
            var parent = localState.parent;
            child.active = parent.active && localState.active;
            return this;
        },

        syncActive() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateChildActive, this);
            }
            return this;
        },

        resetChildActiveState(child) {
            var localState = GetLocalState(child);
            localState.active = child.active;
            return this;
        },

        setChildActive(child, active) {
            child.active = active;
            this.resetChildActiveState(child);
            return this;
        },

        setChildLocalActive(child, active) {
            if (active === undefined) {
                active = true;
            }
            var localState = GetLocalState(child);
            localState.active = active;
            this.updateChildActive(child);
            return this;
        },

        resetLocalActiveState() {
            var parent = GetLocalState(this).parent;
            if (parent) {
                parent.resetChildActiveState(this);
            }
            return this;
        },

        getChildLocalActive(child) {
            var localState = GetLocalState(child);
            return localState.active;
        },
    };

    var ScrollFactor = {
        updateChildScrollFactor(child) {
            var localState = GetLocalState(child);
            var parent = localState.parent;

            if (localState.syncScrollFactor) {
                child.scrollFactorX = parent.scrollFactorX;
                child.scrollFactorY = parent.scrollFactorY;
            }

            return this;
        },

        syncScrollFactor() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateChildScrollFactor, this);
            }
            return this;
        },

    };

    var CameraFilter = {
        updateCameraFilter(child) {
            var state = GetLocalState(child);
            var parent = state.parent;

            if (state.syncCameraFilter) {
                child.cameraFilter = parent.cameraFilter;
            }

            return this;
        },

        syncCameraFilter() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateCameraFilter, this);
            }
            return this;
        },
    };

    var Mask = {
        updateChildMask(child) {
            // Don't propagate null mask to clear children's mask
            if (this.mask == null) {
                return this;
            }

            var maskGameObject = (this.mask.hasOwnProperty('geometryMask')) ? this.mask.geometryMask : this.mask.bitmapMask;
            if (maskGameObject !== child) {
                child.mask = this.mask;
            }
            return this;
        },

        syncMask() {
            if (this.syncChildrenEnable) {
                this.children.forEach(this.updateChildMask, this);
            }
            return this;
        },

        setMask(mask) {
            this.mask = mask;
            return this;
        },

        clearMask(destroyMask) {
            if (destroyMask === undefined) {
                destroyMask = false;
            }

            var self = this;

            // Clear current mask
            this._mask = null;

            this.setChildMaskVisible(this);
            // Also set maskVisible to `true`

            this.children.forEach(function (child) {
                // Clear child's mask
                if (child.clearMask) {
                    child.clearMask(false);
                }

                if (!child.hasOwnProperty('isRexContainerLite')) {
                    self.setChildMaskVisible(child);
                    // Set child's maskVisible to `true`
                }
            });

            if (destroyMask && this.mask) {
                this.mask.destroy();
            }

            return this;
        },
    };

    var FilterDisplayGameObjects = function (gameObjects) {
        return gameObjects.filter(function (gameObject) {
            if (gameObject.displayList) {
                // Inside a scene or a layer
                return true;
            } else if (gameObject.parentContainer) {
                // Inside a container
                return true;
            }
        })
    };

    var Depth = {
        setDepth(value, containerOnly) {
            this.depth = value;
            if (!containerOnly && this.children) {
                var children = this.getAllChildren();
                for (var i = 0, cnt = children.length; i < cnt; i++) {
                    children[i].depth = value;
                }
            }
            return this;
        },

        swapDepth(containerB) {
            var depthA = this.depth;
            var depthB = containerB.depth;
            this.setDepth(depthB);
            containerB.setDepth(depthA);
            return this;
        },

        incDepth(inc) {
            this.depth += inc;
            if (this.children) {
                var children = this.getAllChildren();
                for (var i = 0, cnt = children.length; i < cnt; i++) {
                    children[i].depth += inc;
                }
            }
            return this;
        },

        bringToTop() {
            var displayList = this.displayList;
            if (!displayList) {
                return this;
            }

            var children = this.getAllChildren([this]);
            SortGameObjectsByDepth(children, false);
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                var child = children[i];
                if (displayList.exists(child)) {
                    displayList.bringToTop(child);
                }
            }
            return this;
        },

        bringMeToTop() {
            return this.bringToTop();
        },

        sendToBack() {
            var displayList = this.displayList;
            if (!displayList) {
                return this;
            }

            var children = this.getAllChildren([this]);
            SortGameObjectsByDepth(children, true);
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                var child = children[i];
                if (displayList.exists(child)) {
                    displayList.sendToBack(child);
                }
            }
            return this;
        },

        sendMeToBack() {
            return this.sendToBack();
        },

        moveDepthBelow(gameObject) {
            var displayList = this.displayList;
            if (!displayList) {
                return this;
            }

            if (gameObject.displayList !== displayList) {
                // Do nothing if not at the same display list
                return this;
            }

            var children = this.getAllChildren([this]);
            SortGameObjectsByDepth(children, false);
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                var child = children[i];
                if (displayList.exists(child)) {
                    displayList.moveBelow(gameObject, child);
                    break;
                }
            }
            return this;
        },

        moveMyDepthBelow(gameObject) {
            return this.moveDepthBelow(gameObject);
        },

        moveDepthAbove(gameObject) {
            var displayList = this.displayList;
            if (!displayList) {
                return this;
            }

            if (gameObject.displayList !== displayList) {
                // Do nothing if not at the same display list
                return this;
            }

            var children = this.getAllChildren([this]);
            SortGameObjectsByDepth(children, true);
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                var child = children[i];
                if (displayList.exists(child)) {
                    displayList.moveAbove(gameObject, child);
                    break;
                }
            }
            return this;
        },

        moveMyDepthAbove(gameObject) {
            return this.moveDepthAbove(gameObject);
        },

        bringChildToTop(child) {
            var gameObjects;
            if ((child !== this) && child.isRexContainerLite) {
                gameObjects = child.getAllChildren([child]);
                gameObjects = FilterDisplayGameObjects(gameObjects);
                gameObjects = SortGameObjectsByDepth(gameObjects, false);
            } else {
                gameObjects = [child];
            }

            var children = this.getAllChildren([this]);
            children = FilterDisplayGameObjects(children);
            children = SortGameObjectsByDepth(children, false);
            var topChild = children[children.length - 1];

            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                var gameObject = gameObjects[i];
                if (topChild === gameObject) {
                    continue;
                }
                if ((gameObject !== this) && (topChild.displayList !== gameObject.displayList)) {
                    continue;
                }

                topChild.displayList.moveAbove(gameObject, topChild);
                topChild = gameObject;
            }

            return this;
        },

        sendChildToBack(child) {
            var gameObjects;
            if ((child !== this) && child.isRexContainerLite) {
                gameObjects = child.getAllChildren([child]);
                gameObjects = FilterDisplayGameObjects(gameObjects);
                gameObjects = SortGameObjectsByDepth(gameObjects, false);
            } else {
                gameObjects = [child];
            }

            var children = this.getAllChildren([this]);
            children = FilterDisplayGameObjects(children);
            children = SortGameObjectsByDepth(children, false);
            var bottomChild = children[0];

            for (var i = gameObjects.length - 1; i >= 0; i--) {
                var gameObject = gameObjects[i];
                if (bottomChild === gameObject) {
                    continue;
                }
                if ((gameObject !== this) && (bottomChild.displayList !== gameObject.displayList)) {
                    continue;
                }

                bottomChild.displayList.moveBelow(gameObject, bottomChild);
                bottomChild = gameObject;
            }

            return this;
        },
    };

    var DepthFirstSearch = function (root, callback) {
        var skip = callback(root);
        if ((!skip) && root.isRexContainerLite) {
            var children = root.children;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                DepthFirstSearch(children[i], callback);
            }
        }
    };

    var BreadthFirstSearch = function (root, callback) {
        var queue = [root];
        while (queue.length > 0) {
            var current = queue.shift();
            var skip = callback(current);

            if ((!skip) && current.isRexContainerLite) {
                queue.push(...current.children);
            }
        }
    };

    const ArrayUtils = Phaser.Utils.Array;

    var Children = {
        getChildren(out) {
            if (!out) {
                out = this.children; // Return internal children array
            } else {
                for (var i = 0, cnt = this.children.length; i < cnt; i++) {
                    out.push(this.children[i]);
                }
                // Copy children
            }
            return out;
        },

        getAllChildren(out) {
            if (out === undefined) {
                out = [];
            }

            var root = this;
            BreadthFirstSearch(root, function (child) {
                // Don't add root
                if (child === root) {
                    return;
                }
                out.push(child);
            });

            return out;
        },

        getAllVisibleChildren(out) {
            if (out === undefined) {
                out = [];
            }

            var root = this;
            BreadthFirstSearch(root, function (child) {
                // Don't add root
                if (child === root) {
                    return;
                }
                // Don't add invisible child
                if (!child.visible) {
                    return true;
                }
                out.push(child);
            });

            return out;
        },

        bfs(callback, root) {
            if (root === undefined) {
                root = this;
            }
            BreadthFirstSearch(root, callback);
            return this;
        },

        dfs(callback, root) {
            if (root === undefined) {
                root = this;
            }
            DepthFirstSearch(root, callback);
            return this;
        },

        contains(gameObject) { // Override Base.contains method
            var parent = GetParent$1(gameObject);
            if (!parent) {
                return false;
            } else if (parent === this) {
                return true;
            } else {
                return this.contains(parent);
            }
        },

        getByName(name, recursive) {
            if (!recursive) {
                return ArrayUtils.GetFirst(this.children, 'name', name); // object, or null if not found

            } else { // recursive
                // Breadth-first search
                var queue = [this];
                var parent, child;
                while (queue.length) {
                    parent = queue.shift();

                    for (var i = 0, cnt = parent.children.length; i < cnt; i++) {
                        child = parent.children[i];
                        if (child.name === name) {
                            return child;
                        } else if (child.isRexContainerLite) {
                            queue.push(child);
                        }
                    }
                }
                return null;

            }

        },

        getRandom(startIndex, length) {
            return ArrayUtils.GetRandom(this.children, startIndex, length);
        },

        getFirst(property, value, startIndex, endIndex) {
            return ArrayUtils.GetFirstElement(this.children, property, value, startIndex, endIndex);
        },

        getAll(property, value, startIndex, endIndex) {
            return ArrayUtils.GetAll(this.children, property, value, startIndex, endIndex);
        },

        count(property, value, startIndex, endIndex) {
            return ArrayUtils.CountAllMatching(this.children, property, value, startIndex, endIndex);
        },

        swap(child1, child2) {
            ArrayUtils.Swap(this.children, child1, child2);
            return this;
        },

        setAll(property, value, startIndex, endIndex) {
            ArrayUtils.SetAll(this.children, property, value, startIndex, endIndex);
            return this;
        },
    };

    var GetLocalStates = function (gameObjects) {
        var localStates = [];
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            var gameObject = gameObjects[i];
            if (!gameObject.hasOwnProperty('rexContainer')) {
                continue;
            }
            localStates.push(gameObject.rexContainer);
        }
        return localStates;
    };

    var GetScene = function (gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            var scene = gameObjects[i].scene;
            if (scene) {
                return scene;
            }
        }
        return null;
    };

    var UpdateChild = function (tween, key, target) {
        if (!target.parent) {
            // target object was removed, so remove this tween too
            tween.remove();
            return;
        }

        var parent = target.parent;
        var child = target.self;
        switch (key) {
            case 'x':
            case 'y':
                parent.updateChildPosition(child);
                break;

            case 'angle':
            case 'rotation':
                parent.updateChildRotation(child);
                break;

            case 'scaleX':
            case 'scaleY':        
            case 'displayWidth':
            case 'displayHeight':
                parent.updateChildScale(child);
                break;

            case 'alpha':
                parent.updateChildAlpha(child);
                break;

            default:
                parent.updateChildPosition(child);
                parent.updateChildRotation(child);
                parent.updateChildScale(child);
                parent.updateChildAlpha(child);
                break;
        }
    };

    var Tween = {
        tweenChild(tweenConfig) {
            var targets = tweenConfig.targets;
            if (!Array.isArray(targets)) {
                targets = [targets];
            }

            var scene = this.scene || GetScene(targets);
            if (!scene) {
                return;
            }

            // Map child game objects to local states
            tweenConfig.targets = GetLocalStates(targets);
            var tween = scene.tweens.add(tweenConfig);

            // Update child game object in 'update' event
            tween.on('update', UpdateChild);

            return tween;
        },

        tweenSelf(tweenConfig) {
            tweenConfig.targets = [this];
            return this.tweenChild(tweenConfig);
        },

        createTweenChildConfig(tweenConfig) {
            var targets = tweenConfig.targets;
            if (targets) {
                if (!Array.isArray(targets)) {
                    targets = [targets];
                }
                // Map child game objects to local states
                tweenConfig.targets = GetLocalStates(targets);
            }

            var onUpdate = tweenConfig.onUpdate;
            tweenConfig.onUpdate = function (tween, target) {
                if (onUpdate) {
                    onUpdate(tween, target);
                }
                UpdateChild(tween, undefined, target);
            };

            return tweenConfig;
        },

        tween(tweenConfig) {
            var scene = this.scene;
            if (!tweenConfig.targets) {
                tweenConfig.targets = this;
            }
            return scene.tweens.add(tweenConfig);
        },
    };

    const ContainerClass = Phaser.GameObjects.Container;

    var IsContainerGameObject = function (gameObject) {
        return (gameObject instanceof ContainerClass);
    };

    var GetValidChildren = function (parent) {
        var children = parent.getAllChildren([parent]);
        children = children.filter(function (gameObject) {
            return !!gameObject.displayList ||   // At scene's displayList or at a layer
                !!gameObject.parentContainer;  // At a container
        });
        return children;
    };

    var AddToContainer = function (p3Container) {
        var gameObjects = GetValidChildren(this);
        // This containerLite parent should be considered.
        if (gameObjects.indexOf(this) === -1) {
            gameObjects.push(this);
        }

        SortGameObjectsByDepth(gameObjects);

        p3Container.add(gameObjects);
    };

    var RemoveFromContainer = function (p3Container, descending, addToScene) {
        if (!this.scene) {
            // Destroyed
            return;
        }

        var gameObjects = GetValidChildren(this);

        SortGameObjectsByDepth(gameObjects, descending);

        p3Container.remove(gameObjects);

        if (addToScene) {
            gameObjects.forEach(function (gameObject) {
                gameObject.addToDisplayList();
            });
        }
    };

    var P3Container$1 = {
        addToContainer(p3Container) {
            if (!IsContainerGameObject(p3Container)) {
                return this;
            }

            this._setParentContainerFlag = true;
            AddToContainer.call(this, p3Container);
            this._setParentContainerFlag = false;
            return this;
        },

        addToLayer(layer) {
            if (!IsLayerGameObject(layer)) {
                return this;
            }

            AddToContainer.call(this, layer);

            return this;
        },

        removeFromContainer() {
            if (!this.parentContainer) {
                return this;
            }

            this._setParentContainerFlag = true;
            RemoveFromContainer.call(this, this.parentContainer, true, false);
            this._setParentContainerFlag = false;
            return this;
        },

        removeFromLayer(addToScene) {
            if (addToScene === undefined) {
                addToScene = true;
            }

            if (!IsLayerGameObject(this.displayList)) {
                return this;
            }

            RemoveFromContainer.call(this, this.displayList, false, addToScene);

            return this;
        },

        getParentContainer() {
            if (this.parentContainer) {
                return this.parentContainer;
            }

            // One of parent container has a layer
            var parent = this.getParent();
            while (parent) {
                var p3Container = parent.parentContainer;
                if (p3Container) {
                    return p3Container;
                }
                parent = parent.getParent();
            }

            return null;
        },

        addToParentContainer(gameObject) {
            // Do nothing if gameObject is not in any displayList
            if (!gameObject.displayList) {
                return this;
            }

            var p3Container = this.getParentContainer();
            if (!p3Container) {
                return this;
            }

            if (gameObject.isRexContainerLite) {
                // Add containerLite and its children
                gameObject.addToContainer(p3Container);
            } else {
                // Add gameObject directly
                p3Container.add(gameObject);
            }

            return this;
        },

        addToPatentLayer(gameObject) {
            // Do nothing if gameObject is not in any displayList
            if (!gameObject.displayList) {
                return this;
            }

            // At the same display list
            var parentLayer = this.displayList;
            if (parentLayer === gameObject.displayList) {
                return this;
            }

            if (IsLayerGameObject(parentLayer)) {
                if (gameObject.isRexContainerLite) {
                    // Add containerLite and its children
                    gameObject.addToLayer(parentLayer);
                } else {
                    // Add gameObject directly
                    parentLayer.add(gameObject);
                }
            }

            return this;
        }
    };

    var RenderLayer = {
        hasLayer() {
            return !!this.privateRenderLayer;
        },

        enableLayer() {
            if (this.hasLayer()) {
                return this;
            }

            var layer = this.scene.add.layer();
            // layer.name = (this.name) ? `${this.name}.privateLayer` : 'privateLayer';

            this.moveDepthBelow(layer);

            this.addToLayer(layer);

            this.privateRenderLayer = layer;

            return this;
        },

        getLayer() {
            if (!this.hasLayer()) {
                this.enableLayer();
            }

            return this.privateRenderLayer;
        },

        getRenderLayer() {
            // This containerLite has a layer
            if (this.hasLayer()) {
                return this.privateRenderLayer;
            }

            // One of parent container has a layer
            var parent = this.getParent();
            while (parent) {
                var layer = parent.privateRenderLayer;
                if (layer) {
                    return layer;
                }
                parent = parent.getParent();
            }

            return null;
        },

        // Internal method for adding child
        addToRenderLayer(gameObject) {
            // Don't add to layer if gameObject is not in any displayList
            if (!gameObject.displayList) {
                return this;
            }

            // Move gameObject from scene to layer
            var layer = this.getRenderLayer();
            if (!layer) {
                return this;
            }

            if (layer === gameObject.displayList) {
                return this;
            }

            if (gameObject.isRexContainerLite) {
                // Add containerLite and its children
                gameObject.addToLayer(layer);
            } else {
                // Add gameObject directly
                layer.add(gameObject);
            }

            var state = GetLocalState(gameObject);
            state.layer = layer;

            return this;
        },

        // Internal method for removing child
        removeFromRenderLayer(gameObject) {
            // Move gameObject from layer to scene
            var state = GetLocalState(gameObject);
            var layer = state.layer;
            if (!layer) {
                return this;
            }

            if (gameObject.isRexContainerLite) {
                // Remove containerLite and its children
                gameObject.removeFromLayer(true);
            } else {
                // Remove gameObject directly
                layer.remove(gameObject);
            }

            state.layer = null;

            return this;
        },
    };

    const Rectangle$1 = Phaser.Geom.Rectangle;
    const Union = Phaser.Geom.Rectangle.Union;

    var GetBoundsOfGameObjects = function (gameObjects, out) {
        if (out === undefined) {
            out = new Rectangle$1();
        } else if (out === true) {
            if (GlobRect$1 === undefined) {
                GlobRect$1 = new Rectangle$1();
            }
            out = GlobRect$1;
        }

        out.setTo(0, 0, 0, 0);

        var gameObject;
        var firstClone = true;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            gameObject = gameObjects[i];
            if (!gameObject.getBounds) {
                continue;
            }

            var boundsRect = GetBounds(gameObject, true);

            if (firstClone) {
                out.setTo(boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
                firstClone = false;
            } else {
                Union(boundsRect, out, out);
            }
        }

        return out;
    };

    var GlobRect$1;

    var GetValue$2T = Phaser.Utils.Objects.GetValue;

    var Snapshot = function (config) {
        if (!config) {
            return;
        }

        var gameObjects = config.gameObjects;
        var renderTexture = config.renderTexture;  // renderTexture, or dynamicTexture
        var saveTexture = config.saveTexture;
        var x = GetValue$2T(config, 'x', undefined);
        var y = GetValue$2T(config, 'y', undefined);
        var width = GetValue$2T(config, 'width', undefined);
        var height = GetValue$2T(config, 'height', undefined);
        var originX = GetValue$2T(config, 'originX', 0);
        var originY = GetValue$2T(config, 'originY', 0);
        var padding = GetValue$2T(config, 'padding', 0);

        var scrollX, scrollY;
        if ((width === undefined) || (height === undefined) || (x === undefined) || (y === undefined)) {
            // Union bounds of gameObjects
            var bounds = GetBoundsOfGameObjects(gameObjects, true);
            var isCenterOrigin = (x !== undefined) && (y !== undefined);
            if (isCenterOrigin) {
                width = Math.max((x - bounds.left), (bounds.right - x)) * 2;
                height = Math.max((y - bounds.top), (bounds.bottom - y)) * 2;
                originX = 0.5;
                originY = 0.5;
            } else {
                x = bounds.x;
                y = bounds.y;
                width = bounds.width;
                height = bounds.height;
                originX = 0;
                originY = 0;
            }
            scrollX = bounds.x;
            scrollY = bounds.y;
        } else {
            scrollX = x + ((0 - originX) * width);
            scrollY = y + ((0 - originY) * height);
        }

        scrollX -= padding;
        scrollY -= padding;
        width += (padding * 2);
        height += (padding * 2);

        var scene = gameObjects[0].scene;
        var textureManager = scene.sys.textures;

        // Snapshot on dynamicTexture directly
        if (saveTexture && !renderTexture) {
            renderTexture = textureManager.addDynamicTexture(saveTexture, width, height);
        }

        // Return a renderTexture
        if (!renderTexture) {
            renderTexture = scene.add.renderTexture(0, 0, width, height);
        }

        if (renderTexture.setPosition) {
            renderTexture.setPosition(x, y);
        }

        if ((renderTexture.width !== width) || (renderTexture.height !== height)) {
            renderTexture.setSize(width, height);
        }

        if (renderTexture.setOrigin) {
            renderTexture.setOrigin(originX, originY);
        }

        renderTexture.camera.setScroll(scrollX, scrollY);

        // Draw gameObjects
        gameObjects = SortGameObjectsByDepth(Clone$2(gameObjects));
        renderTexture.draw(gameObjects);

        // Save render result to texture
        if (saveTexture) {
            if (IsGameObject(renderTexture)) {
                renderTexture.saveTexture(saveTexture);
            } else if (renderTexture.key !== saveTexture) {
                textureManager.renameTexture(renderTexture.key, key);
            }
        }

        return renderTexture;
    };

    var RenderTexture$1 = {
        snapshot(config) {
            // Save scale
            var scaleXSave = this.scaleX;
            var scaleYSave = this.scaleY;
            var scale1 = (scaleXSave === 1) && (scaleYSave === 1);
            if (!scale1) {
                this.setScale(1);
            }

            // Snapshot with scale = 1
            if (config === undefined) {
                config = {};
            }
            config.gameObjects = this.getAllVisibleChildren();
            config.x = this.x;
            config.y = this.y;
            config.originX = this.originX;
            config.originY = this.originY;
            var rt = Snapshot(config);
            var isValidRT = !!rt.scene;

            // Restore scale
            if (!scale1) {
                this.setScale(scaleXSave, scaleYSave);

                if (isValidRT) {
                    rt.setScale(scaleXSave, scaleYSave);
                }
            }

            return (isValidRT) ? rt : this;
        }
    };

    const GetValue$2S = Phaser.Utils.Objects.GetValue;

    var DrawBounds$1 = function (graphics, config) {
        var drawContainer = GetValue$2S(config, 'drawContainer', true);

        var gameObjects = GetValue$2S(config, 'children');
        if (gameObjects === undefined) {
            gameObjects = this.getAllVisibleChildren([this]);
        }

        if (!drawContainer) {
            gameObjects = gameObjects.filter(function (gameObject) {
                return !gameObject.isRexContainerLite;
            });
        }

        DrawBounds$2(gameObjects, graphics, config);

        return this;
    };

    const RotateAround$4 = Phaser.Math.RotateAround;

    var ChangeOrigin$1 = function (gameObject, originX, originY) {
        if (originY === undefined) {
            originY = originX;
        }

        var deltaXY = {
            x: (originX - gameObject.originX) * gameObject.displayWidth,
            y: (originY - gameObject.originY) * gameObject.displayHeight
        };
        RotateAround$4(deltaXY, 0, 0, gameObject.rotation);

        gameObject.originX = originX;
        gameObject.originY = originY;
        gameObject.x = gameObject.x + deltaXY.x;
        gameObject.y = gameObject.y + deltaXY.y;

        return gameObject;
    };

    var ChangeOrigin = function (originX, originY) {
        this.syncChildrenEnable = false;
        ChangeOrigin$1(this, originX, originY);
        this.syncChildrenEnable = true;

        var children = this.getAllChildren();
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            this.resetChildPositionState(children[i]);
        }
        return this;
    };

    var methods$A = {
        changeOrigin: ChangeOrigin,
        drawBounds: DrawBounds$1,
    };

    Object.assign(
        methods$A,
        Parent,
        AddChild$2,
        RemoveChild$1,
        ChildState,
        Transform$1,
        Position,
        Rotation,
        Scale$1,
        Visible$1,
        Alpha,
        Active,
        ScrollFactor,
        CameraFilter,
        Mask,
        Depth,
        Children,
        Tween,
        P3Container$1,
        RenderLayer,
        RenderTexture$1,
    );

    class ContainerLite extends Base$2 {
        constructor(scene, x, y, width, height, children) {
            if (Array.isArray(width)) {
                children = width;
                width = undefined;
                height = undefined;
            }
            super(scene, x, y, width, height);
            this.type = 'rexContainerLite';
            this.isRexContainerLite = true;
            this.syncChildrenEnable = true;

            this._active = true;
            this._mask = null;
            this._scrollFactorX = 1;
            this._scrollFactorY = 1;
            this._cameraFilter = 0;
            this.privateRenderLayer = undefined;

            if (children) {
                this.add(children);
            }
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.syncChildrenEnable = false; // Don't sync properties changing anymore
            super.destroy(fromScene);

            if (this.privateRenderLayer && this.privateRenderLayer.scene) {
                this.privateRenderLayer.list.length = 0;  // Remove all children without trigger callback
                this.privateRenderLayer.destroy();
            }
        }

        resize(width, height) {
            this.setSize(width, height);
            return this;
        }

        get x() {
            return this._x;
        }

        set x(value) {
            if (this._x === value) {
                return;
            }
            this._x = value;

            this.syncPosition();
        }

        get y() {
            return this._y;
        }

        set y(value) {
            if (this._y === value) {
                return;
            }
            this._y = value;

            this.syncPosition();
        }

        // Override
        get rotation() {
            return super.rotation;
        }

        set rotation(value) {
            if (this.rotation === value) {
                return;
            }
            super.rotation = value;

            this.syncPosition();
        }

        // Override
        get scaleX() {
            return super.scaleX;
        }

        set scaleX(value) {
            if (this.scaleX === value) {
                return;
            }
            super.scaleX = value;

            this.syncPosition();
        }

        // Override
        get scaleY() {
            return super.scaleY;
        }

        set scaleY(value) {
            if (this.scaleY === value) {
                return;
            }
            super.scaleY = value;

            this.syncPosition();
        }

        // Override
        get scale() {
            return super.scale;
        }

        set scale(value) {
            if (this.scale === value) {
                return;
            }
            super.scale = value;

            this.syncPosition();
        }

        // Override
        get visible() {
            return super.visible;
        }

        set visible(value) {
            if (super.visible === value) {
                return;
            }
            super.visible = value;

            this.syncVisible();
        }

        // Override
        get alpha() {
            return super.alpha;
        }

        set alpha(value) {
            if (super.alpha === value) {
                return;
            }
            super.alpha = value;

            this.syncAlpha();
        }

        // Override
        get active() {
            return this._active;
        }

        set active(value) {
            if (this._active === value) {
                return;
            }
            this._active = value;

            this.syncActive();
        }

        // Override
        get mask() {
            return this._mask;
        }
        set mask(mask) {
            if (this._mask === mask) {
                return;
            }
            this._mask = mask;

            this.syncMask();
        }

        // Override
        get scrollFactorX() {
            return this._scrollFactorX;
        }

        set scrollFactorX(value) {
            if (this._scrollFactorX === value) {
                return;
            }

            this._scrollFactorX = value;
            this.syncScrollFactor();
        }
        get scrollFactorY() {
            return this._scrollFactorY;
        }

        set scrollFactorY(value) {
            if (this._scrollFactorY === value) {
                return;
            }

            this._scrollFactorY = value;
            this.syncScrollFactor();
        }

        get cameraFilter() {
            return this._cameraFilter;
        }

        set cameraFilter(value) {
            if (this._cameraFilter === value) {
                return;
            }

            this._cameraFilter = value;
            this.syncCameraFilter();
        }

        // Compatiable with container plugin
        get list() {
            return this.children;
        }

        static GetParent(child) {
            return GetParent$1(child);
        }

        // For p3-container
        get parentContainer() {
            return this._parentContainer;
        }

        set parentContainer(value) {
            // Initialize
            if (!this._parentContainer && !value) {
                this._parentContainer = value;
                return;
            }

            // Set this._parentContainer only,
            // if under AddToContainer, or RemoveFromContainer methods
            if (this.setParentContainerFlag) {
                this._parentContainer = value;
                return;
            }
            // else if (!this.setParentContainerFlag)

            // Add itself and all children to container,
            // Or remove itseld and all children from container
            if (this._parentContainer && !value) {
                // Remove from container
                this.removeFromContainer();
                this._parentContainer = value;
            } else if (value) {
                // Add to container
                this._parentContainer = value;
                this.addToContainer(value);
            } else {
                this._parentContainer = value;
            }
        }

        get setParentContainerFlag() {
            if (this._setParentContainerFlag) {
                return true;
            }
            var parent = GetParent$1(this);
            return (parent) ? parent.setParentContainerFlag : false;
        }

    }

    Object.assign(
        ContainerLite.prototype,
        methods$A
    );

    var GetSizerConfig$1 = function (gameObject) {
        if (!gameObject.hasOwnProperty('rexSizer')) {
            gameObject.rexSizer = {};
        }
        return gameObject.rexSizer;
    };

    function GetSizerConfig (gameObject) {
        if (gameObject === undefined) {
            gameObject = this;
        }
        return GetSizerConfig$1(gameObject);
    }

    var GetChildPrevState = function (child) {
        var childConfig = GetSizerConfig$1(child);
        if (!childConfig.hasOwnProperty('prevState')) {
            childConfig.prevState = {};
        }
        return childConfig.prevState;
    };

    var PushIntoBounds = function (bounds) {
        if (bounds === undefined) {
            bounds = GetViewport(this.scene);
        }

        this.left = Math.max(this.left, bounds.left);
        this.right = Math.min(this.right, bounds.right);
        this.top = Math.max(this.top, bounds.top);
        this.bottom = Math.min(this.bottom, bounds.bottom);
        return this;
    };

    const ALIGN$1 = Phaser.Display.Align;
    var AlignConst = {
        center: ALIGN$1.CENTER,
        left: ALIGN$1.LEFT_CENTER,
        right: ALIGN$1.RIGHT_CENTER,
        top: ALIGN$1.TOP_CENTER,
        bottom: ALIGN$1.BOTTOM_CENTER,

        'left-top': ALIGN$1.TOP_LEFT,
        'top-left': ALIGN$1.TOP_LEFT,

        'left-center': ALIGN$1.LEFT_CENTER,
        'center-left': ALIGN$1.LEFT_CENTER,

        'left-bottom': ALIGN$1.BOTTOM_LEFT,
        'bottom-left': ALIGN$1.BOTTOM_LEFT,

        'center-top': ALIGN$1.TOP_CENTER,
        'top-center': ALIGN$1.TOP_CENTER,

        'center-center': ALIGN$1.CENTER,

        'center-bottom': ALIGN$1.BOTTOM_CENTER,
        'bottom-center': ALIGN$1.BOTTOM_CENTER,

        'right-top': ALIGN$1.TOP_RIGHT,
        'top-right': ALIGN$1.TOP_RIGHT,

        'right-center': ALIGN$1.RIGHT_CENTER,
        'center-right': ALIGN$1.RIGHT_CENTER,

        'right-bottom': ALIGN$1.BOTTOM_RIGHT,
        'bottom-right': ALIGN$1.BOTTOM_RIGHT,
    };

    var globZone = new Phaser.GameObjects.Zone({
        sys: {
            queueDepthSort: NOOP,
            events: {
                once: NOOP
            }
        }
    }, 0, 0, 1, 1);
    globZone.setOrigin(0);

    var ALIGN_CONST = {

        /**
        * A constant representing a top-left alignment or position.
        * @constant
        * @name Phaser.Display.Align.TOP_LEFT
        * @since 3.0.0
        * @type {integer}
        */
        TOP_LEFT: 0,

        /**
        * A constant representing a top-center alignment or position.
        * @constant
        * @name Phaser.Display.Align.TOP_CENTER
        * @since 3.0.0
        * @type {integer}
        */
        TOP_CENTER: 1,

        /**
        * A constant representing a top-right alignment or position.
        * @constant
        * @name Phaser.Display.Align.TOP_RIGHT
        * @since 3.0.0
        * @type {integer}
        */
        TOP_RIGHT: 2,

        /**
        * A constant representing a left-top alignment or position.
        * @constant
        * @name Phaser.Display.Align.LEFT_TOP
        * @since 3.0.0
        * @type {integer}
        */
        LEFT_TOP: 3,

        /**
        * A constant representing a left-center alignment or position.
        * @constant
        * @name Phaser.Display.Align.LEFT_CENTER
        * @since 3.0.0
        * @type {integer}
        */
        LEFT_CENTER: 4,

        /**
        * A constant representing a left-bottom alignment or position.
        * @constant
        * @name Phaser.Display.Align.LEFT_BOTTOM
        * @since 3.0.0
        * @type {integer}
        */
        LEFT_BOTTOM: 5,

        /**
        * A constant representing a center alignment or position.
        * @constant
        * @name Phaser.Display.Align.CENTER
        * @since 3.0.0
        * @type {integer}
        */
        CENTER: 6,

        /**
        * A constant representing a right-top alignment or position.
        * @constant
        * @name Phaser.Display.Align.RIGHT_TOP
        * @since 3.0.0
        * @type {integer}
        */
        RIGHT_TOP: 7,

        /**
        * A constant representing a right-center alignment or position.
        * @constant
        * @name Phaser.Display.Align.RIGHT_CENTER
        * @since 3.0.0
        * @type {integer}
        */
        RIGHT_CENTER: 8,

        /**
        * A constant representing a right-bottom alignment or position.
        * @constant
        * @name Phaser.Display.Align.RIGHT_BOTTOM
        * @since 3.0.0
        * @type {integer}
        */
        RIGHT_BOTTOM: 9,

        /**
        * A constant representing a bottom-left alignment or position.
        * @constant
        * @name Phaser.Display.Align.BOTTOM_LEFT
        * @since 3.0.0
        * @type {integer}
        */
        BOTTOM_LEFT: 10,

        /**
        * A constant representing a bottom-center alignment or position.
        * @constant
        * @name Phaser.Display.Align.BOTTOM_CENTER
        * @since 3.0.0
        * @type {integer}
        */
        BOTTOM_CENTER: 11,

        /**
        * A constant representing a bottom-right alignment or position.
        * @constant
        * @name Phaser.Display.Align.BOTTOM_RIGHT
        * @since 3.0.0
        * @type {integer}
        */
        BOTTOM_RIGHT: 12

    };

    var GetBottom = function (gameObject) {
        var height = GetDisplayHeight(gameObject);
        return (gameObject.y + height) - (height * gameObject.originY);
    };

    var GetCenterX = function (gameObject) {
        var width = GetDisplayWidth(gameObject);
        return gameObject.x - (width * gameObject.originX) + (width * 0.5);
    };

    var SetBottom = function (gameObject, value) {
        var height = GetDisplayHeight(gameObject);
        gameObject.y = (value - height) + (height * gameObject.originY);
        return gameObject;
    };

    var SetCenterX = function (gameObject, x) {
        var width = GetDisplayWidth(gameObject);
        var offsetX = width * gameObject.originX;
        gameObject.x = (x + offsetX) - (width * 0.5);

        return gameObject;
    };

    var BottomCenter = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
        SetBottom(gameObject, GetBottom(alignIn) + offsetY);

        return gameObject;
    };

    var GetLeft = function (gameObject) {
        var width = GetDisplayWidth(gameObject);
        return gameObject.x - (width * gameObject.originX);
    };

    var SetLeft = function (gameObject, value) {
        var width = GetDisplayWidth(gameObject);
        gameObject.x = value + (width * gameObject.originX);
        return gameObject;
    };

    var BottomLeft = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        SetLeft(gameObject, GetLeft(alignIn) - offsetX);
        SetBottom(gameObject, GetBottom(alignIn) + offsetY);

        return gameObject;
    };

    var GetRight = function (gameObject) {
        var width = GetDisplayWidth(gameObject);
        return (gameObject.x + width) - (width * gameObject.originX);
    };

    var SetRight = function (gameObject, value) {
        var width = GetDisplayWidth(gameObject);
        gameObject.x = (value - width) + (width * gameObject.originX);

        return gameObject;
    };

    var BottomRight = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        SetRight(gameObject, GetRight(alignIn) + offsetX);
        SetBottom(gameObject, GetBottom(alignIn) + offsetY);

        return gameObject;
    };

    var SetCenterY = function (gameObject, y) {
        var height = GetDisplayHeight(gameObject);
        var offsetY = height * gameObject.originY;
        gameObject.y = (y + offsetY) - (height * 0.5);

        return gameObject;
    };

    var CenterOn = function (gameObject, x, y) {
        SetCenterX(gameObject, x);
        return SetCenterY(gameObject, y);
    };

    var GetCenterY = function (gameObject) {
        var height = GetDisplayHeight(gameObject);
        return gameObject.y - (height * gameObject.originY) + (height * 0.5);
    };

    var Center = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);

        return gameObject;
    };

    var LeftCenter = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        SetLeft(gameObject, GetLeft(alignIn) - offsetX);
        SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);

        return gameObject;
    };

    var RightCenter = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        SetRight(gameObject, GetRight(alignIn) + offsetX);
        SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);

        return gameObject;
    };

    var GetTop = function (gameObject) {
        var height = GetDisplayHeight(gameObject);
        return gameObject.y - (height * gameObject.originY);
    };

    var SetTop = function (gameObject, value) {
        var height = GetDisplayHeight(gameObject);
        gameObject.y = value + (height * gameObject.originY);
        return gameObject;
    };

    var TopCenter = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
        SetTop(gameObject, GetTop(alignIn) - offsetY);

        return gameObject;
    };

    var TopLeft = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        SetLeft(gameObject, GetLeft(alignIn) - offsetX);
        SetTop(gameObject, GetTop(alignIn) - offsetY);

        return gameObject;
    };

    var TopRight = function (gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        SetRight(gameObject, GetRight(alignIn) + offsetX);
        SetTop(gameObject, GetTop(alignIn) - offsetY);

        return gameObject;
    };

    var AlignInMap = [];

    AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = BottomCenter;
    AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = BottomLeft;
    AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = BottomRight;
    AlignInMap[ALIGN_CONST.CENTER] = Center;
    AlignInMap[ALIGN_CONST.LEFT_CENTER] = LeftCenter;
    AlignInMap[ALIGN_CONST.RIGHT_CENTER] = RightCenter;
    AlignInMap[ALIGN_CONST.TOP_CENTER] = TopCenter;
    AlignInMap[ALIGN_CONST.TOP_LEFT] = TopLeft;
    AlignInMap[ALIGN_CONST.TOP_RIGHT] = TopRight;

    var QuickSet = function (child, alignIn, position, offsetX, offsetY) {
        return AlignInMap[position](child, alignIn, offsetX, offsetY);
    };

    var AlignIn = function (child, x, y, width, height, align) {
        globZone.setPosition(x, y).setSize(width, height);
        QuickSet(child, globZone, align);
    };

    const GetValue$2R = Phaser.Utils.Objects.GetValue;
    const Group$1 = Phaser.GameObjects.Group;
    const P3Container = Phaser.GameObjects.Container;

    var DrawBounds = function (graphics, config) {
        var scene = graphics.scene;

        var color, lineWidth;
        var createTextCallback, createTextCallbackScope, textAlign;
        if (typeof (config) === 'number') {
            color = config;
        } else {
            color = GetValue$2R(config, 'color');
            lineWidth = GetValue$2R(config, 'lineWidth');
            var nameTextConfig = GetValue$2R(config, 'name', false);
            if (nameTextConfig) {
                createTextCallback = GetValue$2R(nameTextConfig, 'createTextCallback', DefaultCreateTextCallback);
                createTextCallbackScope = GetValue$2R(nameTextConfig, 'createTextCallbackScope', undefined);
                textAlign = GetValue$2R(nameTextConfig, 'align', 'left-top');
                if (typeof (textAlign) === 'string') {
                    textAlign = AlignConst[textAlign];
                }
            }
        }

        if (color === undefined) {
            color = 0xffffff;
        }
        if (lineWidth === undefined) {
            lineWidth = 1;
        }

        if (createTextCallback && !graphics.children) {
            graphics.children = new Group$1(scene);
            graphics.once('destroy', function (graphics, fromScene) {
                graphics.children.destroy(!fromScene);
                graphics.children = undefined;
            });
            var graphicsClear = graphics.clear.bind(graphics);
            graphics.clear = function () {
                graphicsClear();
                graphics.children.clear(false, true);
            };
        }

        var children = this.getAllShownChildren([this]);
        GetP3ContainerChildren(children, children);

        var child;
        var nameText;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.getBounds ||
                ((child.width !== undefined) && (child.height !== undefined))
            ) {
                GlobRect = GetBounds(child, GlobRect);
            } else {
                continue;
            }

            if (color != null) {
                graphics
                    .lineStyle(lineWidth, color)
                    .strokeRectShape(GlobRect);
            }

            if (child.name && createTextCallback) {
                if (createTextCallbackScope) {
                    nameText = createTextCallback.call(createTextCallbackScope, scene);
                } else {
                    nameText = createTextCallback(scene);
                }
                if (nameText) {
                    nameText.setText(child.name);
                    graphics.children.add(nameText);

                    AlignIn(nameText, GlobRect.x, GlobRect.y, GlobRect.width, GlobRect.height, textAlign);
                }
            }
        }
        return this;
    };

    var DefaultCreateTextCallback = function (scene, child, childBoundsRect) {
        return scene.add.text(0, 0, '');
    };

    var GetP3ContainerChildren = function (gameObjects, output) {
        if (!Array.isArray(gameObjects)) {
            gameObjects = [gameObjects];
        }
        if (output === undefined) {
            output = [];
        }

        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            var gameObject = gameObjects[i];
            if (gameObject instanceof P3Container) {
                output.push(...gameObject.list);
                GetP3ContainerChildren(gameObject.list, output);
            }
        }

        return output;
    };

    var GlobRect = undefined;

    const GetValue$2Q = Phaser.Utils.Objects.GetValue;

    var GetBoundsConfig$1 = function (config, out) {
        if (config === undefined) {
            config = 0;
        }
        if (out === undefined) {
            out = {};
        }

        if (typeof (config) === 'number') {
            out.left = config;
            out.right = config;
            out.top = config;
            out.bottom = config;
        } else {
            out.left = GetValue$2Q(config, 'left', 0);
            out.right = GetValue$2Q(config, 'right', 0);
            out.top = GetValue$2Q(config, 'top', 0);
            out.bottom = GetValue$2Q(config, 'bottom', 0);
        }
        return out;
    };

    const ContainerAdd = ContainerLite.prototype.add;

    var AddChild$1 = function (gameObject) {
        ContainerAdd.call(this, gameObject);

        if (this.sizerEventsEnable) {
            gameObject.emit('sizer.add', gameObject, this);
            this.emit('add', gameObject, this);
        }

        return this;
    };

    var AddChildMethods$8 = {
        addBackground(gameObject, paddingConfig, childKey) {
            if (this.backgroundChildren === undefined) {
                this.backgroundChildren = [];
            }

            if (typeof (paddingConfig) === 'string') {
                childKey = paddingConfig;
                paddingConfig = undefined;
            }

            if (paddingConfig === undefined) {
                paddingConfig = 0;
            }

            AddChild$1.call(this, gameObject);
            this.backgroundChildren.push(gameObject);

            var config = this.getSizerConfig(gameObject);
            config.padding = GetBoundsConfig$1(paddingConfig);

            if (childKey !== undefined) {
                this.addChildrenMap(childKey, gameObject);
            }
            return this;
        },

        isBackground(gameObject) {
            if (this.backgroundChildren === undefined) {
                return false;
            }
            return (this.backgroundChildren.indexOf(gameObject) !== -1);
        }
    };

    var GetParent = function (gameObject, name) {
        var parent = null;
        if (name === undefined) {
            if (gameObject.hasOwnProperty('rexContainer')) {
                parent = gameObject.rexContainer.parent;
                if (parent) {
                    if (!parent.isRexSizer) {
                        // Try to get sizer parent
                        parent = GetParent(parent);
                    }
                } else {
                    parent = null;
                }
            }

        } else {
            parent = GetParent(gameObject);
            while (parent) {
                if (parent.name === name) {
                    break;
                }
                parent = GetParent(parent);
            }
        }
        return parent;
    };

    var GetTopmostParent = function (gameObject) {
        var parent = GetParent(gameObject);
        while (parent) {
            gameObject = parent;
            parent = GetParent(parent);
        }
        return gameObject;
    };


    var GetParentSizerMethods = {
        getParentSizer(gameObject, name) {
            if (typeof (gameObject) === 'string') {
                name = gameObject;
                gameObject = undefined;
            }
            if (gameObject === undefined) {
                gameObject = this;
            }
            return GetParent(gameObject, name);
        },

        getTopmostSizer(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }
            return GetTopmostParent(gameObject);
        },

        hasParentSizer(parentGameObject, gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }

            var parent = GetParent(gameObject);
            while (parent) {
                if (parent === parentGameObject) {
                    return true;
                }
                parent = GetParent(parent);
            }

            return false;
        },

        hasChild(child, gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }

            return this.hasParentSizer(gameObject, child);
        }
    };

    const RemoveItem$5 = Phaser.Utils.Array.Remove;
    const ContainerRemove = ContainerLite.prototype.remove;
    const GetParentSizer$1 = GetParentSizerMethods.getParentSizer;

    var RemoveChild = function (gameObject, destroyChild) {
        // Invoke parent's removeChildCallback method
        var parent = GetParentSizer$1(gameObject);
        while (parent) {
            if (parent.removeChildCallback) {
                parent.removeChildCallback(gameObject, destroyChild);
            }
            parent = GetParentSizer$1(parent);
        }

        if (this.isBackground(gameObject)) {
            RemoveItem$5(this.backgroundChildren, gameObject);
        }
        ContainerRemove.call(this, gameObject, destroyChild);

        if (!destroyChild && this.sizerEventsEnable) {
            gameObject.emit('sizer.remove', gameObject, this);
            this.emit('remove', gameObject, this);
        }

        return this;
    };

    const RemoveItem$4 = Phaser.Utils.Array.Remove;
    const GetParentSizer = GetParentSizerMethods.getParentSizer;

    var RemoveChildMethods$7 = {
        removeFromParentSizer() {
            var parent = GetParentSizer(gameObject);
            if (parent) {
                parent.remove(this);
            }
            return this;
        },

        removeBackground(gameObject, destroyChild) {
            if (this.backgroundChildren === undefined) {
                return this;
            }

            if (this.getParentSizer(gameObject) !== this) {
                return this;
            }

            RemoveItem$4(this.backgroundChildren, gameObject);
            RemoveChild.call(this, gameObject, destroyChild);
            return this;
        },

        removeAllBackgrounds(destroyChild) {
            if (this.backgroundChildren === undefined) {
                return this;
            }

            for (var i = this.backgroundChildren.length - 1; i >= 0; i--) {
                this.remove(this.backgroundChildren[i], destroyChild);
            }
            return this;
        },
    };

    var AddChildrenMap = function (key, gameObject) {
        if (typeof (key) === 'string') {
            this.childrenMap[key] = gameObject;
        } else {
            var config = key;
            for (key in config) {
                this.childrenMap[key] = config[key];
            }
        }
        return this;
    };

    var RemoveChildrenMap = function (key) {
        if (typeof (key) === 'object') {
            var gameObject = key;
            for (var key in this.childrenMap) {
                if (this.childrenMap[key] === gameObject) {
                    delete this.childrenMap[key];
                    return this;
                }
            }
        }

        delete this.childrenMap[key];
        return this;
    };

    var GetElement = function (mapNameList, recursive) {
        if (typeof (mapNameList) === 'string') {
            mapNameList = mapNameList.split('.');
        }
        if (mapNameList.length === 0) {
            return undefined;
        }

        if (recursive === undefined) {
            recursive = false;
        }

        var name = mapNameList.shift(),
            element = null;
        if (name.charAt(0) === '#') { // Get element by name
            name = name.substring(1);
            element = this.getByName(name, recursive);
        } else if ((mapNameList.length === 0) && recursive) { // Get element by single key and recursive        
            var childrenMap = this.childrenMap;
            if (childrenMap) {
                var queue = [childrenMap];
                var child;
                while (queue.length) {
                    childrenMap = queue.shift();

                    for (var key in childrenMap) {
                        child = childrenMap[key];
                        if (key === name) {
                            element = child;
                            break;  // Leave for-loop
                        } else if (child && (typeof (child) === 'object') && child.childrenMap) {
                            queue.push(child.childrenMap);
                        }
                    }

                    if (element) { // leave while-loop
                        break;
                    }
                }
            }

        } else if (name.indexOf('[') === (-1)) { // Get element by key
            if (this.childrenMap) {
                element = this.childrenMap[name];
            }
        } else { // Get element by key[]
            var innerMatch = name.match(RE_OBJ);
            if (innerMatch != null) {
                if (this.childrenMap) {
                    var elements = this.childrenMap[innerMatch[1]];
                    if (elements) {
                        element = elements[innerMatch[2]];
                    }
                }
            }
        }

        if (mapNameList.length === 0) {
            return element;
        } else if (element && element.childrenMap) {
            return element.getElement(mapNameList);
        } else {
            return null;
        }
    };

    const RE_OBJ = /(\S+)\[(\d+)\]/i;

    var GetChildIndex = function (child) {
        if (Array.isArray(this.sizerChildren)) {
            var index = this.sizerChildren.indexOf(child);
            if (index === -1) {
                index = null;
            }
            return index;

        } else {
            if (this.getParentSizer(child) !== this) {
                return null;
            }

            for (var key in this.sizerChildren) {
                if (this.sizerChildre[key] === child) {
                    return key;
                }
            }
            return null;
        }
    };

    var PaddingMethods = {
        getInnerPadding(key) {
            return GetPadding$1(this.space, key);
        },

        setInnerPadding(key, value) {
            SetPadding$1(this.space, key, value);
            return this;
        },

        getOuterPadding(key) {
            return GetPadding$1(this.getSizerConfig(this).padding, key);
        },

        setOuterPadding(key, value) {
            SetPadding$1(this.getSizerConfig(this).padding, key, value);
            return this;
        },

        getChildOuterPadding(child, key) {
            if (typeof (child) === 'string') {
                child = this.getElement(child);
            }
            return GetPadding$1(this.getSizerConfig(child).padding, key);
        },

        setChildOuterPadding(child, key, value) {
            if (typeof (child) === 'string') {
                child = this.getElement(child);
            }
            SetPadding$1(this.getSizerConfig(child).padding, key, value);
            return this;
        },
    };

    var ResolveWidth$3 = function (width) {
        var childrenWidth = this.childrenWidth;
        if (childrenWidth === undefined) {  // Can't resolve child width
            return undefined;
        }

        var minWidth = (this.minWidth !== undefined) ? (this.minWidth * this.scaleX) : 0;
        if (width === undefined) {
            width = Math.max(minWidth, childrenWidth);

            if (this.layoutWarnEnable) {
                if ((minWidth > 0) && (childrenWidth > minWidth)) {
                    console.warn(`Layout width warn: ${this.constructor.name}'s minWidth (${minWidth}) < childrenWidth (${childrenWidth})`);
                }
            }
        } else {
            if (this.layoutWarnEnable) {
                if ((minWidth > width) || (childrenWidth > width)) {
                    console.warn(`Layout width warn: ${this.constructor.name}'s minWidth (${minWidth}) or childrenWidth (${childrenWidth} > targetWidth ${width})`);
                }
            }
        }

        return width;
    };

    var HasWidthWrap$2 = function () {
        var child;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (
                (!child) ||
                (child.isRexSizer && child.ignoreLayout) ||
                (!child.runWidthWrap)
            ) {
                continue;
            }

            if (
                !child.hasWidthWrap ||
                child.hasWidthWrap()
            ) {
                return true;
            }
        }

        return false;
    };

    var ResolveChildrenWidth$1 = function (parentWidth) {
        // Resolve width of sizer children
        var child, expandedChildWidth, childWidth;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (child && child.isRexSizer && !child.ignoreLayout) {
                expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
                childWidth = child.resolveWidth(expandedChildWidth);
                if (childWidth === undefined) {
                    childWidth = expandedChildWidth;
                }
                child.resolveChildrenWidth(childWidth);
            }
        }
    };

    // Default method
    var RunWidthWrap$3 = function (parentWidth) {
        var child, expandedChildWidth, childWidth;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (
                (!child) ||
                (child.isRexSizer && child.ignoreLayout) ||
                (!child.runWidthWrap)
            ) {
                continue;
            }

            expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
            if (child.isRexSizer) {
                childWidth = child.resolveWidth(expandedChildWidth);
                if (childWidth === undefined) {
                    childWidth = expandedChildWidth;
                }
            } else {
                childWidth = expandedChildWidth;
            }
            child.runWidthWrap(childWidth);
        }
        return this;
    };

    var ResolveHeight$3 = function (height) {
        var childrenHeight = this.childrenHeight;
        if (childrenHeight === undefined) {  // Can't resolve child height
            return undefined;
        }

        var minHeight = (this.minHeight !== undefined) ? (this.minHeight * this.scaleY) : 0;
        if (height === undefined) {
            height = Math.max(minHeight, childrenHeight);

            if (this.layoutWarnEnable) {
                if ((minHeight > 0) && (childrenHeight > minHeight)) {
                    console.warn(`Layout height warn: ${this.constructor.name}'s minHeight (${minHeight}) < childrenHeight (${childrenHeight})`);
                }
            }
        } else {
            if (this.layoutWarnEnable) {
                if ((minHeight > height) || (childrenHeight > height)) {
                    console.warn(`Layout height warn: ${this.constructor.name}'s minHeight (${minHeight}) or childrenHeight (${childrenHeight}) > targetHeight (${height})`);
                }
            }
        }

        return height;
    };

    var HasHeightWrap$2 = function () {
        var child;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (
                (!child) ||
                (child.isRexSizer && child.ignoreLayout) ||
                (!child.runHeightWrap)
            ) {
                continue;
            }

            if (
                !child.hasHeightWrap ||
                child.hasHeightWrap()     // all kind of sizers has hasHeightWrap method
            ) {
                return true;
            }
        }

        return false;
    };

    var ResolveChildrenHeight$1 = function (parentHeight) {
        // Resolve width of sizer children
        var child, expandedChildHeight, childHeight;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (child && child.isRexSizer && !child.ignoreLayout) {
                expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
                childHeight = child.resolveHeight(expandedChildHeight);
                if (childHeight === undefined) {
                    childHeight = expandedChildHeight;
                }
                child.resolveChildrenHeight(childHeight);
            }
        }
    };

    // Default method
    var RunHeightWrap$3 = function (parentHeight) {
        var child, expandedChildHeight, childHeight;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (
                (!child) ||
                (child.isRexSizer && child.ignoreLayout) ||
                (!child.runHeightWrap)
            ) {
                continue;
            }

            expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
            if (child.isRexSizer) {
                childHeight = child.resolveHeight(expandedChildHeight);
                if (childHeight === undefined) {
                    childHeight = expandedChildHeight;
                }
            } else {
                childHeight = expandedChildHeight;
            }
            child.runHeightWrap(childHeight);
        }
        return this;
    };

    var GetChildWidth = function (child) {
        var childWidth;
        if (child.isRexSizer) { // Sizer game object
            var childrenWidth = child.childrenWidth;
            if (childrenWidth == undefined) {
                return undefined;
            }

            var childMinWidth = child.minWidth * child.scaleX;
            childWidth = Math.max(childMinWidth, childrenWidth);
        } else {  // Normal game object
            if (child.minWidth !== undefined) {  // Force minWidth
                childWidth = child.minWidth;
            } else if (child._minWidth !== undefined) {  // Force minWidth
                childWidth = child._minWidth;
            } else {
                childWidth = GetDisplayWidth(child);
            }
        }

        return childWidth;
    };

    var GetChildHeight = function (child) {
        var childHeight;
        if (child.isRexSizer) {  // Sizer game object
            var childrenHeight = child.childrenHeight;
            if (childrenHeight === undefined) {
                return undefined;
            }

            var childMinHeight = child.minHeight * child.scaleY;
            childHeight = Math.max(childMinHeight, childrenHeight);
        } else {  // Normal game object
            if (child.minHeight !== undefined) {  // Force minHeight
                childHeight = child.minHeight;
            } else if (child._minHeight !== undefined) {
                childHeight = child._minHeight;
            } else {
                childHeight = GetDisplayHeight(child);
            }
        }
        return childHeight;
    };

    // Override
    var GetExpandedChildWidth$4 = function (child, parentWidth) {
        return parentWidth;
    };

    // Override
    var GetExpandedChildHeight$4 = function (child, parentHeight) {
        return parentHeight;
    };

    // Override
    var GetChildrenWidth$5 = function () {
        return 0;
    };

    // Override
    var GetChildrenHeight$5 = function () {
        return 0;
    };

    var GetAllChildrenSizers = function (out) {
        if (out === undefined) {
            out = [];
        }
        var startIdx = out.length;
        var children = this.getChildrenSizers(out);
        var endIdx = out.length;
        for (var i = startIdx; i < endIdx; i++) {
            children[i].getAllChildrenSizers(out);
        }

        return out;
    };

    // Default method
    var GetChildrenSizers$5 = function(out) {
        if (out === undefined) {
            out = [];
        }
        return out;
    };

    var GetShownChildrenMethods = {
        getShownChildren(out) {
            if (out === undefined) {
                out = [];
            }
            var children = this.children,
                child;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = children[i];
                if (child.rexSizer && child.rexSizer.hidden) { // Don't add hidden child
                    continue;
                }

                out.push(child);
            }

            return out;
        },

        getAllShownChildren(out) {
            if (out === undefined) {
                out = [];
            }

            var queue = [this];
            while (queue.length > 0) {
                var current = queue.shift();
                if (current.rexSizer && current.rexSizer.hidden) {
                    continue;
                }

                if (current !== this) {
                    out.push(current);
                }

                if (current.isRexContainerLite) {
                    queue.push(...current.children);
                }
            }

            return out;
        }
    };

    var PreLayout$4 = function () {
        this._childrenWidth = undefined;
        this._childrenHeight = undefined;

        var children = this.getChildrenSizers(),
            child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.ignoreLayout) {
                continue;
            }
            child.preLayout();
        }
    };

    var Layout = function () {
        this.runLayout();
        return this;
    };

    var HasResizeMethod = function (gameObject) {
        // 1st pass : Has `resize` method?
        if (gameObject.resize) {
            return true;
        }

        // 2nd pass : Has `setSize` method?
        // Does not have `setSize` method
        if (!gameObject.setSize) {
            return false;
        }

        // Has `setSize` method but only for internal usage.
        for (var i = 0, cnt = ExcludeClassList$1.length; i < cnt; i++) {
            var excludeClass = ExcludeClassList$1[i];
            if (excludeClass && gameObject instanceof excludeClass) {
                return false;
            }
        }

        return true;
    };

    var ExcludeClassList$1 = [
        Phaser.GameObjects.Image,
        Phaser.GameObjects.Sprite,
        Phaser.GameObjects.Mesh,
        Phaser.GameObjects.Shader,
        Phaser.GameObjects.Video
    ];

    var CanSetDisplaySize = function (gameObject) {
        if (gameObject.displayWidth === undefined) {
            return false;
        }

        for (var i = 0, cnt = ExcludeClassList.length; i < cnt; i++) {
            var excludeClass = ExcludeClassList[i];
            if (excludeClass && gameObject instanceof excludeClass) {
                return false;
            }
        }

        return true;
    };

    var ExcludeClassList = [
        Phaser.GameObjects.BitmapText,
    ];

    var ResizeGameObject = function (gameObject, newDisplayWidth, newDisplayHeight) {
        // Set display size

        if (!gameObject || ((newDisplayWidth === undefined) && (newDisplayHeight === undefined))) {
            return;
        }

        if (HasResizeMethod(gameObject)) { // Has `resize`, or `setSize` method
            var newWidth, newHeight;
            if (newDisplayWidth === undefined) {
                newWidth = gameObject.width;
            } else {
                newWidth = newDisplayWidth / gameObject.scaleX;
            }
            if (newDisplayHeight === undefined) {
                newHeight = gameObject.height;
            } else {
                newHeight = newDisplayHeight / gameObject.scaleY;
            }

            if (gameObject.resize) {
                gameObject.resize(newWidth, newHeight);
            } else {
                gameObject.setSize(newWidth, newHeight);
            }

        } else {
            var canSetDisplaySize = CanSetDisplaySize(gameObject);
            if (newDisplayWidth !== undefined) {
                if (canSetDisplaySize) {
                    gameObject.displayWidth = newDisplayWidth;
                } else {
                    gameObject.scaleX = newDisplayWidth / gameObject.width;
                }
            }
            if (newDisplayHeight !== undefined) {
                if (canSetDisplaySize) {
                    gameObject.displayHeight = newDisplayHeight;
                } else {
                    gameObject.scaleY = newDisplayHeight / gameObject.height;
                }
            }

        }
    };

    // Override
    var RunLayout$1 = function (parent, newWidth, newHeight) {
        // Skip hidden or !dirty sizer
        if (this.ignoreLayout) {
            return this;
        }

        var isTopmostParent = !parent;
        // Pre-processor, top parent only
        if (isTopmostParent) {
            this.preLayout();
        }

        var runWidthWrap, runHeightWrap;
        if (isTopmostParent || parent.runChildrenWrapFlag) {
            runWidthWrap = this.hasWidthWrap();
            runHeightWrap = this.hasHeightWrap();
        } else {
            runWidthWrap = false;
            runHeightWrap = false;
        }

        var size = ResolveSize(this, newWidth, newHeight, runWidthWrap, runHeightWrap);
        if (!size) {
            console.error('Can\'t resolve size of ', this);
        }

        var width = size.width;
        var height = size.height;

        // Resize parent
        ResizeGameObject(this, width, height);

        if (this.sizerEventsEnable) {
            if (this.layoutedChildren === undefined) {
                this.layoutedChildren = [];
            }
        }

        // Layout children    
        this.layoutChildren();

        // Layout background children
        this.layoutBackgrounds();

        if (this.sizerEventsEnable) {
            this.emit('postlayout', this.layoutedChildren, this);
            this.layoutedChildren.length = 0;
        }

        // Custom postLayout callback
        this.postLayout(parent, width, height);

        // Post-processor, top parent only
        if (isTopmostParent) {
            if (this._anchor) {
                this._anchor.updatePosition();
            }
        }

        return this;
    };

    var ResolveSize = function (self, width, height, runWidthWrap, runHeightWrap) {
        var newWidth = ResolveWidth$2(self, width, runWidthWrap);

        var newHeight = ResolveHeight$2(self, height, runHeightWrap);

        if (newWidth === undefined) {
            newWidth = ResolveWidth$2(self, width, runWidthWrap);
        }

        if ((newWidth !== undefined) && (newHeight !== undefined)) {
            return {
                width: newWidth,
                height: newHeight
            }
        }

        return false;
    };

    var ResolveWidth$2 = function (self, width, runWidthWrap) {
        // Calculate parent width
        var width = self.resolveWidth(width);

        // Calculate all children width, run width wrap
        if (width !== undefined) {
            if (runWidthWrap) {
                self.resolveChildrenWidth(width);
                self.runWidthWrap(width);
            }
        }

        return width;
    };

    var ResolveHeight$2 = function (self, height, runHeightWrap) {
        // Calculate parent height
        var height = self.resolveHeight(height);

        // Calculate all children width, run width wrap
        if (height !== undefined) {
            if (runHeightWrap) {
                self.resolveChildrenHeight(height);
                self.runHeightWrap(height);
            }
        }

        return height;
    };

    // Override
    var LayoutChildren$6 = function () {

    };

    // Override
    var PostLayout = function (parent, newWidth, newHeight) {
        return this;
    };

    var DefaultResizeCallback = function (width, height, gameObject, anchor) {
        ResizeGameObject(gameObject, width, height);
    };

    const GetValue$2P = Phaser.Utils.Objects.GetValue;

    class Anchor extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, { eventEmitter: false });
            // No event emitter
            // this.parent = gameObject;

            this.viewport = undefined;
            this.resetFromJSON(config);
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            this.autoAnchor(false);

            this.viewport = undefined;
            this.onUpdateViewportCallback = undefined;
            this.onUpdateViewportCallbackScope = undefined;
            this.onResizeCallback = undefined;
            this.onResizeCallbackScope = undefined;

            super.shutdown(fromScene);
        }

        resetFromJSON(o) {
            if (o === undefined) {
                o = {};
            }

            // Position
            var alignX, configX;
            if (o.x !== undefined) {
                alignX = null;
                configX = o.x;
            } else if (o.left !== undefined) {
                alignX = 0;
                configX = o.left;
            } else if (o.right !== undefined) {
                alignX = 1;
                configX = o.right;
            } else if (o.centerX !== undefined) {
                alignX = 0.5;
                configX = o.centerX;
            }

            var alignY, configY;
            if (o.y !== undefined) {
                alignY = null;
                configY = o.y;
            } else if (o.top !== undefined) {
                alignY = 0;
                configY = o.top;
            } else if (o.bottom !== undefined) {
                alignY = 1;
                configY = o.bottom;
            } else if (o.centerY !== undefined) {
                alignY = 0.5;
                configY = o.centerY;
            }

            var percentageX, offsetX;
            if (configX !== undefined) {
                configX = configX.replace('left', '0%').replace('right', '100%').replace('center', '50%').split('%');
                percentageX = parseFloat(configX[0]) / 100;
                offsetX = (configX[1] === '') ? 0 : parseFloat(configX[1]);
            }
            var percentageY, offsetY;
            if (configY !== undefined) {
                configY = configY.replace('top', '0%').replace('bottom', '100%').replace('center', '50%').split('%');
                percentageY = parseFloat(configY[0]) / 100;
                offsetY = (configY[1] === '') ? 0 : parseFloat(configY[1]);
            }

            // Size
            var configWidth = o.width;
            var percentageWidth, paddingWidth;
            if (configWidth !== undefined) {
                configWidth = configWidth.split('%');
                percentageWidth = parseFloat(configWidth[0]) / 100;
                paddingWidth = (configWidth[1] === '') ? 0 : parseFloat(configWidth[1]);
            }

            var configHeight = o.height;
            var percentageHeight, paddingHeight;
            if (configHeight !== undefined) {
                configHeight = configHeight.split('%');
                percentageHeight = parseFloat(configHeight[0]) / 100;
                paddingHeight = (configHeight[1] === '') ? 0 : parseFloat(configHeight[1]);
            }

            // Position
            this.setAlign(alignX, alignY);
            this.setPercentage(percentageX, percentageY);
            this.setOffset(offsetX, offsetY);
            // Size
            this.setSizePercentage(percentageWidth, percentageHeight);
            this.setSizePadding(paddingWidth, paddingHeight);

            var onResizeCallback = GetValue$2P(o, 'onResizeCallback', DefaultResizeCallback);
            var onResizeCallbackScope = GetValue$2P(o, 'onResizeCallbackScope');
            this.setResizeCallback(onResizeCallback, onResizeCallbackScope);

            var onUpdateViewportCallback = GetValue$2P(o, 'onUpdateViewportCallback');
            var onUpdateViewportCallbackScope = GetValue$2P(o, 'onUpdateViewportCallbackScope');
            this.setUpdateViewportCallback(onUpdateViewportCallback, onUpdateViewportCallbackScope);

            this.autoAnchor(o.enable);

            return this;
        }

        autoAnchor(enable) {
            if (enable === undefined) {
                enable = true;
            }

            enable = !!enable;
            if (this.autoAnchorEnable === enable) {
                return this;
            }

            if (enable) {
                this.scene.sys.scale.on('resize', this.anchor, this);
                this.anchor();
            } else {
                this.scene.sys.scale.off('resize', this.anchor, this);
            }

            this.autoAnchorEnable = enable;

            return this;
        }

        // Position
        setAlign(x, y) {
            this.alignX = x;
            this.alignY = y;
            return this;
        }

        setPercentage(x, y) {
            this.percentageX = x;
            this.percentageY = y;
            return this;
        }

        setOffset(x, y) {
            this.offsetX = x;
            this.offsetY = y;
            return this;
        }

        // Size
        setSizePercentage(width, height) {
            this.percentageWidth = width;
            this.percentageHeight = height;
            return this;
        }

        setSizePadding(width, height) {
            this.paddingWidth = width;
            this.paddingHeight = height;
            return this;
        }

        setResizeCallback(callback, scope) {
            this.onResizeCallback = callback;
            this.onResizeCallbackScope = scope;
            return this;
        }

        setUpdateViewportCallback(callback, scope) {
            this.onUpdateViewportCallback = callback;
            this.onUpdateViewportCallbackScope = scope;
            return this;
        }

        anchor() {
            this.updateViewport();
            this.updateSize();
            this.updatePosition();
            return this;
        }

        updateSize() {
            var callback = this.onResizeCallback,
                scope = this.onResizeCallbackScope;
            var newWidth = this.anchorWidth,
                newHeight = this.anchorHeight;
            if (((newWidth === undefined) && (newHeight === undefined)) || !callback) {
                return;
            }

            var gameObject = this.parent;
            if (newWidth === undefined) {
                newWidth = gameObject.width;
            }
            if (newHeight === undefined) {
                newHeight = gameObject.height;
            }

            if (scope) {
                callback.call(scope, newWidth, newHeight, gameObject, this);
            } else {
                callback(newWidth, newHeight, gameObject, this);
            }
        }

        updatePosition() {
            var gameObject = this.parent;

            if (this.alignX === null) {
                gameObject.x = this.anchorX;
            } else if (this.alignX !== undefined) {
                gameObject.x = this.anchorX + (gameObject.displayWidth * (gameObject.originX - this.alignX));
            }

            if (this.alignY === null) {
                gameObject.y = this.anchorY;
            } else if (this.alignY !== undefined) {
                gameObject.y = this.anchorY + (gameObject.displayHeight * (gameObject.originY - this.alignY));
            }

            return this;
        }

        get anchorX() {
            return this.viewport.x + (this.viewport.width * this.percentageX) + this.offsetX;
        }

        get anchorY() {
            return this.viewport.y + (this.viewport.height * this.percentageY) + this.offsetY;
        }

        get anchorWidth() {
            if (this.percentageWidth === undefined) {
                return undefined;
            }
            return (this.viewport.width * this.percentageWidth) + this.paddingWidth;
        }

        get anchorHeight() {
            if (this.percentageHeight === undefined) {
                return undefined;
            }
            return (this.viewport.height * this.percentageHeight) + this.paddingHeight;
        }

        updateViewport() {
            var camera = this.parent.scene.cameras.main;
            this.viewport = GetViewport(this.scene, camera, this.viewport);

            var viewport = this.viewport;
            var callback = this.onUpdateViewportCallback,
                scope = this.onUpdateViewportCallbackScope;
            if (callback) {
                if (scope) {
                    callback.call(scope, viewport, this.parent, this);
                } else {
                    callback(viewport, this.parent, this);
                }
            }
        }
    }

    var SetAnchor = function (config) {
        if (config === undefined) {
            config = {};
        }

        // Assign default onResizeCallback if not given    
        var hasMinWidth = config.hasOwnProperty('width');
        var hasMinHeight = config.hasOwnProperty('height');
        var hasOnResizeCallback = config.hasOwnProperty('onResizeCallback');
        if ((hasMinWidth || hasMinHeight) && !hasOnResizeCallback) {
            config.onResizeCallback = function (width, height, sizer) {
                if (hasMinWidth) {
                    sizer.setMinWidth(width);
                }

                if (hasMinHeight) {
                    sizer.setMinHeight(height);
                }

                sizer.layout();
            };
        }

        if (this._anchor === undefined) {
            this._anchor = new Anchor(this, config);
        } else {
            this._anchor.resetFromJSON(config);
        }
        return this;
    };

    const GetValue$2O = Phaser.Utils.Objects.GetValue;
    const GetAdvancedValue$3 = Phaser.Utils.Objects.GetAdvancedValue;
    const Linear$h = Phaser.Math.Linear;

    class Scale extends EaseValueTaskBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;
            // this.timer

            this.scaleStart = {};
            this.scaleEnd = {};

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);

            this.setMode(GetValue$2O(o, 'mode', 0));
            this.setScaleRange(
                GetAdvancedValue$3(o, 'start', undefined),
                GetAdvancedValue$3(o, 'end', 0)
            );

            return this;
        }

        setMode(m) {
            if (typeof (m) === 'string') {
                m = MODE$3[m];
            }
            this.mode = m;
            return this;
        }

        setScaleRange(start, end) {
            if (typeof (start) === 'number') {
                this.startX = start;
                this.startY = start;
            } else {
                this.startX = GetAdvancedValue$3(start, 'x', this.parent.scaleX);
                this.startY = GetAdvancedValue$3(start, 'y', this.parent.scaleY);
            }
            if (typeof (end) === 'number') {
                this.endX = end;
                this.endY = end;
            } else {
                this.endX = GetAdvancedValue$3(end, 'x', undefined);
                this.endY = GetAdvancedValue$3(end, 'y', undefined);
            }

            this.hasScaleX = (this.startX !== undefined) && (this.endX !== undefined);
            this.hasScaleY = (this.startY !== undefined) && (this.endY !== undefined);
            return this;
        }

        start() {
            if (this.timer.isRunning) {
                return this;
            }

            var gameObject = this.parent;
            if (this.hasScaleX) {
                gameObject.scaleX = this.startX;
            }
            if (this.hasScaleY) {
                gameObject.scaleY = this.startY;
            }

            var repeat = this.repeat;
            if (this.mode === 2) {  // Yoyo
                if (repeat !== -1) {
                    repeat = ((repeat + 1) * 2) - 1;
                }
            }

            this.timer
                .setDelay(this.delay)
                .setDuration(this.duration)
                .setRepeat(repeat);

            super.start();
            return this;
        }

        updateTarget(gameObject, timer) {
            var t = timer.t;
            if (timer.isOddIteration) {  // Yoyo
                t = 1 - t;
            }
            t = this.easeFn(t);

            if (this.hasScaleX) {
                gameObject.scaleX = Linear$h(this.startX, this.endX, t);
            }
            if (this.hasScaleY) {
                gameObject.scaleY = Linear$h(this.startY, this.endY, t);
            }
        }

        complete() {
            super.complete();

            if (this.mode === 1) {
                this.parent.destroy();
                // Will also destroy this behavior
            }
            return this;
        }
    }

    const MODE$3 = {
        stop: 0,
        destroy: 1,
        yoyo: 2
    };

    var PopUp$1 = function (gameObject, duration, orientation, ease, scale) {
        if (ease === undefined) {
            ease = 'Cubic';
        }

        // Ease scale from 0 to current scale
        var start, end;
        switch (orientation) {
            case 0:
            case 'x':
                start = { x: 0 };
                end = { x: gameObject.scaleX };
                break;
            case 1:
            case 'y':
                start = { y: 0 };
                end = { y: gameObject.scaleY };
                break;
            default:
                start = 0;
                end = gameObject.scale;
                break;
        }

        var config = {
            mode: 0,
            start: start,
            end: end,
            duration: duration,
            ease: ease
        };

        if (scale === undefined) {
            scale = new Scale(gameObject, config);
        } else {
            scale.resetFromJSON(config);
        }
        scale.restart();

        return scale;
    };

    var ScaleDownDestroy = function (gameObject, duration, orientation, ease, destroyMode, scale) {
        if (ease === undefined) {
            ease = 'Linear';
        }

        // Ease from current scale to 0
        if (destroyMode instanceof Scale) {
            scale = destroyMode;
            destroyMode = undefined;
        }

        if (destroyMode === undefined) {
            destroyMode = true;
        }

        var config = {};
        config.mode = (destroyMode) ? 1 : 0;
        switch (orientation) {
            case 0:
            case 'x':
                config.end = {
                    x: 0
                };
                break;
            case 1:
            case 'y':
                config.end = {
                    y: 0
                };
                break;
            default:
                config.end = 0;
                break;
        }
        config.duration = duration;
        config.ease = ease;

        if (scale === undefined) {
            scale = new Scale(gameObject, config);
        } else {
            scale.resetFromJSON(config);
        }
        scale.restart();

        return scale;
    };

    var Yoyo = function (gameObject, duration, peakValue, repeat, orientation, ease, scale) {
        if (peakValue === undefined) {
            peakValue = 1.2;
        }
        if (repeat === undefined) {
            repeat = 0;
        }
        if (ease === undefined) {
            ease = 'Cubic';
        }

        // Ease scale from 0 to current scale
        var start, end;
        switch (orientation) {
            case 0:
            case 'x':
                start = { x: gameObject.scaleX };
                end = { x: peakValue };
                break;
            case 1:
            case 'y':
                start = { y: gameObject.scaleX };
                end = { y: peakValue };
                break;
            default:
                start = gameObject.scaleX;
                end = peakValue;
                break;
        }

        var config = {
            mode: 2,
            start: start,
            end: end,
            duration: (duration / 2),
            ease: ease,
            repeat: repeat,
        };

        if (scale === undefined) {
            scale = new Scale(gameObject, config);
        } else {
            scale.resetFromJSON(config);
        }
        scale.restart();

        return scale;
    };

    const IsPlainObject$C = Phaser.Utils.Objects.IsPlainObject;

    var ScaleMethods = {
        onInitScale() {
            var gameObject = this;
            var scale = this._scaleBehavior;

            // Route 'complete' of scale to gameObject
            scale.completeEventName = undefined;
            scale.on('complete', function () {
                if (scale.completeEventName) {
                    gameObject.emit(scale.completeEventName, gameObject);
                    scale.completeEventName = undefined;
                }
            });
        },

        popUp(duration, orientation, ease) {
            if (IsPlainObject$C(duration)) {
                var config = duration;
                duration = config.duration;
                orientation = config.orientation;
                ease = config.ease;
            }

            var isInit = (this._scaleBehavior === undefined);

            this._scaleBehavior = PopUp$1(this, duration, orientation, ease, this._scaleBehavior);

            if (isInit) {
                this.onInitScale();
            }

            this._scaleBehavior.completeEventName = 'popup.complete';

            return this;
        },

        popUpPromise(duration, orientation, ease) {
            this.popUp(duration, orientation, ease);
            return WaitComplete(this._scaleBehavior);
        },

        isRunningPopUp() {
            return this._scaleBehavior && (this._scaleBehavior.completeEventName === 'popup.complete');
        },

        scaleDownDestroy(duration, orientation, ease, destroyMode) {
            if (IsPlainObject$C(duration)) {
                var config = duration;
                duration = config.duration;
                orientation = config.orientation;
                ease = config.ease;
                destroyMode = config.destroy;
            }

            var isInit = (this._scaleBehavior === undefined);

            this._scaleBehavior = ScaleDownDestroy(this, duration, orientation, ease, destroyMode, this._scaleBehavior);

            if (isInit) {
                this.onInitScale();
            }

            this._scaleBehavior.completeEventName = 'scaledown.complete';

            return this;
        },

        scaleDownDestroyPromise(duration, orientation, ease, destroyMode) {
            this.scaleDownDestroy(duration, orientation, ease, destroyMode);
            return WaitComplete(this._scaleBehavior);
        },

        scaleDown(duration, orientation, ease) {
            this.scaleDownDestroy(duration, orientation, ease, false);
            return this;
        },

        scaleDownPromise(duration, orientation, ease) {
            this.scaleDown(duration, orientation, ease);
            return WaitComplete(this._scaleBehavior);
        },

        isRunningScaleDown() {
            return this._scaleBehavior && (this._scaleBehavior.completeEventName === 'scaledown.complete');
        },

        scaleYoyo(duration, peakValue, repeat, orientation, ease) {
            if (IsPlainObject$C(duration)) {
                var config = duration;
                duration = config.duration;
                peakValue = config.peakValue;
                repeat = config.repeat;
                orientation = config.orientation;
                ease = config.ease;
            }

            var isInit = (this._scaleBehavior === undefined);

            this._scaleBehavior = Yoyo(this, duration, peakValue, repeat, orientation, ease, this._scaleBehavior);

            if (isInit) {
                this.onInitScale();
            }

            this._scaleBehavior.completeEventName = 'scaleyoyo.complete';

            return this;
        },

        scaleYoyoPromise(duration, peakValue, repeat, orientation, ease) {
            this.scaleYoyo(duration, peakValue, repeat, orientation, ease);
            return WaitComplete(this._scaleBehavior);
        },

        isRunningScaleYoyo() {
            return this._scaleBehavior && (this._scaleBehavior.completeEventName = 'scaleyoyo.complete');
        },

        isRunningEaseScale() {
            return this.isRunningPopUp() || this.isRunningScaleDown() || this.isRunningScaleYoyo();
        },
    };

    var methods$z = {};
    Object.assign(methods$z, ScaleMethods);

    methods$z.onInitScale = function () {
        ScaleMethods.onInitScale.call(this);

        var gameObject = this;
        var scale = this._scaleBehavior;
        // Update local state
        scale.on('update', function () {
            var parent = GetParentSizerMethods.getParentSizer(gameObject);
            if (parent) {
                parent.resetChildPositionState(gameObject);
            }
        });
    };

    const GetValue$2N = Phaser.Utils.Objects.GetValue;
    const GetAdvancedValue$2 = Phaser.Utils.Objects.GetAdvancedValue;
    const Linear$g = Phaser.Math.Linear;

    let Fade$2 = class Fade extends EaseValueTaskBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;
            // this.timer

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);

            this.setMode(GetValue$2N(o, 'mode', 0));
            this.setAlphaRange(
                GetAdvancedValue$2(o, 'start', this.parent.alpha),
                GetAdvancedValue$2(o, 'end', 0)
            );
            return this;
        }

        setMode(m) {
            if (typeof (m) === 'string') {
                m = MODE$2[m];
            }
            this.mode = m;
            return this;
        }

        setAlphaRange(start, end) {
            this.alphaStart = start;
            this.alphaEnd = end;
            return this;
        }

        start() {
            if (this.timer.isRunning) {
                return this;
            }

            var gameObject = this.parent;
            gameObject.setAlpha(this.alphaStart);

            this.timer
                .setDelay(this.delay)
                .setDuration(this.duration)
                .setRepeat((this.mode === 2) ? -1 : 0);

            super.start();
            return this;
        }

        updateTarget(gameObject, timer) {
            var t = timer.t;
            if (timer.isOddIteration) {  // Yoyo
                t = 1 - t;
            }

            gameObject.alpha = Linear$g(this.alphaStart, this.alphaEnd, t);
        }

        complete() {
            super.complete();
            if (this.mode === 1) {
                this.parent.destroy();
                // Will also destroy this behavior
            }
            return this;
        }

    };

    const MODE$2 = {
        stop: 0,
        destroy: 1,
        yoyo: 2
    };

    const IsPlainObject$B = Phaser.Utils.Objects.IsPlainObject;

    var FadeIn = function (gameObject, duration, alpha, fade) {
        var startAlpha, endAlpha;
        if (IsPlainObject$B(alpha)) {
            startAlpha = alpha.start;
            endAlpha = alpha.end;
        } else {
            endAlpha = alpha;
        }
        if (startAlpha === undefined) {
            startAlpha = 0;
        }
        if (endAlpha === undefined) {
            endAlpha = 1;
        }

        var config = {
            mode: 0,
            start: startAlpha,
            end: endAlpha,
            duration: duration,
        };

        if (fade === undefined) {
            fade = new Fade$2(gameObject, config);
        } else {
            fade.resetFromJSON(config);
        }
        fade.restart();

        return fade;
    };

    var FadeOutDestroy = function (gameObject, duration, destroyMode, fade) {
        if (destroyMode instanceof Fade$2) {
            fade = destroyMode;
            destroyMode = undefined;
        }

        if (destroyMode === undefined) {
            destroyMode = true;
        }

        var config = {
            mode: (destroyMode) ? 1 : 0,
            end: 0,
            duration: duration,
        };

        if (fade === undefined) {
            fade = new Fade$2(gameObject, config);
        } else {
            fade.resetFromJSON(config);
        }
        fade.restart();

        return fade;
    };

    const IsPlainObject$A = Phaser.Utils.Objects.IsPlainObject;

    var FadeMethods = {
        onInitFade() {
            var gameObject = this;
            var fade = this._fade;

            // Route 'complete' of fade to gameObject
            fade.completeEventName = undefined;
            fade.on('complete', function () {
                if (fade.completeEventName) {
                    gameObject.emit(fade.completeEventName, gameObject);
                    fade.completeEventName = undefined;
                }
            });
        },

        fadeIn(duration, alpha) {
            if (IsPlainObject$A(duration)) {
                var config = duration;
                duration = config.duration;
                alpha = config.alpha;
            }

            var isInit = (this._fade === undefined);

            this._fade = FadeIn(this, duration, alpha, this._fade);

            if (isInit) {
                this.onInitFade();
            }

            this._fade.completeEventName = 'fadein.complete';

            return this;
        },

        fadeInPromise(duration, alpha) {
            this.fadeIn(duration, alpha);
            return WaitComplete(this._fade);
        },

        isRunningFadeIn() {
            return this._fade && (this._fade.completeEventName === 'fadein.complete');
        },

        fadeOutDestroy(duration, destroyMode) {
            if (IsPlainObject$A(duration)) {
                var config = duration;
                duration = config.duration;
                destroyMode = config.destroy;
            }

            var isInit = (this._fade === undefined);

            this._fade = FadeOutDestroy(this, duration, destroyMode, this._fade);

            if (isInit) {
                this.onInitFade();
            }

            this._fade.completeEventName = 'fadeout.complete';

            return this;
        },

        fadeOutDestroyPromise(duration, destroyMode) {
            this.fadeOutDestroy(duration, destroyMode);
            return WaitComplete(this._fade);
        },

        fadeOut(duration) {
            this.fadeOutDestroy(duration, false);
            return this;
        },

        fadeOutPromise(duration) {
            this.fadeOut(duration);
            return WaitComplete(this._fade);
        },

        isRunningFadeOut() {
            return this._fade && (this._fade.completeEventName === 'fadeout.complete');
        },

        isRunningEaseFade() {
            return this.isRunningFadeIn() || this.isRunningFadeOut();
        }
    };

    var methods$y = {};
    Object.assign(methods$y, FadeMethods);

    methods$y.onInitFade = function () {
        FadeMethods.onInitFade.call(this);

        var gameObject = this;
        var fade = this._fade;
        // Update local state
        fade.on('update', function () {
            var parent = GetParentSizerMethods.getParentSizer(gameObject);
            if (parent) {
                parent.resetChildAlphaState(gameObject);
            }
        });
    };

    const GetValue$2M = Phaser.Utils.Objects.GetValue;
    const GetAdvancedValue$1 = Phaser.Utils.Objects.GetAdvancedValue;
    const Linear$f = Phaser.Math.Linear;

    class EaseMove extends EaseValueTaskBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;
            // this.timer

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);

            this.setMode(GetValue$2M(o, 'mode', 0));

            if (o && (o.hasOwnProperty('x') || o.hasOwnProperty('y'))) {
                var endX = GetAdvancedValue$1(o, 'x', undefined);
                var endY = GetAdvancedValue$1(o, 'y', undefined);
                this.setTargetPosition(endX, endY);
            } else {
                this.setTargetPosition(o);
            }

            return this;
        }

        setMode(m) {
            if (typeof (m) === 'string') {
                m = MODE$1[m];
            }
            this.mode = m;
            return this;
        }

        setTargetPosition(x, y) {
            if ((typeof (x) === 'number') || (typeof (y) === 'number')) {
                // endX, endY
                // x,y : a number, or undefined
                this.startX = this.parent.x;
                this.startY = this.parent.y;
                this.endX = x;
                this.endY = y;
            } else {
                var config = x;
                this.startX = GetAdvancedValue$1(config, 'startX', undefined);
                this.startY = GetAdvancedValue$1(config, 'startY', undefined);
                this.endX = GetAdvancedValue$1(config, 'endX', undefined);
                this.endY = GetAdvancedValue$1(config, 'endY', undefined);
            }

            this.hasMoveX = (this.startX !== undefined) && (this.endX !== undefined);
            this.hasMoveY = (this.startY !== undefined) && (this.endY !== undefined);
            return this;
        }

        start() {
            if (this.timer.isRunning) {
                return this;
            }

            var gameObject = this.parent;
            if (this.hasMoveX) {
                gameObject.x = this.startX;
            }
            if (this.hasMoveY) {
                gameObject.y = this.startY;
            }

            this.timer
                .setDelay(this.delay)
                .setDuration(this.duration)
                .setRepeat((this.mode === 2) ? -1 : 0);

            super.start();
            return this;
        }

        updateTarget(gameObject, timer) {
            var t = timer.t;
            if (timer.isOddIteration) {   // Yoyo
                t = 1 - t;
            }
            t = this.easeFn(t);

            if (this.hasMoveX) {
                gameObject.x = Linear$f(this.startX, this.endX, t);
            }
            if (this.hasMoveY) {
                gameObject.y = Linear$f(this.startY, this.endY, t);
            }
        }

        complete() {
            super.complete();

            if (this.mode === 1) {
                this.parent.destroy();
                // Will also destroy this behavior
            }
            return this;
        }
    }

    const MODE$1 = {
        stop: 0,
        destroy: 1,
        yoyo: 2
    };

    var ParseValue = function (propertyValue, startValue) {
        // propertyValue : number or string
        if (typeof (propertyValue) === 'number') {
            return propertyValue;
        } else {
            var op = propertyValue[0];
            var num = parseFloat(propertyValue.substr(2));
            switch (op) {
                case '+': return startValue + num;
                case '-': return startValue - num;
                case '*': return startValue * num;
                case '/': return startValue / num;
            }
        }
    };

    var EaseMoveTo = function (gameObject, duration, endX, endY, ease, destroyMode, easeMove) {
        if (destroyMode instanceof EaseMove) {
            easeMove = destroyMode;
            destroyMode = undefined;
        }

        if (destroyMode === undefined) {
            destroyMode = false;
        }

        var config = {};
        config.mode = (destroyMode) ? 1 : 0;
        if (endX !== undefined) {
            config.startX = gameObject.x;
            config.endX = ParseValue(endX, gameObject.x);
        }
        if (endY !== undefined) {
            config.startY = gameObject.y;
            config.endY = ParseValue(endY, gameObject.y);
        }
        config.duration = duration;
        config.ease = (ease === undefined) ? 'Linear' : ease;

        if (easeMove === undefined) {
            easeMove = new EaseMove(gameObject, config);
        } else {
            easeMove.resetFromJSON(config);
        }
        easeMove.restart();

        return easeMove;
    };

    var EaseMoveFrom = function (gameObject, duration, startX, startY, ease, destroyMode, easeMove) {
        if (destroyMode instanceof EaseMove) {
            easeMove = destroyMode;
            destroyMode = undefined;
        }

        if (destroyMode === undefined) {
            destroyMode = false;
        }

        var config = {};
        config.mode = (destroyMode) ? 1 : 0;
        if (startX !== undefined) {
            config.startX = ParseValue(startX, gameObject.x);
            config.endX = gameObject.x;
        }
        if (startY !== undefined) {
            config.startY = ParseValue(startY, gameObject.y);
            config.endY = gameObject.y;
        }
        config.duration = duration;
        config.ease = (ease === undefined) ? 'Linear' : ease;

        if (easeMove === undefined) {
            easeMove = new EaseMove(gameObject, config);
        } else {
            easeMove.resetFromJSON(config);
        }
        easeMove.restart();

        return easeMove;
    };

    const IsPlainObject$z = Phaser.Utils.Objects.IsPlainObject;
    const DistanceBetween$6 = Phaser.Math.Distance.Between;

    var EaseMoveMethods = {
        onInitEaseMove() {
            var gameObject = this;
            var easeMove = this._easeMove;
            // Route 'complete' of easeMove to gameObject
            easeMove.completeEventName = undefined;
            easeMove.on('complete', function () {
                if (easeMove.completeEventName) {
                    gameObject.emit(easeMove.completeEventName, gameObject);
                    easeMove.completeEventName = undefined;
                }
            });
        },

        moveFrom(duration, x, y, ease, destroyMode) {
            if (IsPlainObject$z(duration)) {
                var config = duration;
                x = config.x;
                y = config.y;
                if (config.hasOwnProperty('speed')) {
                    duration = (DistanceBetween$6(x, y, this.x, this.y) * 1000) / config.speed;
                } else {
                    duration = config.duration;
                }

                ease = config.ease;
            }

            var isInit = (this._easeMove === undefined);

            this._easeMove = EaseMoveFrom(this, duration, x, y, ease, destroyMode, this._easeMove);

            if (isInit) {
                this.onInitEaseMove();
            }

            this._easeMove.completeEventName = 'movefrom.complete';

            return this;
        },

        moveFromPromise(duration, x, y, ease, destroyMode) {
            this.moveFrom(duration, x, y, ease, destroyMode);
            return WaitComplete(this._easeMove);
        },

        moveFromDestroy(duration, x, y, ease) {
            this.moveFrom(duration, x, y, ease, true);
            return this;
        },

        moveFromDestroyPromise(duration, x, y, ease) {
            this.moveFromDestroy(duration, x, y, ease);
            return WaitComplete(this._easeMove);
        },

        isRunningMoveFrom() {
            return this._easeMove && (this._easeMove.completeEventName = 'movefrom.complete');
        },

        moveTo(duration, x, y, ease, destroyMode) {
            if (IsPlainObject$z(duration)) {
                var config = duration;
                x = config.x;
                y = config.y;
                if (config.hasOwnProperty('speed')) {
                    duration = (DistanceBetween$6(x, y, this.x, this.y) * 1000) / config.speed;
                } else {
                    duration = config.duration;
                }

                ease = config.ease;
            }

            var isInit = (this._easeMove === undefined);

            this._easeMove = EaseMoveTo(this, duration, x, y, ease, destroyMode, this._easeMove);

            if (isInit) {
                this.onInitEaseMove();
            }

            this._easeMove.completeEventName === 'moveto.complete';

            return this;
        },

        moveToPromise(duration, x, y, ease, destroyMode) {
            this.moveTo(duration, x, y, ease, destroyMode);
            return WaitComplete(this._easeMove);
        },

        moveToDestroy(duration, x, y, ease) {
            this.moveTo(duration, x, y, ease, true);
            return this;
        },

        moveToDestroyPromise(duration, x, y, ease) {
            this.moveToDestroy(duration, x, y, ease, true);
            return WaitComplete(this._easeMove);
        },

        isRunningMoveTo() {
            return this._easeMove && (this._easeMove.completeEventName === 'moveto.complete');
        },

        isRunningEaseMove() {
            return this.isRunningMoveFrom() || this.isRunningMoveTo();
        },

        moveStop(toEnd) {
            if (!this._easeMove) {
                return this;
            }

            this._easeMove.stop(toEnd);
            return this;
        }
    };

    var methods$x = {};
    Object.assign(methods$x, EaseMoveMethods);

    methods$x.onInitEaseMove = function () {
        EaseMoveMethods.onInitEaseMove.call(this);

        var gameObject = this;
        var easeMove = this._easeMove;
        easeMove.on('update', function () {
            var parent = GetParentSizerMethods.getParentSizer(gameObject);
            if (parent) {
                parent.resetChildPositionState(gameObject);
            }
        });
    };

    const GetValue$2L = Phaser.Utils.Objects.GetValue;

    class ShakePosition extends TickTask {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            this.timer = new Timer$1();
            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.timer.resetFromJSON(GetValue$2L(o, 'timer'));
            this.setEnable(GetValue$2L(o, 'enable', true));
            this.setMode(GetValue$2L(o, 'mode', 1));
            this.isRunning = GetValue$2L(o, 'isRunning', false);
            this.setMagnitudeMode(GetValue$2L(o, 'magnitudeMode', 1));
            this.setAxisMode(GetValue$2L(o, "axis", 0));
            this.setDuration(GetValue$2L(o, 'duration', 500));
            this.setMagnitude(GetValue$2L(o, 'magnitude', 10));
            this.ox = GetValue$2L(o, 'ox', undefined);
            this.oy = GetValue$2L(o, 'oy', undefined);
            return this;
        }

        toJSON() {
            return {
                timer: this.timer.toJSON(),
                enable: this.enable,
                mode: this.mode,
                isRunning: this.isRunning,
                magnitudeMode: magnitudeMode,
                duration: this.duration,
                magnitude: this.magnitude,
                ox: this.ox,
                oy: this.oy,
            };
        }

        // override
        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            super.shutdown(fromScene);
            this.timer.destroy();
            this.timer = undefined;
        }

        startTicking() {
            super.startTicking();

            if (this.mode === 0) { // Effect mode
                this.scene.game.events.on('poststep', this.update, this);
                this.scene.game.events.on('prestep', this.backToOrigin, this);
            } else { // Behavior Mode
                this.scene.sys.events.on('preupdate', this.update, this);
            }
        }

        stopTicking() {
            super.stopTicking();

            if (this.scene) { // Scene might be destoryed
                if (this.mode === 0) { // Effect mode
                    this.scene.game.events.off('poststep', this.update, this);
                    this.scene.game.events.off('prestep', this.backToOrigin, this);
                } else { // Behavior Mode
                    this.scene.sys.events.off('preupdate', this.update, this);
                }

            }
        }

        setEnable(e) {
            if (e == undefined) {
                e = true;
            }
            this.enable = e;
            return this;
        }

        setMode(mode) {
            if (typeof (mode) === 'string') {
                mode = MODE[mode];
            }
            this.mode = mode;
            return this;
        }

        setMagnitudeMode(magnitudeMode) {
            if (typeof (magnitudeMode) === 'string') {
                magnitudeMode = MANITUDEMODE[magnitudeMode];
            }

            this.magnitudeMode = magnitudeMode;
            return this;
        }

        setAxisMode(m) {
            if (typeof (m) === 'string') {
                m = DIRECTIONNODE$1[m];
            }
            this.axisMode = m;
            return this;
        }

        setDuration(duration) {
            this.duration = duration;
            return this;
        }

        setMagnitude(magnitude) {
            this.magnitude = magnitude;
            return this;
        }

        start(duration, magnitude) {
            if (typeof (duration) !== 'number') {
                var config = duration;
                magnitude = GetValue$2L(config, 'magnitude', undefined);
                duration = GetValue$2L(config, 'duration', undefined);
            }
            if (magnitude !== undefined) {
                this.setMagnitude(magnitude);
            }
            if (duration !== undefined) {
                this.setDuration(duration);
            }

            this.timer
                .setDuration(this.duration)
                .start();

            super.start();
            return this;
        }

        shake(duration, magnitude) {
            this.start(duration, magnitude);
            return this;
        }

        update(time, delta) {
            if ((!this.isRunning) || (!this.enable)) {
                return this;
            }

            var gameObject = this.parent;
            if (!gameObject.active) {
                return this;
            }

            this.timer.update(time, delta);
            if (this.timer.isDone) {
                this.backToOrigin();
                this.complete();
            } else {
                if (this.ox === undefined) {
                    this.ox = gameObject.x;
                    this.oy = gameObject.y;
                }

                var magnitude = this.magnitude;
                if (this.magnitudeMode === 1) // decay
                {
                    magnitude *= (1 - this.timer.t);
                }
                var a = Math.random() * Math.PI * 2;
                var x = this.ox + (Math.cos(a) * magnitude);
                var y = this.oy + (Math.sin(a) * magnitude);

                switch (this.axisMode) {
                    case 1:
                        gameObject.x = x;
                        break;

                    case 2:
                        gameObject.y = y;
                        break;

                    default:
                        gameObject.x = x;
                        gameObject.y = y;
                        break;
                }
            }

            return this;
        }

        backToOrigin() {
            if ((!this.isRunning) || (!this.enable)) {
                return this;
            }

            if (this.ox === undefined) {
                return this;
            }

            var gameObject = this.parent;

            switch (this.axisMode) {
                case 1:
                    gameObject.x = this.ox;
                    break;

                case 2:
                    gameObject.y = this.oy;
                    break;

                default:
                    gameObject.x = this.ox;
                    gameObject.y = this.oy;
                    break;
            }

            this.ox = undefined;
            this.oy = undefined;
            return this;
        }
    }

    const MODE = {
        effect: 0,
        behavior: 1,
    };

    const DIRECTIONNODE$1 = {
        'both': 0,
        'h&v': 0,
        'x&y': 0,
        'horizontal': 1,
        'h': 1,
        'x': 1,
        'vertical': 2,
        'v': 2,
        'y': 2
    };

    const MANITUDEMODE = {
        constant: 0,
        decay: 1,
    };

    const IsPlainObject$y = Phaser.Utils.Objects.IsPlainObject;

    var OnInitShake = function (gameObject, shake) {
        // Route 'complete' of shake to gameObject
        shake.on('complete', function () {
            gameObject.emit('shake.complete', gameObject);
        });

        // Shake effect won't change position
    };

    var ShakeMethods = {
        shake(duration, magnitude, magnitudeMode) {
            if (IsPlainObject$y(duration)) {
                var config = duration;
                duration = config.duration;
                magnitude = config.magnitude;
                magnitudeMode = config.magnitudeMode;
            }

            if (this._shake === undefined) {
                this._shake = new ShakePosition(this, {
                    mode: 0,
                    magnitudeMode: 1
                });
                OnInitShake(this, this._shake);
            }

            if (duration !== undefined) {
                this._shake.setDuration(duration);
            }

            if (magnitude !== undefined) {
                this._shake.setMagnitude(magnitude);
            }

            if (magnitudeMode !== undefined) {
                this._shake.setMagnitudeMode(magnitudeMode);
            }

            this._shake.shake();

            return this;
        },

        shakePromise(duration, alpha) {
            this.shake(duration, alpha);
            return WaitComplete(this._shake);
        },
    };

    const IsPlainObject$x = Phaser.Utils.Objects.IsPlainObject;

    class EaseData extends ComponentBase {
        constructor(parent, config) {
            super(parent, config);

            this.parent.setDataEnabled();
            this.easeTasks = {};
        }

        complete(key) {
            this.emit(`complete-${key}`, this.parent, this);
            this.emit('complete', key, this.parent, this);
        }

        getEaseTask(key) {
            var easeTask = this.easeTasks[key];
            if (easeTask === undefined) {
                easeTask = new EaseValueTask(this.parent);
                this.easeTasks[key] = easeTask;

                easeTask
                    .setTarget(this.parent.data.values)
                    .on('complete', function () {
                        this.complete(key);
                    }, this);
            }
            return easeTask;
        }

        easeTo(key, value, duration, ease) {
            if (IsPlainObject$x(key)) {
                var config = key;
                key = config.key;
                value = config.value;
                duration = config.duration;
                ease = config.ease;

                var speed = config.speed;
                if ((duration === undefined) && (speed !== undefined)) {
                    duration = (Math.abs(value - this.parent.data.values[key]) / speed) * 1000;
                }
            }

            if (duration === undefined) {
                duration = 1000;
            }
            if (ease === undefined) {
                ease = 'Linear';
            }

            var easeTask = this.getEaseTask(key);
            easeTask.restart({
                key: key,
                to: value,
                duration: duration,
                ease: ease
            });

            return this;
        }

        easeFrom(key, value, duration, ease) {
            if (IsPlainObject$x(key)) {
                var config = key;
                key = config.key;
                value = config.value;
                duration = config.duration;
                ease = config.ease;

                var speed = config.speed;
                if ((duration === undefined) && (speed !== undefined)) {
                    duration = (Math.abs(value - this.parent.data.values[key]) / speed) * 1000;
                }
            }

            if (duration === undefined) {
                duration = 1000;
            }
            if (ease === undefined) {
                ease = 'Linear';
            }

            var easeTask = this.getEaseTask(key);
            easeTask.restart({
                key: key,
                from: value,
                duration: duration,
                ease: ease
            });

            return this;
        }

        stopEase(key, toEnd) {
            if (toEnd === undefined) {
                toEnd = true;
            }

            var easeTask = this.easeTasks[key];
            if (easeTask) {
                easeTask.stop(toEnd);
            }

            return this;
        }

        stopAll(toEnd) {
            if (toEnd === undefined) {
                toEnd = true;
            }

            for (var key in this.easeTasks) {
                this.stopEase(key, toEnd);
            }
            return this;
        }
    }

    var OnInitEaseData = function (gameObject, easeData) {
        // Route 'complete' of easeData to gameObject
        easeData.on('complete', function (key) {
            gameObject.emit(`easedata.${key}.complete`, gameObject);
            gameObject.emit('easedata.complete', key, gameObject);
        });
    };

    var EaseDataMethods = {
        easeDataTo(key, value, duration, ease) {
            if (!this._easeData) {
                this._easeData = new EaseData(this);
                OnInitEaseData(this, this._easeData);
            }
            this._easeData.easeTo(key, value, duration, ease);
            return this;
        },

        easeDataToPromise(key, value, duration, ease) {
            this.easeDataTo(key, value, duration, ease);
            return WaitEvent(this._easeData, `complete-${key}`);
        },

        stopEaseData(key, toEnd) {
            if (!this._easeData) {
                return this;
            }

            this._easeData.stopEase(key, toEnd);
            return this;
        },

        stopAllEaseData(toEnd) {
            if (!this._easeData) {
                return this;
            }

            this._easeData.stopAll(toEnd);
            return this;
        }
    };

    var RemoveItem$3 = Phaser.Utils.Array.Remove;

    var OnInitDelayCallTimers = function (gameObject) {
        gameObject._delayCallTimers = [];
        gameObject.once('destroy', function () {
            var timers = gameObject._delayCallTimers;
            for (var i = 0, cnt = timers.length; i < cnt; i++) {
                timers[i].remove();
            }
            gameObject._delayCallTimers = undefined;
        });
    };

    var DelayCallMethods$2 = {
        delayCall(delay, callback, scope) {
            var timers = this._delayCallTimers;

            if (timers === undefined) {
                OnInitDelayCallTimers(this);
            }


            var timer;
            var self = this;
            var OnTimeOut = function () {
                RemoveItem$3(self._delayCallTimers, timer);
                if (scope) {
                    callback.call(scope);
                } else {
                    callback();
                }
            };

            timer = this.scene.time.delayedCall(delay, OnTimeOut);
            this._delayCallTimers.push(timer);

            return this;
        },
    };

    var Show = function (gameObject) {
        _hide(gameObject, false);
    };

    var Hide = function (gameObject) {
        _hide(gameObject, true);
    };

    var IsShown = function (gameObject) {
        if (!gameObject) {
            return false;
        }
        var config = GetSizerConfig$1(gameObject);
        return !config.hidden;
    };

    var _hide = function (gameObject, hidden) {
        if (!gameObject) {
            return;
        }
        var config = GetSizerConfig$1(gameObject);
        config.hidden = hidden;

        var parent = GetParent$1(gameObject);
        if (parent) {
            parent.setChildVisible(gameObject, !hidden);
        } else {
            gameObject.setVisible(!hidden);
        }
    };

    var HideMethods = {
        show(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }
            Show(gameObject);
            return this;
        },

        hide(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }
            Hide(gameObject);
            return this;
        },

        isShow(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }
            return IsShown(gameObject);
        }
    };

    const StateProperties$1 = ['next', 'exit', 'enter'];

    let FSM$1 = class FSM {
        /*
        var config = {
            start: 'A',   // default: undefined
            states: {
                A: {
                    next: 'B',  // function() { return 'B'; }
                    enter: function() {},
                    exit: function() {},
                },
                // ...
            },        
            extend: {
                i: 0,
                name: 'abc'
                // ...
            },
            init: function() {},
            enable: true,
            eventEmitter: true,
        };
        */
        constructor(config) {
            // Attach get-next-state function
            var states = GetValue$3U(config, 'states', undefined);
            if (states) {
                this.addStates(states);
            }

            // Attach extend members
            var extend = GetValue$3U(config, 'extend', undefined);
            if (extend) {
                for (var name in extend) {
                    if (!this.hasOwnProperty(name) || this[name] === undefined) {
                        this[name] = extend[name];
                    }
                }
            }

            // Event emitter
            var eventEmitter = GetValue$3U(config, 'eventEmitter', undefined);
            var EventEmitterClass = GetValue$3U(config, 'EventEmitterClass', undefined);
            this.setEventEmitter(eventEmitter, EventEmitterClass);

            this._stateLock = false;
            this.resetFromJSON(config);
        }

        shutdown() {
            this.destroyEventEmitter();
        }

        destroy() {
            this.shutdown();
        }

        resetFromJSON(o) {
            this.setEnable(GetValue$3U(o, 'enable', true));
            this.start(GetValue$3U(o, 'start', undefined));
            var init = GetValue$3U(o, 'init', undefined);
            if (init) {
                init.call(this);
            }

            return this;
        }

        toJSON() {
            return {
                curState: this.state,
                prevState: this.prevState,

                enable: this.enable,
                start: this._start
            };
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }
            this.enable = e;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        set state(newState) {
            if (!this.enable || this._stateLock) {
                return;
            }
            if (this._state === newState) {
                return;
            }
            this._prevState = this._state;
            this._state = newState;

            this._stateLock = true; // lock state

            this.emit('statechange', this);

            if (this._prevState != null) {
                var exitEventName = 'exit_' + this._prevState;
                var exitCallback = this[exitEventName];
                if (exitCallback) {
                    exitCallback.call(this);
                }
                this.emit(exitEventName, this);
            }

            this._stateLock = false;

            if (this._state != null) {
                var enterEventName = 'enter_' + this._state;
                var enterCallback = this[enterEventName];
                if (enterCallback) {
                    enterCallback.call(this);
                }
                this.emit(enterEventName, this);
            }
        }

        get state() {
            return this._state;
        }

        get prevState() {
            return this._prevState;
        }

        start(state) {
            this._start = state;
            this._prevState = undefined;
            this._state = state; // Won't fire statechange events
            return this;
        }

        goto(nextState) {
            if (nextState != null) {
                this.state = nextState;
            }
            return this;
        }

        next() {
            var nextState;
            var getNextState = this['next_' + this.state];
            if (getNextState) {
                if (typeof (getNextState) === 'string') {
                    nextState = getNextState;
                } else {
                    nextState = getNextState.call(this);
                }
            }

            this.goto(nextState);
            return this;
        }

        get stateProperties() {
            return StateProperties$1;
        }

        addState(name, state) {
            if (typeof (name) !== 'string') {
                state = name;
                name = state.name;
            }

            var stateProperties = this.stateProperties;
            for (var i = 0, cnt = stateProperties.length; i < cnt; i++) {
                var propertyName = stateProperties[i];
                var propertyValue = state[propertyName];
                if (propertyValue) {
                    this[`${propertyName}_${name}`] = propertyValue;
                }
            }

            return this;
        }

        addStates(states) {
            if (Array.isArray(states)) {
                for (var i = 0, cnt = states.length; i < cnt; i++) {
                    this.addState(states[i]);
                }
            } else {
                for (var name in states) {
                    this.addState(name, states[name]);
                }
            }
            return this;
        }

        runMethod(methodName, a1, a2, a3, a4, a5) {
            var fn = this[methodName + '_' + this.state];
            if (!fn) {
                return undefined;
            }

            // Copy from eventemitter3
            var len = arguments.length;
            switch (len) {
                case 1: return fn.call(this);
                case 2: return fn.call(this, a1);
                case 3: return fn.call(this, a1, a2);
                case 4: return fn.call(this, a1, a2, a3);
                case 5: return fn.call(this, a1, a2, a3, a4);
                case 6: return fn.call(this, a1, a2, a3, a4, a5);
            }
            var args = new Array(len - 1);
            for (var i = 1; i < len; i++) {
                args[i - 1] = arguments[i];
            }
            return fn.apply(this, args);
        }
    };

    Object.assign(
        FSM$1.prototype,
        EventEmitterMethods,
    );

    var HasListener = function (eventEmitter, eventName, fn, context, once) {
        if (once === undefined) {
            once = false;
        }

        var listeners = eventEmitter._events[eventName];
        if (!listeners) {
            return false;
        }

        for (var i = 0, cnt = listeners.length; i < cnt; i++) {
            var listener = listeners[i];
            if ((listener.fn === fn) &&
                (listener.context === context) &&
                (listener.once === once)
            ) {
                return true;
            }
        }

        return false;

    };

    const StateProperties = ['next', 'exit', 'enter', 'update', 'preupdate', 'postupdate'];

    class FSM extends FSM$1 {
        /*
        var config = {
            start: 'A',   // default: undefined
            states: {
                A: {
                    next: 'B',  // function() { return 'B'; }
                    enter: function() {},
                    exit: function() {},
                    update: function(time, delta) {},
                    preupdate: function(time, delta) {},
                    postupdate: function(time, delta) {},
                },
                // ...
            },        
            extend: {
                i: 0,
                name: 'abc'
                // ...
            },
            init: function() {},
            enable: true,
            scene: undefined,
            eventEmitter: true,
        };
        */
        shutdown() {
            this.stopUpdate();
            this.stopPreUpdate();
            this.stopPostUpdate();
            this._scene = undefined;

            super.shutdown();
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this._scene = GetValue$3U(o, 'scene', undefined);
            return this;
        }

        get stateProperties() {
            return StateProperties;
        }

        update(time, delta) {
            this.runMethod('update', time, delta);
        }

        preupdate(time, delta) {
            this.runMethod('preupdate', time, delta);
        }

        postupdate(time, delta) {
            this.runMethod('postupdate', time, delta);
        }

        startUpdate(scene) {
            if (!scene) {
                scene = this._scene;
            }

            var eventEmitter = scene.sys.events;
            if (HasListener(eventEmitter, 'update', this.update, this)) {
                return this;
            }

            this._scene = scene;
            eventEmitter.on('update', this.update, this);
            return this;
        }

        stopUpdate() {
            if (!this._scene) {
                return this;
            }

            this._scene.sys.events.off('update', this.update, this);
            return this;
        }

        startPreUpdate(scene) {
            if (!scene) {
                scene = this._scene;
            }

            var eventEmitter = scene.sys.events;
            if (HasListener(eventEmitter, 'preupdate', this.preupdate, this)) {
                return this;
            }

            this._scene = scene;
            eventEmitter.on('preupdate', this.preupdate, this);
            return this;
        }

        stopPreUpdate() {
            if (!this._scene) {
                return this;
            }

            this._scene.sys.events.off('preupdate', this.preupdate, this);
            return this;
        }

        startPostUpdate(scene) {
            if (!scene) {
                scene = this._scene;
            }

            var eventEmitter = scene.sys.events;
            if (HasListener(eventEmitter, 'postupdate', this.postupdate, this)) {
                return this;
            }

            this._scene = scene;
            eventEmitter.on('postupdate', this.postupdate, this);
            return this;
        }

        stopPostUpdate() {
            if (!this._scene) {
                return this;
            }

            this._scene.sys.events.off('postupdate', this.postupdate, this);
            return this;
        }
    }

    /*
    graph TD

    IDLE --> |"requestOpen()"| TRANS_OPNE["TRAN_OPEN<br>runTransitionInCallback()"]
    TRANS_OPNE --> |transitInTime| OPEN
    OPEN --> |"requestClose()"| TRANS_CLOSE["TRANS_CLOSE<br>runTransitionOutCallback()"]
    TRANS_CLOSE --> |transitOutTime| CLOSE
    CLOSE --> |"requestOpen()"| TRANS_OPNE
    */

    let State$1 = class State extends FSM {
        constructor(parent, config) {
            super(config);
            this.parent = parent;

            var initState = config.initState || 'IDLE';
            this.start(initState);
        }

        init() {
            this.start('IDLE');
        }

        // IDLE -> TRANS_OPNE
        next_IDLE() {
            return 'TRANS_OPNE';
        }
        // IDLE

        // TRANS_OPNE -> OPEN
        next_TRANS_OPNE() {
            return 'OPEN';
        }
        enter_TRANS_OPNE() {
            var transitionBehavior = this.parent;
            if (transitionBehavior.transitInTime > 0) {
                var delay = transitionBehavior.runTransitionInCallback();
                transitionBehavior.delayCall(delay, this.next, this);
            } else {
                this.next();
            }
        }
        exit_TRANS_OPNE() {
            var transitionBehavior = this.parent;
            transitionBehavior.removeDelayCall();
        }
        // TRANS_OPNE

        // OPEN -> TRANS_CLOSE
        next_OPEN() {
            return 'TRANS_CLOSE';
        }
        enter_OPEN() {
            var transitionBehavior = this.parent;
            transitionBehavior.onOpen();
        }
        exit_OPEN() {
            var transitionBehavior = this.parent;
            transitionBehavior.removeDelayCall();
        }
        // OPEN

        // TRANS_CLOSE -> CLOSE
        next_TRANS_CLOSE() {
            return 'CLOSE';
        }
        enter_TRANS_CLOSE() {
            var transitionBehavior = this.parent;
            if (transitionBehavior.transitOutTime > 0) {
                var delay = transitionBehavior.runTransitionOutCallback();
                transitionBehavior.delayCall(delay, this.next, this);
            } else {
                this.next();
            }
        }
        exit_TRANS_CLOSE() {
            var transitionBehavior = this.parent;
            transitionBehavior.removeDelayCall();
        }
        // TRANS_CLOSE

        // CLOSE -> TRANS_OPNE
        next_CLOSE() {
            return 'TRANS_OPNE';
        }
        enter_CLOSE() {
            var transitionBehavior = this.parent;
            transitionBehavior.onClose();
        }
        exit_CLOSE() {
        }
        // CLOSE

        canOpen() {
            return (this.state === 'IDLE') || (this.state === 'CLOSE');
        }

        canClose() {
            return (this.state === 'IDLE') || (this.state === 'OPEN');
        }
    };

    var PostStepDelayCall = function (gameObject, delay, callback, scope, args) {
        // Invoke callback under game's 'poststep' event
        var scene = GetSceneObject(gameObject);
        var timer = scene.time.delayedCall(delay, function () {
            scene.game.events.once('poststep', function () {
                callback.call(scope, args);
            });
        });
        return timer;
    };

    var DelayCallMethods$1 = {
        delayCall(delay, callback, scope) {
            // Invoke callback under scene's 'postupdate' event
            this.delayCallTimer = PostStepDelayCall(this, delay, callback, scope);
            return this;
        },

        removeDelayCall() {
            if (this.delayCallTimer) {
                this.delayCallTimer.remove(false);
                this.delayCallTimer = undefined;
            }
            return this;
        }

    };

    var ConfigurationMethods$3 = {
        setTransitInTime(time) {
            this.transitInTime = time;
            return this;
        },

        setTransitOutTime(time) {
            this.transitOutTime = time;
            return this;
        },

        setTransitInCallback(callback) {
            if (!callback) {
                callback = NOOP;
            }

            this.transitInCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

        setTransitOutCallback(callback) {
            if (!callback) {
                callback = NOOP;
            }

            this.transitOutCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

    };

    var OpenMethods$1 = {
        // Override
        runTransitionInCallback() {
            this.transitInCallback(this.parent, this.transitInTime);
            return this.transitInTime;
        },

        // Override
        onOpen() {
        },

        requestOpen(openEventData, duration) {
            if (!this._state.canOpen()) {
                return this;
            }

            this.openEventData = (arguments.length > 0) ? openEventData : this.parent;

            var transitionTimeSave = this.transitInTime;
            if (duration !== undefined) {
                this.transitInTime = duration;
            }

            this._state.goto('TRANS_OPNE');

            this.transitInTime = transitionTimeSave;

            return this;
        },
    };

    var CloseMethods = {
        // Override
        runTransitionOutCallback() {
            this.transitOutCallback(this.parent, this.transitOutTime);
            return this.transitOutTime;
        },

        // Override
        onClose() {
            // Destroy parent and this behavior
            if (this.oneShotMode) {
                this.parent.destroy();
                // Will invoke `this.destroy()`
            }
        },

        requestClose(closeEventData, duration) {
            if (!this._state.canClose) {
                return this;
            }

            this.closeEventData = (arguments.length > 0) ? closeEventData : this.parent;

            var transitionTimeSave = this.transitOutTime;
            if (duration !== undefined) {
                this.transitOutTime = duration;
            }

            this._state.goto('TRANS_CLOSE');

            this.transitOutTime = transitionTimeSave;

            return this;
        },
    };

    var methods$w = {};

    Object.assign(
        methods$w,
        DelayCallMethods$1,
        ConfigurationMethods$3,
        OpenMethods$1,
        CloseMethods,
    );

    const GetValue$2K = Phaser.Utils.Objects.GetValue;

    class OpenCloseTransition extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;
            // this.scene

            this.setTransitInTime(GetValue$2K(config, 'duration.in', 200));
            this.setTransitOutTime(GetValue$2K(config, 'duration.out', 200));
            this.setTransitInCallback(GetValue$2K(config, 'transitIn'));
            this.setTransitOutCallback(GetValue$2K(config, 'transitOut'));

            this.oneShotMode = GetValue$2K(config, 'destroy', false);

            this.delayCallTimer = undefined;
            this._state = new State$1(this, {
                eventEmitter: false,
                initState: GetValue$2K(config, 'initState', 'IDLE')
            });
            this.openEventData = undefined;
            this.closeEventData = undefined;
        }

        get state() {
            return this._state.state;
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            this.transitInCallback = undefined;
            this.transitOutCallback = undefined;
            this.openEventData = undefined;
            this.closeEventData = undefined;

            this.removeDelayCall();

            super.shutdown(fromScene);
        }
    }

    Object.assign(
        OpenCloseTransition.prototype,
        methods$w,
    );

    const Rectangle = Phaser.GameObjects.Rectangle;

    class FullWindowRectangle extends Rectangle {
        constructor(scene, color, alpha) {
            super(scene, 0, 0, 2, 2, color, 1);

            this.fullWindow = new FullWindow(this);

            this.setAlpha(alpha);
        }

        get tint() {
            return this.fillColor;
        }

        set tint(value) {
            this.setFillStyle(value, this.fillAlpha);
        }
    }

    const GetValue$2J = Phaser.Utils.Objects.GetValue;

    class TouchEventStop extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, { eventEmitter: false });
            // No event emitter
            // this.parent = gameObject;

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.setHitAreaMode(GetValue$2J(o, 'hitAreaMode', 0));
            this.setEnable(GetValue$2J(o, 'enable', true));
            this.setStopMode(GetValue$2J(o, 'stopAllLevels', true));
            return this;
        }

        boot() {
            this.parent
                .on('pointerdown', function (pointer, localX, localY, event) {
                    if (this.stopAllLevels) {
                        event.stopPropagation();
                    }
                }, this)
                .on('pointerup', function (pointer, localX, localY, event) {
                    if (this.stopAllLevels) {
                        event.stopPropagation();
                    }
                }, this)
                .on('pointermove', function (pointer, localX, localY, event) {
                    if (this.stopAllLevels) {
                        event.stopPropagation();
                    }
                }, this)
                .on('pointerover', function (pointer, localX, localY, event) {
                    if (this.stopAllLevels) {
                        event.stopPropagation();
                    }
                }, this)
                .on('pointerout', function (pointer, event) {
                    if (this.stopAllLevels) {
                        event.stopPropagation();
                    }
                }, this);
        }

        setHitAreaMode(mode) {
            if (typeof (mode) === 'string') {
                mode = HitAreaMode[mode];
            }

            var gameObject = this.parent;
            if (gameObject.input) {
                gameObject.removeInteractive();
            }

            if (mode === 0) {
                gameObject.setInteractive();
            } else {
                gameObject.setInteractive({
                    hitArea: {},
                    hitAreaCallback: function () { return true; }
                });
            }

            return this;
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            if (e) {
                this.parent.setInteractive();
            } else {
                this.parent.disableInteractive();
            }

            this.enable = e;
            return this;
        }

        setStopMode(allLevels) {
            if (allLevels === undefined) {
                allLevels = true;
            }
            this.stopAllLevels = allLevels;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }
    }

    var HitAreaMode = {
        default: 0,
        fullWindow: 1
    };

    const GetValue$2I = Phaser.Utils.Objects.GetValue;

    class Cover extends FullWindowRectangle {
        constructor(scene, config) {
            var fillColor = GetValue$2I(config, 'color', 0x0);
            var fillAlpha = GetValue$2I(config, 'alpha', 0.8);
            super(scene, fillColor, fillAlpha);

            this.touchEventStop = new TouchEventStop(this, { hitAreaMode: 1 });
        }
    }

    var CreateCover = function (gameObject, config) {
        var scene = gameObject.scene;
        var cover = new Cover(scene, config);
        scene.add.existing(cover);

        // Put cover behind game object
        if (gameObject.isRexContainerLite) {
            gameObject.pin(cover, {
                syncPosition: false,
                syncRotation: false,
                syncScale: false,
                syncAlpha: false,
                syncScrollFactor: false
            });
            gameObject.moveDepthBelow(cover);
        } else {
            scene.children.moveBelow(cover, gameObject);
        }
        return cover;
    };

    var DefaultTransitCallbacks = {
        popUp(gameObject, duration) {
            if (gameObject._modalScaleSave !== undefined) {
                gameObject.scaleX = gameObject._modalScaleSave;
                gameObject.scaleY = gameObject._modalScaleSave;
            } else {
                gameObject._modalScaleSave = gameObject.scaleX;
            }

            PopUp$1(gameObject, duration);
        },

        scaleDown(gameObject, duration) {
            // Don't destroy here
            ScaleDownDestroy(gameObject, duration, undefined, undefined, false);
        },

        fadeIn(gameObject, duration) {
            if (gameObject._modalAlphaSave !== undefined) {
                gameObject.alpha = gameObject._modalAlphaSave;
            } else {
                gameObject._modalAlphaSave = gameObject.alpha;
            }

            FadeIn(gameObject, duration);
        },

        fadeOut(gameObject, duration) {
            // Don't destroy here
            FadeOutDestroy(gameObject, duration, false);
        },
    };

    var DefaultCoverTransitInCallback = function (cover, duration) {
        if (cover._modalAlphaSave !== undefined) {
            cover.alpha = cover._modalAlphaSave;
        } else {
            cover._modalAlphaSave = cover.alpha;
        }

        FadeIn(cover, duration, cover.alpha);
    };

    var DefaultCoverTransitOutCallback = function (cover, duration) {
        FadeOutDestroy(cover, duration, false);
    };

    var IsPointInBounds = function (gameObject, x, y, preTest, postTest) {
        // Can't get bounds
        if (!gameObject) {
            return false;
        }

        if (preTest && !preTest(gameObject, x, y)) {
            return false;
        }

        var boundsRect = GetBounds(gameObject, true);
        if (!boundsRect.contains(x, y)) {
            return false;
        }

        if (postTest && !postTest(gameObject, x, y)) {
            return false;
        }

        return true;
    };

    const GetValue$2H = Phaser.Utils.Objects.GetValue;

    let Modal$3 = class Modal extends OpenCloseTransition {
        constructor(gameObject, config) {
            if (config === undefined) {
                config = {};
            }
            if (config.transitIn == null) {
                config.transitIn = TransitionMode$1.popUp;
            }
            if (config.transitOut == null) {
                config.transitOut = TransitionMode$1.scaleDown;
            }

            config.destroy = GetValue$2H(config, 'destroy', true);

            super(gameObject, config);
            // this.parent = gameObject;
            // this.scene

            // Cover : key of modal, to block touch input        
            var coverConfig = GetValue$2H(config, 'cover');
            this.cover = (coverConfig !== false) ? CreateCover(gameObject, coverConfig) : undefined;
            if (this.cover) {
                this.setCoverTransitInCallback(GetValue$2H(coverConfig, 'transitIn', DefaultCoverTransitInCallback));
                this.setCoverTransitOutCallback(GetValue$2H(coverConfig, 'transitOut', DefaultCoverTransitOutCallback));
            }

            // Close conditions:
            var touchOutsideClose = GetValue$2H(config, 'touchOutsideClose', false);
            var timeOutDuration = GetValue$2H(config, 'duration.hold', -1);
            var timeOutClose = GetValue$2H(config, 'timeOutClose', (timeOutDuration >= 0));
            var anyTouchClose = GetValue$2H(config, 'anyTouchClose', false);
            var manualClose = GetValue$2H(config, 'manualClose', false);

            if (manualClose) {
                touchOutsideClose = false;
                anyTouchClose = false;
                timeOutClose = false;
            }

            if (anyTouchClose) {
                touchOutsideClose = false;
            }

            if (timeOutClose) {
                this.setDisplayTime(timeOutDuration);
            } else {
                this.setDisplayTime(-1);
            }

            // Registet touch-close event after opened
            if (anyTouchClose) {
                this.once('open', this.anyTouchClose, this);
            } else if (touchOutsideClose) {
                this.once('open', this.touchOutsideClose, this);
            }

            if (GetValue$2H(config, 'openOnStart', true)) {
                // Run this.requestOpen() next tick
                // User can register events before this.requestOpen()
                this.delayCall(0, this.requestOpen, this);
            }
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            // Registered in touchOutsideClose(), or anyTouchClose()
            if (!this.cover) {
                this.scene.input.off('pointerup', this.touchCloseCallback, this);
            }

            if (this.cover && !fromScene) {
                this.cover.destroy();
                this.cover = undefined;
            }

            super.shutdown(fromScene);
        }

        touchOutsideClose() {
            if (this.cover) {
                this.cover.on('pointerup', this.touchCloseCallback, this);
            } else {
                this.scene.input.on('pointerup', this.touchCloseCallback, this);
            }
            this.clickOutsideTest = true;
            return this;
        }

        anyTouchClose() {
            if (this.cover) {
                this.cover.once('pointerup', this.touchCloseCallback, this);
            } else {
                this.scene.input.once('pointerup', this.touchCloseCallback, this);
            }
            return this;
        }

        touchCloseCallback(pointer) {
            if (this.clickOutsideTest && IsPointInBounds(this.parent, pointer.worldX, pointer.worldY)) {
                return;
            }
            this.requestClose();
        }

        runTransitionInCallback() {
            var duration = super.runTransitionInCallback();

            var cover = this.cover;
            if (cover && this.coverTransitInCallback) {
                this.coverTransitInCallback(cover, duration);
            }

            return duration;
        }

        runTransitionOutCallback() {
            var duration = super.runTransitionOutCallback();

            var cover = this.cover;
            if (cover && this.coverTransitOutCallback) {
                this.coverTransitOutCallback(cover, duration);
            }

            return duration;
        }

        onOpen() {
            var duration = this.displayTime;
            if (duration >= 0) {
                this.delayCall(
                    duration,
                    this.requestClose, // callback
                    this               // scope
                );
            }

            this.emit('open', this.parent, this);

            super.onOpen();
        }

        onClose() {
            this.emit('close', this.closeEventData);

            super.onClose();
        }

        setDisplayTime(time) {
            this.displayTime = time;
            return this;
        }

        setTransitInCallback(callback) {
            if (typeof (callback) === 'string') {
                callback = TransitionMode$1[callback];
            }

            switch (callback) {
                case TransitionMode$1.popUp:
                    callback = DefaultTransitCallbacks.popUp;
                    break;
                case TransitionMode$1.fadeIn:
                    callback = DefaultTransitCallbacks.fadeIn;
                    break;
            }

            super.setTransitInCallback(callback);
            // callback = function(gameObject, duration) {}
            return this;
        }

        setTransitOutCallback(callback) {
            if (typeof (callback) === 'string') {
                callback = TransitionMode$1[callback];
            }

            switch (callback) {
                case TransitionMode$1.scaleDown:
                    callback = DefaultTransitCallbacks.scaleDown;
                    break;
                case TransitionMode$1.fadeOut:
                    callback = DefaultTransitCallbacks.fadeOut;
                    break;
            }

            super.setTransitOutCallback(callback);
            // callback = function(gameObject, duration) {}
            return this;
        }

        setCoverTransitInCallback(callback) {
            this.coverTransitInCallback = callback;
            return this;
        }

        setCoverTransitOutCallback(callback) {
            this.coverTransitOutCallback = callback;
            return this;
        }

    };

    const TransitionMode$1 = {
        popUp: 0,
        fadeIn: 1,
        scaleDown: 0,
        fadeOut: 1,
    };

    var Modal$2 = function (gameObject, config) {
        var modalBehavior = new Modal$3(gameObject, config);

        // Route modal's 'open', 'close' event
        modalBehavior.on('open', function () {
            gameObject.emit('modal.open', modalBehavior);
        });
        modalBehavior.on('close', function (closeEventData) {
            gameObject.emit('modal.close', closeEventData, modalBehavior);
        });

        // Reigster 'modal.requestClose' event for invoking modalBehavior.requestClose() method
        gameObject.on('modal.requestClose', modalBehavior.requestClose, modalBehavior);
        /*
        It is not necessary to turn off gameObject's 'modal.requestClose' event because that :

        - If `config.destroy` is `undefined` (or `true), gameObject and modalBehavior will be destroyed
        - If `config.destroy` is `false` (for reusing dialog), keeping gameObject and modalBehavior 
        */

        return modalBehavior;
    };

    var ModalPromise = function (gameObject, config) {
        var modalBehavior = Modal$2(gameObject, config);
        return new Promise(function (resolve, reject) {
            modalBehavior.once('close', function (closeEventData) {
                resolve(closeEventData);
            });
        });
    };

    var ModalClose = function (gameObject, closeEventData) {
        gameObject.emit('modal.requestClose', closeEventData);
    };

    var IsFunction = function (obj) {    
        return obj && (typeof(obj) === 'function');
    };

    var ModalMethods$1 = {
        // Override
        // onCreateModalBehavior(self, config) { },

        modal(config, onClose) {
            if (IsFunction(config)) {
                onClose = config;
                config = undefined;
            }

            if (this._modalBehavior === undefined) {
                if (this.onCreateModalBehavior) {
                    this.onCreateModalBehavior(this, config);
                }
                this._modalBehavior = Modal$2(this, config);
            }

            if (onClose) {
                this._modalBehavior.once('close', onClose);
            }

            this._modalBehavior.requestOpen();

            return this;
        },

        modalPromise(config) {
            var self = this;
            return new Promise(function (resolve, reject) {
                self.modal(config, resolve);
            });
        },

        modalClose(closeEventData) {
            ModalClose(this, closeEventData);
            return this;
        }
    };

    var BindEventWithGameObject = function (gameObject, eventEmitter, eventName, callback, scope, once) {
        if (once === undefined) {
            once = false;
        }

        eventEmitter[(once) ? 'once' : 'on'](eventName, callback, scope);

        gameObject.once('destroy', function () {
            eventEmitter.off(eventName, callback, scope);
        });

        return gameObject;
    };

    var BindSceneEvent = function (eventName, gameObject, callback, scope, once) {
        if (IsFunction(gameObject)) {
            once = scope;
            scope = callback;
            callback = gameObject;
            gameObject = this;
        }

        var eventEmitter = this.scene.events;

        this.bindEvent(gameObject, eventEmitter, eventName, callback, scope, once);

        return this;
    };

    var BindEventMethods = {
        bindEvent(gameObject, eventEmitter, eventName, callback, scope, once) {
            if (typeof (eventEmitter) === 'string') {
                once = scope;
                scope = callback;
                callback = eventName;
                eventName = eventEmitter;
                eventEmitter = gameObject;
                gameObject = this;
            }

            BindEventWithGameObject(gameObject, eventEmitter, eventName, callback, scope, once);

            return this;
        },

        bindScenePreupdateEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'preupdate', gameObject, callback, scope, once);
            return this;
        },

        bindSceneUpdateEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'update', gameObject, callback, scope, once);
            return this;
        },

        bindScenePostupdateEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'postupdate', gameObject, callback, scope, once);
            return this;
        },

        bindSceneRenderEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'render', gameObject, callback, scope, once);
            return this;
        },

        bindScenePauseEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'pause', gameObject, callback, scope, once);
            return this;
        },

        bindSceneResumeEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'resume', gameObject, callback, scope, once);
            return this;
        },

        bindSceneSleepEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'sleep', gameObject, callback, scope, once);
            return this;
        },

        bindSceneWakeEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'wake', gameObject, callback, scope, once);
            return this;
        },

        bindSceneShutdownEvent(gameObject, callback, scope, once) {
            BindSceneEvent.call(this, 'shutdown', gameObject, callback, scope, once);
            return this;
        },


    };

    var GetPointerWorldXY = function (pointer, targetCamera, out) {
        var camera = pointer.camera;
        if (!camera) {
            return null;
        }

        if (out === undefined) {
            out = {};
        } else if (out === true) {
            out = globalOut$1;
        }

        if (camera === targetCamera) {
            out.x = pointer.worldX;
            out.y = pointer.worldY;
        } else {
            camera.getWorldPoint(pointer.x, pointer.y, out);
        }

        return out;
    };

    var globalOut$1 = {};

    var PointerTest = function (gameObject, pointer, mainTest, preTest, postTest) {
        var mainCamera = gameObject.scene.sys.cameras.main,
            worldXY;

        var useScreenXY = (gameObject.scrollFactorX === 0) && (gameObject.scrollFactorY === 0);

        if (pointer) {
            if (useScreenXY) {
                return mainTest(gameObject, pointer.x, pointer.y, preTest, postTest);

            } else {
                worldXY = GetPointerWorldXY(pointer, mainCamera, true);
                if (!worldXY) {
                    return false;
                }
                return mainTest(gameObject, worldXY.x, worldXY.y, preTest, postTest);

            }

        } else {
            var inputManager = gameObject.scene.input.manager;
            var pointersTotal = inputManager.pointersTotal;
            var pointers = inputManager.pointers;
            for (var i = 0; i < pointersTotal; i++) {
                pointer = pointers[i];

                if (useScreenXY) {
                    if (mainTest(gameObject, pointer.x, pointer.y, preTest, postTest)) {
                        return true;
                    }

                } else {
                    worldXY = GetPointerWorldXY(pointer, mainCamera, true);
                    if (!worldXY) {
                        continue;
                    }

                    if (mainTest(gameObject, worldXY.x, worldXY.y, preTest, postTest)) {
                        return true;
                    }

                }

            }
            return false;

        }};

    var IsPointerInBounds = function (gameObject, pointer, preTest, postTest) {
        return PointerTest(gameObject, pointer, IsPointInBounds, preTest, postTest)
    };

    var IsInTouching = function (pointer, gameObject) {
        if (IsGameObject(pointer) || (typeof (pointer) === 'string')) {
            gameObject = pointer;
            pointer = undefined;
        }

        if (gameObject === undefined) {
            gameObject = this;
        } else if (typeof (gameObject) === 'string') {
            gameObject = this.getElement(gameObject);
        }

        return IsPointerInBounds(gameObject, pointer);
    };

    var IsArray = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };

    var ContainsPoint$1 = function (gameObject, x, y, preTest, postTest) {
        return IsPointInBounds(
            gameObject,
            x, y,
            GetPreTestCallback(preTest),
            postTest
        );
    };

    var IsShownSizer = function (gameObject) {
        var isHiddenSizer = gameObject.rexSizer && gameObject.rexSizer.hidden;
        return !isHiddenSizer;
    };

    var GetPreTestCallback = function (preTest) {
        if (!preTest) {
            return IsShownSizer;
        }

        return function (gameObject, x, y) {
            if (!IsShownSizer(gameObject)) {
                return false;
            }
            preTest(gameObject, x, y);
            return true;
        }
    };

    var PointToChild$2 = function (x, y, preTest, postTest, children) {
        if (!IsFunction(preTest)) {
            children = preTest;
            preTest = undefined;
            postTest = undefined;
        }

        if (children === undefined) {
            if (this.sizerChildren) {
                children = this.sizerChildren;
            } else {
                children = this.children;
            }
        }

        if (IsArray(children)) {
            var child;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = children[i];
                if (ContainsPoint$1(child, x, y, preTest, postTest)) {
                    return child;
                }
            }
        } else {
            var child;
            for (var key in children) {
                child = children[key];
                if (ContainsPoint$1(child, x, y, preTest, postTest)) {
                    return child;
                }
            }
        }

        return null;
    };

    var CopyState = function (gamObject, out) {
        if (out === undefined) {
            out = {};
        } else if (out === true) {
            out = GlobState;
        }

        out.x = gamObject.x;
        out.y = gamObject.y;
        out.scaleX = gamObject.scaleX;
        out.scaleY = gamObject.scaleY;
        out.width = gamObject.width;
        out.height = gamObject.height;
        out.displayWidth = gamObject.displayWidth;
        out.displayHeight = gamObject.displayHeight;

        return out;
    };

    var GlobState = {};

    var PreLayoutChild = function (child) {
        if (this.sizerEventsEnable) {
            CopyState(child, this.getChildPrevState(child));
            this.layoutedChildren.push(child);
        }
    };

    var LayoutChild = function (child, x, y, width, height, align, offsetX, offsetY) {
        if (offsetX === undefined) { offsetX = 0; }
        if (offsetY === undefined) { offsetY = 0; }

        AlignIn(child, x, y, width, height, align);

        child.x += offsetX;
        child.y += offsetY;

        this.resetChildPositionState(child);

        if (this.sizerEventsEnable) {
            child.emit('sizer.postlayout', child, this);
        }
    };

    const ALIGN_CENTER$4 = Phaser.Display.Align.CENTER;

    var LayoutBackgrounds = function () {
        if (this.backgroundChildren === undefined) {
            return;
        }
        var backgrounds = this.backgroundChildren;

        var startX = this.left,
            startY = this.top;
        var parentWidth = this.width * this.scaleX,
            parentHeight = this.height * this.scaleY;
        var child, childConfig, padding,
            x, y, width, height;
        for (var i = 0, cnt = backgrounds.length; i < cnt; i++) {
            child = backgrounds[i];
            childConfig = child.rexSizer;
            if (childConfig.hidden) {
                continue;
            }

            padding = childConfig.padding;

            PreLayoutChild.call(this, child);

            x = startX + (padding.left * this.scaleX);
            y = startY + (padding.top * this.scaleY);
            width = parentWidth - ((padding.left + padding.right) * this.scaleX);
            height = parentHeight - ((padding.top + padding.bottom) * this.scaleY);

            ResizeGameObject(child, width, height);

            LayoutChild.call(this,
                child, x, y, width, height, ALIGN_CENTER$4,
                0, 0
            );
        }
    };

    const IsPlainObject$w = Phaser.Utils.Objects.IsPlainObject;
    var SetDraggable = function (sensor, draggable, dragTarget) {
        if (IsPlainObject$w(sensor)) {
            var config = sensor;
            sensor = config.sensor;
            dragTarget = config.target;
            draggable = config.draggable;
        } else {
            if (typeof (draggable) !== 'boolean') {
                dragTarget = draggable;
                draggable = undefined;
            }
        }

        var sensorType = typeof (sensor);
        if (sensorType === 'string') {
            var sensorName = sensor;
            sensor = this.getElement(sensorName);
            if (!sensor) {
                console.error(`Can get element '${sensorName}'`);
                return this;
            }
        } else if ((sensor === undefined) || (sensorType != 'object')) {
            draggable = sensor;
            sensor = this;
        }

        if (draggable === undefined) {
            draggable = true;
        }

        if (sensor.input && sensor.input._rexUIDragSizer) {
            // Draggable is already registered
            sensor.input.draggable = draggable;
        } else if (draggable) {
            // Register draggable
            sensor.setInteractive();
            sensor.scene.input.setDraggable(sensor);
            sensor
                .on('drag', function (pointer, dragX, dragY) {
                    var currentDragTarget = (dragTarget === undefined) ? this.getTopmostSizer() : dragTarget;
                    currentDragTarget.x += (dragX - sensor.x);
                    currentDragTarget.y += (dragY - sensor.y);
                    currentDragTarget.emit('sizer.drag', pointer, dragX, dragY);
                }, this)
                .on('dragstart', function (pointer, dragX, dragY) {
                    var currentDragTarget = (dragTarget === undefined) ? this.getTopmostSizer() : dragTarget;
                    currentDragTarget.emit('sizer.dragstart', pointer, dragX, dragY);
                }, this)
                .on('dragend', function (pointer, dragX, dragY, dropped) {
                    var currentDragTarget = (dragTarget === undefined) ? this.getTopmostSizer() : dragTarget;
                    currentDragTarget.emit('sizer.dragend', pointer, dragX, dragY, dropped);
                }, this)
                .on('drop', function (pointer, dropZone) {
                    var currentDragTarget = (dragTarget === undefined) ? this.getTopmostSizer() : dragTarget;
                    currentDragTarget.emit('sizer.drop', pointer, dropZone);
                });
            sensor.input._rexUIDragSizer = true;
        } else ;
        return this;
    };

    var ClickMethods = {
        onClick(gameObject, callback, scope, config) {
            if (!gameObject) {
                return this;
            }

            if (typeof (gameObject) === 'function') {
                config = scope;
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            if (gameObject._click === undefined) {
                gameObject._click = new Button(gameObject, config);
            }
            gameObject._click.on('click', callback, scope);

            return this;
        },

        offClick(gameObject, callback, scope) {
            if (typeof (gameObject) === 'function') {
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            if (gameObject._click === undefined) {
                return this;
            }
            gameObject._click.off('click', callback, scope);

            return this;
        },

        enableClick(gameObject, enabled) {
            if (typeof (gameObject) === 'boolean') {
                enabled = gameObject;
                gameObject = undefined;
            }

            if (gameObject === undefined) {
                gameObject = this;
            }

            if (gameObject._click === undefined) {
                return this;
            }

            gameObject._click.setEnable(enabled);
            return this;
        },

        disableClick(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }

            if (gameObject._click === undefined) {
                return this;
            }
            gameObject._click.setEnable(false);

            return this;
        }
    };

    const GetValue$2G = Phaser.Utils.Objects.GetValue;

    class ClickOutside extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            this._enable = undefined;

            var inputConfig = GetValue$2G(config, "inputConfig", undefined);
            if (inputConfig) {
                gameObject.setInteractive(inputConfig);
            }

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.pointer = undefined;
            this.lastClickTime = undefined;
            this.setEnable(GetValue$2G(o, "enable", true));
            this.setMode(GetValue$2G(o, "mode", 1));
            this.setClickInterval(GetValue$2G(o, "clickInterval", 100));
            this.setDragThreshold(GetValue$2G(o, 'threshold', undefined));
            return this;
        }

        boot() {
            var scene = this.parent.scene;
            scene.input.on('pointerdown', this.onPress, this);
            scene.input.on('pointerup', this.onRelease, this);
            scene.input.on('pointermove', this.onMove, this);
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            var scene = this.parent.scene;
            scene.input.off('pointerdown', this.onPress, this);
            scene.input.off('pointerup', this.onRelease, this);
            scene.input.off('pointermove', this.onMove, this);
            this.pointer = null;

            super.shutdown(fromScene);
        }

        get enable() {
            return this._enable;
        }

        set enable(e) {
            if (this._enable === e) {
                return;
            }

            if (!e) {
                this.cancel();
            }
            this._enable = e;

            var eventName = (e) ? 'enable' : 'disable';
            this.emit(eventName, this, this.parent);
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        setMode(m) {
            if (typeof (m) === 'string') {
                m = CLICKMODE[m];
            }
            this.mode = m;
            return this;
        }

        setClickInterval(interval) {
            this.clickInterval = interval; // ms
            return this;
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }

        isPointerInside(pointer) {
            var gameObject = this.parent;
            var isInsideCallback = (gameObject.input) ? IsPointerInHitArea : IsPointerInBounds;
            return isInsideCallback(gameObject, pointer);
        }

        // internal
        onPress(pointer) {
            // Do nothing if game object is not visible
            if (!this.parent.willRender(pointer.camera)) {
                return;
            }

            if (this.pointer !== undefined) {
                return;
            }

            if (this.isPointerInside(pointer)) {
                return;
            }

            this.pointer = pointer;

            if (this.mode === 0) {
                if (!this.isPointerInside(pointer)) {
                    this.click(pointer.downTime, pointer);
                }
            }
        }

        onRelease(pointer) {
            // Do nothing if game object is not visible
            if (!this.parent.willRender(pointer.camera)) {
                return;
            }

            if (this.pointer !== pointer) {
                return;
            }

            if (this.mode === 1) {
                if (!this.isPointerInside(pointer)) {
                    this.click(pointer.upTime, pointer);
                }
            }

            this.pointer = undefined;
        }

        onMove(pointer, localX, localY, event) {
            if (this.pointer !== pointer) {
                return;
            }

            if (this.dragThreshold === undefined) {
                return;
            }

            if (this.mode === 1) {
                if ((pointer.getDistance() >= this.dragThreshold) ||
                    (this.isPointerInside(pointer))) {
                    this.cancel();
                }
            }
        }

        click(nowTime, pointer) {
            if (!this.enable) {
                return this;
            }

            if (nowTime === undefined) {
                // fires 'clickoutside' event manually
                this.emit('clickoutside', this, this.parent, pointer);
                return this;
            }

            this.pointer = undefined;
            var lastClickTime = this.lastClickTime;
            if ((lastClickTime !== undefined) &&
                ((nowTime - lastClickTime) <= this.clickInterval)) {
                return this;
            }
            this.lastClickTime = nowTime;
            this.emit('clickoutside', this, this.parent, pointer);

            return this;
        }

        cancel() {
            this.pointer = undefined;
            return this;
        }
    }

    const CLICKMODE = {
        press: 0,
        pointerdown: 0,
        release: 1,
        pointerup: 1,
    };

    var ClickOutsideMethods = {
        onClickOutside(gameObject, callback, scope, config) {
            if (!gameObject) {
                return this;
            }

            if (typeof (gameObject) === 'function') {
                config = scope;
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            if (gameObject._clickOutside === undefined) {
                gameObject._clickOutside = new ClickOutside(gameObject, config);
            }
            gameObject._clickOutside.on('clickoutside', callback, scope);

            return this;
        },

        offClickOutside(gameObject, callback, scope) {
            if (typeof (gameObject) === 'function') {
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            if (gameObject._clickOutside === undefined) {
                return this;
            }
            gameObject._clickOutside.off('clickoutside', callback, scope);

            return this;
        },

        enableClickOutside(gameObject, enabled) {
            if (typeof (gameObject) === 'boolean') {
                enabled = gameObject;
                gameObject = undefined;
            }

            if (gameObject === undefined) {
                gameObject = this;
            }

            if (gameObject._clickOutside === undefined) {
                return this;
            }
            gameObject._clickOutside.setEnable(enabled);

            return this;
        },

        disableClickOutside(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }

            if (gameObject._clickOutside === undefined) {
                return this;
            }
            gameObject._clickOutside.setEnable(false);

            return this;
        }
    };

    class Cooldown extends FSM {
        constructor() {
            super({
                eventEmitter: false
            });

            this.goto('IDLE');
        }

        setCooldownTime(time) {
            this.cooldownTime = time;
            this.cooldownMode = (time !== undefined);
            return this;
        }

        request() {
            return this.runMethod('request');
        }

        // IDLE state
        update_IDLE() {
            this.compensationTime = 0;
        }
        request_IDLE() {
            this.next();
            return true;
        }
        next_IDLE() {
            if (this.cooldownMode) {
                return 'COOLDOWN';
            }
        }

        // COOLDOWN state
        enter_COOLDOWN() {
            this.remainderTime = this.cooldownTime + this.compensationTime;
        }
        update_COOLDOWN(time, delta) {
            this.remainderTime -= delta;
            if (this.remainderTime < 0) {
                this.compensationTime = (this.cooldownTime > delta) ? (-this.remainderTime) : 0;
                this.goto('IDLE');
            }
        }
        request_COOLDOWN() {
            return false;
        }

    }

    const GetValue$2F = Phaser.Utils.Objects.GetValue;

    class InTouching extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            this._enable = undefined;
            this.cooldown = new Cooldown();
            this.parent.setInteractive(GetValue$2F(config, 'inputConfig', undefined));
            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.pointer = undefined;
            this.prevIsInTouch = false;
            this.isInTouching = false;
            this.setEnable(GetValue$2F(o, 'enable', true));
            this.setCooldown(GetValue$2F(o, 'cooldown', undefined));
            return this;
        }

        boot() {
            var gameObject = this.parent;
            gameObject.on('pointerdown', this.onPointIn, this);
            gameObject.on('pointerover', this.onPointIn, this);
            gameObject.on('pointerup', this.onPointOut, this);
            gameObject.on('pointerout', this.onPointOut, this);
            this.scene.sys.events.on('preupdate', this.preupdate, this);
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            // GameObject events will be removed when this gameObject destroyed 
            // this.parent.off('pointerdown', this.onPointIn, this);
            // this.parent.off('pointerover', this.onPointIn, this);
            // this.parent.off('pointerup', this.onPointOut, this);
            // this.parent.off('pointerout', this.onPointOut, this);
            this.scene.sys.events.off('preupdate', this.preupdate, this);

            this.pointer = undefined;
            super.shutdown(fromScene);
        }

        get enable() {
            return this._enable;
        }

        set enable(e) {
            if (this._enable === e) {
                return;
            }

            if (!e) {
                this.prevIsInTouch = false;
                this.isInTouching = false;
                this.pointer = undefined;
            }
            this._enable = e;
            return this;
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        get cooldownTime() {
            return this.cooldown.cooldownTime;
        }

        set cooldownTime(time) {
            this.cooldown.setCooldownTime(time);
        }

        setCooldown(time) {
            this.cooldownTime = time;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        // internal
        onPointIn(pointer, localX, localY) {
            if ((!this.enable) ||
                (!pointer.isDown) ||
                (this.pointer !== undefined)) {
                return;
            }
            this.pointer = pointer;
            this.isInTouching = true;
        }

        onPointOut(pointer) {
            if ((!this.enable) ||
                (this.pointer !== pointer)) {
                return;
            }
            this.pointer = undefined;
            this.isInTouching = false;
        }

        preupdate(time, delta) {
            this.cooldown.update(time, delta);

            if (!this.prevIsInTouch && this.isInTouching) {
                this.emit('touchstart', this, this.parent);
            }

            if (this.isInTouching && this.cooldown.request()) {
                this.emit('intouch', this, this.parent, this.pointer);
            }
            
            if (this.prevIsInTouch && !this.isInTouching) {
                this.emit('touchend', this, this.parent);
            }

            this.prevIsInTouch = this.isInTouching;
        }
    }

    var TouchingMethods = {
        isPointerInBounds(target) {
            if (target === undefined) {
                target = this;
            } else if (typeof (target) === 'string') {
                target = this.getElement(target);
            }

            if (!target) {
                return false;
            }

            return IsPointerInBounds(target);
        },

        onTouching(gameObject, callback, scope, config) {
            if (!gameObject) {
                return this;
            }

            if (typeof (gameObject) === 'function') {
                config = scope;
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            if (gameObject._inTouching === undefined) {
                gameObject._inTouching = new InTouching(gameObject, config);
            }
            gameObject._inTouching.on('intouch', callback, scope);

            return this;
        },

        offTouching(gameObject, callback, scope) {
            if (typeof (gameObject) === 'function') {
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            if (gameObject._inTouching === undefined) {
                return this;
            }
            gameObject._inTouching.off('intouch', callback, scope);

            return this;
        },

        onTouchingEnd(gameObject, callback, scope, config) {
            if (!gameObject) {
                return this;
            }

            if (typeof (gameObject) === 'function') {
                config = scope;
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            if (gameObject._inTouching === undefined) {
                gameObject._inTouching = new InTouching(gameObject, config);
            }
            gameObject._inTouching.on('touchend', callback, scope);

            return this;
        },

        offTouchingEnd(gameObject, callback, scope) {
            if (typeof (gameObject) === 'function') {
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            if (gameObject._inTouching === undefined) {
                return this;
            }
            gameObject._inTouching.off('touchend', callback, scope);

            return this;
        },


        enableTouching(gameObject, enabled) {
            if (typeof (gameObject) === 'boolean') {
                enabled = gameObject;
                gameObject = undefined;
            }

            if (gameObject === undefined) {
                gameObject = this;
            }

            if (gameObject._inTouching === undefined) {
                return this;
            }
            gameObject._inTouching.setEnable(enabled);

            return this;
        },

        disableTouching(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }

            if (gameObject._inTouching === undefined) {
                return this;
            }
            gameObject._inTouching.setEnable(false);

            return this;
        },


    };

    var HoverMethods = {
        onOver(gameObject, callback, scope) {
            if (!gameObject) {
                return this;
            }
            if (typeof (gameObject) === 'function') {
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            gameObject
                .setInteractive()
                .on('pointerover', callback, scope);

            return this;
        },

        onOut(gameObject, callback, scope) {
            if (!gameObject) {
                return this;
            }
            if (typeof (gameObject) === 'function') {
                scope = callback;
                callback = gameObject;
                gameObject = this;
            }

            gameObject
                .setInteractive()
                .on('pointerout', callback, scope);

            return this;
        },
    };

    var ContainsPoint = function (targetMode, gameObjects, x, y) {
        if (targetMode === 'parent') {
            var parent;
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                parent = gameObjects[i];
                if (!ContainsPoint$1(parent, x, y)) {
                    continue;
                }

                return parent.pointToChild(x, y);
            }
        } else {  // direct mode
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                var target = gameObjects[i];
                if (ContainsPoint$1(target, x, y)) {
                    return target;
                }
            }
        }

        return null;
    };

    var EmitChildEvent = function (eventEmitter, eventName, targets, targetMode, worldX, worldY, pointer, event) {
        var child;
        if (worldY === undefined) {
            child = worldX;
        } else {
            var firstChild = targets[0];
            if (!firstChild) {
                return;
            }
            var camera = pointer.camera;
            var px = worldX + camera.scrollX * (firstChild.scrollFactorX - 1);
            var py = worldY + camera.scrollY * (firstChild.scrollFactorY - 1);
            child = ContainsPoint(targetMode, targets, px, py);
        }

        if (!child) {
            return;
        }

        eventEmitter.emit(eventName, child, pointer, event);
    };

    const GetValue$2E = Phaser.Utils.Objects.GetValue;

    var DownChild = function (config) {
        var downConfig = GetValue$2E(config, 'down', undefined);
        if (downConfig === false) {
            return;
        } else if (downConfig === true) {
            downConfig = undefined;
        }

        this
            .on('pointerdown', OnDown, this);
    };

    var OnDown = function (pointer, localX, localY, event) {
        var childrenInteractive = this._childrenInteractive;

        EmitChildEvent(
            childrenInteractive.eventEmitter,
            `${childrenInteractive.eventNamePrefix}down`,
            childrenInteractive.targetSizers,
            childrenInteractive.targetMode,
            pointer.worldX, pointer.worldY,
            pointer, event
        );
    };

    const GetValue$2D = Phaser.Utils.Objects.GetValue;

    var UpChild = function (config) {
        var upConfig = GetValue$2D(config, 'up', undefined);
        if (upConfig === false) {
            return;
        } else if (upConfig === true) {
            upConfig = undefined;
        }

        this
            .on('pointerup', OnUp, this);
    };

    var OnUp = function (pointer, localX, localY, event) {
        var childrenInteractive = this._childrenInteractive;

        EmitChildEvent(
            childrenInteractive.eventEmitter,
            `${childrenInteractive.eventNamePrefix}up`,
            childrenInteractive.targetSizers,
            childrenInteractive.targetMode,
            pointer.worldX, pointer.worldY,
            pointer, event
        );
    };

    const GetValue$2C = Phaser.Utils.Objects.GetValue;

    var OverChild = function (config) {
        var overConfig = GetValue$2C(config, 'over', undefined);
        if (overConfig === false) {
            return;
        } else if (overConfig === true) {
            overConfig = undefined;
        }

        this
            .on('pointermove', OnMove$1, this)
            .on('pointerover', OnMove$1, this)
            .on('pointerout', OnOut$1, this);  // pointer-up is included too
    };

    var OnMove$1 = function (pointer, localX, localY, event) {
        var childrenInteractive = this._childrenInteractive;
        var firstChild = childrenInteractive.targetSizers[0];
        if (!firstChild) {
            return;
        }
        var camera = pointer.camera;
        var px = pointer.worldX + camera.scrollX * (firstChild.scrollFactorX - 1);
        var py = pointer.worldY + camera.scrollY * (firstChild.scrollFactorY - 1);

        var child = ContainsPoint(childrenInteractive.targetMode, childrenInteractive.targetSizers, px, py);
        var preChild = childrenInteractive.lastOverChild;
        if (child && preChild &&
            (child === preChild)) {
            return;
        }

        childrenInteractive.lastOverChild = child;
        EmitChildEvent(
            childrenInteractive.eventEmitter,
            `${childrenInteractive.eventNamePrefix}out`,
            childrenInteractive.targetSizers,
            childrenInteractive.targetMode,
            preChild, undefined,
            pointer, event
        );
        EmitChildEvent(
            childrenInteractive.eventEmitter,
            `${childrenInteractive.eventNamePrefix}over`,
            childrenInteractive.targetSizers,
            childrenInteractive.targetMode,
            child, undefined,
            pointer, event
        );
    };

    var OnOut$1 = function (pointer, event) {
        var childrenInteractive = this._childrenInteractive;
        var child = childrenInteractive.lastOverChild;
        childrenInteractive.lastOverChild = null;
        EmitChildEvent(
            childrenInteractive.eventEmitter,
            `${childrenInteractive.eventNamePrefix}out`,
            childrenInteractive.targetSizers,
            childrenInteractive.targetMode,
            child, undefined,
            pointer, event
        );
    };

    const GetValue$2B = Phaser.Utils.Objects.GetValue;

    var ClickChild = function (config) {
        var clickConfig = GetValue$2B(config, 'click', undefined);
        if (clickConfig === false) {
            return;
        } else if (clickConfig === true) {
            clickConfig = undefined;
        }

        if (clickConfig === undefined) {
            clickConfig = {};
        }
        if (!clickConfig.hasOwnProperty('threshold')) {
            clickConfig.threshold = 10;
        }

        var childrenInteractive = this._childrenInteractive;
        this._click = new Button(this, clickConfig);
        this._click.on('click', function (button, gameObject, pointer, event) {
            EmitChildEvent(
                childrenInteractive.eventEmitter,
                `${childrenInteractive.eventNamePrefix}click`,
                childrenInteractive.targetSizers,
                childrenInteractive.targetMode,
                pointer.worldX, pointer.worldY,
                pointer, event
            );
        }, this);
    };

    const GetValue$2A = Phaser.Utils.Objects.GetValue;

    class OnePointerTracer extends TickTask {
        constructor(gameObject, config) {
            var scene = GetSceneObject(gameObject);
            if (scene === gameObject) {
                gameObject = undefined;
            }
            super(scene, config);

            this.gameObject = gameObject;
            if (gameObject) {
                gameObject.setInteractive(GetValue$2A(config, 'inputConfig', undefined));
            }
            this._enable = undefined;
            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.setEnable(GetValue$2A(o, 'enable', true));

            this.setDetectBounds();
            if (this.gameObject === undefined) {
                this.setDetectBounds(GetValue$2A(o, 'bounds', undefined));
            } else {
                this.setDetectBounds();
            }

            this.tracerState = TOUCH0$2;
            // this.recongizedState = new stateClass(this);
            this.pointer = undefined;
            this.lastPointer = undefined; // Last catched pointer
            this.movedState = false;
            this.isTouchingAnyObject = false;
            return this;
        }

        boot() {
            super.boot();
            if (this.gameObject) {
                this.gameObject.on('pointerdown', this.onPointerDown, this);
            } else {
                this.scene.input.on('pointerdown', this.onPointerDown, this);
            }
            this.scene.input.on('pointerup', this.onPointerUp, this);
            this.scene.input.on('gameout', this.dragCancel, this);

            this.scene.input.on('pointermove', this.onPointerMove, this);
            this.scene.sys.events.once('shutdown', this.destroy, this);
        }

        shutdown(fromScene) {
            if (!this.scene) {
                return
            }

            if (this.gameObject) ; else {
                this.scene.input.off('pointerdown', this.onPointerDown, this);
            }
            this.scene.input.off('pointerup', this.onPointerUp, this);
            this.scene.input.off('gameout', this.dragCancel, this);

            this.scene.input.off('pointermove', this.onPointerMove, this);
            this.scene.sys.events.off('shutdown', this.destroy, this);

            this.gameObject = undefined;
            this.bounds = undefined;
            this.pointer = undefined;
            this.lastPointer = undefined; // Last catched pointer
            this.movedState = false;

            super.shutdown(fromScene);
        }

        get enable() {
            return this._enable;
        }

        set enable(e) {
            if (this._enable === e) {
                return;
            }

            if (!e) {
                this.dragCancel();
            }
            this._enable = e;
            return this;
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        setDetectBounds(bounds) {
            this.bounds = bounds;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        onPointerDown(pointer, gameObjects) {
            if (!this.enable) {
                return;
            }

            if (this.pointer !== undefined) {
                return;
            }

            var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
            if (!isInsideBounds) {
                return;
            }

            if (this.pointer === pointer) {
                return;
            }

            this.pointer = pointer;
            this.pointerCamera = pointer.camera;
            this.lastPointer = pointer;
            this.movedState = false;
            this.tracerState = TOUCH1$2;

            if (this.gameObject === undefined) {
                this.isTouchingAnyObject = (gameObjects.length > 0);
            }
            this.onDragStart();
        }

        onPointerUp(pointer) {
            if (!this.enable) {
                return;
            }

            var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
            if (!isInsideBounds) {
                return;
            }

            if (this.pointer !== pointer) {
                return;
            }

            this.pointer = undefined;
            this.pointerCamera = undefined;
            this.movedState = false;
            this.tracerState = TOUCH0$2;
            this.onDragEnd();
        }

        onPointerMove(pointer) {
            if (!this.enable) {
                return;
            }

            if (pointer.isDown) {
                var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
                var isCatchedPointer = (this.pointer === pointer);
                if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) { // Pointer moves out of bounds
                    this.onPointerUp(pointer);
                } else { // Pointer drags in bounds
                    if (!this.movedState) {
                        this.movedState = (pointer.x !== pointer.downX) || (pointer.y !== pointer.downY);
                    }
                    if (this.movedState) {
                        this.onDrag();
                    }
                }
            }
        }

        dragCancel() {
            if (this.tracerState === TOUCH1$2) {
                this.onDragEnd();
            }
            this.pointer = undefined;
            this.tracerState = TOUCH0$2;
            return this;
        }

        onDragStart() {
            this.emit('dragstart', this);
        }

        onDragEnd() {
            this.emit('dragend', this);
        }

        onDrag() {
            this.emit('drag', this);
        }

        // onLastPointerMove() { }

        preUpdate(time, delta) { }

        postUpdate(time, delta) { }

        startTicking() {
            super.startTicking();
            this.scene.sys.events.on('preupdate', this.preUpdate, this);
            this.scene.sys.events.on('postupdate', this.postUpdate, this);
        }

        stopTicking() {
            super.stopTicking();
            if (this.scene) { // Scene might be destoryed
                this.scene.sys.events.off('preupdate', this.preUpdate, this);
                this.scene.sys.events.off('postupdate', this.postUpdate, this);
            }
        }

        setRecongizedStateObject(stateObject) {
            this.recongizedState = stateObject;
            return this;
        }

        get state() {
            return this.recongizedState.state;
        }

        set state(newState) {
            this.recongizedState.state = newState;
        }

        cancel() {
            this.state = IDLE$7;
            return this;
        }

        isPointerInGameObject(gameObject, preTest, postTest) {
            var pointer = this.lastPointer;
            if (!pointer) {
                return false;
            }

            return IsPointerInBounds(gameObject, pointer, preTest, postTest);
        }
    }

    const TOUCH0$2 = 0;
    const TOUCH1$2 = 1;

    const IDLE$7 = 'IDLE';

    const GetValue$2z = Phaser.Utils.Objects.GetValue;
    const DistanceBetween$5 = Phaser.Math.Distance.Between;

    class Tap extends OnePointerTracer {
        constructor(gameObject, config) {
            super(gameObject, config);

            var self = this;
            var stateConfig = {
                states: {
                    IDLE: {
                        enter: function () {
                            self.stop();
                            self.tapsCount = 0;
                            self.x = 0;
                            self.y = 0;
                            self.worldX = 0;
                            self.worldY = 0;
                            self.lastPointer = undefined;
                        },
                        exit: function () {
                            var pointer = self.lastPointer;
                            self.x = pointer.x;
                            self.y = pointer.y;
                            self.worldX = pointer.worldX;
                            self.worldY = pointer.worldY;
                        }
                    },
                    BEGIN: {
                        enter: function () {
                            self.start();
                            self.tapsCount = 0;
                            self.emit('tappingstart', self, self.gameObject, self.lastPointer);
                        },
                    },
                    RECOGNIZED: {
                        enter: function () {
                            self.start();
                            self.emit('tap', self, self.gameObject, self.lastPointer);
                            self.emit(`${self.tapsCount}tap`, self, self.gameObject, self.lastPointer);
                        },
                    }
                },
                init: function () {
                    this.state = IDLE$6;
                },
                eventEmitter: false,
            };
            this.setRecongizedStateObject(new FSM(stateConfig));
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setHoldTime(GetValue$2z(o, 'time', 250)); // min-hold-time of Press is 251
            this.setTapInterval(GetValue$2z(o, 'tapInterval', 200));
            this.setDragThreshold(GetValue$2z(o, 'threshold', 9));
            this.setTapOffset(GetValue$2z(o, 'tapOffset', 10));

            var taps = GetValue$2z(o, 'taps', undefined);
            if (taps !== undefined) {
                this.setTaps(taps);
            } else {
                this.setMaxTaps(GetValue$2z(o, 'maxTaps', undefined));
                this.setMinTaps(GetValue$2z(o, 'minTaps', undefined));
            }
            return this;
        }

        onDragStart() {
            switch (this.state) {
                case IDLE$6:
                    this.state = BEGIN$5;
                    break;

                case BEGIN$5:
                    var pointer = this.lastPointer;
                    var tapsOffset = DistanceBetween$5(
                        pointer.upX,
                        pointer.upY,
                        pointer.x,
                        pointer.y);
                    if (tapsOffset > this.tapOffset) { // Can't recognize next level, restart here
                        this.state = RECOGNIZED$5;
                        this.state = BEGIN$5;
                    }
                    break;

                case RECOGNIZED$5:
                    this.state = BEGIN$5;
                    break;
            }
        }

        onDragEnd() {
            if (this.state === BEGIN$5) {
                this.tapsCount++; // Try recognize next level
                this.emit('tapping', this, this.gameObject, this.lastPointer);

                if ((this.maxTaps !== undefined) && (this.tapsCount === this.maxTaps)) { // Reach to maxTaps, stop here                
                    this.state = RECOGNIZED$5;
                }
            }
        }

        onDrag() {
            if (this.state === IDLE$6) {
                return;
            }

            if (this.pointer.getDistance() > this.dragThreshold) { // Cancel
                this.state = IDLE$6;
            }
        }

        preUpdate(time, delta) {
            if ((!this.isRunning) || (!this.enable)) {
                return;
            }
            if (this.state === BEGIN$5) {
                var pointer = this.lastPointer;
                if (pointer.isDown) {
                    var holdTime = time - pointer.downTime;
                    if (holdTime > this.holdTime) {
                        this.state = IDLE$6;
                    }
                } else { // isUp
                    var releasedTime = time - pointer.upTime;
                    if (releasedTime > this.tapInterval) {
                        if ((this.minTaps === undefined) || (this.tapsCount >= this.minTaps)) {
                            this.state = RECOGNIZED$5;
                        } else {
                            this.state = IDLE$6;
                        }
                    }
                }
            }
        }

        postUpdate(time, delta) {
            if ((!this.isRunning) || (!this.enable)) {
                return;
            }
            // Clear RECOGNIZED after update()
            if (this.state === RECOGNIZED$5) {
                this.state = IDLE$6;
            }
        }

        get isTapped() {
            return (this.state === RECOGNIZED$5);
        }

        setHoldTime(time) {
            this.holdTime = time; // ms
            return this;
        }

        setTapInterval(time) {
            this.tapInterval = time; // ms
            return this;
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }

        setTapOffset(distance) {
            this.tapOffset = distance;
            return this;
        }

        setMaxTaps(taps) {
            this.maxTaps = taps;
            return this;
        }

        setMinTaps(taps) {
            this.minTaps = taps;
            return this;
        }

        setTaps(minTaps, maxTaps) {
            if (maxTaps === undefined) {
                maxTaps = minTaps;
            }
            this.setMinTaps(minTaps).setMaxTaps(maxTaps);
            return this;
        }
    }

    const IDLE$6 = 'IDLE';
    const BEGIN$5 = 'BEGIN';
    const RECOGNIZED$5 = 'RECOGNIZED';

    const GetValue$2y = Phaser.Utils.Objects.GetValue;

    class Press extends OnePointerTracer {
        constructor(gameObject, config) {
            super(gameObject, config);

            var self = this;
            var stateConfig = {
                states: {
                    IDLE: {
                        enter: function () {
                            self.x = 0;
                            self.y = 0;
                            self.worldX = 0;
                            self.worldY = 0;
                            self.lastPointer = undefined;
                        },
                        exit: function () {
                            var pointer = self.lastPointer;
                            self.x = pointer.x;
                            self.y = pointer.y;
                            self.worldX = pointer.worldX;
                            self.worldY = pointer.worldY;
                        }
                    },
                    BEGIN: {
                        enter: function () {
                            self.start();
                        },
                        exit: function () {
                            self.stop();
                        }
                    },
                    RECOGNIZED: {
                        enter: function () {
                            self.emit('pressstart', self, self.gameObject, self.lastPointer);
                        },
                        exit: function () {
                            self.emit('pressend', self, self.gameObject, self.lastPointer);
                        }
                    }
                },
                init: function () {
                    this.state = IDLE$5;
                },
                eventEmitter: false,
            };
            this.setRecongizedStateObject(new FSM(stateConfig));
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setDragThreshold(GetValue$2y(o, 'threshold', 9));
            this.setHoldTime(GetValue$2y(o, 'time', 251));
            return this;
        }

        onDragStart() {
            this.state = BEGIN$4;
            if (this.holdTime === 0) {
                this.state = RECOGNIZED$4;
            }
        }

        onDragEnd() {
            this.state = IDLE$5;
        }

        onDrag() {
            if (this.state === IDLE$5) {
                return;
            }

            if (this.pointer.getDistance() > this.dragThreshold) {
                this.state = IDLE$5;
            }
        }

        preUpdate(time, delta) {
            if ((!this.isRunning) || (!this.enable)) {
                return;
            }
            if (this.state === BEGIN$4) {
                var holdTime = time - this.pointer.downTime;
                if (holdTime >= this.holdTime) {
                    this.state = RECOGNIZED$4;
                }
            }
        }

        get isPressed() {
            return (this.state === RECOGNIZED$4);
        }

        setHoldTime(time) {
            this.holdTime = time; // ms
            return this;
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }
    }

    const IDLE$5 = 'IDLE';
    const BEGIN$4 = 'BEGIN';
    const RECOGNIZED$4 = 'RECOGNIZED';

    const GetValue$2x = Phaser.Utils.Objects.GetValue;

    class Pan extends OnePointerTracer {
        constructor(gameObject, config) {
            super(gameObject, config);

            var self = this;
            var stateConfig = {
                states: {
                    IDLE: {
                    },
                    BEGIN: {
                        enter: function () {
                            var pointer = self.pointer;
                            self.startX = pointer.x;
                            self.startY = pointer.y;
                            self.startWorldX = pointer.worldX;
                            self.startWorldY = pointer.worldY;
                        }
                    },
                    RECOGNIZED: {
                        enter: function () {
                            self.emit('panstart', self, self.gameObject, self.lastPointer);
                        },
                        exit: function () {
                            var pointer = self.lastPointer;
                            self.endX = pointer.x;
                            self.endY = pointer.y;

                            var worldXY = GetPointerWorldXY(pointer, self.pointerCamera, true);
                            self.endWorldX = worldXY.x;
                            self.endWorldY = worldXY.y;

                            self.emit('panend', self, self.gameObject, self.lastPointer);
                        }
                    }
                },
                init: function () {
                    this.state = IDLE$4;
                },
                eventEmitter: false,
            };
            this.setRecongizedStateObject(new FSM(stateConfig));
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setDragThreshold(GetValue$2x(o, 'threshold', 10));
            return this;
        }

        onDragStart() {
            this.state = BEGIN$3;
            if (this.dragThreshold === 0) {
                this.state = RECOGNIZED$3;
            }
        }

        onDragEnd() {
            this.state = IDLE$4;
        }

        onDrag() {
            switch (this.state) {
                case BEGIN$3:
                    if (this.pointer.getDistance() >= this.dragThreshold) {
                        this.state = RECOGNIZED$3;

                        this.dx = 0;
                        this.dy = 0;
                        this.dWorldX = 0;
                        this.dWorldY = 0;

                        var pointer = this.pointer;
                        this.x = pointer.x;
                        this.y = pointer.y;
                        this.worldX = pointer.worldX;
                        this.worldY = pointer.worldY;
                    }
                    break;

                case RECOGNIZED$3:
                    var pointerCamera = this.pointerCamera;

                    var p1 = this.pointer.position;
                    var p0 = this.pointer.prevPosition;
                    this.dx = p1.x - p0.x;
                    this.dy = p1.y - p0.y;
                    this.dWorldX = this.dx / pointerCamera.zoom;
                    this.dWorldY = this.dy / pointerCamera.zoom;


                    var pointer = this.pointer;
                    this.x = pointer.x;
                    this.y = pointer.y;

                    var worldXY = GetPointerWorldXY(pointer, pointerCamera, true);
                    this.worldX = worldXY.x;
                    this.worldY = worldXY.y;

                    this.emit('pan', this, this.gameObject, this.lastPointer);
                    break;
            }
        }

        get isPanned() {
            return (this.state === RECOGNIZED$3);
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }
    }

    const IDLE$4 = 'IDLE';
    const BEGIN$3 = 'BEGIN';
    const RECOGNIZED$3 = 'RECOGNIZED';

    const DistanceBetween$4 = Phaser.Math.Distance.Between;
    const AngleBetween$1 = Phaser.Math.Angle.Between;

    var VelocityMethods = {
        getDt: function () {
            var dt = GetTickDelta(this.scene);
            return dt;
        },

        getVelocity: function () {
            var p1 = this.pointer.position;
            var p0 = this.pointer.prevPosition;
            var d = DistanceBetween$4(p0.x, p0.y, p1.x, p1.y);
            var velocity = d / (this.getDt() * 0.001);
            return velocity;
        },

        getVelocityX: function () {
            var p1 = this.pointer.position;
            var p0 = this.pointer.prevPosition;
            var d = Math.abs(p1.x - p0.x);
            var velocity = d / (this.getDt() * 0.001);
            return velocity;
        },

        getVelocityY: function () {
            var p1 = this.pointer.position;
            var p0 = this.pointer.prevPosition;
            var d = Math.abs(p1.y - p0.y);
            var velocity = d / (this.getDt() * 0.001);
            return velocity;
        },

        getVelocityAngle: function () {
            var p1 = this.pointer.position;
            var p0 = this.pointer.prevPosition;
            var angle = AngleBetween$1(p0.x, p0.y, p1.x, p1.y);
            return angle;
        }
    };

    var DIRMODE$1 = {
        'up&down': 0,
        'left&right': 1,
        '4dir': 2,
        '8dir': 3
    };

    var AngleToDirections = function (angle, dirMode, out) {
        if (out === undefined) {
            out = {};
        } else if (out === true) {
            out = globOut$1;
        }

        out.left = false;
        out.right = false;
        out.up = false;
        out.down = false;

        angle = (angle + 360) % 360;
        switch (dirMode) {
            case 0: // up & down
                if (angle < 180) {
                    out.down = true;
                } else {
                    out.up = true;
                }
                break;

            case 1: // left & right
                if ((angle > 90) && (angle <= 270)) {
                    out.left = true;
                } else {
                    out.right = true;
                }
                break;

            case 2: // 4 dir
                if ((angle > 45) && (angle <= 135)) {
                    out.down = true;
                } else if ((angle > 135) && (angle <= 225)) {
                    out.left = true;
                } else if ((angle > 225) && (angle <= 315)) {
                    out.up = true;
                } else {
                    out.right = true;
                }
                break;

            case 3: // 8 dir
                if ((angle > 22.5) && (angle <= 67.5)) {
                    out.down = true;
                    out.right = true;
                } else if ((angle > 67.5) && (angle <= 112.5)) {
                    out.down = true;
                } else if ((angle > 112.5) && (angle <= 157.5)) {
                    out.down = true;
                    out.left = true;
                } else if ((angle > 157.5) && (angle <= 202.5)) {
                    out.left = true;
                } else if ((angle > 202.5) && (angle <= 247.5)) {
                    out.left = true;
                    out.up = true;
                } else if ((angle > 247.5) && (angle <= 292.5)) {
                    out.up = true;
                } else if ((angle > 292.5) && (angle <= 337.5)) {
                    out.up = true;
                    out.right = true;
                } else {
                    out.right = true;
                }
                break;
        }

        return out;
    };

    var globOut$1 = {};

    const GetValue$2w = Phaser.Utils.Objects.GetValue;
    const RadToDeg$5 = Phaser.Math.RadToDeg;

    class Swipe extends OnePointerTracer {
        constructor(gameObject, config) {
            super(gameObject, config);

            var self = this;
            var stateConfig = {
                states: {
                    IDLE: {
                        enter: function () {
                            self.x = 0;
                            self.y = 0;
                            self.worldX = 0;
                            self.worldY = 0;
                        },
                        exit: function () {
                            var pointer = self.lastPointer;
                            self.x = pointer.x;
                            self.y = pointer.y;
                            self.worldX = pointer.worldX;
                            self.worldY = pointer.worldY;
                        }
                    },
                    BEGIN: {
                        enter: function () {
                            self.validDrag = false;
                        }
                    },
                    RECOGNIZED: {
                        enter: function () {
                            self.start();
                            self.updateDirectionStates();
                            self.emit('swipe', self, self.gameObject, self.lastPointer);
                        },

                        exit: function () {
                            self.stop();
                            self.clearDirectionStates();
                        }
                    }
                },
                init: function () {
                    this.state = IDLE$3;
                },
                eventEmitter: false,
            };
            this.setRecongizedStateObject(new FSM(stateConfig));
            this.clearDirectionStates();
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setDragThreshold(GetValue$2w(o, 'threshold', 10));
            this.setVelocityThreshold(GetValue$2w(o, 'velocityThreshold', 1000));
            this.setDirectionMode(GetValue$2w(o, 'dir', '8dir'));
            return this;
        }

        onDragStart() {
            this.state = BEGIN$2;
        }

        onDragEnd() {
            this.state = IDLE$3;
        }

        onDrag() {
            if (this.state === BEGIN$2) {
                if (!this.validDrag) {
                    this.validDrag = (this.dragThreshold === 0) || (this.pointer.getDistance() >= this.dragThreshold);
                }
                if (this.validDrag && (this.dragVelocity > this.velocityThreshold)) {
                    this.state = RECOGNIZED$2;
                }
            }
        }

        postUpdate(time, delta) {
            if ((!this.isRunning) || (!this.enable)) {
                return;
            }
            // Clear RECOGNIZED after update()
            if (this.state === RECOGNIZED$2) {
                this.state = IDLE$3;
            }
        }

        get isSwiped() {
            return (this.state === RECOGNIZED$2);
        }

        get dragVelocity() {
            var velocity;
            switch (this.dirMode) {
                case 0: velocity = this.getVelocityY(); break; // up & down
                case 1: velocity = this.getVelocityX(); break; // left & right
                default: velocity = this.getVelocity(); break; // 4 dir, 8 dir
            }
            return velocity;
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }

        setVelocityThreshold(velocity) {
            this.velocityThreshold = velocity;
            return this;
        }

        setDirectionMode(m) {
            if (typeof (m) === 'string') {
                m = DIRMODE$1[m];
            }
            this.dirMode = m;
            return this;
        }

        updateDirectionStates() {
            var angle = RadToDeg$5(this.getVelocityAngle());
            AngleToDirections(angle, this.dirMode, this);
            return this;
        }

        clearDirectionStates() {
            this.left = false;
            this.right = false;
            this.up = false;
            this.down = false;
            return this;
        }
    }

    Object.assign(
        Swipe.prototype,
        VelocityMethods
    );

    const IDLE$3 = 'IDLE';
    const BEGIN$2 = 'BEGIN';
    const RECOGNIZED$2 = 'RECOGNIZED';

    const GetValue$2v = Phaser.Utils.Objects.GetValue;
    const SpliceOne$2 = Phaser.Utils.Array.SpliceOne;
    const DistanceBetween$3 = Phaser.Math.Distance.Between;
    const AngleBetween = Phaser.Math.Angle.Between;

    class TwoPointersTracer {
        constructor(gameObject, config) {
            var scene = GetSceneObject(gameObject);
            if (scene === gameObject) {
                gameObject = undefined;
            }

            var amount = scene.input.manager.pointersTotal - 1;
            if (amount < 2) {
                scene.input.addPointer(2 - amount);
            }

            this.scene = scene;
            this.gameObject = gameObject;
            if (gameObject) {
                gameObject.setInteractive(GetValue$2v(config, 'inputConfig', undefined));
            }

            // Event emitter
            this.setEventEmitter(GetValue$2v(config, 'eventEmitter', undefined));

            this._enable = undefined;
            this.pointers = [];
            this.movedState = {};
            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.setEnable(GetValue$2v(o, "enable", true));
            this.bounds = GetValue$2v(o, 'bounds', undefined);

            this.tracerState = TOUCH0$1;
            this.pointers.length = 0;
            Clear$1(this.movedState);
            return this;
        }

        boot() {
            if (this.gameObject) {
                this.gameObject.on('pointerdown', this.onPointerDown, this);
            } else {
                this.scene.input.on('pointerdown', this.onPointerDown, this);
            }

            this.scene.input.on('pointerup', this.onPointerUp, this);
            this.scene.input.on('gameout', this.dragCancel, this);

            this.scene.input.on('pointermove', this.onPointerMove, this);
            this.scene.sys.events.once('shutdown', this.destroy, this);
        }

        shutdown() {
            if (!this.scene) {
                return
            }

            this.destroyEventEmitter();
            this.pointers.length = 0;
            Clear$1(this.movedState);

            if (this.gameObject) ; else {
                this.scene.input.off('pointerdown', this.onPointerDown, this);
            }

            this.scene.input.off('pointerup', this.onPointerUp, this);
            this.scene.input.off('gameout', this.dragCancel, this);

            this.scene.input.off('pointermove', this.onPointerMove, this);
            this.scene.sys.events.off('shutdown', this.destroy, this);
            this.scene = undefined;
            this.gameObject = undefined;
        }

        destroy() {
            this.shutdown();
        }

        get enable() {
            return this._enable;
        }

        set enable(e) {
            if (this._enable === e) {
                return;
            }

            if (!e) {
                this.dragCancel();
            }
            this._enable = e;
            return this;
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        onPointerDown(pointer) {
            if (!this.enable) {
                return;
            }

            if (this.pointers.length === 2) {
                return;
            }

            var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
            if (!isInsideBounds) {
                return;
            }

            var index = this.pointers.indexOf(pointer);
            if (index !== -1) { // Already in catched pointers
                return;
            }

            this.movedState[pointer.id] = false;
            this.pointers.push(pointer);
            this.pointerCamera = pointer.camera;

            switch (this.tracerState) {
                case TOUCH0$1:
                    this.tracerState = TOUCH1$1;
                    this.onDrag1Start();
                    break;
                case TOUCH1$1:
                    this.tracerState = TOUCH2;
                    this.onDrag2Start();
                    break;
            }
        }

        onPointerUp(pointer) {
            if (!this.enable) {
                return;
            }

            var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
            if (!isInsideBounds) {
                return;
            }

            var index = this.pointers.indexOf(pointer);
            if (index === -1) { // Not in catched pointers
                return;
            } else {
                delete this.movedState[pointer.id];
                SpliceOne$2(this.pointers, index);
            }

            switch (this.tracerState) {
                case TOUCH1$1:
                    this.tracerState = TOUCH0$1;
                    this.onDrag1End();
                    break;
                case TOUCH2:
                    this.tracerState = TOUCH1$1;
                    this.onDrag2End();
                    this.onDrag1Start();
                    break;
            }
        }

        onPointerMove(pointer) {
            if (!this.enable) {
                return;
            }

            if (pointer.isDown) {
                var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
                var isCatchedPointer = (this.pointers.indexOf(pointer) !== -1);
                if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) { // Pointer moves out of bounds, lose pointer
                    this.onPointerUp(pointer);
                } else {  // Pointer drags in bounds
                    if (!this.movedState[pointer.id]) {
                        this.movedState[pointer.id] = (pointer.x !== pointer.downX) || (pointer.y !== pointer.downY);
                    }
                    if (this.movedState[pointer.id]) {
                        switch (this.tracerState) {
                            case TOUCH1$1:
                                this.onDrag1();
                                break;
                            case TOUCH2:
                                this.onDrag2();
                                break;
                        }
                    }
                }
            }
        }

        dragCancel() {
            if (this.tracerState === TOUCH2) {
                this.onDrag2End();
            }
            this.pointers.length = 0;
            Clear$1(this.movedState);
            this.tracerState = TOUCH0$1;
            return this;
        }

        onDrag1Start() {
            this.emit('drag1start', this);
        }

        onDrag1End() {
            this.emit('drag1end', this);
        }

        onDrag1() {
            this.emit('drag1', this);
        }

        onDrag2Start() {
            this.emit('drag2start', this);
        }

        onDrag2End() {
            this.emit('drag2end', this);
        }

        onDrag2() {
            this.emit('drag2', this);
        }

        get distanceBetween() {
            if (this.tracerState !== TOUCH2) {
                return 0;
            }
            var p0 = this.pointers[0],
                p1 = this.pointers[1];
            return DistanceBetween$3(p0.x, p0.y, p1.x, p1.y);
        }

        get angleBetween() {
            if (this.tracerState !== TOUCH2) {
                return 0;
            }
            var p0 = this.pointers[0],
                p1 = this.pointers[1];
            return AngleBetween(p0.x, p0.y, p1.x, p1.y);
        }

        get drag1Vector() {
            var pointer = this.pointers[0];
            if (pointer && this.movedState[pointer.id]) {
                var p1 = pointer.position;
                var p0 = pointer.prevPosition;
                tmpDragVector.x = p1.x - p0.x;
                tmpDragVector.y = p1.y - p0.y;
            } else {
                tmpDragVector.x = 0;
                tmpDragVector.y = 0;
            }
            return tmpDragVector;
        }

        get centerX() {
            if (this.tracerState !== TOUCH2) {
                return 0;
            }
            var p0 = this.pointers[0].position;
            var p1 = this.pointers[1].position;
            return (p0.x + p1.x) / 2;
        }

        get centerY() {
            if (this.tracerState !== TOUCH2) {
                return 0;
            }
            var p0 = this.pointers[0].position;
            var p1 = this.pointers[1].position;
            return (p0.y + p1.y) / 2;
        }

        get prevCenterX() {
            if (this.tracerState !== TOUCH2) {
                return 0;
            }
            var preP0 = (this.movedState[this.pointers[0].id]) ? this.pointers[0].prevPosition : this.pointers[0].position;
            var preP1 = (this.movedState[this.pointers[1].id]) ? this.pointers[1].prevPosition : this.pointers[1].position;
            return (preP0.x + preP1.x) / 2;
        }

        get prevCenterY() {
            if (this.tracerState !== TOUCH2) {
                return 0;
            }
            var preP0 = (this.movedState[this.pointers[0].id]) ? this.pointers[0].prevPosition : this.pointers[0].position;
            var preP1 = (this.movedState[this.pointers[1].id]) ? this.pointers[1].prevPosition : this.pointers[1].position;
            return (preP0.y + preP1.y) / 2;
        }

        get movementCenterX() {
            return this.centerX - this.prevCenterX;
        }

        get movementCenterY() {
            return this.centerY - this.prevCenterY;
        }

        setRecongizedStateObject(stateObject) {
            this.recongizedState = stateObject;
            return this;
        }

        get state() {
            return this.recongizedState.state;
        }

        set state(newState) {
            this.recongizedState.state = newState;
        }

        cancel() {
            this.state = IDLE$2;
            return this;
        }

        isPointer0InGameObject(gameObject, preTest, postTest) {
            var pointer = this.pointers[0];
            if (!pointer) {
                return false;
            }

            return IsPointerInBounds(gameObject, pointer, preTest, postTest);
        }

        isPointer1InGameObject(gameObject, preTest, postTest) {
            var pointer = this.pointers[1];
            if (!pointer) {
                return false;
            }

            return IsPointerInBounds(gameObject, pointer, preTest, postTest);
        }
    }

    Object.assign(
        TwoPointersTracer.prototype,
        EventEmitterMethods$1
    );

    var tmpDragVector = {};

    const TOUCH0$1 = 0;
    const TOUCH1$1 = 1;
    const TOUCH2 = 2;

    const IDLE$2 = 'IDLE';

    const GetValue$2u = Phaser.Utils.Objects.GetValue;

    class Pinch extends TwoPointersTracer {
        constructor(gameObject, config) {
            super(gameObject, config);

            var self = this;
            var stateConfig = {
                states: {
                    IDLE: {
                        enter: function () {
                            self.prevDistance = undefined;
                            self.scaleFactor = 1;
                        },
                    },
                    BEGIN: {
                    },
                    RECOGNIZED: {
                        enter: function () {
                            self.emit('pinchstart', self);
                        },
                        exit: function () {
                            self.emit('pinchend', self);
                        }
                    }
                },
                init: function () {
                    this.state = IDLE$1;
                },
                eventEmitter: false,
            };
            this.setRecongizedStateObject(new FSM(stateConfig));
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setDragThreshold(GetValue$2u(o, 'threshold', 0));
            return this;
        }

        onDrag2Start() {
            this.scaleFactor = 1;
            this.prevDistance = this.distanceBetween;
            this.state = BEGIN$1;
            if (this.dragThreshold === 0) {
                this.state = RECOGNIZED$1;
            }
        }

        onDrag2End() {
            this.state = IDLE$1;
        }

        onDrag2() {
            switch (this.state) {
                case BEGIN$1:
                    if ((this.pointers[0].getDistance() >= this.dragThreshold) &&
                        (this.pointers[1].getDistance() >= this.dragThreshold)) {
                        var curDistance = this.distanceBetween;
                        this.scaleFactor = curDistance / this.prevDistance;
                        this.prevDistance = curDistance;
                        this.state = RECOGNIZED$1;
                    }
                    break;
                case RECOGNIZED$1:
                    var curDistance = this.distanceBetween;
                    this.scaleFactor = curDistance / this.prevDistance;
                    this.emit('pinch', this);
                    this.prevDistance = curDistance;
                    break;
            }
        }

        get isPinched() {
            return (this.state === RECOGNIZED$1);
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }
    }

    const IDLE$1 = 'IDLE';
    const BEGIN$1 = 'BEGIN';
    const RECOGNIZED$1 = 'RECOGNIZED';

    const RotateAround$3 = Phaser.Math.RotateAround;

    var RotateObjectAround = function (gameObject, x, y, angle) {
        RotateAround$3(gameObject, x, y, angle);
        gameObject.rotation += angle;
        return gameObject;
    };

    var ScreenXYToWorldXY = function (screenX, screenY, camera, out) {
        if (out === undefined) {
            out = {};
        } else if (out === true) {
            out = globalOut;
        }

        camera.getWorldPoint(screenX, screenY, out);
        return out;
    };

    var globalOut = {};

    var SpinObject = function (gameObject, camera) {
        if (!this.isRotation) {
            return this;
        }

        if (camera === undefined) {
            camera = this.pointers[0].camera;
        }

        var movementX = this.movementCenterX,
            movementY = this.movementCenterY;

        var worldXY = ScreenXYToWorldXY(this.centerX, this.centerY, camera, true);
        var centerWorldX = worldXY.x;
        var centerWorldY = worldXY.y;

        var angle = this.rotation;
        if (Array.isArray(gameObject)) {
            var gameObjects = gameObject;
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                gameObject = gameObjects[i];
                gameObject.x += movementX;
                gameObject.y += movementY;
                RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
            }
        } else {
            gameObject.x += movementX;
            gameObject.y += movementY;
            RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
        }
        return this;
    };

    const GetValue$2t = Phaser.Utils.Objects.GetValue;
    const WrapDegrees$1 = Phaser.Math.Angle.WrapDegrees; // Wrap degrees: -180 to 180 
    const ShortestBetween$1 = Phaser.Math.Angle.ShortestBetween;
    const RadToDeg$4 = Phaser.Math.RadToDeg;
    const DegToRad$6 = Phaser.Math.DegToRad;

    class Rotate extends TwoPointersTracer {
        constructor(gameObject, config) {
            super(gameObject, config);

            var self = this;
            var stateConfig = {
                states: {
                    IDLE: {
                        enter: function () {
                            self.prevAngle = undefined;
                            self.angle = 0;
                        },
                    },
                    BEGIN: {
                    },
                    RECOGNIZED: {
                        enter: function () {
                            self.emit('rotatestart', self);
                        },
                        exit: function () {
                            self.emit('rotateend', self);
                        }
                    }
                },
                init: function () {
                    this.state = IDLE;
                },
                eventEmitter: false,
            };
            this.setRecongizedStateObject(new FSM(stateConfig));
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setDragThreshold(GetValue$2t(o, 'threshold', 0));
            return this;
        }

        onDrag2Start() {
            this.prevAngle = WrapDegrees$1(RadToDeg$4(this.angleBetween)); // Degrees
            this.state = BEGIN;
            if (this.dragThreshold === 0) {
                this.state = RECOGNIZED;
            }
        }

        onDrag2End() {
            this.state = IDLE;
        }

        onDrag2() {
            switch (this.state) {
                case BEGIN:
                    if ((this.pointers[0].getDistance() >= this.dragThreshold) &&
                        (this.pointers[1].getDistance() >= this.dragThreshold)) {
                        var curAngle = WrapDegrees$1(RadToDeg$4(this.angleBetween));
                        this.angle = ShortestBetween$1(this.prevAngle, curAngle);
                        this.prevAngle = curAngle;
                        this.state = RECOGNIZED;
                    }
                    break;
                case RECOGNIZED:
                    var curAngle = WrapDegrees$1(RadToDeg$4(this.angleBetween));
                    this.angle = ShortestBetween$1(this.prevAngle, curAngle);
                    this.prevAngle = curAngle;
                    this.emit('rotate', this);
                    break;
            }
        }

        get isRotated() {
            return (this.state === RECOGNIZED);
        }

        get rotation() {
            return DegToRad$6(this.angle);
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }

    }

    var methods$v = {
        spinObject: SpinObject,
    };
    Object.assign(
        Rotate.prototype,
        methods$v
    );


    const IDLE = 'IDLE';
    const BEGIN = 'BEGIN';
    const RECOGNIZED = 'RECOGNIZED';

    const GetValue$2s = Phaser.Utils.Objects.GetValue;

    var TapChild = function (config) {
        var tapConfig = GetValue$2s(config, 'tap', undefined);
        if (tapConfig === false) {
            return;
        } else if (tapConfig === true) {
            tapConfig = undefined;
        }

        var childrenInteractive = this._childrenInteractive;
        this._tap = new Tap(this, tapConfig);
        this._tap
            .on('tap', function (tap, gameObject, lastPointer) {
                EmitChildEvent(
                    childrenInteractive.eventEmitter,
                    `${childrenInteractive.eventNamePrefix}${tap.tapsCount}tap`,
                    childrenInteractive.targetSizers,
                    childrenInteractive.targetMode,
                    tap.worldX, tap.worldY,
                    lastPointer, tap
                );

                EmitChildEvent(
                    childrenInteractive.eventEmitter,
                    `${childrenInteractive.eventNamePrefix}tap`,
                    childrenInteractive.targetSizers,
                    childrenInteractive.targetMode,
                    tap.worldX, tap.worldY,
                    lastPointer, tap
                );
            }, this);
    };

    const GetValue$2r = Phaser.Utils.Objects.GetValue;

    var PressChild = function (config) {
        var pressConfig = GetValue$2r(config, 'press', undefined);
        if (pressConfig === false) {
            return;
        } else if (pressConfig === true) {
            pressConfig = undefined;
        }

        var childrenInteractive = this._childrenInteractive;
        this._press = new Press(this, pressConfig);
        this._press
            .on('pressstart', function (press, gameObject, lastPointer) {
                EmitChildEvent(
                    childrenInteractive.eventEmitter,
                    `${childrenInteractive.eventNamePrefix}pressstart`,
                    childrenInteractive.targetSizers,
                    childrenInteractive.targetMode,
                    press.worldX, press.worldY,
                    lastPointer, press
                );
            }, this)
            .on('pressend', function (press, gameObject, lastPointer) {
                EmitChildEvent(
                    childrenInteractive.eventEmitter,
                    `${childrenInteractive.eventNamePrefix}pressend`,
                    childrenInteractive.targetSizers,
                    childrenInteractive.targetMode,
                    press.worldX, press.worldY,
                    lastPointer, press
                );
            }, this);
    };

    const GetValue$2q = Phaser.Utils.Objects.GetValue;

    var SwipeChild = function (config) {
        var swipeConfig = GetValue$2q(config, 'swipe', undefined);
        if (swipeConfig === false) {
            return;
        } else if (swipeConfig === true) {
            swipeConfig = undefined;
        }

        if (swipeConfig === undefined) {
            swipeConfig = {};
        }
        if (!swipeConfig.hasOwnProperty('dir')) {
            swipeConfig.dir = '4dir';
        }

        var childrenInteractive = this._childrenInteractive;
        this._swipe = new Swipe(this, swipeConfig);
        this._swipe
            .on('swipe', function (swipe, gameObject, lastPointer) {
                var dirName =
                    (swipe.left) ? 'left' :
                        (swipe.right) ? 'right' :
                            (swipe.up) ? 'up' :
                                'down';
                EmitChildEvent(
                    childrenInteractive.eventEmitter,
                    `${childrenInteractive.eventNamePrefix}swipe${dirName}`,
                    childrenInteractive.targetSizers,
                    childrenInteractive.targetMode,
                    swipe.worldX, swipe.worldY,
                    lastPointer, swipe
                );

                EmitChildEvent(
                    childrenInteractive.eventEmitter,
                    `${childrenInteractive.eventNamePrefix}swipe`,
                    childrenInteractive.targetSizers,
                    childrenInteractive.targetMode,
                    swipe.worldX, swipe.worldY,
                    lastPointer, swipe
                );
            }, this);
    };

    const GetValue$2p = Phaser.Utils.Objects.GetValue;

    var SetChildrenInteractive$1 = function (gameObject, config) {
        gameObject.setInteractive();

        if (GetValue$2p(config, 'dropZone', false)) {
            gameObject.input.dropZone = true;
        }

        gameObject._childrenInteractive = {
            targetSizers: GetValue$2p(config, 'targets', [gameObject]),
            targetMode: GetValue$2p(config, 'targetMode', 'parent'),
            eventEmitter: GetValue$2p(config, 'eventEmitter', gameObject),
            eventNamePrefix: GetValue$2p(config, 'inputEventPrefix', 'child.')
        };

        DownChild.call(gameObject, config);
        UpChild.call(gameObject, config);
        OverChild.call(gameObject, config);
        ClickChild.call(gameObject, config);
        TapChild.call(gameObject, config);
        PressChild.call(gameObject, config);
        SwipeChild.call(gameObject, config);

        return gameObject;
    };

    var SetChildrenInteractiveWrap = function (config) {    
        SetChildrenInteractive$1(this, config);
        return this;
    };

    var BroadcastEvent = function () {
        var gameObjects = this.getAllChildren([this]);
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            var gameObject = gameObjects[i];
            gameObject.emit.apply(gameObject, arguments);
        }
        return this;
    };

    var methods$u = {
        getSizerConfig: GetSizerConfig,
        getChildPrevState: GetChildPrevState,
        pushIntoBounds: PushIntoBounds,
        drawBounds: DrawBounds,
        resolveWidth: ResolveWidth$3,
        hasWidthWrap: HasWidthWrap$2,
        resolveChildrenWidth: ResolveChildrenWidth$1,
        runWidthWrap: RunWidthWrap$3,
        resolveHeight: ResolveHeight$3,
        hasHeightWrap: HasHeightWrap$2,
        resolveChildrenHeight: ResolveChildrenHeight$1,
        runHeightWrap: RunHeightWrap$3,
        getChildWidth: GetChildWidth,
        getChildHeight: GetChildHeight,
        getExpandedChildWidth: GetExpandedChildWidth$4,
        getExpandedChildHeight: GetExpandedChildHeight$4,

        getChildrenWidth: GetChildrenWidth$5,
        getChildrenHeight: GetChildrenHeight$5,
        addChildrenMap: AddChildrenMap,
        addElement: AddChildrenMap,
        removeChildrenMap: RemoveChildrenMap,
        getElement: GetElement,
        getChildIndex: GetChildIndex,
        getAllChildrenSizers: GetAllChildrenSizers,
        getChildrenSizers: GetChildrenSizers$5,
        preLayout: PreLayout$4,
        layout: Layout,
        runLayout: RunLayout$1,
        layoutChildren: LayoutChildren$6,

        layoutBackgrounds: LayoutBackgrounds,
        postLayout: PostLayout,

        setAnchor: SetAnchor,
        isInTouching: IsInTouching,
        pointToChild: PointToChild$2,
        setDraggable: SetDraggable,
        setChildrenInteractive: SetChildrenInteractiveWrap,
        broadcastEvent: BroadcastEvent,

    };

    Object.assign(
        methods$u,
        PaddingMethods,
        AddChildMethods$8,
        RemoveChildMethods$7,
        GetParentSizerMethods,
        methods$z,
        methods$y,
        methods$x,
        ShakeMethods,
        EaseDataMethods,
        DelayCallMethods$2,
        ClickMethods,
        ClickOutsideMethods,
        TouchingMethods,
        HoverMethods,
        HideMethods,
        ModalMethods$1,
        GetShownChildrenMethods,
        BindEventMethods,
    );

    const GetValue$2o = Phaser.Utils.Objects.GetValue;

    let Base$1 = class Base extends ContainerLite {
        constructor(scene, x, y, minWidth, minHeight, config) {
            super(scene, x, y, 1, 1);
            this.isRexSizer = true;

            var origin = GetValue$2o(config, 'origin', 0.5);
            var originX = GetValue$2o(config, 'originX', origin);
            var originY = GetValue$2o(config, 'originY', origin);
            this.setOrigin(originX, originY);

            this.setMinSize(minWidth, minHeight);
            this.setName(GetValue$2o(config, 'name', ''));
            this.rexSizer = {};
            this.space = {};
            this.backgroundChildren = undefined;
            this.sizerChildren = undefined; // [] or {}
            this.childrenMap = {};
            this.layoutedChildren = undefined;

            // FixWidthSizer uses these flag
            this.runChildrenWrapFlag = false;

            this.enableLayoutWarn(false);

            var anchorConfig = GetValue$2o(config, 'anchor', undefined);
            if (anchorConfig) {
                this.setAnchor(anchorConfig);
            }

            this.setInnerPadding(GetValue$2o(config, 'space', 0));

            var draggable = GetValue$2o(config, 'draggable', false);
            if (draggable) {
                this.setDraggable(draggable);
            }

            this.setSizerEventsEnable(GetValue$2o(config, 'sizerEvents', false));
            this.setDirty(true);

            if (GetValue$2o(config, 'enableLayer', false)) {
                this.enableLayer();
            }
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            if (fromScene) {
                // In this case, children will be cleared and destroy in scene level
                var sizers = this.getAllChildrenSizers([this]);
                for (var i = 0, cnt = sizers.length; i < cnt; i++) {
                    sizers[i].sizerEventsEnable = false;
                }
            }

            super.destroy(fromScene);

            Clear$1(this.backgroundChildren);
            Clear$1(this.sizerChildren);
            this.childrenMap = undefined;
            this.space = undefined;
            this.rexSizer = undefined;
            this.layoutedChildren = undefined;
        }

        setMinSize(minWidth, minHeight) {
            this.setMinWidth(minWidth).setMinHeight(minHeight);
            return this;
        }

        setMinWidth(minWidth) {
            if (minWidth == null) {
                minWidth = 0;
            }
            this.minWidth = minWidth;
            return this;
        }

        setMinHeight(minHeight) {
            if (minHeight == null) {
                minHeight = 0;
            }
            this.minHeight = minHeight;
            return this;
        }

        setDirty(dirty) {
            if (dirty === undefined) {
                dirty = true;
            }
            this.dirty = dirty;
            return this;
        }

        setSizerEventsEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            this.sizerEventsEnable = enable;
            return this;
        }

        enableLayoutWarn(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.layoutWarnEnable = enable;
            return this;
        }

        get ignoreLayout() {
            // Skip hidden or !dirty sizer
            return this.rexSizer.hidden || (!this.dirty);
        }

        get childrenWidth() {
            if (this._childrenWidth === undefined) {
                this._childrenWidth = this.getChildrenWidth();
            }
            return this._childrenWidth;
        }

        get childrenHeight() {
            if (this._childrenHeight === undefined) {
                this._childrenHeight = this.getChildrenHeight();
            }
            return this._childrenHeight;
        }

        get left() {
            return this.x - (GetDisplayWidth(this) * this.originX);
        }

        set left(value) {
            this.x += (value - this.left);
        }

        alignLeft(value) {
            this.left = value;
            return this;
        }

        get right() {
            return this.left + GetDisplayWidth(this);
        }

        set right(value) {
            this.x += (value - this.right);
        }

        alignRight(value) {
            this.right = value;
            return this;
        }

        get centerX() {
            return this.left + (GetDisplayWidth(this) / 2);
        }

        set centerX(value) {
            this.x += (value - this.centerX);
        }

        alignCenterX(value) {
            this.centerX = value;
            return this;
        }

        get top() {
            return this.y - (GetDisplayHeight(this) * this.originY);
        }

        set top(value) {
            this.y += (value - this.top);
        }

        alignTop(value) {
            this.top = value;
            return this;
        }

        get bottom() {
            return this.top + GetDisplayHeight(this);
        }

        set bottom(value) {
            this.y += (value - this.bottom);
        }

        alignBottom(value) {
            this.bottom = value;
            return this;
        }

        get centerY() {
            return this.top + (GetDisplayHeight(this) / 2);
        }

        set centerY(value) {
            this.y += (value - this.centerY);
        }

        alignCenterY(value) {
            this.centerY = value;
            return this;
        }

        get innerLeft() {
            return this.left + (this.space.left * this.scaleX);
        }

        get innerRight() {
            return this.right - (this.space.right * this.scaleX);
        }

        get innerTop() {
            return this.top + (this.space.top * this.scaleY);
        }

        get innerBottom() {
            return this.bottom - (this.space.bottom * this.scaleY);
        }

        get innerWidth() {
            return (this.width - this.space.left - this.space.right) * this.scaleX;
        }

        get innerHeight() {
            return (this.height - this.space.top - this.space.bottom) * this.scaleY;
        }

        get minInnerWidth() {
            var result = (this.minWidth - this.space.left - this.space.right) * this.scaleX;
            return Math.max(result, 0);
        }

        get minInnerHeight() {
            var result = (this.minHeight - this.space.top - this.space.bottom) * this.scaleY;
            return Math.max(result, 0);
        }
    };

    Object.assign(
        Base$1.prototype,
        methods$u
    );

    var GetChildrenWidth$4 = function () {
        if (this.rexSizer.hidden) {
            return 0;
        }

        var result = 0;
        var children = this.sizerChildren;
        var child, padding, childWidth;
        var hasUnknownChildWidth = false;

        for (var key in children) {
            child = children[key];

            childWidth = this.getChildWidth(child);
            if (childWidth === undefined) {
                hasUnknownChildWidth = true;
            }

            if (hasUnknownChildWidth) {
                continue;
            }

            padding = child.rexSizer.padding;
            childWidth += (padding.left + padding.right) * this.scaleX;
            result = Math.max(childWidth, result);
        }

        if (hasUnknownChildWidth) {
            return undefined;
        }

        return result + ((this.space.left + this.space.right) * this.scaleX);
    };

    var GetChildrenHeight$4 = function () {
        if (this.rexSizer.hidden) {
            return 0;
        }

        var result = 0;
        var children = this.sizerChildren;
        var child, padding, childHeight;
        var hasUnknownChildHeight = false;

        for (var key in children) {
            child = children[key];

            childHeight = this.getChildHeight(child);
            if (childHeight === undefined) {
                hasUnknownChildHeight = true;
            }

            if (hasUnknownChildHeight) {
                continue;
            }

            padding = child.rexSizer.padding;
            childHeight += (padding.top + padding.bottom) * this.scaleY;
            result = Math.max(childHeight, result);
        }

        if (hasUnknownChildHeight) {
            return undefined;
        }

        return result + ((this.space.top + this.space.bottom) * this.scaleY);
    };

    var GetExpandedChildWidth$3 = function (child, parentWidth) {
        if (parentWidth === undefined) {
            parentWidth = this.width * this.scaleX;
        }

        var childWidth;
        var childConfig = child.rexSizer;
        if (childConfig.expandWidth) {
            var innerWidth = parentWidth - ((this.space.left + this.space.right) * this.scaleX);
            var padding = childConfig.padding;
            childWidth = innerWidth - ((padding.left + padding.right) * this.scaleX);
        }
        return childWidth;
    };

    var GetExpandedChildHeight$3 = function (child, parentHeight) {
        if (parentHeight === undefined) {
            parentHeight = this.height;
        }

        var childHeight;
        var childConfig = child.rexSizer;
        if (childConfig.expandHeight) {
            var innerHeight = parentHeight - ((this.space.top + this.space.bottom) * this.scaleY);
            var padding = childConfig.padding;
            childHeight = innerHeight - ((padding.top + padding.bottom) * this.scaleY);
        }
        return childHeight;
    };

    var GetChildrenSizers$4 = function (out) {
        if (out === undefined) {
            out = [];
        }
        var children = this.sizerChildren,
            child;
        for (var key in children) {
            child = children[key];
            if (child.isRexSizer) {
                out.push(child);
            }
        }
        return out;
    };

    var FitTo = function (source, target, fitMode, out) {
        if (fitMode === undefined) {
            fitMode = 0;
        } else {
            var fitModeType = typeof (fitMode);
            if (fitModeType === 'boolean') {
                out = fitMode;
                fitMode = 0;
            } else if (fitModeType === 'string') {
                fitMode = FitModeMap[fitMode];
            }
        }

        if (out === undefined) {
            out = {};
        } else if (out === true) {
            out = globalSize;
        }

        var scaleX = target.width / source.width;
        var scaleY = target.height / source.height;
        var scale = (!fitMode) ? Math.min(scaleX, scaleY) : Math.max(scaleX, scaleY);
        out.width = source.width * scale;
        out.height = source.height * scale;

        return out;
    };

    const FitModeMap = {
        'fit': 0,
        'FIT': 0,
        'envelop': 1,
        'ENVELOP': 1
    };

    var globalSize = {};

    var CheckSize = function (child, parent) {
        if (child.layoutWarnEnable) {
            if (child.width < child.childrenWidth) {
                // Warning
                console.warn(`Layout width error: Parent=${parent.constructor.name}, Child=${child.constructor.name}`);
            }
            if (child.height < child.childrenHeight) {
                // Warning
                console.warn(`Layout height error: Parent=${parent.constructor.name}, Child=${child.constructor.name}`);
            }
        }
    };

    var LayoutChildren$5 = function () {
        var child, childConfig, padding;
        var startX = this.innerLeft,
            startY = this.innerTop;
        var innerWidth = this.innerWidth,
            innerHeight = this.innerHeight;
        var x, y, width, height, alignOffsetX, alignOffsetY; // Align zone
        var childWidth, childHeight, childSize;
        // Layout current page
        var children = this.sizerChildren;
        for (var key in children) {
            child = children[key];
            if (child.rexSizer.hidden) {
                continue;
            }

            childConfig = child.rexSizer;
            padding = childConfig.padding;

            PreLayoutChild.call(this, child);

            childWidth = this.getExpandedChildWidth(child);
            childHeight = this.getExpandedChildHeight(child);

            if (childConfig.aspectRatio > 0) {
                sourceSize.width = childConfig.aspectRatio;
                sourceSize.height = 1;
                targetSize.width = childWidth;
                targetSize.height = childHeight;

                childSize = FitTo(sourceSize, targetSize, 'FIT', true);

                childWidth = childSize.width;
                childHeight = childSize.height;
            }

            // Set size
            if (child.isRexSizer) {
                child.runLayout(this, childWidth, childHeight);
                CheckSize(child, this);
            } else {
                ResizeGameObject(child, childWidth, childHeight);
            }

            // Set position
            x = startX + (padding.left * this.scaleX);
            width = innerWidth - ((padding.left + padding.right) * this.scaleX);
            y = startY + (padding.top * this.scaleY);
            height = innerHeight - ((padding.top + padding.bottom) * this.scaleY);

            if (childWidth === undefined) {
                childWidth = GetDisplayWidth(child);
            }
            if (childHeight === undefined) {
                childHeight = GetDisplayHeight(child);
            }
            alignOffsetX = (childConfig.alignOffsetX + (childConfig.alignOffsetOriginX * childWidth)) * this.scaleX;
            alignOffsetY = (childConfig.alignOffsetY + (childConfig.alignOffsetOriginY * childHeight)) * this.scaleY;

            LayoutChild.call(this,
                child, x, y, width, height, childConfig.align,
                alignOffsetX, alignOffsetY
            );
        }
    };

    var sourceSize = {};
    var targetSize = {};

    const IsPlainObject$v = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$2n = Phaser.Utils.Objects.GetValue;
    const ALIGN_CENTER$3 = Phaser.Display.Align.CENTER;
    const UUID$3 = Phaser.Utils.String.UUID;

    var Add$7 = function (gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY, aspectRatio) {
        var offsetOriginX, offsetOriginY;

        AddChild$1.call(this, gameObject);

        if (IsPlainObject$v(childKey)) {
            var config = childKey;
            childKey = GetValue$2n(config, 'key', undefined);
            align = GetValue$2n(config, 'align', ALIGN_CENTER$3);
            padding = GetValue$2n(config, 'padding', 0);
            expand = GetValue$2n(config, 'expand', true);

            if (!gameObject.isRexSizer) {
                // Get minWidth,minHeight from config
                minWidth = GetValue$2n(config, 'minWidth', gameObject._minWidth);
                minHeight = GetValue$2n(config, 'minHeight', gameObject._minHeighted);
            }

            offsetX = GetValue$2n(config, 'offsetX', 0);
            offsetY = GetValue$2n(config, 'offsetY', 0);
            offsetOriginX = GetValue$2n(config, 'offsetOriginX', 0);
            offsetOriginY = GetValue$2n(config, 'offsetOriginY', 0);

            aspectRatio = GetValue$2n(config, 'aspectRatio', 0);
        }

        var hasValidKey = (childKey !== undefined);
        if (!hasValidKey) {
            childKey = UUID$3();
        }

        if (typeof (align) === 'string') {
            align = AlignConst[align];
        }

        if (align === undefined) {
            align = ALIGN_CENTER$3;
        }
        if (padding === undefined) {
            padding = 0;
        }
        if (expand === undefined) {
            expand = true;
        }
        if (!gameObject.isRexSizer) {
            // Get minWidth,minHeight from game object
            if (minWidth === undefined) {
                minWidth = gameObject._minWidth;
            }
            if (minHeight === undefined) {
                minHeight = gameObject._minHeight;
            }
        }

        if (offsetX === undefined) {
            offsetX = 0;
        }
        if (offsetY === undefined) {
            offsetY = 0;
        }
        if (offsetOriginX === undefined) {
            offsetOriginX = 0;
        }
        if (offsetOriginY === undefined) {
            offsetOriginY = 0;
        }

        if (aspectRatio === undefined) {
            aspectRatio = 0;
        } else if (aspectRatio === true) {
            aspectRatio = GetDisplayWidth(gameObject) / GetDisplayHeight(gameObject);
        }
        if (aspectRatio > 0) {
            expand = true;

            if (minWidth === undefined) {
                minWidth = 0;
            }
            if (minHeight === undefined) {
                minHeight = 0;
            }
        }

        var config = this.getSizerConfig(gameObject);

        config.align = align;

        config.padding = GetBoundsConfig$1(padding);

        if (IsPlainObject$v(expand)) {
            config.expandWidth = GetValue$2n(expand, 'width', false);
            config.expandHeight = GetValue$2n(expand, 'height', false);
        } else {
            config.expandWidth = expand;
            config.expandHeight = expand;
        }

        if (!gameObject.isRexSizer) {  // Expand normal game object
            if (config.expandWidth) {
                // minWidth is still undefined, uses current display width
                gameObject.minWidth = (minWidth === undefined) ? GetDisplayWidth(gameObject) : minWidth;
            }
            if (config.expandHeight) {
                // minHeight is still undefined, uses current display height
                gameObject.minHeight = (minHeight === undefined) ? GetDisplayHeight(gameObject) : minHeight;
            }
        }

        config.alignOffsetX = offsetX;
        config.alignOffsetY = offsetY;
        config.alignOffsetOriginX = offsetOriginX;
        config.alignOffsetOriginY = offsetOriginY;

        config.aspectRatio = aspectRatio;

        if (this.sizerChildren.hasOwnProperty(childKey)) {
            this.sizerChildren[childKey].destroy();
        }
        this.sizerChildren[childKey] = gameObject;

        if (hasValidKey) {
            this.addChildrenMap(childKey, gameObject);
        }
        return this;
    };

    var AddChildMethods$7 = {
        add: Add$7
    };

    const ContainerClear = ContainerLite.prototype.clear;

    var ClearChildren = function (destroyChild) {
        if (this.backgroundChildren) {
            this.backgroundChildren.length = 0;
        }

        var fireRemoveEvent = !destroyChild && this.sizerEventsEnable;
        var children;
        if (fireRemoveEvent) {
            children = this.getChildren([]);
        }

        ContainerClear.call(this, destroyChild);

        if (fireRemoveEvent) {
            var gameObject;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                gameObject = children[i];
                gameObject.emit('sizer.remove', gameObject, this);
                this.emit('remove', gameObject, this);
            }
        }
        return this;
    };

    var RemoveChildMethods$6 = {
        remove(gameObject, destroyChild) {
            var key;
            if (typeof (gameObject) === 'string') {
                key = gameObject;
                gameObject = this.sizerChildren[key];
                if (!gameObject) {
                    return this;
                }
            } else if (this.getParentSizer(gameObject) !== this) {
                return this;
            } else {
                key = this.childToKey(gameObject);
            }

            if (key) {
                delete this.sizerChildren[key];
                if (this.childrenMap.hasOwnProperty(key)) {
                    delete this.childrenMap[key];
                }
            }
            RemoveChild.call(this, gameObject, destroyChild);
            return this;
        },

        removeAll(destroyChild) {
            for (var key in this.sizerChildren) {
                this.remove(key, destroyChild);
            }
            return this;
        },

        clear(destroyChild) {
            for (var key in this.sizerChildren) {
                delete this.sizerChildren[key];
                if (this.childrenMap.hasOwnProperty(key)) {
                    delete this.childrenMap[key];
                }
            }
            ClearChildren.call(this, destroyChild);
            return this;
        }
    };

    var methods$t = {
        getChildrenWidth: GetChildrenWidth$4,
        getChildrenHeight: GetChildrenHeight$4,
        getExpandedChildWidth: GetExpandedChildWidth$3,
        getExpandedChildHeight: GetExpandedChildHeight$3,
        getChildrenSizers: GetChildrenSizers$4,
        layoutChildren: LayoutChildren$5,
    };

    Object.assign(
        methods$t,
        AddChildMethods$7,
        RemoveChildMethods$6
    );

    var IndexOf = function (obj, child) {
        if (Array.isArray(obj)) {
            return obj.indexOf(child);
        } else {
            for (var key in obj) {
                if (obj[key] === child) {
                    return key;
                }
            }
            return null;
        }
    };

    const IsPlainObject$u = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$2m = Phaser.Utils.Objects.GetValue;

    class OverlapSizer extends Base$1 {
        constructor(scene, x, y, minWidth, minHeight, config) {
            if (IsPlainObject$u(x)) {
                config = x;
                x = GetValue$2m(config, 'x', 0);
                y = GetValue$2m(config, 'y', 0);
                minWidth = GetValue$2m(config, 'width', undefined);
                minHeight = GetValue$2m(config, 'height', undefined);
            } else if (IsPlainObject$u(minWidth)) {
                config = minWidth;
                minWidth = GetValue$2m(config, 'width', undefined);
                minHeight = GetValue$2m(config, 'height', undefined);
            }

            super(scene, x, y, minWidth, minHeight, config);

            this.type = 'rexOverlapSizer';
            this.sizerChildren = {};

            this.addChildrenMap('items', this.sizerChildren);
        }

        childToKey(gameObject) {
            if (typeof (gameObject) === 'string') {
                var key = gameObject;
                if (this.sizerChildren.hasOwnPropery(key)) {
                    return key;
                }
            } else {
                return IndexOf(this.sizerChildren, gameObject);
            }
            return null;
        }
    }

    Object.assign(
        OverlapSizer.prototype,
        methods$t
    );

    var GetDistance = Phaser.Math.Distance.Between;

    var IsLocalPointInKnob = function (knob, localX, localY) {
        var centerX = knob.width / 2;
        return GetDistance(centerX, centerX, localX, localY) <= centerX;
    };

    const GetAngle$1 = Phaser.Math.Angle.Between;
    const NormalizeAngle = Phaser.Math.Angle.Normalize;

    var OnTouchPad = function (pointer, localX, localY) {
        if (!this.enable) {
            return;
        }
        if (!pointer.isDown) {
            return;
        }
        var knob = this.sizerChildren.knob;
        if (!IsLocalPointInKnob(knob, localX, localY)) {
            return;
        }

        var centerX = knob.width / 2;
        var startAngle = knob.startAngle;
        var endAngle = GetAngle$1(centerX, centerX, localX, localY);
        var deltaAngle = (knob.anticlockwise) ? (startAngle - endAngle) : (endAngle - startAngle);
        var value = NormalizeAngle(deltaAngle) / (2 * Math.PI);

        this.stopEaseValue();
        if ((this.easeValueDuration === 0) || (Math.abs(this.value - value) < 0.1)) {
            this.value = value;
        } else {
            this.easeValueTo(value);
        }
    };

    var InstallEvents$1 = function () {
        var knob = this.sizerChildren.knob;
        knob
            .on('pointerdown', OnTouchPad, this)
            .on('pointermove', OnTouchPad, this)
            .setInteractive();
    };

    const GetAngle = Phaser.Math.Angle.Between;
    const WrapAngle = Phaser.Math.Angle.Wrap;

    var OnPointerDown = function (pointer, localX, localY) {
        if ((!this.enable) || (this.panPointer)) {
            return;
        }
        var knob = this.sizerChildren.knob;
        if (!IsLocalPointInKnob(knob, localX, localY)) {
            return;
        }

        OnPanStart.call(this, pointer);
    };

    var OnPointerMove = function (pointer, localX, localY) {
        if (!this.enable) {
            return;
        }
        if (!pointer.isDown) {
            return;
        }

        var knob = this.sizerChildren.knob;
        switch (this.panState) {
            case TOUCH0:
                if (IsLocalPointInKnob(knob, localX, localY)) {
                    OnPanStart.call(this, pointer);
                }
                break;

            case TOUCH1:
                if (IsLocalPointInKnob(knob, localX, localY)) {
                    OnPan.call(this);
                } else {
                    OnPanEnd.call(this);
                }
                break;
        }
    };

    var OnPointerUp = function (pointer, localX, localY) {
        if ((!this.enable) || (this.panPointer !== pointer)) {
            return;
        }

        OnPanEnd.call(this);
    };

    var OnPanStart = function (pointer) {
        this.panPointer = pointer;
        this.panState = TOUCH1;
    };

    var OnPanEnd = function () {
        this.panPointer = undefined;
        this.panState = TOUCH0;
    };

    var OnPan = function () {
        var p0 = this.panPointer.prevPosition,
            p1 = this.panPointer.position;
        var knob = this.sizerChildren.knob;
        var startAngle = GetAngle(knob.x, knob.y, p0.x, p0.y),
            endAngle = GetAngle(knob.x, knob.y, p1.x, p1.y);
        var deltaAngle = (knob.anticlockwise) ? (startAngle - endAngle) : (endAngle - startAngle);
        var deltaValue = WrapAngle(deltaAngle) / (Math.PI * 2);

        this.stopEaseValue();
        this.value += deltaValue;
    };

    const TOUCH0 = 0;
    const TOUCH1 = 1;

    var InstallEvents = function () {
        var knob = this.sizerChildren.knob;
        knob
            .on('pointerdown', OnPointerDown, this)
            .on('pointermove', OnPointerMove, this)
            .on('pointerup', OnPointerUp, this)
            .setInteractive();

        this.panPointer = undefined;
        this.panState = TOUCH0;
    };

    var SetTextFormatCallback = function (callback, scope) {
        this.textFormatCallback = callback;
        this.textFormatCallbackScope = scope;
        return this;
    };

    var GetFormatText = function (value) {
        if (value === undefined) {
            value = this.value;
        }

        var text;
        if (this.textFormatCallbackScope) {
            text = this.textFormatCallback(value);
        } else {
            text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
        }
        return text;
    };

    var UpdateText = function (value) {
        var textObject = this.sizerChildren.text;
        if (textObject && this.textFormatCallback) {
            textObject.setText(GetFormatText.call(this, value));
            if (textObject.layout) {
                textObject.layout();
            }
        }
        return this;
    };

    var TextObjectMethods = {
        setTextFormatCallback: SetTextFormatCallback,
        getFormatText: GetFormatText,
        updateText: UpdateText
    };

    const GetValue$2l = Phaser.Utils.Objects.GetValue;
    const SnapTo$3 = Phaser.Math.Snap.To;

    class Knob extends ProgressBase(OverlapSizer) {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            // Create sizer
            super(scene, config);
            this.type = 'rexKnob';

            this.bootProgressBase(config);

            // Add elements
            var background = GetValue$2l(config, 'background', undefined);
            var textObject = GetValue$2l(config, 'text', undefined);

            if (background) {
                this.addBackground(background);
            }
            // Get text object
            if (textObject) {
                // Don't draw text on knob directly
                config.textColor = undefined;
                config.textStrokeColor = undefined;
                this.setTextFormatCallback(
                    GetValue$2l(config, 'textFormatCallback', undefined),
                    GetValue$2l(config, 'textFormatCallbackScope', undefined)
                );
                config.textFormatCallback = undefined;
                config.textFormatCallbackScope = undefined;
            }
            // Create circular progress object
            var knob = new CircularProgress(scene, config);
            knob.setDepth(GetValue$2l(config, 'knobDepth', 0));
            knob._value = -1; // To trigger text updating
            scene.add.existing(knob);

            this.add(knob, 'knob');
            if (textObject) {
                this.add(textObject, 'text', 'center', 0, false);
                scene.children.moveBelow(knob, textObject); // Move knob below textObject
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('knob', knob);
            this.addChildrenMap('text', textObject);

            this.setEnable(GetValue$2l(config, 'enable', undefined));

            this.setGap(GetValue$2l(config, 'gap', undefined));
            this.setValue(GetValue$2l(config, 'value', 0), GetValue$2l(config, 'min', undefined), GetValue$2l(config, 'max', undefined));

            // Input
            var inputMode = GetValue$2l(config, 'input', 0);
            if (typeof (inputMode) === 'string') {
                inputMode = INPUTMODE$1[inputMode];
            }
            switch (inputMode) {
                case 0: // 'pan'
                    InstallEvents.call(this);
                    break;
                case 1: // 'click'
                    InstallEvents$1.call(this);
                    break;
            }
        }

        setEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.enable = enable;
            return this;
        }

        setGap(gap) {
            this.gap = gap;
            return this;
        }

        // Override
        get value() {
            return this.sizerChildren.knob.value;
        }

        // Override
        set value(value) {
            if (this.gap !== undefined) {
                value = SnapTo$3(value, this.gap);
            }
            var oldValue = this.value;
            this.sizerChildren.knob.value = value;

            var newValue = this.value;
            if (oldValue !== newValue) {
                this.updateText();
                this.eventEmitter.emit('valuechange', newValue, oldValue, this.eventEmitter);
            }
        }

    }

    const INPUTMODE$1 = {
        pan: 0,
        drag: 0,
        click: 1,
        none: -1,
    };

    Object.assign(
        Knob.prototype,
        TextObjectMethods,
    );

    ObjectFactory.register('knob', function (config) {
        var gameObject = new Knob(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Knob', Knob);

    const ShapeClasses = {
        arc: Arc,
        circle: Circle,
        curve: Curve,
        ellipse: Ellipse,
        line: Line,
        lines: Lines,
        rectangle: Rectangle$2,
        roundRectangle: RoundRectangle,
        triangle: Triangle$1
    };

    const GetValue$2k = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$t = Phaser.Utils.Objects.IsPlainObject;

    const ClearAll = function () {
        var shapes = this.getShapes();
        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
            shapes[i].lineStyle().fillStyle();
        }
    };

    var ShapesUpdateMethods = {
        createShape(shapeType, name) {
            var ShapeClass = ShapeClasses[shapeType];
            var shape = new ShapeClass();
            if (name) {
                shape.setName(name);
            }
            return shape;
        },

        buildShapes(config) {
            var createCallback = GetValue$2k(config, 'create', undefined);

            if (IsPlainObject$t(createCallback)) {
                var shapes = createCallback;
                for (var shapeType in shapes) {
                    var name = shapes[shapeType];
                    switch (typeof (name)) {
                        case 'number':
                            for (var i = 0; i < name; i++) {
                                this.addShape(this.createShape(shapeType));
                            }
                            break;

                        case 'string':
                            this.addShape(this.createShape(shapeType, name));
                            break;

                        default: //Array
                            var names = name;
                            for (var i = 0, cnt = names.length; i < cnt; i++) {
                                this.addShape(this.createShape(shapeType, names[i]));
                            }
                            break;
                    }
                }
            } else if (Array.isArray(createCallback)) {
                var shapes = createCallback;
                for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                    var shape = shapes[i];
                    this.addShape(this.createShape(shape.type, shape.name));
                }

            } else if (typeof (createCallback) === 'function') {
                createCallback.call(this);

            }

            this.setUpdateShapesCallback(GetValue$2k(config, 'update'));
        },

        setUpdateShapesCallback(callback) {
            if (callback === undefined) {
                callback = ClearAll;
            }
            this.dirty = this.dirty || (this.updateCallback !== callback);
            this.updateCallback = callback;
            return this;
        },

        updateShapes() {
            this.updateCallback.call(this);
        }
    };

    const TransformMatrix = Phaser.GameObjects.Components.TransformMatrix;
    const TransformXY = Phaser.Math.TransformXY;

    var WorldXYToGameObjectLocalXY = function (gameObject, worldX, worldY, camera, out) {
        if (camera === undefined) {
            camera = gameObject.scene.cameras.main;
        }

        if (out === undefined) {
            out = {};
        } else if (out === true) {
            out = globOut;
        }

        var csx = camera.scrollX;
        var csy = camera.scrollY;
        var px = worldX + (csx * gameObject.scrollFactorX) - csx;
        var py = worldY + (csy * gameObject.scrollFactorY) - csy;
        if (gameObject.parentContainer) {
            if (tempMatrix$1 === undefined) {
                tempMatrix$1 = new TransformMatrix();
                parentMatrix = new TransformMatrix();
            }

            gameObject.getWorldTransformMatrix(tempMatrix$1, parentMatrix);
            tempMatrix$1.applyInverse(px, py, out);
        }
        else {
            TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, out);
        }

        out.x += gameObject.displayOriginX;
        out.y += gameObject.displayOriginY;

        return out;
    };

    var tempMatrix$1, parentMatrix;
    var globOut = {};

    const GetValue$2j = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$s = Phaser.Utils.Objects.IsPlainObject;

    class CustomShapes extends BaseShapes {
        constructor(scene, x, y, width, height, config) {
            if (IsPlainObject$s(x)) {
                config = x;
                x = GetValue$2j(config, 'x', 0);
                y = GetValue$2j(config, 'y', 0);
                width = GetValue$2j(config, 'width', 2);
                height = GetValue$2j(config, 'height', 2);
            }

            super(scene, x, y, width, height);
            this.type = GetValue$2j(config, 'type', 'rexCustomShapes');
            this.buildShapes(config);
        }

        get centerX() {
            return this.width / 2;
        }

        get centerY() {
            return this.height / 2;
        }

        worldToLocalXY(worldX, worldY, camera, out) {
            if (typeof (camera) === 'boolean') {
                out = camera;
                camera = undefined;
            }

            return WorldXYToGameObjectLocalXY(this, worldX, worldY, camera, out);
        }
    }

    Object.assign(
        CustomShapes.prototype,
        ShapesUpdateMethods
    );

    ObjectFactory.register('customShapes', function (x, y, width, height, config) {
        var gameObject = new CustomShapes(this.scene, x, y, width, height, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.CustomShapes', CustomShapes);

    const GetValue$2i = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$r = Phaser.Utils.Objects.IsPlainObject;

    class CustomProgress extends ProgressBase(CustomShapes) {
        constructor(scene, x, y, width, height, config) {
            if (IsPlainObject$r(x)) {
                config = x;
                x = GetValue$2i(config, 'x', 0);
                y = GetValue$2i(config, 'y', 0);
                width = GetValue$2i(config, 'width', 2);
                height = GetValue$2i(config, 'height', 2);
            }
            if (config === undefined) {
                config = {};
            }
            if (!config.type) {
                config.type = 'rexCustomProgress';
            }

            super(scene, x, y, width, height, config);

            this.bootProgressBase(config);

            this.setValue(GetValue$2i(config, 'value', 0));
        }

        get centerX() {
            return this.width / 2;    }

        get centerY() {
            return this.height / 2;
        }

        get radius() {
            return Math.min(this.centerX, this.centerY);
        }
    }

    ObjectFactory.register('customProgress', function (x, y, width, height, config) {
        var gameObject = new CustomProgress(this.scene, x, y, width, height, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.CustomProgress', CustomProgress);

    var Start = function (duration) {
        if (!this.easeValueTask) {
            this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
        }

        if (duration !== undefined) {
            this.duration = duration;
            this.easeValueTask.stop();  // Will restart with new duration
        }

        // Won't restart if easeValueTask is running
        if (this.easeValueTask.isRunning) {
            return this;
        }

        // Start easeValueTask
        this.easeValueTask.restart({
            key: 'value',
            from: 0, to: 1,
            duration: this.duration,
            ease: this.ease,
            repeat: -1,  // -1: infinity

            delay: this.delay,
            repeatDelay: this.repeatDelay
        });

        this.setDirty();

        return this;
    };

    var Stop$1 = function () {
        if (!this.easeValueTask) {
            return this;
        }
        this.easeValueTask.stop();
        this.setDirty();
        return this;
    };

    var Pause = function () {
        if (!this.easeValueTask) {
            return this;
        }
        this.easeValueTask.pause();
        this.setDirty();
        return this;
    };

    var Resume = function () {
        if (!this.easeValueTask) {
            return this;
        }
        this.easeValueTask.pause();
        this.setDirty();
        return this;
    };

    var EaseValueMethods = {
        start: Start,
        stop: Stop$1,
        pause: Pause,
        resume: Resume
    };

    const GetValue$2h = Phaser.Utils.Objects.GetValue;

    class Base extends BaseShapes {
        constructor(scene, config) {
            var x = GetValue$2h(config, 'x', 0);
            var y = GetValue$2h(config, 'y', 0);
            var width = GetValue$2h(config, 'width', 64);
            var height = GetValue$2h(config, 'height', 64);

            super(scene, x, y, width, height);

            this.resetFromConfig(config, true);

            this.buildShapes(config);

            if (GetValue$2h(config, 'start', true)) {
                this.start();
            }
        }

        resetFromConfig(config, setDefaults) {
            if (setDefaults === undefined) {
                setDefaults = false;
            }

            var defaultValue;

            defaultValue = (setDefaults) ? 1000 : this.duration;
            this.setDuration(GetValue$2h(config, 'duration', defaultValue));

            defaultValue = (setDefaults) ? 'Linear' : this.ease;
            this.setEase(GetValue$2h(config, 'ease', defaultValue));

            defaultValue = (setDefaults) ? 0 : this.delay;
            this.setDelay(GetValue$2h(config, 'delay', defaultValue));

            defaultValue = (setDefaults) ? 0 : this.repeatDelay;
            this.setRepeatDelay(GetValue$2h(config, 'repeatDelay', defaultValue));

            defaultValue = (setDefaults) ? 0xffffff : this.color;
            this.setColor(GetValue$2h(config, 'color', defaultValue));

            defaultValue = (setDefaults) ? 0 : this.value;
            this.setValue(GetValue$2h(config, 'value', defaultValue));

            return this;
        }

        buildShapes() {
        }

        get centerX() {
            return this.width / 2;    }

        get centerY() {
            return this.height / 2;
        }

        get radius() {
            return Math.min(this.centerX, this.centerY);
        }

        get color() {
            return this._color;
        }

        set color(value) {
            this.isColorChanged = this.isColorChanged || (this._color !== value);
            this.dirty = this.dirty || this.isColorChanged;
            this._color = value;
            this.setShapesColor(value);
        }

        setColor(color) {
            this.color = color;
            return this;
        }

        setShapesColor(color) {

        }

        get value() {
            return this._value;
        }

        set value(value) {
            value = Phaser.Math.Clamp(value, 0, 1);
            this.dirty = this.dirty || (this._value != value);
            this._value = value;
        }

        setValue(value) {
            this.value = value;
            return this;
        }

        setDuration(duration) {
            this.duration = duration;
            return this;
        }

        setDelay(delay) {
            this.delay = delay;
            return this;
        }

        setRepeatDelay(repeatDelay) {
            this.repeatDelay = repeatDelay;
            return this;
        }

        setEase(ease) {
            this.ease = ease;
            return this;
        }

        get isRunning() {
            return (this.tweenTask) ? this.tweenTask.isRunning : false;
        }
    }

    Object.assign(
        Base.prototype,
        EaseValueMethods
    );

    const DegToRad$5 = Phaser.Math.DegToRad;
    const Linear$e = Phaser.Math.Linear;
    const ExpoIn$4 = Phaser.Math.Easing.Expo.In;

    const DIRMAP = {
        right: 0,
        down: 1,
        left: 2,
        up: 3
    };

    var ArrowPolygon = function (polygon, innerX, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d) {
        var p0 = Transform(innerX, 0, gridWidth, gridHeight, x0, y0, a, b, c, d);
        polygon.startAt(p0.x, p0.y);
        var p1 = Transform(outerX, 0, gridWidth, gridHeight, x0, y0, a, b, c, d);
        polygon.lineTo(p1.x, p1.y);
        var p2 = Transform(outerX, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
        polygon.lineTo(p2.x, p2.y);
        var p3 = Transform(0, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
        polygon.lineTo(p3.x, p3.y);
        var p4 = Transform(0, innerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
        polygon.lineTo(p4.x, p4.y);
        var p5 = Transform(innerX, innerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
        polygon.lineTo(p5.x, p5.y);
        polygon.close();
    };

    var GlobPoint = {};
    var Transform = function (gridX, gridY, gridWidth, gridHeight, x0, y0, a, b, c, d) {
        var x = gridX * gridWidth;
        var y = gridY * gridHeight;
        GlobPoint.x = a * x + b * y + x0;
        GlobPoint.y = c * x + d * y + y0;
        return GlobPoint;
    };

    var ArrowUpdateShapesMethods = {
        setDirection(direction) {
            if (typeof (direction) === 'string') {
                direction = DIRMAP[direction];
            }
            this.direction = direction;
            return this;
        },

        buildShapes() {
            for (var i = 0; i < 3; i++) {
                this.addShape(new Lines());
            }
        },

        updateShapes() {
            var x0, y0, a, b, c, d;
            switch (this.direction) {
                case 1:
                    x0 = this.centerX;
                    y0 = this.centerY - this.radius;
                    // xt = a*x + b*y
                    var radX = DegToRad$5(315);
                    a = Math.cos(radX);
                    b = Math.sin(radX);
                    // yt = c*x + d*y
                    var radY = DegToRad$5(45);
                    c = Math.cos(radY);
                    d = Math.sin(radY);
                    break;

                case 3:
                    x0 = this.centerX;
                    y0 = this.centerY + this.radius;
                    // xt = a*x + b*y
                    var radX = DegToRad$5(135);
                    a = Math.cos(radX);
                    b = Math.sin(radX);
                    // yt = c*x + d*y
                    var radY = DegToRad$5(225);
                    c = Math.cos(radY);
                    d = Math.sin(radY);
                    break;

                case 2:
                    x0 = this.centerX + this.radius;
                    y0 = this.centerY;
                    // xt = a*x + b*y
                    var radX = DegToRad$5(225);
                    a = Math.cos(radX);
                    b = Math.sin(radX);
                    // yt = c*x + d*y
                    var radY = DegToRad$5(315);
                    c = Math.cos(radY);
                    d = Math.sin(radY);
                    break;

                default:
                    x0 = this.centerX - this.radius;
                    y0 = this.centerY;
                    // xt = a*x + b*y
                    var radX = DegToRad$5(45);
                    a = Math.cos(radX);
                    b = Math.sin(radX);
                    // yt = c*x + d*y
                    var radY = DegToRad$5(135);
                    c = Math.cos(radY);
                    d = Math.sin(radY);
                    break;
            }

            var gridSize = this.radius / 7;

            var shapes = this.getShapes();
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var shape = shapes[i];

                var t = (this.value + ((cnt - i) * 0.1)) % 1;
                t = ExpoIn$4(Yoyo$1(t));
                var alpha = Linear$e(0.25, 1, t);

                shape.fillStyle(this.color, alpha);

                var innerX = (i * 3) + 1;
                var outerX = innerX + 2;
                ArrowPolygon(shape, innerX, outerX, gridSize, gridSize, x0, y0, a, b, c, d);
            }
        }
    };

    const Linear$d = Phaser.Math.Linear;

    var AudioUpdateShapeMethods = {
        buildShapes() {
            for (var i = 0; i < 4; i++) {
                this.addShape(new Line());
            }
            this.prevValue = undefined;
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var leftBound = centerX - radius;
            var bottomBound = centerY + radius;
            var maxLineHeight = radius * 2;

            var shapes = this.getShapes(),
                cnt = shapes.length;
            var cellWidth = (radius * 2) / cnt;
            var lineWidth = cellWidth * 0.7;

            // Reset range of value
            if ((this.prevValue === undefined) || (this.prevValue > this.value)) {
                for (var i = 0; i < cnt; i++) {
                    var line = shapes[i];
                    var from = (this.prevValue === undefined) ? Math.random() : line.getData('to');
                    line
                        .setData('from', from)
                        .setData('to', Math.random());
                }
            }
            this.prevValue = this.value;

            for (var i = 0; i < cnt; i++) {
                var line = shapes[i];
                var from = line.getData('from'),
                    to = line.getData('to'),
                    current = Linear$d(from, to, this.value);
                var lineHeight = current * maxLineHeight;
                var x = leftBound + (cellWidth * (i + 0.5));

                line
                    .lineStyle(lineWidth, this.color, 1)
                    .setP0(x, bottomBound)
                    .setP1(x, (bottomBound - lineHeight));

            }
        }
    };

    const Linear$c = Phaser.Math.Linear;

    var BallUpdateShapeMethods = {
        buildShapes() {
            for (var i = 0; i < 3; i++) {
                this.addShape(new Circle());
            }
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var ballRadius = radius * 0.1;
            var lineWidth = Math.ceil(ballRadius * 0.25);

            var t = 1 - Yoyo$1(this.value);
            var trackRadius = Linear$c(0.3, 0.9, t) * radius;

            var shapes = this.getShapes();
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var ball = shapes[i];
                var t = (this.value + (i / cnt)) % 1;
                var angle = Math.PI * 2 * t;
                ball
                    .lineStyle(lineWidth, this.color)
                    .setRadius(ballRadius)
                    .setCenterPosition(
                        centerX + Math.cos(angle) * trackRadius,
                        centerY + Math.sin(angle) * trackRadius
                    );
            }
        }
    };

    const Linear$b = Phaser.Math.Linear;
    const ExpoIn$3 = Phaser.Math.Easing.Expo.In;

    var BarsUpdateShapeMethods = {
        buildShapes() {
            var cnt = 5;
            for (var i = 0; i < cnt; i++) {
                var line = new Line();
                this.addShape(line);
                var offset = Yoyo$1(i / (cnt - 1)) / 2;
                line.setData('offset', offset);
            }
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var leftBound = centerX - radius;
            var maxLineHeight = radius * 2;

            var shapes = this.getShapes(),
                cnt = shapes.length;
            var cellWidth = (radius * 2) / cnt;
            var lineWidth = cellWidth * 0.7;


            for (var i = 0; i < cnt; i++) {
                var line = shapes[i];
                var t = (this.value + line.getData('offset')) % 1;
                t = ExpoIn$3(Yoyo$1(t));

                var lineHeight = Linear$b(0.4, 1, t) * maxLineHeight;
                var x = leftBound + (cellWidth * (i + 0.5));

                line
                    .lineStyle(lineWidth, this.color, 1)
                    .setP0(x, (centerY - (lineHeight / 2)))
                    .setP1(x, (centerY + (lineHeight / 2)));

            }
        }
    };

    var BoxUpdateShapeMethods = {
        buildShapes() {
            this.addShape((new Lines()).setName('border'));
            this.addShape((new Lines()).setName('fill'));
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;

            var halfWidth = radius * 0.7;
            var left = centerX - halfWidth,
                top = centerY - halfWidth,
                width = halfWidth * 2;

            this.getShape('border')
                .lineStyle(2, this.color, 1)
                .startAt(left, top).lineTo(width, 0, true)
                .lineTo(0, width, true).lineTo(-width, 0, true)
                .lineTo(0, -width, true).close();

            if (this.value < 0.5) {
                var t = (0.5 - this.value) * 2;
                var height = width * t;
                this.getShape('fill')
                    .fillStyle(this.color, 1)
                    .startAt(left, top).lineTo(width, 0, true)
                    .lineTo(0, height, true).lineTo(-width, 0, true)
                    .lineTo(0, -height, true).close();

            } else { // Rotate
                var t = (this.value - 0.5) * 2;
                var angle = 180 * t;

                this.getShape('border').rotateAround(centerX, centerY, angle);
                this.getShape('fill').fillStyle().lineStyle();
            }
        }
    };

    const RadToDeg$3 = Phaser.Math.RadToDeg;
    const WrapDegrees = Phaser.Math.Angle.WrapDegrees;
    const WrapRad = Phaser.Math.Angle.Wrap;
    const ShortestBetween = Phaser.Math.Angle.ShortestBetween;
    const DegToRad$4 = Phaser.Math.DegToRad;
    const Rad270 = Phaser.Math.DegToRad(270);

    var ClockUpdateShapeMethods = {
        buildShapes() {
            this.addShape((new Circle()).setName('border'));
            this.addShape((new Line()).setName('minuteHand'));
            this.addShape((new Line()).setName('hourHand'));

            this.minuteHandAngle = 0;
            this.hourHandAngle = 0;
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var lineWidth = Math.ceil(radius / 25);
            var borderRadius = radius - (lineWidth / 2);
            var minuteHandLength = radius * 0.8;
            var hourHandLength = radius * 0.5;

            var prevMinuteHandAngle = this.minuteHandAngle;
            this.minuteHandAngle = Math.PI * 2 * this.value;
            var angle0 = WrapDegrees(RadToDeg$3(prevMinuteHandAngle));
            var angle1 = WrapDegrees(RadToDeg$3(this.minuteHandAngle));
            var deltaAngle = ShortestBetween(angle0, angle1);
            this.hourHandAngle = WrapRad(this.hourHandAngle + (DegToRad$4(deltaAngle) / 12));

            this.getShape('border')
                .lineStyle(lineWidth, this.color)
                .setRadius(borderRadius)
                .setCenterPosition(centerX, centerY);

            var angle = this.minuteHandAngle + Rad270;
            this.getShape('minuteHand')
                .lineStyle(lineWidth, this.color)
                .setP0(centerX, centerY)
                .setP1(
                    centerX + (Math.cos(angle) * minuteHandLength),
                    centerY + (Math.sin(angle) * minuteHandLength)
                );

            var angle = this.hourHandAngle + Rad270;
            this.getShape('hourHand')
                .lineStyle(lineWidth, this.color)
                .setP0(centerX, centerY)
                .setP1(
                    centerX + (Math.cos(angle) * hourHandLength),
                    centerY + (Math.sin(angle) * hourHandLength)
                );
        }
    };

    const Linear$a = Phaser.Math.Linear;
    const ExpoIn$2 = Phaser.Math.Easing.Expo.In;
    const RowNum$1 = 2;
    const ColNum$1 = 2;

    var CubeUpdateShapeMethods = {
        buildShapes() {
            var cnt = RowNum$1 * ColNum$1;
            for (var i = 0; i < cnt; i++) {
                var line = new Line();
                this.addShape(line);
            }
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var leftBound = centerX - radius;
            var topBound = centerY - radius;
            var cellWidth = (radius * 2) / ColNum$1;
            var cellHeight = (radius * 2) / RowNum$1;

            var shapes = this.getShapes(),
                cnt = shapes.length;
            for (var i = 0; i < cnt; i++) {
                var colIdx = (i % ColNum$1);
                var rowIdx = Math.floor(i / RowNum$1);
                var x = leftBound + (cellWidth * (colIdx + 0.5));
                var y = topBound + (cellHeight * (rowIdx + 0.5));

                var line = shapes[i];
                var t = (this.value + ((cnt - i) * 0.1)) % 1;
                t = ExpoIn$2(Yoyo$1(t));

                var lineAlpha = (cnt - i) / cnt;
                var lineHeight = Linear$a(0.7, 1, t) * cellHeight;
                var lineWidth = Linear$a(0.7, 1, t) * cellWidth;

                line
                    .lineStyle(lineWidth, this.color, lineAlpha)
                    .setP0(x - (lineHeight / 2), y)
                    .setP1(x + (lineHeight / 2), y);
            }
        }
    };

    const Linear$9 = Phaser.Math.Linear;

    var DotsUpdateShapeMethods = {
        buildShapes() {
            var cnt = 3;
            for (var i = 0; i < cnt; i++) {
                var dot = new Circle();
                this.addShape(dot);

                var offset = Yoyo$1(i / (cnt - 1)) / 2;
                dot.setData('offset', offset);
            }
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var leftBound = centerX - radius;

            var shapes = this.getShapes(),
                cnt = shapes.length;
            var cellWidth = (radius * 2) / cnt;
            var maxDotRadius = cellWidth / 2;

            for (var i = 0; i < cnt; i++) {
                var dot = shapes[i];
                var t = (this.value + dot.getData('offset')) % 1;
                t = Yoyo$1(t);

                var dotAlpha = Linear$9(0.25, 1, t);
                var dotRadius = Linear$9(0.5, 1, t) * maxDotRadius;
                dot
                    .fillStyle(this.color, dotAlpha)
                    .setRadius(dotRadius)
                    .setCenterPosition(
                        leftBound + (cellWidth * (i + 0.5)),
                        centerY
                    );
            }
        }
    };

    const Linear$8 = Phaser.Math.Linear;
    const ExpoIn$1 = Phaser.Math.Easing.Expo.In;

    var FacebookUpdateShapeMethods = {
        buildShapes() {
            for (var i = 0; i < 3; i++) {
                var shape = new Line();
                this.addShape(shape);
            }
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var leftBound = centerX - radius;

            var shapes = this.getShapes(),
                cnt = shapes.length;
            var cellWidth = (radius * 2) / cnt;
            var cellHeight = radius * 2;

            for (var i = 0; i < cnt; i++) {
                var line = shapes[i];
                var t = (this.value + ((cnt - i) * 0.1)) % 1;
                t = ExpoIn$1(Yoyo$1(t));

                var lineAlpha = (i + 1) / cnt;
                var lineHeight = Linear$8(0.7, 1, t) * cellHeight;
                var lineWidth = Linear$8(0.7, 1, t) * cellWidth;
                var x = leftBound + (cellWidth * (i + 0.5));

                line
                    .lineStyle(lineWidth, this.color, lineAlpha)
                    .setP0(x, centerY - (lineHeight / 2))
                    .setP1(x, centerY + (lineHeight / 2));
            }
        }
    };

    const Linear$7 = Phaser.Math.Linear;
    const RowNum = 3;
    const ColNum = 3;

    var GridUpdateShapeMethods = {
        buildShapes() {
            var cnt = RowNum * ColNum;
            for (var i = 0; i < cnt; i++) {
                var dot = new Circle();
                this.addShape(dot);

                dot.setData('offset', Math.random());
            }
            this.isInitialize = true;
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var needLayout = this.isInitialize || this.isSizeChanged;

            var leftBound = centerX - radius;
            var topBound = centerY - radius;
            var cellWidth = (radius * 2) / ColNum;
            var cellHeight = (radius * 2) / RowNum;
            var maxDotRadius = (Math.min(cellWidth, cellHeight) / 2) * 0.8;


            var shapes = this.getShapes();
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var colIdx = (i % ColNum);
                var rowIdx = Math.floor(i / RowNum);
                var x = leftBound + cellWidth * (colIdx + 0.5);
                var y = topBound + cellHeight * (rowIdx + 0.5);

                var dot = shapes[i];
                var t = (this.value + dot.getData('offset')) % 1;
                t = Yoyo$1(t);
                dot.fillStyle(this.color, Linear$7(0.25, 1, t));

                if (needLayout) {
                    dot
                        .setRadius(maxDotRadius)
                        .setCenterPosition(x, y);
                }
            }

            this.isInitialize = false;
        }
    };

    var HeartsUpdateShapeMethods = {
        buildShapes() {
            for (var i = 0; i < 2; i++) {
                this.addShape(new Lines());
            }
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var lineWidth = Math.ceil(radius / 25);
            var maxW50 = radius - lineWidth,
                maxW30 = maxW50 * 0.6,
                maxW35 = maxW50 * 0.7,
                maxW60 = maxW50 * 1.2;


            var shapes = this.getShapes();
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var heart = shapes[i];
                var t = (this.value + (i / cnt)) % 1;
                var alpha = Yoyo$1(t);
                var x = centerX,
                    y = centerY - (15 * t);
                var w50 = maxW50 * t,
                    w30 = maxW30 * t,
                    w35 = maxW35 * t,
                    w60 = maxW60 * t;

                heart
                    .lineStyle(lineWidth, this.color, alpha)
                    .startAt(
                        x, y
                    )
                    .cubicBezierTo(
                        x, y - w30,
                        x - w50, y - w30,
                        x - w50, y
                    )
                    .cubicBezierTo(
                        x - w50, y + w30,
                        x, y + w35,
                        x, y + w60
                    )
                    .cubicBezierTo(
                        x, y + w35,
                        x + w50, y + w30,
                        x + w50, y
                    )
                    .cubicBezierTo(
                        x + w50, y - w30,
                        x, y - w30,
                        x, y
                    )
                    .close();
            }
        }
    };

    const Linear$6 = Phaser.Math.Linear;

    var IosUpdateShapeMethods = {
        buildShapes() {
            for (var i = 0; i < 12; i++) {
                this.addShape(new Line());
            }
            this.isInitialize = true;
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var needLayout = this.isInitialize || this.isSizeChanged;

            var radius = this.radius;
            var startRadius = radius / 2;
            var lineWidth = Math.ceil(radius / 20);
            var shapes = this.getShapes();
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var line = shapes[i];
                var t = i / cnt;
                var angle = Math.PI * 2 * t;
                var alpha = Linear$6(0.25, 1, (1 - this.value + t) % 1);
                line.lineStyle(lineWidth, this.color, alpha);

                if (needLayout) {
                    line
                        .setP0(
                            centerX + Math.cos(angle) * startRadius,
                            centerY + Math.sin(angle) * startRadius
                        )
                        .setP1(
                            centerX + Math.cos(angle) * radius,
                            centerY + Math.sin(angle) * radius
                        );
                }
            }

            this.isInitialize = false;
        }
    };

    var OribitUpdateShapeMethods = {
        buildShapes() {
            this.addShape((new Circle()).setName('track'));
            this.addShape((new Circle()).setName('thumb'));
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var trackRadius = radius * 0.9;
            var trackThickness = Math.ceil(trackRadius / 25);
            var thumbRadius = radius * 0.1;
            var thumbAngle = Math.PI * 2 * this.value;

            this.getShape('track')
                .lineStyle(trackThickness, this.color, 0.7)
                .setRadius(trackRadius)
                .setCenterPosition(centerX, centerY);

            this.getShape('thumb')
                .fillStyle(this.color)
                .setRadius(thumbRadius)
                .setCenterPosition(
                    centerX + Math.cos(thumbAngle) * trackRadius,
                    centerY + Math.sin(thumbAngle) * trackRadius
                );
        }
    };

    var OvalUpdateShapeMethods = {
        buildShapes() {
            this.addShape((new Circle()).setName('track'));
            this.addShape((new Arc()).setName('arc'));
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var lineWidth = Math.ceil(radius / 25);
            var maxRadius = radius - (lineWidth / 2);

            this.getShape('track')
                .lineStyle(lineWidth, this.color, 0.5)
                .setRadius(maxRadius)
                .setCenterPosition(centerX, centerY);

            var startAngle = this.value * 360;
            var endAngle = startAngle + 60;
            this.getShape('arc')
                .lineStyle(lineWidth, this.color, 1)
                .setRadius(maxRadius)
                .setCenterPosition(centerX, centerY)
                .setAngle(startAngle, endAngle);

        }
    };

    const Linear$5 = Phaser.Math.Linear;

    var PieUpdateShapeMethods = {
        buildShapes() {
            for (var i = 0; i < 4; i++) {
                var pie = (new Arc()).setPie();
                this.addShape(pie);

                pie.setData('speed', Linear$5(180, 360, Math.random()));
            }
            this.prevValue = undefined;
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;

            var deltaValue;
            if (this.prevValue !== undefined) {
                deltaValue = this.value - this.prevValue;
                if (this.prevValue > this.value) {
                    deltaValue += 1;
                }
            }

            var shapes = this.getShapes();
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var pie = shapes[i];
                var pieAlpha = (i + 1) / cnt;

                if (this.prevValue === undefined) {
                    var startAngle = (i / cnt) * 360;
                    var endAngle = startAngle + 90;
                    pie
                        .fillStyle(this.color, pieAlpha)
                        .setRadius(radius)
                        .setCenterPosition(centerX, centerY)
                        .setAngle(startAngle, endAngle)
                        .setData('angle', startAngle);
                } else {
                    var startAngle = pie.getData('angle') + pie.getData('speed') * deltaValue;
                    startAngle = startAngle % 360;
                    var endAngle = startAngle + 90;
                    pie
                        .fillStyle(this.color, pieAlpha)
                        .setRadius(radius)
                        .setCenterPosition(centerX, centerY)
                        .setAngle(startAngle, endAngle)
                        .setData('angle', startAngle);

                }

            }

            this.prevValue = this.value;

        }
    };

    var PuffUpdateShapeMethods = {
        buildShapes() {
            this.addShape(new Circle());
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var puffRadius = radius * this.value;
            var lineWidth = Math.ceil(radius / 25);
            var alpha = Yoyo$1(this.value);

            this.getShapes()[0]
                .lineStyle(lineWidth, this.color, alpha)
                .setRadius(puffRadius)
                .setCenterPosition(centerX, centerY);
        }
    };

    const Linear$4 = Phaser.Math.Linear;
    const ExpoIn = Phaser.Math.Easing.Expo.In;

    var RadioUpdateShapeMethods = {
        buildShapes() {
            this.addShape((new Circle()).setName('center'));
            this.addShape((new Lines()).setName('arc0'));
            this.addShape((new Lines()).setName('arc1'));
            this.isInitialize = true;
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var needLayout = this.isInitialize || this.isSizeChanged;

            var centerRadius = (radius * 2) / 6;
            var x = centerX - radius + centerRadius;
            var y = centerY + radius - centerRadius;

            var shapes = this.getShapes();
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var shape = shapes[i];

                var t = (this.value + ((cnt - i) * 0.1)) % 1;
                t = ExpoIn(Yoyo$1(t));
                var alpha = Linear$4(0.25, 1, t);

                switch (shape.name) {
                    case 'center':
                        shape.fillStyle(this.color, alpha);

                        if (needLayout) {
                            shape
                                .setRadius(centerRadius)
                                .setCenterPosition(x, y);
                        }
                        break;
                    case 'arc0':
                        shape.fillStyle(this.color, alpha);

                        if (needLayout) {
                            var radius0 = centerRadius * 2,
                                radius1 = centerRadius * 3;
                            shape
                                .startAt(x, y - radius0)
                                .lineTo(x, y - radius1)
                                .setIterations(8).arc(x, y, radius1, 270, 360)
                                .lineTo(x + radius0, y)
                                .setIterations(6).arc(x, y, radius0, 360, 270, true)
                                .close();
                        }
                        break;
                    case 'arc1':
                        shape.fillStyle(this.color, alpha);

                        if (needLayout) {
                            var radius0 = centerRadius * 4,
                                radius1 = centerRadius * 5;
                            shape
                                .startAt(x, y - radius0)
                                .lineTo(x, y - radius1)
                                .setIterations(8).arc(x, y, radius1, 270, 360)
                                .lineTo(x + radius0, y)
                                .setIterations(6).arc(x, y, radius0, 360, 270, true)
                                .close();
                        }
                        break;
                }
            }

            this.isInitialize = false;
        }
    };

    var RingsUpdateShapeMethods = {
        buildShapes() {
            for (var i = 0; i < 2; i++) {
                this.addShape(new Circle());
            }
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var lineWidth = Math.ceil(radius / 25);
            var maxRingRadius = radius - lineWidth;

            var shapes = this.getShapes();
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var ring = shapes[i];
                var t = (this.value + (i / cnt)) % 1;
                var alpha = Yoyo$1(t);
                ring
                    .lineStyle(lineWidth, this.color, alpha)
                    .setRadius(t * maxRingRadius)
                    .setCenterPosition(centerX, centerY);
            }
        }
    };

    var SpinnerUpdateShapeMethods = {
        buildShapes() {
            this.addShape((new Arc()).setName('arc'));
        },

        updateShapes() {
            var centerX = this.centerX;
            var centerY = this.centerY;
            var radius = this.radius;
            var lineWidth = Math.ceil(radius / 10);
            var maxRadius = radius - lineWidth;

            var endAngle = this.value * 720;
            var arcAngle = Yoyo$1(this.value) * 180;
            var startAngle = endAngle - arcAngle;
            this.getShape('arc')
                .lineStyle(lineWidth, this.color, 1)
                .setRadius(maxRadius)
                .setCenterPosition(centerX, centerY)
                .setAngle(startAngle + 315, endAngle + 315);

        }
    };

    Phaser.Utils.Objects.GetValue;

    const AnimationModeMap = {
        leftArrow: ArrowUpdateShapesMethods,
        rightArrow: ArrowUpdateShapesMethods,
        upArrow: ArrowUpdateShapesMethods,
        downArrow: ArrowUpdateShapesMethods,
        audio: AudioUpdateShapeMethods,
        ball: BallUpdateShapeMethods,
        bars: BarsUpdateShapeMethods,
        box: BoxUpdateShapeMethods,
        clock: ClockUpdateShapeMethods,
        cube: CubeUpdateShapeMethods,
        dots: DotsUpdateShapeMethods,
        facebook: FacebookUpdateShapeMethods,
        grid: GridUpdateShapeMethods,
        hearts: HeartsUpdateShapeMethods,
        ios: IosUpdateShapeMethods,
        oribit: OribitUpdateShapeMethods,
        oval: OvalUpdateShapeMethods,
        pie: PieUpdateShapeMethods,
        puff: PuffUpdateShapeMethods,
        radio: RadioUpdateShapeMethods,
        rings: RingsUpdateShapeMethods,
        spinner: SpinnerUpdateShapeMethods
    };

    const AnimationModeList = [];
    for (var name in AnimationModeMap) {
        AnimationModeList.push(name);
    }

    const GetRandomItem$1 = Phaser.Utils.Array.GetRandom;

    var UpdateShapeMethods = {
        setAnimationMode(mode, config) {
            if (!AnimationModeMap.hasOwnProperty(mode)) {
                mode = GetRandomItem$1(AnimationModeList);
            }
            this.animationMode = mode;
            var updateMethods = AnimationModeMap[mode];

            if (config) {
                this.resetFromConfig(config);
            }

            switch (mode) {
                case 'leftArrow':
                    // ArrowUpdateShapesMethods
                    updateMethods.setDirection.call(this, 'left');
                    break;

                case 'rightArrow':
                    // ArrowUpdateShapesMethods
                    updateMethods.setDirection.call(this, 'right');
                    break;

                case 'upArrow':
                    // ArrowUpdateShapesMethods
                    updateMethods.setDirection.call(this, 'up');
                    break;

                case 'downArrow':
                    // ArrowUpdateShapesMethods
                    updateMethods.setDirection.call(this, 'down');
                    break;
            }

            this.clear();
            updateMethods.buildShapes.call(this);
            this.updateShapes = updateMethods.updateShapes.bind(this);

            this.stop().start();

            return this;
        },

        setRandomAnimationMode(config) {
            var mode = GetRandomItem$1(AnimationModeList);
            this.setAnimationMode(mode, config);
            return this;
        }
    };

    const GetValue$2g = Phaser.Utils.Objects.GetValue;

    class AIO extends Base {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexSpinnerAIO';

            this.setAnimationMode(GetValue$2g(config, 'animationMode'));
        }
    }

    Object.assign(
        AIO.prototype,
        UpdateShapeMethods,
    );

    ObjectFactory.register('aioSpinner', function (config) {
        var gameObject = new AIO(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.AIOSpinner', AIO);

    var SetTransitionCallbackMethods = {
        setTransitionStartCallback(callback, scope) {
            this.onStartCallback = callback;
            this.onStartCallbackScope = scope;
            return this;
        },

        setTransitionProgressCallback(callback, scope) {
            this.onProgressCallback = callback;
            this.onProgressCallbackScope = scope;
            return this;
        },

        setTransitionCompleteCallback(callback, scope) {
            this.onCompleteCallback = callback;
            this.onCompleteCallbackScope = scope;
            return this;
        },
    };

    var FitImages = function () {
        var scaleMode = this.scaleMode - 1;  // 1->0(FIT), 2->1(ENVELOP)
        for (var i = 0, cnt = this.images.length; i < cnt; i++) {
            var image = this.images[i];
            var result = FitTo(image, this, scaleMode, true);
            var biasScale = result.width / image.width;
            this.setChildLocalScale(image, biasScale);
            image.biasScale = biasScale;
        }
    };

    var OnTextureChange = function (newImage) {
        if (this.scaleMode === 0) {
            this.resize(newImage.width, newImage.height);

        } else {
            // Fit all images to parent's size
            FitImages.call(this);
        }
    };

    const IsPlainObject$q = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$2f = Phaser.Utils.Objects.GetValue;
    const GetRandomItem = Phaser.Utils.Array.GetRandom;

    var DirMode = {
        out: 0,
        in: 1
    };

    var GetValueFromConfigs = function (key, defaultValue, ...configs) {
        for (var i = 0, cnt = configs.length; i < cnt; i++) {
            var config = configs[i];
            if (config && config.hasOwnProperty(key)) {
                return config[key];
            }
        }
        return defaultValue;
    };

    var TransitionMethods = {
        setTransitionDirection(dir) {
            if (typeof (dir) === 'string') {
                dir = DirMode[dir];
            }
            this.dir = dir;
            return this;
        },

        setDuration(duration) {
            this.duration = duration;
            return this;
        },

        setEaseFunction(ease) {
            this.easeFunction = ease;
            return this;
        },

        setNextTexture(texture, frame) {
            this.nextImage.setTexture(texture, frame);

            OnTextureChange.call(this, this.nextImage);
            return this;
        },

        transit(texture, frame, mode) {
            if (this.isRunning) {
                this.ignoreCompleteEvent = true;
                this.stop();
                this.ignoreCompleteEvent = false;
            }

            if (mode !== undefined) {
                texture = {
                    key: texture,
                    frame: frame,
                    mode: mode
                };
            }

            this.currentTransitionMode = undefined;

            if (IsPlainObject$q(texture)) {
                var config = texture;
                texture = GetValue$2f(config, 'key', undefined);
                frame = GetValue$2f(config, 'frame', undefined);

                mode = GetValue$2f(config, 'mode');
                if (Array.isArray(mode)) {
                    mode = GetRandomItem(mode);
                }

                var modeConfig;
                if (this.transitionModes && this.transitionModes.hasOwnProperty(mode)) {
                    modeConfig = this.transitionModes[mode];
                    this.currentTransitionMode = mode;
                }

                this
                    .setDuration(GetValueFromConfigs('duration', this.duration, config, modeConfig))
                    .setEaseFunction(GetValueFromConfigs('ease', this.easeFunction, config, modeConfig))
                    .setTransitionDirection(GetValueFromConfigs('dir', this.dir, config, modeConfig));

                var maskGameObject = GetValueFromConfigs('mask', undefined, config, modeConfig);
                if (maskGameObject) {
                    this.setMaskGameObject(maskGameObject);
                }
                this.setMaskEnable(maskGameObject === true);

                var onStart = GetValueFromConfigs('onStart', undefined, config, modeConfig);
                var onProgress = GetValueFromConfigs('onProgress', undefined, config, modeConfig);
                var onComplete = GetValueFromConfigs('onComplete', undefined, config, modeConfig);
                if ((onStart !== undefined) || (onProgress !== undefined) || (onComplete !== undefined)) {
                    this
                        .setTransitionStartCallback(
                            onStart,
                            GetValueFromConfigs('onStartScope', undefined, config, modeConfig)
                        )
                        .setTransitionProgressCallback(
                            onProgress,
                            GetValueFromConfigs('onProgressScope', undefined, config, modeConfig)
                        )
                        .setTransitionCompleteCallback(
                            onComplete,
                            GetValueFromConfigs('onCompleteScope', undefined, config, modeConfig)
                        );
                }
            }

            this.setNextTexture(texture, frame);

            this.start();
            return this;
        },

        addTransitionMode(name, config) {
            if (this.transitionModes === undefined) {
                this.transitionModes = {};
            }

            if (IsPlainObject$q(name)) {
                config = name;
                name = config.name;
                delete config.name;
            }

            this.transitionModes[name] = config;
            return this;
        },

        start() {
            if (this.easeValueTask === undefined) {
                this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
            }
            this.easeValueTask.restart({
                key: 't', from: 0, to: 1,
                duration: this.duration,
                ease: this.easeFunction
            });
            return this;
        },

        pause() {
            if (this.easeValueTask) {
                this.easeValueTask.pause();
            }
            return this;
        },

        resume() {
            if (this.easeValueTask) {
                this.easeValueTask.resume();
            }
            return this;
        },

        stop() {
            if (this.easeValueTask) {
                this.easeValueTask.stop();
            }
            this.setT(1);
            return this;
        },
    };

    const SetPositionBase = Phaser.GameObjects.Graphics.prototype.setPosition;

    var SetPosition$1 = function (x, y) {
        var parent = this.parent;
        if (x === undefined) {
            x = parent.x;
        }
        if (y === undefined) {
            y = parent.y;
        }

        SetPositionBase.call(this, x, y);
        return this;
    };

    const RectangleGeom = Phaser.Geom.Rectangle;
    const CircleGemo = Phaser.Geom.Circle;

    var GetGeom = function (shapeType, width, height, padding, originX, originY, out) {
        switch (shapeType) {
            case 1: // circle
                // Assume that all padding are the same value in this circle shape
                padding = padding.left;
                var centerX = -width * (originX - 0.5);
                var centerY = -height * (originY - 0.5);
                var radius = Math.min(width, height) / 2 + padding;

                if ((out === undefined) || !(out instanceof (CircleGemo))) {
                    out = new CircleGemo();
                }
                out.setTo(centerX, centerY, radius);
                break;

            default: // 0|'rectangle'
                var topLeftX = -(width * originX) - padding.left;
                var topLeftY = -(height * originY) - padding.top;
                var rectWidth = width + padding.left + padding.right;
                var rectHeight = height + padding.top + padding.bottom;

                if ((out === undefined) || !(out instanceof (RectangleGeom))) {
                    out = new RectangleGeom();
                }
                out.setTo(topLeftX, topLeftY, rectWidth, rectHeight);
                break;
        }

        return out;
    };

    var DrawShape = function (width, height, padding, originX, originY) {
        this.geom = GetGeom(this.shapeType, width, height, padding, originX, originY, this.geom);

        this.clear().fillStyle(0xffffff);
        switch (this.shapeType) {
            case 1: // circle
                // Assume that all padding are the same value in this circle shape
                this.fillCircleShape(this.geom);
                break;

            default: // 0|'rectangle'
                this.fillRectShape(this.geom);
                break;
        }
    };

    var Resize$1 = function (width, height, padding) {
        var parent = this.parent;
        if (width === undefined) {
            width = parent.width;
        }
        if (height === undefined) {
            height = parent.height;
        }

        if (padding === undefined) {
            padding = this.padding;
        } else if (typeof (padding) === 'number') {
            padding = GetBoundsConfig(padding);
        }

        var isSizeChanged = (this.width !== width) || (this.height !== height);
        var isPaddingChanged = (this.padding !== padding) && !IsKeyValueEqual(this.padding, padding);
        if (!isSizeChanged && !isPaddingChanged) {
            return this;
        }

        this.width = width;
        this.height = height;

        if (isPaddingChanged) {
            Clone$2(padding, this.padding);
        }

        // Graphics does not have originX, originY properties
        this.originX = parent.originX;
        this.originY = parent.originY;

        DrawShape.call(this,
            width, height, padding,
            parent.originX, parent.originY
        );

        return this;
    };

    var SetOrigin = function (originX, originY) {
        if (originY === undefined) {
            originY = originX;
        }

        var parent = this.parent;
        if (originX === undefined) {
            originX = parent.originX;
        }
        if (originY === undefined) {
            originY = parent.originY;
        }
        if ((this.originX === originX) && (this.originY === originY)) {
            return this;
        }

        this.originX = originX;
        this.originY = originY;

        DrawShape.call(this,
            this.width, this.height, this.padding,
            originX, originY,
        );
        return this;
    };

    var Contains$1 = function (x, y) {
        x -= this.x;
        y -= this.y;
        return this.geom.contains(x, y);
    };

    var Methods$a = {
        setPosition: SetPosition$1,
        resize: Resize$1,
        setOrigin: SetOrigin,
        contains: Contains$1,
    };

    const Graphics = Phaser.GameObjects.Graphics;

    class DefaultMaskGraphics extends Graphics {
        constructor(parent, shapeType, padding) {
            if (shapeType === undefined) {
                shapeType = 0;
            }
            if (typeof (shapeType) === 'string') {
                shapeType = SHAPEMODE[shapeType];
            }

            super(parent.scene);
            this.parent = parent;
            this.shapeType = shapeType;
            this.padding = GetBoundsConfig$1(padding);
            this.setPosition().resize().setVisible(false);
            // Don't add it to display list
        }

        destroy() {
            this.parent = undefined;
            super.destroy();
            return this;
        }
    }

    const SHAPEMODE = {
        rectangle: 0,
        circle: 1,
    };

    Object.assign(
        DefaultMaskGraphics.prototype,
        Methods$a
    );

    var MaskMethods = {
        setMaskGameObject(gameObject) {
            if (!gameObject) {
                this.removeMaskGameObject();
                return this;
            }

            if (this.maskGameObject) {
                if ((gameObject === true) && (this.maskGameObject instanceof DefaultMaskGraphics)) {
                    return this;
                }
                if (this.maskGameObject === gameObject) {
                    return this;
                }

                // Remove previous Mask Game Object
                this.removeMaskGameObject();
            }

            // Add new Mask Game Object
            if (gameObject === true) {
                gameObject = new DefaultMaskGraphics(this);
            }

            gameObject
                .resize(this.width, this.height)
                .setOrigin(this.originX, this.originY)
                .setPosition(0, 0)
                .setScale(1)
                .setVisible(false);
            this.addLocal(gameObject);
            this.maskGameObject = gameObject;

            if (!gameObject._maskObject) {
                gameObject._maskObject = gameObject.createGeometryMask();
                gameObject.once('destroy', function () {
                    gameObject._maskObject.destroy();
                    gameObject._maskObject = undefined;
                });
            }
            this.childrenMask = gameObject._maskObject;

            return this;
        },

        removeMaskGameObject(destroyMaskGameObject) {
            if (destroyMaskGameObject === undefined) {
                destroyMaskGameObject = true;
            }

            this.backImage.clearMask();
            this.frontImage.clearMask();
            this.childrenMask = undefined;
            this.remove(this.maskGameObject, destroyMaskGameObject);
            this.maskGameObject = undefined;
            return this;
        },

        setImageMaskEnable(gameObject, enable, invertAlpha) {
            if (enable === undefined) {
                enable = true;
            }
            if (invertAlpha === undefined) {
                invertAlpha = false;
            }

            if (enable) {
                // Use DefaultMaskGraphics if not given    
                if (!this.childrenMask) {
                    this.setMaskGameObject(true);
                }
                gameObject.setMask(this.childrenMask);
                this.childrenMask.setInvertAlpha(invertAlpha);
            } else {
                gameObject.clearMask();
            }

            return this;
        },

        setCurrentImageMaskEnable(enable, invertAlpha) {
            this.setImageMaskEnable(this.currentImage, enable, invertAlpha);
            return this;
        },

        setNextImageMaskEnable(enable, invertAlpha) {
            this.setImageMaskEnable(this.nextImage, enable, invertAlpha);
            return this;
        },

        setCellImagesMaskEnable(enable, invertAlpha) {
            var cellImages = this.getCellImages();
            for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
                this.setImageMaskEnable(cellImages[i], enable, invertAlpha);
            }
            return this;
        },

        setMaskEnable(enable, invertAlpha) {
            this.setImageMaskEnable(this.backImage, enable, invertAlpha);
            this.setImageMaskEnable(this.frontImage, enable, invertAlpha);
            this.setCellImagesMaskEnable(enable, invertAlpha);
            return this;
        }
    };

    var GetFrameNameCallback = function (baseFrameName, delimiter) {
        if (typeof (baseFrameName) === 'object') {
            baseFrameName = baseFrameName.name;
        }

        if (delimiter === undefined) {
            delimiter = ',';
        }

        var callback;
        if (baseFrameName === '__BASE') {
            callback = function (colIndex, rowIndex) {
                return `${colIndex}${delimiter}${rowIndex}`;
            };
        } else {
            callback = function (colIndex, rowIndex) {
                return `${baseFrameName}_${colIndex}${delimiter}${rowIndex}`;
            };
        }

        return callback;
    };

    var GenerateFrames = function (scene, key, frame, columns, rows, getFrameNameCallback) {
        if (frame == null) {
            frame = '__BASE';
        }

        if (!getFrameNameCallback) {
            getFrameNameCallback = GetFrameNameCallback(frame, getFrameNameCallback);
        }

        var texture = scene.sys.textures.get(key);
        var baseFrame = (typeof (frame) === 'object') ? frame : texture.get(frame);

        var baseWidth = baseFrame.width,
            baseHeight = baseFrame.height;

        var cellX, cellY, cellName;
        var cellWidth = baseWidth / columns,
            cellHeight = baseHeight / rows;

        var frameCutX = baseFrame.cutX,
            frameCutY = baseFrame.cutY;
        var offsetX = 0,
            offsetY = 0;
        for (var y = 0; y < rows; y++) {
            offsetX = 0;
            for (var x = 0; x < columns; x++) {
                cellName = getFrameNameCallback(x, y);

                cellX = offsetX + frameCutX;
                cellY = offsetY + frameCutY;

                texture.add(
                    cellName, 0,
                    cellX, cellY,
                    cellWidth, cellHeight
                );

                offsetX += cellWidth;
            }
            offsetY += cellHeight;
        }

        return {
            getFrameNameCallback: getFrameNameCallback,
            cellWidth: cellWidth,
            cellHeight: cellHeight,
            columns: columns,
            rows: rows
        }
    };

    const GetValue$2e = Phaser.Utils.Objects.GetValue;
    const DefaultImageClass = Phaser.GameObjects.Image;
    const IsPlainObject$p = Phaser.Utils.Objects.IsPlainObject;
    const RotateAround$2 = Phaser.Math.RotateAround;

    var GridCutImage = function (gameObject, columns, rows, config) {
        if (IsPlainObject$p(columns)) {
            config = columns;
            columns = GetValue$2e(config, 'columns', 1);
            rows = GetValue$2e(config, 'rows', 1);
        }

        var createImageCallback = GetValue$2e(config, 'createImageCallback');
        if (!createImageCallback) {
            var ImageClass = GetValue$2e(config, 'ImageClass', DefaultImageClass);
            createImageCallback = function (scene, key, frame) {
                return new ImageClass(scene, 0, 0, key, frame);
            };
        }

        var originX = GetValue$2e(config, 'originX', 0.5);
        var originY = GetValue$2e(config, 'originY', 0.5);

        var addToScene = GetValue$2e(config, 'add', true);

        var align = GetValue$2e(config, 'align', addToScene);

        var imageObjectPool = GetValue$2e(config, 'objectPool', undefined);

        var scene = gameObject.scene;
        var texture = gameObject.texture;
        var frame = gameObject.frame;

        var result = GenerateFrames(scene, texture, frame, columns, rows);
        var getFrameNameCallback = result.getFrameNameCallback;
        var scaleX = gameObject.scaleX,
            scaleY = gameObject.scaleY;
        var rotation = gameObject.rotation;
        var topLeft = gameObject.getTopLeft(),
            startX = topLeft.x,
            startY = topLeft.y;

        var cellGameObjects = [];
        var scaleCellWidth = result.cellWidth * scaleX,
            scaleCellHeight = result.cellHeight * scaleY;
        for (var y = 0; y < rows; y++) {
            for (var x = 0; x < columns; x++) {
                var cellGameObject;

                var frameName = getFrameNameCallback(x, y);
                if (imageObjectPool && (imageObjectPool.length > 0)) {
                    cellGameObject = (imageObjectPool.pop()).setTexture(texture, frameName);
                } else {
                    cellGameObject = createImageCallback(scene, texture, frameName);
                }

                if (addToScene) {
                    scene.add.existing(cellGameObject);
                }

                if (align) {
                    var cellTLX = startX + (scaleCellWidth * x);
                    var cellTLY = startY + (scaleCellHeight * y);
                    var cellX = cellTLX + (originX * scaleCellWidth);
                    var cellY = cellTLY + (originY * scaleCellHeight);

                    cellGameObject
                        .setOrigin(originX, originY)
                        .setPosition(cellX, cellY)
                        .setScale(scaleX, scaleY)
                        .setRotation(rotation);
                    RotateAround$2(cellGameObject, startX, startY, rotation);
                }

                cellGameObjects.push(cellGameObject);
            }
        }

        return cellGameObjects;
    };

    var GridCutMethods = {
        gridCutImage(gameObject, columns, rows, config) {
            if (config === undefined) {
                config = {};
            }
            config.objectPool = this.imagesPool;
            var cellImages = GridCutImage(gameObject, columns, rows, config),
                cellImage;
            for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
                cellImage = cellImages[i];
                cellImage.setVisible(true);
                this.add(cellImage);
            }

            this.cellImages = cellImages;
            this.setChildLocalVisible(gameObject, false);  // Set cut target to invisible
            return cellImages;
        },

        gridCutCurrentImage(columns, rows, config) {
            return this.gridCutImage(this.currentImage, columns, rows, config);
        },

        gridCutNextImage(columns, rows, config) {
            return this.gridCutImage(this.nextImage, columns, rows, config);
        },

        getCellImages() {
            return this.cellImages;
        },

        freeCellImages() {
            if (this.cellImages.length === 0) {
                return this;
            }

            var texture = this.cellImages[0].texture;
            var cellImages = this.cellImages,
                cellImage, frameName;
            for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
                cellImage = cellImages[i];

                // Reset property of cell image
                this
                    .setChildLocalAlpha(cellImage, 1)
                    .setChildLocalScale(cellImage, 1)
                    .setChildLocalVisible(cellImage, false);

                cellImage.clearMask();

                // Remove frame object
                frameName = cellImage.frame.name;
                cellImage.setTexture();
                texture.remove(frameName);
            }

            this.imagesPool.push(...cellImages);
            cellImages.length = 0;

            return this;
        }
    };

    var FlipMethods = {
        setFlipX(value) {
            this.flipX = value;
            return this;
        },
        setFlipY(value) {
            this.flipY = value;
            return this;
        },
        toggleFlipX() {
            this.flipX = !this.flipX;
            return this;
        },
        toggleFlipY() {
            this.flipY = !this.flipY;
            return this;
        },
        setFlip(x, y) {
            this.flipX = x;
            this.flipY = y;
            return this;
        },
        resetFlip() {
            this.flipX = false;
            this.flipY = false;
            return this;
        }
    };

    var methods$s = {
    };

    Object.assign(
        methods$s,
        SetTransitionCallbackMethods,
        TransitionMethods,
        MaskMethods,
        GridCutMethods,
        FlipMethods
    );

    var OnStart = function (parent, currentImage, nextImage, t) {
    };

    var OnProgress = function (parent, currentImage, nextImage, t) {
        parent
            .setChildLocalAlpha(currentImage, 1 - t)
            .setChildLocalAlpha(nextImage, t);
    };

    var OnComplete = function (parent, currentImage, nextImage, t) {
        parent.setChildLocalAlpha(currentImage, 1);
    };

    const IsPlainObject$o = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$2d = Phaser.Utils.Objects.GetValue;
    const Clamp$a = Phaser.Math.Clamp;

    class TransitionImage extends ContainerLite {
        constructor(scene, x, y, texture, frame, config) {
            if (IsPlainObject$o(x)) {
                config = x;
                x = GetValue$2d(config, 'x', 0);
                y = GetValue$2d(config, 'y', 0);
                texture = GetValue$2d(config, 'key', undefined);
                frame = GetValue$2d(config, 'frame', undefined);
            } else if (IsPlainObject$o(frame)) {
                config = frame;
                frame = undefined;
            }

            var backImage = GetValue$2d(config, 'back', undefined);
            var frontImage = GetValue$2d(config, 'front', undefined);
            if (!backImage) {
                backImage = scene.add.image(x, y, texture, frame);
            }
            if (!frontImage) {
                frontImage = scene.add.image(x, y, texture, frame);
            }

            var width = GetValue$2d(config, 'width', undefined);
            var height = GetValue$2d(config, 'height', undefined);
            var scaleMode = ((width !== undefined) && (height !== undefined)) ? 1 : 0;

            if (width === undefined) {
                width = frontImage.width;
            }
            if (height === undefined) {
                height = frontImage.height;
            }

            super(scene, x, y, width, height);
            this.type = 'rexTransitionImage';
            this._flipX = false;
            this._flipY = false;

            scaleMode = GetValue$2d(config, 'scaleMode', scaleMode);
            if (typeof (scaleMode) === 'string') {
                scaleMode = ScaleModeMap[scaleMode];
            }
            this.scaleMode = scaleMode;

            backImage.setVisible(false);
            this.addMultiple([backImage, frontImage]);

            this.backImage = backImage;
            this.frontImage = frontImage;
            this.images = [this.backImage, this.frontImage];
            this.maskGameObject = undefined;
            this.cellImages = [];
            this.imagesPool = [];
            this.transitionModes = undefined;
            this.currentTransitionMode = undefined;

            // Transition parameters
            var onStart = GetValue$2d(config, 'onStart', undefined);
            var onProgress = GetValue$2d(config, 'onProgress', undefined);
            var onComplete = GetValue$2d(config, 'onComplete', undefined);
            var dir = GetValue$2d(config, 'dir', 0);
            if ((onStart === undefined) && (onProgress === undefined) && (onComplete === undefined)) {
                onStart = OnStart;
                onProgress = OnProgress;
                onComplete = OnComplete;
                dir = 0;
            }

            this
                .setTransitionStartCallback(
                    onStart,
                    GetValue$2d(config, 'onStartScope', undefined)
                )
                .setTransitionProgressCallback(
                    onProgress,
                    GetValue$2d(config, 'onProgressScope', undefined)
                )
                .setTransitionCompleteCallback(
                    onComplete,
                    GetValue$2d(config, 'onCompleteScope', undefined)
                )
                .setTransitionDirection(dir)
                .setDuration(GetValue$2d(config, 'duration', 1000))
                .setEaseFunction(GetValue$2d(config, 'ease', 'Linear'));

            var maskGameObject = GetValue$2d(config, 'mask', undefined);
            if (maskGameObject) {
                this.setMaskGameObject(maskGameObject);
            }
            this.setMaskEnable(false);

            this.ignoreCompleteEvent = false;

            OnTextureChange.call(this, this.frontImage);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            if (this.childrenMask) {
                this.childrenMask.destroy();
                this.childrenMask = undefined;
            }
            this.backImage = undefined;
            this.frontImage = undefined;
            this.images.length = 0;
            this.maskGameObject = undefined;
            this.cellImages.length = 0;
            this.imagesPool.length = 0;
            this.transitionModes = undefined;

            super.destroy(fromScene);

            this.onStartCallback = undefined;
            this.onStartCallbackScope = undefined;
            this.onProgressCallback = undefined;
            this.onProgressCallbackScope = undefined;
            this.onCompleteCallback = undefined;
            this.onCompleteCallbackScope = undefined;
            this.easeValueTask = undefined;
        }

        get currentImage() {
            return (this.dir === 0) ? this.frontImage : this.backImage;
        }

        get nextImage() {
            return (this.dir === 0) ? this.backImage : this.frontImage;
        }

        get texture() {
            return this.nextImage.texture;
        }

        get frame() {
            return this.nextImage.frame;
        }

        get tint() {
            return this._tint;
        }

        set tint(value) {
            if (this._tint === value) {
                return;
            }

            this._tint = value;
            this.backImage.setTint(value);
            this.frontImage.setTint(value);
        }

        setTint(value) {
            this.tint = value;
            return this;
        }

        get flipX() {
            return this._flipX;
        }

        set flipX(value) {
            if (this._flipX === value) {
                return;
            }

            this._flipX = value;
            this.backImage.setFlipX(value);
            this.frontImage.setFlipX(value);
        }

        setFlipX(value) {
            this.flipX = value;
            return this;
        }

        toggleFlipX() {
            this.flipX = !this.flipX;
            return this;
        }

        get flipY() {
            return this._flipY;
        }

        set flipY(value) {
            if (this._flipY === value) {
                return;
            }
            this._flipY = value;
            this.backImage.setFlipY(value);
            this.frontImage.setFlipY(value);
        }

        setFlipY(value) {
            this.flipY = value;
            return this;
        }

        toggleFlipY() {
            this.flipY = !this.flipY;
            return this;
        }

        setFlip(flipX, flipY) {
            this.flipX = flipX;
            this.flipY = flipY;
            return this;
        }

        get t() {
            return this._t;
        }

        set t(value) {
            value = Clamp$a(value, 0, 1);
            if (this._t === value) {
                return;
            }
            this._t = value;

            var currentImage = this.currentImage;
            var nextImage = this.nextImage;

            // Start
            if (value === 0) {
                this
                    .setChildVisible(this.frontImage, true)
                    .setChildVisible(this.backImage, true);

                RunCallback.call(this,
                    this.onStartCallback, this.onStartCallbackScope,
                    this, currentImage, nextImage, value
                );
            }

            // Progress
            RunCallback.call(this,
                this.onProgressCallback, this.onProgressCallbackScope,
                this, currentImage, nextImage, value
            );

            // Complete
            if (value === 1) {
                RunCallback.call(this,
                    this.onCompleteCallback, this.onCompleteCallbackScope,
                    this, currentImage, nextImage, value
                );

                var key = nextImage.texture.key,
                    frame = nextImage.frame.name;
                this.frontImage.setTexture(key, frame);
                this.backImage.setTexture(key, frame);
                OnTextureChange.call(this, nextImage);

                this
                    .setChildVisible(this.frontImage, true)
                    .setChildVisible(this.backImage, false)
                    .setMaskEnable(false)
                    .freeCellImages();
            }

            if ((value === 1) && (!this.ignoreCompleteEvent)) {
                this.emit('complete');
            }
        }

        setT(value) {
            this.t = value;
            return this;
        }

        get isRunning() {
            return (this.easeValueTask) ? this.easeValueTask.isRunning : false;
        }

        setOrigin(originX, originY) {
            super.setOrigin(originX, originY);

            this.backImage.setOrigin(originX, originY);
            this.frontImage.setOrigin(originX, originY);

            if (this.maskGameObject) {
                this.maskGameObject.setOrigin(originX, originY);
            }

            return this;
        }

        setTexture(texture, frame) {
            // Without transition
            this.frontImage.setTexture(texture, frame);
            this.backImage.setTexture(texture, frame).setVisible(false);

            OnTextureChange.call(this, this.frontImage);

            return this;
        }

        setSize(width, height) {
            super.setSize(width, height);

            if (this.scaleMode) {
                FitImages.call(this);
            }

            return this;
        }
    }

    var RunCallback = function (callback, scope, parent, currentImage, nextImage, t) {
        if (!callback) {
            return;
        }

        if (this.scaleMode) {
            var localScale;
            if (currentImage.biasScale > 0) {
                localScale = this.getChildLocalScaleX(currentImage);
                localScale = localScale / currentImage.biasScale;
                this.setChildLocalScale(currentImage, localScale);
            }
            if (nextImage.biasScale) {
                localScale = this.getChildLocalScaleX(nextImage);
                localScale = localScale / nextImage.biasScale;
                this.setChildLocalScale(nextImage, localScale);
            }
        }

        if (scope) {
            callback.call(scope, parent, currentImage, nextImage, t);
        } else {
            callback(parent, currentImage, nextImage, t);
        }

        if (this.scaleMode) {
            var localScale;
            if (currentImage.biasScale > 0) {
                localScale = this.getChildLocalScaleX(currentImage);
                localScale = localScale * currentImage.biasScale;
                this.setChildLocalScale(currentImage, localScale);
            }
            if (nextImage.biasScale) {
                localScale = this.getChildLocalScaleX(nextImage);
                localScale = localScale * nextImage.biasScale;
                this.setChildLocalScale(nextImage, localScale);
            }
        }
    };

    // mixin
    Object.assign(
        TransitionImage.prototype,
        methods$s
    );

    const ScaleModeMap = {
        fit: 1,
        FIT: 1,
        envelop: 2,
        ENVELOP: 2
    };

    ObjectFactory.register('transitionImage', function (x, y, texture, frame, config) {
        var gameObject = new TransitionImage(this.scene, x, y, texture, frame, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TransitionImage', TransitionImage);

    // Slide modes
    const SlideLeft = 'slideLeft';
    const SlideRight = 'slideRight';
    const SlideUp = 'slideUp';
    const SlideDown = 'slideDown';
    const SlideAwayLeft = 'slideAwayLeft';
    const SlideAwayRight = 'slideAwayRight';
    const SlideAwayUp = 'slideAwayUp';
    const SlideAwayDown = 'slideAwayDown';
    const PushLeft = 'pushLeft';
    const PushRight = 'pushRight';
    const PushUp = 'pushUp';
    const PushDown = 'pushDown';

    // Zoom modes
    const ZoomOut = 'zoomOut';
    const ZoomIn = 'zoomIn';
    const ZoomInOut = 'zoomInOut';

    // Fade effect mode
    const Fade$1 = 'fade';
    const CrossFade = 'crossFade';

    // Wipe modes
    const WipeLeft = 'wipeLeft';
    const WipeRight = 'wipeRight';
    const WipeUp = 'wipeUp';
    const WipeDown = 'wipeDown';

    // Iris modes
    const IrisOut = 'irisOut';
    const IrisIn = 'irisIn';
    const IrisInOut = 'irisInOut';

    // Pie modes
    const PieOut = 'pieOut';
    const PieIn = 'pieIn';
    const PieInOut = 'pieInOut';

    // blinds, squares, diamonds, circles, curtain
    const Blinds = 'blinds';
    const Squares = 'squares';
    const Diamonds = 'diamonds';
    const Circles = 'circles';
    const Curtain = 'curtain';

    // Shader effect modes
    const Pixellate = 'pixellate';
    const Dissolve = 'dissolve';

    const RevealLeft = 'revealLeft';
    const RevealRight = 'revealRight';
    const RevealUp = 'revealUp';
    const RevealDown = 'revealDown';

    var AddSlideAwayModes = function (image) {
        image
            .addTransitionMode(SlideAwayRight, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var x = currentImage.width * (t);
                    parent.setChildLocalPosition(currentImage, x, 0);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(currentImage, 0, 0);
                },
            })
            .addTransitionMode(SlideAwayLeft, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var x = currentImage.width * (-t);
                    parent.setChildLocalPosition(currentImage, x, 0);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(currentImage, 0, 0);
                },
            })
            .addTransitionMode(SlideAwayDown, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var y = currentImage.height * (t);
                    parent.setChildLocalPosition(currentImage, 0, y);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(currentImage, 0, 0);
                },
            })
            .addTransitionMode(SlideAwayUp, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var y = currentImage.height * (-t);
                    parent.setChildLocalPosition(currentImage, 0, y);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(currentImage, 0, 0);
                },
            });

    };

    var AddSlideModes = function (image) {
        image
            .addTransitionMode(SlideRight, {
                ease: 'Linear', dir: 'in', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var x = nextImage.width * (t - 1);
                    parent.setChildLocalPosition(nextImage, x, 0);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(nextImage, 0, 0);
                },
            })
            .addTransitionMode(SlideLeft, {
                ease: 'Linear', dir: 'in', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var x = nextImage.width * (1 - t);
                    parent.setChildLocalPosition(nextImage, x, 0);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(nextImage, 0, 0);
                },
            })
            .addTransitionMode(SlideDown, {
                ease: 'Linear', dir: 'in', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var y = nextImage.height * (t - 1);
                    parent.setChildLocalPosition(nextImage, 0, y);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(nextImage, 0, 0);
                },
            })
            .addTransitionMode(SlideUp, {
                ease: 'Linear', dir: 'in', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var y = nextImage.height * (1 - t);
                    parent.setChildLocalPosition(nextImage, 0, y);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(nextImage, 0, 0);
                },
            });
    };

    var AddSliderModes = function (image) {
        image
            .addTransitionMode(PushRight, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    // SlideAwayRight
                    var x = currentImage.width * (t);
                    parent.setChildLocalPosition(currentImage, x, 0);

                    // SlideLeft
                    var x = nextImage.width * (t - 1);
                    parent.setChildLocalPosition(nextImage, x, 0);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(currentImage, 0, 0);
                    parent.setChildLocalPosition(nextImage, 0, 0);
                },
            })
            .addTransitionMode(PushLeft, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    // SlideAwayLeft
                    var x = currentImage.width * (-t);
                    parent.setChildLocalPosition(currentImage, x, 0);

                    // SlideRight
                    var x = nextImage.width * (1 - t);
                    parent.setChildLocalPosition(nextImage, x, 0);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(currentImage, 0, 0);
                    parent.setChildLocalPosition(nextImage, 0, 0);
                },
            })
            .addTransitionMode(PushDown, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    // SlideAwayDown
                    var y = currentImage.height * (t);
                    parent.setChildLocalPosition(currentImage, 0, y);

                    // SlideUp
                    var y = nextImage.height * (t - 1);
                    parent.setChildLocalPosition(nextImage, 0, y);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(currentImage, 0, 0);
                    parent.setChildLocalPosition(nextImage, 0, 0);
                },
            })
            .addTransitionMode(PushUp, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    // SlideAwayUp
                    var y = currentImage.height * (-t);
                    parent.setChildLocalPosition(currentImage, 0, y);

                    // SlideDown
                    var y = nextImage.height * (1 - t);
                    parent.setChildLocalPosition(nextImage, 0, y);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalPosition(currentImage, 0, 0);
                    parent.setChildLocalPosition(nextImage, 0, 0);
                },
            });

    };

    var AddZoomModes = function (image) {
        image
            .addTransitionMode(ZoomOut, {
                ease: 'Linear', dir: 'out', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var scale = 1 - t;
                    parent.setChildLocalScale(currentImage, scale, scale);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalScale(currentImage, 1, 1);
                },
            })
            .addTransitionMode(ZoomIn, {
                ease: 'Linear', dir: 'in', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var scale = t;
                    parent.setChildLocalScale(nextImage, scale, scale);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalScale(nextImage, 1, 1);
                },
            })
            .addTransitionMode(ZoomInOut, {
                ease: 'Linear', dir: 'out', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.tint = 0;  // Turn nextImage to black
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var scale;
                    if (t < 0.5) {
                        scale = 1 - Yoyo$1(t);
                        parent.setChildLocalScale(currentImage, scale, scale);
                    } else {
                        if (currentImage.visible) {
                            parent.setChildVisible(currentImage, false);
                        }

                        scale = 1 - Yoyo$1(t);
                        parent.setChildLocalScale(nextImage, scale, scale);
                    }
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalScale(currentImage, 1, 1);
                    parent.setChildVisible(currentImage, true);
                    currentImage.tint = 0xffffff;

                    parent.setChildLocalScale(nextImage, 1, 1);
                    parent.setChildVisible(nextImage, true);
                    nextImage.tint = 0xffffff;
                },
            });


    };

    var AddFadeModes = function (image) {
        image
            .addTransitionMode(Fade$1, {
                ease: 'Linear', dir: 'out', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.tint = 0;  // Turn nextImage to black
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var tintGray;
                    if (t < 0.5) {
                        t = Yoyo$1(t);
                        tintGray = Math.floor(255 * (1 - t));
                        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
                    } else {
                        if (currentImage.visible) {
                            parent.setChildVisible(currentImage, false);
                        }

                        t = Yoyo$1(t);
                        tintGray = Math.floor(255 * (1 - t));
                        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
                    }
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildVisible(currentImage, true);
                    currentImage.tint = 0xffffff;

                    parent.setChildVisible(nextImage, true);
                    nextImage.tint = 0xffffff;
                },
            })
            .addTransitionMode(CrossFade, {
                ease: 'Linear', dir: 'out', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalAlpha(currentImage, 1 - t);
                    parent.setChildLocalAlpha(nextImage, t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.setChildLocalAlpha(currentImage, 1);
                },
            });

    };

    var CreateMask$7 = function (scene) {
        var maskGameObject = new CustomProgress(scene, {
            type: 'Graphics',
            create: [
                { name: 'rect', type: 'rectangle' },
            ],
            update: function () {
                var rect = this.getShape('rect')
                    .fillStyle(0xffffff);

                var t = 1 - this.value;
                switch (this.wipeMode) {
                    case 'right':
                        rect
                            .setSize(this.width * t, this.height)
                            .setTopLeftPosition(this.width - rect.width, 0);
                        break;

                    case 'left':
                        rect
                            .setSize(this.width * t, this.height)
                            .setTopLeftPosition(0, 0);
                        break;

                    case 'down':
                        rect
                            .setSize(this.width, this.height * t)
                            .setTopLeftPosition(0, this.height - rect.height);
                        break;

                    case 'up':
                        rect
                            .setSize(this.width, this.height * t)
                            .setTopLeftPosition(0, 0);
                        break;
                }
            },
        });
        return maskGameObject;
    };

    var AddWipeModes = function (image) {
        var maskGameObject = CreateMask$7(image.scene);

        image
            .once('destroy', function () {
                maskGameObject.destroy();
            })
            .addTransitionMode(WipeRight, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true);
                    parent.maskGameObject.wipeMode = 'right';
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            })
            .addTransitionMode(WipeLeft, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true);
                    parent.maskGameObject.wipeMode = 'left';
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            })
            .addTransitionMode(WipeDown, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true);
                    parent.maskGameObject.wipeMode = 'down';
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            })
            .addTransitionMode(WipeUp, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true);
                    parent.maskGameObject.wipeMode = 'up';
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            });

    };

    var CreateMask$6 = function (scene) {
        var maskGameObject = new CustomProgress(scene, {
            type: 'Graphics',
            create: [
                { name: 'rect', type: 'rectangle' },
            ],
            update: function () {
                this.getShape('rect')
                    .fillStyle(0xffffff)
                    .setSize(this.width * this.value, this.height * this.value)
                    .setCenterPosition(this.centerX, this.centerY);
            },
        });
        return maskGameObject;
    };

    var AddIrisModes = function (image) {
        var maskGameObject = CreateMask$6(image.scene);

        image
            .once('destroy', function () {
                maskGameObject.destroy();
            })
            .addTransitionMode(IrisOut, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            })
            .addTransitionMode(IrisIn, {
                ease: 'Linear', dir: 'in', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setNextImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(1 - t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            })
            .addTransitionMode(IrisInOut, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.tint = 0;  // Turn nextImage to black
                    parent.setCurrentImageMaskEnable(true);
                    parent.setNextImageMaskEnable(true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var tintGray;
                    if (t < 0.5) {
                        t = Yoyo$1(t);
                        tintGray = Math.floor(255 * (1 - t));
                        parent.maskGameObject.setValue(1 - t);
                        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;

                    } else {
                        if (currentImage.visible) {
                            parent.setChildVisible(currentImage, false);
                        }

                        t = Yoyo$1(t);
                        tintGray = Math.floor(255 * (1 - t));
                        parent.maskGameObject.setValue(1 - t);
                        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
                    }
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);

                    parent.setChildVisible(currentImage, true);
                    currentImage.tint = 0xffffff;

                    parent.setChildVisible(nextImage, true);
                    nextImage.tint = 0xffffff;
                },
            });
    };

    var CreateMask$5 = function (scene) {
        var maskGameObject = new CustomProgress(scene, {
            type: 'Graphics',
            create: [
                { name: 'pie', type: 'arc' },
            ],
            update: function () {
                var radius = Math.max(this.width, this.height) * 2;
                var deltaAngle = 90 * this.value;

                this.getShape('pie')
                    .fillStyle(0xffffff)
                    .setCenterPosition(this.centerX, 0)
                    .setRadius(radius)
                    .setAngle(90 - deltaAngle, 90 + deltaAngle)
                    .setPie();

            },
        });
        return maskGameObject;
    };

    var AddPieModes = function (image) {
        var maskGameObject = CreateMask$5(image.scene);

        image
            .once('destroy', function () {
                maskGameObject.destroy();
            })
            .addTransitionMode(PieOut, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            })
            .addTransitionMode(PieIn, {
                ease: 'Linear', dir: 'in', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setNextImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(1 - t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            })
            .addTransitionMode(PieInOut, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.tint = 0;  // Turn nextImage to black
                    parent.setCurrentImageMaskEnable(true);
                    parent.setNextImageMaskEnable(true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var tintGray;
                    if (t < 0.5) {
                        t = Yoyo$1(t);
                        tintGray = Math.floor(255 * (1 - t));
                        parent.maskGameObject.setValue(1 - t);
                        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
                    } else {
                        if (currentImage.visible) {
                            parent.setChildVisible(currentImage, false);
                        }

                        t = Yoyo$1(t);
                        tintGray = Math.floor(255 * (1 - t));
                        parent.maskGameObject.setValue(1 - t);
                        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
                    }
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);

                    parent.setChildVisible(currentImage, true);
                    currentImage.tint = 0xffffff;

                    parent.setChildVisible(nextImage, true);
                    nextImage.tint = 0xffffff;
                },
            });

    };

    var CreateMask$4 = function (scene, columns) {
        var maskGameObject = new CustomProgress(scene, {
            type: 'Graphics',
            create: {
                rectangle: columns
            },
            update: function () {
                var shapes = this.getShapes();
                var shapeWidth = this.width / columns;
                for (var i = 0; i < columns; i++) {
                    shapes[i]
                        .fillStyle(0xffffff)
                        .setSize(shapeWidth * this.value, this.height)
                        .setTopLeftPosition(shapeWidth * i, 0);
                }
            },
        });
        return maskGameObject;
    };

    var AddBlindsModes = function (image) {
        var maskGameObject = CreateMask$4(image.scene, 10);

        image
            .once('destroy', function () {
                maskGameObject.destroy();
            })
            .addTransitionMode(Blinds, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            });
    };

    var CreateMask$3 = function (scene, columns, rows) {
        var maskGameObject = new CustomProgress(scene, {
            type: 'Graphics',
            create: {
                rectangle: columns * rows
            },
            update: function () {
                var shapes = this.getShapes();
                var shapeWidth = this.width / columns,
                    shapeHeight = this.height / rows;
                for (var r = 0; r < rows; r++) {
                    for (var c = 0; c < columns; c++) {
                        shapes[c * rows + r]
                            .fillStyle(0xffffff)
                            .setSize(shapeWidth * this.value, shapeHeight * this.value)
                            .setCenterPosition(shapeWidth * (c + 0.5), shapeHeight * (r + 0.5));
                    }
                }
            },
        });
        return maskGameObject;
    };

    var AddSquaresModes = function (image) {
        var maskGameObject = CreateMask$3(image.scene, Math.ceil(image.width / 40), Math.ceil(image.height / 40));

        image
            .once('destroy', function () {
                maskGameObject.destroy();
            })
            .addTransitionMode(Squares, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            });
    };

    var CreateMask$2 = function (scene, columns, rows) {
        var maskGameObject = new CustomProgress(scene, {
            type: 'Graphics',
            create: {
                lines: columns * rows
            },
            update: function () {
                var shapes = this.getShapes();
                var shapeHalfWidth = this.width / (columns - 1),
                    shapeHelfHeight = this.height / rows;
                var shapeHeight = shapeHelfHeight * 2;
                var halfWidth = shapeHalfWidth * this.value,
                    halfHeight = shapeHelfHeight * this.value;
                for (var r = 0; r < rows; r++) {
                    for (var c = 0; c < columns; c++) {
                        var centerX = c * shapeHalfWidth;
                        var centerY = r * shapeHeight + (c % 2) * shapeHelfHeight;
                        shapes[c * rows + r]
                            .fillStyle(0xffffff)
                            .start(centerX + halfWidth, centerY)
                            .lineTo(centerX, centerY + halfHeight)
                            .lineTo(centerX - halfWidth, centerY)
                            .lineTo(centerX, centerY - halfHeight)
                            .lineTo(centerX + halfWidth, centerY)
                            .close();
                    }
                }
            },
        });
        return maskGameObject;
    };

    var AddDiamondsMode = function (image) {
        var maskGameObject = CreateMask$2(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));

        image
            .once('destroy', function () {
                maskGameObject.destroy();
            })
            .addTransitionMode(Diamonds, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            });
    };

    var CreateMask$1 = function (scene, columns, rows) {
        var maskGameObject = new CustomProgress(scene, {
            type: 'Graphics',
            create: {
                circle: columns * rows
            },
            update: function () {
                var shapes = this.getShapes();
                var shapeHalfWidth = this.width / (columns - 1),
                    shapeHelfHeight = this.height / rows;
                var shapeHeight = shapeHelfHeight * 2;
                var radius = Math.max(shapeHalfWidth, shapeHelfHeight) * this.value;
                for (var r = 0; r < rows; r++) {
                    for (var c = 0; c < columns; c++) {
                        var centerX = c * shapeHalfWidth;
                        var centerY = r * shapeHeight + (c % 2) * shapeHelfHeight;
                        shapes[c * rows + r]
                            .fillStyle(0xffffff)
                            .setCenterPosition(centerX, centerY)
                            .setRadius(radius);
                    }
                }
            },
        });
        return maskGameObject;
    };

    var AddCirclesMode = function (image) {
        var maskGameObject = CreateMask$1(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));

        image
            .once('destroy', function () {
                maskGameObject.destroy();
            })
            .addTransitionMode(Circles, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setCurrentImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    parent.maskGameObject.setValue(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);
                },
            });
    };

    var CreateMask = function (scene, columns) {
        var maskGameObject = new CustomProgress(scene, {
            type: 'Graphics',
            create: {
                lines: columns
            },
            update: function () {
                var shapes = this.getShapes();
                var shapeWidth = this.width / columns;
                var radius = shapeWidth / 2;
                for (var i = 0; i < columns; i++) {
                    var leftX = shapeWidth * i;
                    var bottomY = this.height * this.value;
                    var centerX = leftX + radius;
                    shapes[i]
                        .fillStyle(0xffffff)
                        .start(leftX, 0)
                        .horizontalLineTo(bottomY)
                        .arc(centerX, bottomY, radius, 180, 0, true)
                        .horizontalLineTo(-bottomY)
                        .lineTo(leftX, 0)
                        .close();
                }
            },
        });
        return maskGameObject;
    };

    var AddCurtainMode = function (image) {
        var maskGameObject = CreateMask(image.scene, 10);

        image
            .once('destroy', function () {
                maskGameObject.destroy();
            })
            .addTransitionMode(Curtain, {
                ease: 'Linear', dir: 'out', mask: maskGameObject,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.tint = 0;  // Turn nextImage to black
                    parent.setCurrentImageMaskEnable(true, true);
                    parent.setNextImageMaskEnable(true, true);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    var tintGray;
                    if (t < 0.5) {
                        t = Yoyo$1(t);
                        tintGray = Math.floor(255 * (1 - t));
                        parent.maskGameObject.setValue(t);
                        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;

                    } else {
                        if (currentImage.visible) {
                            parent.setChildVisible(currentImage, false);
                        }

                        t = Yoyo$1(t);
                        tintGray = Math.floor(255 * (1 - t));
                        parent.maskGameObject.setValue(t);
                        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
                    }
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    parent.removeMaskGameObject(false);

                    parent.setChildVisible(currentImage, true);
                    currentImage.tint = 0xffffff;

                    parent.setChildVisible(nextImage, true);
                    nextImage.tint = 0xffffff;
                },
            });
    };

    var AddPixellateMode = function (image) {
        image
            .addTransitionMode(Pixellate, {
                ease: 'Linear', dir: 'out', mask: true,

                onStart: function (parent, currentImage, nextImage, t) {
                    parent.setChildVisible(nextImage, false);
                    currentImage.effect = currentImage.preFX.addPixelate(0);
                    nextImage.effect = nextImage.preFX.addPixelate(0);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    if (t < 0.5) {
                        t = Yoyo$1(t);
                        var maxAmount = Math.min(currentImage.width, currentImage.height) / 5;
                        currentImage.effect.amount = Math.ceil(maxAmount * t);
                    } else {
                        if (currentImage.visible) {
                            parent.setChildVisible(currentImage, false);
                        }
                        if (!nextImage.visible) {
                            parent.setChildVisible(nextImage, true);
                        }

                        t = Yoyo$1(t);
                        var maxAmount = Math.min(nextImage.width, nextImage.height) / 5;
                        nextImage.effect.amount = Math.ceil(maxAmount * t);
                    }
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    currentImage.preFX.remove(currentImage.effect);
                    delete currentImage.effect;
                    parent.setChildVisible(currentImage, true);

                    nextImage.preFX.remove(nextImage.effect);
                    delete nextImage.effect;
                },
            });

    };

    // Reference: https://medium.com/neosavvy-labs/webgl-with-perlin-noise-part-1-a87b56bbc9fb
    const frag$1 = `\
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
float Perlin(vec3 P) {
    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0); gx1 = fract(gx1);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
}
float Perlin(vec2 P) { return Perlin(vec3(P, 0.0)); }
`;

    // https://github.com/ykob/glsl-dissolve/blob/master/src/glsl/dissolve.fs


    const frag = `\
#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
// Scene buffer
uniform sampler2D uMainSampler;
uniform sampler2D uMainSampler2;

uniform int resizeMode;
uniform float progress;
uniform float fromRatio;
uniform float toRatio;
varying vec2 outFragCoord;
// Effect parameters
uniform float noiseX;
uniform float noiseY;
uniform float noiseZ;
uniform float fromEdgeStart;
uniform float fromEdgeWidth;
uniform float toEdgeStart;
uniform float toEdgeWidth;

${frag$1}

vec4 getFromColor (vec2 uv) {
  return texture2D(uMainSampler, uv);
}

vec4 getToColor (vec2 uv) {
  if (resizeMode == 2) {
    //  cover
    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(min(fromRatio / toRatio, 1.0), min((toRatio / fromRatio), 1.0)));
  } else if (resizeMode == 1) {
    //  contain
    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(max(fromRatio / toRatio, 1.0), max((toRatio / fromRatio), 1.0)));
  } else {
    //  stretch
    return texture2D(uMainSampler2, vec2(uv.x, 1.0 - uv.y));
  }
}

vec4 transition (vec2 uv) {    
  vec4 colorFront = getFromColor(uv);
  vec4 colorTo = getToColor(uv);

  float noise = (Perlin(vec3(uv.x * noiseX, uv.y * noiseY, noiseZ)) + 1.0) / 2.0
    * (1.0 - (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth))
    + (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth) * 0.5;
  vec4 colorResult = colorFront * smoothstep(progress - (fromEdgeStart + fromEdgeWidth), progress - fromEdgeStart, noise)
    + colorTo * smoothstep((1.0 - progress) - (toEdgeStart + toEdgeWidth), (1.0 - progress) - toEdgeStart, (1.0 - noise));
  return colorResult;
}

void main () {
  vec2 uv = outFragCoord;
  gl_FragColor = transition(uv);
}
`;

    const PostFXPipeline = Phaser.Renderer.WebGL.Pipelines.PostFXPipeline;
    const GetValue$2c = Phaser.Utils.Objects.GetValue;
    const Clamp$9 = Phaser.Math.Clamp;

    class DissolvePostFxPipeline extends PostFXPipeline {
        constructor(game) {
            super({
                name: 'rexDissolvePostFx',
                game: game,
                renderTarget: true,
                fragShader: frag
            });

            this._progress = 0;
            this.toFrame = null;
            this.targetTexture = null;
            this.resizeMode = 1;
            this.toRatio = 1;

            this.noiseX = 0;
            this.noiseY = 0;
            this.noiseZ = 0;
            this.fromEdgeStart = 0.01;
            this.fromEdgeWidth = 0.05;
            this.toEdgeStart = 0.01;
            this.toEdgeWidth = 0.05;
        }

        resetFromJSON(o) {
            this.setProgress(GetValue$2c(o, 'progress', 0));
            this.setTransitionTargetTexture(GetValue$2c(o, 'toTexture', '__DEFAULT'), GetValue$2c(o, 'toFrame', undefined), GetValue$2c(o, 'resizeMode', 1));
            this.setNoise(GetValue$2c(o, 'noiseX', undefined), GetValue$2c(o, 'noiseY', undefined), GetValue$2c(o, 'noiseZ', undefined));
            this.setFromEdge(GetValue$2c(o, 'fromEdgeStart', 0.01), GetValue$2c(o, 'fromEdgeWidth', 0.05));
            this.setToEdge(GetValue$2c(o, 'toEdgeStart', 0.01), GetValue$2c(o, 'toEdgeWidth', 0.05));
            return this;
        }

        onBoot() {

        }

        onPreRender() {
            this.set1f('progress', this.progress);
            this.set1i('resizeMode', this.resizeMode);

            this.set1f('noiseX', this.noiseX);
            this.set1f('noiseY', this.noiseY);
            this.set1f('noiseZ', this.noiseZ);
            this.set1f('fromEdgeStart', this.fromEdgeStart);
            this.set1f('fromEdgeWidth', this.fromEdgeWidth);
            this.set1f('toEdgeStart', this.toEdgeStart);
            this.set1f('toEdgeWidth', this.toEdgeWidth);
        }

        onDraw(renderTarget) {
            this.set1f('fromRatio', renderTarget.width / renderTarget.height);

            this.set1f('toRatio', this.toRatio);

            this.set1i('uMainSampler2', 1);

            this.bindTexture(this.targetTexture, 1);

            this.bindAndDraw(renderTarget);
        }

        get progress() {
            return this._progress;
        }

        set progress(value) {
            this._progress = Clamp$9(value, 0, 1);
        }

        setProgress(value) {
            this.progress = value;
            return this;
        }

        setTransitionTargetTexture(key, frame, resizeMode) {
            if (key === undefined) {
                key = '__DEFAULT';
            }
            var phaserTexture = this.game.textures.getFrame(key, frame);

            if (!phaserTexture) {
                phaserTexture = this.game.textures.getFrame('__DEFAULT');
            }

            this.toRatio = phaserTexture.width / phaserTexture.height;

            this.toFrame = phaserTexture;
            this.targetTexture = phaserTexture.glTexture;

            if (resizeMode !== undefined) {
                this.resizeMode = resizeMode;
            }

            return this;
        }

        setResizeMode(mode) {
            if (typeof (mode) === 'string') {
                mode = ResizeMode[mode];
            }
            this.resizeMode = mode;
            return this;
        }

        setNoise(x, y, z) {
            if (x === undefined) {
                x = 4 + Math.random() * 6;
            }
            if (y === undefined) {
                y = 4 + Math.random() * 6;
            }
            if (z === undefined) {
                z = Math.random() * 10;
            }
            this.noiseX = x;
            this.noiseY = y;
            this.noiseZ = z;
            return this;
        }

        setFromEdge(edgeStart, edgeWidth) {
            this.fromEdgeStart = edgeStart;
            this.fromEdgeWidth = edgeWidth;
            return this;
        }

        setToEdge(edgeStart, edgeWidth) {
            this.toEdgeStart = edgeStart;
            this.toEdgeWidth = edgeWidth;
            return this;
        }
    }

    /**
     * Set the resize mode of the target texture.
     * 
     * Can be either:
     * 
     * 0 - Stretch. The target texture is stretched to the size of the source texture.
     * 1 - Contain. The target texture is resized to fit the source texture. This is the default.
     * 2 - Cover. The target texture is resized to cover the source texture.
     * 
     * If the source and target textures are the same size, then use a resize mode of zero
     * for speed.
     *
     */
    var ResizeMode = {
        stretch: 0,
        contain: 1,
        cover: 2
    };

    var RegisterPostPipeline = function (game, postFxPipelineName, PostFxPipelineClass) {
        GetGame(game).renderer.pipelines.addPostPipeline(postFxPipelineName, PostFxPipelineClass);
    };

    var AddPostFxPipelineInstance = function (gameObject, PostFxPipelineClass, config) {
        if (config === undefined) {
            config = {};
        }

        gameObject.setPostPipeline(PostFxPipelineClass);
        var pipeline = gameObject.postPipelines[gameObject.postPipelines.length - 1];
        pipeline.resetFromJSON(config);

        if (config.name) {
            pipeline.name = config.name;
        }

        return pipeline;
    };

    const SpliceOne$1 = Phaser.Utils.Array.SpliceOne;

    var RemovePostFxPipelineInstance = function (gameObject, PostFxPipelineClass, name) {
        if (name === undefined) {
            var pipelines = gameObject.postPipelines;
            for (var i = (pipelines.length - 1); i >= 0; i--) {
                var instance = pipelines[i];
                if (instance instanceof PostFxPipelineClass) {
                    instance.destroy();
                    SpliceOne$1(pipelines, i);
                }
            }
        } else {
            var pipelines = gameObject.postPipelines;
            for (var i = 0, cnt = pipelines.length; i < cnt; i++) {
                var instance = pipelines[i];
                if ((instance instanceof PostFxPipelineClass) && (instance.name === name)) {
                    instance.destroy();
                    SpliceOne$1(pipelines, i);
                }
            }
        }

        gameObject.hasPostPipeline = (gameObject.postPipelines.length > 0);

    };

    var AddDissolveMode = function (image) {
        RegisterPostPipeline(image.scene.game, 'rexDissolvePostFx', DissolvePostFxPipeline);

        image
            .addTransitionMode(Dissolve, {
                ease: 'Linear', dir: 'out', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                    currentImage.effect = AddPostFxPipelineInstance(currentImage, DissolvePostFxPipeline);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    currentImage.effect.setProgress(t);
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    RemovePostFxPipelineInstance(currentImage, DissolvePostFxPipeline);
                    delete currentImage.effect;
                },
            });
    };

    const WipeWidth = 0.1;
    const DirLeftToRight = 0;
    const DirTopToBottom = 0;
    const DirRightToLeft = 1;
    const DirBottomToTop = 1;
    const AxisX = 0;
    const AxisY = 1;

    var AddRevealModes = function (image) {
        image
            .addTransitionMode(RevealRight, {
                ease: 'Linear', dir: 'in', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirLeftToRight, AxisX);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    nextImage.effect.progress = t;
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    nextImage.preFX.remove(nextImage.effect);
                    delete nextImage.effect;
                },
            })
            .addTransitionMode(RevealLeft, {
                ease: 'Linear', dir: 'in', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirRightToLeft, AxisX);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    nextImage.effect.progress = t;
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    nextImage.preFX.remove(nextImage.effect);
                    delete nextImage.effect;
                },
            })
            .addTransitionMode(RevealDown, {
                ease: 'Linear', dir: 'in', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirTopToBottom, AxisY);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    nextImage.effect.progress = t;
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    nextImage.preFX.remove(nextImage.effect);
                    delete nextImage.effect;
                },
            })
            .addTransitionMode(RevealUp, {
                ease: 'Linear', dir: 'in', mask: false,

                onStart: function (parent, currentImage, nextImage, t) {
                    nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirBottomToTop, AxisY);
                },
                onProgress: function (parent, currentImage, nextImage, t) {
                    nextImage.effect.progress = t;
                },
                onComplete: function (parent, currentImage, nextImage, t) {
                    nextImage.preFX.remove(nextImage.effect);
                    delete nextImage.effect;
                },
            });

    };

    const Modes = [
        AddSlideAwayModes, AddSlideModes, AddSliderModes,
        AddZoomModes,
        AddFadeModes,
        AddIrisModes, AddPieModes, AddWipeModes,
        AddBlindsModes, AddSquaresModes, AddDiamondsMode, AddCirclesMode, AddCurtainMode,
        AddPixellateMode, AddDissolveMode, AddRevealModes
    ];

    class TransitionImagePack extends TransitionImage {
        constructor(scene, x, y, texture, frame, config) {
            super(scene, x, y, texture, frame, config);

            for (var i = 0, cnt = Modes.length; i < cnt; i++) {
                Modes[i](this);
            }
        }
    }

    ObjectFactory.register('transitionImagePack', function (x, y, texture, frame, config) {
        var gameObject = new TransitionImagePack(this.scene, x, y, texture, frame, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TransitionImagePack', TransitionImagePack);

    var ScaleImage = function () {
        var image = this.image;

        if ((!this.scaleUp) &&
            (image.width <= this.width) && (image.height <= this.height)
        ) {
            return this;
        }

        var result = FitTo(image, this, 'FIT', true);
        image.setDisplaySize(result.width, result.height);
        this.resetChildScaleState(image);
        return this;
    };

    var methods$r = {
        scaleImage: ScaleImage
    };

    Object.assign(
        methods$r,
        FlipMethods
    );

    var ResizeBackground = function () {
        var background = this.background;
        if (!background) {
            return this;
        }

        background.setOrigin(this.originX, this.originY);
        background.setPosition(this.x, this.y);
        ResizeGameObject(background, this.displayWidth, this.displayHeight);
        this.resetChildScaleState(background);
        return this;
    };

    const IsPlainObject$n = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$2b = Phaser.Utils.Objects.GetValue;

    class ImageBox extends ContainerLite {
        constructor(scene, x, y, texture, frame, config) {
            if (IsPlainObject$n(x)) {
                config = x;
                x = GetValue$2b(config, 'x', 0);
                y = GetValue$2b(config, 'y', 0);
                texture = GetValue$2b(config, 'key', undefined);
                frame = GetValue$2b(config, 'frame', undefined);
            } else if (IsPlainObject$n(frame)) {
                config = frame;
                frame = undefined;
            }

            var image = GetValue$2b(config, 'image');
            if (!image) {
                image = scene.add.image(x, y, texture, frame);
                if (texture === undefined) {
                    image.setVisible(false);
                }
            } else {
                image.setPosition(x, y).setOrigin(0.5);
            }

            super(scene, x, y, 1, 1);
            this.type = 'rexImageBox';

            var background = GetValue$2b(config, 'background');
            if (background) {
                this.add(background);
            }
            this.background = background;

            this.add(image);
            this.image = image;

            this.scaleUp = GetValue$2b(config, 'scaleUp', false);

            var width = GetValue$2b(config, 'width', image.width);
            var height = GetValue$2b(config, 'height', image.height);
            this.resize(width, height);

        }

        get texture() {
            return this.image.texture;
        }

        get frame() {
            return this.image.frame;
        }

        get flipX() {
            return this._flipX;
        }

        set flipX(value) {
            if (this._flipX === value) {
                return;
            }

            this._flipX = value;
            this.image.setFlipX(value);
        }

        get flipY() {
            return this._flipY;
        }

        set flipY(value) {
            if (this._flipY === value) {
                return;
            }
            this._flipY = value;
            this.image.setFlipY(value);
        }

        resize(width, height) {
            super.resize(width, height);

            ResizeBackground.call(this);
            this.scaleImage();
            return this;
        }

        setTexture(texture, frame) {
            var image = this.image;
            image.setTexture(texture, frame);

            if (texture !== null) {
                this.setChildVisible(image, true);
                this.scaleImage();

            } else {
                this.setChildVisible(image, false);

            }
            return this;
        }
    }

    Object.assign(
        ImageBox.prototype,
        methods$r,
    );

    ObjectFactory.register('imageBox', function (x, y, texture, frame, config) {
        var gameObject = new ImageBox(this.scene, x, y, texture, frame, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ImageBox', ImageBox);

    ObjectFactory.register('fullWindowRectangle', function (fillColor, fillAlpha) {
        var gameObject = new FullWindowRectangle(this.scene, fillColor, fillAlpha);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.FullWindowRectangle', FullWindowRectangle);

    ObjectFactory.register('fullWindowZone', function () {
        var gameObject = new FullWindowRectangle$1(this.scene);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.FullWindowZone', FullWindowRectangle$1);

    ObjectFactory.register('cover', function (config) {
        var gameObject = new Cover(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Cover', Cover);

    var Resize = function (width, height) {
        if (this.scene.sys.scale.autoRound) {
            width = Math.floor(width);
            height = Math.floor(height);
        }

        if ((this.width === width) && (this.height === height)) {
            return this;
        }

        var style = this.node.style;
        style.width = `${width}px`;
        style.height = `${height}px`;
        this.updateSize();
        return this;
    };

    const ElementProperties = {
        id: ['id', undefined],
        text: ['value', undefined],
        maxLength: ['maxLength', undefined],
        minLength: ['minLength', undefined],
        placeholder: ['placeholder', undefined],
        tooltip: ['title', undefined],
        readOnly: ['readOnly', false],
        spellCheck: ['spellcheck', false],
        autoComplete: ['autocomplete', 'off'],
        autoCapitalize: ['autocapitalize', 'off']
    };

    const StyleProperties = {
        align: ['textAlign', undefined],
        paddingLeft: ['padding-left', undefined],
        paddingRight: ['padding-right', undefined],
        paddingTop: ['padding-top', undefined],
        paddingBottom: ['padding-bottom', undefined],
        fontFamily: ['fontFamily', undefined],
        fontSize: ['font-size', undefined],
        color: ['color', '#ffffff'],
        backgroundColor: ['backgroundColor', 'transparent'],
        border: ['border', 0],
        borderColor: ['borderColor', 'transparent'],
        borderRadius: ['border-radius', undefined],
        outline: ['outline', 'none'],
        direction: ['direction', undefined]
    };

    const ElementEvents = {
        input: 'textchange',

        click: 'click',
        dblclick: 'dblclick',

        mousedown: 'pointerdown',
        mousemove: 'pointermove',
        mouseup: 'pointerup',

        touchstart: 'pointerdown',
        touchmove: 'pointermove',
        touchend: 'pointerup',

        keydown: 'keydown',
        keyup: 'keyup',
        keypress: 'keypress',

        compositionstart: 'compositionStart',
        compositionend: 'compositionEnd',
        compositionupdate: 'compositionUpdate',

        focus: 'focus',
        blur: 'blur',

        select: 'select',
    };

    const GetValue$2a = Phaser.Utils.Objects.GetValue;

    var RouteEvents = function (gameObject, element, elementEvents, config) {
        var preventDefault = GetValue$2a(config, 'preventDefault', false);
        var preTest = GetValue$2a(config, 'preTest');
        for (let elementEventName in elementEvents) {  // Note: Don't use `var` here
            element.addEventListener(elementEventName, function (e) {
                if (!preTest || preTest(gameObject, elementEventName)) {
                    gameObject.emit(elementEvents[elementEventName], gameObject, e);
                }

                if (preventDefault) {
                    e.preventDefault();
                }
            });
        }
    };

    const DOMElement$2 = Phaser.GameObjects.DOMElement;
    const IsPlainObject$m = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$29 = Phaser.Utils.Objects.GetValue;

    class InputText extends DOMElement$2 {
        constructor(scene, x, y, width, height, config) {
            if (IsPlainObject$m(x)) {
                config = x;
                x = GetValue$29(config, 'x', 0);
                y = GetValue$29(config, 'y', 0);
                width = GetValue$29(config, 'width', 0);
                height = GetValue$29(config, 'height', 0);
            } else if (IsPlainObject$m(width)) {
                config = width;
                width = GetValue$29(config, 'width', 0);
                height = GetValue$29(config, 'height', 0);
            }

            if (config === undefined) {
                config = {};
            }

            var element;
            var textType = GetValue$29(config, 'inputType', undefined);
            if (textType === undefined) {
                textType = GetValue$29(config, 'type', 'text');
            }

            if (textType === 'textarea') {
                element = document.createElement('textarea');
                element.style.resize = 'none';
            } else {
                element = document.createElement('input');
                element.type = textType;
            }

            SetProperties(ElementProperties, config, element);

            var style = GetValue$29(config, 'style', undefined);
            style = SetProperties(StyleProperties, config, style);
            // Apply other style properties
            var elementStyle = element.style;
            for (var key in config) {
                if ((key in ElementProperties) || (key in StyleProperties)) {
                    continue;
                } else if (key in elementStyle) {
                    style[key] = config[key];
                } else if (key in element) {
                    if (key === 'type') {
                        continue;
                    }
                    element[key] = config[key];
                }
            }
            style['box-sizing'] = 'border-box';
            super(scene, x, y, element, style);
            this.type = 'rexInputText';
            this.resize(width, height);

            // Apply events
            RouteEvents(this, element, ElementEvents);

            // Don't propagate touch/mouse events to parent(game canvas)
            StopPropagationTouchEvents(element);

            if (GetValue$29(config, 'selectAll', false)) {
                this.selectAll();
            }

            this._isFocused = false;
            this
                .on('focus', function () {
                    this._isFocused = true;
                }, this)
                .on('blur', function () {
                    this._isFocused = false;
                }, this);

        }

        get inputType() {
            if (this.node.tagName.toLowerCase() === 'textarea') {
                return 'textarea';
            } else {
                return this.node.type;
            }
        }

        get text() {
            return this.node.value;
        }

        set text(value) {
            this.node.value = value;
        }

        setText(value) { // Override
            this.text = value;
            return this;
        }

        get maxLength() {
            return this.node.maxLength;
        }

        set maxLength(value) {
            this.node.maxLength = value;
        }

        setMaxLength(value) {
            this.maxLength = value;
            return this;
        }

        get minLength() {
            return this.node.minLength;
        }

        set minLength(value) {
            this.node.minLength = value;
        }

        setMinLength(value) {
            this.minLength = value;
            return this;
        }

        get placeholder() {
            return this.node.placeholder;
        }

        set placeholder(value) {
            this.node.placeholder = value;
        }

        setPlaceholder(value) {
            this.placeholder = value;
            return this;
        }

        selectText(selectionStart, selectionEnd) {
            if (selectionStart === undefined) {
                this.node.select();
            } else {
                this.node.setSelectionRange(selectionStart, selectionEnd);
            }
            return this;
        }

        selectAll() {
            this.selectText();
            return this;
        }

        get selectionStart() {
            return this.node.selectionStart;
        }

        get selectionEnd() {
            return this.node.selectionEnd;
        }

        get selectedText() {
            var node = this.node;
            return node.value.substring(node.selectionStart, node.selectionEnd);
        }

        get cursorPosition() {
            return this.node.selectionStart;
        }

        set cursorPosition(value) {
            this.node.setSelectionRange(value, value);
        }

        setCursorPosition(value) {
            if (value === undefined) {
                value = this.text.length;
            } else if (value < 0) {
                value = this.text.length + value;
            }

            this.cursorPosition = value;
            return this;
        }

        get tooltip() {
            return this.node.title;
        }

        set tooltip(value) {
            this.node.title = value;
        }

        setTooltip(value) {
            this.tooltip = value;
            return this;
        }

        setTextChangedCallback(callback) {
            this.onTextChanged = callback;
            return this;
        }

        get readOnly() {
            return this.node.readOnly;
        }

        set readOnly(value) {
            this.node.readOnly = value;
        }

        setReadOnly(value) {
            if (value === undefined) {
                value = true;
            }
            this.readOnly = value;
            return this;
        }

        get spellCheck() {
            return this.node.spellcheck;
        }

        set spellCheck(value) {
            this.node.spellcheck = value;
        }

        setSpellCheck(value) {
            this.spellCheck = value;
            return this;
        }

        get fontColor() {
            return this.node.style.color;
        }

        set fontColor(value) {
            this.node.style.color = value;
        }

        setFontColor(value) {
            this.fontColor = value;
            return this;
        }

        setStyle(key, value) {
            this.node.style[key] = value;
            return this;
        }

        getStyle(key) {
            return this.node.style[key];
        }

        scrollToBottom() {
            this.node.scrollTop = this.node.scrollHeight;
            return this;
        }

        setEnabled(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.node.disabled = !enabled;
            return this;
        }

        setBlur() {
            this.node.blur();
            return this;
        }

        setFocus() {
            this.node.focus();
            return this;
        }

        get isFocused() {
            return this._isFocused;
        }

    }

    var methods$q = {
        resize: Resize
    };

    Object.assign(
        InputText.prototype,
        methods$q
    );

    ObjectFactory.register('inputText', function (config) {
        var gameObject = new InputText(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.InputText', InputText);

    const GetValue$28 = Phaser.Utils.Objects.GetValue;

    var CreateFileInput = function (game, config) {
        var fileInput = document.createElement('input');
        fileInput.type = 'file';

        var accept = GetValue$28(config, 'accept', '');
        var multiple = GetValue$28(config, 'multiple', false);

        fileInput.setAttribute('accept', accept);
        if (multiple) {
            fileInput.setAttribute('multiple', '');
        } else {
            fileInput.removeAttribute('multiple');
        }

        return fileInput;
    };

    var Delay = function (time, result) {
        if (time === undefined) {
            time = 0;
        }
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve(result);
            }, time);
        });
    };

    var ClickPromise = function ({ game, fileInput, closeDelay }) {
        return WaitEvent(GetGame(game).events, 'focus')
            .then(function () {
                return Delay(closeDelay);
            })
            .then(function () {
                var result = {
                    files: fileInput.files
                };

                return Promise.resolve(result);
            })
    };

    // Note: Not working in iOS9+


    const GetValue$27 = Phaser.Utils.Objects.GetValue;
    const RemoveFromDOM = Phaser.DOM.RemoveFromDOM;

    var Open$1 = function (game, config) {
        // game: game, scene, or game object
        var closeDelay = GetValue$27(config, 'closeDelay', 200);
        var fileInput = CreateFileInput(game, config);
        fileInput.click();
        return ClickPromise({ game, fileInput, closeDelay })
            .then(function (result) {
                RemoveFromDOM(fileInput);
                fileInput.remove();
                return Promise.resolve(result);
            })
    };

    var SyncTo = function (gameObject) {
        this.setOrigin(gameObject.originX, gameObject.originY);
        this.setPosition(gameObject.x, gameObject.y);
        this.resize(gameObject.displayWidth, gameObject.displayHeight);
        return this;
    };

    var GetCache = function (game, loaderType, cacheType) {
        if (cacheType === undefined) {
            switch (loaderType) {
                case 'image':
                case 'svg':
                    cacheType = 'textures';
                    break;

                case 'animation':
                    cacheType = 'json';
                    break;

                case 'tilemapTiledJSON':
                case 'tilemapCSV':
                    cacheType = 'tilemap';
                    break;

                case 'glsl':
                    cacheType = 'shader';
                    break;

                default:
                    cacheType = loaderType;
                    break;
            }
        }

        game = GetGame(game);
        var cache;
        if (cacheType === 'textures') {
            cache = game.textures;
        } else {
            cache = game.cache[cacheType];
        }
        return cache;
    };

    var FileObjectToCache = function (scene, file, loaderType, key, cacheType, onComplete) {
        // Remove data from cache
        if ((cacheType === null) || (cacheType === false)) ; else if (IsFunction(cacheType)) {
            cacheType();
        } else {
            var cache = GetCache(scene, loaderType, cacheType);
            if (cache.exists(key)) {
                cache.remove(key);
            }
        }

        // Add filecomplete event
        var loader = scene.load;
        if (onComplete) {
            loader.once(`filecomplete-${loaderType}-${key}`, function (key, type, data) {
                onComplete(data);
            });
        }

        // Load file from url
        if (IsFunction(file)) {
            file();
        } else {
            var url = window.URL.createObjectURL(file);
            loader[loaderType](key, url);
        }

        loader.start();
    };

    var LoadFile = function (file, loaderType, key, cacheType, onComplete) {
        var scene = this.scene;
        FileObjectToCache(scene, file, loaderType, key, cacheType, onComplete);

        return this;
    };

    var LoadFilePromise = function (file, loaderType, key, cacheType) {
        var scene = this.scene;
        return new Promise(function (resolve, reject) {
            var onComplete = function (data) {
                resolve(data);
            };
            FileObjectToCache(scene, file, loaderType, key, cacheType, onComplete);
        });
    };

    var LoadFileMethods = {
        loadFile: LoadFile,
        loadFilePromise: LoadFilePromise,
    };

    const DOMElement$1 = Phaser.GameObjects.DOMElement;
    const IsPlainObject$l = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$26 = Phaser.Utils.Objects.GetValue;

    class FileChooser extends DOMElement$1 {
        constructor(scene, x, y, width, height, config) {
            if (IsPlainObject$l(x)) {
                config = x;
                x = GetValue$26(config, 'x', 0);
                y = GetValue$26(config, 'y', 0);
                width = GetValue$26(config, 'width', 0);
                height = GetValue$26(config, 'height', 0);
            } else if (IsPlainObject$l(width)) {
                config = width;
                width = GetValue$26(config, 'width', 0);
                height = GetValue$26(config, 'height', 0);
            }

            // Create a hidden file input
            var inputElement = document.createElement('input');
            inputElement.type = 'file';
            var inputStyle = inputElement.style;
            inputStyle.display = 'none';

            // Create a label parent
            var labelElement = document.createElement('label');
            labelElement.appendChild(inputElement);

            var style = GetValue$26(config, 'style', undefined);
            super(scene, x, y, labelElement, style);
            this.type = 'rexFileChooser';
            this.resetFromJSON(config);
            this.resize(width, height);

            // Register events
            var self = this;
            inputElement.onchange = function () {
                self.emit('change', self);
            };

            this.setCloseDelay(GetValue$26(config, 'closeDelay', 200));
            inputElement.onclick = function () {
                ClickPromise({
                    game: scene,
                    fileInput: inputElement,
                    closeDelay: self.closeDelay
                })
                    .then(function () {
                        self.emit('select', self);
                    });
            };
        }

        resetFromJSON(config) {
            this.setAccept(GetValue$26(config, 'accept', ''));
            this.setMultiple(GetValue$26(config, 'multiple', false));
            return this;
        }

        setAccept(accept) {
            if (accept === undefined) {
                accept = '';
            }
            this.fileInput.setAttribute('accept', accept);
            return this;
        }

        setMultiple(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            if (enabled) {
                this.fileInput.setAttribute('multiple', '');
            } else {
                this.fileInput.removeAttribute('multiple');
            }
            return this;
        }

        setCloseDelay(delay) {
            if (delay === undefined) {
                delay = 200;
            }
            this.closeDelay = delay;
            return this;
        }

        get fileInput() {
            return this.node.children[0];
        }

        open() { // Only work under any touch event
            this.fileInput.click();
            return this;
        }

        get files() {
            return this.fileInput.files;
        }

        setOpenEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.fileInput.disabled = !enable;
            return this;
        }
    }

    var methods$p = {
        resize: Resize,
        syncTo: SyncTo,
    };

    Object.assign(
        FileChooser.prototype,
        methods$p,
        LoadFileMethods,
    );

    ObjectFactory.register('fileChooser', function (config) {
        var gameObject = new FileChooser(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.FileChooser', FileChooser);

    var DropEnableMethods = {
        setDropEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            this.dropEnable = enable;
            return this;
        },

        toggleDropEnable() {
            this.dropEnable = !this.dropEnable;
            return this;
        },
    };

    var FilterMethods = {
        addFilter(name, callback) {
            if (!this.filters) {
                this.filters = {};
            }
            this.filters[name] = callback;
            return this;
        },

        addFilters(filters) {
            if (!this.filters) {
                this.filters = {};
            }
            for (var name in filters) {
                this.filters[name] = filters[name];
            }
            return this;
        },
    };

    var Methods$9 = {
        resize: Resize,
        syncTo: SyncTo,
    };

    Object.assign(
        Methods$9,
        DropEnableMethods,
        FilterMethods,
        LoadFileMethods,
    );

    const DragDropEvents = {
        dragenter: 'dragenter',
        dragleave: 'dragleave',
        dragover: 'dragover',
        drop: 'drop',
    };

    const DOMElement = Phaser.GameObjects.DOMElement;
    const IsPlainObject$k = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$25 = Phaser.Utils.Objects.GetValue;

    class FileDropZone extends DOMElement {
        constructor(scene, x, y, width, height, config) {
            if (IsPlainObject$k(x)) {
                config = x;
                x = GetValue$25(config, 'x', 0);
                y = GetValue$25(config, 'y', 0);
                width = GetValue$25(config, 'width', 0);
                height = GetValue$25(config, 'height', 0);
            } else if (IsPlainObject$k(width)) {
                config = width;
                width = GetValue$25(config, 'width', 0);
                height = GetValue$25(config, 'height', 0);
            }

            if (config === undefined) {
                config = {};
            }

            var element = document.createElement('div');

            var style = GetValue$25(config, 'style', undefined);
            super(scene, x, y, element, style);
            this.type = 'rexFileDropZone';
            this.resize(width, height);

            this._files = [];
            this.setDropEnable(GetValue$25(config, 'dropEnable', true));

            var filters = GetValue$25(config, 'filters');
            if (filters) {
                this.addFilters(filters);
            }

            // Apply events
            RouteEvents(this, element, DragDropEvents, {
                preventDefault: true,
                preTest(gameObject) { return gameObject.dropEnable; }
            });

            this
                .on('drop', function (gameObject, e) {
                    this._files = e.dataTransfer.files;
                    var files = this._files;
                    if (files && this.filters) {
                        for (var filterType in this.filters) {
                            var filterCallback = this.filters[filterType];

                            var filteredFiles = [];
                            for (var i = 0, cnt = files.length; i < cnt; i++) {
                                var file = files[i];
                                if (filterCallback(file, files)) {
                                    filteredFiles.push(file);
                                }
                            }

                            if (filteredFiles.length > 0) {
                                this.emit(`drop.${filterType}`, filteredFiles);
                            }
                        }
                    }
                }, this);
        }

        get files() {
            return this._files;
        }
    }

    Object.assign(
        FileDropZone.prototype,
        Methods$9,
    );

    ObjectFactory.register('fileDropZone', function (config) {
        var gameObject = new FileDropZone(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.FileDropZone', FileDropZone);

    var GetChildrenWidth$3 = function (minimumMode) {
        if (this.rexSizer.hidden) {
            return 0;
        }

        if (minimumMode === undefined) {
            minimumMode = true;
        }

        var result = 0;
        var children = this.sizerChildren;
        var child, sizerConfig, proportion, padding, childWidth;
        var hasUnknownChildWidth = false;
        this.childrenProportion; // To update this.hasProportion0Child member

        if (this.orientation === 0) { // x
            // Get summation of minimum width
            var isFirstChild = true;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = children[i];
                if (!child.hasOwnProperty('rexSizer')) {
                    continue;
                }

                sizerConfig = child.rexSizer;
                if (sizerConfig.hidden) {
                    continue;
                }

                proportion = sizerConfig.proportion;
                if ((proportion === 0) || minimumMode) {
                    childWidth = this.getChildWidth(child);
                    if ((sizerConfig.fitRatio > 0) && (!sizerConfig.resolved)) {
                        childWidth = undefined;
                    }

                    if (childWidth === undefined) {
                        if ((proportion !== 0) && (!this.hasProportion0Child)) {
                            childWidth = 0;
                        } else {
                            hasUnknownChildWidth = true;
                        }
                    }
                } else {
                    childWidth = 0;
                }

                if (hasUnknownChildWidth) {
                    continue;
                }

                padding = child.rexSizer.padding;
                childWidth += (padding.left + padding.right) * this.scaleX;

                if (isFirstChild) {
                    isFirstChild = false;
                } else {
                    childWidth += (this.space.item * this.scaleX);
                }

                result += childWidth;
            }
        } else {
            // Get maximun width
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = children[i];
                if (!child.hasOwnProperty('rexSizer')) {
                    continue;
                }

                sizerConfig = child.rexSizer;
                if (sizerConfig.hidden) {
                    continue;
                }

                childWidth = this.getChildWidth(child);
                if (childWidth === undefined) {
                    hasUnknownChildWidth = true;
                }

                if (hasUnknownChildWidth) {
                    continue;
                }

                padding = sizerConfig.padding;
                childWidth += (padding.left + padding.right) * this.scaleX;

                result = Math.max(childWidth, result);
            }
        }

        if (hasUnknownChildWidth) {
            return undefined;
        }

        return result + (this.space.left + this.space.right) * this.scaleX;
    };

    var GetChildrenHeight$3 = function (minimumMode) {
        if (this.rexSizer.hidden) {
            return 0;
        }

        if (minimumMode === undefined) {
            minimumMode = true;
        }

        var result = 0;
        var children = this.sizerChildren;
        var child, sizerConfig, proportion, padding, childHeight;
        var hasUnknownChildHeight = false;
        this.childrenProportion; // To update this.hasProportion0Child member

        if (this.orientation === 0) { // x
            // Get maximun height
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = children[i];
                if (!child.hasOwnProperty('rexSizer')) {
                    continue;
                }

                sizerConfig = child.rexSizer;
                if (sizerConfig.hidden) {
                    continue;
                }

                childHeight = this.getChildHeight(child);
                if (childHeight === undefined) {
                    hasUnknownChildHeight = true;
                }

                if (hasUnknownChildHeight) {
                    continue;
                }

                padding = sizerConfig.padding;
                childHeight += (padding.top + padding.bottom) * this.scaleY;
                result = Math.max(childHeight, result);
            }
        } else {
            // Get summation of minimum height
            var isFirstChild = true;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = children[i];
                if (!child.hasOwnProperty('rexSizer')) {
                    continue;
                }

                sizerConfig = child.rexSizer;
                if (sizerConfig.hidden) {
                    continue;
                }

                proportion = sizerConfig.proportion;
                if ((proportion === 0) || minimumMode) {
                    childHeight = this.getChildHeight(child);
                    if ((sizerConfig.fitRatio > 0) && (!sizerConfig.resolved)) {
                        childHeight = undefined;
                    }

                    if (childHeight === undefined) {
                        if ((proportion !== 0) && (!this.hasProportion0Child)) {
                            childHeight = 0;
                        } else {
                            hasUnknownChildHeight = true;
                        }
                    }
                } else {
                    childHeight = 0;
                }

                if (hasUnknownChildHeight) {
                    continue;
                }

                padding = sizerConfig.padding;
                childHeight += (padding.top + padding.bottom) * this.scaleY;

                if (isFirstChild) {
                    isFirstChild = false;
                } else {
                    childHeight += (this.space.item * this.scaleY);
                }

                result += childHeight;
            }
        }

        if (hasUnknownChildHeight) {
            return undefined;
        }

        return result + (this.space.top + this.space.bottom) * this.scaleY;
    };

    var GetExpandedChildWidth$2 = function (child, parentWidth) {
        if (parentWidth === undefined) {
            parentWidth = this.width * this.scaleX;
        }

        var childWidth;
        var sizerConfig = child.rexSizer;
        if (this.orientation === 0) { // x
            if ((sizerConfig.proportion > 0) && (this.proportionLength > 0)) {
                childWidth = (sizerConfig.proportion * this.proportionLength);
            }
        } else { // y
            if (sizerConfig.expand) {
                var space = this.space;
                var innerWidth = parentWidth - (space.left + space.right) * this.scaleX;
                var padding = sizerConfig.padding;
                childWidth = innerWidth - (padding.left + padding.right) * this.scaleX;
            }
        }
        return childWidth;
    };

    var GetExpandedChildHeight$2 = function (child, parentHeight) {
        if (parentHeight === undefined) {
            parentHeight = this.height;
        }

        var childHeight;
        var sizerConfig = child.rexSizer;
        if (this.orientation === 0) { // x
            if (sizerConfig.expand) {
                var space = this.space;
                var innerHeight = parentHeight - ((space.top + space.bottom) * this.scaleY);
                var padding = sizerConfig.padding;
                childHeight = innerHeight - ((padding.top + padding.bottom) * this.scaleY);
            }
        } else { // y
            if ((sizerConfig.proportion > 0) && (this.proportionLength > 0)) {
                childHeight = (sizerConfig.proportion * this.proportionLength);
            }
        }
        return childHeight;
    };

    var GetChildrenSizers$3 = function(out) {
        if (out === undefined) {
            out = [];
        }
        var children = this.sizerChildren,
            child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.isRexSizer) {
                out.push(child);
            }
        }
        return out;
    };

    var PreLayout$3 = function () {
        // Resize child to 1x1 for ratio-fit 
        this.hasRatioFitChild = false;
        var child, sizerConfig;
        var children = this.sizerChildren;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            sizerConfig = child.rexSizer;
            if (sizerConfig.hidden) {
                continue;
            }

            if (sizerConfig.fitRatio > 0) {
                ResizeGameObject(child, 0, 0);
                sizerConfig.resolved = false;
                this.hasRatioFitChild = true;
            }

        }

        this._childrenProportion = undefined;
        this.hasProportion0Child = false;
        this.proportionLength = undefined; // Display proportion-length, contains scale
        PreLayout$4.call(this);
        return this;
    };

    const Wrap$1 = Phaser.Math.Wrap;

    var LayoutChildren$4 = function () {
        var children = this.sizerChildren;
        var child, childConfig, padding;
        var startX = this.innerLeft,
            startY = this.innerTop;
        var innerWidth = this.innerWidth;
        var innerHeight = this.innerHeight;
        var itemX = startX,
            itemY = startY;
        var x, y, width, height, alignOffsetX, alignOffsetY; // Align zone
        var childWidth, childHeight;
        var childIndex, startChildIndex = this.startChildIndex;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            if (startChildIndex === 0) {
                childIndex = i;
            } else {
                childIndex = Wrap$1((i + startChildIndex), 0, cnt);
            }

            if (this.rtl) {
                childIndex = cnt - childIndex - 1;
            }

            child = children[childIndex];
            if (child.rexSizer.hidden) {
                continue;
            }

            childConfig = child.rexSizer;
            padding = childConfig.padding;

            PreLayoutChild.call(this, child);

            // Set size
            if (child.isRexSpace) {
                childWidth = 0;
                childHeight = 0;
            } else {
                childWidth = this.getExpandedChildWidth(child);
                childHeight = this.getExpandedChildHeight(child);
            }
            if (child.isRexSizer) {
                child.runLayout(this, childWidth, childHeight);
                CheckSize(child, this);
            } else {
                ResizeGameObject(child, childWidth, childHeight);
            }

            if (childWidth === undefined) {
                childWidth = GetDisplayWidth(child);
            }
            if (childHeight === undefined) {
                childHeight = GetDisplayHeight(child);
            }

            // Set position
            if (this.orientation === 0) { // x
                x = itemX + (padding.left * this.scaleX);
                if ((childConfig.proportion === 0) || (this.proportionLength === 0)) {
                    width = childWidth;
                } else {
                    width = (childConfig.proportion * this.proportionLength);
                }

                y = itemY + (padding.top * this.scaleY);
                height = innerHeight - ((padding.top + padding.bottom) * this.scaleY);
            } else { // y
                x = itemX + (padding.left * this.scaleX);
                width = innerWidth - ((padding.left + padding.right) * this.scaleX);

                y = itemY + (padding.top * this.scaleY);
                if ((childConfig.proportion === 0) || (this.proportionLength === 0)) {
                    height = childHeight;
                } else {
                    height = (childConfig.proportion * this.proportionLength);
                }
            }

            if (childWidth === undefined) {
                childWidth = GetDisplayWidth(child);
            }
            if (childHeight === undefined) {
                childHeight = GetDisplayHeight(child);
            }
            alignOffsetX = (childConfig.alignOffsetX + (childConfig.alignOffsetOriginX * childWidth)) * this.scaleX;
            alignOffsetY = (childConfig.alignOffsetY + (childConfig.alignOffsetOriginY * childHeight)) * this.scaleY;

            LayoutChild.call(this,
                child, x, y, width, height, childConfig.align,
                alignOffsetX, alignOffsetY
            );

            if (this.orientation === 0) { // x
                itemX += (width + ((padding.left + padding.right) * this.scaleX) + (this.space.item * this.scaleX));
            } else { // y
                itemY += (height + ((padding.top + padding.bottom) * this.scaleY) + (this.space.item * this.scaleY));
            }
        }

    };

    var ResolveWidth$1 = function (width) {
        var width = ResolveWidth$3.call(this, width);

        // Calculate proportionLength
        if ((width !== undefined) && (this.orientation === 0) && (this.proportionLength === undefined)) {
            var remainder = width - this.childrenWidth;
            if (remainder > 0) {
                remainder = width - this.getChildrenWidth(false);
                this.proportionLength = remainder / this.childrenProportion;
            } else {
                this.proportionLength = 0;
            }
        }

        return width;
    };

    var ResolveHeight$1 = function (height) {
        var height = ResolveHeight$3.call(this, height);

        // Get proportionLength
        if ((height !== undefined) && (this.orientation === 1) && (this.proportionLength === undefined)) {
            var remainder = height - this.childrenHeight;
            if (remainder > 0) {
                remainder = height - this.getChildrenHeight(false);            
                this.proportionLength = remainder / this.childrenProportion;
            } else {
                this.proportionLength = 0;
            }
        }

        return height;
    };

    var HasWidthWrap$1 = function () {
        if (this.hasRatioFitChild && (this.orientation === 1)) {
            return true;
        }

        return HasWidthWrap$2.call(this);
    };

    var ExpandFitRatioChildren = function (width, height) {
        if (!this.hasRatioFitChild) {
            return;
        }

        var innerHeight;
        if (this.orientation === 0) {
            innerHeight = height - ((this.getInnerPadding('top') + this.getInnerPadding('bottom')) * this.scaleY);
        } else {
            width - ((this.getInnerPadding('left') + this.getInnerPadding('right')) * this.scaleX);
        }

        var child, sizerConfig;
        var childWidth, childHeight;
        var children = this.sizerChildren;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            var sizerConfig = child.rexSizer;
            if (sizerConfig.hidden) {
                continue;
            }

            var fitRatio = sizerConfig.fitRatio;
            if (!fitRatio) {
                continue;
            }

            if (this.orientation === 0) {
                // Set child width by child height 
                childHeight = innerHeight - ((this.getChildOuterPadding(child, 'top') + this.getChildOuterPadding(child, 'bottom')) * this.scaleY);
                childWidth = childHeight * fitRatio;
            } else {
                // Set child height by child width
                childWidth = innerHeight - ((this.getChildOuterPadding(child, 'top') + this.getChildOuterPadding(child, 'bottom')) * this.scaleX);
                childHeight = childWidth / fitRatio;
            }

            ResizeGameObject(child, childWidth, childHeight);
            if (child.isRexSizer) {
                child.setMinSize(childWidth, childHeight);
            }

            sizerConfig.resolved = true;
        }
    };

    var RunWidthWrap$2 = function (width) {
        if (this.wrapResult) {
            // Already got wrapResult
            return;
        }

        if (this.orientation === 1) {
            ExpandFitRatioChildren.call(this, width, undefined);
        }

        RunWidthWrap$3.call(this, width);
    };

    var HasHeightWrap$1 = function () {
        if (this.hasRatioFitChild && (this.orientation === 0)) {
            return true;
        }

        return HasHeightWrap$2.call(this);
    };

    var RunHeightWrap$2 = function (height) {
        if (this.wrapResult) {
            // Already got wrapResult
            return;
        }

        if (this.orientation === 0) {
            ExpandFitRatioChildren.call(this, undefined, height);
        }

        RunHeightWrap$3.call(this, height);
    };

    const Zone = Phaser.GameObjects.Zone;

    class Space extends Zone {
        constructor(scene) {
            super(scene, 0, 0, 1, 1);
            // Don't add Zone into scene
            this.isRexSpace = true;
        }
    }

    var GetNearestChildIndex$1 = function (x, y) {
        var children = this.sizerChildren;
        if (children.length === 0) {
            return -1;
        }

        var nearestIndex = -1,
            minDistance = Infinity;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];

            var distance;
            if (this.orientation === 0) { // x
                distance = Math.abs(child.left - x);
            } else {
                distance = Math.abs(child.top - y);
            }

            if (minDistance > distance) {
                minDistance = distance;
                nearestIndex = i;
            }
        }

        // Check right bound of last child
        var child = children[children.length - 1];
        var distance;
        if (this.orientation === 0) { // x
            distance = Math.abs(child.right - x);
        } else {
            distance = Math.abs(child.bottom - y);
        }

        if (minDistance > distance) {
            minDistance = distance;
            nearestIndex = i + 1;
        }

        return nearestIndex;
    };

    const IsPlainObject$j = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$24 = Phaser.Utils.Objects.GetValue;
    const ALIGN_CENTER$2 = Phaser.Display.Align.CENTER;
    const PROPORTIONMODE = {
        min: 0,
        full: -1,
    };

    var Add$6 = function (
        gameObject,
        proportion, align, paddingConfig, expand,
        childKey, index,
        minWidth, minHeight,
        fitRatio
    ) {
        var offsetX, offsetY;
        var offsetOriginX, offsetOriginY;

        AddChild$1.call(this, gameObject);

        var isRexSpace = gameObject.isRexSpace;
        var proportionType = typeof (proportion);
        if (proportion === null) {
            return this;
        } else if (proportionType === 'number') ; else if (proportionType === 'string') {
            proportion = PROPORTIONMODE[proportion];
        } else if (IsPlainObject$j(proportion)) {
            var config = proportion;
            proportion = GetValue$24(config, 'proportion', undefined);
            align = GetValue$24(config, 'align', ALIGN_CENTER$2);
            paddingConfig = GetValue$24(config, 'padding', 0);
            expand = GetValue$24(config, 'expand', false);
            childKey = GetValue$24(config, 'key', undefined);
            index = GetValue$24(config, 'index', undefined);

            if (!gameObject.isRexSizer) {
                minWidth = GetValue$24(config, 'minWidth', undefined);
                minHeight = GetValue$24(config, 'minHeight', undefined);
            }

            fitRatio = GetValue$24(config, 'fitRatio', 0);  // width/height

            offsetX = GetValue$24(config, 'offsetX', 0);
            offsetY = GetValue$24(config, 'offsetY', 0);
            offsetOriginX = GetValue$24(config, 'offsetOriginX', 0);
            offsetOriginY = GetValue$24(config, 'offsetOriginY', 0);
        }

        if (typeof (align) === 'string') {
            align = AlignConst[align];
        }

        if (proportion === undefined) {
            proportion = (isRexSpace) ? 1 : 0;
        }
        if (align === undefined) {
            align = ALIGN_CENTER$2;
        }
        if (paddingConfig === undefined) {
            paddingConfig = 0;
        }
        if (expand === undefined) {
            expand = false;
        }

        if (minWidth === undefined) {
            if (isRexSpace) {
                minWidth = 0;
            } else if (!gameObject.isRexSizer) {
                minWidth = gameObject._minWidth;
            }
        }
        if (minHeight === undefined) {
            if (isRexSpace) {
                minHeight = 0;
            } else if (!gameObject.isRexSizer) {
                minHeight = gameObject._minHeight;
            }
        }

        if ((fitRatio === undefined) || (fitRatio === false)) {
            fitRatio = 0;
        } else if (fitRatio === true) {
            fitRatio = GetDisplayWidth(gameObject) / GetDisplayHeight(gameObject);
        }

        if (offsetX === undefined) {
            offsetX = 0;
        }
        if (offsetY === undefined) {
            offsetY = 0;
        }
        if (offsetOriginX === undefined) {
            offsetOriginX = 0;
        }
        if (offsetOriginY === undefined) {
            offsetOriginY = 0;
        }

        var config = this.getSizerConfig(gameObject);
        config.proportion = proportion;
        config.align = align;
        config.padding = GetBoundsConfig$1(paddingConfig);
        config.expand = expand;
        config.fitRatio = (proportion === 0) ? fitRatio : 0;
        config.alignOffsetX = offsetX;
        config.alignOffsetY = offsetY;
        config.alignOffsetOriginX = offsetOriginX;
        config.alignOffsetOriginY = offsetOriginY;

        if ((index === undefined) || (index >= this.sizerChildren.length)) {
            this.sizerChildren.push(gameObject);
        } else {
            this.sizerChildren.splice(index, 0, gameObject);
        }

        if (!gameObject.isRexSizer) { // Expand normal game object
            if (proportion > 0) {
                if (this.orientation === 0) { // x
                    // minWidth is still undefined, uses current display width
                    gameObject.minWidth = (minWidth === undefined) ? GetDisplayWidth(gameObject) : minWidth;
                } else {
                    // minHeight is still undefined, uses current display height
                    gameObject.minHeight = (minHeight === undefined) ? GetDisplayHeight(gameObject) : minHeight;
                }
            }
            if (expand) {
                if (this.orientation === 0) { // x
                    // Might have minHeight value, or still undefined
                    gameObject.minHeight = minHeight;
                } else {
                    // Might have minWidth value, or still undefined
                    gameObject.minWidth = minWidth;
                }
            }
        }

        if (childKey !== undefined) {
            this.addChildrenMap(childKey, gameObject);
        }

        return this;
    };

    var AddChildMethods$6 = {
        add: Add$6, // sizer.add could be override

        addSpace(proportion) {
            this.insertSpace(undefined, proportion);
            return this;
        },

        insertSpace(index, proportion) {
            if (proportion === undefined) {
                proportion = 1;
            }
            Add$6.call(this, new Space(this.scene),
                {
                    proportion: proportion,
                    minWidth: 0,
                    minHeight: 0,
                    index: index
                }
            );
            // No problem if sizer.add is override
            return this;
        },

        insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
            if (IsPlainObject$j(proportion)) {
                proportion.index = index;
            }

            Add$6.call(this, gameObject, proportion, align, paddingConfig, expand, childKey, index, minSize);
            // No problem if sizer.add is override
            return this;
        },

        insertAtPosition(x, y, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
            var index = GetNearestChildIndex$1.call(this, x, y);
            if (index === -1) {
                index = undefined;
            }
            this.insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize);
            return this;
        }
    };

    const RemoveItem$2 = Phaser.Utils.Array.Remove;

    var RemoveChildMethods$5 = {
        remove(gameObject, destroyChild) {
            if (this.getParentSizer(gameObject) !== this) {
                return this;
            }

            RemoveItem$2(this.sizerChildren, gameObject);
            RemoveChild.call(this, gameObject, destroyChild);
            return this;
        },

        removeAll(destroyChild) {
            for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
                this.remove(this.sizerChildren[i], destroyChild);
            }
            return this;
        },

        clear(destroyChild) {
            this.sizerChildren.length = 0;
            ClearChildren.call(this, destroyChild);
            return this;
        }
    };

    var AlignMethods = {
        getChildAlign(gameObject) {
            return this.getSizerConfig(gameObject).align;
        },

        setChildAlign(gameObject, align) {
            if (typeof (align) === 'string') {
                align = AlignConst[align];
            }

            this.getSizerConfig(gameObject).align = align;
            return this;
        },

    };

    var ProportionMethods = {
        getChildProportion(gameObject) {
            return this.getSizerConfig(gameObject).proportion;
        },

        setChildProportion(gameObject, proportion) {
            this.getSizerConfig(gameObject).proportion = proportion;
            return this;
        },

    };

    var ExpandMethods$1 = {
        getChildExpand(gameObject) {
            return this.getSizerConfig(gameObject).expand;
        },

        setChildExpand(gameObject, expand) {
            this.getSizerConfig(gameObject).expand = expand;
            return this;
        },

    };

    var SetChildrenAlignMode = function (mode) {
        if (mode === undefined) {
            mode = 'left';
        }

        var children = this.sizerChildren;

        var firstChild = children[0];
        var isFirstChildASpace = firstChild && firstChild.isRexSpace;

        if (    // Has left space
            (mode === 'right') ||
            (mode === 'bottom') ||
            (mode === 'center')
        ) {
            if (!isFirstChildASpace) {
                this.insertSpace(0);
            }

        } else {  // Does not have left space
            if (isFirstChildASpace) {
                this.remove(firstChild, true);
            }
        }

        var lastChildIndex = children.length - 1;
        var lastChild = children[lastChildIndex];
        var isLastChildASpace = lastChild && lastChild.isRexSpace;
        if (mode === 'center') {   // Has right space
            if (!isLastChildASpace) {
                this.insertSpace(lastChildIndex + 1);
            }

        } else {  // Does not have right space
            if (isLastChildASpace) {
                this.remove(lastChild, true);
            }
        }

        return this;
    };

    var SortChildrenMethods = {
        sortChildren(callback) {
            this.sizerChildren.sort(callback);
            return this;
        },

        sortChildrenByData(key, descending) {
            this.sizerChildren.sort(function (childA, childB) {
                var valueA = childA.getData(key);
                var valueB = childB.getData(key);
                if (descending) {
                    return valueB - valueA;
                } else {
                    return valueA - valueB;
                }
            });
            return this;
        },

        sortChildrenByProperty(key, descending) {
            this.sizerChildren.sort(function (childA, childB) {
                var valueA = childA[key];
                var valueB = childB[key];
                if (descending) {
                    return valueB - valueA;
                } else {
                    return valueA - valueB;
                }
            });
            return this;
        },
    };

    var methods$o = {
        getChildrenWidth: GetChildrenWidth$3,
        getChildrenHeight: GetChildrenHeight$3,
        getExpandedChildWidth: GetExpandedChildWidth$2,
        getExpandedChildHeight: GetExpandedChildHeight$2,
        getChildrenSizers: GetChildrenSizers$3,
        preLayout: PreLayout$3,
        layoutChildren: LayoutChildren$4,
        resolveWidth: ResolveWidth$1,
        resolveHeight: ResolveHeight$1,
        hasWidthWrap: HasWidthWrap$1,
        runWidthWrap: RunWidthWrap$2,
        hasHeightWrap: HasHeightWrap$1,
        runHeightWrap: RunHeightWrap$2,

        setChildrenAlignMode: SetChildrenAlignMode,
    };

    Object.assign(
        methods$o,
        AddChildMethods$6,
        RemoveChildMethods$5,
        AlignMethods,
        ProportionMethods,
        ExpandMethods$1,
        SortChildrenMethods,
    );

    var GetChildrenProportion = function () {
        var result = 0;
        var children = this.sizerChildren;
        var child, proportion;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.rexSizer.hidden) {
                continue;
            }
            proportion = child.rexSizer.proportion;
            if (proportion > 0) {
                result += proportion;
            } else if (proportion === 0) {
                this.hasProportion0Child = true;
            }
        }
        return result;
    };

    const IsPlainObject$i = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$23 = Phaser.Utils.Objects.GetValue;

    class Sizer extends Base$1 {
        constructor(scene, x, y, minWidth, minHeight, orientation, config) {
            if (IsPlainObject$i(x)) {
                config = x;
                x = GetValue$23(config, 'x', 0);
                y = GetValue$23(config, 'y', 0);
                minWidth = GetValue$23(config, 'width', undefined);
                minHeight = GetValue$23(config, 'height', undefined);
                orientation = GetValue$23(config, 'orientation', 0);
            } else if (IsPlainObject$i(minWidth)) {
                config = minWidth;
                minWidth = GetValue$23(config, 'width', undefined);
                minHeight = GetValue$23(config, 'height', undefined);
                orientation = GetValue$23(config, 'orientation', 0);
            } else if (IsPlainObject$i(orientation)) {
                config = orientation;
                orientation = GetValue$23(config, 'orientation', 0);
            }

            if (orientation === undefined) {
                orientation = 0;
            }
            super(scene, x, y, minWidth, minHeight, config);

            this.type = 'rexSizer';
            this.sizerChildren = [];
            this.setOrientation(orientation);
            this.setItemSpacing(GetValue$23(config, 'space.item', 0));
            this.setStartChildIndex(GetValue$23(config, 'startChildIndex', 0));
            this.setRTL(GetValue$23(config, 'rtl', false));

            this.addChildrenMap('items', this.sizerChildren);
        }

        setOrientation(orientation) {
            this.orientation = GetOrientationMode(orientation);
            return this;
        }

        setItemSpacing(space) {
            this.space.item = space;
            return this;
        }

        setStartChildIndex(index) {
            this.startChildIndex = index;
            return this;
        }

        setRTL(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.rtl = enable;
            return this;
        }

        get childrenProportion() {
            if (this._childrenProportion === undefined) {
                this._childrenProportion = GetChildrenProportion.call(this);
            }
            return this._childrenProportion;
        }
    }

    Object.assign(
        Sizer.prototype,
        methods$o
    );

    var SetDisplaySize = function (gameObject, width, height) {
        if (!gameObject) {
            return;
        }

        var unknownWidth = (width == null);
        var unknownHeight = (height == null);

        if (unknownWidth && unknownHeight) {
            return gameObject;
        }

        if (!unknownWidth) {
            gameObject.displayWidth = width;
        }

        if (!unknownHeight) {
            gameObject.displayHeight = height;
        }

        if (unknownWidth) {
            gameObject.scaleX = gameObject.scaleY;
        }

        if (unknownHeight) {
            gameObject.scaleY = gameObject.scaleX;
        }

        return gameObject;
    };

    var ResetDisplayContent$2 = function (config) {
        if (config === undefined) {
            config = {};
        } else if (typeof (config) === 'string') {
            config = {
                text: config,
            };
        }

        var text = config.text || '';
        this.setText(text);

        var iconGameObjct = this.childrenMap.icon;
        if (iconGameObjct) {
            if (!config.icon) {
                this.hide(iconGameObjct);
            } else {
                this.show(iconGameObjct);
            }
            var iconSize = config.iconSize;
            if (iconSize) {
                this.setChildDisplaySize(iconGameObjct, iconSize, iconSize);

                if (this.iconWidth !== undefined) {
                    this.setIconSize(iconSize);
                }
            }
            if (config.icon !== true) {
                this.setIconTexture(config.icon, config.iconFrame);
            }
        }

        var actionGameObjct = this.childrenMap.action;
        if (actionGameObjct) {
            if (!config.action) {
                this.hide(actionGameObjct);
            } else {
                this.show(actionGameObjct);
            }
            var actionSize = config.actionSize;
            if (actionSize) {
                this.setChildDisplaySize(actionGameObjct, actionSize, actionSize);

                if (this.actionWidth !== undefined) {
                    this.setActionSize(actionSize);
                }

            }
            if (config.action !== true) {
                this.setActionTexture(config.action, config.actionFrame);
            }
        }

        return this;
    };

    var methods$n = {
        appendText: AppendText$1,
        resetDisplayContent: ResetDisplayContent$2,
    };

    class LabelBase extends Sizer {
        /*
        Elements in childrenMap: 
        
        - background
        - icon, iconMask
        - text, 
        - action, actionMask
        */

        // Access text game object
        get text() {
            var textObject = this.childrenMap.text;
            if (!textObject) {
                return '';
            }
            return textObject.text;
        }

        set text(value) {
            var textObject = this.childrenMap.text;
            if (!textObject) {
                return;
            }
            textObject.setText(value);
        }

        setText(value) {
            this.text = value;
            return this;
        }

        // Access icon game object
        setIconTexture(key, frame) {
            var imageObject = this.childrenMap.icon;
            if (!imageObject || !imageObject.setTexture) {
                return this;
            }
            imageObject.setTexture(key, frame);

            if ((this.iconWidth !== undefined) && (this.iconHeight !== undefined)) {
                SetDisplaySize(imageObject, this.iconWidth, this.iconHeight);
                this.resetChildScaleState(imageObject);
            }

            return this;
        }

        setTexture(key, frame) {
            this.setIconTexture(key, frame);
            return this;
        }

        setIconSize(width, height) {
            if (height === undefined) {
                height = width;
            }

            this.iconWidth = width;
            this.iconHeight = height;

            return this;
        }

        get texture() {
            var imageObject = this.childrenMap.icon;
            if (!imageObject) {
                return undefined;
            }
            return imageObject.texture;
        }

        get frame() {
            var imageObject = this.childrenMap.icon;
            if (!imageObject) {
                return undefined;
            }
            return imageObject.frame;
        }

        setActionTexture(key, frame) {
            var imageObject = this.childrenMap.action;
            if (!imageObject || !imageObject.setTexture) {
                return this;
            }
            imageObject.setTexture(key, frame);

            if ((this.actionWidth !== undefined) && (this.actionHeight !== undefined)) {
                SetDisplaySize(imageObject, this.actionWidth, this.actionHeight);
                this.resetChildScaleState(imageObject);
            }

            return this;
        }

        get actionTexture() {
            var imageObject = this.childrenMap.action;
            if (!imageObject) {
                return undefined;
            }
            return imageObject.texture;
        }

        get actionFrame() {
            var imageObject = this.childrenMap.action;
            if (!imageObject) {
                return undefined;
            }
            return imageObject.frame;
        }

        setActionSize(width, height) {
            if (height === undefined) {
                height = width;
            }

            this.actionWidth = width;
            this.actionHeight = height;

            return this;
        }

        preLayout() {
            var icon = this.childrenMap.icon;
            if (icon && (this.iconWidth !== undefined) && (this.iconHeight !== undefined)) {
                SetDisplaySize(icon, this.iconWidth, this.iconHeight);
            }

            var action = this.childrenMap.action;
            if (action && (this.actionWidth !== undefined) && (this.actionHeight !== undefined)) {
                SetDisplaySize(action, this.actionWidth, this.actionHeight);
            }

            super.preLayout();
        }

        postLayout(parent, newWidth, newHeight) {
            // Pin icon-mask to icon game object
            var iconMask = this.childrenMap.iconMask;
            if (iconMask) {
                iconMask.setPosition();
                this.resetChildPositionState(iconMask);
            }
            // Pin action-mask to action game object
            var actionMask = this.childrenMap.actionMask;
            if (actionMask) {
                actionMask.setPosition();
                this.resetChildPositionState(actionMask);
            }
            super.postLayout(parent, newWidth, newHeight);
            return this;
        }

        resize(width, height) {
            super.resize(width, height);
            // Resize icon-mask to icon game object
            var iconMask = this.childrenMap.iconMask;
            if (iconMask) {
                iconMask.resize();
            }
            // Resize action-mask to icon game object
            var actionMask = this.childrenMap.actionMask;
            if (actionMask) {
                actionMask.resize();
            }
            return this;
        }
    }

    Object.assign(
        LabelBase.prototype,
        methods$n,
    );

    var AddChildMask = function (maskTarget, sizeTarget, shape, padding) {
        var maskGameObject = new DefaultMaskGraphics(sizeTarget, shape, padding); // A Graphics game object
        if (maskTarget && !maskTarget.isRexSizer) { // Sizer game object can't apply mask
            var mask = maskGameObject.createGeometryMask();
            maskTarget.setMask(mask);
            this.once('destroy', function () {
                maskTarget.setMask();
                mask.destroy();
            });
        }
        this.pin(maskGameObject);
        return maskGameObject;
    };

    const TextClass = Phaser.GameObjects.Text;

    var IsTextGameObject = function (gameObject) {
        return (gameObject instanceof TextClass);
    };

    const BitmapTextClass = Phaser.GameObjects.BitmapText;

    var IsBitmapTextGameObject = function (gameObject) {
        return (gameObject instanceof BitmapTextClass);
    };

    const TextType = 0;
    const TagTextType = 1;
    const BitmapTextType = 2;

    var GetTextObjectType = function (textObject) {
        var textObjectType;
        if (IsBitmapTextGameObject(textObject)) {
            textObjectType = BitmapTextType;
        } else if (IsTextGameObject(textObject)) {
            textObjectType = TextType;
        } else {
            textObjectType = TagTextType;
        }

        return textObjectType;
    };

    var TextWrapByCharCallback = function (text, textObject) {
        var output = [];

        var textLines = text.split('\n');
        var style = textObject.style;
        var wrapWidth = style.wordWrapWidth;
        var wrapMode = (style.hasOwnProperty('wrapMode')) ? style.wrapMode : 3;
        var context = textObject.context;
        for (var i = 0, cnt = textLines.length; i < cnt; i++) {
            WrapLine(context, textLines[i], wrapWidth, wrapMode, output);
        }

        return output;
    };

    var GetTokenArray = function (text, wrapMode) {
        var tokenArray;

        if (wrapMode === 2) {  // CHAR_WRAP
            tokenArray = text.split('');
        } else {  // MIX_WRAP
            tokenArray = [];
            var words = text.split(' '), word;
            for (var i = 0, wordCount = words.length; i < wordCount; i++) {
                word = words[i];

                if (i < (wordCount - 1)) {
                    if (IsASCIIString(word)) {
                        tokenArray.push(word + ' ');
                    } else {
                        tokenArray.push(...word.split(''));
                        // Add space as last token
                        tokenArray.push(' ');
                    }

                } else {  // The last word
                    if (word !== '') {
                        if (IsASCIIString(word)) {
                            tokenArray.push(word);
                        } else {
                            tokenArray.push(...word.split(''));
                        }
                    }

                }

            }
        }

        return tokenArray;
    };

    var WrapLine = function (context, text, wrapWidth, wrapMode, output) {
        if (text.length <= 100) {
            var textWidth = context.measureText(text).width;
            if (textWidth <= wrapWidth) {
                output.push(text);
                return output;
            }
        }

        var tokenArray = GetTokenArray(text, wrapMode);

        var token, tokenWidth;
        var line = [], remainderLineWidth = wrapWidth;
        for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
            token = tokenArray[j];
            tokenWidth = context.measureText(token).width;

            remainderLineWidth -= tokenWidth;
            if (remainderLineWidth < 0) {
                output.push(line.join(''));
                line.length = 0;
                remainderLineWidth = wrapWidth - tokenWidth;
            }

            line.push(token);
        }

        if (line.length > 0) {
            output.push(line.join(''));
        }

        return output;
    };

    var SetWrapMode = function (textObject, mode) {
        var textObjectType = GetTextObjectType(textObject);
        switch (textObjectType) {
            case TextType:
                if (typeof mode === 'string') {
                    mode = WRAPMODE$1[mode] || 0;
                }

                textObject.style.wrapMode = mode;
                switch (mode) {
                    case 2:  // CHAR_WRAP
                    case 3:  // MIX_WRAP
                        textObject.style.wordWrapCallback = TextWrapByCharCallback;
                        break;

                    case 1:  // WORD_WRAP
                    default:  // NO_WRAP
                        textObject.style.wordWrapCallback = null;
                        break;
                }

                break;

            case TagTextType:
                if (typeof mode === 'string') {
                    mode = WRAPMODE$1[mode] || 0;
                }
                textObject.style.wrapMode = mode;
                break;


        }
    };

    var TextRunWidthWrap = function (textObject) {
        var RunWidthWrap = function (width) {
            var padding = textObject.padding;
            var wrapWidth = width - ((padding.left + padding.right) * textObject.scaleX);
            var style = textObject.style;
            if (IsTextGameObject(textObject)) {
                style.wordWrapWidth = wrapWidth;
                style.maxLines = 0;
            } else {  // BBCode text, Tag text
                if (style.wrapMode === 0) { // Turn no-wrap to word-wrap
                    style.wrapMode = 1;
                }
                style.wrapWidth = wrapWidth;
                style.maxLines = 0;
            }
            style.fixedWidth = width;
            style.fixedHeight = 0;
            textObject.updateText();  // Redraw text

            textObject.minHeight = textObject.height;
            return textObject;
        };
        return RunWidthWrap;
    };

    var DynamicTextRunWidthWrap = function (textObject) {
        var RunWidthWrap = function (width) {
            textObject
                .setFixedSize(width, 0)
                .runWordWrap();

            textObject.minHeight = textObject.height;
            return textObject;
        };
        return RunWidthWrap;
    };

    var BitmapTextRunWidthWrap = function (textObject) {
        var RunWidthWrap = function (width) {
            textObject.setMaxWidth(width);

            textObject.minHeight = textObject.height;
            return textObject;
        };
        return RunWidthWrap;
    };

    var IsDynamicTextGameObject = function (gameObject) {
        return (gameObject instanceof DynamicText);
    };

    var WrapExpandText = function (textObject, minWidth) {
        if (minWidth === undefined) {
            minWidth = 0;
        }

        textObject._minWidth = minWidth;

        textObject.runWidthWrap =
            IsDynamicTextGameObject(textObject) ? DynamicTextRunWidthWrap(textObject) :
                IsBitmapTextGameObject(textObject) ? BitmapTextRunWidthWrap(textObject) :
                    TextRunWidthWrap(textObject);

        return textObject;
    };

    const MaxTestCount = 65535;

    var FontSizeFit = function (textObject, width, height) {
        if (width == null) {
            // Do nothing if invalid width input
            return textObject;
        }
        if (width === 0) {
            SetTextWidth(textObject, 0, height);
            return textObject;
        }

        var textLength = textObject.text.length;
        if (textLength === 0) {
            SetTextWidth(textObject, width, height);
            return textObject;
        }

        var fontSize = Math.floor(width * 1.5 / textLength);
        if (height !== undefined) {
            if (fontSize > height) {
                fontSize = Math.floor(height);
            }
        }

        var sizeData = {};
        var testResult = TestFontSize(textObject, fontSize, width, height, sizeData);
        for (var i = 0; i <= MaxTestCount; i++) {
            if (testResult === 0) {
                break;
            } else {
                fontSize += testResult;
                if (fontSize < 0) {
                    fontSize = 0;
                    break;
                }
            }
            testResult = TestFontSize(textObject, fontSize, width, height, sizeData);
            // console.log(fontSize, testResult)
        }

        if (i === MaxTestCount) {
            console.warn(`FontSizeFit: Test count exceeds ${MaxTestCount}`);
        }

        textObject.setFontSize(fontSize);
        SetTextWidth(textObject, width, height);

        return textObject;
    };

    var GetTextSize = function (textObject, fontSize, sizeData) {
        if (sizeData[fontSize] === undefined) {
            textObject.setFontSize(fontSize);
            sizeData[fontSize] = {
                width: textObject.width,
                height: textObject.height
            };
        }

        return sizeData[fontSize]
    };

    var TestFontSize = function (textObject, fontSize, width, height, sizeData) {
        var textSize = GetTextSize(textObject, fontSize, sizeData);
        var textSize1 = GetTextSize(textObject, fontSize + 1, sizeData);

        var deltaHeight;
        if (height !== undefined) {
            // Clamp by height
            if ((textSize.height <= height) && (textSize1.height > height)) {
                deltaHeight = 0;

            } else if (textSize.height > height) { // Reduce font size
                return -1;

            } else {
                // Increase font size
                deltaHeight = Math.floor(height - textSize.height);
            }
        }

        // Clamp by width
        var deltaWidth;
        if ((textSize.width <= width) && (textSize1.width > width)) {
            return 0;

        } else if (textSize.width > width) {  // Reduce font size
            return -1;

        } else {
            // Increase font size
            var deltaWidth = Math.floor(width - textSize.width);
            if (deltaHeight === undefined) {
                return deltaWidth;
            } else {
                return Math.min(deltaWidth, deltaHeight);
            }
        }
    };

    var SetTextWidth = function (textObject, width, height) {
        var style = textObject.style;

        if (!style) {
            // BitmapText game object does not have style property
            return;
        }

        style.fixedWidth = width;
        style.parent.width = width;

        if (height !== undefined) {
            style.fixedHeight = height;
            style.parent.height = height;
        }

        style.update(false);
    };

    const GetValue$22 = Phaser.Utils.Objects.GetValue;

    var FontSizeExpandText = function (textObject, config) {
        if (typeof (config) === 'number') {
            config = {
                minWidth: config
            };
        }

        var minWidth = GetValue$22(config, 'minWidth', 0);
        var minHeight = GetValue$22(config, 'minHeight', 0);
        var fitHeight = GetValue$22(config, 'fitHeight', false);

        textObject._minWidth = minWidth;
        textObject._minHeight = minHeight;

        if (!fitHeight) {
            // Set font size to fit width only
            textObject.runWidthWrap = function (width) {
                if (textObject.setFixedSize) {
                    textObject.setFixedSize(0, 0);
                }
                FontSizeFit(textObject, width, undefined);
                return textObject;
            };
            textObject.resize = function (width, height) {
                if ((textObject.width === width) && (textObject.height === height)) {
                    return textObject;
                }

                // Font size is set under runWidthWrap/FontSizeFit
                textObject.setFixedSize(width, height);
                return textObject;
            };

        } else {
            // Set font size to fit width and height
            textObject.runWidthWrap = function (width) {
                // Minimun text size
                if (textObject.setFixedSize) {
                    textObject.setFixedSize(0, 0);
                }

                textObject.setFontSize(1);
                return textObject;
            };
            textObject.resize = function (width, height) {
                FontSizeFit(textObject, width, height);
                return textObject;
            };
        }

        return textObject;
    };

    const GetValue$21 = Phaser.Utils.Objects.GetValue;

    class Label extends LabelBase {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            // Create sizer
            super(scene, config);
            this.type = 'rexLabel';

            // Add elements
            var background = GetValue$21(config, 'background', undefined);
            var icon = GetValue$21(config, 'icon', undefined);
            var iconMask = GetValue$21(config, 'iconMask', undefined);
            var text = GetValue$21(config, 'text', undefined);
            var action = GetValue$21(config, 'action', undefined);
            var actionMask = GetValue$21(config, 'actionMask', undefined);
            // Align
            var align = GetValue$21(config, 'align', undefined); // undefined/left/top: no space


            if (background) {
                this.addBackground(background);
            }

            if (icon) {
                var padding;
                if (this.orientation === 0) {
                    if (text || action) {
                        padding = {
                            right: GetValue$21(config, 'space.icon', 0),
                            top: GetValue$21(config, 'space.iconTop', 0),
                            bottom: GetValue$21(config, 'space.iconBottom', 0),
                            left: GetValue$21(config, 'space.iconLeft', 0),
                        };
                    }
                } else {
                    if (text || action) {
                        padding = {
                            bottom: GetValue$21(config, 'space.icon', 0),
                            left: GetValue$21(config, 'space.iconLeft', 0),
                            right: GetValue$21(config, 'space.iconRight', 0),
                            top: GetValue$21(config, 'space.iconTop', 0),
                        };
                    }
                }
                var fitRatio = GetValue$21(config, 'squareFitIcon', false) ? 1 : 0;

                this.add(
                    icon,
                    { proportion: 0, padding: padding, fitRatio: fitRatio }
                );

                if (iconMask) {
                    iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
                }

                if (!fitRatio) {
                    var iconSize = GetValue$21(config, 'iconSize', undefined);
                    this.setIconSize(
                        GetValue$21(config, 'iconWidth', iconSize),
                        GetValue$21(config, 'iconHeight', iconSize)
                    );
                }
            }


            if (text) {
                var wrapText = GetValue$21(config, 'wrapText', false);
                var adjustTextFontSize = GetValue$21(config, 'adjustTextFontSize', false);
                if (wrapText) {
                    if (wrapText === true) {
                        wrapText = 'word';
                    }
                    SetWrapMode(text, wrapText);
                    config.expandTextWidth = true;
                    WrapExpandText(text);

                } else if (adjustTextFontSize) {
                    config.expandTextWidth = true;
                    config.expandTextHeight = true;
                    FontSizeExpandText(text, { fitHeight: true });

                }

                var textSpace = GetValue$21(config, 'space.text', 0);
                var expandTextWidth = GetValue$21(config, 'expandTextWidth', false);
                var expandTextHeight = GetValue$21(config, 'expandTextHeight', false);
                var proportion, padding, expand;
                if (this.orientation === 0) {
                    proportion = (expandTextWidth) ? 1 : 0;
                    if (action) {
                        padding = { right: textSpace };
                    }
                    expand = expandTextHeight;
                } else {
                    proportion = (expandTextHeight) ? 1 : 0;
                    if (action) {
                        padding = { bottom: textSpace };
                    }
                    expand = expandTextWidth;
                }

                this.add(
                    text,
                    { proportion: proportion, expand: expand, padding: padding, }
                );
            }

            if (action) {
                var padding;
                if (this.orientation === 0) {
                    padding = {
                        top: GetValue$21(config, 'space.actionTop', 0),
                        bottom: GetValue$21(config, 'space.actionBottom', 0),
                        right: GetValue$21(config, 'space.actionRight', 0),
                    };
                } else {
                    padding = {
                        left: GetValue$21(config, 'space.actionLeft', 0),
                        right: GetValue$21(config, 'space.actionRight', 0),
                        bottom: GetValue$21(config, 'space.actionBottom', 0),
                    };
                }
                var fitRatio = GetValue$21(config, 'squareFitAction', false) ? 1 : 0;
                this.add(
                    action,
                    { proportion: 0, padding: padding, fitRatio: fitRatio }
                );

                if (actionMask) {
                    actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
                }

                if (!fitRatio) {
                    var actionSize = GetValue$21(config, 'actionSize');
                    this.setActionSize(
                        GetValue$21(config, 'actionWidth', actionSize),
                        GetValue$21(config, 'actionHeight', actionSize)
                    );
                }
            }

            this.setChildrenAlignMode(align);

            this.addChildrenMap('background', background);
            this.addChildrenMap('icon', icon);
            this.addChildrenMap('iconMask', iconMask);
            this.addChildrenMap('text', text);
            this.addChildrenMap('action', action);
            this.addChildrenMap('actionMask', actionMask);
        }
    }

    const GetValue$20 = Phaser.Utils.Objects.GetValue;

    var CreateCanvas = function (scene, config) {
        var canvasConfig = GetValue$20(config, 'canvas');
        var width = GetValue$20(canvasConfig, 'width', 128);
        var height = GetValue$20(canvasConfig, 'height', 128);

        var canvas = new Canvas(scene, 0, 0, width, height);
        scene.add.existing(canvas);

        var key = GetValue$20(canvasConfig, 'key');
        var frame = GetValue$20(canvasConfig, 'frame');
        var fillColor = GetValue$20(canvasConfig, 'fill');
        if (fillColor !== undefined) {
            canvas.fill(fillColor);
        } else if (key !== undefined) {
            canvas.loadTexture(key, frame);
        }

        // Compatible with Image game object for ImageBox
        canvas.setTexture = canvas.loadTexture.bind(canvas);

        return canvas;
    };

    var CreateImageBox = function (scene, config) {
        var icon = new ImageBox(scene, {
            scaleUp: GetValue$20(config, 'scaleUpIcon', false),
            background: GetValue$20(config, 'iconBackground'),
            image: CreateCanvas(scene, config)
        });
        scene.add.existing(icon);

        return icon;
    };

    const GetValue$1$ = Phaser.Utils.Objects.GetValue;

    var GetClickTarget = function (parent, config) {
        var clickTarget = GetValue$1$(config, 'clickTarget', this);
        if (typeof (clickTarget) === 'string') {
            clickTarget = parent.getElement(clickTarget);
        }

        return clickTarget;
    };

    const GetValue$1_ = Phaser.Utils.Objects.GetValue;

    var CreateClickBehavior = function (parent, config) {
        var clickTarget = GetClickTarget(parent, config);
        if (!clickTarget) {
            return undefined;
        }

        var clickConfig = GetValue$1_(config, 'click');
        var clickBehavior = new Button(clickTarget, clickConfig);
        clickBehavior.on('click', parent.open, parent);

        return clickBehavior;
    };

    const Config = {
        accept: 'image/*',
        multiple: false,
    };

    var OnSelectFile = function (parent, files) {
        if (files.length === 0) {
            return;
        }

        var imageBox = parent.childrenMap.icon;
        var canvas = imageBox.image;
        var selectedFile = files[0];
        return canvas.loadFromFilePromise(selectedFile)
            .then(function () {
                imageBox.scaleImage();

                parent.emit('select', selectedFile, parent);
                return Promise.resolve(selectedFile);
            })
    };

    var CreateFileChooser = function (parent, config) {
        var scene = parent.scene;
        var fileChooser = new FileChooser(scene, Config);
        scene.add.existing(fileChooser);

        parent.pin(fileChooser);

        fileChooser
            .on('change', function () {
                OnSelectFile(parent, fileChooser.files);
            });

        return fileChooser;
    };

    // Note: Not working in iOS9+


    var OpenMethods = {
        async openPromise() {
            var self = this;

            return Open$1(this.scene.game, Config)
                .then(function (result) {
                    return OnSelectFile(self, result.files);
                })
        },

        open() {
            this.openPromise();
            return this;
        },

        setClickOpenEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            if (this.clickBehavior) {
                this.clickBehavior.setEnable(enable);
            }

            if (this.fileChooser) {
                this.fileChooser.setOpenEnable(enable);
            }

            return this;
        },
    };

    var GetFileName = function (file) {
        if (!file) {
            return null;
        }

        var name = file.name;
        return name.substr(0, name.lastIndexOf('.'));
    };

    var SaveTexture = function (key) {
        var canvas = this.childrenMap.canvas;
        canvas.generateTexture(key);

        return this;
    };

    var methods$m = {
        getFileName: GetFileName,
        saveTexture: SaveTexture,
    };

    Object.assign(
        methods$m,
        OpenMethods
    );

    const GetValue$1Z = Phaser.Utils.Objects.GetValue;

    /*
    Label :
        - icon : imageBox
            - image: canvas
    */

    class ImageInputLabel extends Label {
        constructor(scene, config) {
            var icon = CreateImageBox(scene, config);
            config.icon = icon;

            super(scene, config);
            this.type = 'rexImageFileInputLabel';

            // Set initial size of icon(imageBox)
            var iconWidth = this.iconWidth,
                iconHeight = this.iconWidth;
            if ((iconWidth !== undefined) && (iconHeight !== undefined)) {
                icon.resize(iconWidth, iconHeight);
            }

            this.clickTarget = GetClickTarget(this, config);
            if (this.clickTarget) {
                if (!GetValue$1Z(config, 'domButton', true)) {
                    this.clickBehavior = CreateClickBehavior(this, config);
                } else {
                    this.fileChooser = CreateFileChooser(this);
                }
            }
            
            this.addChildrenMap('canvas', icon.image);
            this.addChildrenMap('iconBackground', icon.background);
            this.addChildrenMap('fileChooser', this.fileChooser);

        }

        postLayout(parent, newWidth, newHeight) {
            if (this.fileChooser) {
                this.fileChooser.syncTo(this.clickTarget);
                this.resetChildState(this.fileChooser);
            }
            super.postLayout(parent, newWidth, newHeight);
        }

    }

    Object.assign(
        ImageInputLabel.prototype,
        methods$m,
    );

    ObjectFactory.register('imageInputLabel', function (config) {
        var gameObject = new ImageInputLabel(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ImageInputLabel', ImageInputLabel);

    let Style$3 = class Style extends ComponentBase {
        constructor(gameObject, style) {
            super(gameObject);
            // this.parent = gameObject;

            return new Proxy(this, this);
        }

        get(target, prop) {
            if (HasProperty(target, prop)) {
                return target[prop];
            }

            var gameObject = target.parent;
            if (HasProperty(gameObject, prop)) {
                return gameObject[prop];
            }
        }

        set(target, prop, value) {
            if (HasProperty(target, prop)) {
                target[prop] = value;

            } else if (HasProperty(target.parent, prop)) {
                target.parent[prop] = value;
            }

            return true;
        }

        get key() {
            return this.parent.texture.key;
        }

        set key(value) {
            this.parent.setTexture(value, this.frame);
        }

        get frame() {
            return this.parent.frame.name;
        }

        set frame(value) {
            this.parent.setFrame(value);
        }

        get scale() {
            return this.parent.scaleX;
        }

        set scale(value) {
            this.parent.setScale(value);
        }
    };

    const GetValue$1Y = Phaser.Utils.Objects.GetValue;

    class StyleManager extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            this.style = GetValue$1Y(config, 'style', this);

            var propertiesMap = GetValue$1Y(config, 'propertiesMap');
            this.activeStyle = ExtractStyle(config, 'active', propertiesMap);
            this.hoverStyle = ExtractStyle(config, 'hover', propertiesMap);
            this.disableStyle = ExtractStyle(config, 'disable', propertiesMap);

            this.onModifyStyle = GetValue$1Y(config, 'onModifyStyle');
        }

        getStyle(keys) {
            return GetPartialData(this.style, keys);
        }

        modifyStyle(style) {
            for (var key in style) {
                this.style[key] = style[key];
            }

            if (this.onModifyStyle) {
                this.onModifyStyle(this.parent, style);
            }

            return this;
        }

        applyStyle(newStyle) {
            if (!newStyle) {
                return undefined;
            }

            var currentStyle = this.getStyle(newStyle);
            if (!IsKeyValueEqual(currentStyle, newStyle)) {
                this.modifyStyle(newStyle);
                return currentStyle;
            } else {
                return undefined;
            }
        }

        setActiveState(enable) {
            SetStateEnableMethod.call(this, 'active', enable);
            return this;
        }

        setHoverState(enable) {
            SetStateEnableMethod.call(this, 'hover', enable);
            return this;
        }

        setDisableState(enable) {
            SetStateEnableMethod.call(this, 'disable', enable);
            return this;
        }
    }

    var ExtractStyle = function (config, prefix, propertiesMap) {
        var result = ExtractByPrefix(config, prefix);

        if (propertiesMap) {
            for (var name in result) {
                if (propertiesMap.hasOwnProperty(name)) {
                    result[propertiesMap[name]] = result[name];
                    delete result[name];
                }
            }
        }

        return result;
    };

    var SetStateEnableMethod = function (stateName, enable) {
        if (enable === undefined) {
            enable = true;
        }

        var stateVarName = `${stateName}State`;
        var styleVarName = `${stateName}Style`;
        var styleSaveVarName = `${stateName}StyleSave`;

        if (this[stateVarName] === enable) {
            return;
        }

        this[stateVarName] = enable;

        if (enable) {
            this[styleSaveVarName] = this.applyStyle(this[styleVarName]);
        } else {
            this.applyStyle(this[styleSaveVarName]);
            this[styleSaveVarName] = undefined;
        }
    };

    var HelperMethods = {
        addStyleManager(config) {
            this.styleManager = new StyleManager(this, config);
            return this;
        },

        setActiveState(enable) {
            this.styleManager.setActiveState(enable);
            return this;
        },

        setHoverState(enable) {
            this.styleManager.setHoverState(enable);
            return this;
        },

        setDisableState(enable) {
            this.styleManager.setDisableState(enable);
            return this;
        }
    };

    const PhaserImage = Phaser.GameObjects.Image;
    const GetValue$1X = Phaser.Utils.Objects.GetValue;

    class StatesImage extends PhaserImage {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            var x = GetValue$1X(config, 'x', 0);
            var y = GetValue$1X(config, 'y', 0);
            var key = GetValue$1X(config, 'key', '');
            var frame = GetValue$1X(config, 'frame', undefined);
            super(scene, x, y, key, frame);
            this.type = 'rexStatesImage';

            var effectConfig = GetValue$1X(config, 'effects', true);
            if (effectConfig) {
                AddEffectProperties(this, effectConfig);
            }

            this.style = new Style$3(this, config);

            config.style = this.style;
            this.addStyleManager(config);

            delete config.style;
        }
    }

    Object.assign(
        StatesImage.prototype,
        HelperMethods
    );

    ObjectFactory.register('statesImage', function (config) {
        var gameObject = new StatesImage(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.StatesImage', StatesImage);

    class StatesRoundRectangle extends RoundRectangle$2 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            super(scene, config);
            this.type = 'rexStatesRoundRectangleShape';

            config.style = this;
            config.propertiesMap = PropertiesMap$1;

            this.addStyleManager(config);

            delete config.style;
            delete config.propertiesMap;
        }
    }

    const PropertiesMap$1 = {
        color: 'fillColor',
        alpha: 'fillAlpha',
        // strokeColor: 'strokeColor',
        // strokeAlpha: 'strokeAlpha',
        strokeWidth: 'lineWidth',
    };

    Object.assign(
        StatesRoundRectangle.prototype,
        HelperMethods
    );

    ObjectFactory.register('statesRoundRectangle', function (config) {
        var gameObject = new StatesRoundRectangle(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.StatesRoundRectangle', StatesRoundRectangle);

    let Style$2 = class Style extends ComponentBase {
        constructor(gameObject, style) {
            super(gameObject);
            // this.parent = gameObject;

            return new Proxy(this, this);
        }

        get(target, prop) {
            if (HasProperty(target, prop)) {
                return target[prop];
            }

            var gameObject = target.parent;
            if (HasProperty(gameObject, prop)) {
                return gameObject[prop];
            }
        }

        set(target, prop, value) {
            if (HasProperty(target, prop)) {
                target[prop] = value;

            } else if (HasProperty(target.parent, prop)) {
                target.parent[prop] = value;
            }

            return true;
        }

        get key() {
            return this.parent.texture.key;
        }

        set key(value) {
            if (this.key === value) {
                return;
            }
            this.parent.setTexture(value, this.frame);
        }

        get frame() {
            return this.parent.frame.name;
        }

        set frame(value) {
            if (this.frame === value) {
                return;
            }
            this.parent.setFrame(value);
        }
    };

    const PhaserNineSlice = Phaser.GameObjects.NineSlice;
    const GetValue$1W = Phaser.Utils.Objects.GetValue;

    class StatesNineSlice extends PhaserNineSlice {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            var x = GetValue$1W(config, 'x', 0);
            var y = GetValue$1W(config, 'y', 0);
            var key = GetValue$1W(config, 'key', null);
            var frame = GetValue$1W(config, 'frame', null);
            var width = GetValue$1W(config, 'width', 0);
            var height = GetValue$1W(config, 'height', 0);
            var leftWidth = GetValue$1W(config, 'leftWidth', 0);
            var rightWidth = GetValue$1W(config, 'rightWidth', 0);
            var topHeight = GetValue$1W(config, 'topHeight', 0);
            var bottomHeight = GetValue$1W(config, 'bottomHeight', 0);
            super(scene, x, y, key, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight);
            this.type = 'rexStatesNineSlice';

            var effectConfig = GetValue$1W(config, 'effects', true);
            if (effectConfig) {
                AddEffectProperties(this, effectConfig);
            }

            this.style = new Style$2(this, config);

            config.style = this.style;
            this.addStyleManager(config);

            delete config.style;
        }
    }

    Object.assign(
        StatesNineSlice.prototype,
        HelperMethods
    );

    ObjectFactory.register('statesNineSlice', function (config) {
        var gameObject = new StatesNineSlice(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.StatesNineSlice', StatesNineSlice);

    let Style$1 = class Style extends ComponentBase {
        constructor(gameObject, style) {
            super(gameObject);
            // this.parent = gameObject;

            return new Proxy(this, this);
        }

        get(target, prop) {
            if (HasProperty(target, prop)) {
                return target[prop];
            }

            var gameObject = target.parent;
            if (HasProperty(gameObject, prop)) {
                return gameObject[prop];
            }
        }

        set(target, prop, value) {
            if (HasProperty(target, prop)) {
                target[prop] = value;

            } else if (HasProperty(target.parent, prop)) {
                target.parent[prop] = value;
            }

            return true;
        }

        get key() {
            return this.parent.textureKey;
        }

        set key(value) {
            if (this.key === value) {
                return;
            }
            this.parent.setBaseTexture(value, this.baseFrameName);
        }

        get frame() {
            return this.parent.baseFrameName;
        }

        set frame(value) {
            if (this.frame === value) {
                return;
            }
            this.parent.setBaseTexture(this.parent.textureKey, value);
        }
    };

    const GetValue$1V = Phaser.Utils.Objects.GetValue;

    class StatesNinePatch extends NinePatch$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
           
            super(scene, config);
            this.type = 'rexStatesNinePatch';

            var effectConfig = GetValue$1V(config, 'effects', true);
            if (effectConfig) {
                AddEffectProperties(this, effectConfig);
            }

            this.style = new Style$1(this, config);

            config.style = this.style;
            this.addStyleManager(config);

            delete config.style;
        }
    }

    Object.assign(
        StatesNinePatch.prototype,
        HelperMethods
    );

    ObjectFactory.register('statesNinePatch', function (config) {
        var gameObject = new StatesNinePatch(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.StatesNinePatch', StatesNinePatch);

    const PhaserText = Phaser.GameObjects.Text;
    const GetValue$1U = Phaser.Utils.Objects.GetValue;

    class StatesText extends PhaserText {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            var x = GetValue$1U(config, 'x', 0);
            var y = GetValue$1U(config, 'y', 0);
            var text = GetValue$1U(config, 'text', '');
            super(scene, x, y, text, config);
            this.type = 'rexStatesText';

            config.style = this.style;
            config.onModifyStyle = function (gameObject, style) {
                var recalculateMetrics = style.hasOwnProperty('fontStyle') || style.hasOwnProperty('fontSize') || style.hasOwnProperty('fontFamily');
                gameObject.style.update(recalculateMetrics);
            };

            this.addStyleManager(config);

            delete config.style;
        }
    }

    Object.assign(
        StatesText.prototype,
        HelperMethods
    );

    ObjectFactory.register('statesText', function (config) {
        var gameObject = new StatesText(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.StatesText', StatesText);

    class Style extends ComponentBase {
        constructor(gameObject, style) {
            super(gameObject);
            // this.parent = gameObject;

            return new Proxy(this, this);
        }

        get(target, prop) {
            if (HasProperty(target, prop)) {
                return target[prop];
            }

            var gameObject = target.parent;
            if (HasProperty(gameObject, prop)) {
                return gameObject[prop];
            }
        }

        set(target, prop, value) {
            if (HasProperty(target, prop)) {
                target[prop] = value;

            } else if (HasProperty(target.parent, prop)) {
                target.parent[prop] = value;
            }

            return true;
        }

        get key() {
            return this.parent.texture.key;
        }

        set key(value) {
            this.parent.setTexture(value, this.frame);
        }

        get fontSize() {
            return this.parent.fontSize;
        }

        set fontSize(value) {
            this.parent.setFontSize(value);
        }

        get tint() {
            return this.parent.tintTopLeft;
        }

        set tint(value) {
            this.parent.setTint(value);
        }
        get letterSpacing() {
            return this.parent.letterSpacing;
        }

        set letterSpacing(value) {
            this.parent.setLetterSpacing(value);
        }

        get lineSpacing() {
            return this.parent.lineSpacing;
        }

        set lineSpacing(value) {
            this.parent.setLineSpacing(value);
        }

    }

    const PhaserBitmapText = Phaser.GameObjects.BitmapText;
    const GetValue$1T = Phaser.Utils.Objects.GetValue;

    class StatesBitmapText extends PhaserBitmapText {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            var x = GetValue$1T(config, 'x', 0);
            var y = GetValue$1T(config, 'y', 0);
            var font = GetValue$1T(config, 'font', '');
            var size = GetValue$1T(config, 'fontSize', false);
            var align = GetValue$1T(config, 'align', 0);
            var tint = GetValue$1T(config, 'tint');
            super(scene, x, y, font, '', size, align);
            this.type = 'rexStatesBitmapText';

            if (tint !== undefined) {
                this.setTint(tint);
            }

            var effectConfig = GetValue$1T(config, 'effects', true);
            if (effectConfig) {
                AddEffectProperties(this, effectConfig);
            }

            this.style = new Style(this, config);

            config.style = this.style;
            this.addStyleManager(config);

            delete config.style;
        }
    }

    Object.assign(
        StatesBitmapText.prototype,
        HelperMethods
    );

    ObjectFactory.register('statesBitmapText', function (config) {
        var gameObject = new StatesBitmapText(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.StatesBitmapText', StatesBitmapText);

    class StatesBarRectangle extends LineProgress$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            if (!config.hasOwnProperty('value')) {
                config.value = 0;
            }

            if (!config.hasOwnProperty('hover.bar')) {
                config['hover.bar'] = true;
            }

            if (!config.hasOwnProperty('easeDuration')) {
                config.easeDuration = 200;
            }

            if (!config.hasOwnProperty('ease')) {
                config.ease = 'Quad';
            }

            SetValue(config, 'easeValue.duration', config.easeDuration);
            SetValue(config, 'easeValue.ease', config.ease);

            super(scene, config);
            this.type = 'rexStatesBarRectangleShape';

            this.barState = false;

            config.style = this;
            config.propertiesMap = PropertiesMap;

            this.addStyleManager(config);

            delete config.style;
            delete config.propertiesMap;
        }

        get bar() {
            return this.barState;
        }

        set bar(value) {
            value = !!value;
            if (this.barState === value) {
                return;
            }
            this.barState = value;
            this.easeValueTo((this.barState) ? 1 : 0);
        }

    }

    const PropertiesMap = {
        color: 'trackColor',
        strokeColor: 'trackStrokeColor',
        strokeWidth: 'trackStrokeThickness',

        // barColor: 'barColor'
    };

    Object.assign(
        StatesBarRectangle.prototype,
        HelperMethods
    );

    ObjectFactory.register('statesBarRectangle', function (config) {
        var gameObject = new StatesBarRectangle(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.StatesBarRectangle', StatesBarRectangle);

    var SetChart = function (config) {
        if (!window.Chart) {
            var msg = `Can not find chartjs! Load chartjs in preload stage.
scene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');`;
            console.error(msg);
            return this;
        }

        if (this.chart) {
            this.chart.destroy();        
        }
        this.chart = new Chart(this.context, FillConfig(this, config));
        return this;
    };

    var FillConfig = function (canvas, config) {
        // Get options
        if (config === undefined) {
            config = {};
        }
        if (config.options === undefined) {
            config.options = {};
        }
        var options = config.options;

        // Fill options
        options.responsive = false;
        options.maintainAspectRatio = false;
        if (!options.hasOwnProperty('devicePixelRatio')) {
            options.devicePixelRatio = 1;
        }

        // Get animation config
        var noAnimation = false;
        if (options.animation === undefined) {
            options.animation = {};
        } else if (options.animation === false) {
            noAnimation = true;
            options.animation = {};
        }
        var animationConfig = options.animation;

        // Fill animation config
        if (noAnimation) {
            animationConfig.duration = 0;
        }

        var onProgress = animationConfig.onProgress;
        animationConfig.onProgress = function (animation) {
            if (onProgress) {
                onProgress(animation);
            }
            canvas.needRedraw();
        };

        var onComplete = animationConfig.onComplete;
        animationConfig.onComplete = function (animation) {
            if (onComplete) {
                onComplete(animation);
            }
            canvas.needRedraw();
        };
        return config;
    };

    var GetChartDataset = function (datasetIndex) {
        if (this.chart === undefined) {
            return undefined;
        }

        if (typeof (datasetIndex) === 'string') {
            var datasets = this.chart.data.datasets, dataset;
            for (var i = 0, cnt = datasets.length; i < cnt; i++) {
                dataset = datasets[i];
                if (dataset.label === datasetIndex) {
                    return dataset;
                }
            }
        } else {
            return this.chart.data.datasets[datasetIndex];
        }

        return undefined;
    };

    var GetChartData = function (datasetIndex, dataIndex) {
        var dataset = this.getChartDataset(datasetIndex);
        if (dataset === undefined) {
            return undefined;
        }
        if (typeof (dataIndex) === 'string') {
            var labels = this.chart.data.labels;
            dataIndex = labels.indexOf(dataIndex);
            if (dataIndex === -1) {
                return undefined;
            }
        }
        return dataset.data[dataIndex];
    };

    var SetChartData = function (datasetIndex, dataIndex, value) {
        if (this.chart === undefined) {
            return this;
        }

        var dataset = this.getChartDataset(datasetIndex);
        if (typeof (dataIndex) === 'string') {
            var labels = this.chart.data.labels;
            dataIndex = labels.indexOf(dataIndex);
            if (dataIndex === -1) {
                return this;
            }
        }
        dataset.data[dataIndex] = value;
        return this;
    };

    var UpdateChart = function () {
        if (this.chart === undefined) {
            return this;
        }
        this.chart.update();
        return this;
    };

    // This plugin does not contain chart.js
    // Load chart.js in preload stage -
    // scene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');

    let Chart$1 = class Chart extends Canvas {
        constructor(scene, x, y, width, height, config) {
            super(scene, x, y, width, height);
            this.type = 'rexChart';
            this.chart = undefined;

            if (config !== undefined) {
                this.setChart(config);
            }
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene) {
                return;
            }
            if (this.chart) {
                this.chart.destroy();
                this.chart = undefined;
            }
            super.destroy(fromScene);
        }

        resize(width, height) {
            if ((width === this.width) && (height === this.height)) {
                return this;
            }

            super.resize(width, height);

            if (this.chart) {
                var chart = this.chart;
                chart.height = this.canvas.height;
                chart.width = this.canvas.width;
                chart.aspectRatio = (chart.height) ? chart.width / chart.height : null;
                chart.update();
            }
            return this;
        }
    };

    var methods$l = {
        setChart: SetChart,
        getChartDataset: GetChartDataset,
        getChartData: GetChartData,
        setChartData: SetChartData,
        updateChart: UpdateChart,
    };
    Object.assign(
        Chart$1.prototype,
        methods$l
    );

    ObjectFactory.register('chart', function (x, y, width, height, config) {
        var gameObject = new Chart$1(this.scene, x, y, width, height, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Chart', Chart$1);

    ObjectFactory.register('container', function (x, y, width, height, children) {
        var gameObject = new ContainerLite(this.scene, x, y, width, height, children);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Container', ContainerLite);

    ObjectFactory.register('sizer', function (x, y, minWidth, minHeight, orientation, config) {
        var gameObject = new Sizer(this.scene, x, y, minWidth, minHeight, orientation, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Sizer', Sizer);

    var Sum = function () {
        return Array.prototype.reduce.call(arguments, Add$5, 0);
    };

    var Add$5 = function (a, b) {
        return a + b;
    };

    var GetChildrenWidth$2 = function (minimumMode) {
        if (this.rexSizer.hidden) {
            return 0;
        }

        if (minimumMode === undefined) {
            minimumMode = true;
        }

        var result = 0,
            columnWidth;
        var children = this.sizerChildren;
        var child, padding, childWidth, proportion;
        var hasUnknownChildWidth = false;
        this.totalColumnProportions;  // To update this.hasColumnProportion0Child member

        for (var i = 0; i < this.columnCount; i++) {
            proportion = this.columnProportions[i];
            columnWidth = 0;
            if ((proportion === 0) || minimumMode) {
                for (var j = 0; j < this.rowCount; j++) {
                    child = children[(j * this.columnCount) + i];
                    if (!child) {
                        continue;
                    }
                    if (child.rexSizer.hidden) {
                        continue;
                    }

                    childWidth = this.getChildWidth(child);
                    if (childWidth === undefined) {
                        if ((proportion !== 0) && (!this.hasColumnProportion0Child)) {
                            childWidth = 0;
                        } else {
                            hasUnknownChildWidth = true;
                        }
                    }

                    if (hasUnknownChildWidth) {
                        continue;
                    }

                    padding = child.rexSizer.padding;
                    childWidth += (padding.left + padding.right) * this.scaleX;
                    columnWidth = Math.max(columnWidth, childWidth);
                }

                if (!hasUnknownChildWidth) {
                    result += columnWidth;
                }

            }

            // else,(proportion > 0) : columnWidth is 0
            if (!hasUnknownChildWidth) {
                if (minimumMode) {
                    this.columnWidth[i] = columnWidth;
                }
            }
        }

        if (hasUnknownChildWidth) {
            return undefined;
        }

        var indentLeft = Math.max(this.space.indentLeftOdd, this.space.indentLeftEven);
        var totalSpace = Sum(this.space.left, indentLeft, ...this.space.column, this.space.right);
        return result + (totalSpace * this.scaleX);
    };

    var GetChildrenHeight$2 = function (minimumMode) {
        if (this.rexSizer.hidden) {
            return 0;
        }

        if (minimumMode === undefined) {
            minimumMode = true;
        }

        var result = 0,
            rowHeight;
        var children = this.sizerChildren;
        var child, padding, childHeight, proportion;
        var hasUnknownChildHeight = false;
        this.totalRowProportions;  // To update this.hasColumnProportion0Child member

        for (var i = 0; i < this.rowCount; i++) {
            proportion = this.rowProportions[i];
            rowHeight = 0;
            if ((proportion === 0) || minimumMode) {
                for (var j = 0; j < this.columnCount; j++) {
                    child = children[(i * this.columnCount) + j];
                    if (!child) {
                        continue;
                    }
                    if (child.rexSizer.hidden) {
                        continue;
                    }

                    childHeight = this.getChildHeight(child);
                    if (childHeight === undefined) {
                        if ((proportion !== 0) && (!this.hasRowProportion0Child)) {
                            childHeight = 0;
                        } else {
                            hasUnknownChildHeight = true;
                        }
                    }

                    if (hasUnknownChildHeight) {
                        continue;
                    }

                    padding = child.rexSizer.padding;
                    childHeight += (padding.top + padding.bottom) * this.scaleY;
                    rowHeight = Math.max(rowHeight, childHeight);
                }

                if (!hasUnknownChildHeight) {
                    result += rowHeight;
                }

            }
            // else,(proportion > 0) : rowHeight is 0

            if (!hasUnknownChildHeight) {
                if (minimumMode) {
                    this.rowHeight[i] = rowHeight;
                }
            }

        }

        if (hasUnknownChildHeight) {
            return undefined;
        }

        var indentTop = Math.max(this.space.indentTopOdd, this.space.indentTopEven);
        var totalSpace = Sum(this.space.top, indentTop, ...this.space.row, this.space.bottom);
        return result + (totalSpace * this.scaleY);
    };

    var GetExpandedChildWidth$1 = function (child, colWidth) {
        var childWidth;
        var childConfig = child.rexSizer;
        if (childConfig.expandWidth) {
            var padding = childConfig.padding;
            childWidth = colWidth - ((padding.left + padding.right) * this.scaleX);
        }
        return childWidth;
    };

    var GetExpandedChildHeight$1 = function (child, rowHeight) {
        var childHeight;
        var childConfig = child.rexSizer;
        if (childConfig.expandHeight) {
            var padding = childConfig.padding;
            childHeight = rowHeight - ((padding.top + padding.bottom) * this.scaleY);
        }
        return childHeight;
    };

    var GetChildrenSizers$2 = function (out) {
        if (out === undefined) {
            out = [];
        }
        var children = this.sizerChildren,
            child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child && child.isRexSizer) {
                out.push(child);
            }
        }
        return out;
    };

    var PreLayout$2 = function () {
        this._totalColumnProportions = undefined;
        this._totalRowProportions = undefined;
        this.hasColumnProportion0Child = false;
        this.hasRowProportion0Child = false;
        this.proportionWidthLength = undefined;  // Display proportion-length, contains scale
        this.proportionHeightLength = undefined; // Display proportion-length, contains scale
        PreLayout$4.call(this);
        return this;
    };

    var LayoutChildren$3 = function () {
        var child, childConfig, padding;
        var startX = this.innerLeft,
            startY = this.innerTop;
        var itemX,
            itemY = startY;
        var x, y, width, height, alignOffsetX, alignOffsetY; // Align zone
        var childWidth, childHeight;
        // Layout grid children
        var colWidth, rowHeight;
        var indentLeft, indentTop;
        for (var rowIndex = 0; rowIndex < this.rowCount; rowIndex++) {
            rowHeight = this.getRowHeight(rowIndex);

            indentLeft = (rowIndex % 2) ? this.space.indentLeftEven : this.space.indentLeftOdd;
            itemX = startX + (indentLeft * this.scaleX);
            for (var columnIndex = 0; columnIndex < this.columnCount; columnIndex++) {
                colWidth = this.getColumnWidth(columnIndex);

                child = this.getChildAt(columnIndex, rowIndex);
                if ((!child) || (child.rexSizer.hidden)) {
                    itemX += colWidth + (this.space.column[columnIndex] * this.scaleX);
                    continue;
                }

                PreLayoutChild.call(this, child);

                childWidth = this.getExpandedChildWidth(child, colWidth);
                childHeight = this.getExpandedChildHeight(child, rowHeight);
                if (child.isRexSizer) {
                    child.runLayout(this, childWidth, childHeight);
                    CheckSize(child, this);
                } else {
                    ResizeGameObject(child, childWidth, childHeight);
                }

                childConfig = child.rexSizer;
                padding = childConfig.padding;

                x = itemX + (padding.left * this.scaleX);
                width = colWidth - ((padding.left + padding.right) * this.scaleX);

                indentTop = (columnIndex % 2) ? this.space.indentTopEven : this.space.indentTopOdd;
                y = itemY + (indentTop * this.scaleY) + (padding.top * this.scaleY);
                height = rowHeight - ((padding.top + padding.bottom) * this.scaleY);

                if (childWidth === undefined) {
                    childWidth = GetDisplayWidth(child);
                }
                if (childHeight === undefined) {
                    childHeight = GetDisplayHeight(child);
                }
                alignOffsetX = (childConfig.alignOffsetX + (childConfig.alignOffsetOriginX * childWidth)) * this.scaleX;
                alignOffsetY = (childConfig.alignOffsetY + (childConfig.alignOffsetOriginY * childHeight)) * this.scaleY;

                LayoutChild.call(this,
                    child, x, y, width, height, childConfig.align,
                    alignOffsetX, alignOffsetY
                );

                itemX += colWidth + (this.space.column[columnIndex] * this.scaleX);
            }

            itemY += rowHeight + (this.space.row[rowIndex] * this.scaleY);
        }
    };

    var ResolveWidth = function (width) {
        var width = ResolveWidth$3.call(this, width);

        // Calculate proportionLength
        if ((width !== undefined) && (this.proportionWidthLength === undefined)) {
            var totalColumnProportions = this.totalColumnProportions;
            if (totalColumnProportions > 0) {
                var remainder = width - this.getChildrenWidth(false);
                if (remainder >= 0) {
                    this.proportionWidthLength = remainder / totalColumnProportions;
                }
            } else {
                this.proportionWidthLength = 0;
            }
        }

        return width;
    };

    var ResolveHeight = function (height) {
        var height = ResolveHeight$3.call(this, height);

        // Get proportionLength    
        if ((height !== undefined) && (this.proportionHeightLength === undefined)) {
            var totalRowProportions = this.totalRowProportions;
            if (totalRowProportions > 0) {
                var remainder = height - this.getChildrenHeight(false);
                if (remainder >= 0) {
                    this.proportionHeightLength = remainder / totalRowProportions;
                }
            } else {
                this.proportionHeightLength = 0;
            }
        }

        return height;
    };

    var ResolveChildrenWidth = function (parentWidth) {
        // Resolve width of sizer children
        var child, expandedChildWidth, childWidth;
        var colWidth;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (child && child.isRexSizer && !child.ignoreLayout) {
                colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
                expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
                childWidth = child.resolveWidth(expandedChildWidth);
                if (childWidth === undefined) {
                    childWidth = expandedChildWidth;
                }
                child.resolveChildrenWidth(childWidth);
            }
        }
    };

    var ResolveChildrenHeight = function (parentHeight) {
        // Resolve width of sizer children
        var child, expandedChildHeight, childHeight;
        var rowHeight;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (child && child.isRexSizer && !child.ignoreLayout) {
                rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
                expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
                childHeight = child.resolveHeight(expandedChildHeight);
                if (childHeight === undefined) {
                    childHeight = expandedChildHeight;
                }
                child.resolveChildrenHeight(childHeight);
            }
        }
    };

    var RunWidthWrap$1 = function (width) {
        var child, expandedChildWidth, childWidth;
        var colWidth;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (
                (!child) ||
                (child.isRexSizer && child.ignoreLayout) ||
                (!child.runWidthWrap)
            ) {
                continue;
            }

            colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
            expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
            if (child.isRexSizer) {
                childWidth = child.resolveWidth(expandedChildWidth);
                if (childWidth === undefined) {
                    childWidth = expandedChildWidth;
                }
            }
            child.runWidthWrap(childWidth);
        }
        return this;
    };

    var RunHeightWrap$1 = function (height) {
        var child, expandedChildHeight, childHeight;
        var rowHeight;
        for (var i in this.sizerChildren) {
            child = this.sizerChildren[i];
            if (
                (!child) ||
                (child.isRexSizer && child.ignoreLayout) ||
                (!child.runHeightWrap)
            ) {
                continue;
            }

            rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
            expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
            if (child.isRexSizer) {
                childHeight = child.resolveHeight(expandedChildHeight);
                if (childHeight === undefined) {
                    childHeight = expandedChildHeight;
                }
            }
            child.runHeightWrap(childHeight);
        }
        return this;
    };

    const IsPlainObject$h = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$1S = Phaser.Utils.Objects.GetValue;
    const ALIGN_CENTER$1 = Phaser.Display.Align.CENTER;


    var GetEmptyCellIndex = function (columnIndex, rowIndex, cells, columnCount, rowCount) {
        if ((typeof (columnIndex) === 'number') || (typeof (rowIndex) === 'number')) {
            if (columnIndex === undefined) {
                var idx;
                for (var i = 0; i < columnCount; i++) {
                    idx = (rowIndex * columnCount) + i;
                    if (!cells[idx]) {
                        return idx;
                    }
                }
            } else if (rowIndex === undefined) {
                var idx;
                for (var i = 0; i < rowCount; i++) {
                    idx = (i * columnCount) + columnIndex;
                    if (!cells[idx]) {
                        return idx;
                    }
                }
            } else {
                var idx = (rowIndex * columnCount) + columnIndex;
                if (!cells[idx]) {
                    return idx;
                }
            }

        } else if (rowIndex === true) {
            var idx;
            for (var i = 0; i < columnCount; i++) {
                for (var j = 0; j < rowCount; j++) {
                    idx = (j * columnCount) + i;
                    if (!cells[idx]) {
                        return idx;
                    }
                }
            }
        } else {
            for (var i = 0, cnt = cells.length; i < cnt; i++) {
                if (!cells[i]) {
                    return i;
                }
            }
        }
        return null;
    };

    var Add$4 = function (gameObject, columnIndex, rowIndex, align, paddingConfig, expand, childKey) {
        var offsetX, offsetY;
        var offsetOriginX, offsetOriginY;

        AddChild$1.call(this, gameObject);
        if (IsPlainObject$h(columnIndex)) {
            var config = columnIndex;
            columnIndex = GetValue$1S(config, 'column', undefined);
            rowIndex = GetValue$1S(config, 'row', undefined);
            align = GetValue$1S(config, 'align', ALIGN_CENTER$1);
            paddingConfig = GetValue$1S(config, 'padding', 0);
            expand = GetValue$1S(config, 'expand', false);
            childKey = GetValue$1S(config, 'key', undefined);

            offsetX = GetValue$1S(config, 'offsetX', 0);
            offsetY = GetValue$1S(config, 'offsetY', 0);
            offsetOriginX = GetValue$1S(config, 'offsetOriginX', 0);
            offsetOriginY = GetValue$1S(config, 'offsetOriginY', 0);
        }

        // Get insert index
        var itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
        if (itemIndex === null) {
            // Specific index mode
            if ((typeof (columnIndex) === 'number') && (typeof (rowIndex) === 'number')) {
                return this;
            }

            if ((rowIndex === true) || (typeof (rowIndex) === 'number')) {
                this.addEmptyColumn();
            } else {
                this.addEmptyRow();
            }

            // Get insert index again
            itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
        }

        if (typeof (align) === 'string') {
            align = AlignConst[align];
        }
        if (align === undefined) {
            align = ALIGN_CENTER$1;
        }
        if (paddingConfig === undefined) {
            paddingConfig = 0;
        }
        if (expand === undefined) {
            expand = true;
        }

        if (offsetX === undefined) {
            offsetX = 0;
        }
        if (offsetY === undefined) {
            offsetY = 0;
        }
        if (offsetOriginX === undefined) {
            offsetOriginX = 0;
        }
        if (offsetOriginY === undefined) {
            offsetOriginY = 0;
        }

        var config = this.getSizerConfig(gameObject);
        config.align = align;
        config.padding = GetBoundsConfig$1(paddingConfig);

        if (IsPlainObject$h(expand)) {
            config.expandWidth = GetValue$1S(expand, 'width', false);
            config.expandHeight = GetValue$1S(expand, 'height', false);
        } else {
            config.expandWidth = expand;
            config.expandHeight = expand;
        }

        config.alignOffsetX = offsetX;
        config.alignOffsetY = offsetY;
        config.alignOffsetOriginX = offsetOriginX;
        config.alignOffsetOriginY = offsetOriginY;

        this.sizerChildren[itemIndex] = gameObject;

        if (childKey !== undefined) {
            this.addChildrenMap(childKey, gameObject);
        }
        return this;
    };

    var AddChildMethods$5 = {
        add: Add$4
    };

    var Fill = function (arr, value, startIdx, endIdx) {
        if (startIdx === undefined) {
            startIdx = 0;
        }
        if (endIdx === undefined) {
            endIdx = arr.length - 1;
        }
        for (var i = startIdx; i <= endIdx; i++) {
            arr[i] = value;
        }
        return arr;
    };

    var RemoveChildMethods$4 = {
        remove(gameObject, destroyChild) {
            if (this.getParentSizer(gameObject) !== this) {
                return this;
            }

            var idx = this.sizerChildren.indexOf(gameObject);
            if (idx !== -1) {
                this.sizerChildren[idx] = null;
            }

            RemoveChild.call(this, gameObject, destroyChild);
            return this;
        },

        removeAt(columnIndex, rowIndex, destroyChild) {
            var child = this.getChildAt(columnIndex, rowIndex);
            if (child) {
                this.remove(child, destroyChild);
            }
            return this;
        },

        removeAll(destroyChild) {
            for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
                var child = this.sizerChildren[i];
                if (!child) {
                    continue;
                }

                this.remove(child, destroyChild);
            }
            return this;
        },

        clear(destroyChild) {
            Fill(this.sizerChildren, null);
            ClearChildren.call(this, destroyChild);
            return this;
        }
    };

    var SetSpaceMethods = {
        setColumnSpace(columnSpace) {
            if (!this.space.column) {
                this.space.column = [];
            }

            this.space.column.length = this.columnCount - 1;
            if (typeof (columnSpace) === 'number') {
                this.space.column0 = columnSpace;
                Fill(this.space.column, columnSpace);
            } else {
                this.space.column0 = columnSpace[0];
                for (var i = 0, cnt = this.columnCount - 1; i < cnt; i++) {
                    this.space.column[i] = columnSpace[i] || 0;
                }
            }
            return this;
        },

        setRowSpace(rowSpace) {
            if (!this.space.row) {
                this.space.row = [];
            }

            this.space.row.length = this.rowCount - 1;
            if (typeof (rowSpace) === 'number') {
                this.space.row0 = rowSpace;
                Fill(this.space.row, rowSpace);
            } else {
                this.space.row0 = rowSpace[i];
                for (var i = 0, cnt = this.rowCount - 1; i < cnt; i++) {
                    this.space.row[i] = rowSpace[i] || 0;
                }
            }

            return this;
        },

        setIndentLeft(odd, even) {
            this.space.indentLeftOdd = odd;
            this.space.indentLeftEven = even;
            return this;
        },

        setIndentTop(odd, even) {
            this.space.indentTopOdd = odd;
            this.space.indentTopEven = even;
            return this;
        }
    };

    const GetValue$1R = Phaser.Utils.Objects.GetValue;

    var ResetGrid = function (
        columnCount, rowCount,
        columnProportions, rowProportions,
        space
    ) {
        if (columnCount === undefined) { columnCount = 0; }
        if (rowCount === undefined) { rowCount = 0; }
        if (columnProportions === undefined) { columnProportions = 0; }
        if (rowProportions === undefined) { rowProportions = 0; }

        this.columnCount = columnCount;
        this.rowCount = rowCount;
        this.gridCount = columnCount * rowCount;

        // children
        this.removeAll();
        this.sizerChildren.length = columnCount * rowCount;
        Fill(this.sizerChildren, null);

        // proportions
        this.columnProportions = [];
        this.columnProportions.length = columnCount;
        if (typeof (columnProportions) === 'number') {
            Fill(this.columnProportions, columnProportions);
        } else {
            for (var i = 0; i < columnCount; i++) {
                this.columnProportions[i] = columnProportions[i] || 0;
            }
        }
        this.rowProportions = [];
        this.rowProportions.length = rowCount;
        if (typeof (rowProportions) === 'number') {
            Fill(this.rowProportions, rowProportions);
        } else {
            for (var i = 0; i < rowCount; i++) {
                this.rowProportions[i] = rowProportions[i] || 0;
            }
        }

        // width & height
        this.columnWidth = [];
        this.columnWidth.length = columnCount;
        this.rowHeight = [];
        this.rowHeight.length = rowCount;

        // space
        this.setColumnSpace(GetValue$1R(space, 'column', 0));
        this.setRowSpace(GetValue$1R(space, 'row', 0));

        var scene = this.scene;
        var createCellContainerCallback = this.createCellContainerCallback;
        if (createCellContainerCallback) {
            for (var y = 0, ycnt = this.rowCount; y < ycnt; y++) {
                for (var x = 0, xcnt = this.columnCount; x < xcnt; x++) {
                    var addConfig = { column: x, row: y };
                    var child = createCellContainerCallback(scene, x, y, addConfig);
                    if (child) {
                        this.add(child, addConfig);
                    }
                }
            }
        }

        return this;
    };

    var InsertEmptyRow = function (rowIndex, proportion, space) {
        if (proportion === undefined) {
            proportion = this.rowProportions[0] || 0;
        }
        if (space === undefined) {
            space = this.space.row0 || 0;
        }

        this.rowCount += 1;
        this.gridCount += this.columnCount;

        var args = [rowIndex * this.columnCount, 0];
        for (var i = 0; i < this.columnCount; i++) {
            args.push(null);
        }
        this.sizerChildren.splice.apply(this.sizerChildren, args);

        this.rowProportions.push(proportion);

        this.rowHeight.length += 1;  // this.rowHeight will be recalculated when layout()    

        this.space.row.splice(rowIndex, 0, space);

        return this;
    };

    var AddEmptyRow = function (proportion, space) {
        InsertEmptyRow.call(this, this.rowCount, proportion, space);
        return this;
    };

    var InsertEmptyColumn = function (colIndex, proportion, space) {
        if (proportion === undefined) {
            proportion = this.columnProportions[0] || 0;
        }
        if (space === undefined) {
            space = this.space.column0 || 0;
        }

        this.columnCount += 1;
        this.gridCount += this.rowCount;

        for (var i = this.rowCount - 1; i >= 0; i--) {
            var insertIndex = (i * this.columnCount) + colIndex;
            this.sizerChildren.splice(insertIndex, 0, null);
        }

        this.columnProportions.push(proportion);

        this.columnWidth.length += 1;  // this.columnWidth will be recalculated when layout()    

        this.space.column.splice(colIndex, 0, space);

        return this;
    };

    var AddEmptyColumn = function (proportion, space) {
        InsertEmptyColumn.call(this, this.columnCount, proportion, space);
        return this;
    };

    var methods$k = {
        getChildrenWidth: GetChildrenWidth$2,
        getChildrenHeight: GetChildrenHeight$2,
        getExpandedChildWidth: GetExpandedChildWidth$1,
        getExpandedChildHeight: GetExpandedChildHeight$1,
        getChildrenSizers: GetChildrenSizers$2,
        preLayout: PreLayout$2,
        layoutChildren: LayoutChildren$3,
        resolveWidth: ResolveWidth,
        resolveHeight: ResolveHeight,
        resolveChildrenWidth: ResolveChildrenWidth,
        resolveChildrenHeight: ResolveChildrenHeight,
        runWidthWrap: RunWidthWrap$1,
        runHeightWrap: RunHeightWrap$1,

        resetGrid: ResetGrid,
        insertEmptyRow: InsertEmptyRow,
        addEmptyRow: AddEmptyRow,
        insertEmptyColumn: InsertEmptyColumn,
        addEmptyColumn: AddEmptyColumn,
    };

    Object.assign(
        methods$k,
        AddChildMethods$5,
        RemoveChildMethods$4,
        SetSpaceMethods,
        SortChildrenMethods
    );

    var GetTotalColumnProportions = function () {
        var result = 0,
            proportion;
        for (var i = 0; i < this.columnCount; i++) {
            proportion = this.columnProportions[i];
            if (proportion > 0) {
                result += proportion;
            } else if (proportion === 0) {
                this.hasColumnProportion0Child = true;
            }
        }
        return result;
    };

    var GetTotalRowProportions = function () {
        var result = 0,
            proportion;
        for (var i = 0; i < this.rowCount; i++) {
            proportion = this.rowProportions[i];
            if (proportion > 0) {
                result += proportion;
            } else if (proportion === 0) {
                this.hasRowProportion0Child = true;
            }
        }
        return result;
    };

    const IsPlainObject$g = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$1Q = Phaser.Utils.Objects.GetValue;

    class GridSizer extends Base$1 {
        constructor(scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportions, config) {
            if (IsPlainObject$g(x)) {
                config = x;
                x = GetValue$1Q(config, 'x', 0);
                y = GetValue$1Q(config, 'y', 0);
                minWidth = GetValue$1Q(config, 'width', undefined);
                minHeight = GetValue$1Q(config, 'height', undefined);
                columnCount = GetValue$1Q(config, 'column', (config.col || 0));
                rowCount = GetValue$1Q(config, 'row', 0);
                columnProportions = GetValue$1Q(config, 'columnProportions', 0);
                rowProportions = GetValue$1Q(config, 'rowProportions', 0);
            } else if (IsPlainObject$g(minWidth)) {
                config = minWidth;
                minWidth = GetValue$1Q(config, 'width', undefined);
                minHeight = GetValue$1Q(config, 'height', undefined);
                columnCount = GetValue$1Q(config, 'column', (config.col || 0));
                rowCount = GetValue$1Q(config, 'row', 0);
                columnProportions = GetValue$1Q(config, 'columnProportions', 0);
                rowProportions = GetValue$1Q(config, 'rowProportions', 0);
            } else if (IsPlainObject$g(columnCount)) {
                config = columnCount;
                columnCount = GetValue$1Q(config, 'column', (config.col || 0));
                rowCount = GetValue$1Q(config, 'row', 0);
                columnProportions = GetValue$1Q(config, 'columnProportions', 0);
                rowProportions = GetValue$1Q(config, 'rowProportions', 0);
            } else if (IsPlainObject$g(columnProportions)) {
                config = columnProportions;
                columnProportions = GetValue$1Q(config, 'columnProportions', 0);
                rowProportions = GetValue$1Q(config, 'rowProportions', 0);
            }
            super(scene, x, y, minWidth, minHeight, config);

            this.type = 'rexGridSizer';
            this.sizerChildren = [];
            this.addChildrenMap('items', this.sizerChildren);
            this.setCreateCellContainerCallback(GetValue$1Q(config, 'createCellContainerCallback'));

            this.setIndentLeft(
                GetValue$1Q(config, 'space.indentLeftOdd', 0),
                GetValue$1Q(config, 'space.indentLeftEven', 0)
            );
            this.setIndentTop(
                GetValue$1Q(config, 'space.indentTopOdd', 0),
                GetValue$1Q(config, 'space.indentTopEven', 0)
            );

            this.resetGrid(
                columnCount, rowCount,
                columnProportions, rowProportions,
                GetValue$1Q(config, 'space', undefined)
            );

        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            super.destroy(fromScene);

            // More free resources
            this.columnProportions = undefined;
            this.rowProportions = undefined;
            this.columnWidth = undefined;
            this.rowHeight = undefined;
            this.createCellContainerCallback = undefined;
        }

        setColumnProportion(columnIndex, proportion) {
            if (columnIndex >= this.columnProportions.length) {
                return this;
            }
            this.columnProportions[columnIndex] = proportion;
            return this;
        }

        setRowProportion(rowIndex, proportion) {
            if (rowIndex >= this.rowProportions.length) {
                return this;
            }
            this.rowProportions[rowIndex] = proportion;
            return this;
        }

        get totalColumnProportions() {
            if (this._totalColumnProportions === undefined) {
                this._totalColumnProportions = GetTotalColumnProportions.call(this);
            }
            return this._totalColumnProportions;
        }

        get totalRowProportions() {
            if (this._totalRowProportions === undefined) {
                this._totalRowProportions = GetTotalRowProportions.call(this);
            }
            return this._totalRowProportions;
        }

        getChildAt(columnIndex, rowIndex) {
            return this.sizerChildren[(rowIndex * this.columnCount) + columnIndex];
        }

        childToGridIndex(child, out) {
            if (!child) {
                return null;
            }

            var index = this.sizerChildren.indexOf(child);
            if (index === -1) {
                return null;
            }

            if (out === undefined) {
                out = {};
            }
            out.x = index % this.columnCount;
            out.y = Math.floor(index / this.columnCount);
            return out;
        }

        getColumnWidth(columnIndex) {
            var colProportion = this.columnProportions[columnIndex];
            var colWidth = (colProportion === 0) ? this.columnWidth[columnIndex] : (colProportion * this.proportionWidthLength);
            return colWidth;
        }

        getRowHeight(rowIndex) {
            var rowProportion = this.rowProportions[rowIndex];
            var rowHeight = (rowProportion === 0) ? this.rowHeight[rowIndex] : (rowProportion * this.proportionHeightLength);
            return rowHeight;
        }

        setCreateCellContainerCallback(callback) {
            this.createCellContainerCallback = callback;
            return this;
        }
    }

    Object.assign(
        GridSizer.prototype,
        methods$k
    );

    ObjectFactory.register('gridSizer', function (x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportion, config) {
        var gameObject = new GridSizer(this.scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportion, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.GridSizer', GridSizer);

    var GetChildrenWidth$1 = function (minimumMode) {
        if (this.rexSizer.hidden) {
            return 0;
        }

        if (minimumMode === undefined) {
            minimumMode = true;
        }

        var childrenWidth;
        if (this.orientation === 0) {
            if (minimumMode) {
                childrenWidth = this.maxChildWidth;
            } else {
                childrenWidth = (this.rexSizer.resolved) ? this.wrapResult.width : undefined;
            }
        } else {
            childrenWidth = (this.rexSizer.resolved) ? this.wrapResult.width : undefined;
        }

        if (childrenWidth === undefined) {
            return undefined;
        }

        return childrenWidth + ((this.space.left + this.space.right) * this.scaleX);
    };

    var GetChildrenHeight$1 = function (minimumMode) {
        if (this.rexSizer.hidden) {
            return 0;
        }

        if (minimumMode === undefined) {
            minimumMode = true;
        }

        var childrenHeight;
        if (this.orientation === 1) {
            if (minimumMode) {
                childrenHeight = this.maxChildHeight;
            } else {
                childrenHeight = (this.rexSizer.resolved) ? this.wrapResult.height : undefined;
            }
        } else {
            childrenHeight = (this.rexSizer.resolved) ? this.wrapResult.height : undefined;
        }

        if (childrenHeight === undefined) {
            return undefined;
        }

        return childrenHeight + ((this.space.top + this.space.bottom) * this.scaleY);
    };

    var GetChildrenSizers$1 = function (out) {
        if (out === undefined) {
            out = [];
        }
        var children = this.sizerChildren, child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child === '\n') {
                continue;
            }
            if (child.isRexSizer) {
                out.push(child);
            }
        }
        return out;
    };

    var PreLayout$1 = function () {
        this._maxChildWidth = undefined;
        this._maxChildHeight = undefined;
        this.wrapResult = undefined;
        this.rexSizer.resolved = false;
        PreLayout$4.call(this);
        return this;
    };

    var LayoutChildren$2 = function () {
        var horizontalWrap = (this.orientation === 0);

        var innerLineWidth = (horizontalWrap) ? this.innerWidth : this.innerHeight;
        var child, childConfig, padding, justifySpace = 0, indentLeft, indentTop;
        var startX = this.innerLeft,
            startY = this.innerTop;
        var x, y, width, height, alignOffsetX, alignOffsetY; // Align zone
        var lines = this.wrapResult.lines;  // Get this.wrapResult from RunChildrenWrap()
        var line, lineChlidren, remainderLineWidth;

        var itemX = startX,
            itemY = startY;
        for (var i = 0, icnt = lines.length; i < icnt; i++) {
            // Layout this line
            line = lines[i];
            lineChlidren = line.children;
            if (this.rtl) {
                lineChlidren.reverse();
            }

            if (horizontalWrap) {
                indentLeft = (i % 2) ? this.space.indentLeftEven : this.space.indentLeftOdd;
                itemX = startX + (indentLeft * this.scaleX);
            } else {
                indentTop = (i % 2) ? this.space.indentTopEven : this.space.indentTopOdd;
                itemY = startY + (indentTop * this.scaleY);
            }

            remainderLineWidth = innerLineWidth - ((horizontalWrap) ? line.width : line.height);

            switch (this.align) {
                case 0: // left
                    break;

                case 1: // right
                    if (horizontalWrap) {
                        itemX += remainderLineWidth;
                    } else {
                        itemY += remainderLineWidth;
                    }
                    break;

                case 2: // center
                    if (horizontalWrap) {
                        itemX += remainderLineWidth / 2;
                    } else {
                        itemY += remainderLineWidth / 2;
                    }
                    break;

                case 3: // justify-left            
                    justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
                    break;

                case 4: // justify-right
                    justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
                    if (justifySpace === 0) {
                        // Align right
                        if (horizontalWrap) {
                            itemX += remainderLineWidth;
                        } else {
                            itemY += remainderLineWidth;
                        }
                    }
                    break;

                case 5: // justify-center
                    justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
                    if (justifySpace === 0) {
                        // Align center
                        if (horizontalWrap) {
                            itemX += remainderLineWidth / 2;
                        } else {
                            itemY += remainderLineWidth / 2;
                        }
                    }
                    break;
            }

            var isFirstChild = true;
            for (var j = 0, jcnt = lineChlidren.length; j < jcnt; j++) {
                child = lineChlidren[j];
                if (child.rexSizer.hidden) {
                    continue;
                }

                childConfig = child.rexSizer;
                padding = childConfig.padding;

                PreLayoutChild.call(this, child);

                if (horizontalWrap) {
                    x = itemX + (padding.left * this.scaleX);
                } else {
                    y = itemY + (padding.top * this.scaleY);
                }

                if (isFirstChild) {
                    isFirstChild = false;
                } else {
                    if (horizontalWrap) {
                        x += (this.space.item * this.scaleX);
                    } else {
                        y += (this.space.item * this.scaleY);
                    }
                }

                width = GetDisplayWidth(child);
                height = GetDisplayHeight(child);

                if (horizontalWrap) {
                    indentTop = (j % 2) ? this.space.indentTopEven : this.space.indentTopOdd;
                    y = itemY + (indentTop * this.scaleY) + (padding.top * this.scaleY);
                    itemX = x + width + (padding.right * this.scaleX) + justifySpace;
                } else {
                    indentLeft = (j % 2) ? this.space.indentLeftEven : this.space.indentLeftOdd;
                    x = itemX + (indentLeft * this.scaleX) + (padding.left * this.scaleX);
                    itemY = y + height + (padding.top * this.scaleY) + justifySpace;
                }

                alignOffsetX = (childConfig.alignOffsetX + (childConfig.alignOffsetOriginX * width)) * this.scaleX;
                alignOffsetY = (childConfig.alignOffsetY + (childConfig.alignOffsetOriginY * height)) * this.scaleY;

                LayoutChild.call(this,
                    child, x, y, width, height, childConfig.align,
                    alignOffsetX, alignOffsetY
                );
            }

            if (horizontalWrap) {
                itemY += line.height + (this.space.line * this.scaleY);
            } else {
                itemX += line.width + (this.space.line * this.scaleX);
            }
        }
    };

    var GetJustifySpace = function (total, remainder, justifyPercentage, childCount) {
        return ((remainder / total) <= justifyPercentage) ? (remainder / (childCount - 1)) : 0;
    };

    var HasWidthWrap = function () {
        if (this.orientation === 0) {
            return true;
        }

        return HasWidthWrap$2.call(this);
    };

    var RunChildrenWrap = function (lineWidth) {
        var out = {
            lines: [],
            width: 0,
            height: 0
        };

        var children = this.sizerChildren;
        var child, padding, childWidth, childHeight, remainder = 0, indentLeft, indentTop;
        var lines = out.lines,
            lastLine = undefined,
            newLine;

        if (this.orientation === 0) { // x
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = children[i];
                if (child === '\n') {
                    child = undefined;
                    childWidth = 0;
                    newLine = true;
                } else {
                    if (child.rexSizer.hidden) {
                        continue;
                    }

                    if (child.isRexSizer) {
                        child.runLayout(this);
                    }

                    childWidth = this.getChildWidth(child);
                    padding = child.rexSizer.padding;
                    childWidth += ((padding.left + padding.right) * this.scaleX);

                    newLine = (remainder < childWidth) || (lastLine === undefined);
                }
                // New line
                if (newLine) {
                    if (lastLine) {
                        lastLine.width = lineWidth - (remainder + (this.space.item * this.scaleX));
                        out.width = Math.max(out.width, lastLine.width);
                        out.height += lastLine.height + (this.space.line * this.scaleY);
                    }

                    lastLine = {
                        children: [],
                        width: 0,
                        height: 0
                    };
                    lines.push(lastLine);

                    indentLeft = (lines.length % 2) ? this.space.indentLeftOdd : this.space.indentLeftEven;
                    remainder = lineWidth - (indentLeft * this.scaleX);
                }

                remainder -= childWidth + (this.space.item * this.scaleX);
                if (child) {
                    lastLine.children.push(child);

                    childHeight = this.getChildHeight(child);
                    padding = child.rexSizer.padding;
                    childHeight += (padding.top + padding.bottom) * this.scaleY;

                    lastLine.height = Math.max(lastLine.height, childHeight);
                }
            }

            if (lastLine) {
                lastLine.width = lineWidth - (remainder + (this.space.item * this.scaleX));
                out.width = Math.max(out.width, lastLine.width);
                out.height += lastLine.height;
            }

            out.height += Math.max(this.space.indentTopOdd, this.space.indentTopEven) * this.scaleY;
        } else {

            var lineHeight = lineWidth;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = children[i];
                if (child === '\n') {
                    child = undefined;
                    childWidth = 0;
                    newLine = true;
                } else {
                    if (child.rexSizer.hidden) {
                        continue;
                    }

                    if (child.isRexSizer) {
                        child.layout(); // Use original size
                    }

                    childHeight = this.getChildHeight(child);
                    padding = child.rexSizer.padding;
                    childHeight += (padding.top + padding.bottom) * this.scaleY;

                    newLine = (remainder < childHeight) || (lastLine === undefined);
                }
                // New line
                if (newLine) {
                    if (lastLine) {
                        lastLine.height = lineHeight - (remainder + (this.space.item * this.scaleY));
                        out.height = Math.max(out.height, lastLine.height);
                        out.width += lastLine.width + (this.space.line * this.scaleX);
                    }

                    lastLine = {
                        children: [],
                        width: 0,
                        height: 0
                    };
                    lines.push(lastLine);

                    indentTop = (lines.length % 2) ? this.space.indentTopOdd : this.space.indentTopEven;
                    remainder = lineHeight - (indentTop * this.scaleY);
                }

                remainder -= childHeight + (this.space.item * this.scaleY);
                if (child) {
                    lastLine.children.push(child);

                    childWidth = this.getChildWidth(child);
                    padding = child.rexSizer.padding;
                    childWidth += (padding.left + padding.right) * this.scaleX;

                    lastLine.width = Math.max(lastLine.width, childWidth);
                }
            }

            if (lastLine) {
                lastLine.height = lineHeight - (remainder + (this.space.item * this.scaleY));
                out.height = Math.max(out.height, lastLine.height);
                out.width += lastLine.width;
            }

            out.width += Math.max(this.space.indentLeftOdd, this.space.indentLeftEven) * this.scaleX;
        }

        return out;
    };

    var RunWidthWrap = function (width) {
        if (this.wrapResult) {
            // Already got wrapResult
            return;
        }

        if (this.orientation === 0) {
            var innerWidth = width - ((this.space.left + this.space.right) * this.scaleX);
            this.wrapResult = RunChildrenWrap.call(this, innerWidth);
            this.rexSizer.resolved = true;
            RunWidthWrap$3.call(this, width);
        }
    };

    var HasHeightWrap = function () {
        if (this.orientation === 1) {
            return true;
        }

        return HasHeightWrap$2.call(this);
    };

    var RunHeightWrap = function (height) {
        if (this.wrapResult) {
            // Already got wrapResult
            return;
        }

        if (this.orientation === 1) {
            var innerHeight = height - ((this.space.top + this.space.bottom) * this.scaleY);
            this.wrapResult = RunChildrenWrap.call(this, innerHeight);
            this.rexSizer.resolved = true;
            RunHeightWrap$3.call(this, height);
        }
    };

    // Override
    var GetExpandedChildWidth = function (child, parentWidth) {
        return undefined;
    };

    // Override
    var GetExpandedChildHeight = function (child, parentHeight) {
        return undefined;
    };

    const DistanceBetween$2 = Phaser.Math.Distance.Between;

    var GetNearestChildIndex = function (x, y) {
        var children = this.sizerChildren;
        if (children.length === 0) {
            return -1;
        }

        var nearestIndex = -1,
            minDistance = Infinity;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            // position is not at this line
            if (Math.abs(child.centerY - y) > (child.height / 2)) {
                continue;
            }

            // Check left bound
            var distance = DistanceBetween$2(child.left, child.centerY, x, y);
            if (minDistance > distance) {
                minDistance = distance;
                nearestIndex = i;
            }

            // Is last child of this line
            var nextChild = children[i + 1];
            if (nextChild && (nextChild.y === child.y)) {
                continue;
            }

            var distance = DistanceBetween$2(child.right, child.centerY, x, y);
            if (minDistance > distance) {
                minDistance = distance;
                nearestIndex = i + 1;
            }
        }

        return nearestIndex;
    };

    const IsPlainObject$f = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$1P = Phaser.Utils.Objects.GetValue;
    const ALIGN_CENTER = Phaser.Display.Align.CENTER;

    var Add$3 = function (gameObject, paddingConfig, childKey, index) {
        if (gameObject === '\n') {
            this.addNewLine();
            return this;
        }

        var offsetX, offsetY;
        var offsetOriginX, offsetOriginY;

        AddChild$1.call(this, gameObject);

        if (IsPlainObject$f(paddingConfig)) {
            var config = paddingConfig;
            paddingConfig = GetValue$1P(config, 'padding', 0);
            childKey = GetValue$1P(config, 'key', undefined);
            index = GetValue$1P(config, 'index', undefined);

            offsetX = GetValue$1P(config, 'offsetX', 0);
            offsetY = GetValue$1P(config, 'offsetY', 0);
            offsetOriginX = GetValue$1P(config, 'offsetOriginX', 0);
            offsetOriginY = GetValue$1P(config, 'offsetOriginY', 0);
        }
        if (paddingConfig === undefined) {
            paddingConfig = 0;
        }

        if (offsetX === undefined) {
            offsetX = 0;
        }
        if (offsetY === undefined) {
            offsetY = 0;
        }
        if (offsetOriginX === undefined) {
            offsetOriginX = 0;
        }
        if (offsetOriginY === undefined) {
            offsetOriginY = 0;
        }

        var config = this.getSizerConfig(gameObject);
        config.align = ALIGN_CENTER;
        config.padding = GetBoundsConfig$1(paddingConfig);
        config.alignOffsetX = offsetX;
        config.alignOffsetY = offsetY;
        config.alignOffsetOriginX = offsetOriginX;
        config.alignOffsetOriginY = offsetOriginY;

        if ((index === undefined) || (index >= this.sizerChildren.length)) {
            this.sizerChildren.push(gameObject);
        } else {
            this.sizerChildren.splice(index, 0, gameObject);
        }

        if (childKey !== undefined) {
            this.addChildrenMap(childKey, gameObject);
        }
        return this;
    };

    var AddChildMethods$4 = {
        add(gameObject, paddingConfig, childKey) {
            if (IsArray(gameObject)) {
                var gameObjects = gameObject;
                for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                    Add$3.call(this, gameObjects[i], paddingConfig);
                }
            } else {
                Add$3.call(this, gameObject, paddingConfig, childKey);
            }
            return this;
        },

        addNewLine() {
            this.sizerChildren.push('\n');
            return this;
        },

        insert(index, gameObject, paddingConfig, childKey) {
            Add$3.call(this, gameObject, paddingConfig, childKey, index);
            return this;
        },

        insertAtPosition(x, y, gameObject, paddingConfig, childKey) {
            var index = GetNearestChildIndex.call(this, x, y);
            if (index === -1) {
                index = undefined;
            }
            this.insert(index, gameObject, paddingConfig, childKey);
            return this;
        }
    };

    const RemoveItem$1 = Phaser.Utils.Array.Remove;

    var RemoveChildMethods$3 = {
        remove(gameObject, destroyChild) {
            if (this.getParentSizer(gameObject) !== this) {
                return this;
            }
            RemoveItem$1(this.sizerChildren, gameObject);
            RemoveChild.call(this, gameObject, destroyChild);
            return this;
        },

        removeAll(destroyChild) {
            for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
                this.remove(this.sizerChildren[i], destroyChild);
            }
            return this;
        },

        clear(destroyChild) {
            this.sizerChildren.length = 0;
            ClearChildren.call(this, destroyChild);
            return this;
        }
    };

    var methods$j = {
        getChildrenWidth: GetChildrenWidth$1,
        getChildrenHeight: GetChildrenHeight$1,
        getChildrenSizers: GetChildrenSizers$1,
        preLayout: PreLayout$1,
        layoutChildren: LayoutChildren$2,
        hasWidthWrap: HasWidthWrap,
        runWidthWrap: RunWidthWrap,
        hasHeightWrap: HasHeightWrap,
        runHeightWrap: RunHeightWrap,
        getExpandedChildWidth: GetExpandedChildWidth,
        getExpandedChildHeight: GetExpandedChildHeight,

    };

    Object.assign(
        methods$j,
        AddChildMethods$4,
        RemoveChildMethods$3,
        SortChildrenMethods
    );

    var GetMaxChildWidth = function (children) {
        if (children === undefined) {
            children = this.sizerChildren;
        }
        var result = 0;
        var child, childWidth;
        var hasUnknownChildWidth = false;

        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child === '\n') {
                continue;
            }

            childWidth = this.getChildWidth(child);
            if (childWidth === undefined) {
                hasUnknownChildWidth = true;
            }

            if (hasUnknownChildWidth) {
                continue;
            }

            result = Math.max(childWidth, result);
        }
        
        if (hasUnknownChildWidth) {
            return undefined;
        }

        return result;
    };

    var GetMaxChildHeight = function (children) {
        if (children === undefined) {
            children = this.sizerChildren;
        }
        var result = 0;
        var child, childHeight;
        var hasUnknownChildHeight = false;

        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child === '\n') {
                continue;
            }

            childHeight = this.getChildHeight(child);
            if (childHeight === undefined) {
                hasUnknownChildHeight = true;
            }

            if (hasUnknownChildHeight) {
                continue;
            }

            result = Math.max(childHeight, result);
        }

        if (hasUnknownChildHeight) {
            return undefined;
        }

        return result;
    };

    const IsPlainObject$e = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$1O = Phaser.Utils.Objects.GetValue;

    class FixWidthSizer extends Base$1 {
        constructor(scene, x, y, minWidth, minHeight, config) {
            if (IsPlainObject$e(x)) {
                config = x;
                x = GetValue$1O(config, 'x', 0);
                y = GetValue$1O(config, 'y', 0);
                minWidth = GetValue$1O(config, 'width', undefined);
                minHeight = GetValue$1O(config, 'height', undefined);
            } else if (IsPlainObject$e(minWidth)) {
                config = minWidth;
                minWidth = GetValue$1O(config, 'width', undefined);
                minHeight = GetValue$1O(config, 'height', undefined);
            }

            super(scene, x, y, minWidth, minHeight, config);
            this.type = 'rexFixWidthSizer';
            this.sizerChildren = [];

            this.runChildrenWrapFlag = true;

            this.setOrientation(GetValue$1O(config, 'orientation', 0));
            this.setItemSpacing(GetValue$1O(config, 'space.item', 0));
            this.setLineSpacing(GetValue$1O(config, 'space.line', 0));
            this.setIntentLeft(
                GetValue$1O(config, 'space.indentLeftOdd', 0),
                GetValue$1O(config, 'space.indentLeftEven', 0)
            );
            this.setIntentTop(
                GetValue$1O(config, 'space.indentTopOdd', 0),
                GetValue$1O(config, 'space.indentTopEven', 0)
            );
            this.setAlign(GetValue$1O(config, 'align', 0));
            this.setJustifyPercentage(GetValue$1O(config, 'justifyPercentage', 0.25));
            this.setRTL(GetValue$1O(config, 'rtl', false));

            this.wrapResult = undefined;  // {lines, width, height}

            this.addChildrenMap('items', this.sizerChildren);
        }

        setOrientation(orientation) {
            this.orientation = GetOrientationMode(orientation);
            return this;
        }

        setItemSpacing(space) {
            this.space.item = space;
            return this;
        }

        setLineSpacing(space) {
            this.space.line = space;
            return this;
        }

        setIntentLeft(odd, even) {
            this.space.indentLeftOdd = odd;
            this.space.indentLeftEven = even;
            return this;
        }

        setIntentTop(odd, even) {
            this.space.indentTopOdd = odd;
            this.space.indentTopEven = even;
            return this;
        }

        setAlign(align) {
            if (typeof (align) === 'string') {
                align = ALIGN[align];
            }
            this.align = align;
            return this;
        }

        setJustifyPercentage(value) {
            this.justifyPercentage = value;
            return this;
        }

        setRTL(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.rtl = enabled;
            return this;
        }

        get maxChildWidth() {
            if (this._maxChildWidth === undefined) {
                this._maxChildWidth = GetMaxChildWidth.call(this);
            }
            return this._maxChildWidth;
        }

        get maxChildHeight() {
            if (this._maxChildHeight === undefined) {
                this._maxChildHeight = GetMaxChildHeight.call(this);
            }
            return this._maxChildHeight;
        }
    }

    const ALIGN = {
        left: 0, top: 0,
        right: 1, bottom: 1,
        center: 2,
        justify: 3,
        'justify-left': 3, 'justify-top': 3,
        'justify-right': 4, 'justify-bottom': 4,
        'justify-center': 5
    };

    Object.assign(
        FixWidthSizer.prototype,
        methods$j
    );

    ObjectFactory.register('fixWidthSizer', function (x, y, minWidth, minHeight, config) {
        var gameObject = new FixWidthSizer(this.scene, x, y, minWidth, minHeight, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.FixWidthSizer', FixWidthSizer);

    ObjectFactory.register('overlapSizer', function (x, y, minWidth, minHeight, config) {
        var gameObject = new OverlapSizer(this.scene, x, y, minWidth, minHeight, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.OverlapSizer', OverlapSizer);

    ObjectFactory.register('space', function () {
        var gameObject = new Space(this.scene);
        // Don't add Zone into scene
        // this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Space', Space);

    ObjectFactory.register('label', function (config) {
        var gameObject = new Label(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Label', Label);

    const Properties = [
        'alpha', 'tint', 'flipX', 'flipY'
    ];

    var DecorateGameObject = function (gameObject, config) {
        if (!config) {
            return gameObject;
        }

        for (var i = 0, cnt = Properties.length; i < cnt; i++) {
            var propertyName = Properties[i];
            if ((propertyName in config) && (propertyName in gameObject)) {
                gameObject[propertyName] = config[propertyName];
            }
        }

        if (('origin' in config) && ('originX' in gameObject)) {
            gameObject.setOrigin(config.origin);
        } else {
            var originX, originY;
            if (('originX' in config) && ('originX' in gameObject)) {
                originX = config.originX;
            }
            if (('originY' in config) && ('originY' in gameObject)) {
                originY = config.originY;
            }
            if ((originX !== undefined) && (originY !== undefined)) {
                gameObject.setOrigin(originX, originY);
            }
        }

        return gameObject;
    };

    var CreateBackground$2 = function (scene, config) {
        var gameObjectType;
        if (config) {
            if (config.hasOwnProperty('$type')) {
                gameObjectType = config.$type;
            } else {
                if (config.hasOwnProperty('barColor')) {
                    gameObjectType = 'bar';
                } else if (config.hasOwnProperty('leftWidth')) {
                    gameObjectType = 'nineSlice';
                } else if (config.hasOwnProperty('key')) {
                    gameObjectType = 'image';
                }
            }
        }

        var gameObject;
        switch (gameObjectType) {
            case 'bar':
                gameObject = new StatesBarRectangle(scene, config);
                break;

            case 'image':
                gameObject = new StatesImage(scene, config);
                break;

            case 'nineSlice':
                if (!config.hasOwnProperty('stretchMode')) {
                    gameObject = new StatesNineSlice(scene, config);
                } else {
                    gameObject = new StatesNinePatch(scene, config);
                }
                break;

            default:
                gameObject = new StatesRoundRectangle(scene, config);
                break;
        }

        DecorateGameObject(gameObject, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    var ResizeController = function () {
        switch (this.scrollMode) {
            case 0:
            case 1:
                SetControllerBounds.call(this);

                this.updateController();

                HideUnscrollableSlider.call(this);

                AdaptThumbSize.call(this);

                break;

            default: // 2
                SetControllerBounds.call(this, 'y');
                SetControllerBounds.call(this, 'x');

                this.updateController();

                HideUnscrollableSlider.call(this, 'y');
                HideUnscrollableSlider.call(this, 'x');

                AdaptThumbSize.call(this, 'y');
                AdaptThumbSize.call(this, 'x');
                break;
        }

        return this;
    };


    var SetControllerBounds = function (axis) {
        // Scale will force to 1
        var bound0, bound1;
        var scroller, slider;
        switch (this.scrollMode) {
            case 0:
            case 1:
                bound0 = this.topChildOY;
                bound1 = this.bottomChildOY;
                scroller = this.childrenMap.scroller;
                slider = this.childrenMap.slider;
                axis = (this.scrollMode === 0) ? 'Y' : 'X';
                break;

            default:  // 2
                axis = axis.toUpperCase();
                if (axis === 'Y') {
                    bound0 = this.topChildOY;
                    bound1 = this.bottomChildOY;
                } else {
                    bound0 = this.leftChildOX;
                    bound1 = this.rightChildOX;
                }
                scroller = this.childrenMap[`scroller${axis}`];
                slider = this.childrenMap[`slider${axis}`];
        }

        var scale = (axis === 'Y') ? this.scaleY : this.scaleX;
        bound1 *= scale;

        if (scroller) {
            scroller.setBounds(bound0, bound1);
        }
        if (slider) {
            slider.setEnable(bound0 !== bound1);

            if (slider.tickLength) {
                slider.setTick(slider.tickLength, bound0, bound1);
            }
        }
    };

    var HideUnscrollableSlider = function (axis) {
        switch (this.scrollMode) {
            case 0:
            case 1:
                var slider = this.childrenMap.slider;
                if (slider && this.hideUnscrollableSlider) {
                    this.setChildVisible(slider, this.isOverflow);
                }

                var scroller = this.childrenMap.scroller;
                if (scroller && this.disableUnscrollableDrag) {
                    scroller.setEnable(this.isOverflow);
                }

                break;

            default:
                axis = axis.toUpperCase();
                var isOverflow = this[`isOverflow${axis}`];

                var slider = this.childrenMap[`slider${axis}`];
                var hideUnscrollableSlider = this[`hideUnscrollableSlider${axis}`];
                if (slider && hideUnscrollableSlider) {
                    this.setChildVisible(slider, isOverflow);
                }

                var scroller = this.childrenMap.scroller;
                var disableUnscrollableDrag = this[`disableUnscrollableDrag${axis}`];
                if (scroller && disableUnscrollableDrag) {
                    scroller.setEnable(isOverflow);
                }
                break;
        }
    };

    var AdaptThumbSize = function (axis) {
        switch (this.scrollMode) {
            case 0:
            case 1:
                if (!this.adaptThumbSizeMode) {
                    return;
                }
                var slider = this.childrenMap.slider;
                if (!slider) {
                    return;
                }

                // Change slider size according to visible ratio
                var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
                var track = slider.childrenMap.track;
                var thumb = slider.childrenMap.thumb;
                var minThumbSize = this.minThumbSize;
                if (this.scrollMode === 0) {
                    var newHeight = track.displayHeight * ratio;
                    if ((minThumbSize !== undefined) && (newHeight < minThumbSize)) {
                        newHeight = minThumbSize;
                    }
                    ResizeGameObject(thumb, undefined, newHeight);
                } else {
                    var newWidth = track.displayWidth * ratio;
                    if ((minThumbSize !== undefined) && (newWidth < minThumbSize)) {
                        newWidth = minThumbSize;
                    }
                    ResizeGameObject(thumb, newWidth, undefined);

                }
                LayoutSlider(slider);
                break;

            default:
                // TODO
                axis = axis.toUpperCase();
                var adaptThumbSizeMode = this[`adaptThumb${axis}SizeMode`];
                if (!adaptThumbSizeMode) {
                    return;
                }
                var slider = this.childrenMap[`slider${axis}`];
                if (!slider) {
                    return;
                }

                // Change slider size according to visible ratio            
                var track = slider.childrenMap.track;
                var thumb = slider.childrenMap.thumb;
                var minThumbSize = this[`minThumb${axis}Size`];
                if (axis === 'Y') {
                    var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
                    var newHeight = track.displayHeight * ratio;
                    if ((minThumbSize !== undefined) && (newHeight < minThumbSize)) {
                        newHeight = minThumbSize;
                    }
                    ResizeGameObject(thumb, undefined, newHeight);
                } else {
                    var ratio = Math.min(this.childVisibleWidth / this.childWidth, 1);
                    var newWidth = track.displayWidth * ratio;
                    if ((minThumbSize !== undefined) && (newWidth < minThumbSize)) {
                        newWidth = minThumbSize;
                    }
                    ResizeGameObject(thumb, newWidth, undefined);

                }
                LayoutSlider(slider);
                break;

        }


    };

    var LayoutSlider = function (slider) {
        // Save minSize
        var minWidthSave = slider.minWidth;
        var minHeightSave = slider.minHeight;
        // Set minSize to current size
        slider.minWidth = slider.width;
        slider.minHeight = slider.height;
        // Layout slider
        slider.layout();
        // Restore minSize
        slider.minWidth = minWidthSave;
        slider.minHeight = minHeightSave;
    };

    var UpdateController = function () {
        switch (this.scrollMode) {
            case 0:
            case 1:
                var scroller = this.childrenMap.scroller;
                var slider = this.childrenMap.slider;
                if (scroller) {
                    scroller.setValue(this.childOY);
                }
                if (slider) {
                    slider.setValue(this.t);
                }
                break;

            default:
                var scrollerY = this.childrenMap.scrollerY;
                var sliderY = this.childrenMap.sliderY;
                var scrollerX = this.childrenMap.scrollerX;
                var sliderX = this.childrenMap.sliderX;

                if (scrollerY) {
                    scrollerY.setValue(this.childOY);
                }
                if (sliderY) {
                    sliderY.setValue(this.t);
                }
                if (scrollerX) {
                    scrollerX.setValue(this.childOX);
                }
                if (sliderX) {
                    sliderX.setValue(this.s);
                }
                break;
        }

    };

    const Clamp$8 = Phaser.Math.Clamp;

    var ChildPositionMethods = {
        setChildOY(value, clamp) {
            if (clamp === undefined) {
                clamp = false;
            }
            if (clamp) {
                value = Clamp$8(value, this.bottomChildOY, this.topChildOY);
            }
            this.childOY = value;
            return this;
        },

        addChildOY(inc, clamp) {
            this.setChildOY(this.childOY + inc, clamp);
            return this;
        },

        setT(value, clamp) {
            if (clamp === undefined) {
                clamp = false;
            }
            if (clamp) {
                value = Clamp$8(value, 0, 1);
            }
            this.t = value;
            return this;
        },

        addT(inc, clamp) {
            this.setT(this.t + inc, clamp);
            return this;
        },

        scrollToTop() {
            this.t = 0;
            return this;
        },

        scrollToBottom() {
            this.t = 1;
            // t will be 0 if panel/table does not exceed visible area
            if (this.t === 0) {
                return this;
            }

            // Panel/Table height might be expanded while cells are visible        
            do {
                this.t = 1;
            } while (this.t !== 1)

            return this;
        },

        setChildOX(value, clamp) {
            if (clamp === undefined) {
                clamp = false;
            }
            if (clamp) {
                value = Clamp$8(value, this.leftChildOX, this.rightChildOX);
            }
            this.childOX = value;
            return this;
        },

        addChildOX(inc, clamp) {
            this.setChildOX(this.childOX + inc, clamp);
            return this;
        },

        setS(value, clamp) {
            if (clamp === undefined) {
                clamp = false;
            }
            if (clamp) {
                value = Clamp$8(value, 0, 1);
            }
            this.s = value;
            return this;
        },

        addS(inc, clamp) {
            this.setS(this.s + inc, clamp);
            return this;
        },

        scrollToLeft() {
            this.s = 0;
            return this;
        },

        scrollToRight() {
            this.s = 1;
            // s will be 0 if panel/table does not exceed visible area
            if (this.s === 0) {
                return this;
            }

            // Panel/Table height might be expanded while cells are visible        
            do {
                this.s = 1;
            } while (this.s !== 1)

            return this;
        },

    };

    var Methods$8 = {
        resizeController: ResizeController,
        updateController: UpdateController
    };

    Object.assign(
        Methods$8,
        ChildPositionMethods
    );

    var SCROLLMODE$1 = {
        v: 0,
        vertical: 0,
        y: 0,

        h: 1,
        horizontal: 1,
        x: 1,

        xy: 2,
        vh: 2,
    };

    var GetScrollMode = function (config, key) {
        if (key === undefined) {
            key = 'scrollMode';
        }

        if (!config.hasOwnProperty(key)) {
            config[key] = GetDefaultScrollMode(config);
        }

        var scrollMode = config[key];
        if (typeof (scrollMode) === 'string') {
            scrollMode = SCROLLMODE$1[scrollMode];
        }

        return scrollMode;
    };

    var GetDefaultScrollMode = function (config) {
        var hasSliderY = (!!config.sliderY) || (!!config.scrollerY);
        var hasSliderX = (!!config.sliderX) || (!!config.scrollerX);
        var scrollMode;
        if (hasSliderY && hasSliderX) {
            scrollMode = 2;
        } else if (hasSliderY) {
            scrollMode = 0;
        } else if (hasSliderX) {
            scrollMode = 1;
        } else {
            scrollMode = 0;
        }
        return scrollMode;
    };

    const GetValue$1N = Phaser.Utils.Objects.GetValue;

    var AddChild = function (topPatent, childParent, config) {
        var childConfig = GetValue$1N(config, 'child');
        var child = GetValue$1N(childConfig, 'gameObject', undefined);
        if (child) {
            var childSpace = GetValue$1N(config, 'space.child', 0);
            topPatent.childMargin = {};
            var childMargin = topPatent.childMargin;
            var childPadding = {};

            if (typeof (childSpace) === 'number') {
                // Legacy, add childSpace to slider
                switch (topPatent.scrollMode) {
                    case 0:
                    case 1:
                        childMargin.top = 0;
                        childMargin.bottom = 0;
                        childMargin.left = 0;
                        childMargin.right = 0;
                        break;

                    default:
                        childMargin.top = childSpace;
                        childMargin.bottom = childSpace;
                        childMargin.left = childSpace;
                        childMargin.right = childSpace;
                        break;
                }
            } else {
                switch (topPatent.scrollMode) {
                    case 0:
                        childMargin.top = GetValue$1N(childSpace, 'top', 0);
                        childMargin.bottom = GetValue$1N(childSpace, 'bottom', 0);

                        childPadding.left = GetValue$1N(childSpace, 'left', 0);
                        childPadding.right = GetValue$1N(childSpace, 'right', 0);
                        break;

                    case 1:
                        childMargin.top = GetValue$1N(childSpace, 'left', 0);
                        childMargin.bottom = GetValue$1N(childSpace, 'right', 0);

                        childPadding.top = GetValue$1N(childSpace, 'top', 0);
                        childPadding.bottom = GetValue$1N(childSpace, 'bottom', 0);
                        break;

                    default: // 2
                        childMargin.top = GetValue$1N(childSpace, 'top', 0);
                        childMargin.bottom = GetValue$1N(childSpace, 'bottom', 0);
                        childMargin.left = GetValue$1N(childSpace, 'left', 0);
                        childMargin.right = GetValue$1N(childSpace, 'right', 0);
                        break;

                }
            }

            childParent.add(child,
                {
                    column: 1,
                    row: 1,
                    align: GetValue$1N(childConfig, 'align', 'center'),
                    padding: childPadding,
                    expand: {
                        width: GetValue$1N(childConfig, 'expandWidth', true),  // Private
                        height: GetValue$1N(childConfig, 'expandHeight', true) // Private
                    }
                }
            );
        }

        topPatent.addChildrenMap('child', child);

    };

    const Percent$3 = Phaser.Math.Percent;

    var PositionToPercent = function (startPoint, endPoint, currentPoint) {
        var value;
        if (startPoint.y === endPoint.y) {
            value = Percent$3(currentPoint.x, startPoint.x, endPoint.x);
        } else if (startPoint.x === endPoint.x) {
            value = Percent$3(currentPoint.y, startPoint.y, endPoint.y);
        }
        return value
    };

    var GetValueByPosition = function (x, y) {
        tmpPoint$3.x = x;
        tmpPoint$3.y = y;
        var startPoint, endPoint;
        if (!this.reverseAxis) {
            startPoint = this.getStartPoint();
            endPoint = this.getEndPoint();
        } else {
            startPoint = this.getEndPoint();
            endPoint = this.getStartPoint();
        }
        var value = PositionToPercent(startPoint, endPoint, tmpPoint$3);
        return value;
    };
    var tmpPoint$3 = {};

    var OnDragThumb = function (pointer, dragX, dragY) {
        if (!this.enable || !this.inputActive) {
            return;
        }
        this.value = GetValueByPosition.call(this, dragX, dragY);
    };

    var OnTouchTrack = function (pointer) {
        if (!this.enable || !this.inputActive) {
            return;
        }
        if (!pointer.isDown) {
            return;
        }

        var value = GetValueByPosition.call(this, pointer.worldX, pointer.worldY);

        this.stopEaseValue();
        if ((this.easeValueDuration === 0) || (Math.abs(this.value - value) < 0.1)) {
            this.value = value;
        } else {
            this.easeValueTo(value);
        }
    };

    const GetValue$1M = Phaser.Utils.Objects.GetValue;

    var RegisterInputEvents = function (config) {
        this.inputActive = false;

        var inputMode = GetValue$1M(config, 'input', 0);
        if (typeof (inputMode) === 'string') {
            inputMode = INPUTMODE[inputMode];
        }

        var thumb = this.childrenMap.thumb;

        switch (inputMode) {
            case 0: // 'drag'
                if (thumb) {
                    thumb.setInteractive();
                    this.scene.input.setDraggable(thumb);
                    thumb
                        .on('dragstart', function (pointer) {
                            this.inputActive = true;
                            this.eventEmitter.emit('inputstart', pointer);
                        }, this)
                        .on('dragend', function (pointer) {
                            this.inputActive = false;
                            this.eventEmitter.emit('inputend', pointer);
                        }, this)
                        .on('drag', OnDragThumb, this);
                }
                break;
            case 1: // 'click'
                this
                    .setInteractive()
                    .on('pointerdown', function (pointer) {
                        this.inputActive = true;
                        this.eventEmitter.emit('inputstart', pointer);
                    }, this)
                    .on('pointerdown', OnTouchTrack, this);

                var OnReleaseTrack = function (pointer) {
                    if (!this.inputActive) {
                        return;
                    }
                    this.inputActive = false;
                    this.eventEmitter.emit('inputend', pointer);
                };

                this.scene.input
                    // pointerup event
                    .on('pointerup', OnReleaseTrack, this)
                    // pointermove event
                    .on('pointermove', OnTouchTrack, this);

                this
                    .once('destroy', function () {
                        this.scene.input
                            .on('pointerup', OnReleaseTrack, this)
                            .off('pointermove', OnTouchTrack, this);

                    }, this);

                break;
        }
    };

    const INPUTMODE = {
        pan: 0,
        drag: 0,
        click: 1,
        none: -1,
    };

    var GetThumbAlignPoint = function (align, out) {
        if (out === undefined) {
            out = tmpPoint$2;
        }
        var thumb = this.childrenMap.thumb;
        var currentX = thumb.x;
        var currentY = thumb.y;

        AlignIn(thumb, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, align);
        out.x = thumb.x;
        out.y = thumb.y;

        thumb.x = currentX;
        thumb.y = currentY;

        return out;
    };

    var tmpPoint$2 = {};

    const AlignLeft$1 = Phaser.Display.Align.LEFT_CENTER;
    const AlignTop$1 = Phaser.Display.Align.TOP_CENTER;

    var GetStartPoint = function (out) {
        if (out === undefined) {
            out = tmpPoint$1;
        }
        if (this.childrenMap.thumb) {
            var align = (this.orientation === 0) ? AlignLeft$1 : AlignTop$1;
            GetThumbAlignPoint.call(this, align, out);
        } else {
            if (this.orientation === 0) {
                out.x = this.innerLeft + 1; // Add 1 pixel margin
                out.y = this.centerY;
            } else {
                out.x = this.centerX;
                out.y = this.innerTop + 1; // Add 1 pixel margin
            }
        }
        return out;
    };

    var tmpPoint$1 = {};

    const AlignRight$1 = Phaser.Display.Align.RIGHT_CENTER;
    const AlignBottom$1 = Phaser.Display.Align.BOTTOM_CENTER;

    var GetEndoint = function (out) {
        if (out === undefined) {
            out = tmpPoint;
        }
        if (this.childrenMap.thumb) {
            var align = (this.orientation === 0) ? AlignRight$1 : AlignBottom$1;
            GetThumbAlignPoint.call(this, align, out);
        } else {
            if (this.orientation === 0) {
                out.x = this.innerRight - 1; // Add 1 pixel margin
                out.y = this.centerY;
            } else {
                out.x = this.centerX;
                out.y = this.innerBottom - 1; // Add 1 pixel margin
            }
        }
        return out;
    };

    var tmpPoint = {};

    const Linear$3 = Phaser.Math.Linear;

    var PercentToPosition = function (t, startPoint, endPoint, out) {
        if (out === undefined) {
            out = tmpOut;
        }
        out.x = Linear$3(startPoint.x, endPoint.x, t);
        out.y = Linear$3(startPoint.y, endPoint.y, t);
        return out;
    };
    var tmpOut = {};

    var UpdateThumb = function (t) {
        var thumb = this.childrenMap.thumb;
        if (thumb === undefined) {
            return this;
        }

        if (t === undefined) {
            t = this.value;
        }

        var startPoint, endPoint;
        if (!this.reverseAxis) {
            startPoint = this.getStartPoint();
            endPoint = this.getEndPoint();
        } else {
            startPoint = this.getEndPoint();
            endPoint = this.getStartPoint();
        }
        PercentToPosition(t, startPoint, endPoint, thumb);
        thumb.x += this.thumbOffsetX;
        thumb.y += this.thumbOffsetY;
        this.resetChildPositionState(thumb);
        return this;
    };

    const AlignLeft = Phaser.Display.Align.LEFT_CENTER;
    const AlignTop = Phaser.Display.Align.TOP_CENTER;
    const AlignRight = Phaser.Display.Align.RIGHT_CENTER;
    const AlignBottom = Phaser.Display.Align.BOTTOM_CENTER;

    var UpdateIndicator = function (t) {
        var indicator = this.childrenMap.indicator;
        if (indicator === undefined) {
            return this;
        }

        if (t === undefined) {
            t = this.value;
        }

        var reverseAxis = this.reverseAxis;
        var newWidth, newHeight;
        var thumb = this.childrenMap.thumb;
        if (thumb) {
            if (this.orientation === 0) { // x, extend width
                var thumbWidth = GetDisplayWidth(thumb);

                if (!reverseAxis) {
                    var thumbLeft = thumb.x - (thumbWidth * thumb.originX);
                    var thumbRight = thumbLeft + thumbWidth;
                    newWidth = thumbRight - this.left;
                } else {
                    var thumbLeft = thumb.x - (thumbWidth * thumb.originX);
                    newWidth = this.right - thumbLeft;
                }
            } else { // y, extend height
                var thumbHeight = GetDisplayHeight(thumb);

                if (!reverseAxis) {
                    var thumbTop = thumb.y - (thumbHeight * thumb.originY);
                    var thumbBottom = thumbTop + thumbHeight;
                    newHeight = thumbBottom - this.top;
                } else {
                    var thumbTop = thumb.y - (thumbHeight * thumb.originY);
                    newHeight = this.bottom - thumbTop;
                }
            }
        } else {
            if (this.orientation === 0) { // x, extend width
                newWidth = this.width * t;
            } else { // y, extend eight
                newHeight = this.height * t;
            }
        }
        ResizeGameObject(indicator, newWidth, newHeight);

        var align;
        if (!reverseAxis) {
            align = (this.orientation === 0) ? AlignLeft : AlignTop;
        } else {
            align = (this.orientation === 0) ? AlignRight : AlignBottom;
        }
        QuickSet(indicator, this, align);

        this.resetChildPositionState(indicator);
    };

    const GetValue$1L = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$d = Phaser.Utils.Objects.IsPlainObject;
    const Clamp$7 = Phaser.Math.Clamp;
    const SnapTo$2 = Phaser.Math.Snap.To;

    class Slider extends ProgressBase(Sizer) {
        constructor(scene, config) {
            // Create sizer
            super(scene, config);
            this.type = 'rexSlider';

            this.bootProgressBase(config);

            this.reverseAxis = GetValue$1L(config, 'reverseAxis', false);

            // Add elements
            var background = GetValue$1L(config, 'background', undefined);
            var track = GetValue$1L(config, 'track', undefined);
            var indicator = GetValue$1L(config, 'indicator', undefined);
            var thumb = GetValue$1L(config, 'thumb', undefined);

            if (background) {
                if (IsPlainObject$d(background)) {
                    background = CreateBackground$2(scene, background);
                }
                this.addBackground(background);
            }

            if (track) {
                if (IsPlainObject$d(track)) {
                    track = CreateBackground$2(scene, track);
                }
                this.add(track,
                    {
                        proportion: 1,
                        expand: true,
                        minWidth: ((this.orientation === 0) ? 0 : undefined),
                        minHeight: ((this.orientation === 1) ? 0 : undefined)
                    }
                );
            }

            if (indicator) {
                if (IsPlainObject$d(indicator)) {
                    indicator = CreateBackground$2(scene, indicator);
                }
                this.pin(indicator); // Put into container but not layout it
            }

            if (thumb) {
                if (IsPlainObject$d(thumb)) {
                    thumb = CreateBackground$2(scene, thumb);
                }
                this.pin(thumb); // Put into container but not layout it

                var thumbOffsetX = GetValue$1L(config, 'thumbOffsetX', 0);
                var thumbOffsetY = GetValue$1L(config, 'thumbOffsetY', 0);
                this.setThumbOffset(thumbOffsetX, thumbOffsetY);
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('track', track);
            this.addChildrenMap('indicator', indicator);
            this.addChildrenMap('thumb', thumb);

            this.setEnable(GetValue$1L(config, 'enable', undefined));

            var gap = GetValue$1L(config, 'tick', undefined);
            if (gap === undefined) {
                gap = GetValue$1L(config, 'gap', undefined);
            }
            this.setGap(gap);

            // Input
            RegisterInputEvents.call(this, config);

            this.setValue(GetValue$1L(config, 'value', 0), GetValue$1L(config, 'min', undefined), GetValue$1L(config, 'max', undefined));

        }

        setEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.enable = enable;
            return this;
        }

        setGap(gap, min, max) {
            if (gap && (min !== undefined)) {
                gap = gap / (max - min);
            }

            this.gap = gap;
            return this;
        }

        setTick(tick, min, max) {
            this.setGap(tick, min, max);
            return this;
        }

        get tick() {
            return this.gap;
        }

        set tick(value) {
            this.gap = value;
        }

        setThumbOffset(x, y) {
            this.thumbOffsetX = x;
            this.thumbOffsetY = y;
            return this;
        }

        // Override
        get value() {
            return this._value;
        }

        // Override
        set value(value) {
            if (this.gap !== undefined) {
                value = SnapTo$2(value, this.gap);
            }
            var oldValue = this._value;
            this._value = Clamp$7(value, 0, 1);

            if (oldValue !== this._value) {
                this.updateThumb(this._value);
                this.updateIndicator(this._value);
                this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
            }
        }

        postLayout(parent, newWidth, newHeight) {
            this.updateThumb();
            this.updateIndicator();
            super.postLayout(parent, newWidth, newHeight);
            return this;
        }
    }

    var methods$i = {
        getStartPoint: GetStartPoint,
        getEndPoint: GetEndoint,
        updateThumb: UpdateThumb,
        updateIndicator: UpdateIndicator,
    };

    Object.assign(
        Slider.prototype,
        methods$i,
    );

    const GetValue$1K = Phaser.Utils.Objects.GetValue;

    class ScrollBar extends Sizer {
        constructor(scene, config) {
            // Create sizer
            super(scene, config);
            this.type = 'rexScrollBar';

            // Add elements
            var background = GetValue$1K(config, 'background', undefined);

            var buttonsConfig = GetValue$1K(config, 'buttons', undefined);
            var button0 = GetValue$1K(buttonsConfig, 'top', GetValue$1K(buttonsConfig, 'left', undefined));
            var button1 = GetValue$1K(buttonsConfig, 'bottom', GetValue$1K(buttonsConfig, 'right', undefined));

            var slider,
                sliderConfig = GetValue$1K(config, 'slider', undefined);

            if (background) {
                this.addBackground(background);
            }

            if (button0) {
                this.add(button0);

                var inTouching = new InTouching(button0);
                inTouching
                    .on('intouch', function () {
                        if (!this.enable) {
                            return;
                        }
                        var step = (!slider.reverseAxis) ? -this.scrollStep : this.scrollStep;
                        this.value += step;
                    }, this);
            }

            if (sliderConfig) {
                sliderConfig.orientation = this.orientation;
                sliderConfig.eventEmitter = this;
                sliderConfig.value = null;

                var proportion;
                if (this.orientation === 0) {
                    var sliderWidth = GetValue$1K(sliderConfig, 'width', undefined);
                    proportion = (sliderWidth === undefined) ? 1 : 0;
                } else {
                    var sliderHeight = GetValue$1K(sliderConfig, 'height', undefined);
                    proportion = (sliderHeight === undefined) ? 1 : 0;
                }

                slider = new Slider(scene, sliderConfig);
                scene.add.existing(slider);
                this.add(
                    slider,
                    {
                        proportion: proportion,
                    }
                );
            }

            if (button1) {
                this.add(button1);

                var inTouching = new InTouching(button1);
                inTouching
                    .on('intouch', function () {
                        if (!this.enable) {
                            return;
                        }
                        var step = (!slider.reverseAxis) ? this.scrollStep : -this.scrollStep;
                        this.value += step;
                    }, this);
            }

            var buttons = [button0, button1];

            this.addChildrenMap('background', background);
            this.addChildrenMap('slider', slider);
            this.addChildrenMap('buttons', buttons);

            var callback = GetValue$1K(config, 'valuechangeCallback', null);
            if (callback !== null) {
                var scope = GetValue$1K(config, 'valuechangeCallbackScope', undefined);
                this.on('valuechange', callback, scope);
            }
            this.setEnable(GetValue$1K(config, 'enable', undefined));
            this.setValue(GetValue$1K(config, 'value', 0));
            this.setScrollStep(GetValue$1K(buttonsConfig, 'step', 0.01));
        }

        setScrollStep(value) {
            this.scrollStep = value;
            return this;
        }

        get enable() {
            if (this.childrenMap.slider) {
                return this.childrenMap.slider.enable;
            } else {
                return false;
            }
        }

        set enable(value) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setEnable(value);
            }
        }

        setEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.enable = enable;
            return this;
        }

        get value() {
            if (this.childrenMap.slider) {
                return this.childrenMap.slider.value;
            } else {
                return 0;
            }
        }

        set value(value) {
            if (!this.childrenMap.slider) {
                return;
            }
            this.childrenMap.slider.value = value;
        }

        setValue(value, min, max) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setValue(value, min, max);
            }
            return this;
        }

        addValue(inc, min, max) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.addValue(inc, min, max);
            }
            return this;
        }

        getValue(min, max) {
            if (this.childrenMap.slider) {
                return this.childrenMap.slider.getValue(min, max);
            } else {
                return 0;
            }
        }

        easeValueTo(value, min, max) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.easeValueTo(value, min, max);
            }
            return this;
        }

        stopEaseValue() {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.stopEaseValue();
            }
            return this;
        }

        setEaseValueDuration(duration) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setEaseValueDuration(duration);
            }
            return this;
        }

        setEaseValueFunction(ease) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setEaseValueFunction(ease);
            }
            return this;
        }

        setGap(gap, min, max) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setGap(gap, min, max);
            }
            return this;
        }

        get gap() {
            if (this.childrenMap.slider) {
                return this.childrenMap.slider.gap;
            }
            return undefined;
        }

        set gap(value) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.gap = value;
            }
        }

        setTick(tick, min, max) {
            this.setGap(tick, min, max);
            return this;
        }

        get tick() {
            if (this.childrenMap.slider) {
                return this.childrenMap.slider.tick;
            }
            return undefined;
        }

        set tick(value) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.tick = value;
            }
        }

    }

    var CreateScrollbar = function (scene, config) {
        if (config === undefined) {
            config = {};
        }

        var sliderConfig = Clone$2(config);
        config = {
            slider: sliderConfig
        };

        // Move orientation parameter from sliderConfig to config
        config.orientation = sliderConfig.orientation;
        delete sliderConfig.orientation;

        // Move background parameter from sliderConfig to config
        config.background = sliderConfig.background;
        delete sliderConfig.background;

        // Move buttons parameter from sliderConfig to config
        config.buttons = sliderConfig.buttons;
        delete sliderConfig.buttons;

        config.value = null;  // Don't assign initial value (0)

        var scrollBar = new ScrollBar(scene, config);
        scene.add.existing(scrollBar);

        var slider = scrollBar.childrenMap.slider;
        scrollBar.addChildrenMap('track', slider.childrenMap.track);
        scrollBar.addChildrenMap('indicator', slider.childrenMap.indicator);
        scrollBar.addChildrenMap('thumb', slider.childrenMap.thumb);

        return scrollBar;
    };

    const SnapTo$1 = Phaser.Math.Snap.To;
    Phaser.Math.Clamp;

    // this: Scroller

    // enter_DRAG
    var OnDragStart = function () {
        this.emit('dragstart');
    };

    // exit_DRAG
    var OnDragEnd = function () {
        this.emit('dragend');
    };

    // everyTick_DRAG
    var Dragging = function () {
        this.value += this.dragDelta;
    };

    // enter_SLIDE 
    var OnSliding = function () {
        var start = this.value;
        var speed = this.dragSpeed;
        var snapStep = this.snapStep;
        var snapMode = !!snapStep;

        if (!snapMode) {
            if (speed === 0) {
                this._slowDown.stop();
                this._state.next();

            } else {
                var dec = this.slidingDeceleration;
                this._slowDown.init(start, (speed > 0), speed, dec);

            }

        } else { // snapMode
            var end = start;
            // Distance of deceleration
            var dist = (speed === 0) ? 0 : (speed * speed) / (2 * this.slidingDeceleration);
            end += (speed > 0) ? dist : -dist;
            end = SnapTo$1(end, snapStep, this.minValue);
            // Distance of snapping
            dist = Math.abs(end - start);

            if (dist > 0) {
                var dec;
                if (speed === 0) {
                    dec = this.backDeceleration;
                    speed = Math.sqrt(2 * dec * dist);
                } else {
                    dec = (speed * speed) / (2 * dist);
                    dec *= 0.99; // Smaller deceleration value
                }

                this._slowDown.init(start, undefined, speed, dec, end);

            } else {
                this._slowDown.stop();
                this._state.next();

            }
        }
    };

    // everyTick_SLIDE
    var Sliding = function (time, delta) {
        delta *= 0.001;
        var newValue = this._slowDown.update(delta).value;
        if (this.overMax(newValue)) {
            this.value = this.maxValue;
            this._slowDown.stop();
        } else if (this.overMin(newValue)) {
            this.value = this.minValue;
            this._slowDown.stop();
        } else {
            this.value = newValue;
        }
    };

    // enter_BACK
    var OnBack = function () {
        var start = this.value;
        var end = (this.outOfMinBound) ? this.minValue : this.maxValue;
        var dist = Math.abs(end - start);
        var dec = this.backDeceleration;
        var speed = Math.sqrt(2 * dec * dist);
        this._slowDown.init(start, undefined, speed, dec, end);
    };

    // everyTick_BACK
    var Back = function (time, delta) {
        delta *= 0.001;
        this.value = this._slowDown.update(delta).value;

        if (!this._slowDown.isMoving) {
            this._state.next();
        }
    };

    // exit_SLIDE, exit_BACK
    var Stop = function () {
        this._slowDown.stop();
    };

    class State extends FSM {
        constructor(parent, config) {
            super(config);
            this.parent = parent;
            this.init();
        }

        init() {
            this.start('IDLE');
        }

        // IDLE -> DRAGBEGIN|DRAG
        next_IDLE() {
            var nextState,
                parent = this.parent,
                dragState = parent.dragState;
            if (dragState.isDown) {
                nextState = (parent.dragThreshold === 0) ? 'DRAG' : 'DRAGBEGIN';
            }
            return nextState;
        }
        update_IDLE(time, delta) {
            this.next();
        }
        // IDLE

        // DRAGBEGIN -> DRAG|IDLE
        next_DRAGBEGIN() {
            var nextState,
                parent = this.parent,
                dragState = parent.dragState;
            if (dragState.isDown) {
                nextState = (dragState.pointer.getDistance() >= parent.dragThreshold) ? 'DRAG' : 'DRAGBEGIN';
            } else { // dragState.isUp
                nextState = 'IDLE';
            }
            return nextState;
        }
        update_DRAGBEGIN(time, delta) {
            this.next();
        }
        // DRAGBEGIN

        // DRAG -> BACK|SLIDE|IDLE
        next_DRAG() {
            var nextState,
                parent = this.parent,
                dragState = parent.dragState;
            if (dragState.isUp) {
                if (parent.outOfBounds) {
                    nextState = 'BACK';
                } else if (parent.slidingEnable) {
                    nextState = 'SLIDE';
                } else {
                    nextState = 'IDLE';
                }
            }
            return nextState;
        }
        update_DRAG(time, delta) {
            var parent = this.parent,
                dragState = parent.dragState;
            if (dragState.justMoved) {
                Dragging.call(parent);
            }
            this.next();
        }
        enter_DRAG() {
            OnDragStart.call(this.parent);
        }
        exit_DRAG() {
            OnDragEnd.call(this.parent);
        }
        // DRAG    

        // SLIDE -> DRAG|IDLE
        next_SLIDE() {
            var nextState,
                parent = this.parent,
                dragState = parent.dragState;
            if (dragState.isDown) {
                nextState = 'DRAG';
            } else if (!parent.isSliding) {
                nextState = 'IDLE';
            }
            return nextState;
        }
        enter_SLIDE() {
            OnSliding.call(this.parent);
        }
        exit_SLIDE() {
            Stop.call(this.parent);
        }
        update_SLIDE(time, delta) {
            Sliding.call(this.parent, time, delta);
            this.next();
        }
        // SLIDE    

        // BACK -> DRAG|IDLE
        next_BACK() {
            var nextState,
                parent = this.parent,
                dragState = parent.dragState;
            if (dragState.isDown) {
                nextState = 'DRAG';
            } else if (!parent.isPullBack) {
                nextState = 'IDLE';
            }
            return nextState;
        }
        enter_BACK() {
            OnBack.call(this.parent);
        }
        exit_BACK() {
            Stop.call(this.parent);
        }
        update_BACK(time, delta) {
            Back.call(this.parent, time, delta);
            this.next();
        }
        // BACK
    }

    const GetValue$1J = Phaser.Utils.Objects.GetValue;
    const DistanceBetween$1 = Phaser.Math.Distance.Between;

    class DragSpeed extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            this._enable = undefined;

            this.rectBoundsInteractive = GetValue$1J(config, 'rectBoundsInteractive', false);

            if (!this.rectBoundsInteractive) {
                gameObject.setInteractive(GetValue$1J(config, "inputConfig", undefined));
            }

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.pointer = undefined;
            this.isInTouched = false;
            this.holdStartTime = undefined;
            this.x = undefined;
            this.y = undefined;
            this.preX = undefined;
            this.preY = undefined;
            this.localX = undefined;
            this.localY = undefined;
            this.justMoved = false;
            this.setEnable(GetValue$1J(o, 'enable', true));
            this.holdThreshold = GetValue$1J(o, 'holdThreshold', 50); // ms
            this.pointerOutReleaseEnable = GetValue$1J(o, 'pointerOutRelease', true);
            return this;
        }

        boot() {
            var scene = this.scene;
            var gameObject = this.parent;

            if (!this.rectBoundsInteractive) {
                // Drag start only when pointer down
                gameObject.on('pointerdown', this.onPointIn, this);

                gameObject.on('pointerup', this.onPointOut, this);

                if (this.pointerOutReleaseEnable) {
                    gameObject.on('pointerout', this.onPointOut, this);
                }

                gameObject.on('pointermove', this.onPointerMove, this);

            } else {
                scene.input.on('pointerdown', this.onPointIn, this);

                scene.input.on('pointerup', this.onPointOut, this);

                scene.input.on('pointermove', this.onPointerMove, this);
            }

            scene.sys.events.on('preupdate', this.preupdate, this);
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            var scene = this.scene;
            this.parent;

            if (!this.rectBoundsInteractive) ; else {
                scene.input.off('pointerdown', this.onPointIn, this);

                scene.input.off('pointerup', this.onPointOut, this);

                scene.input.off('pointermove', this.onPointerMove, this);
            }

            scene.sys.events.off('preupdate', this.preupdate, this);

            this.pointer = undefined;

            super.shutdown(fromScene);
        }

        get enable() {
            return this._enable;
        }

        set enable(e) {
            if (this._enable === e) {
                return;
            }

            if (!e) {
                this.isInTouched = false;
                this.pointer = undefined;
            }
            this._enable = e;
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        setPointerOutReleaseEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.pointerOutReleaseEnable = enable;
            return this;
        }

        get isDown() {
            return this.pointer && this.pointer.isDown;
        }

        get isUp() {
            return !this.isDown;
        }

        get dx() {
            return this.x - this.preX;
        }

        get dy() {
            return this.y - this.preY;
        }

        get dt() {
            var delta = GetTickDelta(this.scene);
            return delta;
        }

        get speed() {
            if ((this.x === this.preX) && (this.y === this.preY)) {
                return 0;
            }
            var d = DistanceBetween$1(this.preX, this.preY, this.x, this.y);
            var speed = d / (this.dt * 0.001);
            return speed;
        }

        get speedX() {
            return this.dx / (this.dt * 0.001);
        }

        get speedY() {
            return this.dy / (this.dt * 0.001);
        }

        // internal
        onPointIn(pointer, localX, localY) {
            if ((!this.enable) ||
                (!pointer.isDown) ||
                (this.pointer !== undefined)) {
                return;
            }

            if (
                this.rectBoundsInteractive &&
                !IsPointerInBounds(this.parent, pointer)
            ) {
                return;
            }

            this.pointer = pointer;
            this.localX = localX;
            this.localY = localY;
        }

        onPointOut(pointer) {
            if ((!this.enable) ||
                (this.pointer !== pointer)) {
                return;
            }
            this.pointer = undefined;
        }

        onPointerMove(pointer, localX, localY) {
            if ((!this.enable) ||
                (!pointer.isDown) ||
                (this.pointer !== pointer)) {
                return;
            }

            if (
                this.rectBoundsInteractive &&
                this.pointerOutReleaseEnable &&
                !IsPointerInBounds(this.parent, pointer)
            ) {
                this.onPointOut(pointer);
                return;
            }

            this.localX = localX;
            this.localY = localY;
        }

        preupdate(time, delta) {
            if (!this.enable) {
                return;
            }

            var pointer = this.pointer;
            this.justMoved = false;
            if (pointer && (!this.isInTouched)) {
                // Touch start
                this.x = pointer.worldX;
                this.y = pointer.worldY;
                this.preX = pointer.worldX;
                this.preY = pointer.worldY;
                this.isInTouched = true;
                this.holdStartTime = undefined;
                this.emit('touchstart', pointer, this.localX, this.localY);

            } else if (pointer && this.isInTouched) {
                // In touch
                if ((this.x === pointer.x) && (this.y === pointer.y)) {
                    // Hold
                    if (this.holdStartTime === undefined) {
                        this.holdStartTime = time;
                    } else if (time - this.holdStartTime > this.holdThreshold) {
                        this.preX = this.x;
                        this.preY = this.y;
                    }
                } else {
                    // Move
                    this.preX = this.x;
                    this.preY = this.y;
                    this.x = pointer.worldX;
                    this.y = pointer.worldY;
                    this.holdStartTime = undefined;
                    this.justMoved = true;
                    this.emit('touchmove', pointer, this.localX, this.localY);
                }

            } else if ((!pointer) && this.isInTouched) {
                // Touch end
                this.isInTouched = false;
                this.holdStartTime = undefined;
                this.emit('touchend', pointer);

            }
        }
    }

    const GetValue$1I = Phaser.Utils.Objects.GetValue;

    class Movement {
        constructor(config) {
            this.resetFromJSON(config);
        }

        resetFromJSON(o) {
            this.setValue(GetValue$1I(o, 'value', 0));
            this.setSpeed(GetValue$1I(o, 'speed', 0));
            this.setAcceleration(GetValue$1I(o, 'acceleration', 0));
            return this;
        }

        reset() {
            this.setValue(0);
            this.setSpeed(0);
            this.setAcceleration(0);
        }

        setValue(value) {
            this.value = value;
            return this;
        }

        setSpeed(speed) {
            // speed == 0 : stop
            // speed  > 0 : move
            this.speed = speed;
            return this;        
        }

        setAcceleration(acc) {
            // acc == 0 : constant speed
            // acc  > 0 : acceleration
            // acc  < 0 : deceleration
            this.acceleration = acc;
            return this;
        }

        updateSpeed(delta) {
            // delta in sec
            if (this.acceleration !== 0) {
                this.speed += (this.acceleration * delta);
                if (this.speed < 0) {
                    this.speed = 0;
                }
            }
            return this;
        }

        getDeltaValue(delta) {
            // delta in sec
            this.updateSpeed(delta);
            if (this.speed <= 0) {
                return 0;
            }
            return (this.speed * delta);
        }

        update(delta) {
            // delta in sec
            this.updateSpeed(delta);
            if (this.speed > 0) {
                this.value += this.getDeltaValue(delta);
            }
            return this;
        }

        get isMoving() {
            return (this.speed > 0);
        }
    }

    class SlowDown {
        constructor() {
            this.value;
            this.dir; // true:+, false:-
            this.movement = new Movement();
        }

        init(start, dir, speed, dec, end) {
            this.value = start;
            this.end = end;
            if (end !== undefined) {
                this.dir = (start < end);
            } else {
                this.dir = dir;
            }

            speed = Math.abs(speed);

            this.movement
                .setSpeed(speed)
                .setAcceleration(-dec);
            return this;
        }

        stop() {
            this.movement.reset();
        }

        update(delta) {
            // delta in sec
            var d = this.movement.getDeltaValue(delta);
            if (!this.dir) {
                d = -d;
            }

            if (this.end === undefined) {
                this.value += d;
            } else {
                if (d === 0) {
                    this.value = this.end;
                } else {
                    this.value += d;
                    if (this.dir) { // +
                        if (this.value > this.end) {
                            this.value = this.end;
                        }
                    } else { // -
                        if (this.value < this.end) {
                            this.value = this.end;
                        }
                    }
                }
            }
            return this;
        }

        get isMoving() {
            return this.movement.isMoving;
        }
    }

    const GetValue$1H = Phaser.Utils.Objects.GetValue;
    const Clamp$6 = Phaser.Math.Clamp;

    class Scroller extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            var enable = GetValue$1H(config, 'enable', true);
            this._state = new State(this, {
                enable: enable,
                eventEmitter: false,
            });

            var drapSpeedConfig = {
                rectBoundsInteractive: GetValue$1H(config, 'rectBoundsInteractive', false),
                inputConfig: GetValue$1H(config, 'inputConfig', undefined),
                enable: enable,
                pointerOutRelease: GetValue$1H(config, 'pointerOutRelease', true),
                eventEmitter: false,
            };
            this.dragState = new DragSpeed(gameObject, drapSpeedConfig);

            this._enable = undefined;
            this._value = undefined;
            this._slowDown = new SlowDown();

            this.setSnapStep(GetValue$1H(config, 'snapStep', undefined));

            var callback = GetValue$1H(config, 'valuechangeCallback', null);
            if (callback !== null) {
                var scope = GetValue$1H(config, 'valuechangeCallbackScope', undefined);
                this.on('valuechange', callback, scope);
            }
            callback = GetValue$1H(config, 'overmaxCallback', null);
            if (callback !== null) {
                var scope = GetValue$1H(config, 'overmaxCallbackScope', undefined);
                this.on('overmax', callback, scope);
            }
            callback = GetValue$1H(config, 'overminCallback', null);
            if (callback !== null) {
                var scope = GetValue$1H(config, 'overminCallbackScope', undefined);
                this.on('overmin', callback, scope);
            }

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.setOrientationMode(GetValue$1H(o, 'orientation', 0));
            this.setDragThreshold(GetValue$1H(o, 'threshold', 10));
            this.setSlidingDeceleration(GetValue$1H(o, 'slidingDeceleration', 5000));
            this.setBackDeceleration(GetValue$1H(o, 'backDeceleration', 2000));

            var dragRate = GetValue$1H(o, 'dragRate', 1);
            dragRate = dragRate * (GetValue$1H(o, 'dragReverse', false) ? -1 : 1);
            this.setDragRate(dragRate);

            var bounds = GetValue$1H(o, 'bounds', undefined);
            if (bounds) {
                this.setBounds(bounds);
            } else {
                this.setBounds(GetValue$1H(o, 'max', 0), GetValue$1H(o, 'min', 0));
            }
            this.setValue(GetValue$1H(o, 'value', this.maxValue || 0));
            this.setEnable(GetValue$1H(o, "enable", true));
            return this;
        }

        boot() {
            this.scene.sys.events.on('preupdate', this._state.update, this._state);
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            this.scene.sys.events.off('preupdate', this._state.update, this._state);
            this._state.destroy(fromScene);
            this.dragState.destroy(fromScene);
            this._state = undefined;
            this.dragState = undefined;

            super.shutdown(fromScene);
        }

        get enable() {
            return this._enable;
        }

        set enable(e) {
            if (this._enable === e) {
                return;
            }

            this._enable = e;
            this._state.setEnable(e);
            this.dragState.setEnable(e);

            return this;
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        setOrientationMode(m) {
            if (typeof (m) === 'string') {
                m = ORIENTATIONMODE$2[m];
            }
            this.orientationMode = m;
            return this;
        }

        setDragThreshold(distance) {
            this.dragThreshold = distance;
            return this;
        }

        setSlidingDeceleration(dec) {
            this.slidingDeceleration = dec;
            return this;
        }

        setBackDeceleration(dec) {
            this.backDeceleration = dec;
            return this;
        }

        setDragRate(ratio) {
            this.dragRate = ratio;
            return this;
        }

        setBounds(value0, value1) {
            if (Array.isArray(value0)) {
                var bounds = value0;
                value0 = bounds[0];
                value1 = bounds[1];
            }
            if (value0 < value1) {
                this.minValue = value0;
                this.maxValue = value1;
            } else {
                this.minValue = value1;
                this.maxValue = value0;
            }
            return this;
        }

        setSnapStep(snapStep) {
            this.snapStep = snapStep;
            return this;
        }

        get value() {
            return this._value;
        }

        set value(value) {
            if (value === this._value) {
                return;
            }

            var oldValue = this._value;
            var isOverMax = this.overMax(value);
            var isOverMin = this.overMin(value);
            if (isOverMax) {
                this.emit('overmax', value, oldValue);
            }
            if (isOverMin) {
                this.emit('overmin', value, oldValue);
            }
            if (!this.backEnable) {
                if (isOverMax) {
                    value = this.maxValue;
                }
                if (isOverMin) {
                    value = this.minValue;
                }
            }

            this._value = value;
            this.emit('valuechange', value, oldValue);
        }

        setValue(value, clamp) {
            if (clamp === undefined) {
                clamp = false;
            }

            if (clamp) {
                value = Clamp$6(value, this.minValue, this.maxValue);
            }

            this.value = value;
            return this;
        }

        addValue(inc, clamp) {
            this.setValue(this.value + inc, clamp);
            return this;
        }

        get state() {
            return this._state.state;
        }

        get isDragging() {
            return this.dragState.isInTouched;
        }

        get outOfMaxBound() {
            return this.overMax(this.value);
        }

        get outOfMinBound() {
            return this.overMin(this.value);
        }

        get outOfBounds() {
            return this.outOfMinBound || this.outOfMaxBound;
        }

        // internal
        overMax(value) {
            return (this.maxValue != null) && (value > this.maxValue);
        }

        overMin(value) {
            return (this.minValue != null) && (value < this.minValue);
        }

        get backEnable() {
            return (typeof (this.backDeceleration) === 'number');
        }

        get isPullBack() {
            return this._slowDown.isMoving;
        }

        get slidingEnable() {
            return (typeof (this.slidingDeceleration) === 'number');
        }

        get isSliding() {
            return this._slowDown.isMoving;
        }

        get dragDelta() {
            var delta;
            if (this.orientationMode === 0) { // y
                delta = this.dragState.dy;
            } else if (this.orientationMode === 1) { // x
                delta = this.dragState.dx;
            } else {
                delta = 0;
            }
            delta *= this.dragRate;
            return delta;
        }

        get dragSpeed() {
            var speed;
            if (this.orientationMode === 0) { // y
                speed = this.dragState.speedY;
            } else if (this.orientationMode === 1) { // x
                speed = this.dragState.speedX;
            } else {
                speed = 0;
            }
            speed *= this.dragRate;
            return speed;
        }
    }

    const ORIENTATIONMODE$2 = {
        y: 0,
        v: 0,
        vertical: 0,
        x: 1,
        h: 1,
        horizontal: 1,
    };

    const GetValue$1G = Phaser.Utils.Objects.GetValue;

    class MouseWheelScroller extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            if (this.parent !== this.scene) {
                this.focusMode = GetValue$1G(config, 'focus', true);
            } else {
                this.focusMode = false;
            }

            if (typeof (this.focusMode) === 'boolean') {
                this.focusMode = (this.focusMode) ? 1 : 0;
            }

            this.setSpeed(GetValue$1G(config, 'speed', 0.1));
            this.setEnable(GetValue$1G(config, 'enable', true));

            switch (this.focusMode) {
                case 0:
                case 2:
                    this.scene.input.on('wheel', this.onSceneScroll, this);
                    break;

                default:  // case 1
                    gameObject
                        .setInteractive(GetValue$1G(config, "inputConfig", undefined))
                        .on('wheel', function (pointer, dx, dy, dz, event) {
                            this.tryScroll(dy);
                        }, this);
                    break;
            }
        }

        destroy() {
            switch (this.focusMode) {
                case 0:
                case 2:
                    this.scene.input.off('wheel', this.onSceneScroll, this);
                    break;
            }
        }

        onSceneScroll(pointer, currentlyOver, dx, dy, dz, event) {
            if (this.focusMode === 2) {
                if (!IsPointerInBounds(this.parent, pointer)) {
                    return;
                }
            }

            this.tryScroll(dy);
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        setSpeed(speed) {
            this.speed = speed;
            return this;
        }

        tryScroll(dy) {
            if (!this.enable) {
                return;
            }
            this.scroll(dy);
            return this;
        }

        scroll(dy) {
            dy *= this.speed;
            this.emit('scroll', dy, this.parent, this);
            return this;
        }
    }

    const GetValue$1F = Phaser.Utils.Objects.GetValue;
    const SnapTo = Phaser.Math.Snap.To;

    var AddSlider = function (topPatent, sliderParent, axis, config) {
        axis = axis.toUpperCase();
        var isAxisY = (axis === 'Y');
        var isScrollXYMode = (topPatent.scrollMode === 2);
        var child = topPatent.childrenMap.child;

        var snapStep;
        var snapStepKey = `snapStep${axis}`;
        if (isScrollXYMode) {
            snapStep = GetValue$1F(config, snapStepKey, undefined);
        } else {
            var snapStep = GetValue$1F(config, 'snapStep', undefined);
            if (snapStep === undefined) {
                snapStep = GetValue$1F(config, snapStepKey, undefined);
            }
        }
        topPatent[snapStepKey] = snapStep;

        var sliderConfig, slider;
        var sliderConfigKey = `slider${axis}`;
        if (isScrollXYMode) {
            sliderConfig = GetValue$1F(config, sliderConfigKey, undefined);
        } else {
            if (config.hasOwnProperty(sliderConfigKey)) {
                sliderConfig = GetValue$1F(config, sliderConfigKey, undefined);
            } else {
                sliderConfig = GetValue$1F(config, 'slider', undefined);
            }
        }

        if (sliderConfig) {
            if (sliderConfig === true) {
                sliderConfig = {};
            }

            sliderConfig.orientation = (isAxisY) ? 1 : 0;
            slider = CreateScrollbar(topPatent.scene, sliderConfig);

            var column, row, padding;

            var sliderPosition = GetValue$1F(sliderConfig, 'position', 0);
            if (typeof (sliderPosition) === 'string') {
                sliderPosition = SLIDER_POSITION_MAP[sliderPosition];
            }

            /*
            1. space.sliderX, space.sliderY
            2. space.slider
            3. space.child
            */
            var sliderPadding = GetValue$1F(config, `space.slider${axis}`, undefined);
            var childPadding;  // Legacy
            if (sliderPadding === undefined) {
                sliderPadding = GetValue$1F(config, 'space.slider', undefined);
                if (sliderPadding === undefined) {
                    if (isScrollXYMode) {
                        sliderPadding = 0;
                    } else {
                        childPadding = GetValue$1F(config, 'space.child', 0);
                    }
                }
            }

            var isNumberSliderPadding;
            if (childPadding === undefined) {
                isNumberSliderPadding = (typeof (sliderPadding) === 'number');
            } else {
                isNumberSliderPadding = (typeof (childPadding) === 'number');
            }

            if (isAxisY) {
                if (sliderPosition === 0) { // right
                    column = 2;
                    row = 1;

                    if (childPadding === undefined) {
                        padding = (isNumberSliderPadding) ? { left: sliderPadding } : sliderPadding;
                    } else {
                        padding = { left: GetValue$1F(childPadding, 'right', childPadding) };
                    }

                } else { // left
                    column = 0;
                    row = 1;

                    if (childPadding === undefined) {
                        padding = (isNumberSliderPadding) ? { right: sliderPadding } : sliderPadding;
                    } else {
                        padding = { right: GetValue$1F(childPadding, 'left', childPadding) };
                    }
                }

            } else {
                if (sliderPosition === 0) { // bottom
                    column = 1;
                    row = 2;

                    if (childPadding === undefined) {
                        padding = (isNumberSliderPadding) ? { top: sliderPadding } : sliderPadding;
                    } else {
                        padding = { top: GetValue$1F(childPadding, 'bottom', childPadding) };
                    }

                } else { // top
                    column = 1;
                    row = 0;

                    if (childPadding === undefined) {
                        padding = (isNumberSliderPadding) ? { bottom: sliderPadding } : sliderPadding;
                    } else {
                        padding = { bottom: GetValue$1F(childPadding, 'top', childPadding) };
                    }
                }
            }

            sliderParent.add(slider,
                {
                    column: column,
                    row: row,
                    align: 'center',
                    padding: padding,
                    expand: true,
                }
            );

            topPatent[`hideUnscrollableSlider${axis}`] = GetValue$1F(sliderConfig, 'hideUnscrollableSlider', false);
            topPatent[`disableUnscrollableDrag${axis}`] = GetValue$1F(sliderConfig, 'disableUnscrollableDrag', false);
            topPatent[`adaptThumb${axis}SizeMode`] = GetValue$1F(sliderConfig, 'adaptThumbSize', false);
            topPatent[`minThumb${axis}Size`] = GetValue$1F(sliderConfig, 'minThumbSize', undefined);

        } else {
            topPatent[`hideUnscrollableSlider${axis}`] = false;
            topPatent[`disableUnscrollableDrag${axis}`] = false;
            topPatent[`adaptThumb${axis}SizeMode`] = false;
            topPatent[`minThumb${axis}Size`] = undefined;
        }

        // 0=gameObject, 1=rectBounds
        var scrollDetectionMode = GetValue$1F(config, 'scrollDetectionMode');
        if (typeof (scrollDetectionMode) === 'string') {
            scrollDetectionMode = SCROLLDECTIONMODE_MAP[scrollDetectionMode];
        }

        var scrollerConfig, scroller;
        var scrollerConfigKey = `scroller${axis}`;
        if (isScrollXYMode) {
            scrollerConfig = GetValue$1F(config, scrollerConfigKey, true);
        } else {
            if (config.hasOwnProperty(scrollerConfigKey)) {
                scrollerConfig = GetValue$1F(config, scrollerConfigKey, true);
            } else {
                scrollerConfig = GetValue$1F(config, 'scroller', true);
            }
        }

        if (scrollerConfig && child) {
            if (scrollerConfig === true) {
                scrollerConfig = {};
            }

            scrollerConfig.orientation = (isAxisY) ? 0 : 1;

            if (scrollDetectionMode !== undefined) {
                scrollerConfig.rectBoundsInteractive = (scrollDetectionMode === 1);
            }

            scrollerConfig.snapStep = snapStep;

            scroller = new Scroller(child, scrollerConfig);

            if (child.isRexContainerLite) {
                // Send touch detection sensor to back
                child.sendChildToBack(child);
            }
        }

        var mouseWheelScrollerConfig = GetValue$1F(config, ((isScrollXYMode) ? `mouseWheelScroller${axis}` : 'mouseWheelScroller'), false),
            mouseWheelScroller;
        if (mouseWheelScrollerConfig && child) {
            if (scrollDetectionMode !== undefined) {
                mouseWheelScrollerConfig.focus = (scrollDetectionMode === 1) ? 2 : 0;
            }

            mouseWheelScroller = new MouseWheelScroller(child, mouseWheelScrollerConfig);
        }

        topPatent.addChildrenMap(`slider${axis}`, slider);
        topPatent.addChildrenMap(`scroller${axis}`, scroller);
        topPatent.addChildrenMap(`mouseWheelScroller${axis}`, mouseWheelScroller);

        if ((!isScrollXYMode) || (isAxisY)) {
            topPatent['hideUnscrollableSlider'] = topPatent[`hideUnscrollableSlider${axis}`];
            topPatent['disableUnscrollableDrag'] = topPatent[`disableUnscrollableDrag${axis}`];
            topPatent['adaptThumbSizeMode'] = topPatent[`adaptThumb${axis}SizeMode`];
            topPatent['minThumbSize'] = topPatent[`minThumb${axis}Size`];

            topPatent.addChildrenMap('slider', slider);
            topPatent.addChildrenMap('scroller', scroller);
            topPatent.addChildrenMap('mouseWheelScroller', mouseWheelScroller);
        }


        // Control
        if (slider) {
            var keyST, eventName;
            if (isScrollXYMode) {
                keyST = (isAxisY) ? 't' : 's';
                eventName = `scroll${axis}`;
            } else {
                keyST = 't';
                eventName = 'scroll';
            }
            slider
                .on('valuechange', function (newValue) {
                    topPatent[keyST] = newValue;
                    topPatent.emit(eventName, topPatent);
                })
                .on('inputend', function () {
                    var snapStep = topPatent[`snapStep${axis}`];
                    if (snapStep) {
                        var min = topPatent[(isAxisY) ? `topChildOY` : `leftChildOX`];
                        var max = topPatent[(isAxisY) ? `bottomChildOY` : `rightChildOX`];
                        var valueEnd = topPatent[`childO${axis}`];
                        var valueTo = SnapTo(valueEnd, snapStep, min);
                        var easeDuration = 500 * (Math.abs(valueTo - valueEnd) / snapStep);
                        slider
                            .setEaseValueDuration(easeDuration)
                            .easeValueTo(valueTo, min, max);
                    }
                });

        }

        if (scroller) {
            var keyChildOXY, eventName;
            if (isScrollXYMode) {
                keyChildOXY = `childO${axis}`;
                eventName = `scroll${axis}`;
            } else {
                keyChildOXY = 'childOY';
                eventName = 'scroll';
            }
            scroller
                .on('valuechange', function (newValue) {
                    topPatent[keyChildOXY] = newValue;
                    topPatent.emit(eventName, topPatent);
                });
        }

        if (mouseWheelScroller) {
            var methodAddChildOXY;
            if (isScrollXYMode) {
                methodAddChildOXY = `addChildO${axis}`;
            } else {
                methodAddChildOXY = 'addChildOY';
            }
            mouseWheelScroller
                .on('scroll', function (incValue) {
                    var snapStep = topPatent[snapStepKey];
                    if (snapStep) {
                        incValue = snapStep;
                    }
                    topPatent[methodAddChildOXY](-incValue, true);
                });
        }
    };

    const SLIDER_POSITION_MAP = {
        right: 0,
        left: 1,
        bottom: 0,
        top: 1,
    };

    const SCROLLDECTIONMODE_MAP = {
        gameObject: 0,
        rectBounds: 1,
    };

    const GetValue$1E = Phaser.Utils.Objects.GetValue;

    var CreateScrollableSizer = function (parent, config) {
        var scene = parent.scene;

        var columnProportions = [0, 1, 0],
            rowProportions = [0, 1, 0];
        var parentMinWidth = GetValue$1E(config, 'width');
        var parentMinHeight = GetValue$1E(config, 'height');
        if (!parentMinWidth) {
            var expandChildWidth = GetValue$1E(config, 'child.expandWidth', true);
            if (!expandChildWidth) {
                columnProportions[1] = 0;  // Calculate parent's width by child's width
            }
        }
        if (!parentMinHeight) {
            var expandChildHeight = GetValue$1E(config, 'child.expandHeight', true);
            if (!expandChildHeight) {
                rowProportions[1] = 0;    // Calculate parent's height by child's height
            }
        }

        var scrollableSizer = new GridSizer(scene, {
            column: 3, row: 3,
            columnProportions: columnProportions,
            rowProportions: rowProportions
        });

        AddChild(parent, scrollableSizer, config);

        switch (parent.scrollMode) {
            case 0:  // y
                AddSlider(parent, scrollableSizer, 'y', config);
                break;
            case 1:  // x
                AddSlider(parent, scrollableSizer, 'x', config);
                break;

            default: // xy
                AddSlider(parent, scrollableSizer, 'y', config);
                AddSlider(parent, scrollableSizer, 'x', config);
                break;
        }

        return scrollableSizer;
    };

    const GetValue$1D = Phaser.Utils.Objects.GetValue;

    let Scrollable$1 = class Scrollable extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            var scrollMode = GetScrollMode(config); // 0:y, 1:x, 2:xy
            // Create sizer
            var isRevererXY = (scrollMode === 1);
            config.orientation = (!isRevererXY) ? 1 : 0;
            super(scene, config);
            this.type = GetValue$1D(config, 'type', 'rexScrollable');
            this.scrollMode = scrollMode;

            // Add elements
            // Background
            var background = GetValue$1D(config, 'background', undefined);
            if (background) {
                this.addBackground(background);
            }

            var header = GetValue$1D(config, 'header', undefined);
            if (header) {
                var align = GetValue$1D(config, 'align.header', 'center');
                var headerSpace = GetValue$1D(config, 'space.header', 0);
                var padding;
                if (!isRevererXY) {
                    padding = { bottom: headerSpace };
                } else {
                    padding = { right: headerSpace };
                }
                this.add(header,
                    {
                        proportion: 0,
                        align: align,
                        padding: padding,
                        expand: GetValue$1D(config, 'expand.header', true)
                    }
                );
            }

            var scrollableSizer = CreateScrollableSizer(this, config);
            if (scrollableSizer) {
                this.add(scrollableSizer,
                    {
                        proportion: 1,
                        align: 'center',
                        padding: 0,
                        expand: true
                    }
                );
            }

            var footer = GetValue$1D(config, 'footer', undefined);
            if (footer) {
                var align = GetValue$1D(config, 'align.footer', 'center');
                var footerSpace = GetValue$1D(config, 'space.footer', 0);
                var padding;
                if (!isRevererXY) {
                    padding = { top: footerSpace };
                } else {
                    padding = { left: footerSpace };
                }
                this.add(footer,
                    {
                        proportion: 0,
                        align: align,
                        padding: padding,
                        expand: GetValue$1D(config, 'expand.footer', true)
                    }
                );
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('header', header);
            this.addChildrenMap('footer', footer);

            this.runLayoutFlag = false;

            /* 
            Necessary properties of child object :

            - child.t (RW), 
            - child.childOY (RW)        
            - child.topChildOY (R)
            - child.bottomChildOY (R)
            - child.childVisibleHeight (R)
            - child.childHeight (R)

            - child.s (RW), 
            - child.childOX (RW)
            - child.leftChildOX (R)
            - child.rightChildOX (R)
            - child.childVisibleWidth (R)
            - child.childWidth (R)        
            */
        }

        postLayout(parent, newWidth, newHeight) {
            var s = 0, t = 0;
            if (!this.runLayoutFlag) {
                this.runLayoutFlag = true;
            } else {
                t = this.t;

                if (this.scrollMode === 2) {
                    s = this.s;
                }
            }

            this.resizeController();

            this.setT(t);
            if (this.scrollMode === 2) {
                this.setS(s);
            }

            super.postLayout(parent, newWidth, newHeight);

            return this;
        }

        set t(value) {
            // Get inner childT
            var childMargin = this.childMargin;
            if ((childMargin.top !== 0) || (childMargin.bottom !== 0)) {
                var child = this.childrenMap.child;
                var innerHeight = (child.topChildOY - child.bottomChildOY);
                var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
                var innerChildOY = (outerHeight * value) - childMargin.top;
                value = (innerHeight !== 0) ? (innerChildOY / innerHeight) : 0;
            }

            this.childrenMap.child.t = value;
            this.updateController();
        }

        get t() {
            var t = this.childrenMap.child.t;

            // Get outer childT
            var childMargin = this.childMargin;
            if ((childMargin.top !== 0) || (childMargin.bottom !== 0)) {
                var child = this.childrenMap.child;
                var innerHeight = (child.topChildOY - child.bottomChildOY);
                var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
                var outerChildOY = (innerHeight * t) + childMargin.top;
                t = (outerHeight !== 0) ? (outerChildOY / outerHeight) : 0;
            }
            return t;
        }

        set s(value) {
            // Get inner childS
            var childMargin = this.childMargin;
            if ((childMargin.left !== 0) || (childMargin.right !== 0)) {
                var child = this.childrenMap.child;
                var innerWidth = (child.leftChildOX - child.rightChildOX);
                var outerWidth = innerWidth + childMargin.left + childMargin.right;
                var innerChildOX = (outerWidth * value) - childMargin.left;
                value = (innerWidth !== 0) ? (innerChildOX / innerWidth) : 0;
            }

            this.childrenMap.child.s = value;
            this.updateController();
        }

        get s() {
            var s = this.childrenMap.child.s;

            // Get outer childT
            var childMargin = this.childMargin;
            if ((childMargin.left !== 0) || (childMargin.right !== 0)) {
                var child = this.childrenMap.child;
                var innerWidth = (child.leftChildOX - child.rightChildOX);
                var outerWidth = innerWidth + childMargin.left + childMargin.right;
                var outerChildOX = (innerWidth * s) + childMargin.left;
                s = (outerWidth !== 0) ? (outerChildOX / outerWidth) : 0;
            }
            return s;
        }

        set childOY(value) {
            this.childrenMap.child.childOY = value;
            this.updateController();
        }

        get childOY() {
            return this.childrenMap.child.childOY;
        }

        set childOX(value) {
            this.childrenMap.child.childOX = value;
            this.updateController();
        }

        get childOX() {
            return this.childrenMap.child.childOX;
        }

        get topChildOY() {
            return this.childrenMap.child.topChildOY + this.childMargin.top;
        }

        get bottomChildOY() {
            return this.childrenMap.child.bottomChildOY - this.childMargin.bottom;
        }

        get leftChildOX() {
            return this.childrenMap.child.leftChildOX + this.childMargin.left;
        }

        get rightChildOX() {
            return this.childrenMap.child.rightChildOX - this.childMargin.right;
        }

        get childVisibleHeight() {
            return this.childrenMap.child.childVisibleHeight;
        }

        get childHeight() {
            return this.childrenMap.child.childHeight;
        }

        get childVisibleWidth() {
            return this.childrenMap.child.childVisibleWidth;
        }

        get childWidth() {
            return this.childrenMap.child.childWidth;
        }

        get isOverflow() {
            var child = this.childrenMap.child;
            return child.topChildOY !== child.bottomChildOY;
        }

        get isOverflowY() {
            return this.isOverflow;
        }

        get isOverflowX() {
            var child = this.childrenMap.child;
            return child.leftChildOX !== child.rightChildOX;
        }

        get sliderEnable() {
            var slider = this.childrenMap.slider;
            if (!slider) {
                return false;
            }

            return slider.enable;
        }

        set sliderEnable(value) {
            var slider = this.childrenMap.slider;
            if (!slider) {
                return;
            }
            slider.setEnable(value);
        }

        setSliderEnable(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.sliderEnable = enabled;
            return this;
        }

        get sliderYEnable() {
            return this.sliderEnable
        }

        set sliderYEnable(value) {
            this.sliderEnable = value;
        }

        setSliderYEnable(enabled) {
            this.setSliderEnable(enabled);
            return this;
        }

        get sliderXEnable() {
            var slider = this.childrenMap.sliderX;
            if (!slider) {
                return false;
            }

            return slider.enable;
        }

        set sliderXEnable(value) {
            var slider = this.childrenMap.sliderX;
            if (!slider) {
                return;
            }
            slider.setEnable(value);
        }

        setSliderXEnable(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.sliderXEnable = enabled;
            return this;
        }

        get scrollerEnable() {
            var scroller = this.childrenMap.scroller;
            if (!scroller) {
                return false;
            }

            return scroller.enable;
        }

        set scrollerEnable(value) {
            var scroller = this.childrenMap.scroller;
            if (!scroller) {
                return;
            }
            scroller.setEnable(value);
        }

        setScrollerEnable(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.scrollerEnable = enabled;
            return this;
        }

        get scrollerYEnable() {
            return this.scrollerEnable;
        }

        set scrollerYEnable(value) {
            this.scrollerEnable = value;
        }

        setScrollerYEnable(enabled) {
            this.setScrollerEnable(enabled);
            return this;
        }

        get scrollerXEnable() {
            var scroller = this.childrenMap.scrollerX;
            if (!scroller) {
                return false;
            }

            return scroller.enable;
        }

        set scrollerXEnable(value) {
            var scroller = this.childrenMap.scrollerX;
            if (!scroller) {
                return;
            }
            scroller.setEnable(value);
        }

        setScrollerXEnable(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.scrollerXEnable = enabled;
            return this;
        }

        get scrollerXEnable() {
            var scroller = this.childrenMap.scrollerX;
            if (!scroller) {
                return false;
            }

            return scroller.enable;
        }

        set scrollerXEnable(value) {
            var scroller = this.childrenMap.scrollerX;
            if (!scroller) {
                return;
            }
            scroller.setEnable(value);
        }

        setScrollerXEnable(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.scrollerXEnable = enabled;
            return this;
        }

        get mouseWheelScrollerEnable() {
            var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
            if (!mouseWheelScroller) {
                return false;
            }

            return mouseWheelScroller.enable;
        }

        set mouseWheelScrollerEnable(value) {
            var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
            if (!mouseWheelScroller) {
                return;
            }
            mouseWheelScroller.setEnable(value);
        }

        setMouseWheelScrollerEnable(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.mouseWheelScrollerEnable = enabled;
            return this;
        }

        get mouseWheelScrollerYEnable() {
            return this.mouseWheelScrollerEnable;
        }

        set mouseWheelScrollerYEnable(value) {
            this.mouseWheelScrollerEnable = value;
        }

        setMouseWheelScrollerYEnable(enabled) {
            this.setMouseWheelScrollerEnable(enabled);
            return this;
        }

        get mouseWheelScrollerXEnable() {
            var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
            if (!mouseWheelScroller) {
                return false;
            }

            return mouseWheelScroller.enable;
        }

        set mouseWheelScrollerXEnable(value) {
            var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
            if (!mouseWheelScroller) {
                return;
            }
            mouseWheelScroller.setEnable(value);
        }

        setMouseWheelScrollerXEnable(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }
            this.mouseWheelScrollerXEnable = enabled;
            return this;
        }

        setDropZoneEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            var child = this.childrenMap.child;
            child.setInteractive();
            child.input.dropZone = enable;
            return this;
        }
    };

    // mixin
    Object.assign(
        Scrollable$1.prototype,
        Methods$8
    );

    var TextToLines = function (textObject, text, lines) {
        var textObjectType = GetTextObjectType(textObject);
        switch (textObjectType) {
            case TextType:
                lines = textObject.getWrappedText(text); // Array of string
                break;
            case TagTextType:
                lines = textObject.getPenManager(text, lines); // Pens-manager
                break;
            case BitmapTextType:
                if (textObject.maxWidth > 0) {
                    lines = textObject.setText(text).getTextBounds().wrappedText.split('\n');
                } else {
                    lines = text.split('\n');
                }

                break;
        }
        return lines;
    };

    var SetText = function (text) {
        if (text !== undefined) {
            this.text = text;
        }

        // Wrap content in lines
        this.lines = TextToLines(this.textObject, this.text, this.lines);

        // Get lines count
        this.linesCount = this.lines.length;

        // Re-calculate these values later
        this._textHeight = undefined;
        this._textVisibleHeight = undefined;

        this.updateTextObject();
        return this;
    };

    var TextHeightToLinesCount$1 = function (height) {
        // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
        return (height - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing);
    };

    var LinesCountToTextHeight = function (linesCount) {
        // height = (linesCount * (lineHeight + lineSpacing)) - lineSpacing
        return (linesCount * (this.textLineHeight + this.textLineSpacing)) - this.textLineSpacing;
    };

    var GetLines$1 = function (startLineIdx) {
        var endLineIdx = startLineIdx + this.visibleLinesCount + 1;
        var text;
        switch (this.textObjectType) {
            case TextType:
                text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
                break;
            case TagTextType:
                var startIdx = this.lines.getLineStartIndex(startLineIdx);
                var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
                text = this.lines.getSliceTagText(startIdx, endIdx, true);
                break;
            case BitmapTextType:
                text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
                break;
        }
        return text;
    };

    var SetNoWrapText = function (textObject, text) {
        var textObjectType = GetTextObjectType(textObject);
        switch (textObjectType) {
            case TextType:
                // Store wrap properties
                var style = textObject.style;
                var wordWrapWidth = style.wordWrapWidth;
                var wordWrapCallback = style.wordWrapCallback;
                // Disable wrap
                style.wordWrapWidth = 0;
                style.wordWrapCallback = undefined;
                // Set text
                textObject.setText(text);
                // Restore wrap
                style.wordWrapWidth = wordWrapWidth;
                style.wordWrapCallback = wordWrapCallback;
                break;

            case TagTextType:
                // Store wrap properties
                var style = textObject.style;
                var wrapMode = style.wrapMode;
                // Disable wrap
                style.wrapMode = 0;
                // Set text
                textObject.setText(text);
                // Restore wrap
                style.wrapMode = wrapMode;
                break;

            case BitmapTextType:
                // Store wrap properties
                var maxWidth = textObject._maxWidth;
                // Disable wrap
                textObject._maxWidth = 0;
                // Set text
                textObject.setText(text);
                // Restore wrap
                textObject._maxWidth = maxWidth;
                break;
        }
    };

    var ResetTextObjectPosition = function () {
        var config = this.textObject.rexSizer;
        this.textObject.y += (config.offsetY - config.preOffsetY);
        config.preOffsetY = config.offsetY;
        this.resetChildPositionState(this.textObject);

        if (this.textCropEnable) {
            CropTextObject.call(this);
        }
    };

    var CropTextObject = function () {
        // Don't have setCrop method, return
        if (!this.textObject.setCrop) {
            return;
        }

        var offsetY = this.textObject.rexSizer.offsetY;
        var cropY, cropHeight;
        if (offsetY <= 0) {
            cropY = -offsetY;
            cropHeight = this.height;
        } else {
            cropY = 0;
            cropHeight = this.height - offsetY;
        }
        this.textObject.setCrop(
            0,
            cropY,
            this.width,
            cropHeight
        );
    };

    var UpdateTextObject = function () {
        var startLineIndex = Math.max(Math.floor(TextHeightToLinesCount$1.call(this, -this.textOY)), 0);
        var textOffset = LinesCountToTextHeight.call(this, startLineIndex) + this.textOY;

        // Grab visible lines
        var text = GetLines$1.call(this, startLineIndex);

        // Display visible content
        SetNoWrapText(this.textObject, text);

        this.textObject.rexSizer.offsetY = textOffset;
        ResetTextObjectPosition.call(this);
        return this;
    };

    var PreLayout = function () {
        // Style of text
        this._textLineHeight = undefined;
        this._textLineSpacing = undefined;
        // Style of text, width of text
        this._visibleLinesCount = undefined;
        // Style of text, total lines of content
        this._textHeight = undefined;
        this._textVisibleHeight = undefined;

        PreLayout$4.call(this);
        return this;
    };

    var ResizeText = function (textObject, width, height) {
        height += (this.textLineHeight + this.textLineSpacing); // Add 1 line
        if ((this.textObjectWidth === width) && (this._textObjectRealHeight === height)) {
            return;
        }
        this.textObjectWidth = width;
        this._textObjectRealHeight = height;

        switch (this.textObjectType) {
            case TextType:
            case TagTextType:
                textObject.setFixedSize(width, height);

                var style = textObject.style;
                var wrapWidth = Math.max(width, 0);
                if (this.textObjectType === TextType) {  // Built-in text
                    style.wordWrapWidth = wrapWidth;
                } else {  // BBCode text, Tag text
                    if (style.wrapMode === 0) { // Turn no-wrap to word-wrap
                        style.wrapMode = 1;
                    }
                    style.wrapWidth = wrapWidth;
                }
                break;
            case BitmapTextType:
                textObject.setMaxWidth(width);
                break;
        }

        // Render content again
        this.setText();
    };

    var LayoutChildren$1 = function () {
        var child, childConfig, padding;
        var startX = this.left,
            startY = this.top;
        var x, y, width, height; // Align zone

        // LayoutChildren text child
        // Skip invisible child
        child = this.textObject;
        if (!child.rexSizer.hidden) {
            childConfig = child.rexSizer;
            padding = childConfig.padding;
            x = startX + (padding.left * this.scaleX);
            y = startY + (padding.top * this.scaleY);
            width = (this.width * this.scaleX) - ((padding.left + padding.right) * this.scaleX);
            height = (this.height * this.scaleY) - ((padding.top + padding.bottom) * this.scaleY);
            ResizeText.call(this, child, width, height);

            AlignIn(child, x, y, width, height, childConfig.align);

            childConfig.preOffsetY = 0; // Clear preOffsetY
            ResetTextObjectPosition.call(this);

            if (this.textMask) {
                this.textMask.setPosition().resize();
                this.resetChildPositionState(this.textMask);
            }

        }
    };

    var Methods$7 = {
        setText: SetText,
        updateTextObject: UpdateTextObject,
        preLayout: PreLayout,
        layoutChildren: LayoutChildren$1,
    };

    const IsPlainObject$c = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$1C = Phaser.Utils.Objects.GetValue;
    const ALIGN_LEFTTOP$1 = Phaser.Display.Align.TOP_LEFT;

    class TextBlock extends Base$1 {
        constructor(scene, x, y, minWidth, minHeight, config) {
            if (IsPlainObject$c(x)) {
                config = x;
                x = GetValue$1C(config, 'x', 0);
                y = GetValue$1C(config, 'y', 0);
                minWidth = GetValue$1C(config, 'width', undefined);
                minHeight = GetValue$1C(config, 'height', undefined);
            } else if (IsPlainObject$c(minWidth)) {
                config = minWidth;
                minWidth = GetValue$1C(config, 'width', undefined);
                minHeight = GetValue$1C(config, 'height', undefined);
            }

            super(scene, x, y, minWidth, minHeight, config);

            this.type = 'rexTextBlock';
            this.textObject = undefined;
            this.linesCount = 0;
            this.textMask = undefined;
            this.textObjectType = undefined;
            this._textLineHeight = undefined;
            this._textLineSpacing = undefined;
            this._visibleLinesCount = undefined;
            this._textHeight = undefined;
            this._textVisibleHeight = undefined;
            this._textObjectRealHeight = 0;

            this.lines = undefined;
            // Text object : array of string
            // Tag text object : pens-manager
            // Bitmap text object : array of string

            this.text = GetValue$1C(config, 'content', '');
            this._textOY = 0;
            this.execeedTopState = false;
            this.execeedBottomState = false;

            this.setClampMode(GetValue$1C(config, 'clampTextOY', true));

            this.alwaysScrollable = GetValue$1C(config, 'alwaysScrollable', false);

            // Add elements
            var background = GetValue$1C(config, 'background', undefined);
            var textObject = GetValue$1C(config, 'text', undefined);
            if (textObject === undefined) {
                textObject = CreateDefaultTextObject(scene);
            }
            this.textCropEnable = GetValue$1C(config, 'textCrop', !!textObject.setCrop);
            var textMaskEnable = GetValue$1C(config, 'textMask', !this.textCropEnable);

            if (background) {
                this.addBackground(background);
            }

            this.add(textObject);
            this.sizerChildren = [textObject];

            var sizerConfig = this.getSizerConfig(textObject);
            sizerConfig.align = ALIGN_LEFTTOP$1;
            sizerConfig.padding = GetBoundsConfig$1(0);
            sizerConfig.expand = true;
            this.textObject = textObject;

            this.textObjectType = GetTextObjectType(textObject);

            // Add more variables
            sizerConfig.preOffsetY = 0;
            sizerConfig.offsetY = 0;

            // Create mask of text object
            if (textMaskEnable) {
                this.textMask = AddChildMask.call(this, this.textObject, this);
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('text', textObject);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.textObject = undefined;
            this.textMask = undefined;
            if (this.lines) {
                switch (this.textObjectType) {
                    case TextType:
                        this.lines.length = 0;
                        break;
                    case TagTextType:
                        this.lines.destroy();
                        break;
                    case BitmapTextType:
                        this.lines.length = 0;
                        break;
                }
                this.lines = undefined;
            }

            super.destroy(fromScene);
        }

        setClampMode(mode) {
            if (mode === undefined) {
                mode = true;
            }
            this.clampTextOY = mode;
            return this;
        }

        get textLineHeight() {
            if (this._textLineHeight === undefined) {
                var lineHeight;
                switch (this.textObjectType) {
                    case TextType:
                    case TagTextType:
                        var style = this.textObject.style;
                        lineHeight = style.metrics.fontSize + style.strokeThickness;
                        break;
                    case BitmapTextType:
                        var scale = (this.textObject.fontSize / this.textObject.fontData.size);
                        lineHeight = this.textObject.fontData.lineHeight * scale;
                        break;

                }
                this._textLineHeight = lineHeight;
            }
            return this._textLineHeight;
        }

        get textLineSpacing() {
            if (this._textLineSpacing === undefined) {
                var lineSpacing;
                switch (this.textObjectType) {
                    case TextType:
                    case TagTextType:
                        lineSpacing = this.textObject.lineSpacing;
                        break;
                    case BitmapTextType:
                        lineSpacing = 0;
                        break;
                }
                this._textLineSpacing = lineSpacing;
            }
            return this._textLineSpacing;
        }

        get visibleLinesCount() {
            if (this._visibleLinesCount === undefined) {
                this._visibleLinesCount = Math.floor(TextHeightToLinesCount$1.call(this, this._textObjectRealHeight));
            }
            return this._visibleLinesCount;
        }

        get topTextOY() {
            return 0;
        }

        get bottomTextOY() {
            return -this.textVisibleHeight;
        }

        get textHeight() {
            if (this._textHeight === undefined) {
                this._textHeight = LinesCountToTextHeight.call(this, this.linesCount);
            }
            return this._textHeight;
        }

        get textObjectHeight() {
            return this._textObjectRealHeight - (this.textLineHeight + this.textLineSpacing);  // Remove 1 text line
        }

        get textVisibleHeight() {
            if (this._textVisibleHeight === undefined) {
                var h = this.textHeight - this.textObjectHeight;
                if (!this.alwaysScrollable && (h < 0)) {
                    h = 0;
                }
                this._textVisibleHeight = h;
            }
            return this._textVisibleHeight;
        }

        textOYExceedTop(oy) {
            if (oy === undefined) {
                oy = this.textOY;
            }
            return (oy > this.topTextOY);
        }

        textOYExeceedBottom(oy) {
            if (oy === undefined) {
                oy = this.textOY;
            }
            return (oy < this.bottomTextOY);
        }

        get textOY() {
            return this._textOY;
        }

        set textOY(oy) {
            var topTextOY = this.topTextOY;
            var bottomTextOY = this.bottomTextOY;
            var textOYExceedTop = this.textOYExceedTop(oy);
            var textOYExeceedBottom = this.textOYExeceedBottom(oy);

            if (this.clampTextOY) {
                if (this.visibleLinesCount > this.linesCount) {
                    oy = 0;
                } else if (textOYExceedTop) {
                    oy = topTextOY;
                } else if (textOYExeceedBottom) {
                    oy = bottomTextOY;
                }
            }

            if (this._textOY !== oy) {
                this._textOY = oy;
                this.updateTextObject();
            }

            if (textOYExceedTop) {
                if (!this.execeedTopState) {
                    this.emit('execeedtop', this, oy, topTextOY);
                }
            }
            this.execeedTopState = textOYExceedTop;

            if (textOYExeceedBottom) {
                if (!this.execeedBottomState) {
                    this.emit('execeedbottom', this, oy, bottomTextOY);
                }
            }
            this.execeedBottomState = textOYExeceedBottom;
        }

        setTextOY(oy) {
            this.textOY = oy;
            return this;
        }

        set t(value) {
            this.textOY = -this.textVisibleHeight * value;
        }

        get t() {
            var textVisibleHeight = this.textVisibleHeight;
            if (textVisibleHeight === 0) {
                return 0;
            }
            return (this.textOY / -textVisibleHeight);
        }

        setTextOYByPercentage(percentage) {
            this.t = percentage;
            return this;
        }
    }

    var CreateDefaultTextObject = function (scene) {
        return scene.add.text(0, 0, '');
    };

    Object.assign(
        TextBlock.prototype,
        Methods$7
    );

    var InjectProperties$2 = function (textBlock) {
        Object.defineProperty(textBlock, 'childOY', {
            configurable: true,
            get: function () {
                return textBlock.textOY;
            },
            set: function (value) {
                textBlock.textOY = value;
            }
        });
        Object.defineProperty(textBlock, 'topChildOY', {
            get: function () {
                return textBlock.topTextOY;
            }
        });
        Object.defineProperty(textBlock, 'bottomChildOY', {
            get: function () {
                return textBlock.bottomTextOY;
            }
        });
        Object.defineProperty(textBlock, 'childVisibleHeight', {
            get: function () {
                return textBlock.textObjectHeight;
            }
        });
        Object.defineProperty(textBlock, 'childHeight', {
            get: function () {
                return textBlock.textHeight;
            }
        });
    };

    var SetTextMethods$2 = {
        setText(text) {
            var textBlock = this.childrenMap.child;
            textBlock.setText(text);

            this.resizeController();
            return this;
        },

        appendText(text) {
            this.setText(this.text + text);
            return this;
        }
    };

    var ScrollMethods$2 = {
        scrollToLine(lineIndex) {
            this.setChildOY(-this.lineHeight * lineIndex);
            return this;
        },

        scrollToNextLine(lineCount) {
            if (lineCount === undefined) {
                lineCount = 1;
            }

            var lineIndex = this.lineIndex + lineCount;
            this.scrollToLine(lineIndex);
            return this;
        }
    };

    const GetValue$1B = Phaser.Utils.Objects.GetValue;

    class TextArea extends Scrollable$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            // Create text-block
            var textObject = GetValue$1B(config, 'text', undefined);
            var textWidth = GetValue$1B(config, 'textWidth', undefined);
            var textHeight = GetValue$1B(config, 'textHeight', undefined);
            var textCrop = GetValue$1B(config, 'textCrop', !!textObject.setCrop);
            var textMask = GetValue$1B(config, 'textMask', !textCrop);
            var content = GetValue$1B(config, 'content', '');
            var textBlock = new TextBlock(scene, {
                width: textWidth,
                height: textHeight,
                text: textObject,
                textMask: textMask,
                textCrop: textCrop && !textMask,
                content: content,
                clampTextOY: GetValue$1B(config, 'clampChildOY', false),
                alwaysScrollable: GetValue$1B(config, 'alwaysScrollable', false),
            });
            scene.add.existing(textBlock); // Important: Add to display list for touch detecting
            // Inject properties for scrollable interface
            InjectProperties$2(textBlock);

            // Fill config of scrollable
            config.scrollMode = 0; // Vertical
            config.type = 'rexTextArea';
            config.child = {
                gameObject: textBlock,
                expandWidth: (textWidth === undefined),
                expandHeight: (textHeight === undefined),
            };
            var spaceConfig = GetValue$1B(config, 'space', undefined);
            if (spaceConfig) {
                spaceConfig.child = GetValue$1B(spaceConfig, 'text', 0);
            }

            super(scene, config);

            this.addChildrenMap('text', textObject);
        }

        get text() {
            return this.childrenMap.child.text;
        }

        get lineHeight() {
            var textBlock = this.childrenMap.child;
            return textBlock.textLineHeight + textBlock.textLineSpacing;
        }

        get lineIndex() {
            return Math.floor(-this.childOY / this.lineHeight);
        }

        get linesCount() {
            var textBlock = this.childrenMap.child;
            return textBlock.linesCount;
        }

        get contentHeight() {
            var textBlock = this.childrenMap.child;
            return textBlock.textHeight;
        }
    }

    Object.assign(
        TextArea.prototype,
        SetTextMethods$2,
        ScrollMethods$2,
    );

    const GetValue$1A = Phaser.Utils.Objects.GetValue;

    var CreateTextArea = function (scene, config, creators) {
        config = (config) ? DeepClone(config) : {};

        var createBackground = GetValue$1A(creators, 'background', CreateBackground$2);
        var createText = GetValue$1A(creators, 'text', CreateText);
        var createTrack = GetValue$1A(creators, 'track', CreateBackground$2);
        var createThumb = GetValue$1A(creators, 'thumb', CreateBackground$2);

        if (createBackground) {
            config.background = createBackground(scene, config.background);
        } else {
            delete config.background;
        }

        if (createText) {
            config.text = createText(scene, config.text);
        } else {
            delete config.text;
        }

        var sliderConfig = config.slider;
        if ((sliderConfig !== false) && (sliderConfig !== null)) {
            if (sliderConfig === undefined) {
                sliderConfig = {};
            }

            if (createTrack) {
                sliderConfig.track = createTrack(scene, sliderConfig.track);
            } else {
                delete sliderConfig.track;
            }

            if (createThumb) {
                sliderConfig.thumb = createThumb(scene, sliderConfig.thumb);
            } else {
                delete sliderConfig.thumb;
            }

            config.slider = sliderConfig;
        }

        // No header
        // No footer

        var gameObject = new TextArea(scene, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    var CreateText = function (scene, config) {
        var gameObjectType;
        if (config) {
            if (config.hasOwnProperty('$type')) {
                gameObjectType = config.$type;
            } else {
                if (config.hasOwnProperty('key')) {
                    gameObjectType = 'bitmaptext';
                    config.font = config.key;
                }
            }
        }

        var gameObject;
        switch (gameObjectType) {
            case 'bitmaptext':
            case 'bitmap':
                gameObject = new StatesBitmapText(scene, config);
                break;

            case 'bbcodetext':
            case 'bbcode':
                gameObject = new BBCodeText(scene, 0, 0, '', config);
                break;

            case 'label':
                gameObject = new SimpleLabel(scene, config);
                break;

            case 'textarea':
                gameObject = CreateTextArea(scene, config);
                break;

            default:
                gameObject = new StatesText(scene, config);
                break;
        }

        DecorateGameObject(gameObject, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    var CreateImage = function (scene, config) {
        var gameObjectType;
        if (config) {
            if (config.hasOwnProperty('$type')) {
                gameObjectType = config.$type;
            } else {
                if (config.hasOwnProperty('leftWidth')) {
                    gameObjectType = 'nineSlice';
                } else if (config.hasOwnProperty('color') || config.hasOwnProperty('strokeColor')) {
                    gameObjectType = 'roundRectangle';
                }
            }
        }

        var gameObject;
        switch (gameObjectType) {
            case 'nineSlice':
                if (!config.hasOwnProperty('stretchMode')) {
                    gameObject = new StatesNineSlice(scene, config);
                } else {
                    gameObject = new StatesNinePatch(scene, config);
                }
                break;

            case 'roundRectangle':
                gameObject = new StatesRoundRectangle(scene, config);
                break;

            default:
                gameObject = new StatesImage(scene, config);
                break;
        }

        DecorateGameObject(gameObject, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    const GetValue$1z = Phaser.Utils.Objects.GetValue;

    var BuildLabelConfig = function (scene, config, creators) {
        config = (config) ? DeepClone(config) : {};

        var createBackground = GetValue$1z(creators, 'background', CreateBackground$2);
        var createText = GetValue$1z(creators, 'text', CreateText);
        var createIcon = GetValue$1z(creators, 'icon', CreateImage);
        var createAction = GetValue$1z(creators, 'action', CreateImage);

        if ((config.background !== null) && createBackground) {
            config.background = createBackground(scene, config.background);
        } else {
            delete config.background;
        }

        if ((config.text !== null) && createText) {
            config.text = createText(scene, config.text);
        } else {
            delete config.text;
        }

        if ((config.icon !== null) && createIcon) {
            config.icon = createIcon(scene, config.icon);
        } else {
            delete config.icon;
        }

        if ((config.action !== null) && createAction) {
            config.action = createAction(scene, config.action);
        } else {
            delete config.action;
        }

        return config;
    };

    class SimpleLabel extends Label {
        constructor(scene, config, creators) {
            config = BuildLabelConfig(scene, config, creators);
            super(scene, config);
            this.type = 'rexSimpleLabel';
        }

        setActiveState(enable) {
            RunMethod$1(this.getChildren(), 'setActiveState', enable);
            return this;
        }

        setHoverState(enable) {
            RunMethod$1(this.getChildren(), 'setHoverState', enable);
            return this;
        }

        setDisableState(enable) {
            RunMethod$1(this.getChildren(), 'setDisableState', enable);
            return this;
        }

    }

    var RunMethod$1 = function (children, methodName, enable) {
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var gameObject = children[i];
            if (gameObject && gameObject[methodName]) {
                gameObject[methodName](enable);
            }
        }
    };

    ObjectFactory.register('simpleLabel', function (config, creators) {
        var gameObject = new SimpleLabel(this.scene, config, creators);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.SimpleLabel', SimpleLabel);

    /*
    Elements:

    Icon  Title      ActionIcon
    Icon  Separator  ActionIcon
    Icon  Text       ActionIcon

    */


    const GetValue$1y = Phaser.Utils.Objects.GetValue;

    var LayoutMode0$2 = function (config) {
        var scene = this.scene;

        var orientation = GetValue$1y(config, 'orientation', 0);
        this.setOrientation(orientation);

        // Add elements
        var icon = GetValue$1y(config, 'icon', undefined);
        var iconMask = GetValue$1y(config, 'iconMask', undefined);
        var innerBackground = GetValue$1y(config, 'innerBackground', undefined);
        var title = GetValue$1y(config, 'title', undefined);
        var separator = GetValue$1y(config, 'separator', undefined);
        var text = GetValue$1y(config, 'text', undefined);
        var action = GetValue$1y(config, 'action', undefined);
        var actionMask = GetValue$1y(config, 'actionMask', undefined);


        if (icon) {
            var align = GetValue$1y(config, 'align.icon', 'center');
            var padding;
            if (this.orientation === 0) {
                padding = {
                    right: GetValue$1y(config, 'space.icon', 0),
                    top: GetValue$1y(config, 'space.iconTop', 0),
                    bottom: GetValue$1y(config, 'space.iconBottom', 0),
                    left: GetValue$1y(config, 'space.iconLeft', 0),
                };
            } else {
                padding = {
                    bottom: GetValue$1y(config, 'space.icon', 0),
                    left: GetValue$1y(config, 'space.iconLeft', 0),
                    right: GetValue$1y(config, 'space.iconRight', 0),
                    top: GetValue$1y(config, 'space.iconTop', 0),
                };
            }
            var fitRatio = GetValue$1y(config, 'squareFitIcon', false) ? 1 : 0;

            this.add(
                icon,
                { proportion: 0, align: align, padding: padding, fitRatio: fitRatio }
            );

            if (iconMask) {
                iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
            }

            if (!fitRatio) {
                var iconSize = GetValue$1y(config, 'iconSize', undefined);
                this.setIconSize(
                    GetValue$1y(config, 'iconWidth', iconSize),
                    GetValue$1y(config, 'iconHeight', iconSize)
                );
            }
        }

        // InnerSizer : title, separator, text
        var innerSizer = new Sizer(scene, {
            orientation: 1,
        });

        if (innerBackground) {
            innerSizer.addBackground(innerBackground);
        }

        var separatorSpace = GetValue$1y(config, 'space.separator', 0);

        if (title) {
            var align = GetValue$1y(config, 'align.title', 'left');
            var expandTitleWidth = GetValue$1y(config, 'expandTitleWidth', false);
            var expandTitleHeight = GetValue$1y(config, 'expandTitleHeight', false);
            var proportion, padding, expand;
            proportion = (expandTitleHeight) ? 1 : 0;
            expand = expandTitleWidth;
            padding = {
                bottom: (!separator && text) ? GetValue$1y(config, 'space.title', separatorSpace) : 0,
                left: GetValue$1y(config, 'space.titleLeft', 0),
                right: GetValue$1y(config, 'space.titleRight', 0),
            };
            innerSizer.add(
                title,
                { proportion: proportion, expand: expand, align: align, padding: padding }
            );
        }

        if (separator) {
            var padding = {
                top: (title) ? separatorSpace : 0,
                bottom: (text) ? separatorSpace : 0,
                left: GetValue$1y(config, 'space.separatorLeft', 0),
                right: GetValue$1y(config, 'space.separatorRight', 0),
            };
            innerSizer.add(
                separator,
                { expand: true, padding: padding }
                // Fixed height, expand width
            );
        }

        if (text) {
            var align = GetValue$1y(config, 'align.text', 'left');
            var expandTextWidth = GetValue$1y(config, 'expandTextWidth', false);
            var expandTextHeight = GetValue$1y(config, 'expandTextHeight', false);
            var proportion, padding, expand;
            proportion = (expandTextHeight) ? 1 : 0;
            expand = expandTextWidth;
            padding = {
                left: GetValue$1y(config, 'space.textLeft', 0),
                right: GetValue$1y(config, 'space.textRight', 0),
            };
            innerSizer.add(
                text,
                { proportion: proportion, expand: expand, align: align, padding: padding }
            );
        }

        var padding = undefined;
        if (action) {
            padding = {
                right: GetValue$1y(config, 'space.text', 0)
            };
        }
        this.add(
            innerSizer,
            { proportion: 1, padding: padding }
        );
        // InnerSizer : title, separator, text

        if (action) {
            var align = GetValue$1y(config, 'align.action', 'center');
            var padding;
            if (this.orientation === 0) {
                padding = {
                    top: GetValue$1y(config, 'space.actionTop', 0),
                    bottom: GetValue$1y(config, 'space.actionBottom', 0),
                    right: GetValue$1y(config, 'space.actionRight', 0),
                };
            } else {
                padding = {
                    left: GetValue$1y(config, 'space.actionLeft', 0),
                    right: GetValue$1y(config, 'space.actionRight', 0),
                    bottom: GetValue$1y(config, 'space.actionBottom', 0),
                };
            }
            var fitRatio = GetValue$1y(config, 'squareFitAction', false) ? 1 : 0;

            this.add(
                action,
                { proportion: 0, align: align, padding: padding, fitRatio: fitRatio }
            );

            if (actionMask) {
                actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
            }

            if (!fitRatio) {
                var actionSize = GetValue$1y(config, 'actionSize');
                this.setActionSize(
                    GetValue$1y(config, 'actionWidth', actionSize),
                    GetValue$1y(config, 'actionHeight', actionSize)
                );
            }
        }

        this.addChildrenMap('icon', icon);
        this.addChildrenMap('iconMask', iconMask);
        this.addChildrenMap('innerSizer', innerSizer);
        this.addChildrenMap('innerBackground', innerBackground);
        this.addChildrenMap('title', title);
        this.addChildrenMap('separator', separator);
        this.addChildrenMap('text', text);
        this.addChildrenMap('action', action);
        this.addChildrenMap('actionMask', actionMask);
    };

    /*
    Elements:

    Title      Title       Title
    Separator  Separator   Separator
    Icon       Text        ActionIcon 

    */


    const GetValue$1x = Phaser.Utils.Objects.GetValue;

    var LayoutMode1$1 = function (config) {
        this.setOrientation(1);
        this.setRTL(false);

        var scene = this.scene;

        // Add elements
        var title = GetValue$1x(config, 'title', undefined);
        var separator = GetValue$1x(config, 'separator', undefined);
        var innerBackground = GetValue$1x(config, 'innerBackground', undefined);
        var icon = GetValue$1x(config, 'icon', undefined);
        var iconMask = GetValue$1x(config, 'iconMask', undefined);
        var text = GetValue$1x(config, 'text', undefined);
        var action = GetValue$1x(config, 'action', undefined);
        var actionMask = GetValue$1x(config, 'actionMask', undefined);


        if (title) {
            var align = GetValue$1x(config, 'align.title', 'left');
            var expandTitleWidth = GetValue$1x(config, 'expandTitleWidth', false);
            var expandTitleHeight = GetValue$1x(config, 'expandTitleHeight', false);
            var proportion, padding, expand;
            proportion = (expandTitleHeight) ? 1 : 0;
            expand = expandTitleWidth;
            padding = {
                bottom: GetValue$1x(config, 'space.title', 0),
                left: GetValue$1x(config, 'space.titleLeft', 0),
                right: GetValue$1x(config, 'space.titleRight', 0),
            };
            this.add(
                title,
                { proportion: proportion, expand: expand, align: align, padding: padding }
            );
        }

        if (separator) {
            var separatorSpace = GetValue$1x(config, 'space.separator', 0);
            var padding = {
                top: (title) ? separatorSpace : 0,
                bottom: (text) ? separatorSpace : 0,
                left: GetValue$1x(config, 'space.separatorLeft', 0),
                right: GetValue$1x(config, 'space.separatorRight', 0),
            };
            this.add(
                separator,
                { proportion: 0, expand: true, padding: padding }
                // Fixed height, expand width
            );
        }

        var orientation = GetValue$1x(config, 'orientation', 0);
        var innerSizer = new Sizer(scene, {
            orientation: orientation,
            rtl: GetValue$1x(config, 'rtl', false),

            space: {
                left: GetValue$1x(config, 'space.innerLeft', 0),
                right: GetValue$1x(config, 'space.innerRight', 0),
                top: GetValue$1x(config, 'space.innerTop', 0),
                bottom: GetValue$1x(config, 'space.innerBottom', 0),
            }
        });
        if (innerBackground) {
            innerSizer.addBackground(innerBackground);
        }

        this.add(
            innerSizer,
            { proportion: 1, expand: true }
        );

        if (icon) {
            var align = GetValue$1x(config, 'align.icon', 'center');
            var padding;
            if (innerSizer.orientation === 0) {
                padding = {
                    right: GetValue$1x(config, 'space.icon', 0),
                    top: GetValue$1x(config, 'space.iconTop', 0),
                    bottom: GetValue$1x(config, 'space.iconBottom', 0),
                    left: GetValue$1x(config, 'space.iconLeft', 0),
                };
            } else {
                padding = {
                    bottom: GetValue$1x(config, 'space.icon', 0),
                    left: GetValue$1x(config, 'space.iconLeft', 0),
                    right: GetValue$1x(config, 'space.iconRight', 0),
                    top: GetValue$1x(config, 'space.iconTop', 0),
                };
            }
            var fitRatio = GetValue$1x(config, 'squareFitIcon', false) ? 1 : 0;

            innerSizer.add(
                icon,
                { proportion: 0, align: align, padding: padding, fitRatio: fitRatio }
            );

            if (iconMask) {
                iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
            }

            if (!fitRatio) {
                var iconSize = GetValue$1x(config, 'iconSize', undefined);
                this.setIconSize(
                    GetValue$1x(config, 'iconWidth', iconSize),
                    GetValue$1x(config, 'iconHeight', iconSize)
                );
            }
        }

        if (text) {
            var align = GetValue$1x(config, 'align.text', 'left');
            var textSpace = GetValue$1x(config, 'space.text', 0);
            var expandTextWidth = GetValue$1x(config, 'expandTextWidth', false);
            var expandTextHeight = GetValue$1x(config, 'expandTextHeight', false);
            var proportion, padding, expand;
            if (innerSizer.orientation === 0) {
                proportion = (expandTextWidth) ? 1 : 0;
                if (action) {
                    padding = { right: textSpace };
                }
                expand = expandTextHeight;
            } else {
                proportion = (expandTextHeight) ? 1 : 0;
                if (action) {
                    padding = {
                        bottom: textSpace
                    };
                }
                expand = expandTextWidth;
            }

            innerSizer.add(
                text,
                { proportion: proportion, expand: expand, align: align, padding: padding }
            );
        }

        if (action) {
            var align = GetValue$1x(config, 'align.action', 'center');
            var padding;
            if (innerSizer.orientation === 0) {
                padding = {
                    top: GetValue$1x(config, 'space.actionTop', 0),
                    bottom: GetValue$1x(config, 'space.actionBottom', 0),
                    right: GetValue$1x(config, 'space.actionRight', 0),
                };
            } else {
                padding = {
                    left: GetValue$1x(config, 'space.actionLeft', 0),
                    right: GetValue$1x(config, 'space.actionRight', 0),
                    bottom: GetValue$1x(config, 'space.actionBottom', 0),
                };
            }
            var fitRatio = GetValue$1x(config, 'squareFitAction', false) ? 1 : 0;

            innerSizer.add(
                action,
                { proportion: 0, align: align, padding: padding, fitRatio: fitRatio }
            );

            if (actionMask) {
                actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
            }

            if (!fitRatio) {
                var actionSize = GetValue$1x(config, 'actionSize');
                this.setActionSize(
                    GetValue$1x(config, 'actionWidth', actionSize),
                    GetValue$1x(config, 'actionHeight', actionSize)
                );
            }
        }

        this.addChildrenMap('title', title);
        this.addChildrenMap('separator', separator);
        this.addChildrenMap('innerSizer', innerSizer);
        this.addChildrenMap('innerBackground', innerBackground);
        this.addChildrenMap('icon', icon);
        this.addChildrenMap('iconMask', iconMask);
        this.addChildrenMap('text', text);
        this.addChildrenMap('action', action);
        this.addChildrenMap('actionMask', actionMask);
    };

    const GetValue$1w = Phaser.Utils.Objects.GetValue;
    const LayoutCallbacks$1 = [LayoutMode0$2, LayoutMode1$1];

    class TitleLabel extends LabelBase {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            // Create sizer
            super(scene, config);
            this.type = 'rexTitleLabel';

            // Add Background
            var background = GetValue$1w(config, 'background', undefined);
            if (background) {
                this.addBackground(background);
            }

            // Wrap title, text
            var title = GetValue$1w(config, 'title', undefined);
            var text = GetValue$1w(config, 'text', undefined);

            if (title) {
                var wrapTitle = GetValue$1w(config, 'wrapTitle', false);
                var adjustTitleFontSize = GetValue$1w(config, 'adjustTitleFontSize', false);
                if (wrapTitle) {
                    if (wrapTitle === true) {
                        wrapTitle = 'word';
                    }

                    SetWrapMode(title, wrapTitle);
                    config.expandTitleWidth = true;
                    WrapExpandText(title);

                } else if (adjustTitleFontSize) {
                    config.expandTextWidth = true;
                    config.expandTextHeight = true;
                    FontSizeExpandText(title, { fitHeight: true });

                }
            }

            if (text) {
                var wrapText = GetValue$1w(config, 'wrapText', false);
                var adjustTextFontSize = GetValue$1w(config, 'adjustTextFontSize', false);
                if (wrapText) {
                    if (wrapText === true) {
                        wrapText = 'word';
                    }

                    SetWrapMode(text, wrapText);
                    config.expandTextWidth = true;
                    WrapExpandText(text);

                } else if (adjustTextFontSize) {
                    config.expandTextWidth = true;
                    config.expandTextHeight = true;
                    FontSizeExpandText(text, { fitHeight: true });

                }
            }

            var layoutMode = GetValue$1w(config, 'layoutMode', 0);
            var layoutCallback = LayoutCallbacks$1[layoutMode] || LayoutCallbacks$1[0];
            layoutCallback.call(this, config);

            // Elements : title, separator, innerBackground,
            //            icon, iconMask, text, action, actionMask, background
            //            innerSizer
            this.addChildrenMap('background', config.background);

        }

        // Access title game object
        get title() {
            var textObject = this.childrenMap.title;
            if (!textObject) {
                return '';
            }
            return textObject.title;
        }

        set title(value) {
            var textObject = this.childrenMap.title;
            if (!textObject) {
                return;
            }
            textObject.setText(value);
        }

        setTitle(value) {
            this.title = value;
            return this;
        }

        resetDisplayContent(config) {
            if (config === undefined) {
                config = {};
            } else if (typeof (config) === 'string') {
                config = {
                    text: config,
                };
            }

            super.resetDisplayContent(config);

            var textObject = this.childrenMap.title;
            if (textObject) {
                if (config.title === undefined) ; else if (config.title) {
                    this.show(textObject);
                    this.setTitle(config.title);
                } else { // false, null
                    this.hide(textObject);
                }
            }

            return this;
        }
    }

    ObjectFactory.register('titleLabel', function (config) {
        var gameObject = new TitleLabel(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TitleLabel', TitleLabel);

    const GetValue$1v = Phaser.Utils.Objects.GetValue;

    var BuildTitleLabelConfig = function (scene, config, creators) {
        var createInnerBackground = GetValue$1v(creators, 'innerBackground', CreateBackground$2);
        var createSeparator = GetValue$1v(creators, 'separator', CreateBackground$2);
        var createTitle = GetValue$1v(creators, 'title', CreateText);

        var innerBackground, separator;

        // Create innerBackground before background
        if ((config.innerBackground !== null) && createInnerBackground) {
            innerBackground = createInnerBackground(scene, config.innerBackground);
        }

        // Create separator before background
        if ((config.separator !== null) && createSeparator) {
            separator = createSeparator(scene, config.separator);
        }

        config = BuildLabelConfig(scene, config, creators);

        if (innerBackground) {
            config.innerBackground = innerBackground;
        } else {
            delete config.innerBackground;
        }

        if (separator) {
            config.separator = separator;
        } else {
            delete config.separator;
        }

        if ((config.title !== null) && createTitle) {
            config.title = createTitle(scene, config.title);
        } else {
            delete config.title;
        }

        // Keep background as the bottom element
        var background = config.background;
        if (background) {
            if (innerBackground) {
                scene.children.moveBelow(background, innerBackground);  // Move child1 below child2
            } else if (separator) {
                scene.children.moveBelow(background, separator);  // Move child1 below child2
            }
        }

        return config;
    };

    class SimpleTitleLabel extends TitleLabel {
        constructor(scene, config, creators) {
            config = BuildTitleLabelConfig(scene, config, creators);
            super(scene, config);
            this.type = 'rexSimpleTitleLabel';
        }

        setActiveState(enable) {
            RunMethod(this.getChildren(), 'setActiveState', enable);
            return this;
        }

        setHoverState(enable) {
            RunMethod(this.getChildren(), 'setHoverState', enable);
            return this;
        }

        setDisableState(enable) {
            RunMethod(this.getChildren(), 'setDisableState', enable);
            return this;
        }

    }

    var RunMethod = function (children, methodName, enable) {
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var gameObject = children[i];
            if (gameObject && gameObject[methodName]) {
                gameObject[methodName](enable);
            }
        }
    };

    ObjectFactory.register('simpleTitleLabel', function (config, creators) {
        var gameObject = new SimpleTitleLabel(this.scene, config, creators);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.SimpleTitleLabel', SimpleTitleLabel);

    const GetValue$1u = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$b = Phaser.Utils.Objects.IsPlainObject;

    var Build$1 = function (scene, config) {
        // Add elements
        var background = GetValue$1u(config, 'background', undefined);
        var icon = GetValue$1u(config, 'icon', undefined);
        var iconMask = GetValue$1u(config, 'iconMask', undefined);
        var nameText = GetValue$1u(config, 'nameText', undefined);
        var valueText = GetValue$1u(config, 'valueText', undefined);
        var bar = GetValue$1u(config, 'bar', undefined);
        var action = GetValue$1u(config, 'action', undefined);
        var actionMask = GetValue$1u(config, 'actionMask', undefined);

        var isLineBar = (GetValue$1u(config, 'barShape', 'line') === 'line');
        if (IsPlainObject$b(bar)) {
            var BarClass = (isLineBar) ? LineProgress : CircularProgress;
            bar = new BarClass(scene, bar);
            scene.add.existing(bar);
            // Move bar game object below nameText and valueText
            if (nameText) {
                scene.children.moveBelow(bar, nameText);
            }
            if (valueText) {
                scene.children.moveBelow(bar, valueText);
            }
        }

        var hasTextSizer = nameText || valueText || bar;

        if (background) {
            this.addBackground(background);
        }

        if (icon) {
            var padding = undefined;
            if (this.orientation === 0) {
                if (hasTextSizer || action) {
                    padding = {
                        right: GetValue$1u(config, 'space.icon', 0),
                        top: GetValue$1u(config, 'space.iconTop', 0),
                        bottom: GetValue$1u(config, 'space.iconBottom', 0),
                    };
                }
            } else {
                if (hasTextSizer || action) {
                    padding = {
                        bottom: GetValue$1u(config, 'space.icon', 0),
                        left: GetValue$1u(config, 'space.iconLeft', 0),
                        right: GetValue$1u(config, 'space.iconRight', 0),
                    };
                }
            }

            this.add(
                icon,
                { proportion: 0, padding: padding, }
            );

            if (iconMask) {
                iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
            }
        }

        if (hasTextSizer) {
            var textSizer = new Sizer(scene, {
                orientation: 1,
            });

            var nameValueSizer;
            if (nameText || valueText) {
                nameValueSizer = new Sizer(scene, {
                    orientation: 0,
                });

                if (nameText) {
                    // A space character to reserve text height
                    if (nameText.text === '') {
                        nameText.setText(' ');
                    }
                    nameText.setOrigin(0, nameText.originY);
                    var padding = {
                        left: GetValue$1u(config, 'space.name', 0),
                    };
                    nameValueSizer.add(
                        nameText,
                        { padding: padding }
                    );
                }

                if (valueText) {
                    // A space character to reserve text height
                    if (valueText.text === '') {
                        valueText.setText(' ');
                    }
                    valueText.setOrigin(1, valueText.originY);

                    nameValueSizer.addSpace();

                    var padding = {
                        right: GetValue$1u(config, 'space.value', 0),
                    };
                    nameValueSizer.add(
                        valueText,
                        { padding: padding }
                    );

                    this.setValueTextFormatCallback(
                        GetValue$1u(config, 'valueTextFormatCallback', DefaultValueTextFormatCallback),
                        GetValue$1u(config, 'valueTextFormatCallbackScope', undefined)
                    );
                }

                textSizer.add(
                    nameValueSizer,
                    { expand: true, }
                );
            }

            if (bar) {
                if (isLineBar) {
                    var paddingTop = (nameValueSizer) ? GetValue$1u(config, 'space.bar') : 0;
                    if (paddingTop === undefined) {
                        paddingTop = GetValue$1u(config, 'space.barTop', 0);
                    }
                    var padding = {
                        top: paddingTop,
                        bottom: GetValue$1u(config, 'space.barBottom', 0),
                        left: GetValue$1u(config, 'space.barLeft', 0),
                        right: GetValue$1u(config, 'space.barRight', 0),
                    };
                    textSizer.add(
                        bar,
                        { expand: true, padding: padding }
                    );
                } else {
                    var padding = {
                        top: GetValue$1u(config, 'space.barTop', 0),
                        bottom: GetValue$1u(config, 'space.barBottom', 0),
                        left: GetValue$1u(config, 'space.barLeft', 0),
                        right: GetValue$1u(config, 'space.barRight', 0),
                    };
                    this.addBackground(bar, padding);
                }
            }

            var padding = undefined;
            if (action) {
                padding = {
                    right: GetValue$1u(config, 'space.text', 0)
                };
            }
            var textAlign = GetValue$1u(config, 'align.text', 'bottom');
            this.add(
                textSizer,
                { proportion: 1, align: textAlign, padding: padding }
            );
        }

        if (action) {
            var padding;
            if (this.orientation === 0) {
                padding = {
                    top: GetValue$1u(config, 'space.actionTop', 0),
                    bottom: GetValue$1u(config, 'space.actionBottom', 0),
                };
            } else {
                padding = {
                    left: GetValue$1u(config, 'space.actionLeft', 0),
                    right: GetValue$1u(config, 'space.actionRight', 0),
                };
            }

            this.add(
                action,
                { proportion: 0, padding: padding, }
            );

            if (actionMask) {
                actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
            }
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('icon', icon);
        this.addChildrenMap('iconMask', iconMask);
        this.addChildrenMap('name', nameText);
        this.addChildrenMap('value', valueText);
        this.addChildrenMap('bar', bar);
        this.addChildrenMap('action', action);
        this.addChildrenMap('actionMask', actionMask);
    };

    var DefaultValueTextFormatCallback = function (value, min, max) {
        return value.toString();
    };

    const Clamp$5 = Phaser.Math.Clamp;

    var SetValueMethods = {
        setValueTextFormatCallback(callback, scope) {
            this.valueTextFormatCallback = callback;
            this.valueTextFormatCallbackScope = scope;
            return this;
        },

        getFormatValueText(value, min, max) {
            if (value === undefined) {
                value = this.value;
            }
            if (min === undefined) {
                min = this.minValue;
            }
            if (max === undefined) {
                max = this.maxValue;
            }

            var text;
            if (this.valueTextFormatCallbackScope) {
                text = this.valueTextFormatCallback(value, min, max);
            } else {
                text = this.valueTextFormatCallback.call(this.valueTextFormatCallbackScope, value, min, max);
            }
            return text;
        },

        updateValueText(value, min, max) {
            var textObject = this.childrenMap.value;
            if (textObject && this.valueTextFormatCallback) {
                textObject.setText(this.getFormatValueText(value, min, max));
                if (textObject.layout) {
                    textObject.layout();
                }
            }
            return this;
        },

        setValue(value, min, max) {
            if (min === undefined) {
                min = this.minValue;
            } else {
                this.minValue = min;
            }
            if (max === undefined) {
                max = this.maxValue;
            } else {
                this.maxValue = max;
            }

            value = Clamp$5(value, min, max);
            this.value = value;
            this.updateValueText(value, min, max);
            this.setBarValue(value, min, max);
            return this;
        },

        setEaseValueDuration(duration) {
            this.easeValueDuration = duration;
            return this;
        },

        easeValueTo(value, min, max) {
            if (min === undefined) {
                min = this.minValue;
            } else {
                this.minValue = min;
            }
            if (max === undefined) {
                max = this.maxValue;
            } else {
                this.maxValue = max;
            }

            if (this.easeValueTask === undefined) {
                this.easeValueTask = new EaseValueTask(this);
                this.easeValueTask.on('update', function () {
                    this.setValue(this.value, this.minValue, this.maxValue);
                }, this);
            }

            this.easeValueTask.restart({
                key: 'value',
                to: value,
                duration: this.easeValueDuration,
            });

            return this;
        },
    };

    class NameValueLabel extends Sizer {
        constructor(scene, config) {
            // Create sizer
            super(scene, config);
            this.type = 'rexNameValueLabel';

            Build$1.call(this, scene, config);

            this.setEaseValueDuration(1000);
        }

        // Access nameText game object
        get nameText() {
            var textObject = this.childrenMap.name;
            if (textObject === undefined) {
                return '';
            }
            return textObject.text;
        }

        set nameText(value) {
            var textObject = this.childrenMap.name;
            if (textObject === undefined) {
                return;
            }
            textObject.setText(value);
        }

        setNameText(value) {
            this.nameText = value;
            return this;
        }

        // Access valueText game object
        get valueText() {
            var textObject = this.childrenMap.value;
            if (textObject === undefined) {
                return '';
            }
            return textObject.text;
        }

        set valueText(value) {
            var textObject = this.childrenMap.value;
            if (textObject === undefined) {
                return;
            }
            textObject.setText(value);
        }

        setValueText(value) {
            this.valueText = value;
            return this;
        }

        // Accrss bar game object
        get barValue() {
            var bar = this.childrenMap.bar;
            if (bar === undefined) {
                return;
            }
            return bar.value;
        }

        set barValue(value) {
            var bar = this.childrenMap.bar;
            if (bar === undefined) {
                return;
            }
            bar.setValue(value);
        }

        setBarValue(value, min, max) {
            var bar = this.childrenMap.bar;
            if (bar === undefined) {
                return this;
            }
            bar.setValue(value, min, max);
            return this;
        }

        easeBarValueTo(value, min, max) {
            var bar = this.childrenMap.bar;
            if (bar === undefined) {
                return this;
            }
            bar.easeValueTo(value, min, max);
            return this;
        }

        // Access icon game object
        setTexture(key, frame) {
            var imageObject = this.childrenMap.icon;
            if (imageObject === undefined) {
                return;
            }
            imageObject.setTexture(key, frame);
            return this;
        }

        get texture() {
            var imageObject = this.childrenMap.icon;
            if (imageObject === undefined) {
                return undefined;
            }
            return imageObject.texture;
        }

        get frame() {
            var imageObject = this.childrenMap.icon;
            if (imageObject === undefined) {
                return undefined;
            }
            return imageObject.frame;
        }

        postLayout(parent, newWidth, newHeight) {
            // Pin icon-mask to icon game object
            var iconMask = this.childrenMap.iconMask;
            if (iconMask) {
                iconMask.setPosition();
                this.resetChildPositionState(iconMask);
            }
            // Pin action-mask to action game object
            var actionMask = this.childrenMap.actionMask;
            if (actionMask) {
                actionMask.setPosition();
                this.resetChildPositionState(actionMask);
            }
            super.postLayout(parent, newWidth, newHeight);
            return this;
        }

        resize(width, height) {
            super.resize(width, height);
            // Resize icon-mask to icon game object
            var iconMask = this.childrenMap.iconMask;
            if (iconMask) {
                iconMask.resize();
            }
            // Resize action-mask to icon game object
            var actionMask = this.childrenMap.actionMask;
            if (actionMask) {
                actionMask.resize();
            }
            return this;
        }
    }

    Object.assign(
        NameValueLabel.prototype,
        SetValueMethods,
    );

    ObjectFactory.register('nameValueLabel', function (config) {
        var gameObject = new NameValueLabel(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.NameValueLabel', NameValueLabel);

    class LevelCounter extends EventEmitter {
        constructor(config) {
            super();

            this.setTable(GetValue$3U(config, 'table'));
            this.setMaxLevel(GetValue$3U(config, 'maxLevel'));

            var exp = GetValue$3U(config, 'exp', 0);
            var level = GetValue$3U(config, 'level', undefined);
            if ((level !== undefined) && !this.checkLevel(level, exp)) {
                console.error(`Level ${level} and Exp ${exp} are mismatch`);
                level = undefined;
            }
            this.resetExp(exp, level);
        }

        // Configuration
        setTable(table) {
            this.levelTable = table;
            this.isLevelMapFunction = IsFunction(table);
            return this;
        }

        setMaxLevel(maxLevel) {
            if (maxLevel === undefined) {
                if (Array.isArray(this.levelTable)) {
                    maxLevel = this.levelTable.length - 1;
                } else {
                    maxLevel = -1;
                }
            }

            var maxExp;
            if (maxLevel !== -1) {
                maxExp = this.getExp(maxLevel);
            } else {
                maxExp = -1;
            }

            this.hasMaxLevel = (maxLevel !== -1);
            this.maxLevel = maxLevel;
            this.maxExp = maxExp;
            return this;
        }

        resetExp(exp, level) {
            if (this.hasMaxLevel && (exp > this.maxExp)) {
                exp = this.maxExp;
            }
            if (level === undefined) {
                level = this.getLevel(exp);
            }
            this._exp = exp;
            this._level = level;
            this._requiredExp = this.getRequiredExpToNextLevel(level, exp);
            // Won't fire `levelup` event
            return this;
        }

        get exp() {
            return this._exp;
        }

        set exp(exp) {
            if (this.hasMaxLevel && (exp > this.maxExp)) {
                exp = this.maxExp;
            }

            if (exp < this._exp) {
                this.resetExp(exp);
                return;
            }
            if (exp === this._exp) {
                return;
            }

            var level = this.getLevel(exp, this._level);

            // Emit levelup event
            var prevLevel = this._level;
            var fromExp = this._exp,
                toExp;
            while (1) {
                var levelStartExp = this.getExp(prevLevel);
                var levelEndExp = this.getExp(prevLevel + 1);
                toExp = Math.min(levelEndExp, exp);
                this.emit('levelup', prevLevel, fromExp, toExp, levelStartExp, levelEndExp);

                if ((prevLevel === level) && (toExp === exp)) {
                    break;
                }

                prevLevel++;
                fromExp = levelEndExp;
            }

            this.resetExp(exp, level);
        }

        get level() {
            return this._level;
        }

        set level(value) {
            if (this.hasMaxLevel && (value > this.maxLevel)) {
                this.exp = this.maxExp;
            } else {
                this.exp = this.getExp(value);
            }
        }

        get requiredExp() {
            return this._requiredExp;
        }

        getExp(level) {
            if (level === undefined) {
                return this._exp;
            }

            if (this.isLevelMapFunction) {
                return this.levelTable(level);
            } else {
                if (this.hasMaxLevel && (level > this.maxLevel)) {
                    level = this.maxLevel;
                }
                return this.levelTable[level];
            }
        }

        getLevel(exp, level) {
            if (exp === undefined) {
                return this._level;
            }

            if (level === undefined) {
                level = 0;
            }

            while (1) {
                var nextLevelExp = this.getExp(level + 1);
                if (nextLevelExp > exp) {
                    break;
                }

                level++;

                if (this.hasMaxLevel && (nextLevelExp === this.maxExp)) {
                    break;
                }
            }

            return level;
        }

        getRequiredExpToNextLevel(level, exp) {
            if (level === undefined) {
                level = this.level;
            }
            if (exp === undefined) {
                exp = this.exp;
            }
            return this.getExp(level + 1) - exp;
        }

        checkLevel(level, exp) {
            return (exp >= this.getExp(level)) && (exp < this.getExp(level + 1));
        }

        gainExp(incExp, callback, scope) {
            if (callback) {
                this.on('levelup', callback, scope);
            }

            this.exp += incExp;

            if (callback) {
                this.off('levelup', callback, scope);
            }
            return this;
        }

        setExp(exp, callback, scope) {
            if (callback) {
                this.on('levelup', callback, scope);
            }

            this.exp = exp;

            if (callback) {
                this.off('levelup', callback, scope);
            }
            return this;
        }

        setLevel(level, callback, scope) {
            if (callback) {
                this.on('levelup', callback, scope);
            }

            this.level = level;

            if (callback) {
                this.off('levelup', callback, scope);
            }
            return this;
        }
    }

    var RunCommands = function (queue, scope, config) {
        var reverse = GetValue$3U(config, 'reverse', false);

        var retVal;
        if (IsArray(queue[0])) {
            if (!reverse) {
                for (var i = 0, len = queue.length; i < len; i++) {
                    retVal = RunCommands(queue[i], scope, config);
                }
            } else {
                for (var len = queue.length, i = len - 1; i >= 0; i--) {
                    retVal = RunCommands(queue[i], scope, config);
                }
            }
        } else {
            retVal = RunCommand(queue, scope, config);
        }

        return retVal;
    };

    var RunCommand = function (cmd, scope, config) {
        var argsConvert = GetValue$3U(config, 'argsConvert', undefined);
        var argsConvertScope = GetValue$3U(config, 'argsConvertScope', undefined);

        var fnName = cmd[0];

        ARGS = Copy(ARGS, cmd, 1);
        if (argsConvert) {
            // convert string to floating number, boolean, null, or string        
            if (argsConvert === true) {
                argsConvert = TypeConvert;
                argsConvertScope = undefined;
            }
            for (var i = 0, len = ARGS.length; i < len; i++) {
                if (argsConvertScope) {
                    ARGS[i] = argsConvert.call(argsConvertScope, ARGS[i], cmd);
                } else {
                    ARGS[i] = argsConvert(ARGS[i], cmd);
                }
            }
        }

        var fn;
        if (typeof (fnName) === 'string') {
            fn = scope[fnName];
            if (fn == null) {
                fn = GetValue$3U(scope, fnName, null);
            }
        } else {
            fn = fnName;
        }

        var retValue = fn.apply(scope, ARGS);
        return retValue;
    };
    var ARGS = []; // reuse this array

    const GetValue$1t = Phaser.Utils.Objects.GetValue;

    class Player extends ComponentBase {
        constructor(parent, config) {
            super(parent, config);

            var clock = GetValue$1t(config, 'clock', undefined);
            if (!clock) {
                clock = new Clock(parent);
            }
            this.clock = clock;
            this.clock.on('update', this.update, this);

            this.commands = [];

            this.resetFromJSON(config); // this function had been called in super(config)
        }

        resetFromJSON(o) {
            this.clock.resetFromJSON(GetValue$1t(o, 'clock', undefined));
            this.state = GetValue$1t(o, 'state', 0); // 0=idle, 1=run, 2=completed
            this.commands = GetValue$1t(o, 'commands', []); // [[time, cmds], [time, cmds], ...]
            this.scope = GetValue$1t(o, 'scope', undefined);
            this.setTimeUnit(GetValue$1t(o, 'timeUnit', 0));
            this.setDtMode(GetValue$1t(o, 'dtMode', 0));
            this.index = GetValue$1t(o, 'index', 0);
            this.nextTime = GetValue$1t(o, 'nextTime', 0);
            return this;
        }

        toJSON() {
            return {
                clock: this.clock.toJSON(),
                state: this.state,
                commands: this.commands,
                scope: this.scope,
                timeUnit: this.timeUnit,
                dtMode: this.dtMode,
                index: this.index,
                nextTime: this.nextTime
            };
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            this.clock.shutdown(fromScene);
            this.commands = undefined;

            super.shutdown(fromScene);
        }

        load(commands, scope, config) {
            this.stop();
            var timeUnit = GetValue$1t(config, 'timeUnit', undefined);
            if (timeUnit !== undefined) {
                this.setTimeUnit(timeUnit);
            }
            var dtMode = GetValue$1t(config, 'dtMode', undefined);
            if (dtMode !== undefined) {
                this.setDtMode(dtMode);
            }
            commands = commands
                .filter(function (item) {
                    var dt = item[0];
                    return !isNaN(dt);
                })
                .map(function (item) {
                    var dt = item[0];
                    if (typeof (dt) === 'string') {
                        item[0] = parseFloat(item[0]);
                    }
                    return item;
                });

            if (this.dtMode === 0) {
                commands.sort(function (itemA, itemB) {
                    var dtA = itemA[0],
                        dtB = itemB[0];
                    return (dtA > dtB) ? 1 :
                        (dtA < dtB) ? -1 : 0;
                });
            }

            Copy(this.commands, commands);
            this.scope = scope;
            return this;
        }

        clear() {
            this.commands.length = 0;
            return this;
        }

        append(time, fn, ...params) {
            var command;
            if (Array.isArray(fn)) {
                command = fn;
            } else {
                command = [fn, ...params];
            }
            this.commands.push([time, command]);
            return this;
        }

        start(startAt) {
            if (startAt === undefined) {
                startAt = 0;
            }

            this.stop();

            this.index = 0;
            this.state = 1;
            this.nextTime = this.getNextDt(0);

            this.clock.start(startAt);
            this.update(startAt);
            this.emit('start', this.parent, this);
            return this;
        }

        pause() {
            this.clock.pause();
            this.emit('pause', this.parent, this);
            return this;
        }

        resume() {
            this.clock.resume();
            this.emit('resume', this.parent, this);
            return this;
        }

        stop() {
            this.clock.stop();
            this.state = 0;
            this.emit('stop', this.parent, this);
            return this;
        }

        seek(time) {
            this.clock.seek(time);
            return this;
        }

        seekToNext() {
            this.seek(this.nextTime);
            return this;
        }

        get isPlaying() {
            return this.clock.isRunning;
        }

        get completed() {
            return (this.state === 2);
        }

        get timeScale() {
            return this.clock.timeScale;
        }

        set timeScale(timeScale) {
            this.clock.timeScale = timeScale;
        }

        setTimeScale(timeScale) {
            this.timeScale = timeScale;
            return this;
        }

        get now() {
            return this.clock.now;
        }

        update(now) {
            if (this.nextTime > now) {
                return this;
            }

            var commands = this.commands;

            while (1) {
                // Execute a command
                var item = commands[this.index];
                var command = item[1];
                if (!IsArray(command)) { // [dt, fnName, param0, param1, ...]
                    command = Copy(CMD, item, 1);
                }
                RunCommands(command, this.scope);
                this.emit('runcommand', command, this.scope);
                // Execute a command

                if (this.index >= (commands.length - 1)) {
                    this.nextTime = 0;
                    this.complete();
                    return this;
                } else {
                    // Get next time
                    this.index++; // Point to next command
                    this.nextTime = this.getNextDt(this.nextTime);
                    if (this.nextTime > now) {
                        return this;
                    }
                    // Get next time
                }

            }
        }

        complete() {
            this.clock.stop();
            this.state = 2;
            this.emit('complete', this.parent, this);
        }

        getNextDt(currentDt) {
            var time = this.commands[this.index][0];
            if (this.timeUnit === 1) { // Second mode
                time = time * 1000;
            }

            if (this.dtMode === 1) {
                time += currentDt;
            }

            return time;
        }

        setDtMode(dtMode) {
            if (typeof (dtMode) === 'string') {
                dtMode = DTMODE[dtMode];
            }
            this.dtMode = dtMode;
            return this;
        }

        setTimeUnit(timeUnit) {
            if (typeof (timeUnit) === 'string') {
                timeUnit = TIMEUNITMODE[timeUnit];
            }
            this.timeUnit = timeUnit;
            return this;
        }
    }

    var CMD = []; // reuse this array

    const TIMEUNITMODE = {
        ms: 0,
        s: 1,
        sec: 1,
    };

    const DTMODE = {
        abs: 0,
        absolute: 0,
        inc: 1,
        increment: 1
    };

    var OnLevelUp = function (level, fromExp, toExp, levelStartExp, levelEndExp) {
        var time = ((toExp - fromExp) / (levelEndExp - levelStartExp)) * this.totalEaseDuration;
        var levelEnd = (toExp === levelEndExp) ? (level + 1) : level;

        this.player
            //.append(0, this.setValue, fromExp, levelStartExp, levelEndExp)
            .append(0, this.setEaseValueDuration, time)
            .append(0, this.easeValueTo, toExp, levelStartExp, levelEndExp)
            .append(0, this.emit, 'levelup.start', level, fromExp, toExp, this)
            .append(time, NOOP)
            .append(0, this.emit, 'levelup.end', levelEnd, fromExp, toExp, this);

        if (!this.player.isPlaying) {
            this.player.start();
        }
    };

    var ExpMethods = {
        setExpTable(table) {
            this.levelCounter.setTable(table);
            return this;
        },

        resetExp(exp) {
            this.levelCounter.resetExp(exp);
            this.setValue(this.exp, this.getExp(this.level), this.getExp(this.level + 1));
            return this;
        },

        getExp(level) {
            return this.levelCounter.getExp(level);
        },

        getLevel(exp, level) {
            return this.levelCounter.getLevel(exp, level);
        },

        getRequiredExpToNextLevel(level, exp) {
            return this.levelCounter.getRequiredExpToNextLevel(level, exp);
        },

        gainExp(exp) {
            this.levelCounter.gainExp(exp);
            return this;
        },

        setExp(exp) {
            this.levelCounter.setExp(exp);
            return this;
        },

        setLevel(level) {
            this.levelCounter.setLevel(level);
            return this;
        }
    };

    const GetValue$1s = Phaser.Utils.Objects.GetValue;

    class ExpBar extends NameValueLabel {
        constructor(scene, config) {
            super(scene, config);

            this.type = 'rexExpBar';

            this.setTotalEaseDuration(GetValue$1s(config, 'easeDuration', 1000));

            this.levelCounter = new LevelCounter(GetValue$1s(config, 'levelCounter'));

            this.player = new Player(this, {
                scope: this,
                dtMode: 1
            });

            this.levelCounter.on('levelup', OnLevelUp, this);

            this.player.on('complete', function () {
                this.player.clear();
                this.emit('levelup.complete', this.level, this);
            }, this);

            this.setValue(this.exp, this.getExp(this.level), this.getExp(this.level + 1));
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.levelCounter.destroy();
            this.levelCounter = undefined;

            this.player.destroy();
            this.player = undefined;

            super.destroy(fromScene);
        }

        get exp() {
            return this.levelCounter.exp;
        }

        set exp(value) {
            this.levelCounter.exp = value;
        }

        get level() {
            return this.levelCounter.level;
        }

        set level(value) {
            this.levelCounter.level = value;
        }

        get requiredExp() {
            return this.levelCounter.requiredExp;
        }

        setTotalEaseDuration(duration) {
            this.totalEaseDuration = duration;
            return this;
        }
    }

    Object.assign(
        ExpBar.prototype,
        ExpMethods
    );

    ObjectFactory.register('expBar', function (config) {
        var gameObject = new ExpBar(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ExpBar', ExpBar);

    const SizerAdd$3 = Sizer.prototype.add;
    const SizerAddSpace = Sizer.prototype.addSpace;

    var Add$2 = function (gameObject) {
        var isNormalGameObject = !gameObject.isRexSpace;
        var proportion = (!isNormalGameObject || this.buttonsExpand) ? 1 : 0;

        if (this.sizerChildren.length === 0) {  // First element
            if (isNormalGameObject) {
                // Add space at head
                var hasHeadSpace = (!this.buttonsExpand) &&
                    ((this.buttonsAlign === 'right') || (this.buttonsAlign === 'center') || (this.buttonsAlign === 'bottom'));
                if (hasHeadSpace) {
                    SizerAddSpace.call(this);
                }

                SizerAdd$3.call(this,
                    gameObject,
                    { proportion: proportion, expand: true }
                );

                // Add space at tail
                var hasTailSpace = (!this.buttonsExpand) && (this.buttonsAlign === 'center');
                if (hasTailSpace) {
                    SizerAddSpace.call(this);
                }
                this.hasTailSpace = hasTailSpace;

            } else { // A space
                SizerAdd$3.call(this,
                    gameObject,
                    { proportion: proportion, expand: true }
                );
                this.hasTailSpace = false;

            }

        } else {   // Others
            if (this.hasTailSpace) {
                var lastIndex = this.sizerChildren.length - 1;
                SizerAdd$3.call(this,
                    gameObject,
                    { index: lastIndex, proportion: proportion, expand: true }
                );

            } else {
                SizerAdd$3.call(this,
                    gameObject,
                    { proportion: proportion, expand: true }
                );
            }

        }

        // Space or other game object as button
        if (isNormalGameObject) {
            this.buttonGroup.add(gameObject);
        }

        return this;
    };

    var AddChildMethods$3 = {
        addButton(gameObject) {
            if (IsArray(gameObject)) {
                var gameObjects = gameObject;
                for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                    Add$2.call(this, gameObjects[i]);
                }
            } else {
                Add$2.call(this, gameObject);
            }
            return this;
        },

        addButtons(gameObjects) {
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Add$2.call(this, gameObjects[i]);
            }
            return this;
        }
    };

    const SizerRmove$2 = Sizer.prototype.remove;
    const SizerClear$2 = Sizer.prototype.clear;

    var Remove$3 = function (gameObject, destroyChild) {
        if (this.getParentSizer(gameObject) !== this) {
            return this;
        }

        this.buttonGroup.remove(gameObject);
        SizerRmove$2.call(this, gameObject, destroyChild);
        return this;
    };

    var RemoveChildMethods$2 = {
        remove(gameObject, destroyChild) {
            // Remove gameObject no matter it is a button or not
            if (IsArray(gameObject)) {
                var gameObjects = gameObject;
                for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                    Remove$3.call(this, gameObjects[i], destroyChild);
                }
            } else {
                Remove$3.call(this, gameObject, destroyChild);
            }
            return this;
        },

        clear(destroyChild) {
            var buttons = this.buttonGroup.buttons;
            buttons.length = 0;
            SizerClear$2.call(this, destroyChild);
            return this;
        },

        removeButton(gameObject, destroyChild) {
            var gameObject = this.getButton(gameObject);
            // Don't remove this gameObject, it is not a button
            if (!gameObject) {
                return this;
            }
            this.remove(gameObject, destroyChild);
            return this;
        },

        clearButtons(destroyChild) {
            var buttons = this.buttonGroup.buttons;
            for (var i = buttons.length - 1; i >= 0; i--) {
                Remove$3.call(this, buttons[i], destroyChild);
            }
            return this;
        }
    };

    var OnButtonStateChange = function (button, value, previousValue) {
        if (!button) {
            return;
        }

        var callback = this.setValueCallback;
        var scope = this.setValueCallbackScope;
        if (callback) {
            if (scope) {
                callback.call(scope, button, value, previousValue);
            } else {
                callback(button, value, previousValue);
            }
        }

        this.fireEvent('button.statechange', button, value, previousValue);
    };

    var InjectSelectedProperty = function (gameObject) {
        var self = this;

        gameObject._selected = undefined;
        Object.defineProperty(gameObject, 'selected', {
            get: function () {
                return gameObject._selected;
            },
            set: function (newValue) {
                if (gameObject._selected === newValue) {
                    return;
                }
                var previousValue = gameObject._selected;
                gameObject._selected = newValue;

                OnButtonStateChange.call(self, gameObject, newValue, previousValue);
            },
            enumerable: true,
            configurable: true
        });

        gameObject.selected = false;
    };

    var AddMethods = {
        add(gameObject) {
            this.buttons.push(gameObject);

            //Default: Fire 'click' event when touch released after pressed.
            if (!gameObject._click) {
                gameObject._click = new Button(gameObject, this.clickConfig);

                gameObject._click
                    .on('click', function (buttonBehavior, gameObject, pointer, event) {
                        this.fireEvent('button.click', gameObject, pointer, event);
                    }, this)
                    .on('enable', function (buttonBehavior, gameObject) {
                        this.fireEvent('button.enable', gameObject);
                    }, this)
                    .on('disable', function (buttonBehavior, gameObject) {
                        this.fireEvent('button.disable', gameObject);
                    }, this)


                    .on('over', function (buttonBehavior, gameObject, pointer, event) {
                        this.fireEvent('button.over', gameObject, pointer, event);
                    }, this)
                    .on('out', function (buttonBehavior, gameObject, pointer, event) {
                        this.fireEvent('button.out', gameObject, pointer, event);
                    }, this)

                    .on('down', function (buttonBehavior, gameObject, pointer, event) {
                        this.fireEvent('button.down', gameObject, pointer, event);
                    }, this)
                    .on('up', function (buttonBehavior, gameObject, pointer, event) {
                        this.fireEvent('button.up', gameObject, pointer, event);
                    }, this);

                if (gameObject.isRexContainerLite) {
                    // Send touch detection sensor to back
                    gameObject.sendChildToBack(gameObject);
                }
            }

            if (this.buttonsType) {
                if (gameObject.name === undefined) {
                    console.error(`${this.parent.constructor.name}: Option button miss value`);
                }

                InjectSelectedProperty.call(this, gameObject);
            }


            return this;
        },

        addMultiple(gameObjects) {
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                this.add(gameObjects[i]);
            }
            return this;
        }
    };

    const RemoveItem = Phaser.Utils.Array.Remove;

    var RemoveMethods = {
        remove(gameObject) {
            if (this.buttonsType) {
                delete gameObject.selected;
            }

            RemoveItem(this.buttons, gameObject);

            return this;
        },

        clear() {
            if (this.buttonsType) {
                var buttons = this.buttons;
                for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                    delete buttons[i].selected;
                }
            }

            this.buttons.length = 0;

            return this;
        }
    };

    var FireEvent = function (eventName, button, ...args) {
        if(!this.buttons) {
            // ButtonGroup has been destroyed
            return;
        }

        var index;
        if (typeof (button) === 'number') {
            index = button;
            button = this.buttons[index];
            if (!button) {
                return;
            }
        } else {
            index = this.buttons.indexOf(button);
            if (index === -1) {
                return;
            }
        }

        // Buttons is a child. Fire internal events.
        if (this.eventEmitter !== this.parent) {
            this.parent.emit(eventName, button, index, ...args);
        }

        if (this.groupName !== undefined) {
            this.eventEmitter.emit(eventName, button, this.groupName, index, ...args);
        } else {
            this.eventEmitter.emit(eventName, button, index, ...args);
        }
    };

    const GetValue$1r = Phaser.Utils.Objects.GetValue;

    var ButtonsTypeMethods = {
        setButtonsType(config) {
            if (config === undefined) {
                config = {};
            }

            var buttonsType = GetValue$1r(config, 'buttonsType', config.type);
            this.buttonsType = buttonsType;

            if (!this.buttonsType) {
                return this;
            }

            // Assign this.setValueCallback, this.setValueCallbackScope
            var setValueCallback, setValueCallbackScope;
            setValueCallback = GetValue$1r(config, 'setValueCallback', undefined);
            setValueCallbackScope = GetValue$1r(config, 'setValueCallbackScope', undefined);
            if (setValueCallback === undefined) {
                setValueCallback = GetValue$1r(config, 'setButtonStateCallback', undefined);
                setValueCallbackScope = GetValue$1r(config, 'setButtonStateCallbackScope', undefined);
            }
            this.setValueCallback = setValueCallback;
            this.setValueCallbackScope = setValueCallbackScope;

            switch (buttonsType) {
                case 'radio':
                    this.setRadioType();
                    break;
                case 'checkboxes':
                    this.setCheckboxesType();
                    break;
            }

            return this;
        },

        setRadioType() {
            var parent = this.parent,
                buttons = this.buttons;
            parent._value = undefined;
            var selectedIndex = undefined;
            Object.defineProperty(parent, 'value', {
                get: function () {
                    return parent._value;
                },
                set: function (newValue) {
                    if (parent._value === newValue) {
                        return;
                    }

                    parent._value = newValue;

                    for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                        var button = buttons[i];
                        if (button.rexSizer.hidden) {
                            continue;
                        }

                        if (selectedIndex === undefined) {
                            if (button.name === newValue) {
                                button.selected = true;
                            } else {
                                button.selected = false;
                            }
                        } else {
                            if (selectedIndex === i) {
                                button.selected = true;
                            } else {
                                button.selected = false;
                            }
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            parent.on('button.click', function (button) {
                selectedIndex = this.buttons.indexOf(button);
                parent.value = button.name;
                selectedIndex = undefined;
            }, this);

            return this;
        },

        setCheckboxesType() {
            var parent = this.parent;
            parent.on('button.click', function (button) {
                button.selected = !button.selected;
            });

            return this;
        },

        // Common
        clearAllButtonsState() {
            var buttons = this.buttons;
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                var button = buttons[i];
                button.selected = false;
            }
            return this;
        },

        getAllButtonsState() {
            var states = {};
            var buttons = this.buttons;
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                var button = buttons[i];
                if (button.rexSizer.hidden) {
                    continue;
                }
                states[button.name] = button.selected;
            }
            return states;
        },

        // For radio
        setSelectedButtonName(name) {
            this.parent.value = name;
            return this;
        },

        getSelectedButtonName() {
            return this.parent.value;
        },

        // For checkboxes
        setButtonState(name, state) {
            if (state === undefined) {
                state = true;
            }

            var buttons = this.buttons;
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                var button = buttons[i];
                if (button.rexSizer.hidden) {
                    continue;
                }
                if (button.name === name) {
                    button.selected = state;
                    break;
                }
            }
            return this;
        },

        getButtonState(name) {
            var buttons = this.buttons;
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                var button = buttons[i];
                if (button.rexSizer.hidden) {
                    continue;
                }
                if (button.name === name) {
                    return button.selected;
                }
            }
            return undefined;
        }
    };

    var GetGameObjectByName = function (children, name) {
        if (!children) {
            return null;

        } else if (IsArray(children)) {
            var child;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                child = TestName(children[i], name);
                if (child) {
                    return child;
                }
            }

        } else { // Is plain object
            var child;
            for (var key in children) {
                child = TestName(children[key], name);
                if (child) {
                    return child;
                }
            }

        }
    };

    var TestName = function (gameObject, name) {
        if (!gameObject) {
            return null;
        } else if (gameObject.hasOwnProperty('name')) {
            return (gameObject.name === name) ? gameObject : null;
        } else { // Array, or plain object
            return GetElementByName(gameObject, name);
        }
    };

    // Include in ButtonGroup class and Buttons/GridButtons/FixedWidthButtons class


    var ButtonMethods$2 = {
        getButton(index) {
            // buttonGroup and button-sizer have *buttons* member both
            var buttons = this.buttons,
                button;
            var indexType = typeof (index);
            switch (indexType) {
                case 'number':
                    button = buttons[index];
                    break;
                case 'string':
                    button = GetGameObjectByName(buttons, index);
                    break;
                default:
                    button = index;
                    if (buttons.indexOf(button) === -1) {
                        button = undefined;
                    }
                    break;
            }
            return button;
        },

        getButtons() {
            return this.buttons;
        },

        hasAnyButton() {
            return this.buttons.length > 0;
        },

        setButtonEnable(index, enabled) {
            // buttonGroup and button-sizer have *buttons* member both
            var buttons = this.buttons;
            if ((index === undefined) || (typeof (index) === 'boolean')) {
                enabled = index;
                for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                    buttons[i]._click.setEnable(enabled);
                }
            } else {
                this.getButton(index)._click.setEnable(enabled);
            }
            return this;
        },

        toggleButtonEnable(index) {
            // buttonGroup and button-sizer have *buttons* member both
            var buttons = this.buttons;
            if ((index === undefined) || (typeof (index) === 'boolean')) {
                for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                    buttons[i]._click.toggleEnable();
                }
            } else {
                this.getButton(index)._click.toggleEnable();
            }
            return this;
        },

        getButtonEnable(index) {
            if (index === undefined) {
                index = 0;
            }
            return this.getButton(index)._click.enable;
        },

        emitButtonClick(index) {
            // index or button game object
            // this: buttonGroup or button-sizer
            var buttonGroup = (this.buttonGroup) ? this.buttonGroup : this;
            buttonGroup.fireEvent('button.click', index);
            return this;
        },

        emitButtonOver(index) {
            // this: buttonGroup or button-sizer
            var buttonGroup = (this.buttonGroup) ? this.buttonGroup : this;

            var buttons = this.buttons;

            // Fire 'button.out' of overed button(s)
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                var button = buttons[i];
                if (!button._click.isOver) {
                    continue;
                }
                button._click.isOver = false;
                buttonGroup.fireEvent('button.out', button);
            }

            // Fire 'button.over'
            var button = this.getButton(index);
            if (button) {
                button._click.isOver = true;
                buttonGroup.fireEvent('button.over', button);
            }

            return this;
        },

        showButton(index) {
            Show(this.getButton(index));
            return this;
        },

        hideButton(index) {
            Hide(this.getButton(index));
            return this;
        },

        isButtonShown(index) {
            IsShown(this.getButton(index));
            return this;
        },

        forEachButtton(callback, scope) {
            // buttonGroup and button-sizer have *buttons* member both
            var buttons = this.buttons;
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                if (scope) {
                    callback.call(scope, buttons[i], i, buttons);
                } else {
                    callback(buttons[i], i, buttons);
                }
            }
            return this;
        },


    };

    class ButtonGroup {
        constructor(config) {
            this.parent = config.parent;
            this.eventEmitter = config.eventEmitter;
            this.groupName = config.groupName;
            this.clickConfig = config.clickConfig;

            this.buttonsType = undefined;
            this.buttons = [];
        }

        destroy() {
            this.parent = undefined;
            this.eventEmitter = undefined;
            this.clickConfig = undefined;
            this.buttons = undefined; // GameObjects will be destroyed outside
        }
    }

    var methods$h = {
        fireEvent: FireEvent
    };

    Object.assign(
        ButtonGroup.prototype,
        AddMethods,
        RemoveMethods,
        ButtonsTypeMethods,
        ButtonMethods$2,
        methods$h
    );

    // Include in Buttons/GridButtons/FixedWidthButtons class

    var ButtonStateMethods = {
        // Common
        clearAllButtonsState() {
            this.buttonGroup.clearAllButtonsState();
            return this;
        },

        getAllButtonsState() {
            return this.buttonGroup.getAllButtonsState();
        },

        // For radio
        setSelectedButtonName(name) {
            this.buttonGroup.setSelectedButtonName(name);
            return this;
        },

        getSelectedButtonName() {
            return this.buttonGroup.getSelectedButtonName();
        },

        // For checkboxes
        setButtonState(name, state) {
            this.buttonGroup.setButtonState(name, state);
            return this;
        },

        getButtonState(name) {
            return this.buttonGroup.getButtonState(name);
        }
    };

    const GetValue$1q = Phaser.Utils.Objects.GetValue;

    let Buttons$1 = class Buttons extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            var buttonSpace = config.space;
            if (typeof (buttonSpace) === 'number') {
                config.space = { item: buttonSpace };
            }

            // Create
            super(scene, config);
            this.type = 'rexButtons';
            this.buttonGroup = new ButtonGroup({
                parent: this,
                eventEmitter: GetValue$1q(config, 'eventEmitter', this),
                groupName: GetValue$1q(config, 'groupName', undefined),
                clickConfig: GetValue$1q(config, 'click', undefined)
            })
                .setButtonsType(config);

            // Add elements
            var background = GetValue$1q(config, 'background', undefined);
            var buttons = GetValue$1q(config, 'buttons', undefined);

            // Buttons properties
            this.buttonsExpand = GetValue$1q(config, 'expand', false);
            this.buttonsAlign = GetValue$1q(config, 'align', undefined); // undefined/left/top: no space                

            if (background) {
                this.addBackground(background);
            }

            if (buttons) {
                this.addButtons(buttons);
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('buttons', this.buttonGroup.buttons);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            super.destroy(fromScene);
            this.buttonGroup.destroy();
            this.buttonGroup = undefined;
        }

        get buttons() {
            return this.buttonGroup.buttons;
        }

        get groupName() {
            return this.buttonGroup.groupName;
        }

        set groupName(value) {
            this.buttonGroup.groupName = value;
        }

        get eventEmitter() {
            return this.buttonGroup.eventEmitter;
        }
    };

    Object.assign(
        Buttons$1.prototype,
        AddChildMethods$3,
        RemoveChildMethods$2,
        ButtonMethods$2,
        ButtonStateMethods
    );

    ObjectFactory.register('buttons', function (config) {
        var gameObject = new Buttons$1(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Buttons', Buttons$1);

    const SizerAdd$2 = GridSizer.prototype.add;

    var AddChildMethods$2 = {
        addButton(gameObject, columnIndex, rowIndex) {
            SizerAdd$2.call(this, gameObject, columnIndex, rowIndex, undefined, 0, this.buttonsExpand);
            this.buttonGroup.add(gameObject);
            return this;
        },

        addButtons(gameObjects, rowThenColumn) {
            for (var i = 0, cnt = gameObjects; i < cnt; i++) {
                this.addButton(gameObjects[i], undefined, rowThenColumn);
            }
            return this;
        }
    };

    const SizerRmove$1 = GridSizer.prototype.remove;
    const SizerClear$1 = GridSizer.prototype.clear;

    var Remove$2 = function (gameObject, destroyChild) {
        var gameObject = this.getButton(gameObject);
        if (!gameObject) {
            return this;
        }

        this.buttonGroup.remove(gameObject);
        SizerRmove$1.call(this, gameObject, destroyChild);
        return this;
    };

    var RemoveChildMethods$1 = {
        remove(gameObject, destroyChild) {
            if (IsArray(gameObject)) {
                var gameObjects = gameObject;
                for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                    Remove$2.call(this, gameObjects[i], destroyChild);
                }
            } else {
                Remove$2.call(this, gameObject, destroyChild);
            }
            return this;
        },

        clear(destroyChild) {
            var buttons = this.buttonGroup.buttons;
            buttons.length = 0;
            SizerClear$1.call(this, destroyChild);
            return this;
        },

        removeButton(gameObject, destroyChild) {
            this.remove(gameObject, destroyChild);
            return this;
        },

        clearButtons(destroyChild) {
            var buttons = this.buttonGroup.buttons;
            for (var i = buttons.length - 1; i >= 0; i--) {
                Remove$2.call(this, buttons[i], destroyChild);
            }
            return this;
        }
    };

    const GetValue$1p = Phaser.Utils.Objects.GetValue;

    class GridButtons extends GridSizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            var rowCount = GetValue$1p(config, 'row', 0);
            var columnCount = GetValue$1p(config, 'column', (config.col || 0));
            var createCellContainerCallback = GetValue$1p(config, 'createCellContainerCallback');
            var buttons = GetValue$1p(config, 'buttons', undefined);
            var buttonsExpand = GetValue$1p(config, 'expand', true);
            var buttonProportion = (buttonsExpand) ? 1 : 0;

            if (createCellContainerCallback) {
                config.createCellContainerCallback = undefined;
            }
            if (buttons !== undefined) {
                rowCount = Math.max(rowCount, buttons.length);
                for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                    columnCount = Math.max(columnCount, buttons[i].length);
                }
            }

            config.row = rowCount;
            config.column = columnCount;
            config.columnProportions = buttonProportion;
            config.rowProportions = buttonProportion;

            // Create
            super(scene, config);
            this.type = 'rexGridButtons';
            this.buttonGroup = new ButtonGroup({
                parent: this,
                eventEmitter: GetValue$1p(config, 'eventEmitter', this),
                groupName: GetValue$1p(config, 'groupName', undefined),
                clickConfig: GetValue$1p(config, 'click', undefined)
            })
                .setButtonsType(config);

            // Add elements
            var background = GetValue$1p(config, 'background', undefined);

            // Buttons properties
            this.buttonsExpand = buttonsExpand;
            GetValue$1p(config, 'space', undefined);

            if (background) {
                this.addBackground(background);
            }

            if (buttons) {
                var rowButtons, button;
                for (var r = 0, rcnt = buttons.length; r < rcnt; r++) { // row
                    rowButtons = buttons[r];
                    for (var c = 0, ccnt = rowButtons.length; c < ccnt; c++) { // col
                        button = rowButtons[c];
                        if (button) {
                            this.addButton(button, c, r);
                        }
                    }
                }
            } else if (createCellContainerCallback) {
                for (var y = 0; y < rowCount; y++) {
                    for (var x = 0; x < columnCount; x++) {
                        var button = createCellContainerCallback(scene, x, y);
                        if (button) {
                            this.addButton(button, x, y);
                        }
                    }
                }
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('buttons', this.buttonGroup.buttons);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            super.destroy(fromScene);
            this.buttonGroup.destroy();
            this.buttonGroup = undefined;
        }

        get buttons() {
            return this.buttonGroup.buttons;
        }

        get groupName() {
            return this.buttonGroup.groupName;
        }

        set groupName(value) {
            this.buttonGroup.groupName = value;
        }

        get eventEmitter() {
            return this.buttonGroup.eventEmitter;
        }
    }

    Object.assign(
        GridButtons.prototype,
        AddChildMethods$2,
        RemoveChildMethods$1,
        ButtonMethods$2,
        ButtonStateMethods
    );

    ObjectFactory.register('gridButtons', function (config) {
        var gameObject = new GridButtons(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.GridButtons', GridButtons);

    const SizerAdd$1 = FixWidthSizer.prototype.add;

    var Add$1 = function (gameObject) {
        SizerAdd$1.call(this, gameObject);
        this.buttonGroup.add(gameObject);
        return this;
    };

    var AddChildMethods$1 = {
        addButton(gameObject) {
            if (IsArray(gameObject)) {
                var gameObjects = gameObject;
                for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                    Add$1.call(this, gameObjects[i]);
                }
            } else {
                Add$1.call(this, gameObject);
            }
            return this;
        },

        addButtons(gameObjects) {
            if (IsArray(gameObjects[0])) {
                // 2d array
                var lines = gameObjects, line;
                for (var lineIdx = 0, lastLineIdx = (lines.length - 1); lineIdx <= lastLineIdx; lineIdx++) {
                    line = lines[lineIdx];
                    for (var i = 0, cnt = line.length; i < cnt; i++) {
                        Add$1.call(this, line[i]);
                    }
                    if (lineIdx > lastLineIdx) {
                        SizerAdd$1.addNewLine(this);
                    }
                }
            } else {
                // 1d array
                for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                    Add$1.call(this, gameObjects[i]);
                }
            }
            return this;
        }
    };

    const SizerRmove = FixWidthSizer.prototype.remove;
    const SizerClear = FixWidthSizer.prototype.clear;

    var Remove$1 = function (gameObject, destroyChild) {
        var gameObject = this.getButton(gameObject);
        if (!gameObject) {
            return this;
        }

        this.buttonGroup.remove(gameObject);    
        SizerRmove.call(this, gameObject, destroyChild);
        return this;
    };

    var RemoveChildMethods = {
        remove(gameObject, destroyChild) {
            if (IsArray(gameObject)) {
                var gameObjects = gameObject;
                for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                    Remove$1.call(this, gameObjects[i], destroyChild);
                }
            } else {
                Remove$1.call(this, gameObject, destroyChild);
            }
            return this;
        },

        clear(destroyChild) {
            var buttons = this.buttonGroup.buttons;
            buttons.length = 0;
            SizerClear.call(this, destroyChild);
            return this;
        },

        removeButton(gameObject, destroyChild) {
            this.remove(gameObject, destroyChild);
            return this;
        },

        clearButtons(destroyChild) {
            var buttons = this.buttonGroup.buttons;
            for (var i = buttons.length - 1; i >= 0; i--) {
                Remove$1.call(this, buttons[i], destroyChild);
            }
            return this;
        }
    };

    const GetValue$1o = Phaser.Utils.Objects.GetValue;

    class Buttons extends FixWidthSizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            var buttonSpace = config.space;
            if (typeof (buttonSpace) === 'number') {
                config.space = { item: buttonSpace, line: buttonSpace };
            }

            // Create
            super(scene, config);
            this.type = 'rexFixWidthButtons';
            this.buttonGroup = new ButtonGroup({
                parent: this,
                eventEmitter: GetValue$1o(config, 'eventEmitter', this),
                groupName: GetValue$1o(config, 'groupName', undefined),
                clickConfig: GetValue$1o(config, 'click', undefined)
            })
                .setButtonsType(config);

            // Add elements
            var background = GetValue$1o(config, 'background', undefined);
            var buttons = GetValue$1o(config, 'buttons', undefined);

            // Buttons properties
            this.buttonsAlign = GetValue$1o(config, 'align', undefined);

            if (background) {
                this.addBackground(background);
            }

            if (buttons) {
                this.addButtons(buttons);
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('buttons', this.buttonGroup.buttons);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            super.destroy(fromScene);
            this.buttonGroup.destroy();
            this.buttonGroup = undefined;
        }

        get buttons() {
            return this.buttonGroup.buttons;
        }

        get groupName() {
            return this.buttonGroup.groupName;
        }

        set groupName(value) {
            this.buttonGroup.groupName = value;
        }

        get eventEmitter() {
            return this.buttonGroup.eventEmitter;
        }
    }

    Object.assign(
        Buttons.prototype,
        AddChildMethods$1,
        RemoveChildMethods,
        ButtonMethods$2,
        ButtonStateMethods
    );

    ObjectFactory.register('fixWidthButtons', function (config) {
        var gameObject = new Buttons(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.FixWidthButtons', Buttons);

    var FileChooserMethods = {
        setAccept(accept) {
            this.childrenMap.fileChooser.setAccept(accept);
            return this;
        },

        setMultiple(enabled) {
            this.childrenMap.fileChooser.setMultiple(enabled);
            return this;
        },

        loadFile(file, loaderType, key, cacheType, onComplete) {
            this.childrenMap.fileChooser.loadFile(file, loaderType, key, cacheType, onComplete);
            return this;
        },

        loadFilePromise(file, loaderType, key, cacheType) {
            return this.childrenMap.fileChooser.loadFilePromise(file, loaderType, key, cacheType);
        }

    };

    const GetValue$1n = Phaser.Utils.Objects.GetValue;

    class FileSelectorButton extends Label {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexFileSelectorButton';

            var fileChooser = new FileChooser(scene);
            scene.add.existing(fileChooser);
            this.addBackground(fileChooser);

            this.addChildrenMap('fileChooser', fileChooser);

            this.setAccept(GetValue$1n(config, 'accept', ''));
            this.setMultiple(GetValue$1n(config, 'multiple', false));

            fileChooser
                .on('change', function (gameObject) {
                    var files = gameObject.files;
                    if (files.length === 0) {
                        return;
                    }

                    files = Array.from(files);
                    this.emit('select', files, this);
                }, this);

        }

        get files() {
            return this.childrenMap.fileChooser.files;
        }

    }

    Object.assign(
        FileSelectorButton.prototype,
        FileChooserMethods,
    );

    ObjectFactory.register('fileSelectorButton', function (config) {
        var gameObject = new FileSelectorButton(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.FileSelectorButton', FileSelectorButton);

    var ButtonMethods$1 = {
        getChoice(index) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                return choicesSizer.getButton(index);
            } else {
                return undefined;
            }
        },

        getAction(index) {
            return this.childrenMap.actionsSizer.getButton(index);
        },

        getToolbar(index) {
            return this.childrenMap.toolbarSizer.getButton(index);
        },

        getLeftToolbar(index) {
            return this.childrenMap.leftToolbarSizer.getButton(index);
        },

        setChoiceEnable(index, enabled) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.setButtonEnable(index, enabled);
            }
            return this;
        },

        setActionEnable(index, enabled) {
            this.childrenMap.actionsSizer.setButtonEnable(index, enabled);
            return this;
        },

        setToolbarEnable(index, enabled) {
            this.childrenMap.toolbarSizer.setButtonEnable(index, enabled);
            return this;
        },

        setLeftToolbarEnable(index, enabled) {
            this.childrenMap.leftToolbarSizer.setButtonEnable(index, enabled);
            return this;
        },

        toggleChoiceEnable(index) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.toggleButtonEnable(index);
            }
            return this;
        },

        toggleActionEnable(index) {
            this.childrenMap.actionsSizer.toggleButtonEnable(index);
            return this;
        },

        toggleToolbarEnable(index) {
            this.childrenMap.toolbarSizer.toggleButtonEnable(index);
            return this;
        },

        toggleLeftToolbarEnable(index) {
            this.childrenMap.leftToolbarSizer.toggleButtonEnable(index);
            return this;
        },

        getChoiceEnable(index) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                return choicesSizer.getButtonEnable(index);
            } else {
                return false;
            }
        },

        getActionEnable(index) {
            return this.childrenMap.actionsSizer.getButtonEnable(index);
        },

        getToolbarEnable(index) {
            return this.childrenMap.toolbarSizer.getButtonEnable(index);
        },

        getLeftToolbarEnable(index) {
            return this.childrenMap.leftToolbarSizer.getButtonEnable(index);
        },

        emitChoiceClick(index) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.emitButtonClick(index);
            }
            return this;
        },

        emitActionClick(index) {
            this.childrenMap.actionsSizer.emitButtonClick(index);
            return this;
        },

        emitToolbarClick(index) {
            this.childrenMap.toolbarSizer.emitButtonClick(index);
            return this;
        },

        emitLeftToolbarClick(index) {
            this.childrenMap.leftToolbarSizer.emitButtonClick(index);
            return this;
        },

        showChoice(index) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.showButton(index);
            }
            return this;
        },

        showAction(index) {
            this.childrenMap.actionsSizer.showButton(index);
            return this;
        },

        showToolbar(index) {
            this.childrenMap.toolbarSizer.showButton(index);
            return this;
        },

        showLeftToolbar(index) {
            this.childrenMap.leftToolbarSizer.showButton(index);
            return this;
        },

        hideChoice(index) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.hideButton(index);
            }
            return this;
        },

        hideAction(index) {
            this.childrenMap.actionsSizer.hideButton(index);
            return this;
        },

        hideToolbar(index) {
            this.childrenMap.toolbarSizer.hideButton(index);
            return this;
        },

        hideLeftToolbar(index) {
            this.childrenMap.leftToolbarSizer.hideButton(index);
            return this;
        },

        addChoice(gameObject) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.addButton(gameObject);
            }
            return this;
        },

        addAction(gameObject) {
            this.childrenMap.actionsSizer.addButton(gameObject);
            return this;
        },

        addToolbar(gameObject) {
            this.childrenMap.toolbarSizer.addButton(gameObject);
            return this;
        },

        addLeftToolbar(gameObject) {
            this.childrenMap.leftToolbarSizer.addButton(gameObject);
            return this;
        },

        removeChoice(index, destroyChild) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.removeButton(index, destroyChild);
            }
            return this;
        },

        removeAction(index, destroyChild) {
            this.childrenMap.actionsSizer.removeButton(index, destroyChild);
            return this;
        },

        removeToolbar(index, destroyChild) {
            this.childrenMap.toolbarSizer.removeButton(index, destroyChild);
            return this;
        },

        removeLeftToolbar(index, destroyChild) {
            this.childrenMap.leftToolbarSizer.removeButton(index, destroyChild);
            return this;
        },

        clearChoices(destroyChild) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.clearButtons(destroyChild);
            }
            return this;
        },

        clearActions(destroyChild) {
            this.childrenMap.actionsSizer.clearButtons(destroyChild);
            return this;
        },

        clearToolbar(destroyChild) {
            this.childrenMap.toolbarSizer.clearButtons(destroyChild);
            return this;
        },

        clearLeftToolbar(destroyChild) {
            this.childrenMap.leftToolbarSizer.clearButtons(destroyChild);
            return this;
        },

        forEachChoice(callback, scope) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.forEachButtton(callback, scope);
            }
            return this;
        },

        forEachAction(callback, scope) {
            this.childrenMap.actionsSizer.forEachButtton(callback, scope);
            return this;
        },

        forEachToolbar(callback, scope) {
            this.childrenMap.toolbarSizer.forEachButtton(callback, scope);
            return this;
        },

        forEachLeftToolbar(callback, scope) {
            this.childrenMap.leftToolbarSizer.forEachButtton(callback, scope);
            return this;
        },

        setAllButtonsEnable(enabled) {
            if (enabled === undefined) {
                enabled = true;
            }

            if (this.childrenMap.toolbarSizer) {
                this.setToolbarEnable(enabled);
            }
            if (this.childrenMap.leftToolbarSizer) {
                this.setLeftToolbarEnable(enabled);
            }
            if (this.childrenMap.actionsSizer) {
                this.setActionEnable(enabled);
            }
            if (this.childrenMap.choicesSizer) {
                this.setChoiceEnable(enabled);
            }

            return this;
        },

        // Checkboxes
        getChoicesButtonStates() {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                return choicesSizer.getAllButtonsState();
            } else {
                return {};
            }
        },

        getChoicesButtonState(name) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (name === undefined) {
                if (choicesSizer) {
                    return choicesSizer.getAllButtonsState();
                } else {
                    return {}
                }
            } else {
                if (choicesSizer) {
                    return choicesSizer.getButtonState(name);
                } else {
                    return false;
                }
            }
        },

        setChoicesButtonState(name, state) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.setButtonState(name, state);
            }
            return this;
        },

        clearChoicesButtonStates() {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.clearAllButtonsState();
            }
            return this;
        },

        // Radio buttons
        getChoicesSelectedButtonName() {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                return choicesSizer.getSelectedButtonName();
            } else {
                return '';
            }
        },

        setChoicesSelectedButtonName(name) {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                choicesSizer.setSelectedButtonName(name);
            }
            return this;
        },

        hasAnyChoice() {
            var choicesSizer = this.childrenMap.choicesSizer;
            if (choicesSizer) {
                return choicesSizer.hasAnyButton();
            }
            return false;
        },

        hasAnyAction() {
            var actionsSizer = this.childrenMap.actionsSizer;
            if (actionsSizer) {
                return actionsSizer.hasAnyButton();
            }
            return false;
        },

        hasAnyToolbar() {
            var toolbarSizer = this.childrenMap.toolbarSizer;
            if (toolbarSizer) {
                return toolbarSizer.hasAnyButton();
            }
            return false;
        },

        hasAnyLeftToolbar() {
            var leftToolbarSizer = this.childrenMap.leftToolbarSizer;
            if (leftToolbarSizer) {
                return leftToolbarSizer.hasAnyButton();
            }
            return false;
        },
    };

    var ModalMethods = {
        onCreateModalBehavior(self) {
            self.on('button.click', function (button, groupName, index, pointer, event) {
                var canClose = false;
                switch (groupName) {
                    case 'actions':
                        // Click any action button
                        canClose = true;
                        break;

                    case 'choices':
                        // Click any choice button, and no action button in this dialog
                        if (!self.hasAnyAction()) {
                            canClose = true;
                        }
                        break;
                }
                if (!canClose) {
                    return;
                }

                var closeEventData = {
                    index: index,
                    text: button.text,
                    button: button,
                    dialog: self
                };


                switch (self.buttonsType) {
                    case 'radio':
                        closeEventData.value = self.getChoicesSelectedButtonName();
                        break;
                    case 'checkboxes':
                        closeEventData.value = self.getChoicesButtonStates();
                        break;
                    default:
                        closeEventData.value = undefined;
                }

                self.modalClose(closeEventData);
            });
        },

        modal(config, onClose) {
            if (config && (config.defaultBehavior === false)) {
                this.onCreateModalBehavior = false;
            } else {
                delete this.onCreateModalBehavior;
            }

            ModalMethods$1.modal.call(this, config, onClose);
            return this;
        }
    };

    var Methods$6 = {};

    Object.assign(
        Methods$6,
        ButtonMethods$1,
        ModalMethods,
    );

    const GetValue$1m = Phaser.Utils.Objects.GetValue;

    class Dialog extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            // Create sizer        
            config.orientation = 1; // Top to bottom
            super(scene, config);
            this.type = 'rexDialog';
            this.eventEmitter = GetValue$1m(config, 'eventEmitter', this);

            // Add elements
            var background = GetValue$1m(config, 'background', undefined);
            var title = GetValue$1m(config, 'title', undefined);
            var toolbar = GetValue$1m(config, 'toolbar', undefined);
            var toolbarBackground = GetValue$1m(config, 'toolbarBackground', undefined);
            var leftToolbar = GetValue$1m(config, 'leftToolbar', undefined);
            var leftToolbarBackground = GetValue$1m(config, 'leftToolbarBackground', undefined);
            var content = GetValue$1m(config, 'content', undefined);
            var description = GetValue$1m(config, 'description', undefined);
            var choicesSizer;
            var choices = GetValue$1m(config, 'choices', undefined);
            var choicesBackground = GetValue$1m(config, 'choicesBackground', undefined);
            var actionsSizer;
            var actions = GetValue$1m(config, 'actions', undefined);
            var actionsBackground = GetValue$1m(config, 'actionsBackground', undefined);
            var clickConfig = GetValue$1m(config, 'click', undefined);

            if (background) {
                this.addBackground(background);
            }

            var toolbarSizer;
            if (toolbar) {
                toolbarSizer = new Buttons$1(scene, {
                    groupName: 'toolbar',
                    background: toolbarBackground,
                    buttons: toolbar,
                    orientation: 0, // Left-right
                    space: { item: GetValue$1m(config, 'space.toolbarItem', 0) },
                    click: clickConfig,
                    eventEmitter: this.eventEmitter,
                });
                scene.add.existing(toolbarSizer);
            }

            var leftToolbarSizer;
            if (leftToolbar) {
                leftToolbarSizer = new Buttons$1(scene, {
                    groupName: 'leftToolbar',
                    background: leftToolbarBackground,
                    buttons: leftToolbar,
                    orientation: 0, // Left-right
                    space: { item: GetValue$1m(config, 'space.leftToolbarItem', 0) },
                    click: clickConfig,
                    eventEmitter: this.eventEmitter,
                });
                scene.add.existing(leftToolbarSizer);
            }

            // title or toolbar or leftToolbar
            if (title || toolbar || leftToolbar) {
                var titleExpandWidth = !!title && GetValue$1m(config, 'expand.title', true);
                var titleAlign = GetValue$1m(config, 'align.title', 'center');
                var useOverlapSizer =
                    // Has title, title is not exapnd-width, title align to center
                    (title && !titleExpandWidth && (titleAlign === 'center')) ||
                    // No title
                    (!title && (toolbar || leftToolbar));
                var useSizer = !useOverlapSizer;

                var titleSizer;
                if (useSizer) {
                    titleSizer = new Sizer(scene, { orientation: 0 });
                } else {
                    titleSizer = new OverlapSizer(scene);
                }
                scene.add.existing(titleSizer);

                var titleChildExpand = (useSizer) ? true : { height: true };

                // Add leftToolbar
                if (leftToolbarSizer) {
                    titleSizer.add(
                        leftToolbarSizer,
                        { align: 'left', expand: titleChildExpand }
                    );
                }

                // Add title
                if (title) {
                    // Add space if not expand, align to right
                    if (useSizer && !titleExpandWidth && (titleAlign === 'right')) {
                        titleSizer.addSpace();
                    }

                    var padding = {
                        left: GetValue$1m(config, 'space.titleLeft', 0),
                        right: GetValue$1m(config, 'space.titleRight', 0)
                    };
                    var proportion = (titleExpandWidth) ? 1 : 0;
                    titleSizer.add(
                        title,
                        { align: titleAlign, proportion: proportion, expand: titleChildExpand, padding: padding }
                    );

                    // Add space if not expand, align to left
                    if (useSizer && !titleExpandWidth && (titleAlign === 'left')) {
                        titleSizer.addSpace();
                    }
                }

                // Add toolbar
                if (toolbarSizer) {
                    // Add space if not title
                    if (useSizer && !title) {
                        titleSizer.addSpace();
                    }
                    titleSizer.add(
                        toolbarSizer,
                        { align: 'right', expand: titleChildExpand }
                    );
                }

                // Add sizer to dialog
                var padding;
                if (content || description || choices || actions) {
                    padding = {
                        bottom: GetValue$1m(config, 'space.title', 0),
                        top: GetValue$1m(config, 'space.titleTop', 0)
                    };
                }
                var proportion = GetValue$1m(config, 'proportion.title', 0);
                this.add(
                    titleSizer,
                    { padding: padding, proportion: proportion, expand: true }
                );
            }

            if (content) {
                var align = GetValue$1m(config, 'align.content', 'center');
                var contentSpace = GetValue$1m(config, 'space.content', 0);
                var padding = {
                    left: GetValue$1m(config, 'space.contentLeft', 0),
                    right: GetValue$1m(config, 'space.contentRight', 0),
                    bottom: ((description || choices || actions) ? contentSpace : 0)
                };
                var proportion = GetValue$1m(config, 'proportion.content', 0);
                var expand = GetValue$1m(config, 'expand.content', true);
                this.add(
                    content,
                    { align: align, padding: padding, proportion: proportion, expand: expand }
                );
            }

            if (description) {
                var align = GetValue$1m(config, 'align.description', 'center');
                var descriptionSpace = GetValue$1m(config, 'space.description', 0);
                var padding = {
                    left: GetValue$1m(config, 'space.descriptionLeft', 0),
                    right: GetValue$1m(config, 'space.descriptionRight', 0),
                    bottom: ((choices || actions) ? descriptionSpace : 0)
                };
                var proportion = GetValue$1m(config, 'proportion.description', 0);
                var expand = GetValue$1m(config, 'expand.description', true);
                this.add(
                    description,
                    { align: align, padding: padding, proportion: proportion, expand: expand }
                );
            }

            if (choices) {
                var choicesType = GetValue$1m(config, 'choicesType', '').split('-');
                var ButtonsClass = Contains(choicesType, 'wrap') ? Buttons :
                    Contains(choicesType, 'grid') ? GridButtons :
                        Buttons$1;
                var buttonsType = Contains(choicesType, 'radio') ? 'radio' :
                    Contains(choicesType, 'checkboxes') ? 'checkboxes' : undefined;

                var space = {
                    left: GetValue$1m(config, 'space.choicesBackgroundLeft', 0),
                    right: GetValue$1m(config, 'space.choicesBackgroundRight', 0),
                    top: GetValue$1m(config, 'space.choicesBackgroundTop', 0),
                    bottom: GetValue$1m(config, 'space.choicesBackgroundBottom', 0),
                };
                var itemSpace = GetValue$1m(config, 'space.choice', 0);
                if (ButtonsClass === Buttons$1) {
                    space.item = itemSpace;
                } else if (ButtonsClass === Buttons) {
                    space.item = itemSpace;
                    space.line = GetValue$1m(config, 'space.choiceLine', itemSpace);
                } else {  // GridButtons
                    space.column = GetValue$1m(config, 'space.choiceColumn', itemSpace);
                    space.row = GetValue$1m(config, 'space.choiceRow', itemSpace);
                }

                var choicesConfig = {
                    width: GetValue$1m(config, 'choicesWidth', undefined),
                    height: GetValue$1m(config, 'choicesHeight', undefined),
                    groupName: 'choices',
                    buttonsType: buttonsType,
                    background: choicesBackground,
                    buttons: choices,
                    space: space,
                    click: clickConfig,
                    eventEmitter: this.eventEmitter,
                    setValueCallback: GetValue$1m(config, 'choicesSetValueCallback', undefined),
                    setValueCallbackScope: GetValue$1m(config, 'choicesSetValueCallbackScope', undefined)
                };

                if (ButtonsClass === Buttons$1) {
                    choicesConfig.orientation = Contains(choicesType, 'x') ? 0 : 1;
                }

                choicesSizer = new ButtonsClass(scene, choicesConfig);
                scene.add.existing(choicesSizer);
                var choicesSpace = GetValue$1m(config, 'space.choices', 0);
                var padding = {
                    left: GetValue$1m(config, 'space.choicesLeft', 0),
                    right: GetValue$1m(config, 'space.choicesRight', 0),
                    bottom: ((actions) ? choicesSpace : 0)
                };
                var align = GetValue$1m(config, 'align.choices', 'center');
                var proportion = GetValue$1m(config, 'proportion.choices', 0);
                var expand = GetValue$1m(config, 'expand.choices', true);
                this.add(
                    choicesSizer,
                    { align: align, padding: padding, proportion: proportion, expand: expand }
                );

                this.buttonsType = buttonsType;
            }

            if (actions) {
                actionsSizer = new Buttons$1(scene, {
                    groupName: 'actions',
                    background: actionsBackground,
                    buttons: actions,
                    orientation: 0, // Left-right
                    space: { item: GetValue$1m(config, 'space.action', 0) },
                    expand: GetValue$1m(config, 'expand.actions', false),
                    align: GetValue$1m(config, 'align.actions', 'center'),
                    click: clickConfig,
                    eventEmitter: this.eventEmitter,
                });
                scene.add.existing(actionsSizer);
                var padding = {
                    left: GetValue$1m(config, 'space.actionsLeft', 0),
                    right: GetValue$1m(config, 'space.actionsRight', 0),
                    bottom: GetValue$1m(config, 'space.actionsBottom', 0),
                };
                var proportion = GetValue$1m(config, 'proportion.action', 0);
                this.add(
                    actionsSizer,
                    { align: 'center', padding: padding, proportion: proportion, expand: true }
                );
            }

            EmitButtonEvent(this, 'click');
            EmitButtonEvent(this, 'over');
            EmitButtonEvent(this, 'out');
            EmitButtonEvent(this, 'enable');
            EmitButtonEvent(this, 'disable');

            this.addChildrenMap('background', background);
            this.addChildrenMap('title', title);
            this.addChildrenMap('toolbar', toolbar);
            this.addChildrenMap('leftToolbar', leftToolbar);
            this.addChildrenMap('content', content);
            this.addChildrenMap('description', description);
            this.addChildrenMap('choices', (choicesSizer) ? choicesSizer.buttons : undefined);
            this.addChildrenMap('actions', (actionsSizer) ? actionsSizer.buttons : undefined);
            this.addChildrenMap('choicesSizer', choicesSizer);
            this.addChildrenMap('actionsSizer', actionsSizer);
            this.addChildrenMap('toolbarSizer', toolbarSizer);
            this.addChildrenMap('leftToolbarSizer', leftToolbarSizer);
        }
    }

    var Contains = function (arr, item) {
        return arr.indexOf(item) !== -1;
    };

    var ButtonsGroupEventNameMap = {
        actions: 'action',
        choices: 'choice',
        toolbar: 'toolbar',
        leftToolbar: 'leftToolbar'
    };

    var EmitButtonEvent = function (dialog, postEventName) {
        dialog.on(`button.${postEventName}`, function (button, groupName, index, pointer, event) {
            if (!ButtonsGroupEventNameMap.hasOwnProperty(groupName)) {
                return
            }
            dialog.emit(`${ButtonsGroupEventNameMap[groupName]}.${postEventName}`, button, index, pointer, event);
        });
    };

    Object.assign(
        Dialog.prototype,
        Methods$6
    );

    ObjectFactory.register('dialog', function (config) {
        var gameObject = new Dialog(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Dialog', Dialog);

    var CreateLabel = function (scene, config, creators) {
        var gameObject = new SimpleLabel(scene, config, creators);
        scene.add.existing(gameObject);
        return gameObject;
    };

    var ResetDisplayContent$1 = function (config) {
        if (config === undefined) {
            config = {};
        }

        ResetTitle$1.call(this, config);
        ResetContent$1.call(this, config);
        ResetActions$1.call(this, config);
        ResetChoices.call(this, config);

        return this;
    };

    var ResetTitle$1 = function (config) {
        var title = this.childrenMap.title;
        config = config.title;
        if (config === null) {
            title.hide();
        } else {
            title.show();

            title.resetDisplayContent(config);
        }
    };

    var ResetContent$1 = function (config) {
        var content = this.childrenMap.content;
        config = config.content;
        if (config === null) {
            content.hide();
        } else {
            content.show();

            if (content.resetDisplayContent) {
                // Label
                content.resetDisplayContent(config);
            } else {
                // TextArea
                var text = config || '';
                content.setText(text);
            }
        }

    };

    var ResetActions$1 = function (config) {
        var actionButtons = this.childrenMap.actions;
        if (!actionButtons) {
            return;
        }

        var buttonContentArray = config.buttons;
        if (!buttonContentArray) {
            var buttonA = actionButtons[0];
            if (buttonA) {
                if (config.buttonA === null) {
                    buttonA.hide();
                } else {
                    buttonA.show();
                    buttonA.resetDisplayContent(config.buttonA);
                }
            }

            var buttonB = actionButtons[1];
            if (buttonB) {
                if (config.buttonB === null) {
                    buttonB.hide();
                } else {
                    buttonB.show();
                    buttonB.resetDisplayContent(config.buttonB);
                }
            }

        } else {
            var scene = this.scene;
            var defaultActionConfig = this.defaultActionConfig;
            var defaultActionButtonCreator = this.defaultActionButtonCreator;
            for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
                var buttonContent = buttonContentArray[i];
                var button = actionButtons[i];
                if (!button) {
                    button = CreateLabel(scene, defaultActionConfig, defaultActionButtonCreator);
                    this.addAction(button);
                }
                button.show().resetDisplayContent(buttonContent);
            }

            this.buttonMode = buttonContentArray.length;

            for (var i = buttonContentArray.length, cnt = actionButtons.length; i < cnt; i++) {
                actionButtons[i].hide();
            }
        }
    };

    var ResetChoices = function (config) {
        var choices = this.childrenMap.choices;
        if (!choices) {
            return;
        }

        var buttonContentArray = config.choices;
        if (!buttonContentArray) {
            buttonContentArray = [];
        }

        var scene = this.scene;
        var defaultChoiceConfig = this.defaultChoiceConfig;
        var defaultActionButtonCreator = this.defaultActionButtonCreator;
        for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
            var buttonContent = buttonContentArray[i];
            if (typeof (buttonContent) === 'string') {
                buttonContent = { text: buttonContent };
            }

            var button = choices[i];
            if (!button) {
                button = CreateLabel(scene, defaultChoiceConfig, defaultActionButtonCreator);
                this.addChoice(button);
            }

            button.show().resetDisplayContent(buttonContent);

            var optionValue;
            if (buttonContent.hasOwnProperty('value')) {
                optionValue = buttonContent.value;
            } else {
                optionValue = buttonContent.text;
            }
            button.setName(optionValue);
        }

        for (var i = buttonContentArray.length, cnt = choices.length; i < cnt; i++) {
            choices[i].hide();
        }
    };

    const Merge$4 = Phaser.Utils.Objects.Merge;

    var Modal$1 = function (config, onClose) {
        if (IsFunction(config)) {
            onClose = config;
            config = undefined;
        }

        if (config === undefined) {
            config = {};
        }

        config = Merge$4(config, this.modalStyle);

        var zeroButtonMode;
        if (this.buttonMode === 0) {
            if (this.hasAnyChoice()) {
                zeroButtonMode = false;
            } else {
                zeroButtonMode = true;
            }
        } else {
            zeroButtonMode = false;
        }

        if (!config.hasOwnProperty('anyTouchClose')) {
            config.anyTouchClose = zeroButtonMode;
        }

        if (!config.hasOwnProperty('manualClose')) {
            config.manualClose = !zeroButtonMode;
        }

        var self = this;
        var onCloseWrap = function (data) {
            var buttonIndex = data.index;
            if (buttonIndex === self.confirmButtonIndex) {
                self.emit('confirm', data);
            } else if (buttonIndex === self.cancelButtonIndex) {
                self.emit('cancel', data);
            }

            if (onClose) {
                onClose(data);
            }
        };

        ModalMethods$1.modal.call(this, config, onCloseWrap);

        return this;
    };

    var SetButtonIndexMethods = {
        setConfirmButtonIndex(index) {
            this.confirmButtonIndex = index;
            return this;
        },

        setCancelButtonIndex(index) {
            this.cancelButtonIndex = index;
            return this;
        },
    };

    var Methods$5 = {
        resetDisplayContent: ResetDisplayContent$1,
        modal: Modal$1,
    };

    Object.assign(
        Methods$5,
        SetButtonIndexMethods,
    );

    var OnPointerOverCallback = function (button) {
        if (button.setHoverState) {
            button.setHoverState(true);
        }
    };

    var OnPointerOutCallback = function (button) {
        if (button.setHoverState) {
            button.setHoverState(false);
        }
    };

    var OnChoiceButtonStateChange = function (button, groupName, index, value) {
        if (button.setActiveState) {
            button.setActiveState(value);
        }
    };

    var OnButtonEnable = function (button) {
        if (button.setDisableState) {
            button.setDisableState(false);
        }
    };

    var OnButtonDisable = function (button) {
        if (button.setDisableState) {
            button.setDisableState(true);
        }
    };

    var RegisterEvents = function () {
        this
            .on('button.over', OnPointerOverCallback)
            .on('button.out', OnPointerOutCallback)
            .on('button.enable', OnButtonEnable)
            .on('button.disable', OnButtonDisable)
            .on('button.statechange', OnChoiceButtonStateChange);

    };

    const GetValue$1l = Phaser.Utils.Objects.GetValue;

    var CreateContent$1 = function (scene, config, creators) {
        var type = GetValue$1l(config, '$type');
        if (type === undefined) {
            if (config &&
                (config.hasOwnProperty('slider') || config.hasOwnProperty('scroller'))
            ) {
                type = 'textarea';
            }
        }


        var gameObject;
        switch (type) {
            case 'textarea':
                gameObject = new CreateTextArea(scene, config, creators);
                break;

            default:
                gameObject = new CreateLabel(scene, config, creators);
                break;
        }

        scene.add.existing(gameObject);
        return gameObject;
    };

    const GetValue$1k = Phaser.Utils.Objects.GetValue;

    class ConfirmDialog extends Dialog {
        constructor(scene, config, creators) {
            config = (config) ? DeepClone(config) : {};

            if (creators === undefined) {
                creators = {};
            }

            var createBackground = GetValue$1k(creators, 'background', CreateBackground$2);
            config.background = createBackground(scene, config.background);

            config.title = CreateLabel(scene, config.title, creators.title);

            config.content = CreateContent$1(scene, config.content, creators.content);
            if (config.content instanceof TextArea) {
                if (HasValue(config, 'height') && !HasValue(config, 'proportion.content')) {
                    SetValue(config, 'proportion.content', 1);
                }
            }

            var defaultButtonConfig = config.button;
            var buttonAConfig = config.buttonA || defaultButtonConfig;
            var buttonBConfig = config.buttonB || defaultButtonConfig;
            var buttonMode = config.buttonMode;
            if (buttonMode === undefined) {
                buttonMode = (!!buttonAConfig && !!buttonBConfig) ? 2 :
                    (!!buttonAConfig) ? 1 :
                        0;
            }

            var defaultButtonCreator = creators.button;
            var buttonACreators = creators.buttonA || defaultButtonCreator;
            var buttonBCreators = creators.buttonB || defaultButtonCreator;
            switch (buttonMode) {
                case 2:
                    config.actions = [
                        CreateLabel(scene, buttonAConfig, buttonACreators),
                        CreateLabel(scene, buttonBConfig, buttonBCreators),
                    ];
                    break;

                case 1:
                    config.actions = [
                        CreateLabel(scene, buttonAConfig, buttonACreators),
                    ];
                    break;

                case 0:
                    break;

                default:
                    config.actions = [];
                    break;
            }

            var defaultChoiceConfig = config.choice;
            if (defaultChoiceConfig) {
                config.choices = [];
            }

            super(scene, config);
            this.type = 'rexConfirmDialog';

            this.buttonMode = buttonMode;

            this.defaultActionConfig = defaultButtonConfig;
            this.defaultActionButtonCreator = defaultButtonCreator;

            this.defaultChoiceConfig = defaultChoiceConfig;
            this.defaultChoiceCreator = creators.choice;

            var buttons = this.childrenMap.actions;
            this.addChildrenMap('buttonA', (buttons) ? buttons[0] : null);
            this.addChildrenMap('buttonB', (buttons) ? buttons[1] : null);

            // Interactive
            RegisterEvents.call(this);

            // Assign button index for comfirm, cancel events
            this.setConfirmButtonIndex(GetValue$1k(config, 'confirmButtonIndex', 0));
            this.setCancelButtonIndex(GetValue$1k(config, 'cancelButtonIndex', 1));

            this.modalStyle = config.modal || {};
        }
    }

    Object.assign(
        ConfirmDialog.prototype,
        Methods$5
    );

    ObjectFactory.register('confirmDialog', function (config, creators) {
        var gameObject = new ConfirmDialog(this.scene, config, creators);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ConfirmDialog', ConfirmDialog);

    const GetValue$1j = Phaser.Utils.Objects.GetValue;

    var ConfirmAction = function (scene, config) {
        var dialog = config.dialog;
        var newDialogMode = !dialog;
        if (newDialogMode) {
            var dialogStyle = config.style;
            dialogStyle.buttonMode = 2;

            dialog = new ConfirmDialog(scene, dialogStyle, config.creators);
            scene.add.existing(dialog);
        }

        dialog
            .setConfirmButtonIndex(GetValue$1j(config, 'confirmButtonIndex', 0))
            .setCancelButtonIndex(GetValue$1j(config, 'cancelButtonIndex', 1))
            .resetDisplayContent(config.content)
            .layout();

        if (newDialogMode && config.onCreateDialog) {
            config.onCreateDialog(dialog);
        }

        var modalConfig = config.modal;
        if (modalConfig && !modalConfig.hasOwnProperty('destroy')) {
            modalConfig.destroy = newDialogMode;
        }

        var confirmCallback = config.confirm;
        var cancelCallback = config.cancel;
        var confirmScope = config.confirmScope;
        var cancelScope = config.cancelScope;

        if (confirmCallback) {
            dialog.once('confirm', confirmCallback, confirmScope);
        }
        if (cancelCallback) {
            dialog.once('cancel', cancelCallback, cancelScope);
        }

        var onClose = function (data) {
            dialog.off('confirm', confirmCallback, confirmScope);
            dialog.off('cancel', cancelCallback, cancelScope);
        };

        dialog.modal(modalConfig, onClose);

        return dialog;
    };

    class ConfirmActionButton extends Label {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            super(scene, config);
            this.type = 'rexConfirmActionButton';

            this.setConfirmDialogEnable();

            this.confirmActionConfig = Clone$2(config.confirmDialog || {});
            if (config.confirm) {
                this.setConfirmCallback(config.confirm, config.confirmScope);
            }
            if (config.cancel) {
                this.setCancelCallback(config.cancel, config.cancelScope);
            }

            this.onClickCallback = function () {
                if (this.confirmDialogEnable) {
                    if (this.confirmDialog) {
                        return;
                    }

                    this.confirmDialog = ConfirmAction(scene, this.confirmActionConfig);
                    this.confirmDialog.once('destroy', function () {
                        this.confirmDialog = undefined;
                    }, this);

                } else {
                    this.runConfirmCallback();
                }
            };
            this.onClick(this.onClickCallback, this);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            if (this.confirmDialog) {
                this.confirmDialog.destroy();
            }

            super.destroy(fromScene);

            this.confirmActionConfig = undefined;
            this.onClickCallback = undefined;
            this.confirmDialog = undefined;
        }

        setConfirmCallback(callback, scope) {
            this.confirmActionConfig.confirm = callback;
            this.confirmActionConfig.confirmScope = scope;
            return this;
        }

        setCancelCallback(callback, scope) {
            this.confirmActionConfig.cancel = callback;
            this.confirmActionConfig.cancelScope = scope;
            return this;
        }

        setConfirmDialogContent(content) {
            this.confirmActionConfig.content = content;
            return this;
        }

        setConfitmDialogStyle(style) {
            this.confirmActionConfig.style = style;
            return this;
        }

        setConfitmDialogModalConfig(config) {
            this.confirmActionConfig.modal = config;
            return this;
        }

        setConfirmDialogEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            this.confirmDialogEnable = enable;
            return this;
        }

        runConfirmCallback() {
            var callback = this.confirmActionConfig.confirm;
            var scope = this.confirmActionConfig.confirmScope;

            if (callback) {
                callback.call(scope);
            }

            return this;
        }
    }

    ObjectFactory.register('confirmActionButton', function (config) {
        var gameObject = new ConfirmActionButton(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ConfirmActionButton', ConfirmActionButton);

    var ResetDisplayContent = function (config) {
        if (config === undefined) {
            config = {};
        }

        ResetTitle.call(this, config);
        ResetContent.call(this, config);
        ResetActions.call(this, config);

        return this;
    };

    var ResetTitle = function (config) {
        var title = this.childrenMap.title;
        if (config.title === null) {
            this.hide(title);
        } else {
            this.show(title);

            title.resetDisplayContent(config.title);
        }
    };

    var ResetContent = function (config) {
        var firstNameTitle = this.childrenMap.firstNameTitle;
        if (config.firstNameTitle === null) {
            this.hide(firstNameTitle);
        } else {
            this.show(firstNameTitle);

            // Label
            var firstNameTitleConfig = config.firstNameTitle || '';
            firstNameTitle.resetDisplayContent(firstNameTitleConfig);
        }

        var firstNameInput = this.childrenMap.firstNameInput;
        if (config.firstName === null) {
            this.hide(firstNameInput);
        } else {
            this.show(firstNameInput);

            // Text
            var firstName = config.firstName || '';
            firstNameInput.setText(firstName);
        }

        var lastNameTitle = this.childrenMap.lastNameTitle;
        if (config.lastNameTitle === null) {
            this.hide(lastNameTitle);
        } else {
            this.show(lastNameTitle);

            // Label
            var lastNameTitleConfig = config.lastNameTitle || '';
            lastNameTitle.resetDisplayContent(lastNameTitleConfig);
        }

        var lastNameInput = this.childrenMap.lastNameInput;
        if (config.lastName === null) {
            this.hide(lastNameInput);
        } else {
            this.show(lastNameInput);

            // Text
            var lastName = config.lastName || '';
            lastNameInput.setText(lastName);
        }
    };

    var ResetActions = function (config) {
        var action = this.childrenMap.actions[0];
        if (config.button === null) {
            this.hide(action);
        } else {
            this.show(action);
            action.resetDisplayContent(config.button);
        }
    };

    const Merge$3 = Phaser.Utils.Objects.Merge;

    var Modal = function (config, onClose) {
        if (IsFunction(config)) {
            onClose = config;
            config = undefined;
        }

        if (config === undefined) {
            config = {};
        }

        config = Merge$3(config, this.modalStyle);
        config.anyTouchClose = false;
        config.manualClose = false;

        var self = this;
        var onCloseWrap = function (data) {
            data.firstName = self.firstName;
            data.lastName = self.lastName;

            self.emit('confirm', data);
            if (onClose) {
                onClose(data);
            }
        };

        ModalMethods$1.modal.call(this, config, onCloseWrap);

        return this;
    };

    var methods$g = {
        resetDisplayContent: ResetDisplayContent,
        modal: Modal,
    };

    var CreateInputText$1 = function (scene, config, deepCloneConfig) {
        if (deepCloneConfig === undefined) {
            deepCloneConfig = true;
        }

        if (deepCloneConfig) {
            config = (config) ? DeepClone(config) : {};
        } else if (!config) {
            config = {};
        }


        var inputText = new CanvasInput(scene, config);
        scene.add.existing(inputText);
        return inputText;
    };

    const GetValue$1i = Phaser.Utils.Objects.GetValue;

    var CreateContent = function (scene, config, creators) {
        // Names-sizer as content
        var layoutMode = GetOrientationMode(GetValue$1i(config, 'layoutMode', 0));
        var isHorizontalLayout = layoutMode === 0;
        var nameSizer = new Sizer(scene, {
            orientation: layoutMode,
            space: {
                item: GetValue$1i(config, 'space.firstName', 0)
            }
        });
        scene.add.existing(nameSizer);

        // First name
        var firstNameSizer = new Sizer(scene, { orientation: 'x' });
        scene.add.existing(firstNameSizer);

        var firstNameTitleConfig = GetValue$1i(config, 'firstNameTitle', config.nameTitle);
        var firstNameTitle = CreateLabel(scene, firstNameTitleConfig, creators.firstNameTitle || creators.nameTitle);
        firstNameSizer.add(
            firstNameTitle,
            {
                expand: true,
                proportion: GetValue$1i(config, 'proportion.firstNameTitle', 0),
                padding: {
                    right: GetValue$1i(config, 'space.firstNameTitle', 0)
                },
            }
        );

        var defaultNameInputConfig = config.nameInput || {};
        var firstNameInputConfig = GetValue$1i(config, 'firstNameInput', defaultNameInputConfig);
        var firstNameInput = CreateInputText$1(scene, firstNameInputConfig, creators.firstNameInput || creators.nameInput);
        var expandFirstNameSizer = !firstNameInputConfig.hasOwnProperty('width');
        firstNameSizer.add(
            firstNameInput,
            {
                expand: true,
                proportion: (expandFirstNameSizer) ? 1 : 0,
            }
        );

        // Last name
        var lastNameSizer = new Sizer(scene, { orientation: 'x' });
        scene.add.existing(lastNameSizer);

        var lastNameTitleConfig = GetValue$1i(config, 'lastNameTitle', config.nameTitle);
        var lastNameTitle = CreateLabel(scene, lastNameTitleConfig, creators.lastNameTitle || creators.nameTitle);
        lastNameSizer.add(
            lastNameTitle,
            {
                expand: true,
                proportion: GetValue$1i(config, 'proportion.lastNameTitle', 0),
                padding: {
                    right: GetValue$1i(config, 'space.lastNameTitle', 0)
                }
            }
        );

        var lastNameInputConfig = GetValue$1i(config, 'firstNameInput', defaultNameInputConfig);
        var lastNameInput = CreateInputText$1(scene, lastNameInputConfig, creators.lastNameInput || creators.nameInput);
        var expandLastNameSizer = !lastNameInputConfig.hasOwnProperty('width');
        lastNameSizer.add(
            lastNameInput,
            {
                expand: true,
                proportion: (expandLastNameSizer) ? 1 : 0,
            }
        );


        if (isHorizontalLayout) {
            // First | Last

            var defaultFirstNameProportion = (expandFirstNameSizer) ? 1 : 0;
            var firstNameProportion = GetValue$1i(config, 'proportion.firstName', defaultFirstNameProportion);
            nameSizer.add(
                firstNameSizer,
                {
                    expand: true,
                    proportion: firstNameProportion,
                }
            );

            var defaultLastNameProportion = (expandLastNameSizer) ? 1 : 0;
            var lastNameProportion = GetValue$1i(config, 'proportion.lastName', defaultLastNameProportion);
            nameSizer.add(
                lastNameSizer,
                {
                    expand: true,
                    proportion: lastNameProportion,
                }
            );
        } else {
            // First        
            // Last
            nameSizer.add(
                firstNameSizer,
                {
                    expand: expandFirstNameSizer,
                    proportion: 0,
                }
            );
            nameSizer.add(
                lastNameSizer,
                {
                    expand: expandLastNameSizer,
                    proportion: 0,
                }
            );
        }

        nameSizer.addChildrenMap('firstNameTitle', firstNameTitle);
        nameSizer.addChildrenMap('firstNameInput', firstNameInput);
        nameSizer.addChildrenMap('lastNameTitle', lastNameTitle);
        nameSizer.addChildrenMap('lastNameInput', lastNameInput);

        return nameSizer;
    };

    const GetValue$1h = Phaser.Utils.Objects.GetValue;

    class NameInputDialog extends Dialog {
        constructor(scene, config, creators) {
            if (config === undefined) {
                config = {};
            }

            if (creators === undefined) {
                creators = {};
            }

            config.orientation = 'y';

            var spaceConfig = config.space;
            if (spaceConfig) {
                if (spaceConfig.hasOwnProperty('names')) {
                    spaceConfig.content = spaceConfig.names;
                }
                if (spaceConfig.hasOwnProperty('namesLeft')) {
                    spaceConfig.contentLeft = spaceConfig.namesLeft;
                }
                if (spaceConfig.hasOwnProperty('namesRight')) {
                    spaceConfig.contentRight = spaceConfig.namesRight;
                }
            }


            // Background
            var createBackground = GetValue$1h(creators, 'background', CreateBackground$2);
            config.background = createBackground(scene, config.background);

            // Title
            config.title = CreateLabel(scene, config.title, creators.title);

            // Content
            config.content = CreateContent(scene, config, creators);

            // Actions
            config.actions = [
                CreateLabel(scene, config.button, creators.button)
            ];

            super(scene, config);
            this.type = 'rexNameInputDialog';

            var namesSizerChildrenMap = config.content.childrenMap;
            this.addChildrenMap('firstNameTitle', namesSizerChildrenMap.firstNameTitle);
            this.addChildrenMap('firstNameInput', namesSizerChildrenMap.firstNameInput);
            this.addChildrenMap('lastNameTitle', namesSizerChildrenMap.lastNameTitle);
            this.addChildrenMap('lastNameInput', namesSizerChildrenMap.lastNameInput);

            this.addChildrenMap('button', config.actions[0]);

            // Interactive
            RegisterEvents.call(this);

            this.modalStyle = config.modal || {};
        }

        get firstName() {
            return this.childrenMap.firstNameInput.text;
        }

        set firstName(value) {
            this.childrenMap.firstNameInput.setText(value);
        }

        setFirstName(value) {
            this.firstName = value;
            return this;
        }

        get lastName() {
            return this.childrenMap.lastNameInput.text;
        }

        set lastName(value) {
            this.childrenMap.lastNameInput.setText(value);
        }

        setLastName(value) {
            this.lastName = value;
            return this;
        }

    }


    Object.assign(
        NameInputDialog.prototype,
        methods$g
    );

    ObjectFactory.register('nameInputDialog', function (config, creators) {
        var gameObject = new NameInputDialog(this.scene, config, creators);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.NameInputDialog', NameInputDialog);

    var RemoveFromParent = function (gameObject, destroyChild) {
        if (!gameObject) {
            return;
        }

        var parent = GetParent$1(gameObject);

        if (!parent) {
            return;
        }

        parent.remove(gameObject, destroyChild);
    };

    const GetValue$1g = Phaser.Utils.Objects.GetValue;

    var GetAddChildConfig = function (config, key, defaultValues) {
        var proportion = GetValue$1g(config, `proportion.${key}`, defaultValues.proportion);
        var align = GetValue$1g(config, `align.${key}`, 'center');
        var padding = GetValue$1g(config, `space.${key}`, undefined);
        if ((typeof (padding) === 'number') && defaultValues.paddingKey) {
            var paddingNum = padding;
            padding = {};
            padding[defaultValues.paddingKey] = paddingNum;
        }
        var expand = GetValue$1g(config, `expand.${key}`, true);

        return {
            proportion: proportion,
            align: align,
            padding: padding,
            expand: expand,
        }
    };

    var GetAddHeaderConfig = function (config) {
        return GetAddChildConfig(config, 'header', {
            proportion: 0,
            paddingKey: 'bottom'
        })
    };

    var GetAddLeftSideConfig = function (config) {
        return GetAddChildConfig(config, 'leftSide', {
            proportion: 0,
            paddingKey: 'right'
        })
    };

    var GetAddContentConfig = function (config) {
        return GetAddChildConfig(config, 'content', {
            proportion: 1
        })
    };

    var GetAddRightSideConfig = function (config) {
        return GetAddChildConfig(config, 'rightSide', {
            proportion: 0,
            paddingKey: 'left'
        })
    };

    var GetAddFooterConfig = function (config) {
        return GetAddChildConfig(config, 'footer', {
            proportion: 0,
            paddingKey: 'top'
        })
    };

    var GetAddContainerConfig = function (config) {
        return {
            proportion: 1,
            align: 'center',
            padding: 0,
            expand: true,
        }
    };

    var CreatExpandContainer = function (scene, orientation) {
        var container = new Sizer(scene, {
            orientation: orientation
        });
        scene.add.existing(container);
        return container;
    };

    /*
    Elements:
        ```
        HHH
        LCR
        FFF
        ```
    */


    var LayoutMode0$1 = function (config) {
        var scene = this.scene;

        // Add Header
        var header = config.header;
        if (header) {
            this.add(header, GetAddHeaderConfig(config));
        }

        /*
        L C R
        */    
        var bodySizer = CreatExpandContainer(scene, 0);
        this.add(bodySizer, GetAddContainerConfig());

        // Add Left-side
        var leftSide = config.leftSide;
        if (leftSide) {
            bodySizer.add(leftSide, GetAddLeftSideConfig(config));
        }

        // Add content
        var content = config.content;
        if (content) {
            bodySizer.add(content, GetAddContentConfig(config));
        }

        // Add Right-side
        var rightSide = config.rightSide;
        if (rightSide) {
            bodySizer.add(rightSide, GetAddRightSideConfig(config));
        }

        // Add Footer
        var footer = config.footer;
        if (footer) {
            this.add(footer, GetAddFooterConfig(config));
        }
    };

    /*
    Elements:
        ```
        HHH
        LCR
        LFF
        ```
    */


    var LayoutMode1 = function (config) {
        var scene = this.scene;

        // Add Header
        var header = config.header;
        if (header) {
            this.add(header, GetAddHeaderConfig(config));
        }

        /*
        L CR
        L FF
        */
        var bodySizer0 = CreatExpandContainer(scene, 0);
        this.add(bodySizer0, GetAddContainerConfig());

        // Add Left-side
        var leftSide = config.leftSide;
        if (leftSide) {
            bodySizer0.add(leftSide, GetAddLeftSideConfig(config));
        }

        /*
        CR

        FF
        */
        var bodySizer1 = CreatExpandContainer(scene, 1);
        bodySizer0.add(bodySizer1, GetAddContainerConfig());

        /*
        C R
        */
        var bodySizer2 = CreatExpandContainer(scene, 0);
        bodySizer1.add(bodySizer2, GetAddContainerConfig());

        // Add content
        var content = config.content;
        if (content) {
            bodySizer2.add(content, GetAddContentConfig(config));
        }

        // Add Right-side
        var rightSide = config.rightSide;
        if (rightSide) {
            bodySizer2.add(rightSide, GetAddRightSideConfig(config));
        }

        // Add Footer
        var footer = config.footer;
        if (footer) {
            bodySizer1.add(footer, GetAddFooterConfig(config));
        }
    };

    /*
    Elements:
        ```
        HHH
        LCR
        FFR
        ```
    */


    var LayoutMode2 = function (config) {
        var scene = this.scene;

        // Add Header
        var header = config.header;
        if (header) {
            this.add(header, GetAddHeaderConfig(config));
        }

        /*
        LC R
        FF R
        */
        var bodySizer0 = CreatExpandContainer(scene, 0);
        this.add(bodySizer0, GetAddContainerConfig());

        /*
        LC

        FF
        */
        var bodySizer1 = CreatExpandContainer(scene, 1);
        bodySizer0.add(bodySizer1, GetAddContainerConfig());

        /*
        L C
        */
        var bodySizer2 = CreatExpandContainer(scene, 0);
        bodySizer1.add(bodySizer2, GetAddContainerConfig());

        // Add Left-side
        var leftSide = config.leftSide;
        if (leftSide) {
            bodySizer2.add(leftSide, GetAddLeftSideConfig(config));
        }

        // Add content
        var content = config.content;
        if (content) {
            bodySizer2.add(content, GetAddContentConfig(config));
        }

        // Add Footer
        var footer = config.footer;
        if (footer) {
            bodySizer1.add(footer, GetAddFooterConfig(config));
        }

        // Add Right-side
        var rightSide = config.rightSide;
        if (rightSide) {
            bodySizer0.add(rightSide, GetAddRightSideConfig(config));
        }

    };

    /*
    Elements:
        ```
        HHH
        LCR
        LFR
        ```
    */


    var LayoutMode0 = function (config) {
        var scene = this.scene;

        // Add Header
        var header = config.header;
        if (header) {
            this.add(header, GetAddHeaderConfig(config));
        }

        /*
        L C R
        L F R
        */    
        var bodySizer0 = CreatExpandContainer(scene, 0);
        this.add(bodySizer0, GetAddContainerConfig());

        // Add Left-side
        var leftSide = config.leftSide;
        if (leftSide) {
            bodySizer0.add(leftSide, GetAddLeftSideConfig(config));
        }

        /*
        C

        F
        */    
        var bodySizer1 = CreatExpandContainer(scene, 1);
        bodySizer0.add(bodySizer1, GetAddContainerConfig());

        // Add content
        var content = config.content;
        if (content) {
            bodySizer1.add(content, GetAddContentConfig(config));
        }

        // Add Footer
        var footer = config.footer;
        if (footer) {
            bodySizer1.add(footer, GetAddFooterConfig(config));
        }

        // Add Right-side
        var rightSide = config.rightSide;
        if (rightSide) {
            bodySizer0.add(rightSide, GetAddRightSideConfig(config));
        }

    };

    const GetValue$1f = Phaser.Utils.Objects.GetValue;
    const LayoutCallbacks = [LayoutMode0$1, LayoutMode1, LayoutMode2, LayoutMode0];

    var Build = function (config) {
        if (config === undefined) {
            config = {};
        }

        var background = config.background;
        var header = config.header;
        var leftSide = config.leftSide;
        var content = config.content;
        var rightSide = config.rightSide;
        var footer = config.footer;

        // Remove from parent
        RemoveFromParent(background);
        RemoveFromParent(header);
        RemoveFromParent(leftSide);
        RemoveFromParent(content);
        RemoveFromParent(rightSide);
        RemoveFromParent(footer);

        this.clear(true);

        // Add Background
        if (background) {
            this.addBackground(background);
        }

        var layoutMode = GetValue$1f(config, 'layoutMode', 0);
        if (typeof (layoutMode) === 'string') {
            layoutMode = LayoutModesMap[layoutMode.toUpperCase()];
        }
        var layoutCallback = LayoutCallbacks[layoutMode] || LayoutCallbacks[0];
        layoutCallback.call(this, config);

        this.addChildrenMap('background', background);
        this.addChildrenMap('header', header);
        this.addChildrenMap('leftSide', leftSide);
        this.addChildrenMap('content', content);
        this.addChildrenMap('rightSide', rightSide);
        this.addChildrenMap('footer', footer);

        return this;
    };

    const LayoutModesMap = {
        'FFF': 0,
        'LFF': 1,
        'FFR': 2,
        'LFR': 3
    };

    class HolyGrail extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            config.orientation = 1; // top-to-bottom
            // Create sizer
            super(scene, config);
            this.type = 'rexHolyGrail';

            this.build(config);
        }
    }

    var methods$f = {
        build: Build,
    };

    Object.assign(
        HolyGrail.prototype,
        methods$f,
    );

    ObjectFactory.register('holyGrail', function (config) {
        var gameObject = new HolyGrail(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.HolyGrail', HolyGrail);

    var ButtonMethods = {
        getButtonsSizer(groupName) {
            return this.childrenMap[`${groupName}ButtonsSizer`];
        },

        getButton(groupName, index) {
            var buttonsSizer = this.getButtonsSizer(groupName);
            return (buttonsSizer) ? buttonsSizer.getButton(index) : undefined;
        },

        setButtonEnable(groupName, index, enabled) {
            this.getButtonsSizer(groupName).setButtonEnable(index, enabled);
            return this;
        },

        setLeftButtonEnable(index, enabled) {
            this.childrenMap.leftButtonsSizer.setButtonEnable(index, enabled);
            return this;
        },

        setRightButtonEnable(index, enabled) {
            this.childrenMap.rightButtonsSizer.setButtonEnable(index, enabled);
            return this;
        },

        setTopButtonEnable(index, enabled) {
            this.childrenMap.topButtonsSizer.setButtonEnable(index, enabled);
            return this;
        },

        setBottomButtonEnable(index, enabled) {
            this.childrenMap.bottomButtonsSizer.setButtonEnable(index, enabled);
            return this;
        },

        toggleButtonEnable(groupName, index) {
            this.getButtonsSizer(groupName).toggleButtonEnable(index);
            return this;
        },

        toggleLeftButtonEnable(index) {
            this.childrenMap.leftButtonsSizer.toggleButtonEnable(index);
            return this;
        },

        toggleRightButtonEnable(index) {
            this.childrenMap.rightButtonsSizer.toggleButtonEnable(index);
            return this;
        },

        toggleTopButtonEnable(index) {
            this.childrenMap.topButtonsSizer.toggleButtonEnable(index);
            return this;
        },

        toggleBottomButtonEnable(index) {
            this.childrenMap.bottomButtonsSizer.toggleButtonEnable(index);
            return this;
        },

        getButtonEnable(groupName, index) {
            return this.getButtonsSizer(groupName).getButtonEnable(index);
        },

        getLeftButtonEnable(index) {
            return this.childrenMap.leftButtonsSizer.getButtonEnable(index);
        },

        getRightButtonEnable(index) {
            return this.childrenMap.rightButtonsSizer.getButtonEnable(index);
        },

        getTopButtonEnable(index) {
            return this.childrenMap.topButtonsSizer.getButtonEnable(index);
        },

        getBottomButtonEnable(index) {
            return this.childrenMap.bottomButtonsSizer.getButtonEnable(index);
        },

        emitButtonClick(groupName, index) {
            var buttonsSizer = this.getButtonsSizer(groupName);
            if (!buttonsSizer) {
                return this;
            }
            buttonsSizer.emitButtonClick(index);
            return this;
        },

        emitLeftButtonClick(index) {
            this.childrenMap.leftButtonsSizer.emitButtonClick(index);
            return this;
        },

        emitRightButtonClick(index) {
            this.childrenMap.rightButtonsSizer.emitButtonClick(index);
            return this;
        },

        emitTopButtonClick(index) {
            this.childrenMap.topButtonsSizer.emitButtonClick(index);
            return this;
        },

        emitBottomButtonClick(index) {
            this.childrenMap.bottomButtonsSizer.emitButtonClick(index);
            return this;
        },

        getLeftButton(index) {
            return this.childrenMap.leftButtonsSizer.getButton(index);
        },

        getRightButton(index) {
            return this.childrenMap.rightButtonsSizer.getButton(index);
        },

        getTopButton(index) {
            return this.childrenMap.topButtonsSizer.getButton(index);
        },

        getBottomButton(index) {
            return this.childrenMap.bottomButtonsSizer.getButton(index);
        },

        showButton(groupName, index) {
            Show(this.getButton(groupName, index));
            return this;
        },

        showLeftButton(index) {
            Show(this.getLeftButton(index));
            return this;
        },

        showRightButton(index) {
            Show(this.getRightButton(index));
            return this;
        },

        showTopButton(index) {
            Show(this.getTopButton(index));
            return this;
        },

        showBottomButton(index) {
            Show(this.getBottomButton(index));
            return this;
        },

        hideButton(groupName, index) {
            Hide(this.getButton(groupName, index));
            return this;
        },

        hideLeftButton(index) {
            Hide(this.getLeftButton(index));
            return this;
        },

        hideRightButton(index) {
            Hide(this.getRightButton(index));
            return this;
        },

        hideTopButton(index) {
            Hide(this.getTopButton(index));
            return this;
        },

        hideBottomButton(index) {
            Hide(this.getBottomButton(index));
            return this;
        },

        addButton(groupName, gameObject) {
            this.getButtonsSizer(groupName).addButton(gameObject);
            return this;
        },

        addLeftButton(gameObject) {
            this.addButton('left', gameObject);
            return this;
        },

        addRightButton(gameObject) {
            this.addButton('right', gameObject);
            return this;
        },

        addTopButton(gameObject) {
            this.addButton('top', gameObject);
            return this;
        },

        removeButton(groupName, index, destroyChild) {
            this.getButtonsSizer(groupName).removeButton(index, destroyChild);
            return this;
        },

        removeLeftButton(index, destroyChild) {
            this.removeButton('left', index, destroyChild);
            return this;
        },

        removeRightButton(index, destroyChild) {
            this.removeButton('right', index, destroyChild);
            return this;
        },

        removeTopButton(index, destroyChild) {
            this.removeButton('top', index, destroyChild);
            return this;
        },

        removeBottomButton(index, destroyChild) {
            this.removeButton('bottom', index, destroyChild);
            return this;
        },

        clearButtons(groupName, destroyChild) {
            this.getButtonsSizer(groupName).clearButtons(destroyChild);
            return this;
        },

        clearLeftButtons(destroyChild) {
            this.clearButtons('left', destroyChild);
            return this;
        },

        clearRightButtons(destroyChild) {
            this.clearButtons('right', destroyChild);
            return this;
        },

        clearTopButtons(destroyChild) {
            this.clearButtons('top', destroyChild);
            return this;
        },

        clearBottomButtonss(destroyChild) {
            this.clearButtons('bottom', destroyChild);
            return this;
        },

        forEachButton(groupName, callback, scope) {
            this.getButtonsSizer(groupName).forEachButtton(callback, scope);
            return this;
        },

        forEachLeftButton(callback, scope) {
            this.childrenMap.leftButtonsSizer.forEachButtton(callback, scope);
            return this;
        },

        forEachRightButton(callback, scope) {
            this.childrenMap.rightButtonsSizer.forEachButtton(callback, scope);
            return this;
        },

        forEachTopButton(callback, scope) {
            this.childrenMap.topButtonsSizer.forEachButtton(callback, scope);
            return this;
        },

        forEachBottomButton(callback, scope) {
            this.childrenMap.bottomButtonsSizer.forEachButtton(callback, scope);
            return this;
        },
    };

    const GetValue$1e = Phaser.Utils.Objects.GetValue;

    class Tabs extends GridSizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            // Create sizer
            config.column = 3;
            config.row = 3;
            config.columnProportions = [0, 0, 0];
            config.rowProportions = [0, 0, 0];

            var expandPanel = GetValue$1e(config, 'expand.panel', false);
            if (expandPanel) {
                config.columnProportions[1] = 1;
                config.rowProportions[1] = 1;
            }

            super(scene, config);
            this.type = 'rexTabs';
            this.eventEmitter = GetValue$1e(config, 'eventEmitter', this);

            // Add elements
            var background = GetValue$1e(config, 'background', undefined);
            var panel = GetValue$1e(config, 'panel', undefined);
            var leftButtons = GetValue$1e(config, 'leftButtons', undefined);
            var leftButtonsBackground = GetValue$1e(config, 'leftButtonsBackground', undefined);
            var leftButtonsSizer;
            var rightButtons = GetValue$1e(config, 'rightButtons', undefined);
            var rightButtonsBackground = GetValue$1e(config, 'rightButtonsBackground', undefined);
            var rightButtonsSizer;
            var topButtons = GetValue$1e(config, 'topButtons', undefined);
            var topButtonsBackground = GetValue$1e(config, 'topButtonsBackground', undefined);
            var topButtonsSizer;
            var bottomButtons = GetValue$1e(config, 'bottomButtons', undefined);
            var bottomButtonsBackground = GetValue$1e(config, 'bottomButtonsBackground', undefined);
            var bottomButtonsSizer;
            var clickConfig = GetValue$1e(config, 'click', undefined);

            if (background) {
                this.addBackground(background);
            }

            if (panel) {
                this.add(panel,
                    {
                        column: 1,
                        row: 1,
                        expand: expandPanel
                    }
                );
            }

            if (leftButtons) {
                var leftButtonsOffset = GetValue$1e(config, 'space.leftButtonsOffset', 0);
                var leftButtonSpace = GetValue$1e(config, 'space.leftButton', 0);
                var leftButtonExpand = GetValue$1e(config, 'expand.leftButtons', false);
                var leftButtonsAlign = GetValue$1e(config, 'align.leftButtons', 'top');
                leftButtonsSizer = new Buttons$1(scene, {
                    groupName: 'left',
                    background: leftButtonsBackground,
                    buttons: leftButtons,
                    orientation: 'y', // Top-Bottom
                    space: { item: leftButtonSpace },
                    expand: leftButtonExpand,
                    click: clickConfig,
                    eventEmitter: this.eventEmitter,
                });
                this.add(leftButtonsSizer,
                    {
                        column: 0,
                        row: 1,
                        align: leftButtonsAlign,
                        padding: { top: leftButtonsOffset, },
                        expand: leftButtonExpand
                    }
                );
            }

            if (rightButtons) {
                var rightButtonsOffset = GetValue$1e(config, 'space.rightButtonsOffset', 0);
                var rightButtonSpace = GetValue$1e(config, 'space.rightButton', 0);
                var rightButtonExpand = GetValue$1e(config, 'expand.rightButtons', false);
                var rightButtonsAlign = GetValue$1e(config, 'align.rightButtons', 'top');
                rightButtonsSizer = new Buttons$1(scene, {
                    groupName: 'right',
                    background: rightButtonsBackground,
                    buttons: rightButtons,
                    orientation: 'y', // Top-Bottom
                    space: { item: rightButtonSpace },
                    expand: rightButtonExpand,
                    click: clickConfig,
                    eventEmitter: this.eventEmitter,
                });
                this.add(rightButtonsSizer,
                    {
                        column: 2,
                        row: 1,
                        align: rightButtonsAlign,
                        padding: { top: rightButtonsOffset, },
                        expand: rightButtonExpand
                    }
                );
            }

            if (topButtons) {
                var toptButtonsOffset = GetValue$1e(config, 'space.topButtonsOffset', 0);
                var topButtonSpace = GetValue$1e(config, 'space.topButton', 0);
                var topButtonExpand = GetValue$1e(config, 'expand.topButtons', false);
                var topButtonsAlign = GetValue$1e(config, 'align.topButtons', 'left');
                topButtonsSizer = new Buttons$1(scene, {
                    groupName: 'top',
                    background: topButtonsBackground,
                    buttons: topButtons,
                    orientation: 'x', // Left-Right
                    space: { item: topButtonSpace },
                    expand: topButtonExpand,
                    align: GetValue$1e(config, 'align.topButtons', undefined),
                    click: clickConfig,
                    eventEmitter: this.eventEmitter,
                });
                this.add(topButtonsSizer,
                    {
                        column: 1,
                        row: 0,
                        align: topButtonsAlign,
                        padding: { left: toptButtonsOffset, },
                        expand: topButtonExpand
                    }
                );
            }

            if (bottomButtons) {
                var bottomButtonsOffset = GetValue$1e(config, 'space.bottomButtonsOffset', 0);
                var bottomButtonSpace = GetValue$1e(config, 'space.bottomButton', 0);
                var bottomButtonExpand = GetValue$1e(config, 'expand.bottomButtons', false);
                var bottomButtonsAlign = GetValue$1e(config, 'align.bottomButtons', 'left');
                bottomButtonsSizer = new Buttons$1(scene, {
                    groupName: 'bottom',
                    background: bottomButtonsBackground,
                    buttons: bottomButtons,
                    orientation: 'x', // Left-Right
                    space: { item: bottomButtonSpace },
                    expand: bottomButtonExpand,
                    align: GetValue$1e(config, 'align.bottomButtons', undefined),
                    click: clickConfig,
                    eventEmitter: this.eventEmitter,
                });
                this.add(bottomButtonsSizer,
                    {
                        column: 1,
                        row: 2,
                        align: bottomButtonsAlign,
                        padding: { left: bottomButtonsOffset, },
                        expand: bottomButtonExpand
                    }
                );
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('panel', panel);
            this.addChildrenMap('leftButtons', leftButtons);
            this.addChildrenMap('rightButtons', rightButtons);
            this.addChildrenMap('topButtons', topButtons);
            this.addChildrenMap('bottomButtons', bottomButtons);
            this.addChildrenMap('leftButtonsSizer', leftButtonsSizer);
            this.addChildrenMap('rightButtonsSizer', rightButtonsSizer);
            this.addChildrenMap('topButtonsSizer', topButtonsSizer);
            this.addChildrenMap('bottomButtonsSizer', bottomButtonsSizer);
        }
    }

    Object.assign(
        Tabs.prototype,
        ButtonMethods
    );

    ObjectFactory.register('tabs', function (config) {
        var gameObject = new Tabs(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Tabs', Tabs);

    ObjectFactory.register('slider', function (config) {
        var gameObject = new Slider(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Slider', Slider);

    class Cell {
        constructor(parent, config) {
            this.container = null;
            this._deltaHeight = 0;
            this.setParent(parent);
            // this.resetFromJSON(config);
        }

        setParent(parent) {
            this.parent = parent; // parent: table
            this.parentContainer = parent.getParentContainer();
        }

        // resetFromJSON(o) {
        //     return this;
        // }

        destroy(fromScene) {
            if (fromScene === undefined) {
                fromScene = false;
            }

            if (!fromScene) {
                this.destroyContainer();
            }

            this.deltaHeight = 0;
            this.data = undefined;
            this.container = null;
            this.parent = undefined;
            this.parentContainer = undefined;
        }

        get table() {
            return this.parent;
        }

        get scrollMode() {
            return this.parentContainer.scrollMode;
        }

        get colIndx() {
            return this.parent.cellIndxeToColIndex(this.index);
        }

        get rowIndx() {
            return this.parent.cellIndxeToRowIndex(this.index);
        }

        getContainer() {
            return this.container;
        }

        setContainer(container) {
            if (!container) {
                this.destroyContainer();
                return this;
            }

            if (this.container) {
                this.container.destroy();
            }
            this.container = container;
            this.parentContainer.add(container);
            return this;
        }

        destroyContainer() {
            if (this.container) {
                this.container.destroy();
                this.container = null;
            }
            return this;
        }

        popContainer() {
            if (this.container) {
                var container = this.container;
                this.container = null;
                this.parentContainer.remove(container);
                return container;
            } else {
                return null;
            }
        }

        setXY(x, y) {
            if (this.container) {
                this.parentContainer.setChildLocalPosition(this.container, x, y);
            }
            return this;
        }

        setCellContainerAlign(align) {
            if (typeof (align) === 'string') {
                align = AlignConst[align];
            }
            this.cellContainerAlign = align;
            return this;
        }

        get deltaHeight() {
            return this._deltaHeight;
        }

        set deltaHeight(deltaHeight) {
            if (deltaHeight == null) {
                deltaHeight = 0;
            }
            var table = this.parent;
            if ((this._deltaHeight === 0) && (deltaHeight !== 0)) {
                table.nonZeroDeltaHeightCount++;
            } else if ((this._deltaHeight !== 0) && (deltaHeight === 0)) {
                table.nonZeroDeltaHeightCount--;
            }

            var isTableHeightChanged = (this._deltaHeight !== deltaHeight);

            this._deltaHeight = deltaHeight;

            if (isTableHeightChanged) {
                table.resetTotalRowsHeight();
                var eventName = (this.scrollMode === 0) ? 'cellheightchange' : 'cellwidthchange';
                this.parentContainer.emit(eventName, this, this.container, this.parentContainer);
            }
        }

        get deltaWidth() {
            return this.deltaHeight;
        }

        set deltaWidth(deltaWidth) {
            this.deltaHeight = deltaWidth;
        }

        setDeltaHeight(deltaHeight) {
            this.deltaHeight = deltaHeight;
            return this;
        }

        setDeltaWidth(deltaWidth) {
            this.deltaHeight = deltaWidth;
            return this;
        }

        get height() {
            if (this.scrollMode === 0) {
                return this.deltaHeight + this.parent.defaultCellHeight;
            } else {
                return this.parent.defaultCellWidth;
            }
        }

        set height(height) {
            // Only worked when scrollMode is 0
            if (this.scrollMode === 1) {
                return;
            }
            this.setDeltaHeight(height - this.parent.defaultCellHeight);
        }

        setHeight(height) {
            // Only worked when scrollMode is 0
            this.height = height;
            return this;
        }

        get width() {
            if (this.scrollMode === 0) {
                return this.parent.defaultCellWidth;
            } else {
                return this.deltaHeight + this.parent.defaultCellHeight;
            }
        }

        set width(width) {
            // Only worked when scrollMode is 1
            if (this.scrollMode === 0) {
                return;
            }
            this.setDeltaHeight(width - this.parent.defaultCellHeight);
        }

        setWidth(width) {
            this.width = width;
            return this;
        }

        get scene() {
            return this.parentContainer.scene;
        }
    }

    Object.assign(
        Cell.prototype,
        DataMethods$2
    );

    const GetValue$1d = Phaser.Utils.Objects.GetValue;
    const SpliceOne = Phaser.Utils.Array.SpliceOne;

    class Table {
        constructor(parent, config) {
            this.parent = parent; // parent: GridTable game object (Container)
            this.cells = [];
            this.cellPool = new Stack();
            this.resetFromJSON(config);
        }

        resetFromJSON(o) {
            if (o === undefined) {
                o = {};
            }
            this.colCount = undefined;
            this.nonZeroDeltaHeightCount = 0;
            this.resetTotalRowsHeight();

            var cellHeight = o.cellHeight;
            if (cellHeight === undefined) {
                cellHeight = 60;
            }

            var cellWidth = o.cellWidth;
            if (cellWidth === undefined) {
                cellWidth = 60;
            }

            this.setDefaultCellHeight(cellHeight);
            this.setDefaultCellWidth(cellWidth);
            this.initCells(GetValue$1d(o, 'cellsCount', 0));
            this.setColumnCount(GetValue$1d(o, 'columns', 1));
            return this;
        }

        destroy(fromScene) {
            // GridTable is destroyed, all cell containers will also be destroyed too
            // Don't have to freeCell
            this.cellPool.destroy();
            this.cells = undefined;
            this.parent = undefined;
        }

        get defaultCellHeightMode() {
            return (this.nonZeroDeltaHeightCount === 0);
        }

        setDefaultCellHeight(height) {
            this.defaultCellHeight = height;
            return this;
        }

        setDefaultCellWidth(width) {
            this.defaultCellWidth = width;
            return this;
        }

        initCells(size) {
            var cells = this.cells;
            cells.length = size;
            for (var i = 0; i < size; i++) {
                cells[i] = null;
            }
            return this;
        }

        insertNewCells(cellIdx, count) {
            var cells = this.cells;
            if (cellIdx === cells.length) {
                // append at end of array
                var endIdx = cellIdx + count;
                cells.legth = endIdx;
                for (var i = cellIdx; i < endIdx; i++) {
                    cells[i] = null;
                }
            } else {
                var newCells = [];
                newCells.length = count;
                for (var i = 0; i < count; i++) {
                    newCells[i] = null;
                }
                this.cells.splice(cellIdx, 0, ...newCells);
            }

            this.resetTotalRowsHeight();
            return this;
        }

        removeCells(cellIdx, count) {
            var endIdx = cellIdx + count;
            for (var i = cellIdx; i < endIdx; i++) {
                this.freeCell(i);
            }

            if (endIdx === this.cells.length) {
                // remove until end of array
                this.cells.length = cellIdx;
            } else {
                if (count === 1) {
                    SpliceOne(this.cells, cellIdx);
                } else {
                    this.cells.splice(cellIdx, count);
                }
                this.buildCellIndex(cellIdx);
            }

            this.resetTotalRowsHeight();
            return this;
        }

        setColumnCount(columns) {
            this.colCount = columns;

            this.resetTotalRowsHeight();

            // Set cellWith according to parent width/height and columns
            var parent = this.parent;
            if (parent.expandCellSize) {
                var width = (parent.scrollMode === 0) ? parent.width : parent.height;
                var cellWidth = width / columns;
                this.setDefaultCellWidth(cellWidth);
            }

            return this;
        }

        get rowCount() {
            return Math.ceil(this.cells.length / this.colCount);
        }

        get cellsCount() {
            return this.cells.length;
        }

        isValidCellIdx(idx) {
            return ((idx >= 0) && (idx < this.cells.length));
        }

        heightToRowIndex(height, roundMode) {
            if (roundMode === undefined) {
                roundMode = 0;
            }
            /*
            roundMode:
            - 0 : floor
            - 1 : ceil
            - 2 :             
                - Default : floor
                - Vary : plus one if rowIdx is an integer, else floor
            */

            if (height === 0) {
                return 0;
            }

            // defaultCellHeightMode
            if (this.defaultCellHeightMode) {
                var rowIdx = height / this.defaultCellHeight;
                switch (roundMode) {
                    case 1:
                        rowIdx = Math.ceil(rowIdx);
                        break;

                    default: // 0, 2
                        rowIdx = Math.floor(rowIdx);
                        break;
                }

                return rowIdx;
            }

            // count cell height one by one
            var rowCount = this.rowCount;
            var remainder = height,
                isValidIdx;
            var rowHeight, rowIdx = 0;

            while (1) {
                rowHeight = this.getRowHeight(rowIdx);
                remainder -= rowHeight;

                isValidIdx = (rowIdx >= 0) && (rowIdx < rowCount);
                if ((remainder > 0) && isValidIdx) {
                    rowIdx += 1;
                } else if (remainder === 0) {
                    if (roundMode === 2) {
                        rowIdx += 1;
                    }
                    return rowIdx;
                } else {
                    if (roundMode === 1) {
                        var preRowIdx = rowIdx;
                        rowIdx += 1;
                        isValidIdx = (rowIdx >= 0) && (rowIdx < rowCount);

                        if (!isValidIdx) {
                            rowIdx = preRowIdx;
                        }
                    }

                    return rowIdx;
                }
            }

        }

        widthToColIndex(width, isCeil) {
            if (width === 0) {
                return 0;
            }

            var colIdx = width / this.defaultCellWidth;
            if (isCeil) {
                colIdx = Math.ceil(colIdx);
            } else {
                colIdx = Math.floor(colIdx);
            }

            return colIdx;
        }

        colRowToCellIndex(colIdx, rowIdx) {
            if (colIdx >= this.colCount) {
                return null;
            }
            return (rowIdx * this.colCount) + colIdx;
        }

        rowIndexToHeight(start, end) {
            // defaultCellHeightMode
            if (this.defaultCellHeightMode) {
                return (end - start + 1) * this.defaultCellHeight;
            }

            var h, sum = 0;
            for (var i = start; i <= end; i++) {
                h = this.getRowHeight(i);
                sum += h;
            }

            return sum;
        }

        colIndexToWidth(start, end) {
            return (end - start + 1) * this.defaultCellWidth;
        };

        getRowHeight(rowIdx) {
            var cnt = this.colCount;
            // single column
            if (cnt <= 1) {
                return this.getCellHeight(this.colRowToCellIndex(0, rowIdx));
            }

            // multiple columns, get the maximum height
            var maxHeight = 0,
                cellHeight;
            for (var i = 0; i < cnt; i++) {
                cellHeight = this.getCellHeight(this.colRowToCellIndex(i, rowIdx));
                if (maxHeight < cellHeight)
                    maxHeight = cellHeight;
            }
            return maxHeight;
        }

        getColWidth(idx) {
            return this.defaultCellWidth;
        }

        getCellHeight(cellIdx) {
            if (!this.isValidCellIdx(cellIdx)) {
                return 0;
            }

            var cellHeight;
            if (this.defaultCellHeightMode)
                cellHeight = this.defaultCellHeight;
            else {
                var cell = this.getCell(cellIdx, false);
                var deltaHeight = (cell) ? cell.deltaHeight : 0;
                cellHeight = this.defaultCellHeight + deltaHeight;
            }

            return cellHeight;
        }

        resetTotalRowsHeight() {
            this._totalRowsHeight = null;
        }

        get totalRowsHeight() {
            if (this._totalRowsHeight === null) {
                this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1);
            }

            return this._totalRowsHeight;
        }

        get totalColumnWidth() {
            return this.colCount * this.defaultCellWidth;
        }

        cellIndxeToColIndex(cellIdx) {
            return cellIdx % this.colCount;
        }

        cellIndxeToRowIndex(cellIdx) {
            return Math.floor(cellIdx / this.colCount);
        }

        getCell(cellIdx, createNewCell) {
            if (!this.isValidCellIdx(cellIdx)) {
                return null;
            }

            if (createNewCell === undefined) {
                createNewCell = true;
            }
            if ((this.cells[cellIdx] === null) && createNewCell) {
                var cell = this.newCell(cellIdx);
                this.cells[cellIdx] = cell;
            }

            return this.cells[cellIdx];
        }

        newCell(cellIdx) {
            var cell = this.cellPool.pop();
            if (cell === null) {
                cell = new Cell(this);
            } else {
                cell.setParent(this);
            }
            cell.index = cellIdx;

            return cell;
        }

        buildCellIndex(startIdx) {
            if (startIdx === undefined) {
                startIdx = 0;
            }
            var cells = this.cells,
                cell;
            for (var i = startIdx, len = cells.length; i < len; i++) {
                cell = cells[i];
                if (cell) {
                    cell.index = i;
                }
            }
            return this;
        }

        getParentContainer() {
            return this.parent;
        }

        freeCell(cell) {
            if (typeof (cell) === 'number') {
                cell = this.cells[cell];
            }

            if (!cell) {
                return this;
            }

            cell.destroy();
            this.cellPool.push(cell);
            return this;
        }
    }

    var SetTableOY = function (oy) {
        var table = this.table;
        var topTableOY = this.topTableOY;
        var bottomTableOY = this.bottomTableOY;
        var tableOYExceedTop = (oy > topTableOY);
        var tableOYExeceedBottom = (oy < bottomTableOY);
        if (this.clampTableOXY) {
            var rowCount = table.rowCount;
            var visibleRowCount = table.heightToRowIndex(this.instHeight, 1);

            // less then 1 page
            if (rowCount < visibleRowCount) {
                oy = 0;
            } else if (tableOYExceedTop) {
                oy = topTableOY;
            } else if (tableOYExeceedBottom) {
                oy = bottomTableOY;
            }
        }

        if (this._tableOY !== oy) {
            this._tableOY = oy;
        }


        if (tableOYExceedTop) {
            if (!this.execeedTopState) {
                this.emit('execeedtop', this, oy, topTableOY);
            }
        }
        this.execeedTopState = tableOYExceedTop;

        if (tableOYExeceedBottom) {
            if (!this.execeedBottomState) {
                this.emit('execeedbottom', this, oy, bottomTableOY);
            }
        }
        this.execeedBottomState = tableOYExeceedBottom;
        return this;
    };

    var SetTableOX = function (ox) {
        var table = this.table;
        var leftTableOX = this.leftTableOX;
        var rightTableOX = this.rightTableOX;
        var tableOXExeceedLeft = (ox > this.leftTableOX);
        var tableOXExeceedRight = (ox < this.rightTableOX);
        if (this.clampTableOXY) {
            var colCount = table.colCount;
            var visibleColCount = table.widthToColIndex(this.instWidth, true);

            // less then 1 page            
            if (colCount < visibleColCount) {
                ox = 0;
            } else if (tableOXExeceedLeft) {
                ox = leftTableOX;
            } else {
                // var tableVisibleWidth = this.tableVisibleWidth;
                if (tableOXExeceedRight)
                    ox = rightTableOX;
            }
        }

        if (this._tableOX !== ox) {
            this._tableOX = ox;
        }

        if (tableOXExeceedLeft) {
            if (!this.execeedLeftState) {
                this.emit('execeedleft', this, ox, leftTableOX);
            }
        }
        this.execeedLeftState = tableOXExeceedLeft;

        if (tableOXExeceedRight) {
            if (!this.execeedRightState) {
                this.emit('execeedright', this, ox, rightTableOX);
            }
        }
        this.execeedRightState = tableOXExeceedRight;
        return this;
    };

    var MaskToGameObject = function (mask) {
        return (mask.hasOwnProperty('geometryMask')) ? mask.geometryMask : mask.bitmapMask;
    };

    const Intersects = Phaser.Geom.Intersects.RectangleToRectangle;
    const Overlaps = Phaser.Geom.Rectangle.Overlaps;

    var MaskChildren = function ({
        parent, mask, children,    
        onVisible, onInvisible, scope,
    }) {

        if (!mask) {
            return;
        }

        if (children === undefined) {
            children = parent.getAllChildren();
        }

        var hasAnyVisibleCallback = !!onVisible || !!onInvisible;

        var parentBounds = parent.getBounds();
        var maskGameObject = MaskToGameObject(mask);

        var child, childBounds, visiblePointsNumber;
        var isChildVisible;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];

            if (child === maskGameObject) {
                continue;
            }
            if (!IsVisible(child)) {  // Child is invisible before masking
                continue;
            }

            isChildVisible = child.visible;
            if (child.getBounds) {
                childBounds = child.getBounds(childBounds);
                visiblePointsNumber = ContainsPoints(parentBounds, childBounds);
                switch (visiblePointsNumber) {
                    case 4: // 4 points are all inside visible window, set visible                     
                        ShowAll(parent, child);
                        break;
                    case 0: // No point is inside visible window
                        // Parent intersects with child, or parent is inside child, set visible, and apply mask
                        if (Intersects(parentBounds, childBounds) || Overlaps(parentBounds, childBounds)) {
                            ShowSome(parent, child, mask);
                        } else { // Set invisible
                            ShowNone(parent, child);
                        }
                        break;
                    default: // Part of points are inside visible window, set visible, and apply mask
                        ShowSome(parent, child, mask);
                        break;
                }
            } else {
                ShowSome(parent, child, mask);
            }

            if (hasAnyVisibleCallback && (child.visible !== isChildVisible)) {
                var callback = (child.visible) ? onVisible : onInvisible;
                if (callback) {
                    if (scope) {
                        callback.call(scope, child, parent);
                    } else {
                        callback(child, parent);
                    }
                }
            }
        }
    };

    var IsVisible = function (gameObject) {
        if (!gameObject.displayList) {
            return false;
        }

        while (1) {
            var localState = gameObject.rexContainer;
            if (!localState) { // Top game object
                return gameObject.visible;
            } else if (localState.visible) {
                var parent = localState.parent;
                if (parent) { // Test parent's visible
                    gameObject = parent;
                    continue;
                } else { // Top visible game object
                    return true;
                }
            } else { // Current game object is invisible
                return false;
            }
        }
    };

    var ContainsPoints = function (rectA, rectB) {
        var top = rectB.top,
            bottom = rectB.bottom,
            left = rectB.left,
            right = rectB.right;

        var result = 0;
        result += rectA.contains(left, top) ? 1 : 0;
        result += rectA.contains(left, bottom) ? 1 : 0;
        result += rectA.contains(right, top) ? 1 : 0;
        result += rectA.contains(right, bottom) ? 1 : 0;
        return result;
    };

    var ShowAll = function (parent, child, mask) {
        if (!child.hasOwnProperty('isRexContainerLite')) {
            if (child.clearMask) {
                child.clearMask();
            }

            parent.setChildMaskVisible(child, true);

        } else {
            child.syncChildrenEnable = false;
            parent.setChildMaskVisible(child, true);
            child.syncChildrenEnable = true;

        }

    };

    var ShowSome = function (parent, child, mask) {
        if (!child.hasOwnProperty('isRexContainerLite')) {
            if (child.setMask) {
                child.setMask(mask);
            }

            parent.setChildMaskVisible(child, true);

        } else {
            child.syncChildrenEnable = false;
            parent.setChildMaskVisible(child, true);
            child.syncChildrenEnable = true;

        }

    };

    var ShowNone = function (parent, child, mask) {
        if (!child.hasOwnProperty('isRexContainerLite')) {
            if (child.clearMask) {
                child.clearMask();
            }

            parent.setChildMaskVisible(child, false);

        } else {
            child.syncChildrenEnable = false;
            parent.setChildMaskVisible(child, false);
            child.syncChildrenEnable = true;

        }


    };

    const GetValue$1c = Phaser.Utils.Objects.GetValue;

    const MASKUPDATEMODE = {
        update: 0,
        everyTick: 1
    };

    var ChildrenMaskMethods = {
        setupChildrenMask(config) {
            if (config === false) {
                // No children mask
                return this;
            }

            this.setMaskUpdateMode(GetValue$1c(config, 'updateMode', 0));
            this.enableChildrenMask(GetValue$1c(config, 'padding', 0));
            this.setMaskLayer(GetValue$1c(config, 'layer', undefined));

            this.onMaskGameObjectVisible = GetValue$1c(config, 'onVisible');
            this.onMaskGameObjectInvisible = GetValue$1c(config, 'onInvisible');
            this.maskGameObjectCallbackScope = GetValue$1c(config, 'scope');

            this.startMaskUpdate();

            return this;
        },

        destroyChildrenMask() {
            if (!this.childrenMask) {
                return this;
            }

            this.stopMaskUpdate();
            this.childrenMask.destroy();
            this.childrenMask = undefined;

            this.onMaskGameObjectVisible = null;
            this.onMaskGameObjectInvisible = null;
            this.maskGameObjectCallbackScope = null;

            return this;
        },

        setMaskUpdateMode(mode) {
            if (typeof (mode) === 'string') {
                mode = MASKUPDATEMODE[mode];
            }
            this.maskUpdateMode = mode;
            return this;
        },

        startMaskUpdate() {
            this.scene.game.events.on('poststep', this.maskChildren, this);
        },

        stopMaskUpdate() {
            this.scene.game.events.off('poststep', this.maskChildren, this);
        },

        enableChildrenMask(maskPadding) {
            var maskGameObject = AddChildMask.call(this, null, this, 0, maskPadding);
            this.childrenMask = maskGameObject.createGeometryMask();
            // this.childrenMask is a mask object, not a (Graphics) game object
            return this;
        },

        setMaskChildrenFlag(value) {
            if (value === undefined) {
                value = true;
            }
            this.maskChildrenFlag = value;
            return this;
        },

        setMaskLayer(layer) {
            // To reduce amount of masked game object
            this.maskLayer = layer;
            return this;
        },

        maskChildren() {
            if (
                (!this.childrenMask) ||                // No childrenMask
                (!this.maskChildrenFlag) ||            // No maskChildrenFlag set
                (this.alpha === 0) || (!this.visible)  // Parent is not visible
            ) {
                return this;
            }

            if (this.privateRenderLayer) {
                this.privateRenderLayer.setMask(this.childrenMask);

            } else if (this.maskLayer) {
                // 1. Add parent and children into layer
                this.addToLayer(this.maskLayer);
                // 2. Mask this layer
                this.maskLayer.setMask(this.childrenMask);

            } else {
                MaskChildren({
                    parent: this,
                    mask: this.childrenMask,

                    onVisible: this.onMaskGameObjectVisible,
                    onInvisible: this.onMaskGameObjectInvisible,
                    scope: this.maskGameObjectCallbackScope
                });

            }

            if (this.maskUpdateMode === 0) {
                this.maskChildrenFlag = false;
            }
            return this;
        },

        layoutChildrenMask() {
            if (!this.childrenMask) {
                return this;
            }

            var maskGameObject = MaskToGameObject(this.childrenMask);
            maskGameObject.setPosition().resize();
            this.resetChildPositionState(maskGameObject);
            return this;
        }
    };

    var ShowCells = function () {
        if (this.cellsCount === 0) {
            return;
        }

        // Save scale
        var scaleXSave = this.scaleX;
        var scaleYSave = this.scaleY;
        var scale1 = (scaleXSave === 1) && (scaleYSave === 1);
        if (!scale1) {
            this.setScale(1);
        }

        var table = this.table;

        var tableOYOffset = this.tableOYOffset;
        var tableOY = this.tableOY + tableOYOffset,
            tableOX = this.tableOX;

        this.startRowIndex = Math.max(table.heightToRowIndex(-tableOY, 2), 0);
        var rowIndex = this.startRowIndex;

        var startColumnIndex = Math.max(table.widthToColIndex(-tableOX), 0);
        var columnIndex = startColumnIndex;

        var cellIdx = table.colRowToCellIndex(columnIndex, rowIndex);
        var bottomBound = this.bottomBound;
        var rightBound = this.rightBound;
        var lastIdx = table.cellsCount - 1;
        var lastColIdx = table.colCount - 1;

        var startCellTLX = this.getCellTLX(columnIndex),
            cellTLX = startCellTLX;
        var startCellTLY = this.getCellTLY(rowIndex) + tableOYOffset,
            cellTLY = startCellTLY;
        while ((cellTLY < bottomBound) && (cellIdx <= lastIdx)) {
            if (this.table.isValidCellIdx(cellIdx)) {
                var cell = table.getCell(cellIdx, true);
                this.visibleCells.set(cell);
                if (!this.preVisibleCells.contains(cell)) {
                    this.showCell(cell);
                }

                var x, y;
                if (this.scrollMode === 0) {
                    x = cellTLX;
                    y = cellTLY;
                } else {
                    x = cellTLY;
                    y = cellTLX;
                }
                if (cell.cellContainerAlign == null) {
                    cell.setXY(x, y);
                } else {
                    var cellContainer = cell.getContainer();
                    AlignIn(cellContainer, x, y, cell.width, cell.height, cell.cellContainerAlign);
                    cell.setXY(cellContainer.x, cellContainer.y);
                }
            }

            if ((cellTLX < rightBound) && (columnIndex < lastColIdx)) {
                cellTLX += table.getColWidth(columnIndex);
                columnIndex += 1;
            } else {
                cellTLX = startCellTLX;
                cellTLY += table.getRowHeight(rowIndex);

                columnIndex = startColumnIndex;
                rowIndex += 1;
            }

            cellIdx = table.colRowToCellIndex(columnIndex, rowIndex);
        }

        // Restore scale
        if (!scale1) {
            this.setScale(scaleXSave, scaleYSave);
        }
    };

    var ShowCell = function (cell) {
        // Attach container to cell by cell.setContainer(container) under this event
        var reusedCellContainer = null;
        var cellContainer = cell.getContainer();
        if (cellContainer) {
            reusedCellContainer = cellContainer;
            cell.popContainer();
        } else if (this.cellContainersPool) {
            reusedCellContainer = this.cellContainersPool.getFirstDead();
            if (reusedCellContainer !== null) { // Reuse this game object
                reusedCellContainer.setActive(true).setVisible(true);
            }
        }

        this.emit('cellvisible', cell, reusedCellContainer, this);

        if (this.cellContainersPool) {
            var cellContainer = cell.getContainer();
            if (cellContainer) {
                if (reusedCellContainer === null) {
                    this.cellContainersPool.add(cellContainer); // New cell container, add to pool
                } else if (reusedCellContainer !== cellContainer) {
                    // Why reusedCellContainer is not equal to cellContainer?
                    this.cellContainersPool.add(cellContainer); // New cell container, add to pool
                    this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
                }
            } else { // No cell container added
                if (reusedCellContainer !== null) {
                    this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
                }
            }
        }
    };

    var GetCellTLX = function (colIdx) {
        var ox = (this.scrollMode === 0) ? this.topLeftX : this.topLeftY;
        var x = this.tableOX + this.table.colIndexToWidth(0, colIdx - 1) + ox;
        return x;
    };

    var GetCellTLY = function (rowIdx) {
        var oy = (this.scrollMode === 0) ? this.topLeftY : this.topLeftX;
        var y = this.tableOY + this.table.rowIndexToHeight(0, rowIdx - 1) + oy;
        return y;
    };

    var HideCells = function () {
        var preList = this.preVisibleCells;
        var curList = this.visibleCells;
        preList.iterate(function (cell) {
            if (!curList.contains(cell)) {
                this.hideCell(cell);
            }
        }, this);
    };

    var HideCell = function (cell) {
        // Option: pop container of cell by cell.popContainer() under this event 
        this.emit('cellinvisible', cell);

        if (this.cellContainersPool) {
            var cellContainer = cell.popContainer(); // null if already been removed
            if (cellContainer) {
                cellContainer.setScale(1).setAlpha(1);
                this.cellContainersPool.killAndHide(cellContainer);
            }
        }

        cell.destroyContainer(); // Destroy container of cell
    };

    var UpdateTable = function (refresh, maskChildren) {
        if (refresh === undefined) {
            refresh = false;
        }
        if (maskChildren === undefined) {
            maskChildren = false;
        }

        if (refresh) {
            ClearVisibleCellIndexes.call(this);
            this.hideCells();
        }
        ClearVisibleCellIndexes.call(this);
        this.showCells();
        this.hideCells();

        this.setMaskChildrenFlag();

        if (maskChildren) {
            // Layout children-mask
            this.layoutChildrenMask();
            // Re-mask children
            this.maskChildren();
        }

        return this;
    };

    var ClearVisibleCellIndexes = function () {
        var tmp = this.preVisibleCells;
        this.preVisibleCells = this.visibleCells;
        this.visibleCells = tmp;
        this.visibleCells.clear();
    };

    var IsCellVisible = function (cellIdx) {
        var cell = this.table.getCell(cellIdx, false);
        return cell && this.visibleCells.contains(cell);
    };

    var PointToCellIndex = function (x, y) {
        y -= (this.y + this.topLeftY);
        x -= (this.x + this.topLeftX);
        var offsetTableOY = this.tableOY - ((this.scrollMode === 0) ? y : x);
        var offsetTableOX = this.tableOX - ((this.scrollMode === 0) ? x : y);

        var table = this.table;
        var rowIdx = table.heightToRowIndex(-offsetTableOY, 0);
        var colIdx = table.widthToColIndex(-offsetTableOX);
        var cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
        if (cellIdx === null) {
            return null;
        }
        if (!this.isCellVisible(cellIdx)) {
            return null;
        }
        return cellIdx;
    };

    var PointToCellContainer = function (x, y) {
        var cellIdx = PointToCellIndex.call(this, x, y);
        if (cellIdx === null) {
            return undefined;
        }
        return this.getCellContainer(cellIdx);
    };

    // For when you know this Set will be modified during the iteration
    var EachVisibleCell = function (callback, scope) {
        this.visibleCells.each(callback, scope);
        return this;
    };

    // For when you absolutely know this Set won't be modified during the iteration
    var IterateVisibleCell = function (callback, scope) {
        this.visibleCells.iterate(callback, scope);
        return this;
    };

    var EachCell = function (callback, scope) {
        this.table.cells.slice().forEach(callback, scope);
        return this;
    };

    var IterateCell = function (callback, scope) {
        this.table.cells.forEach(callback, scope);
        return this;
    };

    var SetCellsCount = function (count) {
        var cellsCount = this.cellsCount;
        if (cellsCount === count) {
            return this;
        }

        if (cellsCount > count) {
            this.removeCells(count, cellsCount - count);
        } else { // cellsCount < count
            this.insertNewCells(cellsCount, count - cellsCount);
        }
        return this;
    };

    const Clamp$4 = Phaser.Math.Clamp;

    var InsertNewCells = function (cellIdx, count) {
        if (typeof (cellIdx) === 'object') {
            cellIdx = cellIdx.index;
        }
        if (count === undefined) {
            count = 1;
        }
        if (count <= 0) {
            return this;
        }
        cellIdx = Clamp$4(cellIdx, 0, this.cellsCount);
        this.table.insertNewCells(cellIdx, count);
        return this;
    };

    var RemoveCells = function (cellIdx, count) {
        if (typeof (cellIdx) === 'object') {
            cellIdx = cellIdx.index;
        }
        if (count === undefined) {
            count = 1;
        }
        if (cellIdx < 0) {
            count += cellIdx;
            cellIdx = 0;
        }
        if (count <= 0) {
            return this;
        }
        // out-of-range
        if (cellIdx > this.cellsCount) {
            return this;
        }

        var cell;
        for (var i = cellIdx, endIdx = cellIdx + count; i < endIdx; i++) {
            cell = this.getCell(i, false);
            if (cell) {
                if (this.visibleCells.contains(cell)) {
                    HideCell.call(this, cell);
                    this.visibleCells.delete(cell);
                }
                this.preVisibleCells.delete(cell);
            }
        }

        this.table.removeCells(cellIdx, count);
        return this;
    };

    var SetColumnCount = function (count) {
        if (this.table.colCount === count) {
            return this;
        }
        this.table.setColumnCount(count);
        return this;
    };

    var SetGridSize = function (colCount, rowCount) {
        this.setCellsCount(colCount * rowCount);
        this.table.setColumnCount(colCount);
        return this;
    };

    var UpdateVisibleCell = function (cellIdx) {
        var cell = this.table.getCell(cellIdx, false);
        if (!cell || !cell.container) {
            return this;
        }

        ShowCell.call(this, cell);

        return this;
    };

    var methods$e = {
        setTableOY: SetTableOY,
        setTableOX: SetTableOX,

        showCells: ShowCells,
        showCell: ShowCell,
        getCellTLX: GetCellTLX,
        getCellTLY: GetCellTLY,
        hideCells: HideCells,
        hideCell: HideCell,
        updateTable: UpdateTable,

        isCellVisible: IsCellVisible,
        pointToCellIndex: PointToCellIndex,
        pointToCellContainer: PointToCellContainer,
        eachVisibleCell: EachVisibleCell,
        iterateVisibleCell: IterateVisibleCell,
        eachCell: EachCell,
        iterateCell: IterateCell,

        setCellsCount: SetCellsCount,
        insertNewCells: InsertNewCells,
        removeCells: RemoveCells,
        setColumnCount: SetColumnCount,
        setGridSize: SetGridSize,
        updateVisibleCell: UpdateVisibleCell
    };

    Object.assign(
        methods$e,
        ChildrenMaskMethods
    );

    const Group = Phaser.GameObjects.Group;
    const Set = Phaser.Structs.Set;
    const GetValue$1b = Phaser.Utils.Objects.GetValue;

    let GridTable$1 = class GridTable extends ContainerLite {
        constructor(scene, x, y, width, height, config) {
            if (config === undefined) {
                config = {};
            }
            super(scene, x, y, width, height);
            this.type = 'rexGridTable';
            this._tableOX = 0;
            this._tableOY = 0;
            this.visibleCells = new Set();
            this.preVisibleCells = new Set();
            this.execeedTopState = false;
            this.execeedBottomState = false;
            this.execeedLeftState = false;
            this.execeedRightState = false;

            var reuseCellContainer = GetValue$1b(config, 'reuseCellContainer', false);
            if (reuseCellContainer) {
                this.cellContainersPool = new Group(scene); // Don't add Group into update list, I will destroy it manually
            }

            var callback = GetValue$1b(config, 'cellVisibleCallback', null);
            if (callback !== null) {
                var scope = GetValue$1b(config, 'cellVisibleCallbackScope', undefined);
                this.on('cellvisible', callback, scope);
            }
            callback = GetValue$1b(config, 'cellInvisibleCallback', null);
            if (callback !== null) {
                var scope = GetValue$1b(config, 'cellInvisibleCallbackScope', undefined);
                this.on('cellinvisible', callback, scope);
            }

            if (GetValue$1b(config, 'enableLayer', false)) {
                this.enableLayer();
            }

            this.setupChildrenMask(GetValue$1b(config, 'mask', undefined));

            this.setScrollMode(GetValue$1b(config, 'scrollMode', 0));
            this.setClampMode(GetValue$1b(config, 'clampTableOXY', true));
            this.setStartFromBottomEnable(GetValue$1b(config, 'startFromBottom', false));

            // Pre-process cell size
            var cellWidth, cellHeight, columns;
            var scrollY = (this.scrollMode === 0);
            if (scrollY) {  // scroll y
                cellWidth = config.cellWidth;
                cellHeight = config.cellHeight;
                columns = config.columns;
            } else {  // scroll x
                cellWidth = config.cellHeight;
                cellHeight = config.cellWidth;
                columns = GetValue$1b(config, 'rows', config.columns);
            }

            this.fixedCellSize = GetValue$1b(config, 'fixedCellSize', false);
            this.expandCellSize = (!this.fixedCellSize) && (cellWidth === undefined);

            if (!columns) {
                columns = 1;  // Default columns
            }
            if (this.fixedCellSize) {
                columns = Math.max(Math.floor(this.instWidth / cellWidth), 1);
            } else if (this.expandCellSize) {
                var width = (scrollY) ? this.width : this.height;
                cellWidth = width / columns;
            }

            config.cellWidth = cellWidth;
            config.cellHeight = cellHeight;
            config.columns = columns;

            this.table = new Table(this, config);

            this.updateTable();
        }

        destroy(fromScene) {  // preDestroy method does not have fromScene parameter
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.destroyChildrenMask();

            this.table.destroy(fromScene);
            this.table = undefined;
            if (this.cellContainersPool) {
                this.cellContainersPool.destroy(true);
                this.cellContainersPool = undefined;
            }

            super.destroy(fromScene);
        }

        setScrollMode(mode) {
            if (typeof (mode) === 'string') {
                mode = SCROLLMODE[mode.toLowerCase()];
            }
            this.scrollMode = mode;
            return this;
        }

        setClampMode(mode) {
            if (mode === undefined) {
                mode = true;
            }
            this.clampTableOXY = mode;
            return this;
        }

        setStartFromBottomEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.startFromBottomEnable = enable;
            return this;
        }

        get tableOY() {
            return this._tableOY;
        }

        get tableOX() {
            return this._tableOX;
        }

        set tableOY(oy) {
            this.setTableOY(oy).updateTable();
        }

        set tableOX(ox) {
            this.setTableOX(ox).updateTable();
        }

        setTableOXY(ox, oy) {
            this.setTableOY(oy).setTableOX(ox);
            return this;
        }

        addTableOY(dy) {
            this.setTableOY(this.tableOY + dy);
            return this;
        }

        addTableOX(dx) {
            this.setTableOX(this.tableOX + dx);
            return this;
        }

        addTableOXY(dx, dy) {
            this.addTableOY(dy).addTableOX(dx);
            return this;
        }

        setTableOYByPercentage(percentage) {
            this.setTableOY(-this.tableVisibleHeight * percentage);
            return this;
        }

        getTableOYPercentage() {
            var tableVisibleHeight = this.tableVisibleHeight;
            if (tableVisibleHeight === 0) {
                return 0;
            }
            return (this.tableOY / -tableVisibleHeight);
        }

        setTableOXByPercentage(percentage) {
            this.setTableOX(-this.tableVisibleWidth * percentage);
            return this;
        }

        getTableOXPercentage() {
            var tableVisibleWidth = this.tableVisibleWidth;
            if (tableVisibleWidth === 0) {
                return 0;
            }
            return (this.tableOX / -tableVisibleWidth);
        }

        set t(value) {
            this.setTableOYByPercentage(value).updateTable();
        }

        get t() {
            return this.getTableOYPercentage();
        }

        set s(value) {
            this.setTableOXByPercentage(value).updateTable();
        }

        get s() {
            return this.getTableOXPercentage();
        }

        scrollToBottom() {
            this.t = 1;
            // t will be 0 if table does not exceed visible area
            if (this.t === 0) {
                return this;
            }

            // Table height might be expanded while cells are visible        
            do {
                this.t = 1;
            } while (this.t !== 1)

            return this;
        }

        scrollToRow(rowIndex) {
            // To get all height of cells
            this.scrollToBottom();

            var height = this.table.rowIndexToHeight(0, rowIndex - 1);
            this.setTableOY(-height).updateTable();
            return this;
        }

        scrollToNextRow(rowCount) {
            if (rowCount === undefined) {
                rowCount = 1;
            }
            this.scrollToRow(this.startRowIndex + rowCount);
            return this;
        }

        getCell(cellIdx) {
            return this.table.getCell(cellIdx, true);
        }

        getCellContainer(cellIdx) {
            var cell = this.table.getCell(cellIdx, false);
            var container;
            if (cell) {
                container = cell.getContainer();
            }
            return container;
        }

        get cellsCount() {
            return this.table.cellsCount;
        }

        get columnCount() {
            return this.table.colCount;
        }

        setCellHeight(cellIdx, height) {
            var cell;
            if (typeof (cellIdx) === 'number') {
                cell = this.table.getCell(cellIdx, true);
            } else {
                cell = cellIdx;
            }
            cell.height = height; // Only worked when scrollMode is 0
            return this;
        }

        setCellWidth(cellIdx, width) {
            var cell;
            if (typeof (cellIdx) === 'number') {
                cell = this.table.getCell(cellIdx, true);
            } else {
                cell = cellIdx;
            }
            cell.width = width; // Only worked when scrollMode is 1
            return this;
        }

        resetAllCellsSize(width, height) {
            // Swap width and height if scrollMode is 1
            if (this.scrollMode === 1) {
                var temp = width;
                width = height;
                height = temp;
            }

            this.table
                .setDefaultCellHeight(height)
                .setDefaultCellWidth(width);

            var cells = this.table.cells;
            for (var i = 0, cnt = cells.length; i < cnt; i++) {
                var cell = cells[i];
                if (!cell) {
                    continue;
                }
                cell.deltaHeight = 0;
            }

            if (this.fixedCellSize) {
                var colCount = Math.floor(this.instWidth / width);
                this.table.setColumnCount(colCount);
            }

            this.updateTable(true, true);

            return this;
        }

        get instHeight() {
            return (this.scrollMode === 0) ? this.height : this.width;
        }

        get instWidth() {
            return (this.scrollMode === 0) ? this.width : this.height;
        }

        get tableHeight() {
            return this.table.totalRowsHeight;
        }

        get tableWidth() {
            return this.table.totalColumnWidth;
        }

        get tableOYOffset() {
            if (this.startFromBottomEnable) {
                var h = this.tableHeight - this.instHeight;
                if (h < 0) {
                    return -h;
                }
            }

            return 0;
        }

        get topTableOY() {
            return 0;
        }

        get bottomTableOY() {
            return -this.tableVisibleHeight;
        }

        get leftTableOX() {
            return 0;
        }

        get rightTableOX() {
            return -this.tableVisibleWidth;
        }

        get tableVisibleHeight() {
            var h = this.tableHeight - this.instHeight;
            if (h < 0) {
                h = 0;
            }
            return h;
        }

        get tableVisibleWidth() {
            var w = this.tableWidth - this.instWidth;
            if (w < 0) {
                w = 0;
            }
            return w;
        }

        get bottomLeftY() {
            return -(this.displayHeight * this.originY) + this.displayHeight;
        }

        get topRightX() {
            return -(this.displayWidth * this.originX) + this.displayWidth;
        }

        get topLeftX() {
            return -(this.displayWidth * this.originX);
        }

        get topLeftY() {
            return -(this.displayHeight * this.originY)
        }

        get bottomBound() {
            if (this.scrollMode === 0) {
                return this.bottomLeftY;
            } else {
                return this.topRightX;
            }
        }

        get rightBound() {
            if (this.scrollMode === 0) {
                return this.topRightX;
            } else {
                return this.bottomLeftY;
            }
        }

        resize(width, height) {
            if ((this.width === width) && (this.height === height)) {
                return this;
            }

            super.resize(width, height);

            if (this.fixedCellSize) {
                var colCount = Math.floor(this.instWidth / this.table.defaultCellWidth);
                this.table.setColumnCount(colCount);
            } else if (this.expandCellSize) {
                this.table.setDefaultCellWidth(this.instWidth / this.table.colCount);
            }

            this.updateTable(true, true);

            return this;
        }
    };
    // mixin
    Object.assign(
        GridTable$1.prototype,
        methods$e
    );

    const SCROLLMODE = {
        v: 0,
        vertical: 0,
        h: 1,
        horizontal: 1
    };

    var InjectProperties$1 = function (table) {
        Object.defineProperty(table, 'childOY', {
            configurable: true,
            get: function () {
                return table.tableOY;
            },
            set: function (value) {
                table.tableOY = value;
            }
        });
        Object.defineProperty(table, 'childOX', {
            configurable: true,
            get: function () {
                return table.tableOX;
            },
            set: function (value) {
                table.tableOX = value;
            }
        });
        Object.defineProperty(table, 'topChildOY', {
            get: function () {
                return table.topTableOY;
            }
        });
        Object.defineProperty(table, 'bottomChildOY', {
            get: function () {
                return table.bottomTableOY;
            }
        });
        Object.defineProperty(table, 'leftChildOX', {
            get: function () {
                return table.leftTableOX;
            }
        });
        Object.defineProperty(table, 'rightChildOX', {
            get: function () {
                return table.rightTableOX;
            }
        });
        Object.defineProperty(table, 'childVisibleHeight', {
            get: function () {
                return table.instHeight;
            }
        });
        Object.defineProperty(table, 'childHeight', {
            get: function () {
                return table.tableHeight;
            }
        });
        Object.defineProperty(table, 'childVisibleWidth', {
            get: function () {
                return table.instWidth;
            }
        });
        Object.defineProperty(table, 'childWidth', {
            get: function () {
                return table.tableWidth;
            }
        });
    };

    var TableOnCellVisible = function (table) {
        table.on('cellvisible', function (cell, cellContainer, table) {
            var callback = this.createCellContainerCallback;
            var scope = this.createCellContainerCallbackScope;
            cell.item = this.items[cell.index];
            cell.items = this.items;
            var cellContainer;
            if (scope) {
                cellContainer = callback.call(scope, cell, cellContainer, table);
            } else {
                cellContainer = callback(cell, cellContainer, table);
            }

            if (cellContainer) {
                if ((cell.cellContainerAlign == null) && cellContainer.setOrigin) {
                    cellContainer.setOrigin(0);
                }
                if (cellContainer.isRexSizer) {
                    cellContainer.layout(); // Use original size
                }
            }

            cell.item = undefined;
            cell.items = undefined;
            cell.setContainer(cellContainer);
        }, this);
    };

    var EmitCellEvent = function (eventEmitter, eventName, table, worldX, worldY, pointer, event) {
        var cellIndex;
        if (worldY === undefined) {
            cellIndex = worldX;
        } else {
            var camera = pointer.camera;
            var px = worldX + camera.scrollX * (table.scrollFactorX - 1);
            var py = worldY + camera.scrollY * (table.scrollFactorY - 1);
            cellIndex = table.pointToCellIndex(px, py);

        }
        if ((cellIndex === null) || (cellIndex === undefined)) {
            return;
        }
        var cellContainer = table.getCellContainer(cellIndex);
        if (cellContainer) {
            eventEmitter.emit(eventName, cellContainer, cellIndex, pointer, event);
        }
    };

    var PointerUpDownCell = function (table, tableConfig) {
        table
            .on('pointerdown', function (pointer, localX, localY, event) {
                EmitCellEvent(this.eventEmitter, 'cell.down', table, pointer.worldX, pointer.worldY, pointer, event);
            }, this)
            .on('pointerup', function (pointer, localX, localY, event) {
                EmitCellEvent(this.eventEmitter, 'cell.up', table, pointer.worldX, pointer.worldY, pointer, event);
            }, this);
    };

    var OverCell = function (table, tableConfig) {
        table
            .on('pointermove', OnMove, this)
            .on('pointerover', OnMove, this)
            .on('pointerout', OnOut, this);  // pointer-up is included too
    };

    var OnMove = function (pointer, localX, localY, event) {
        var table = this.childrenMap.child;
        var camera = pointer.camera;
        var px = pointer.worldX + camera.scrollX * (table.scrollFactorX - 1);
        var py = pointer.worldY + camera.scrollY * (table.scrollFactorY - 1);

        var cellIndex = table.pointToCellIndex(px, py);
        if (cellIndex === table.input.lastOverCellIndex) {
            return;
        }

        var preCellIndex = table.input.lastOverCellIndex;
        table.input.lastOverCellIndex = cellIndex;
        EmitCellEvent(this.eventEmitter, 'cell.out', table, preCellIndex, undefined, pointer, event);
        EmitCellEvent(this.eventEmitter, 'cell.over', table, cellIndex, undefined, pointer, event);
    };

    var OnOut = function (pointer, event) {
        var table = this.childrenMap.child;
        var cellIndex = table.input.lastOverCellIndex;
        table.input.lastOverCellIndex = undefined;
        EmitCellEvent(this.eventEmitter, 'cell.out', table, cellIndex, undefined, pointer, event);
    };

    const GetValue$1a = Phaser.Utils.Objects.GetValue;

    var ClickCell = function (table, tableConfig) {
        var buttonConfig = GetValue$1a(tableConfig, 'click', undefined);
        if (buttonConfig === false) {
            return;
        } else if (buttonConfig === undefined) {
            buttonConfig = {};
        }
        buttonConfig.threshold = 10;
        table._click = new Button(table, buttonConfig);
        table._click.on('click', function (button, gameObject, pointer, event) {
            EmitCellEvent(this.eventEmitter, 'cell.click', gameObject, pointer.worldX, pointer.worldY, pointer, event);
        }, this);
    };

    const GetValue$19 = Phaser.Utils.Objects.GetValue;

    var TapCell = function (table, tableConfig) {
        var tapConfig = GetValue$19(tableConfig, 'tap', undefined);
        if (tapConfig === false) {
            return;
        }

        table._tap = new Tap(table, tapConfig);
        table._tap
            .on('tap', function (tap, gameObject, lastPointer) {
                var eventName = `cell.${tap.tapsCount}tap`;
                EmitCellEvent(this.eventEmitter, eventName, tap.gameObject, tap.worldX, tap.worldY, lastPointer);
            }, this);
    };

    const GetValue$18 = Phaser.Utils.Objects.GetValue;

    var PressCell = function (table, tableConfig) {
        var pressConfig = GetValue$18(tableConfig, 'press', undefined);
        if (pressConfig === false) {
            return;
        }

        table._press = new Press(table, pressConfig);
        table._press
            .on('pressstart', function (press, gameObject, lastPointer) {
                EmitCellEvent(this.eventEmitter, 'cell.pressstart', table, press.worldX, press.worldY, lastPointer);
            }, this)
            .on('pressend', function (press, gameObject, lastPointer) {
                EmitCellEvent(this.eventEmitter, 'cell.pressend', table, press.worldX, press.worldY, lastPointer);
            }, this);
    };

    const GetValue$17 = Phaser.Utils.Objects.GetValue;

    var SwipeCell = function (table, tableConfig) {
        var swipeConfig = GetValue$17(tableConfig, 'swipe', undefined);
        if (swipeConfig === false) {
            return;
        } else if (swipeConfig === undefined) {
            swipeConfig = {};
        }
        swipeConfig.dir = '4dir';
        table._swipe = new Swipe(table, swipeConfig);
        table._swipe
            .on('swipe', function (swipe, gameObject, lastPointer) {
                var dirName =
                    (swipe.left) ? 'left' :
                        (swipe.right) ? 'right' :
                            (swipe.up) ? 'up' :
                                'down';
                EmitCellEvent(this.eventEmitter, `cell.swipe${dirName}`, table, swipe.worldX, swipe.worldY, lastPointer);
            }, this);
    };

    var TableSetInteractive = function (table, tableConfig) {
        table.setInteractive();
        
        PointerUpDownCell.call(this, table, tableConfig);
        OverCell.call(this, table, tableConfig);
        ClickCell.call(this, table, tableConfig);
        TapCell.call(this, table, tableConfig);
        PressCell.call(this, table, tableConfig);
        SwipeCell.call(this, table, tableConfig);
    };

    var SetItems = function (items, updateTable) {
        if (items === undefined) {
            this.items = [];
        } else {
            this.items = items;
        }

        if (updateTable === undefined) {
            updateTable = true;
        }

        var table = this.childrenMap.child;
        table.setCellsCount(this.items.length);

        if (updateTable) {
            table.updateTable(true);
            this.resizeController();
        }

        return this;
    };

    var ScrollMethods$1 = {
        scrollToRow(rowIndex) {
            var table = this.childrenMap.child;
            table.scrollToRow(rowIndex);
            return this;
        },

        scrollToNextRow(rowCount) {
            var table = this.childrenMap.child;
            table.scrollToNextRow(rowCount);
            return this;
        }
    };

    const GetValue$16 = Phaser.Utils.Objects.GetValue;

    class GridTable extends Scrollable$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            // Create grid table core
            var scrollMode = GetScrollMode(config);
            var tableConfig = GetValue$16(config, 'table', undefined);
            if (tableConfig === undefined) {
                tableConfig = {};
            }
            tableConfig.scrollMode = (scrollMode === 2) ? 0 : scrollMode;
            tableConfig.clampTableOXY = GetValue$16(config, 'clampChildOY', false);
            var tableWidth = GetValue$16(tableConfig, 'width', undefined);
            var tableHeight = GetValue$16(tableConfig, 'height', undefined);
            var table = new GridTable$1(scene, 0, 0, tableWidth, tableHeight, tableConfig);
            scene.add.existing(table); // Important: Add to display list for touch detecting
            var expandWidth, expandHeight;
            if (tableConfig.scrollMode === 0) {
                expandWidth = (tableWidth === undefined);
                expandHeight = (tableHeight === undefined);
            } else {
                expandWidth = (tableHeight === undefined);
                expandHeight = (tableWidth === undefined);
            }
            // Inject properties for scrollable interface
            InjectProperties$1(table);
            // Set minWidth/minHeight to 0 if tableWidth/tableHeight is undefined
            table._minWidth = (tableWidth === undefined) ? 0 : undefined;
            table._minHeight = (tableHeight === undefined) ? 0 : undefined;

            // Fill config of scrollable
            config.type = 'rexGridTable';
            config.child = {
                gameObject: table,
                expandWidth: expandWidth,
                expandHeight: expandHeight,
            };
            var spaceConfig = GetValue$16(config, 'space', undefined);
            if (spaceConfig) {
                spaceConfig.child = GetValue$16(spaceConfig, 'table', 0);
            }

            super(scene, config);

            this.addChildrenMap('table', table);
            this.addChildrenMap('tableLayer', table.maskLayer);

            this.eventEmitter = GetValue$16(config, 'eventEmitter', this);
            var callback = GetValue$16(config, 'createCellContainerCallback', NOOP);
            var scope = GetValue$16(config, 'createCellContainerCallbackScope', undefined);
            this.setCreateCellContainerCallback(callback, scope);
            TableOnCellVisible.call(this, table);

            this.resizeControllerFlag = false;
            var eventName = (scrollMode === 0) ? 'cellheightchange' : 'cellwidthchange';
            table.on(eventName, function () {
                this.resizeControllerFlag = true;
            }, this);

            if (GetValue$16(tableConfig, 'interactive', true)) {
                TableSetInteractive.call(this, table, tableConfig);
            }

            this.setItems(GetValue$16(config, 'items', []), false);

            scene.game.events.on('poststep', this.onPostStep, this);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.scene.game.events.off('poststep', this.onPostStep, this);

            super.destroy(fromScene);
        }

        setCreateCellContainerCallback(callback, scope) {
            this.createCellContainerCallback = callback;
            this.createCellContainerCallbackScope = scope;
            return this;
        }

        refresh() {
            this.setItems(this.items);
            return this;
        }

        getCell(cellIdx) {
            var table = this.childrenMap.child;
            return table.getCell(cellIdx);
        }

        getCellContainer(cellIdx) {
            var table = this.childrenMap.child;
            return table.getCellContainer(cellIdx);
        }

        updateVisibleCell(cellIdx) {
            var table = this.childrenMap.child;
            return table.updateVisibleCell(cellIdx);
        }

        resetAllCellsSize(width, height) {
            var table = this.childrenMap.child;
            table.resetAllCellsSize(width, height);
            return this;
        }

        onPostStep() {
            if (this.resizeControllerFlag) {
                this.resizeController();
                this.resizeControllerFlag = false;
            }
        }

        get startRowIndex() {
            var table = this.childrenMap.child;
            return table.startRowIndex;
        }
    }

    var methods$d = {
        setItems: SetItems
    };
    Object.assign(
        GridTable.prototype,
        ScrollMethods$1,
        methods$d,
    );

    ObjectFactory.register('gridTable', function (config) {
        var gameObject = new GridTable(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.GridTable', GridTable);

    var GetEaseConfig = function (easeConfig, menu) {
        if (easeConfig.sameOrientation) {
            easeConfig.orientation = menu.orientation;
        } else {
            easeConfig.orientation = (menu.orientation === 0) ? 1 : 0;
        }
        return easeConfig;
    };

    var PopUp = function (menu, duration) {
        menu.popUp(GetEaseConfig(menu.root.easeIn, menu));
    };

    var ScaleDown$1 = function (menu, duration) {
        // Don't destroy here
        menu.scaleDown(GetEaseConfig(menu.root.easeOut, menu));
    };

    var SetTransitCallbackMethods = {
        setTransitInCallback(callback) {
            if (callback === undefined) {
                callback = PopUp;
            }

            this.transitInCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

        setTransitOutCallback(callback) {
            if (callback === undefined) {
                callback = ScaleDown$1;
            }

            this.transitOutCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        }
    };

    var PostUpdateDelayCall = function (gameObject, delay, callback, scope, args) {
        // Invoke callback under scene's 'postupdate' event
        var scene = GetSceneObject(gameObject);
        var timer = scene.time.delayedCall(delay, function () {
            scene.sys.events.once('postupdate', function () {
                callback.call(scope, args);
            });
        });
        return timer;
    };

    var DelayCallMethods = {
        delayCall(delay, callback, scope) {
            // Invoke callback under scene's 'postupdate' event
            this.timer = PostUpdateDelayCall(this, delay, callback, scope);
            return this;
        },

        removeDelayCall() {
            if (this.timer) {
                this.timer.remove(false);
                this.timer = undefined;
            }
            return this;
        }
    };

    var ExpandSubMenu = function (parentButton, items) {
        var subMenu = this.childrenMap.subMenu;
        // Submenu already expand
        if (subMenu && subMenu.parentButton === parentButton) {
            return this;
        }

        this.collapseSubMenu();

        var orientation;
        if (this.root.toggleOrientation) {
            orientation = (this.orientation === 0) ? 1 : 0;
        } else {
            orientation = this.orientation;
        }

        var subMenu = new this.constructor(this.scene, {
            items: items,
            orientation: orientation,
            space: this.space,

            createBackgroundCallback: this.root.createBackgroundCallback,
            createBackgroundCallbackScope: this.root.createBackgroundCallbackScope,
            createButtonCallback: this.root.createButtonCallback,
            createButtonCallbackScope: this.root.createButtonCallbackScope,
            easeIn: this.root.easeIn,
            easeOut: this.root.easeOut,

            _rootMenu: this.root,
            _parentMenu: this,
            _parentButton: parentButton
        });

        this.pin(subMenu);
        this.childrenMap.subMenu = subMenu;
        this.root.emit('expand', subMenu, parentButton, this);
        return this;
    };

    var Collapse = function () {
        var root = this.root;
        root.emit('collapse', this, this.parentButton, root);

        var duration = root.easeOut.duration;
        // Don't destroy under transitOutCallback
        root.transitOutCallback(this, duration);
        this.collapseSubMenu();

        // Destroy by delayCall
        this.delayCall(duration, this.destroy, this);

        return this;
    };

    var CollapseSubMenu = function () {
        var subMenu = this.childrenMap.subMenu;
        if (subMenu === undefined) {
            return this;
        }
       
        this.childrenMap.subMenu = undefined;
        this.remove(subMenu);
        subMenu.collapse();
        return this;
    };

    var Methods$4 = {
        expandSubMenu: ExpandSubMenu,
        collapse: Collapse,
        collapseSubMenu: CollapseSubMenu,
    };

    Object.assign(
        Methods$4,
        SetTransitCallbackMethods,
        DelayCallMethods
    );

    var CreateBackground$1 = function (scene, items, callback, scope) {
        var background;
        if (callback) {
            items.scene = scene;
            if (scope) {
                background = callback.call(scope, items);
            } else {
                background = callback(items);
            }
            items.scene = undefined;
        }

        return background;
    };

    var CreateButtons$4 = function (scene, items, callback, scope) {
        var item;
        var buttons = [],
            button;
        if (items && callback) {
            for (var i = 0, cnt = items.length; i < cnt; i++) {
                item = items[i];
                item.scene = scene;
                if (scope) {
                    button = callback.call(scope, item, i, items);
                } else {
                    button = callback(item, i, items);
                }
                item.scene = undefined;
                buttons.push(button);
            }
        }

        return buttons;
    };

    var MenuSetInteractive = function (menu) {
        menu
            // Expand sub event
            .on(menu.root.expandEventName, function (button, index) {
                if (this._isPassedEvent) {
                    return;
                }
                var childrenKey =  this.root.childrenKey;
                var subItems = this.items[index][childrenKey];
                if (subItems) {
                    this.expandSubMenu(button, subItems);
                }
            }, menu)
            // Click any button
            .on('button.click', function (button, index, pointer, event) {
                // Pass event to root menu object
                if (this !== this.root) {
                    this.root._isPassedEvent = true;
                    this.root.emit('button.click', button, index, pointer, event);
                    this.root._isPassedEvent = false;
                }
            }, menu)
            //Pointer over any button
            .on('button.over', function (button, index, pointer, event) {
                // Pass event to root menu object
                if (this !== this.root) {
                    this.root._isPassedEvent = true;
                    this.root.emit('button.over', button, index, pointer, event);
                    this.root._isPassedEvent = false;
                }
            }, menu)
            //Pointer out any button
            .on('button.out', function (button, index, pointer, event) {
                // Pass event to root menu object
                if (this !== this.root) {
                    this.root._isPassedEvent = true;
                    this.root.emit('button.out', button, index, pointer, event);
                    this.root._isPassedEvent = false;
                }
            }, menu);
    };

    var ParseEaseConfig = function (menu, easeConfig) {
        if (typeof (easeConfig) === 'number') {
            easeConfig = {
                duration: easeConfig
            };
        }

        if (easeConfig.hasOwnProperty('orientation') && (easeConfig.orientation !== undefined)) {
            easeConfig.sameOrientation = GetOrientationMode(easeConfig.orientation) === menu.orientation;
        } else {
            easeConfig.sameOrientation = true;
        }
        easeConfig.destroy = false;
        return easeConfig;
    };

    var Expand = function () {
        var root = this.root;

        var duration = root.easeIn.duration;
        // Ease in menu
        root.transitInCallback(this, duration);

        if (this !== this.root) {
            this.delayCall(duration, function () {
                // Pass event to root menu object
                this.root.emit('popup.complete', this);
            }, this);
        }
    };

    const GetValue$15 = Phaser.Utils.Objects.GetValue;

    class Menu extends Buttons$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            // Orientation
            if (!config.hasOwnProperty('orientation')) {
                config.orientation = 1; // y
            }

            // Parent
            var rootMenu = config._rootMenu;
            var parentMenu = config._parentMenu;
            var parentButton = config._parentButton;
            // Popup, root menu can be static, sub-menus are always popup.
            var popUp = GetValue$15(config, 'popup', true);
            // Items
            var items = GetValue$15(config, 'items', undefined);
            // Background
            var createBackgroundCallback = GetValue$15(config, 'createBackgroundCallback', undefined);
            var createBackgroundCallbackScope = GetValue$15(config, 'createBackgroundCallbackScope', undefined);
            config.background = CreateBackground$1(scene, items, createBackgroundCallback, createBackgroundCallbackScope);
            // Buttons
            var createButtonCallback = GetValue$15(config, 'createButtonCallback', undefined);
            var createButtonCallbackScope = GetValue$15(config, 'createButtonCallbackScope', undefined);
            config.buttons = CreateButtons$4(scene, items, createButtonCallback, createButtonCallbackScope);

            super(scene, config);
            this.type = 'rexMenu';

            this.items = items;
            this.root = (rootMenu === undefined) ? this : rootMenu;
            this.isRoot = (this.root === this);
            this.parentMenu = parentMenu;
            this.parentButton = parentButton;
            this.timer = undefined;

            // Root menu
            if (this.isRoot) {
                this.isPopUpMode = popUp;
                // Bounds
                var bounds = config.bounds;
                if (bounds === undefined) {
                    bounds = GetViewport(scene);
                }
                this.bounds = bounds;

                // Side of submenu
                this.subMenuSide = [
                    ((this.y < bounds.centerY) ? SUBMENU_DOWN : SUBMENU_UP),
                    ((this.x < bounds.centerX) ? SUBMENU_RIGHT : SUBMENU_LEFT)
                ];
                // Overwrite subMenuSide value if given
                var subMenuSide = GetValue$15(config, 'subMenuSide', undefined);
                if (subMenuSide !== undefined) {
                    if (typeof (subMenuSide) === 'string') {
                        subMenuSide = SubMenuSideMode[subMenuSide];
                    }
                    this.subMenuSide[this.orientation] = subMenuSide;
                }
                // ToggleOrientation mode
                this.toggleOrientation = GetValue$15(config, 'toggleOrientation', false);
                // Expand mode
                this.expandEventName = GetValue$15(config, 'expandEvent', 'button.click');
                // Transition
                this.easeIn = ParseEaseConfig(this, GetValue$15(config, 'easeIn', 0));
                this.easeOut = ParseEaseConfig(this, GetValue$15(config, 'easeOut', 0));
                this.setTransitInCallback(GetValue$15(config, 'transitIn'));
                this.setTransitOutCallback(GetValue$15(config, 'transitOut'));
                // Callbacks
                this.createBackgroundCallback = createBackgroundCallback;
                this.createBackgroundCallbackScope = createBackgroundCallbackScope;
                this.createButtonCallback = createButtonCallback;
                this.createButtonCallbackScope = createButtonCallbackScope;
                // Children key
                this.childrenKey = GetValue$15(config, 'childrenKey', 'children');
                // Event flag
                this._isPassedEvent = false;

                // pointerdown-outside-collapse
                this.pointerDownOutsideCollapsing = GetValue$15(config, 'pointerDownOutsideCollapsing', true);
                if (this.pointerDownOutsideCollapsing) {
                    scene.input.on('pointerdown', this.onPointerDownOutside, this);
                }

            }

            var originX = 0, originY = 0;
            if (!this.root.easeIn.sameOrientation) {
                var easeOrientation = GetEaseConfig(this.root.easeIn, this).orientation;
                var menuOrientation = (parentMenu) ? parentMenu.orientation : this.orientation;
                var subMenuSide = this.root.subMenuSide[menuOrientation];
                if ((easeOrientation === 0) && (subMenuSide === SUBMENU_LEFT)) {
                    originX = 1;
                }
                if ((easeOrientation === 1) && (subMenuSide === SUBMENU_UP)) {
                    originY = 1;
                }
            }

            if (popUp) {
                this.setOrigin(originX, originY).layout();
            }

            // Sub-menu: 
            // - scale to root's scale value
            // - align to parent button
            if (!this.isRoot) {
                this.setScale(this.root.scaleX, this.root.scaleY);
                var subMenuSide = this.root.subMenuSide[parentMenu.orientation];
                switch (subMenuSide) {
                    case SUBMENU_LEFT: //Put submene at left side
                        this.alignTop(parentButton.top).alignRight(parentButton.left);
                        break;

                    case SUBMENU_RIGHT: //Put submene at right side
                        this.alignTop(parentButton.top).alignLeft(parentButton.right);
                        break;

                    case SUBMENU_UP: //Put submene at up side
                        this.alignLeft(parentButton.left).alignBottom(parentButton.top);
                        break;

                    case SUBMENU_DOWN: //Put submene at down side
                        this.alignLeft(parentButton.left).alignTop(parentButton.bottom);
                        break;
                }
            }

            MenuSetInteractive(this);

            if (popUp) {
                this.pushIntoBounds(this.root.bounds);

                // Expand this menu
                Expand.call(this);
            }

        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            if (this.isRoot && this.pointerDownOutsideCollapsing) {
                this.scene.input.off('pointerdown', this.onPointerDownOutside, this);
            }

            super.destroy(fromScene);
            this.removeDelayCall();
        }

        isInTouching(pointer) {
            if (super.isInTouching(pointer)) {
                return true;
            } else if (this.childrenMap.subMenu) {
                return this.childrenMap.subMenu.isInTouching(pointer);
            } else {
                return false;
            }
        }

        onPointerDownOutside(pointer) {
            if (this.isInTouching(pointer)) {
                return;
            }

            if (this.isPopUpMode) {
                this.collapse();
            } else {
                this.collapseSubMenu();
            }
        }


    }

    const SUBMENU_LEFT = 2;
    const SUBMENU_RIGHT = 0;
    const SUBMENU_UP = 3;
    const SUBMENU_DOWN = 1;
    const SubMenuSideMode = {
        up: SUBMENU_UP,
        down: SUBMENU_DOWN,
        left: SUBMENU_LEFT,
        right: SUBMENU_RIGHT
    };

    Object.assign(
        Menu.prototype,
        Methods$4
    );

    ObjectFactory.register('menu', function (config) {
        var gameObject = new Menu(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Menu', Menu);

    var methods$c = {
        setWrapEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }

            this.listWrapEnable = enable;
            return this;
        },

        setCreateButtonCallback(callback) {
            this.listCreateButtonCallback = callback;
            return this;
        },

        setCreateListBackgroundCallback(callback) {
            this.listCreateBackgroundCallback = callback;
            return this;
        },

        setCreateListSliderTrackCallback(callback) {
            this.listCreateSliderTrackCallback = callback;
            return this;
        },

        setCreateListSliderThumbCallback(callback) {
            this.listCreateSliderThumbCallback = callback;
            return this;
        },

        setListSliderAdaptThumbSizeEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.listSliderAdaptThumbSizeEnable = enable;
            return this;
        },

        setListScrollerConfig(config) {
            if (config === undefined) {
                config = {};
            }
            this.listScrollerConfig = config;
            return this;
        },

        setListMouseWheelScrollerConfig(config) {
            this.listMouseWheelScrollerConfig = config;
            return this;
        },

        setButtonClickCallback(callback) {
            this.listOnButtonClick = callback;
            return this;
        },

        setButtonOverCallback(callback) {
            this.listOnButtonOver = callback;
            return this;
        },

        setButtonOutCallback(callback) {
            this.listOnButtonOut = callback;
            return this;
        },

        setListExpandDirection(direction) {
            if (typeof (direction) === 'string') {
                direction = ListExpandDirections[direction];
            }
            this.listExpandDirection = direction;
            return this;
        },

        setListEaseInDuration(duration) {
            if (duration === undefined) {
                duration = 0;
            }
            this.listEaseInDuration = duration;
            return this;
        },

        setListEaseOutDuration(duration) {
            if (duration === undefined) {
                duration = 0;
            }
            this.listEaseOutDuration = duration;
            return this;
        },

        setListTransitInCallback(callback) {
            this.listTransitInCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

        settListTransitOutCallback(callback) {
            this.listTransitOutCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

        setListBounds(bounds) {
            this.listBounds = bounds;
            return this;
        },

        setListWidth(width) {
            this.listWidth = width;
            return this;
        },

        setListHeight(height) {
            this.listHeight = height;
            return this;
        },

        setListSize(width, height) {
            this.setListWidth(width).setListHeight(height);
            return this;
        },

        setListMaxHeight(height) {
            this.listMaxHeight = height;
            return this;
        },


        setListAlignmentMode(mode) {
            this.listAlignMode = mode;
            return this;
        },

        setListAlignmentSide(side) {
            if (side === undefined) {
                side = '';
            }

            this.listAlignSide = side;
            return this;
        },

        setListSpace(space) {
            if (space === undefined) {
                space = {};
            }
            this.listSpace = space;
            return this;
        },

        setListDraggable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.listDraggable = enable;
            return this;
        },

    };

    const ListExpandDirections = {
        down: 0,
        up: 1
    };

    var GetChildrenWidth = function () {
        if (this.rexSizer.hidden) {
            return 0;
        }

        var childWidth;
        var child = this.child,
            childConfig = child.rexSizer;
        var hasUnknownChildWidth = false;

        if (childConfig.hidden) {
            childWidth = 0;
        } else {
            switch (this.scrollMode) {
                case 0:
                    childWidth = this.getChildWidth(child);
                    if (childWidth === undefined) {
                        hasUnknownChildWidth = true;
                    }
                    break;

                case 1:
                    childWidth = 0;
                    break;

                default:
                    childWidth = 0;
                    break;
            }
        }

        if (hasUnknownChildWidth) {
            return undefined;
        }

        return childWidth;
    };

    var GetChildrenHeight = function () {
        if (this.rexSizer.hidden) {
            return 0;
        }

        var childHeight;
        var child = this.child,
            childConfig = child.rexSizer;
        var hasUnknownChildHeight = false;

        if (childConfig.hidden) {
            childHeight = 0;
        } else {
            switch (this.scrollMode) {
                case 0:
                    childHeight = 0;
                    break;

                case 1:
                    childHeight = this.getChildHeight(child);
                    if (childHeight === undefined) {
                        hasUnknownChildHeight = true;
                    }
                    break;

                default:
                    childHeight = 0;
                    break;
            }
        }

        if (hasUnknownChildHeight) {
            return undefined;
        }

        return childHeight;
    };

    var GetChildrenSizers = function(out) {
        if (out === undefined) {
            out = [];
        }
        if (this.child && this.child.isRexSizer) {
            out.push(this.child);
        }
        return out;
    };

    var ResetChildPosition = function () {
        var x = this.left;
        var y = this.top;

        switch (this.scrollMode) {
            case 0:
                y += this.childOY;
                break;
            case 1:
                x += this.childOY;
                break;

            default:  // xy
                y += this.childOY;
                x += this.childOX;
                break;
        }

        this.child.setPosition(x, y);
        this.resetChildPositionState(this.child);

        this.setMaskChildrenFlag();
    };

    var LayoutChildren = function () {
        // LayoutChildren child
        var child = this.child;
        var childWidth, childHeight;
        if (!child.rexSizer.hidden) {
            // Set size
            switch (this.scrollMode) {
                case 0:
                    childWidth = this.width * this.scaleX;
                    break;
                case 1:
                    childHeight = this.height * this.scaleY;
                    break;
            }

            if (child.isRexSizer) {
                child.runLayout(this, childWidth, childHeight);
            } else {
                ResizeGameObject(child, childWidth, childHeight);
            }

            // Update local state
            this.resetChildPosition();
            // Layout children-mask
            this.layoutChildrenMask();
            // Re-mask children
            this.maskChildren();
        }
    };

    var RemoveChildCallback = function (gameObject, destroyChild) {
        if (destroyChild) {
            return;
        }

        if (gameObject.clearMask) {
            gameObject.clearMask(false);
        }
    };

    var methods$b = {
        getChildrenWidth: GetChildrenWidth,
        getChildrenHeight: GetChildrenHeight,
        getChildrenSizers: GetChildrenSizers,
        resetChildPosition: ResetChildPosition,
        layoutChildren: LayoutChildren,
        removeChildCallback: RemoveChildCallback,
    };

    Object.assign(
        methods$b,
        ChildrenMaskMethods
    );

    const IsPlainObject$a = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$14 = Phaser.Utils.Objects.GetValue;
    const ALIGN_LEFTTOP = Phaser.Display.Align.TOP_LEFT;

    class ScrollableBlock extends Base$1 {
        constructor(scene, x, y, minWidth, minHeight, config) {
            if (IsPlainObject$a(x)) {
                config = x;
                x = GetValue$14(config, 'x', 0);
                y = GetValue$14(config, 'y', 0);
                minWidth = GetValue$14(config, 'width', undefined);
                minHeight = GetValue$14(config, 'height', undefined);
            } else if (IsPlainObject$a(minWidth)) {
                config = minWidth;
                minWidth = GetValue$14(config, 'width', undefined);
                minHeight = GetValue$14(config, 'height', undefined);
            }
            super(scene, x, y, minWidth, minHeight, config);

            this.type = 'rexScrollableBlock';
            this.child = undefined;
            this.childrenMask = undefined;
            this._childOY = 0;
            this._childOX = 0;
            this.execeedTopState = false;
            this.execeedBottomState = false;
            this.execeedLeftState = false;
            this.execeedRightState = false;

            this.setScrollMode(GetValue$14(config, 'scrollMode', 0));

            var clampChildOY = GetValue$14(config, 'clampChildOY', true);
            var clampChildOX = GetValue$14(config, 'clampChildOX', clampChildOY);
            this.setClampMode(clampChildOY, clampChildOX);

            // Add elements
            // No background object, and child does not have padding
            var child = GetValue$14(config, 'child', undefined);
            var expand = GetValue$14(config, 'expand', true);

            if (child.setOrigin) {
                child.setOrigin(0);
            }

            this.add(child);
            this.sizerChildren = [child];

            var sizerConfig = this.getSizerConfig(child);
            sizerConfig.align = ALIGN_LEFTTOP;
            sizerConfig.expand = expand;
            this.child = child;

            // Create mask of child object
            var maskConfig = GetValue$14(config, 'mask');
            this.setupChildrenMask(maskConfig);

            if (this.childrenMask) {
                this.maskGameObject = MaskToGameObject(this.childrenMask);
            }
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.destroyChildrenMask();

            this.child = undefined;

            super.destroy(fromScene);
        }

        setScrollMode(mode) {
            if (typeof (mode) === 'string') {
                mode = SCROLLMODE$1[mode.toLowerCase()];
            }
            this.scrollMode = mode;
            return this;
        }

        setClampMode(clampChildOY, clampChildOX) {
            this.clampChildOY = clampChildOY;
            this.clampChildOX = clampChildOX;
            return this;
        }

        get instHeight() {
            if ((this.scrollMode === 0) || (this.scrollMode === 2)) {
                return this.displayHeight;
            } else { // scrollMode === 1
                return this.displayWidth;
            }
        }

        get instWidth() {
            if ((this.scrollMode === 0) || (this.scrollMode === 2)) {
                return this.displayWidth;
            } else { // scrollMode === 1
                return this.displayHeight;
            }
        }

        get childHeight() {
            if ((this.scrollMode === 0) || (this.scrollMode === 2)) {
                return GetDisplayHeight(this.child);
            } else { // scrollMode === 1
                return GetDisplayWidth(this.child);
            }
        }

        get childWidth() {
            if ((this.scrollMode === 0) || (this.scrollMode === 2)) {
                return GetDisplayWidth(this.child);
            } else { // scrollMode === 1
                return GetDisplayHeight(this.child);
            }
        }

        get topChildOY() {
            return 0;
        }

        get bottomChildOY() {
            return -this.visibleHeight;
        }

        get leftChildOX() {
            return 0;
        }

        get rightChildOX() {
            return -this.visibleWidth;
        }

        get childVisibleHeight() {
            return this.instHeight;
        }

        get childVisibleWidth() {
            return this.instWidth;
        }

        get visibleHeight() {
            var h = this.childHeight - this.childVisibleHeight;
            if (h < 0) {
                h = 0;
            }
            return h;
        }

        get visibleWidth() {
            var w = this.childWidth - this.childVisibleWidth;
            if (w < 0) {
                w = 0;
            }
            return w;
        }

        childOYExceedTop(oy) {
            if (oy === undefined) {
                oy = this.childOY;
            }
            return (oy > this.topChildOY);
        }

        childOYExeceedBottom(oy) {
            if (oy === undefined) {
                oy = this.childOY;
            }
            return (oy < this.bottomChildOY);
        }

        childOXExceedLeft(ox) {
            if (ox === undefined) {
                ox = this.childOX;
            }
            return (ox > this.leftChildOX);
        }

        childOXExeceedRight(ox) {
            if (ox === undefined) {
                ox = this.childOX;
            }
            return (ox < this.rightChildOX);
        }

        get childOY() {
            return this._childOY;
        }

        set childOY(oy) {
            var topChildOY = this.topChildOY;
            var bottomChildOY = this.bottomChildOY;
            var childOYExceedTop = this.childOYExceedTop(oy);
            var childOYExeceedBottom = this.childOYExeceedBottom(oy);

            if (this.clampChildOY) {
                if (this.childVisibleHeight > this.childHeight) {
                    oy = 0;
                } else if (childOYExceedTop) {
                    oy = topChildOY;
                } else if (childOYExeceedBottom) {
                    oy = bottomChildOY;
                }
            }

            if (this._childOY !== oy) {
                this._childOY = oy;
                this.resetChildPosition();
            }

            if (childOYExceedTop) {
                if (!this.execeedTopState) {
                    this.emit('execeedtop', this, oy, topChildOY);
                }
            }
            this.execeedTopState = childOYExceedTop;

            if (childOYExeceedBottom) {
                if (!this.execeedBottomState) {
                    this.emit('execeedbottom', this, oy, bottomChildOY);
                }
            }
            this.execeedBottomState = childOYExeceedBottom;
        }

        get childOX() {
            return this._childOX;
        }

        set childOX(ox) {
            var leftChildOX = this.leftChildOX;
            var rightChildOX = this.rightChildOX;
            var childOXExceedLeft = this.childOXExceedLeft(ox);
            var childOXExeceedRight = this.childOXExeceedRight(ox);

            if (this.clampChildOX) {
                if (this.childVisibleWidth > this.childWidth) {
                    ox = 0;
                } else if (childOXExceedLeft) {
                    ox = leftChildOX;
                } else if (childOXExeceedRight) {
                    ox = rightChildOX;
                }
            }

            if (this._childOX !== ox) {
                this._childOX = ox;
                this.resetChildPosition();
            }

            if (childOXExceedLeft) {
                if (!this.execeedLeftState) {
                    this.emit('execeedleft', this, ox, leftChildOX);
                }
            }
            this.execeedLeftState = childOXExceedLeft;

            if (childOXExeceedRight) {
                if (!this.execeedRightState) {
                    this.emit('execeedright', this, ox, rightChildOX);
                }
            }
            this.execeedRightState = childOXExeceedRight;
        }

        setChildOY(oy) {
            this.childOY = oy;
            return this;
        }

        setChildOX(ox) {
            this.childOX = ox;
            return this;
        }

        set t(value) {
            this.childOY = -this.visibleHeight * value;
        }

        get t() {
            var visibleHeight = this.visibleHeight;
            if (visibleHeight === 0) {
                return 0;
            }
            return (this.childOY / -visibleHeight);
        }

        set s(value) {
            this.childOX = -this.visibleWidth * value;
        }

        get s() {
            var visibleWidth = this.visibleWidth;
            if (visibleWidth === 0) {
                return 0;
            }
            return (this.childOX / -visibleWidth);
        }

        setChildOYByPercentage(percentage) {
            this.t = percentage;
            return this;
        }

        setChildOXByPercentage(percentage) {
            this.s = percentage;
            return this;
        }
    }

    Object.assign(
        ScrollableBlock.prototype,
        methods$b
    );

    var ScrollToChild = function (child, align) {
        if (!this.hasChild(child)) {
            return this;
        }

        switch (this.scrollMode) {
            case 0:
                AlignChild.call(this, child, 'y', align);
                break;

            case 1:
                AlignChild.call(this, child, 'x', align);
                break;

            default:
                AlignChild.call(this, child, 'y', align);
                AlignChild.call(this, child, 'x', align);
                break;
        }

        return this;
    };

    const AlignYModes = ['top', 'bottom', 'centerY', 'center'];
    const AlignXModes = ['left', 'right', 'centerX', 'center'];

    var AlignChild = function (child, axis, align) {
        axis = axis.toUpperCase();
        var isAxisY = (axis === 'Y');

        var scrollableBlock = this.childrenMap.child;
        var delta;
        if (isAxisY) {
            if (align) {
                for (var i = 0, cnt = AlignYModes.length; i < cnt; i++) {
                    var modeName = AlignYModes[i];
                    if (align.indexOf(modeName) !== -1) {
                        align = modeName;
                        break;
                    }
                }
            }

            switch (align) {
                case 'top':
                    delta = scrollableBlock.top - GetTopLeft(child).y;
                    break;

                case 'bottom':
                    delta = scrollableBlock.bottom - GetBottomLeft(child).y;
                    break;

                case 'centerY':
                case 'center':
                    delta = scrollableBlock.centerY - GetCenter(child).y;
                    break;

                default:
                    var dTop = scrollableBlock.top - GetTopLeft(child).y;
                    var dBottom = scrollableBlock.bottom - GetBottomLeft(child).y;
                    if ((dTop <= 0) && (dBottom >= 0)) {
                        delta = 0;
                    } else {
                        delta = (Math.abs(dTop) <= Math.abs(dBottom)) ? dTop : dBottom;
                    }
                    break;
            }
        } else {
            if (align) {
                for (var i = 0, cnt = AlignXModes.length; i < cnt; i++) {
                    var modeName = AlignXModes[i];
                    if (align.indexOf(modeName) !== -1) {
                        align = modeName;
                        break;
                    }
                }
            }

            switch (align) {
                case 'left':
                    delta = scrollableBlock.left - GetTopLeft(child).x;
                    break;

                case 'right':
                    delta = scrollableBlock.right - GetTopRight(child).x;
                    break;

                case 'centerX':
                case 'center':
                    delta = scrollableBlock.centerX - GetCenter(child).x;
                    break;

                default:
                    var dLeft = scrollableBlock.left - GetTopLeft(child).x;
                    var dRight = scrollableBlock.right - GetTopRight(child).x;
                    if ((dLeft <= 0) && (dRight >= 0)) {
                        delta = 0;
                    } else {
                        delta = (Math.abs(dLeft) <= Math.abs(dRight)) ? dLeft : dRight;
                    }
                    break;
            }
        }

        switch (this.scrollMode) {
            case 0:
            case 1:
                this.childOY += delta;
                break;

            default:
                this[`childO${axis}`] += delta;
                break;
        }
    };

    const GetValue$13 = Phaser.Utils.Objects.GetValue;

    class ScrollablePanel extends Scrollable$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            // Create scrollable-block
            var scrollMode = GetScrollMode(config);
            var panelConfig = GetValue$13(config, 'panel', undefined);
            if (panelConfig === undefined) {
                panelConfig = {};
            }
            panelConfig.scrollMode = scrollMode;
            panelConfig.clampChildOY = GetValue$13(config, 'clampChildOY', false);
            panelConfig.clampChildOX = GetValue$13(config, 'clampChildOX', false);
            var scrollableBlock = new ScrollableBlock(scene, panelConfig);
            scene.add.existing(scrollableBlock); // Important: Add to display list for touch detecting

            var expandPanelWidth,
                expandPanelHeight;
            switch (scrollMode) {
                case 0:
                    expandPanelWidth = GetValue$13(config, 'expand.panel', true);
                    expandPanelHeight = true;
                    break;

                case 1:
                    expandPanelWidth = true;
                    expandPanelHeight = GetValue$13(config, 'expand.panel', true);
                    break;

                default: // 2
                    expandPanelWidth = true;
                    expandPanelHeight = true;
            }

            // Fill config of scrollable
            config.type = 'rexScrollablePanel';
            config.child = {
                gameObject: scrollableBlock,
                expandWidth: expandPanelWidth,
                expandHeight: expandPanelHeight,
                align: GetValue$13(config, 'align.panel', 'center')
            };
            var spaceConfig = GetValue$13(config, 'space', undefined);
            if (spaceConfig) {
                spaceConfig.child = GetValue$13(spaceConfig, 'panel', 0);
            }
            super(scene, config);

            this.addChildrenMap('panel', scrollableBlock.child);
            this.addChildrenMap('panelLayer', scrollableBlock.maskLayer);
            this.addChildrenMap('mask', scrollableBlock.maskGameObject);
            this.addChildrenMap('scrollableBlock', scrollableBlock);
        }

        setChildrenInteractive(config) {
            if (config === undefined) {
                config = {};
            }

            if (!config.hasOwnProperty('eventEmitter')) {
                config.eventEmitter = this;
            }

            if (!config.hasOwnProperty('targets')) {
                config.targets = [this.childrenMap.panel];
            }

            SetChildrenInteractive$1(this.childrenMap.child, config);
            return this;
        }
    }

    var methods$a = {
        scrollToChild: ScrollToChild
    };

    Object.assign(
        ScrollablePanel.prototype,
        methods$a,
    );

    const GetValue$12 = Phaser.Utils.Objects.GetValue;

    var CreateListPanel = function () {
        var scene = this.scene;

        var background;
        var createBackgroundCallback = this.listCreateBackgroundCallback;
        if (createBackgroundCallback) {
            background = createBackgroundCallback.call(this, scene);
            scene.add.existing(background);
        }

        var buttons = [];
        var createButtonCallback = this.listCreateButtonCallback;
        if (createButtonCallback) {
            var options = this.options;
            for (var i = 0, cnt = options.length; i < cnt; i++) {
                var button = createButtonCallback.call(this, scene, options[i], i, options);
                if (!button) {
                    continue;
                }
                scene.add.existing(button);
                buttons.push(button);
            }
        }

        var width = this.listWidth;
        if (width === undefined) {
            if (this.listAlignMode === 'text') {
                width = this.getElement('text').width;
            } else {
                width = this.width;
            }
        }

        var height = this.listHeight;

        var buttonConfig = {
            width: width,
            buttons: buttons,
            space: this.listSpace,
        };

        var buttons, listPanel;

        var isScrollable;
        if (this.listCreateSliderThumbCallback) {
            isScrollable = (height > 0) || (this.listMaxHeight > 0);
        } else {
            isScrollable = false;
        }

        if (!isScrollable) {
            buttonConfig.height = height;
            buttons = CreateButtons$3(scene, buttonConfig, this.listWrapEnable);
            listPanel = buttons;

        } else {
            var buttons = CreateButtons$3(scene, buttonConfig, this.listWrapEnable);

            if (this.listMaxHeight > 0) {
                buttons.layout();
                if (buttons.height <= this.listMaxHeight) {
                    listPanel = buttons;
                }
            }

            if (!listPanel) {
                if (height === 0) {
                    height = this.listMaxHeight;
                }

                var track = CreateGameObject(scene, this.listCreateSliderTrackCallback);
                var thumb = CreateGameObject(scene, this.listCreateSliderThumbCallback);

                listPanel = new ScrollablePanel(scene, {
                    height: height,
                    scrollMode: 0,

                    panel: {
                        child: buttons,
                        mask: {
                            padding: 1,
                        },
                    },

                    slider: {
                        track: track,
                        thumb: thumb,

                        adaptThumbSize: this.listSliderAdaptThumbSizeEnable,
                    },

                    scrollDetectionMode: 1,

                    scroller: this.listScrollerConfig,

                    mouseWheelScroller: this.listMouseWheelScrollerConfig,

                    space: {
                        panel: GetValue$12(this.listSpace, 'panel', 0),
                    },
                });
                scene.add.existing(listPanel);
            }
        }

        if (background) {
            listPanel.addBackground(background, 'background');
        }

        if (this.listDraggable) {
            listPanel.setDraggable(true);
        }

        if (listPanel !== buttons) {
            // Route buttons' events to listPanel
            buttons
                .on('button.over', function (button, index, pointer, event) {
                    listPanel.emit('button.over', button, index, pointer, event);
                })
                .on('button.out', function (button, index, pointer, event) {
                    listPanel.emit('button.out', button, index, pointer, event);
                })
                .on('button.click', function (button, index, pointer, event) {
                    listPanel.emit('button.click', button, index, pointer, event);
                });
        }

        return listPanel;
    };

    var CreateButtons$3 = function (scene, config, isWrapEnable) {
        var gameObject;
        if (!isWrapEnable) {
            config.orientation = 'y';
            gameObject = new Buttons$1(scene, config);
        } else {
            config.orientation = 'x';
            gameObject = new Buttons(scene, config);
        }
        scene.add.existing(gameObject);
        return gameObject;
    };

    var CreateGameObject = function (scene, callback, scope) {
        var gameObject;
        if (callback) {
            gameObject = callback.call(scope, scene);
            scene.add.existing(gameObject);
        }

        return gameObject;
    };

    var ScaleDown = function (gameObject, duration, orientation, ease, scale) {
        if (ease === undefined) {
            ease = 'Linear';
        }

        var config = {};
        config.mode = 0;
        switch (orientation) {
            case 0:
            case 'x':
                config.end = {
                    x: 0
                };
                break;
            case 1:
            case 'y':
                config.end = {
                    y: 0
                };
                break;
            default:
                config.end = 0;
                break;
        }
        config.duration = duration;
        config.ease = ease;

        if (scale === undefined) {
            scale = new Scale(gameObject, config);
        } else {
            scale.resetFromJSON(config);
        }
        scale.restart();

        return scale;
    };

    var GetValueFromAliasKeys = function (source, key0, key1, key2, defaultValue) {
        if (HasValue(source, key0)) {
            return GetValue$3U(source, key0);
        } else if (key1 && HasValue(source, key1)) {
            return GetValue$3U(source, key1);
        } else if (key2 && HasValue(source, key2)) {
            return GetValue$3U(source, key2);
        } else {
            return defaultValue;
        }

    };

    const GetValue$11 = Phaser.Utils.Objects.GetValue;

    var SetPosition = function (gameObject, config) {
        var expandDirection = GetValue$11(config, 'expandDirection', undefined);
        if (typeof (expandDirection) === 'string') {
            expandDirection = ExpandDirections[expandDirection];
        }
        var alignTargetX = GetValueFromAliasKeys(config, 'alignTarget', 'alignTargetX');
        var alignTargetY = GetValue$11(config, 'alignTargetY', alignTargetX);
        var alignOffsetX = GetValue$11(config, 'alignOffsetX', 0);
        var alignOffsetY = GetValue$11(config, 'alignOffsetY', 0);
        var alignSide = GetValue$11(config, 'alignSide', '');
        var alignRight = alignSide.includes('right');

        var positionBounds = GetValue$11(config, 'bounds');

        // Expand direction
        var isExpandDown = (expandDirection === 0);
        var isExpandUp = (expandDirection === 1);
        var flexExpand = !isExpandDown && !isExpandUp;

        var originX = (alignRight) ? 1 : 0;
        var originY = (isExpandDown || flexExpand) ? 0 : 1;
        gameObject.setOrigin(originX, originY);

        var x, y;
        if (alignRight) {
            x = alignTargetX.getTopRight().x;
        } else {
            x = alignTargetX.getTopLeft().x;
        }

        y = alignTargetY.getBottomLeft().y;
        gameObject.setPosition(
            x + alignOffsetX,
            y + alignOffsetY
        );

        var bounds = positionBounds;
        if (!bounds) {
            bounds = GetViewport(gameObject.scene);
        }

        if (flexExpand && (gameObject.getBottomLeft().y > bounds.bottom)) {
            // Out of bounds, can't put list-panel below parent
            y = alignTargetY.getTopLeft().y;
            gameObject
                .setOrigin(0, 1)
                .setPosition(
                    x + alignOffsetX,
                    y + alignOffsetY
                );
        }

    };

    const ExpandDirections = {
        down: 0,
        up: 1
    };

    const GetValue$10 = Phaser.Utils.Objects.GetValue;

    class DropDown extends OpenCloseTransition {
        constructor(gameObject, config) {
            if (config === undefined) {
                config = {};
            }
            if (config.transitIn == null) {
                config.transitIn = function (gameObject, duration) {
                    PopUp$1(gameObject, duration, 'y', 'Cubic');
                };
            }
            if (config.transitOut == null) {
                config.transitOut = function (gameObject, duration) {
                    // Don't destroy here
                    ScaleDown(gameObject, duration, 'y', 'Linear');
                };
            }
            config.manualClose = true;
            config.clickOutsideClose = true;
            config.destroy = true;

            super(gameObject, config);
            // this.parent = gameObject;
            // this.scene

            SetPosition(gameObject, config);

            if (gameObject.isRexSizer) {
                gameObject.layout();
            }

            // Close conditions:
            var touchOutsideClose = GetValue$10(config, 'touchOutsideClose', false);
            var anyTouchClose = GetValue$10(config, 'anyTouchClose', false);

            if (anyTouchClose) {
                touchOutsideClose = false;
            }

            // Registet touch-close event after opened
            if (anyTouchClose) {
                this.once('open', this.anyTouchClose, this);
            } else if (touchOutsideClose) {
                this.once('open', this.touchOutsideClose, this);
            }

            this.requestOpen();
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            // Registered in touchOutsideClose()
            this.scene.input.off('pointerup', this.touchCloseCallback, this);

            super.shutdown(fromScene);
        }

        touchOutsideClose() {
            this.scene.input.on('pointerup', this.touchCloseCallback, this);
            this.clickOutsideTest = true;
            return this;
        }

        anyTouchClose() {
            this.scene.input.once('pointerup', this.touchCloseCallback, this);
            return this;
        }

        touchCloseCallback(pointer) {
            if (this.clickOutsideTest && IsPointInBounds(this.parent, pointer.worldX, pointer.worldY)) {
                return;
            }
            this.requestClose();
        }

        onOpen() {
            this.emit('open', this.parent, this);
            super.onOpen();
        }

        onClose() {
            this.emit('close', this.parent, this);
            super.onClose();
        }

    }

    var OpenListPanel = function () {
        if (this.listPanel) {
            return this;
        }

        if (this.options.length === 0) {
            return this;
        }

        var listPanel = CreateListPanel.call(this);

        // Button over/out
        listPanel
            .on('button.over', function (button, index, pointer, event) {
                this.currentOverIndex = index;

                if (this.listOnButtonOver) {
                    this.listOnButtonOver.call(this, button, index, pointer, event);
                }

                this.emit('button.over', this, listPanel, button, index, pointer, event);
            }, this)
            .on('button.out', function (button, index, pointer, event) {
                if (this.currentOverIndex === index) {
                    this.currentOverIndex = undefined;
                }

                if (this.listOnButtonOut) {
                    this.listOnButtonOut.call(this, button, index, pointer, event);
                }

                this.emit('button.out', this, listPanel, button, index, pointer, event);
            }, this);


        var alignTargetX;
        if (!this.listAlignMode || (this.listAlignMode === 'label')) {
            alignTargetX = this;
        } else {
            alignTargetX = this.getElement(this.listAlignMode);
        }

        var dropDownBehavior = new DropDown(listPanel, {
            // Transition
            duration: {
                in: this.listEaseInDuration,
                out: this.listEaseOutDuration
            },
            transitIn: this.listTransitInCallback,
            transitOut: this.listTransitOutCallback,

            // Position
            expandDirection: this.listExpandDirection,

            alignTargetX: alignTargetX,
            alignTargetY: this,
            alignSide: this.listAlignSide,

            bounds: this.listBounds,

            // Close condition        
        })
            .on('open', function () {
                // After popping up
                // Can click
                listPanel
                    .on('button.click', function (button, index, pointer, event) {
                        if (this.listOnButtonClick) {
                            this.listOnButtonClick.call(this, button, index, pointer, event);
                        }
                        this.emit('button.click', this, listPanel, button, index, pointer, event);
                        this.dropDownBehavior.requestClose();
                    }, this);

                this.emit('list.open', this, listPanel);
            }, this)

            .on('close', function () {
                this.listPanel = undefined;
                this.dropDownBehavior = undefined;

                this.emit('list.close', this);
            }, this);

        listPanel
            .onClickOutside(function () {
                dropDownBehavior.requestClose();
            });

        this.listPanel = listPanel;
        this.dropDownBehavior = dropDownBehavior;

        this.pin(listPanel);

        return this;
    };

    var CloseListPanel = function () {
        if (!this.dropDownBehavior) {
            return this;
        }

        this.dropDownBehavior.requestClose();
        this.currentOverIndex = undefined;

        return this;
    };

    var ToggleListPanel = function () {
        if (!this.listPanel) {
            this.openListPanel();
        } else {
            this.closeListPanel();
        }
        return this;
    };

    var EmitListButtonClick = function (index) {
        if (index === undefined) {
            index = this.currentOverIndex;
        }

        if (index === undefined) {
            return this;
        }

        var listPanel = this.listPanel;

        // Use option if listPanel is not created.
        var button = (listPanel) ? listPanel.getButton(index) : this.options[index];

        if (this.listOnButtonClick) {
            this.listOnButtonClick.call(this, button, index);
        }
        this.emit('button.click', this, listPanel, button, index);

        return this;
    };

    var EmitButtonOver = function (index) {
        var listPanel = this.listPanel;
        if (!listPanel) {
            return this;
        }

        listPanel.emitButtonOver(index);

        return this;
    };

    var FocusButtonMethods = {
        focusNextButton() {
            if (!this.isOpened) {
                return this;
            }

            var currentIndex = this.currentOverIndex;

            var nextIndex;
            if (currentIndex === undefined) {
                nextIndex = 0;
            } else {
                var total = this.listPanel.getButtons().length;
                nextIndex = (currentIndex + 1) % total;
            }

            this.emitButtonOver(nextIndex);

            return this;
        },

        focusPrevButton() {
            if (!this.isOpened) {
                return this;
            }

            var currentIndex = this.currentOverIndex;

            var nextIndex;
            if (currentIndex === undefined) {
                nextIndex = 0;
            } else {
                var total = this.listPanel.getButtons().length;
                nextIndex = (currentIndex - 1 + total) % total;
            }

            this.emitButtonOver(nextIndex);

            return this;
        }
    };

    var Methods$3 = {
        openListPanel: OpenListPanel,
        closeListPanel: CloseListPanel,
        toggleListPanel: ToggleListPanel,
        emitButtonClick: EmitListButtonClick,
        emitButtonOver: EmitButtonOver,
    };

    Object.assign(
        Methods$3,
        methods$c,
        FocusButtonMethods,
    );

    const GetValue$$ = Phaser.Utils.Objects.GetValue;

    class DropDownList extends Label {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexDropDownList';
            this.timer = undefined;
            this.listPanel = undefined;
            this.currentOverIndex = undefined;

            this.setOptions(GetValue$$(config, 'options'));

            var listConfig = GetValue$$(config, 'list');
            this.setWrapEnable(GetValue$$(listConfig, 'wrap', false));
            this.setCreateButtonCallback(GetValue$$(listConfig, 'createButtonCallback'));
            this.setCreateListBackgroundCallback(GetValue$$(listConfig, 'createBackgroundCallback'));
            this.setCreateListSliderTrackCallback(GetValue$$(listConfig, 'createTrackCallback'));
            this.setCreateListSliderThumbCallback(GetValue$$(listConfig, 'createThumbCallback'));
            this.setListSliderAdaptThumbSizeEnable(GetValue$$(listConfig, 'sliderAdaptThumbSize', false));
            this.setListScrollerConfig(GetValue$$(listConfig, 'scroller'));
            this.setListMouseWheelScrollerConfig(GetValue$$(listConfig, 'mouseWheelScroller'));
            this.setButtonClickCallback(GetValue$$(listConfig, 'onButtonClick'));
            this.setButtonOverCallback(GetValue$$(listConfig, 'onButtonOver'));
            this.setButtonOutCallback(GetValue$$(listConfig, 'onButtonOut'));
            this.setListExpandDirection(GetValue$$(listConfig, 'expandDirection'));
            this.setListEaseInDuration(GetValue$$(listConfig, 'easeIn', 500));
            this.setListEaseOutDuration(GetValue$$(listConfig, 'easeOut', 100));
            this.setListTransitInCallback(GetValue$$(listConfig, 'transitIn'));
            this.settListTransitOutCallback(GetValue$$(listConfig, 'transitOut'));
            this.setListMaxHeight(GetValue$$(listConfig, 'maxHeight', 0));
            this.setListSize(GetValue$$(listConfig, 'width'), GetValue$$(listConfig, 'height', 0));
            this.setListAlignmentMode(GetValue$$(listConfig, 'alignParent', 'text'));
            this.setListAlignmentSide(GetValue$$(listConfig, 'alignSide', ''));
            this.setListBounds(GetValue$$(listConfig, 'bounds'));
            this.setListSpace(GetValue$$(listConfig, 'space'));
            this.setListDraggable(GetValue$$(listConfig, 'draggable', false));

            this.setValueChangeCallback(
                GetValue$$(config, 'setValueCallback'),
                GetValue$$(config, 'setValueCallbackScope')
            );
            this.setValue(GetValue$$(config, 'value'));

            this.onClick(this.toggleListPanel, this);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            if (this.listPanel) {
                this.listPanel.destroy(fromScene);
                this.listPanel = undefined;
            }

            super.destroy(fromScene);
        }

        get isOpened() {
            return !!this.listPanel;
        }

        setOptions(options) {
            if (options === undefined) {
                options = [];
            }
            this.options = options;
            return this;
        }

        setValueChangeCallback(callback, scope) {
            this.valueChangeCallback = callback;
            this.valueChangeCallbackScope = scope;
            return this;
        }

        setValue(value) {
            this.value = value;
            return this;
        }

        get value() {
            return this._value;
        }

        set value(value) {
            if (this._value === value) {
                return;
            }

            var previousValue = this._value;
            this._value = value;

            var callback = this.valueChangeCallback,
                scope = this.valueChangeCallbackScope;
            if (callback) {
                if (scope) {
                    callback.call(scope, this, value, previousValue);
                } else {
                    callback(this, value, previousValue);
                }
            }

            this.emit('valuechange', this, value, previousValue);

        }

    }

    Object.assign(
        DropDownList.prototype,
        Methods$3,
    );

    ObjectFactory.register('dropDownList', function (config) {
        var gameObject = new DropDownList(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.DropDownList', DropDownList);

    var BuildListConfig = function (scene, config, creators) {
        config = (config) ? DeepClone(config) : {};

        if (creators === undefined) { creators = {}; }

        var labelConfig = config.label || config.button;
        var listButtonConfig = config.button || config.label;
        delete config.label;
        delete config.button;

        var labelCreator = creators.label || creators.button || creators;
        var listButtonCreator = creators.button || creators.label || creators;

        var listConfig = BuildLabelConfig(scene, labelConfig, labelCreator);
        listConfig.list = config.list || {};

        listConfig.list.createButtonCallback = function (scene, option) {
            var gameObject = CreateLabel(scene, listButtonConfig, listButtonCreator)
                .resetDisplayContent(option);

            if (option.hasOwnProperty('value')) {
                gameObject.value = option.value;
            }
            return gameObject;
        };

        var trackConfig = config.track;
        if (trackConfig) {
            listConfig.list.createTrackCallback = function (scene) {
                return CreateBackground$2(scene, trackConfig);
            };
            delete config.track;
        }

        var thumbConfig = config.thumb;
        if (thumbConfig) {
            listConfig.list.createThumbCallback = function (scene) {
                return CreateBackground$2(scene, thumbConfig);
            };
            delete config.thumb;
        }

        listConfig.list.onButtonOver = function (button, index, pointer, event) {
            if (button.setHoverState) {
                button.setHoverState(true);
            }
        };
        listConfig.list.onButtonOut = function (button, index, pointer, event) {
            if (button.setHoverState) {
                button.setHoverState(false);
            }
        };

        return listConfig;
    };

    class SimpleDropDownList extends DropDownList {
        constructor(scene, config, creators) {
            config = BuildListConfig(scene, config, creators);
            super(scene, config);
            this.type = 'rexSimpleDropDownList';
        }

        setOptions(options) {
            if (options === undefined) {
                options = [];
            }
            for (var i = 0, cnt = options.length; i < cnt; i++) {
                var option = options[i];
                if (typeof (option) === 'string') {
                    options[i] = { text: option, value: option };
                }
            }
            super.setOptions(options);
            return this;
        }

    }

    ObjectFactory.register('simpleDropDownList', function (config, creators) {
        var gameObject = new SimpleDropDownList(this.scene, config, creators);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.SimpleDropDownList', SimpleDropDownList);

    var TextHeightToLinesCount = function (textObject) {
        var textObjectType = GetTextObjectType(textObject);
        var height, lineSpacing, lineHeight;
        switch (textObjectType) {
            case TextType:
            case TagTextType:
                height = textObject.height - textObject.padding.top - textObject.padding.bottom;
                lineSpacing = textObject.lineSpacing;
                lineHeight = textObject.style.metrics.fontSize + textObject.style.strokeThickness;
                break;

            case BitmapTextType:
                height = textObject.height;
                lineSpacing = 0;
                var scale = (textObject.fontSize / textObject.fontData.size);
                lineHeight = textObject.fontData.lineHeight * scale;
                break;
        }

        // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
        return (height - lineSpacing) / (lineHeight + lineSpacing);

    };

    var GetLines = function (startLineIndex, endLineIdx) {
        if (startLineIndex === undefined) {
            startLineIndex = this.startLineIndex;
        }
        if (endLineIdx === undefined) {
            var pageLinesCount = this.pageLinesCount;
            if (pageLinesCount > 0) {
                endLineIdx = startLineIndex + pageLinesCount;
            } else {
                endLineIdx = this.totalLinesCount;
            }
        }
        if (endLineIdx > this.totalLinesCount) {
            endLineIdx = this.totalLinesCount;
        }

        var text;
        switch (this.textObjectType) {
            case TextType:
            case BitmapTextType:
                text = this.lines.slice(startLineIndex, endLineIdx).join('\n');
                break;
            case TagTextType:
                var startIdx = this.lines.getLineStartIndex(startLineIndex);
                var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
                text = this.lines.getSliceTagText(startIdx, endIdx, true);

                // Check line count
                var newLineCharCount = (text.match(/\n/g) || []).length;
                if (newLineCharCount > (endLineIdx - startLineIndex - 1)) {
                    // Remove last '\n'
                    text = text.substring(0, text.length - 1);
                }

                break;
        }

        return text;
    };

    var SetContentMethods = {
        clearText() {
            this.sections.length = 0;
            this.pageStartIndexes.length = 0;
            this.lines.length = 0;

            return this;
        },

        appendPage(text) {
            var pageStartIndex = this.totalLinesCount;

            this.sections.push(GetString(text));
            var text = this.sections.join('\n');
            this.lines = TextToLines(this.parent, text, this.lines);

            var newLinesCount = this.totalLinesCount - pageStartIndex;
            var pageLinesCount = this.pageLinesCount;
            var pageCount;
            if (pageLinesCount > 0) {
                pageCount = Math.ceil(newLinesCount / this.pageLinesCount);
            } else {  // Height of Text object might be 0
                pageCount = 1;
            }

            for (var i = 0; i < pageCount; i++) {
                this.pageStartIndexes.push(
                    pageStartIndex + (i * this.pageLinesCount)
                );
            }

            return this;
        },

        setText(text, resetIndex) {
            if (resetIndex === undefined) {
                resetIndex = true;
            }

            if (resetIndex) {
                this.resetIndex();
            }

            this.clearText();

            var sections = GetString(text).split(this.pageBreak);
            // if (sections[sections.length - 1] === '') { // Last section is an empty string
            //     sections.length -= 1;
            // }

            for (var i = 0, cnt = sections.length; i < cnt; i++) {
                this.appendPage(sections[i]);
            }

            return this;
        },

        appendText(text) {
            var content = this.content + GetString(text);
            this.setText(content, false);
            return this;
        },


    };

    const Clamp$3 = Phaser.Math.Clamp;

    var GetPageMethods = {

        resetIndex() {
            this.pageIndex = -1;
            this.startLineIndex = -1;
            this.endLineIndex = undefined;
            return this;
        },

        setPageIndex(idx) {
            idx = Clamp$3(idx, 0, this.lastPageIndex);
            this.pageIndex = idx;
            this.startLineIndex = this.pageStartIndexes[idx];
            this.endLineIndex = this.pageStartIndexes[idx + 1];
            return this;
        },

        getPage(idx) {
            if (idx === undefined) {
                idx = this.pageIndex;
            }

            return this.setPageIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
        },

        getNextPage() {
            return this.getPage(this.pageIndex + 1);
        },

        getPreviousPage() {
            return this.getPage(this.pageIndex - 1);
        },

        getFirstPage() {
            return this.getPage(0);
        },

        getLastPage() {
            return this.getPage(this.lastPageIndex);
        },

        setStartLineIndex(idx) {
            var lastStartLineIndex = Math.max(this.totalLinesCount - this.pageLinesCount, 0);
            idx = Clamp$3(idx, 0, lastStartLineIndex);

            this.startLineIndex = idx;
            this.endLineIndex = idx + this.pageLinesCount;
            return this;
        },

        getPageByLineIndex(idx) {
            return this.setStartLineIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
        },

        getPageOfNextLine() {
            return this.getPageByLineIndex(this.startLineIndex + 1);
        },

        getPageOfPreviousLine() {
            return this.getPageByLineIndex(this.startLineIndex - 1);
        },

        getPageOfFirstLine() {
            return this.getPageByLineIndex(0);
        },

        getPageOfLastLine() {
            return this.getPageByLineIndex(this.totalLinesCount);
        },

    };

    var ShowMethods = {
        showPage(idx) {
            this.displayText(
                this.getPage(idx)
            );
            return this;
        },

        showNextPage() {
            this.displayText(
                this.getNextPage()
            );
            return this;
        },

        showPreviousPage() {
            this.displayText(
                this.getPreviousPage()
            );
            return this;
        },

        showFirstPage() {
            this.displayText(
                this.getFirstPage()
            );
            return this;
        },

        showLastPage() {
            this.displayText(
                this.getLastPage()
            );
            return this;
        },

        show() {
            this.displayText(
                this.getLines()
            );
            return this;
        },

        showPageByLineIndex(lineIndex) {
            this.displayText(
                this.getPageByLineIndex(lineIndex)
            );
            return this;
        },

        showNextLine() {
            this.displayText(
                this.getPageOfNextLine()
            );
            return this;
        },

        showPreviousLine() {
            this.displayText(
                this.getPageOfPreviousLine()
            );
            return this;
        },

        showFirstLine() {
            this.displayText(
                this.getPageOfFirstLine()
            );
            return this;
        },

        showLastLine() {
            this.displayText(
                this.getPageOfLastLine()
            );
            return this;
        },

        displayText(text) {
            SetNoWrapText(this.parent, text);
        }
    };

    var Methods$2 = {   
        getLines: GetLines,
    };

    Object.assign(
        Methods$2,
        SetContentMethods,
        GetPageMethods,
        ShowMethods
    );

    const GetValue$_ = Phaser.Utils.Objects.GetValue;
    Phaser.Math.Clamp;

    class TextPage extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, { eventEmitter: false });
            // No event emitter
            // this.parent = gameObject;

            this.textObjectType = GetTextObjectType(this.parent);

            this.pageStartIndexes = [];

            // Text object : array of string
            // Tag text object : pens-manager
            // Bitmap text object : array of string
            this.lines = TextToLines(this.parent, '');

            this.sections = [];

            this.resetFromJSON(config);
        }

        resetFromJSON(o) {
            this.setMaxLines(GetValue$_(o, 'maxLines', undefined));
            this.setPageBreak(GetValue$_(o, 'pageBreak', '\f\n'));
            this.setText(GetValue$_(o, 'text', ''));

            this.startLineIndex = GetValue$_(o, 'start', -1);
            this.endLineIndex = GetValue$_(o, 'end', undefined);

            var pageIndex = GetValue$_(o, 'page');
            if (pageIndex === undefined) {
                this.resetIndex();
            } else {
                this.setPageIndex(pageIndex);
            }

            return this;
        }

        toJSON() {
            return {
                maxLines: this.maxLines,
                text: this.content,
                start: this.startLineIndex,
                end: this.endLineIndex,
                page: this.pageIndex,
                pageBreak: this.pageBreak
            };
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            switch (this.textObjectType) {
                case TextType:
                    this.lines.length = 0;
                    break;
                case TagTextType:
                    this.lines.destroy();
                    break;
                case BitmapTextType:
                    this.lines.length = 0;
                    break;
            }

            this.pageStartIndexes.length = 0;
            this.sections.length = 0;

            this.lines = undefined;
            this.pageStartIndexes = undefined;
            this.sections = undefined;

            super.shutdown(fromScene);
        }

        setMaxLines(maxLines) {
            this.maxLines = maxLines;
            return this;
        }

        setPageBreak(pageBreak) {
            this.pageBreak = pageBreak;
            return this;
        }

        get pageCount() {
            return this.pageStartIndexes.length;
        }

        get lastPageIndex() {
            return this.pageCount - 1;
        }

        get isFirstPage() {
            return (this.pageIndex <= 0);
        }

        get isLastPage() {
            return (this.pageIndex >= (this.pageCount - 1));
        }

        get totalLinesCount() {
            return (this.lines) ? this.lines.length : 0;
        }

        get pageLinesCount() {
            // Since the line height of each line is the same, 
            // each page will have the same number of lines

            if (this.maxLines !== undefined) {
                return this.maxLines;

            } else {
                var count;
                switch (this.textObjectType) {
                    case TextType:
                    case TagTextType:
                        var maxLines = this.parent.style.maxLines;
                        if (maxLines > 0) {
                            count = maxLines;
                        } else {
                            count = Math.floor(TextHeightToLinesCount(this.parent));
                        }
                        break;
                    case BitmapTextType:
                        count = this.totalLinesCount;
                        break;
                }
                return count;

            }
        }

        get isFirstLine() {
            return (this.startLineIndex <= 0);
        }

        get isLastLine() {
            return this.endLineIndex === this.totalLinesCount;
        }

        get content() {
            return this.sections.join(this.pageBreak);
        }
    }

    Object.assign(
        TextPage.prototype,
        Methods$2,
    );

    var SetTextMethods$1 = {
        setText(text) {
            if (this.setTextCallback) {
                if (this.setTextCallbackScope) {
                    text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIndex);
                } else {
                    text = this.setTextCallback(text, this.isLastChar, this.insertIndex);
                }
            }

            if (this.textWrapEnable) {
                SetNoWrapText(this.parent, text);
            } else {
                this.parent.setText(text);
            }
        },

        appendText(text) {
            var newText = this.text.concat(GetString(text));
            if (this.isTyping) {
                this.setTypingContent(newText);
            } else {
                this.start(newText, undefined, this.textLength);
            }

            return this;
        }

    };

    var StartTyping = function (text, speed, startIndex, timerStartAt) {
        if (text !== undefined) {
            this.setTypingContent(text);
        }
        if (speed !== undefined) {
            this.speed = speed;
        }
        if (startIndex === undefined) {
            startIndex = 0;
        }

        this.typingIndex = startIndex + 1;
        if (this.speed === 0) {
            this.stop(true);
        } else {
            this.setText('');
            this.startTimer(timerStartAt);
        }

        return this;
    };

    var GetPlainText = function (textObject, text) {
        if (textObject.getPlainText) {
            text = textObject.getPlainText(text);
        }

        return text;
    };

    var StartTypingFromLine = function (text, lineIndex, speed, offsetIndex, timerStartAt) {
        var startIdx;
        if (lineIndex > 0) {
            if (offsetIndex === undefined) {
                offsetIndex = 0;
            }

            var plainText = GetPlainText(this.parent, text);
            startIdx = GetNewLineIndex(plainText, lineIndex) + offsetIndex;
        }
        return this.start(text, speed, startIdx, timerStartAt);
    };

    var GetNewLineIndex = function (s, n) {
        var index = undefined;
        for (var i = 0; i < n; i++) {
            index = s.indexOf('\n', index + 1);
            if (index === -1) {
                break;
            }
        }
        return index;
    };

    var GetSubString = function (textObject, text, startIdx, endIdx) {
        var result;
        if (textObject.getSubString) {
            result = textObject.getSubString(text, startIdx, endIdx);
        } else {
            result = text.slice(startIdx, endIdx);
        }

        return result;
    };

    var GetTypingString = function (text, typeIdx, textLength, typeMode) {
        var textObject = this.parent;
        var result;
        if (typeMode === 0) { //left-to-right
            var startIdx = 0;
            var endIdx = typeIdx;
            this.insertIndex = endIdx;
            result = GetSubString(textObject, text, startIdx, endIdx);

        } else if (typeMode === 1) { //right-to-left
            var endIdx = textLength;
            var startIdx = endIdx - typeIdx;
            this.insertIndex = 0;
            result = GetSubString(textObject, text, startIdx, endIdx);

        } else if (typeMode === 2) { //middle-to-sides
            var midIdx = textLength / 2;
            var startIdx = Math.floor(midIdx - (typeIdx / 2));
            var endIdx = startIdx + typeIdx;
            this.insertIndex = (typeIdx % 2) ? typeIdx : 0;
            result = GetSubString(textObject, text, startIdx, endIdx);

        } else if (typeMode === 3) { //sides-to-middle
            var lowerLen = Math.floor(typeIdx / 2);
            var lowerResult;
            if (lowerLen > 0) {
                var endIdx = textLength;
                var startIdx = endIdx - lowerLen;
                lowerResult = GetSubString(textObject, text, startIdx, endIdx);
            } else {
                lowerResult = "";
            }

            var upperLen = typeIdx - lowerLen;
            var upperResult;
            if (upperLen > 0) {
                var startIdx = 0;
                var endIdx = startIdx + upperLen;
                this.insertIndex = endIdx;
                upperResult = GetSubString(textObject, text, startIdx, endIdx);
            } else {
                upperResult = "";
                this.insertIndex = 0;
            }
            result = upperResult + lowerResult;
        }

        this.insertChar = result.charAt(this.insertIndex - 1);

        return result;
    };

    var StopTyping = function (showAllText) {
        var timer = this.getTimer();
        if (timer) {
            this.freeTimer();
        }
        if (showAllText) {
            // Fire 'type' event for remainder characters until lastChar
            while (!this.isLastChar) {
                GetTypingString.call(this, this.text, this.typingIndex, this.textLength, this.typeMode);
                this.emit('typechar', this.insertChar);
                this.typingIndex++;
            }
            // Display all characters on text game object
            this.setText(this.text);
            this.emit('type');
            this.emit('complete', this, this.parent);
        }

        return this;
    };

    var PauseTyping = function () {
        var timer = this.getTimer();
        if (timer) {
            timer.paused = true;
        }
        return this;
    };

    var ResumeTyping = function () {
        var timer = this.getTimer();
        if (timer) {
            timer.paused = false;
        }
        return this;
    };

    var methods$9 = {
        start: StartTyping,
        startFromLine: StartTypingFromLine,
        stop: StopTyping,
        pause: PauseTyping,
        resumeTyping: ResumeTyping,
    };

    Object.assign(
        methods$9,
        SetTextMethods$1
    );

    var GetWrapText = function (textObject, text) {
        var textObjectType = GetTextObjectType(textObject);
        switch (textObjectType) {
            case TextType:
                textObject.style.syncFont(textObject.canvas, textObject.context);
                text = textObject.runWordWrap(text);
                break;
            case TagTextType:
                text = textObject.getText(text, undefined, undefined, true);
                break;
            case BitmapTextType:
                text = textObject.setText(text).getTextBounds().wrappedText;
                break;
        }
        return text;
    };

    const GetFastValue = Phaser.Utils.Objects.GetFastValue;
    const GetValue$Z = Phaser.Utils.Objects.GetValue;

    class TextTyping extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;

            this.timer = null;
            this.resetFromJSON(config);
        }

        resetFromJSON(o) {
            this.setTextWrapEnable(GetValue$Z(o, 'wrap', false));
            this.setTypeMode(GetValue$Z(o, 'typeMode', 0));
            this.setTypingSpeed(GetValue$Z(o, 'speed', 333));
            this.setTextCallback = GetFastValue(o, 'setTextCallback', null);
            this.setTextCallbackScope = GetFastValue(o, 'setTextCallbackScope', null);

            this.setTypingContent(GetFastValue(o, 'text', ''));
            this.typingIndex = GetFastValue(o, 'typingIndex', 0);
            this.insertIndex = null;
            this.insertChar = null;

            var elapsed = GetFastValue(o, 'elapsed', null);
            if (elapsed !== null) {
                this.start(undefined, undefined, this.typingIndex, elapsed);
            }

            return this;
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            this.freeTimer();

            super.shutdown(fromScene);
        }

        setTypeMode(m) {
            if (typeof (m) === 'string') {
                m = TYPEMODE[m];
            }
            this.typeMode = m;
            return this;
        }

        setTypeSpeed(speed) {
            this.speed = speed;
            return this;
        }

        setTypingSpeed(speed) {
            this.speed = speed;
            return this;
        }

        setTextWrapEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.textWrapEnable = enable;
            return this;
        }

        set text(value) {
            var text = GetString(value);
            if (this.textWrapEnable) {
                text = GetWrapText(this.parent, text);
            }

            this._text = text;
        }

        get text() {
            return this._text;
        }

        get isTyping() {
            return (this.getTimer() !== null);
        }

        get isLastChar() {
            return (this.typingIndex === this.textLength);
        }

        setTypingContent(text) {
            this.text = text;
            this.textLength = GetPlainText(this.parent, this.text).length;
            return this;
        }

        onTyping() {
            var newText = GetTypingString.call(this, this.text, this.typingIndex, this.textLength, this.typeMode);

            this.setText(newText);

            this.emit('typechar', this.insertChar);
            this.emit('type');

            if (this.isLastChar) {
                this.freeTimer();
                // Fire 'complete' next tick, to render last character on screen
                this.scene.sys.events.once('preupdate', function () {
                    this.emit('complete', this, this.parent);
                }, this);
            } else {
                this.timer.delay = this.speed; // delay of next typing            
                this.typingIndex++;
            }
        }

        startTimer(timerStartAt) {
            if (this.timer) {
                this.freeTimer();
            }
            var startAt;
            if (timerStartAt === undefined) {
                startAt = 0;
            } else {
                this.speed;
                startAt = timerStartAt;
            }

            this.timer = this.scene.time.addEvent({
                delay: 0.0001,
                startAt: startAt,
                loop: true,
                callback: this.onTyping,
                callbackScope: this
            });
            // Note: Throw error message if delay is 0 with repeat/loop

            return this;
        }

        getTimer() {
            return this.timer;
        }

        freeTimer() {
            if (this.timer) {
                this.timer.remove();
                this.timer = null;
            }

            return this;
        }

        setText(text) {
            if (this.setTextCallback) {
                if (this.setTextCallbackScope) {
                    text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIndex);
                } else {
                    text = this.setTextCallback(text, this.isLastChar, this.insertIndex);
                }
            }

            if (this.textWrapEnable) {
                SetNoWrapText(this.parent, text);
            } else {
                this.parent.setText(text);
            }
        }
    }

    const TYPEMODE = {
        'left-to-right': 0,
        'right-to-left': 1,
        'middle-to-sides': 2,
        'sides-to-middle': 3
    };

    Object.assign(
        TextTyping.prototype,
        methods$9
    );

    const GetValue$Y = Phaser.Utils.Objects.GetValue;

    var TextBoxBase = function (GOClass, type) {
        if (type === undefined) {
            type = 'rexTextBox';
        }
        class TextBox extends GOClass {
            constructor(scene, config) {
                super(scene, config);
                this.type = type;
                this.isRunning = false;
                this._isPageEnd = false;

                // childrenMap must have 'text' element
                var text = this.childrenMap.text;

                // Expand text size
                var expandTextWidth = GetValue$Y(config, 'expandTextWidth', false);
                var expandTextHeight = GetValue$Y(config, 'expandTextHeight', false);
                if (expandTextWidth || expandTextHeight) {
                    var textObjectType = GetTextObjectType(text);
                    switch (textObjectType) {
                        case TextType:
                        case TagTextType:
                            // Don't overwrite resize method if text has it already
                            text.resize = function (width, height) {
                                var fixedWidth = (expandTextWidth) ? width : 0;
                                var fixedHeight = (expandTextHeight) ? height : 0;
                                text.setFixedSize(fixedWidth, fixedHeight);

                                if (fixedWidth > 0) {
                                    text.setWordWrapWidth(fixedWidth);
                                }
                            };

                            if (textObjectType === TagTextType) {
                                var style = text.style;
                                if (style.wrapMode === 0) { // Turn no-wrap to word-wrap
                                    style.wrapMode = 1;
                                }
                            }
                            break;

                    }

                    if (expandTextWidth) {
                        text._minWidth = 0;
                    }
                    if (expandTextHeight) {
                        text._minHeight = 0;
                    }
                }

                // Build typing and page behaviors
                this.setTypingMode(GetValue$Y(config, 'typingMode', 'page'));
                this.page = new TextPage(text, GetValue$Y(config, 'page', undefined));
                this.typing = new TextTyping(text, GetValue$Y(config, 'typing', config.type));
                this.typing
                    .on('complete', this.onTypingComplete, this)
                    .on('type', this.onType, this)
                    .on('typechar', this.onTypeChar, this);

                // Run layout again when size of text game object has changed
                this.textWidthSave = text.width;
                this.textHeightSave = text.height;
            }

            setTypingMode(mode) {
                if (typeof (mode) === 'string') {
                    mode = TypingMode[mode];
                }
                this.typingMode = mode;
                return this;
            }

            start(text, speed) {
                if (speed !== undefined) {
                    this.setTypingSpeed(speed);
                }

                // Start typing task
                this.isRunning = true;

                this.page.setText(text);

                this.emit('start');

                if (this.typingMode === 0) {
                    // Typing page by page
                    this.typeNextPage();
                } else {
                    // Typing line by line
                    this.typeNextLine();
                }
                return this;
            }

            more(text, speed) {
                if (speed !== undefined) {
                    this.setTypingSpeed(speed);
                }

                if (this.isRunning) {
                    this.page.appendText(text);
                    this.typing.appendText(text);

                } else {
                    this.isRunning = true;

                    this.page.appendText(text);

                    this.emit('start');

                    if (this.typingMode === 0) {
                        this._isPageEnd = false;
                        var txt = this.page.getPage();
                        var startIndex = this.typing.textLength;
                        this.typing.start(txt, undefined, startIndex);

                    }
                    return this;
                }
            }

            typeNextPage() {
                // Do nothing if typing task does not start
                if (!this.isRunning) {
                    return this;
                }

                if (!this.isLastPage) {
                    this._isPageEnd = false;
                    var txt = this.page.getNextPage();
                    this.typing.start(txt);

                } else {
                    this.emit('complete');

                }
                return this;
            }

            typeNextLine() {
                // Do nothing if typing task does not start
                if (!this.isRunning) {
                    return this;
                }

                if (!this.isLastLine) {
                    var txt = this.page.getPageOfNextLine();

                    var startLineIndex;
                    if (this.isFirstLine) {
                        // Typing from 1st line
                        startLineIndex = 0;
                    } else {
                        // Typing last line
                        startLineIndex = this.page.pageLinesCount - 1;
                    }
                    this.typing.startFromLine(txt, startLineIndex);

                } else {
                    // Stop typing tasl if typing complete at last line

                    this.isRunning = false;
                    this.emit('pageend');
                    this.emit('complete');

                }
            }

            pause() {
                // Do nothing if typing task does not start
                if (!this.isRunning) {
                    return this;
                }

                if (this.isTyping) {
                    this.typing.pause();
                    this.emit('pause');
                }
                return this;
            }

            resume() {
                // Do nothing if typing task does not start
                if (!this.isRunning) {
                    return this;
                }

                if (!this.isTyping) {
                    this.emit('resume');
                    this.typing.resume();
                }
                return this;
            }

            stop(showAllText) {
                // Do nothing if typing task does not start
                if (!this.isRunning) {
                    return this;
                }

                this.typing.stop(showAllText);
                return this;
            }

            showLastPage() {
                // Do nothing if typing task does not start
                if (!this.isRunning) {
                    return this;
                }

                this.typing.stop();
                if (this.typingMode === 0) {
                    this.page.showLastPage();
                } else {
                    this.page.showLastLine();
                }
                this.emit('type');
                this.onTypingComplete();
                return this;
            }

            setTypeSpeed(speed) {
                this.typing.setTypingSpeed(speed);
                return this;
            }

            setTypingSpeed(speed) {
                this.typing.setTypingSpeed(speed);
                return this;
            }

            get isTyping() {
                return this.typing.isTyping;
            }

            get isPageEnd() {
                return this._isPageEnd;
            }

            get isLastPage() {
                return this.page.isLastPage;
            }

            get isFirstPage() {
                return this.page.isFirstPage;
            }

            get pageCount() {
                return this.page.pageCount;
            }

            get pageIndex() {
                return this.page.pageIndex;
            }

            get isLastLine() {
                return this.page.isLastLine;
            }

            get isFirstLine() {
                return this.page.isFirstLine;
            }

            get lineCound() {
                return this.page.totalLinesCount;
            }

            get startLineIndex() {
                return this.page.startLineIndex;
            }

            get endLineIndex() {
                return this.page.endLineIndex;
            }

            get typingSpeed() {
                return this.typing.speed;
            }

            onType() {
                var text = this.childrenMap.text;
                if ((this.textWidthSave !== text.width) || (this.textHeightSave !== text.height)) {
                    this.textWidthSave = text.width;
                    this.textHeightSave = text.height;
                    this.getTopmostSizer().layout();
                }
                this.emit('type');
            }

            onTypeChar(char) {
                this.emit('typechar', char);
            }

            onTypingComplete() {
                if (this.typingMode === 0) {
                    this._isPageEnd = true;
                    var isLastPage = this.isLastPage;

                    // Stop typing tasl if typing complete at last page
                    this.isRunning = !isLastPage;

                    this.emit('pageend');
                    /*
                    Might enter this method immediately, if invoking typeNextPage() in this 'pageend' event.
                    */

                    if (isLastPage) {
                        this.emit('complete');
                    }

                } else {
                    // Typing next line continually
                    this.typeNextLine();

                }

            }

        }

        return TextBox;
    };

    const TypingMode = {
        page: 0,
        line: 1
    };

    class TextBox extends TextBoxBase(TitleLabel) {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            if (!config.hasOwnProperty('layoutMode')) {
                config.layoutMode = 1;
            }

            super(scene, config);
        }
    }

    ObjectFactory.register('textBox', function (config) {
        var gameObject = new TextBox(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TextBox', TextBox);

    class SimpleTextBox extends TextBox {
        constructor(scene, config, creators) {
            config = BuildTitleLabelConfig(scene, config, creators);
            super(scene, config);
        }
    }

    ObjectFactory.register('simpleTextBox', function (config) {
        var gameObject = new SimpleTextBox(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.SimpleTextBox', SimpleTextBox);

    const GetValue$X = Phaser.Utils.Objects.GetValue;

    class NumberBar extends Sizer {
        constructor(scene, config) {
            // Create sizer
            super(scene, config);
            this.type = 'rexNumberBar';

            // Add elements
            var background = GetValue$X(config, 'background', undefined);
            var icon = GetValue$X(config, 'icon', undefined);
            var iconMask = GetValue$X(config, 'iconMask', undefined);
            var sliderConfig = GetValue$X(config, 'slider', undefined);
            var text = GetValue$X(config, 'text', undefined);

            // Space
            var iconSpace = GetValue$X(config, 'space.icon', 0);
            var sliderSpace = GetValue$X(config, 'space.slider', 0);

            if (background) {
                this.addBackground(background);
            }

            if (icon) {
                var padding;
                if (this.orientation === 0) {
                    if (sliderConfig || text) {
                        padding = { right: iconSpace };
                    }
                } else {
                    if (sliderConfig || text) {
                        padding = { bottom: iconSpace };
                    }
                }

                this.add(icon,
                    {
                        proportion: 0,
                        align: 'center',
                        padding: padding
                    }
                );

                if (iconMask) {
                    iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
                }
            }

            var slider;
            if (sliderConfig) {
                sliderConfig.orientation = this.orientation;
                sliderConfig.eventEmitter = this;
                sliderConfig.value = null;
                if (!sliderConfig.hasOwnProperty('input')) {
                    sliderConfig.input = -1;
                }
                slider = new Slider(scene, sliderConfig);
                scene.add.existing(slider);

                var padding;
                if (this.orientation === 0) {
                    if (text) {
                        padding = { right: sliderSpace };
                    }
                } else {
                    if (text) {
                        padding = { bottom: sliderSpace };
                    }
                }

                var proportion;
                if (this.orientation === 0) {
                    var sliderWidth = GetValue$X(sliderConfig, 'width', undefined);
                    proportion = (sliderWidth === undefined) ? 1 : 0;
                } else {
                    var sliderHeight = GetValue$X(sliderConfig, 'height', undefined);
                    proportion = (sliderHeight === undefined) ? 1 : 0;
                }

                this.add(slider,
                    {
                        proportion: proportion,
                        align: 'center',
                        padding: padding
                    }
                );
            }


            if (text) {
                this.add(text);
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('icon', icon);
            this.addChildrenMap('iconMask', iconMask);
            this.addChildrenMap('slider', slider);
            this.addChildrenMap('text', text);

            var callback = GetValue$X(config, 'valuechangeCallback', null);
            if (callback !== null) {
                var scope = GetValue$X(config, 'valuechangeCallbackScope', undefined);
                this.on('valuechange', callback, scope);
            }
            this.setEnable(GetValue$X(config, 'enable', undefined));
            this.setValue(GetValue$X(config, 'value', 0));
        }

        get enable() {
            if (this.childrenMap.slider) {
                return this.childrenMap.slider.enable;
            } else {
                return false;
            }
        }

        set enable(value) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setEnable(value);
            }
        }

        setEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.enable = enable;
            return this;
        }

        get value() {
            if (this.childrenMap.slider) {
                return this.childrenMap.slider.value;
            } else {
                return 0;
            }
        }

        set value(value) {
            if (!this.childrenMap.slider) {
                return;
            }
            this.childrenMap.slider.value = value;
        }

        setValue(value, min, max) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setValue(value, min, max);
            }
            return this;
        }

        addValue(inc, min, max) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.addValue(inc, min, max);
            }
            return this;
        }

        getValue(min, max) {
            if (this.childrenMap.slider) {
                return this.childrenMap.slider.getValue(min, max);
            } else {
                return 0;
            }
        }

        easeValueTo(value, min, max) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.easeValueTo(value, min, max);
            }
            return this;
        }

        stopEaseValue() {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.stopEaseValue();
            }
            return this;
        }

        setEaseValueDuration(duration) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setEaseValueDuration(duration);
            }
            return this;
        }

        setEaseValueFunction(ease) {
            if (this.childrenMap.slider) {
                this.childrenMap.slider.setEaseValueFunction(ease);
            }
            return this;
        }

        get text() {
            var textObject = this.childrenMap.text;
            if (textObject === undefined) {
                return '';
            }
            var value;
            if (textObject.text) {
                value = textObject.text;
            } else {
                value = textObject.getData('text');
            }
            return value;
        }

        set text(value) {
            var textObject = this.childrenMap.text;
            if (textObject === undefined) {
                return;
            }
            if (textObject.setText) {
                textObject.setText(value);
            } else {
                textObject.setData('text', value);
            }
        }

        setText(value) {
            this.text = value;
            return this;
        }
    }

    ObjectFactory.register('numberBar', function (config) {
        var gameObject = new NumberBar(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.NumberBar', NumberBar);

    ObjectFactory.register('scrollBar', function (config) {
        var gameObject = new ScrollBar(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ScrollBar', ScrollBar);

    const GetValue$W = Phaser.Utils.Objects.GetValue;
    const BadgeKeys = {
        leftTop: 'left-top', centerTop: 'center-top', rightTop: 'right-top',
        leftCenter: 'left-center', center: 'center', rightCenter: 'right-center',
        leftBottom: 'left-bottom', centerBottom: 'center-bottom', rightBottom: 'right-bottom'
    };

    class Badge extends OverlapSizer {
        constructor(scene, config) {
            // Create sizer  
            super(scene, config);
            this.type = 'rexBadge';

            // Add elements
            var background = GetValue$W(config, 'background', undefined);
            if (background) {
                this.addBackground(background);
            }
            this.addChildrenMap('background', background);

            // Base item
            var main = GetValue$W(config, 'main', undefined);
            if (main) {
                this.add(main, {
                    key: 'main',
                    align: 'center',
                    expand: false,
                });
            }
            this.addChildrenMap('main', main);

            // Badges
            for (var key in BadgeKeys) {
                var badge = GetValue$W(config, key, undefined);
                if (badge) {
                    this.add(badge, {
                        key: key,
                        align: BadgeKeys[key],
                        expand: false,
                    });
                    this.addChildrenMap(key, badge);
                }            
            }
        }
    }

    ObjectFactory.register('badgeLabel', function (config) {
        var gameObject = new Badge(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.BadgeLabel', Badge);

    const OverlapSizerAdd = OverlapSizer.prototype.add;

    var Add = function (gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY) {
        gameObject.setVisible(false); // Default is invisible
        OverlapSizerAdd.call(this, gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY);
        return this;
    };

    var AddChildMethods = {
        add: Add,
        addPage: Add
    };

    var GetPage$1 = function (key) {
        if (key === undefined) {
            return null;
        } else if (!this.sizerChildren.hasOwnProperty(key)) {
            return null;
        } else {
            return this.sizerChildren[key];
        }
    };

    const ContainerSetChildVisible$1 = ContainerLite.prototype.setChildVisible;

    var SwapPage$1 = function (key, fadeInDuration) {
        this._previousKey = this._currentKey;
        var prevoiusPage = this.previousPage;
        if (prevoiusPage) {
            if (this.swapMode === 0) { // Invisible
                ContainerSetChildVisible$1.call(this, prevoiusPage, false);
                this.emit('pageinvisible', prevoiusPage, this._previousKey, this);
            } else { // Destroy
                prevoiusPage.destroy();
            }
        }

        if (key && !this.sizerChildren.hasOwnProperty(key)) {
            this.emit('createpage', key, this);
        }

        this._currentKey = key;
        var currentPage = this.currentPage;
        if (currentPage) {
            ContainerSetChildVisible$1.call(this, currentPage, true);
            this.emit('pagevisible', currentPage, this._currentKey, this);

            if (fadeInDuration === undefined) {
                fadeInDuration = this.fadeInDuration;
            }

            if (fadeInDuration > 0) {
                currentPage.setAlpha(0).fadeIn(fadeInDuration, 1);
            }
        }
        return this;
    };

    var HasPage = function (key) {
        return this.sizerChildren.hasOwnProperty(key);
    };

    var methods$8 = {
        getPage: GetPage$1,
        swapPage: SwapPage$1,
        hasPage: HasPage,
    };

    Object.assign(
        methods$8,
        AddChildMethods,
    );

    const GetValue$V = Phaser.Utils.Objects.GetValue;

    class Pages extends OverlapSizer {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexPages';
            this.childrenMap = this.sizerChildren;
            this._previousKey = undefined;
            this._currentKey = undefined;
            this.setSwapMode(GetValue$V(config, 'swapMode', 0));
            this.setFadeInDuration(GetValue$V(config, 'fadeIn', 0));
        }

        setSwapMode(mode) {
            if (typeof (mode) === 'string') {
                mode = SWAPMODE[mode];
            }
            this.swapMode = mode;
            return this;
        }

        setFadeInDuration(duration) {
            this.fadeInDuration = duration;
            return this;
        }

        get previousKey() {
            return this._previousKey;
        }

        get currentKey() {
            return this._currentKey;
        }

        set currentKey(key) {
            this.swapPage(key);
        }

        get currentPage() {
            return this.getPage(this.currentKey);
        }

        get previousPage() {
            return this.getPage(this.previousKey);
        }

        get keys() {
            return Object.keys(this.sizerChildren);
        }
    }

    Object.assign(
        Pages.prototype,
        methods$8
    );

    const SWAPMODE = {
        invisible: 0,
        destroy: 1
    };

    ObjectFactory.register('pages', function (config) {
        var gameObject = new Pages(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Pages', Pages);

    const Mesh = Phaser.GameObjects.Mesh;

    class MeshBase extends Mesh {
        get tint() {
            if (this.vertices.length === 0) {
                return 0xffffff;
            } else {
                return this.vertices[0].color;
            }
        }

        forceUpdate() {
            this.dirtyCache[10] = 1;
            return this;
        }

    }

    const Vector3 = Phaser.Math.Vector3;
    const Matrix4 = Phaser.Math.Matrix4;

    var tempPosition = new Vector3();
    var tempRotation = new Vector3();
    var tempMatrix = new Matrix4();

    var TransformVerts = function (mesh, x, y, z, rotateX, rotateY, rotateZ) {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (z === undefined) { z = 0; }
        if (rotateX === undefined) { rotateX = 0; }
        if (rotateY === undefined) { rotateY = 0; }
        if (rotateZ === undefined) { rotateZ = 0; }

        tempPosition.set(x, y, z);
        tempRotation.set(rotateX, rotateY, rotateZ);
        tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, true);

        for (var i = 0, cnt = mesh.vertices.length; i < cnt; i++) {
            mesh.vertices[i].transformMat4(tempMatrix);
        }
    };

    const IsPlainObject$9 = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$U = Phaser.Utils.Objects.GetValue;
    const GenerateGridVerts = Phaser.Geom.Mesh.GenerateGridVerts;
    const RadToDeg$2 = Phaser.Math.RadToDeg;
    const DegToRad$3 = Phaser.Math.DegToRad;

    const FOV = 45;
    const PanZ = 1 + (1 / Math.sin(DegToRad$3(FOV)));

    let Image$2 = class Image extends MeshBase {
        constructor(scene, x, y, key, frame, config) {
            if (IsPlainObject$9(x)) {
                config = x;
                x = GetValue$U(config, 'x', 0);
                y = GetValue$U(config, 'y', 0);
                key = GetValue$U(config, 'key', null);
                frame = GetValue$U(config, 'frame', null);
            }

            super(scene, x, y, key, frame);
            this.type = 'rexPerspectiveImage';
            this.setSizeToFrame();

            this.resetPerspective();
            this.panZ(PanZ);
            this.hideCCW = GetValue$U(config, 'hideCCW', true);

            var gridWidth = GetValue$U(config, 'gridWidth', 0);
            var gridHeight = GetValue$U(config, 'gridHeight', gridWidth);
            this.resetVerts(gridWidth, gridHeight);

            this.prevFrame = this.frame;
        }

        preUpdate(time, delta) {
            // Reset size and vertex if frame is changed
            if (this.prevFrame !== this.frame) {
                this.prevFrame = this.frame;
                this.syncSize();
            }

            super.preUpdate(time, delta);
        }

        get originX() {
            return 0.5;
        }

        get originY() {
            return 0.5;
        }

        resetPerspective() {
            this.setPerspective(this.width, this.height, FOV);
            return this;
        }

        resetVerts(gridWidth, gridHeight) {
            if (gridWidth !== undefined) {
                this.gridWidth = gridWidth;
            }
            if (gridHeight !== undefined) {
                this.gridHeight = gridHeight;
            }

            // Clear faces and vertices
            this.clear();
            this.dirtyCache[9] = -1;
            if ((this.width === 0) || (this.height === 0)) {
                return this;
            }

            // Generate faces and vertices
            var frameWidth = this.frame.cutWidth,
                frameHeight = this.frame.cutHeight;

            var gridWidth, gridHeight;
            if (this.gridWidth === 0) {
                gridWidth = Math.max(frameWidth / 8, 32);
            } else {
                gridHeight = this.gridWidth;
            }
            if (this.gridHeight === 0) {
                gridHeight = Math.max(frameHeight / 8, 32);
            } else {
                gridHeight = this.gridHeight;
            }

            GenerateGridVerts({
                mesh: this,

                width: frameWidth / this.height,
                height: frameHeight / this.height,

                widthSegments: Math.ceil(frameWidth / gridWidth),
                heightSegments: Math.ceil(frameHeight / gridHeight),
            });

            // Recover vertices transform
            var transformInfo = this.transformInfo;
            if (transformInfo) {
                this.transformVerts(
                    transformInfo.x, transformInfo.y, transformInfo.z,
                    transformInfo.rotateX, transformInfo.rotateY, transformInfo.rotateZ
                );
            }

            return this;
        }

        syncSize() {
            this.setSizeToFrame();  // Reset size
            this.resetPerspective();  // Reset perspective
            this.resetVerts();  // Reset verts
            return this;
        }

        get rotationX() {
            return this.modelRotation.x;
        }

        set rotationX(value) {
            this.modelRotation.x = value;
        }

        get angleX() {
            return RadToDeg$2(this.rotationX);
        }

        set angleX(value) {
            this.rotationX = DegToRad$3(value);
        }

        get rotationY() {
            return this.modelRotation.y;
        }

        set rotationY(value) {
            this.modelRotation.y = value;
        }

        get angleY() {
            return RadToDeg$2(this.rotationY);
        }

        set angleY(value) {
            this.rotationY = DegToRad$3(value);
        }

        get rotationZ() {
            return this.modelRotation.z;
        }

        set rotationZ(value) {
            this.modelRotation.z = value;
        }

        get angleZ() {
            return RadToDeg$2(this.rotationZ);
        }

        set angleZ(value) {
            this.rotationZ = DegToRad$3(value);
        }

        transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (z === undefined) { z = 0; }
            if (rotateX === undefined) { rotateX = 0; }
            if (rotateY === undefined) { rotateY = 0; }
            if (rotateZ === undefined) { rotateZ = 0; }

            if (!this.transformInfo) {
                this.transformInfo = {};
            }

            this.transformInfo.x = x;
            this.transformInfo.y = y;
            this.transformInfo.rotateX = rotateX;
            this.transformInfo.rotateY = rotateY;
            this.transformInfo.rotateZ = rotateZ;

            TransformVerts(this, x, y, z, rotateX, rotateY, rotateZ);
            return this;
        }

    };

    const DynamicTexture = Phaser.Textures.DynamicTexture;

    var CreateDynamicTexture = function (scene, width, height) {
        if (width === undefined) {
            width = 2;
        }
        if (height === undefined) {
            height = 2;
        }
        var dt = new DynamicTexture(scene.sys.textures, null, width, height);
        return dt;
    };

    const IsPlainObject$8 = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$T = Phaser.Utils.Objects.GetValue;

    class RenderTexture extends Image$2 {
        constructor(scene, x, y, width, height, config) {
            if (IsPlainObject$8(x)) {
                config = x;
                x = GetValue$T(config, 'x', 0);
                y = GetValue$T(config, 'y', 0);
                width = GetValue$T(config, 'width', 32);
                height = GetValue$T(config, 'height', 32);
            }

            // dynamic-texture -> quad-image
            var texture = CreateDynamicTexture(scene, width, height);

            super(scene, x, y, texture, null, config);
            this.type = 'rexPerspectiveRenderTexture';
            this.rt = this.texture;
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            super.destroy(fromScene);

            this.rt.destroy();
            this.rt = null;
        }

        snapshot(gameObjects, config) {
            if (config === undefined) {
                config = {};
            }
            config.gameObjects = gameObjects;
            config.renderTexture = this.rt;

            Snapshot(config);

            if ((this.width !== this.frame.realWidth) || (this.height !== this.frame.realHeight)) {
                this.syncSize();
            }

            return this;
        }
    }

    Phaser.Animations.AnimationState;
    Phaser.Utils.Objects.IsPlainObject;
    Phaser.Utils.Objects.GetValue;

    var ForEachFace = function (faces, callback, scope, ignoreInvalid) {
        if (Array.isArray(faces)) {
            var isBreak = false;
            for (var i = 0, cnt = faces.length; i < cnt; i++) {
                var face = faces[i];
                if (ignoreInvalid && !face) {
                    continue;
                }
                if (scope) {
                    isBreak = callback.call(scope, face, i, faces);
                } else {
                    isBreak = callback(face, i, faces);
                }

                if (isBreak) {
                    return;
                }
            }
        } else {
            var isBreak = false;
            for (var name in faces) {
                var face = faces[name];
                if (ignoreInvalid && !face) {
                    continue;
                }
                if (scope) {
                    isBreak = callback.call(scope, face, name, faces);
                } else {
                    isBreak = callback(face, name, faces);
                }

                if (isBreak) {
                    return;
                }
            }
        }
    };

    const RadToDeg$1 = Phaser.Math.RadToDeg;
    const DegToRad$2 = Phaser.Math.DegToRad;

    class FaceContainer extends ContainerLite {
        constructor(scene, x, y, width, height, faces) {
            super(scene, x, y, width, height);
            this.faces = faces;  // Face Dictionary, or array

            ForEachFace(faces, function (face) {
                face.setPosition(x, y);
                this.add(face);
            }, this, true);
        }

        // Override
        get rotationX() {
            return 0;
        }

        // Override
        set rotationX(value) {
            // rad
        }

        get angleX() {
            return RadToDeg$1(this.rotationX);
        }

        set angleX(value) {
            this.rotationX = DegToRad$2(value);
        }

        get rotateX() {
            return RadToDeg$1(this.rotationX);
        }

        set rotateX(value) {
            this.rotationX = DegToRad$2(value);
        }

        // Override
        get rotationY() {
            return 0;
        }

        // Override
        set rotationY(value) {
            // rad
        }

        get angleY() {
            return RadToDeg$1(this.rotationY);
        }

        set angleY(value) {
            this.rotationY = DegToRad$2(value);
        }

        get rotateY() {
            return RadToDeg$1(this.rotationY);
        }

        set rotateY(value) {
            this.rotationY = DegToRad$2(value);
        }

        // Override
        get rotationZ() {
            return 0;
        }

        // Override
        set rotationZ(value) {
            // rad
        }

        get angleZ() {
            return RadToDeg$1(this.rotationZ);
        }

        set angleZ(value) {
            this.rotationZ = DegToRad$2(value);
        }

        get rotateZ() {
            return RadToDeg$1(this.rotationZ);
        }

        set rotateZ(value) {
            this.rotationZ = DegToRad$2(value);
        }

        setDebug(graphic, callback) {
            ForEachFace(this.faces, function (face) {
                face.setDebug(graphic, callback);
            }, null, true);
            return this;
        }

        panX(v) {
            ForEachFace(this.faces, function (face) {
                face.panX(v);
            }, null, true);
            return this;
        }

        panY(v) {
            ForEachFace(this.faces, function (face) {
                face.panY(v);
            }, null, true);
            return this;
        }

        panZ(v) {
            ForEachFace(this.faces, function (face) {
                face.panZ(v);
            }, null, true);
            return this;
        }

        transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
            ForEachFace(this.faces, function (face) {
                face.transformVerts(x, y, z, rotateX, rotateY, rotateZ);
            }, null, true);
            return this;
        }

        forEachFace(callback, scope, ignoreInvalid) {
            ForEachFace(this.faces, callback, scope, ignoreInvalid);
            return this;
        }

    }

    const IsPlainObject$7 = Phaser.Utils.Objects.IsPlainObject;
    const DefaultImageConfig = { key: '__WHITE' };
    const ClassMap = {
        image: Image$2,
        rendertexture: RenderTexture
    };

    var CreatePerspectiveObject = function (scene, config) {
        if (config === undefined) {
            config = DefaultImageConfig;
        }

        var perspectiveObject;
        if (IsPlainObject$7(config)) {
            if (!config.hasOwnProperty('type')) {
                if (config.hasOwnProperty('key')) {
                    config.type = 'image';
                } else if (config.hasOwnProperty('width')) {
                    config.type = 'rendertexture';
                }
            }

            perspectiveObject = new (ClassMap[config.type])(scene, config);
            scene.add.existing(perspectiveObject);
        } else {
            perspectiveObject = config;
        }

        return perspectiveObject;
    };

    var CreateFaces = function (scene, config, faceNames) {
        var faces;
        if (faceNames === undefined) { // Return an array of faces
            faces = [];
            var face, faceConfig;
            for (var i = 0, cnt = config.length; i < cnt; i++) {
                faceConfig = config[i];
                if (faceConfig) {
                    face = CreatePerspectiveObject(scene, faceConfig);
                } else {
                    face = null;
                }
                faces.push(face);
            }
        } else { // Return a face map
            faces = {};
            var face, name;
            for (var i = 0, cnt = faceNames.length; i < cnt; i++) {
                name = faceNames[i];
                if (config.hasOwnProperty(name)) {
                    face = CreatePerspectiveObject(scene, config[name]);
                } else {
                    face = null;
                }

                faces[name] = face;
            }
        }

        return faces;
    };

    const DegToRad$1 = Phaser.Math.DegToRad;

    const RAD180 = DegToRad$1(180);

    var LayoutFaces = function (parent, faces) {
        var backFace = faces.back;
        if (backFace) {
            if (parent.orientation === 0) { // Flip around Y
                backFace.transformVerts(0, 0, 0, 0, RAD180, 0);
            } else { // Flip around X
                backFace.transformVerts(0, 0, 0, RAD180, 0, 0);
            }
        }
    };

    const GetValue$S = Phaser.Utils.Objects.GetValue;
    const Linear$2 = Phaser.Math.Linear;

    let Flip$1 = class Flip extends EaseValueTaskBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;
            // this.timer

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setEase(GetValue$S(o, 'ease', 'Cubic'));

            this.setFrontToBackDirection(GetValue$S(o, 'frontToBack', 0));
            this.setBackToFrontDirection(GetValue$S(o, 'backToFront', 1));
            return this;
        }

        setFrontToBackDirection(direction) {
            if (typeof (direction) === 'string') {
                direction = DIRMODE[direction];
            }
            this.endAngleFB = (direction === 0) ? 180 : -180;
            return this;
        }

        setBackToFrontDirection(direction) {
            if (typeof (direction) === 'string') {
                direction = DIRMODE[direction];
            }
            this.endAngleBF = (direction === 0) ? -180 : 180;
            return this;
        }

        start(duration, repeat) {
            if (this.timer.isRunning) {
                return this;
            }

            this.timer
                .setDelay(this.delay)
                .setDuration(duration);

            var loop = repeat + 1;
            var gameObject = this.parent;
            if (gameObject.face === 0) {  // isFrontToBack
                this.startAngle = 0;
                this.endAngle = this.endAngleFB * loop;
            } else {
                this.startAngle = this.endAngleBF;
                this.endAngle = this.startAngle - (this.endAngleBF * loop);
            }

            super.start();
            return this;
        }

        flip(duration, repeat) {
            if (this.isRunning) {
                return this;
            }
            if (duration === undefined) {
                duration = this.duration;
            }
            if (repeat === undefined) {
                repeat = 0;
            }

            this.start(duration, repeat);
            this.emit('start', this.parent, this);

            // Set face index
            this.parent.currentFaceIndex = (this.parent.currentFaceIndex + repeat + 1) % 2;
            return this;
        }

        flipRight(duration, repeat) {
            if (this.parent.currentFaceIndex === 0) { // Front to back
                this.setFrontToBackDirection(0);
            } else {  // Back to front
                this.setBackToFrontDirection(0);
            }
            this.flip(duration, repeat);
            return this;
        }

        flipLeft(duration, repeat) {
            if (this.parent.currentFaceIndex === 0) { // Front to back
                this.setFrontToBackDirection(1);
            } else {  // Back to front
                this.setBackToFrontDirection(1);
            }
            this.flip(duration, repeat);
            return this;
        }

        updateTarget(gameObject, timer) {
            var t = this.easeFn(timer.t);

            var value = Linear$2(this.startAngle, this.endAngle, t);
            if (gameObject.orientation === 0) {
                gameObject.angleY = value;
            } else {
                gameObject.angleX = value;
            }
        }
    };

    const DIRMODE = {
        'right': 0,
        'left-to-right': 0,
        'left': 1,
        'right-to-left': 1
    };

    const IsPlainObject$6 = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$R = Phaser.Utils.Objects.GetValue;

    const FaceNames = ['back', 'front'];

    class Card extends FaceContainer {
        constructor(scene, x, y, config) {
            if (IsPlainObject$6(x)) {
                config = x;
                x = GetValue$R(config, 'x', 0);
                y = GetValue$R(config, 'y', 0);
            }

            var faces = CreateFaces(scene, config, FaceNames);
            var backFace = faces.back;
            var frontFace = faces.front;

            var width = GetValue$R(config, 'width');
            var height = GetValue$R(config, 'height');
            if ((width === undefined) || (height === undefined)) {
                if (width === undefined) {
                    var frontFaceWidth = (frontFace) ? frontFace.width : 0;
                    var backFaceWidth = (backFace) ? backFace.width : 0;
                    width = Math.max(frontFaceWidth, backFaceWidth);
                }

                if (height === undefined) {
                    var frontFaceHeight = (frontFace) ? frontFace.height : 0;
                    var backFaceHeight = (backFace) ? backFace.height : 0;
                    height = Math.max(frontFaceHeight, backFaceHeight);
                }
            }

            super(scene, x, y, width, height, faces);
            this.type = 'rexPerspectiveCard';

            this.frontFaceRotationX = 0;
            this.frontFaceRotationY = 0;
            this.frontFaceRotationZ = 0;

            ForEachFace(faces, function (face, name) {
                this[`${name}Face`] = face;
            }, this);

            var flipConfig = GetValue$R(config, 'flip', undefined);
            if (flipConfig !== false) {
                this.flip = new Flip$1(this, flipConfig);
            }

            this.setOrientation(GetValue$R(config, 'orientation', 0));
            LayoutFaces(this, faces);

            this.setFace(GetValue$R(config, 'face', 0));
        }

        get rotationX() {
            return this.frontFaceRotationX;
        }

        set rotationX(value) {
            if (this.frontFaceRotationX === value) {
                return;
            }

            this.frontFaceRotationX = value;
            ForEachFace(this.faces, function (face) {
                face.rotationX = value;
            }, null, true);
        }

        get rotationY() {
            return this.frontFaceRotationY;
        }

        set rotationY(value) {
            if (this.frontFaceRotationY === value) {
                return;
            }

            this.frontFaceRotationY = value;
            ForEachFace(this.faces, function (face) {
                face.rotationY = value;
            }, null, true);
        }

        get rotationZ() {
            return this.frontFaceRotationZ;
        }

        set rotationZ(value) {
            if (this.frontFaceRotationZ === value) {
                return;
            }

            this.frontFaceRotationZ = value;
            ForEachFace(this.faces, function (face) {
                face.rotationZ = value;
            }, null, true);
        }

        setOrientation(orientation) {
            if (typeof (orientation) === 'string') {
                orientation = ORIENTATIONMODE$1[orientation];
            }
            this.orientation = orientation;
            return this;
        }

        get face() {
            return this.currentFaceIndex;
        }

        set face(index) {
            if (typeof (index) === 'string') {
                index = FACEMODE$1[index];
            }
            this.currentFaceIndex = index;

            var isBackFace = (index === 1);
            var angle = (isBackFace) ? 180 : 0;
            if (this.orientation === 0) {  // Flip around Y
                this.angleY = angle;
            } else {  // Flip around X
                this.angleX = angle;
            }
        }

        setFace(face) {
            this.face = face;
            return this;
        }

        toggleFace() {
            var newFace = (this.face === 0) ? 1 : 0;
            this.setFace(newFace);
            return this;
        }
    }

    const ORIENTATIONMODE$1 = {
        x: 0,
        horizontal: 0,
        h: 0,

        y: 1,
        vertical: 1,
        v: 1
    };

    const FACEMODE$1 = {
        front: 0,
        back: 1,
    };

    Phaser.Utils.Objects.GetValue;
    Phaser.Math.RadToDeg;
    Phaser.Math.DegToRad;
    Phaser.Math.Angle.WrapDegrees;
    Phaser.Math.Angle.ShortestBetween;
    Phaser.Math.Wrap;
    Phaser.Math.Linear;

    Phaser.Utils.Objects.IsPlainObject;
    Phaser.Utils.Objects.GetValue;
    Phaser.Math.DegToRad;
    Phaser.Math.RadToDeg;
    Phaser.Math.Angle.WrapDegrees;
    Phaser.Math.Linear;
    Phaser.Math.Wrap;

    Phaser.Utils.Objects.IsPlainObject;
    Phaser.Utils.Objects.GetValue;
    Phaser.Math.Wrap;

    const GetValue$Q = Phaser.Utils.Objects.GetValue;

    var Init = function (parentContainer, rtOwner, config) {
        rtOwner.visibleSibling = [];
        rtOwner.isRunning = false;
        rtOwner.useParentBounds = GetValue$Q(config, 'useParentBounds', false);

        rtOwner
            .setPosition(parentContainer.x, parentContainer.y)
            .setVisible(false);
        parentContainer.pin(rtOwner);
    };

    var Exit = function (parentContainer, rtOwner) {
        if (!parentContainer) {
            return false;
        }

        var visibleSibling = rtOwner.visibleSibling;
        // Set all visible children back
        for (var i = 0, cnt = visibleSibling.length; i < cnt; i++) {
            parentContainer.setChildVisible(visibleSibling[i], true);
        }
        visibleSibling.length = 0;

        // Set rtOwner to be invisible
        parentContainer.setChildVisible(rtOwner, false);

        rtOwner.isRunning = false;

        return true;
    };

    var Enter = function (parentContainer, rtOwner) {
        if (!parentContainer) {
            return false;
        }

        Exit(parentContainer, rtOwner);

        // Get and paste all visible children, which dose not include this render texture
        var useParentBounds = rtOwner.useParentBounds;
        Snapshot({
            gameObjects: parentContainer.getAllVisibleChildren(),
            renderTexture: rtOwner.rt,
            x: rtOwner.x,
            y: rtOwner.y,
            width: ((useParentBounds) ? parentContainer.displayWidth : undefined),
            height: ((useParentBounds) ? parentContainer.displayHeighth : undefined),
            originX: ((useParentBounds) ? parentContainer.originX : undefined),
            originY: ((useParentBounds) ? parentContainer.originY : undefined),
        });

        // Set rtOwner to be visible
        parentContainer.setChildVisible(rtOwner, true);

        // Set visible sibling to be invisible
        var visibleSibling = rtOwner.visibleSibling;
        var children = parentContainer.children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if ((child.visible) && (child !== rtOwner)) {
                parentContainer.setChildVisible(child, false);
                visibleSibling.push(child);
            }
        }

        rtOwner.isRunning = true;

        return true;
    };

    var MeshRenderTextureBase = function (RenderTextureOwnerClass) {
        return class Base extends RenderTextureOwnerClass {
            constructor(parentContainer, config) {
                var scene = parentContainer.scene;
                super(scene, 0, 0, 1, 1, config);
                scene.add.existing(this);

                Init(parentContainer, this, config);
            }

            destroy(fromScene) {
                if (!this.scene || this.ignoreDestroy) {
                    return;
                }

                this.exit();
                super.destroy(fromScene);
            }

            enter() {
                var result = Enter(this.rexContainer.parent, this);
                if (result) {
                    this.syncSize();
                }

                return this;
            }

            exit() {
                Exit(this.rexContainer.parent, this);
                return this;
            }
        }
    };

    class ContainerPerspective extends MeshRenderTextureBase(RenderTexture) {
        get perspectiveState() {
            return this.isRunning;
        }
    }

    const GetValue$P = Phaser.Utils.Objects.GetValue;

    var CreatePerspectiveCardMesh = function (config) {
        var scene = this.scene;

        this.setSnapshotPadding(GetValue$P(config, 'snapshotPadding', 0));

        config = Clone$2(config);
        // Remove size config
        delete config.width;
        delete config.height;
        // Initial size of render-texture is 1x1
        config.front = { width: 1, height: 1 };
        config.back = { width: 1, height: 1 };
        // Create PerspectiveCard as card-behavior
        var card = new Card(scene, config);
        scene.add.existing(card);

        var flip = card.flip;
        if (flip) {
            var parent = this;
            flip
                .on('start', function () {
                    // Before flipping
                    parent.enterPerspectiveMode();
                })
                .on('complete', function () {
                    // After flipping
                    parent.exitPerspectiveMode();
                });
        }

        return card;
    };

    const FaceIndexMap = ['front', 'back'];

    var PerspectiveMethods = {
        enterPerspectiveMode() {
            if (this.isInPerspectiveMode) {
                return this;
            }

            // Set card's visible to true
            this.setChildVisible(this.perspectiveCard, true);
            // Snapshot front and back children to card's faces
            this.snapshotFace(0);
            this.snapshotFace(1);
            // Set front and back children's visible to false
            this.setChildVisible(this.childrenMap.front, false);
            this.setChildVisible(this.childrenMap.back, false);
            // Reset size of card
            this.perspectiveCard.setSize(this.width, this.height);

            return this;
        },

        exitPerspectiveMode() {
            if (!this.isInPerspectiveMode) {
                return this;
            }

            // Set card's visible to false
            this.setChildVisible(this.perspectiveCard, false);
            // Set front or back children's visible to true, according to card's face
            var isFrontFace = (this.perspectiveCard.face === 0);
            this.setChildVisible(this.childrenMap.front, isFrontFace);
            this.setChildVisible(this.childrenMap.back, !isFrontFace);

            return this;
        },

        setSnapshotPadding(padding) {
            this.snapshotPadding = padding;
            return this;
        },

        snapshotFace(face) {
            if (typeof (face) === 'number') {
                face = FaceIndexMap[face];
            }

            var cardFace = this.perspectiveCard.faces[face];
            var faceChild = this.childrenMap[face];

            cardFace.rt.clear();

            var faceChildVisibleSave = faceChild.visible;
            faceChild.visible = true;

            var gameObjects = (faceChild.isRexContainerLite) ? faceChild.getAllVisibleChildren() : faceChild;
            cardFace.snapshot(
                gameObjects,
                { padding: this.snapshotPadding }
            );

            faceChild.visible = faceChildVisibleSave;

            return this;
        }

    };

    const GetValue$O = Phaser.Utils.Objects.GetValue;

    class PerspectiveCard extends OverlapSizer {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexPerspectiveCard';

            // Layout faces
            var backFace = config.back;
            var backFaceExpand = GetValue$O(config, 'expand.back', true);
            this.add(
                backFace,
                { key: 'back', expand: backFaceExpand }
            );

            var frontFace = config.front;
            var frontFaceExpand = GetValue$O(config, 'expand.front', true);
            this.add(
                frontFace,
                { key: 'front', expand: frontFaceExpand }
            );

            // Add PerspectiveCardMesh
            this.perspectiveCard = CreatePerspectiveCardMesh.call(this, config);
            this.pin(this.perspectiveCard);

            this.exitPerspectiveMode(false);
        }

        get flip() {
            return this.perspectiveCard.flip;
        }

        get face() {
            return this.perspectiveCard.face;
        }

        set face(index) {
            // Can't set face during flipping
            if (this.flip && this.flip.isRunning) {
                return;
            }
            this.perspectiveCard.face = index;

            var isFrontFace = (index === 0);
            var frontFace = this.childrenMap.front;
            var backFace = this.childrenMap.back;
            this.setChildVisible(frontFace, isFrontFace);
            this.setChildVisible(backFace, !isFrontFace);
        }

        setFace(face) {
            this.face = face;
            return this;
        }

        toggleFace() {
            var newFace = (this.face === 0) ? 1 : 0;
            this.setFace(newFace);
            return this;
        }

        get isInPerspectiveMode() {
            return this.perspectiveCard.visible;
        }

        get rotationX() {
            return this.perspectiveCard.rotationX;
        }

        set rotationX(value) {
            this.enterPerspectiveMode();
            this.perspectiveCard.rotationX = value;
        }

        get angleX() {
            return this.perspectiveCard.angleX;
        }

        set angleX(value) {
            this.enterPerspectiveMode();
            this.perspectiveCard.angleX = value;
        }

        get rotationY() {
            return this.perspectiveCard.rotationY;
        }

        set rotationY(value) {
            this.enterPerspectiveMode();
            this.perspectiveCard.rotationY = value;
        }

        get angleY() {
            return this.perspectiveCard.angleY;
        }

        set angleY(value) {
            this.enterPerspectiveMode();
            this.perspectiveCard.angleY = value;
        }

        get rotationZ() {
            return this.perspectiveCard.rotationZ;
        }

        set rotationZ(value) {
            this.enterPerspectiveMode();
            this.perspectiveCard.rotationZ = value;
        }

        get angleZ() {
            return this.perspectiveCard.angleZ;
        }

        set angleZ(value) {
            this.enterPerspectiveMode();
            this.perspectiveCard.angleZ = value;
        }

        panX(v) {
            this.enterPerspectiveMode();
            this.perspectiveCard.panX(v);
            return this;
        }

        panY(v) {
            this.enterPerspectiveMode();
            this.perspectiveCard.panY(v);
            return this;
        }

        panZ(v) {
            this.enterPerspectiveMode();
            this.perspectiveCard.panZ(v);
            return this;
        }

        transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
            this.enterPerspectiveMode();
            this.perspectiveCard.transformVerts(x, y, z, rotateX, rotateY, rotateZ);
            return this;
        }

        forEachFace(callback, scope, ignoreInvalid) {
            this.enterPerspectiveMode();
            this.perspectiveCard.forEachFace(callback, scope, ignoreInvalid);
            return this;
        }
    }

    Object.assign(
        PerspectiveCard.prototype,
        PerspectiveMethods
    );

    ObjectFactory.register('perspectiveCard', function (config) {
        var gameObject = new PerspectiveCard(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.PerspectiveCard', PerspectiveCard);

    var GetPageKeyByIndex = function (index) {
        var buttons = this.getElement('tabs.buttons');
        if (index >= buttons.length) {
            return undefined;
        }

        return buttons[index].name;
    };

    var GetPageIndexByKey = function (key) {
        var buttons = this.getElement('tabs.buttons');
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
            if (buttons[i].name === key) {
                return i;
            }
        }

        return undefined;
    };

    const IsPlainObject$5 = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$N = Phaser.Utils.Objects.GetValue;
    const UUID$2 = Phaser.Utils.String.UUID;

    var AddPage = function (key, tabGameObject, pageGameObject) {
        if (IsPlainObject$5(key)) {
            var config = key;
            key = GetValue$N(config, 'key');
            tabGameObject = GetValue$N(config, 'tab');
            pageGameObject = GetValue$N(config, 'page');
        }

        if (!key) {
            key = UUID$2();
        }

        tabGameObject.name = key;  // For ratio buttons

        this.childrenMap.tabs.addButton(tabGameObject);
        this.childrenMap.pages.addPage(pageGameObject, { key: key });

        return this;
    };

    var SwapPage = function (key, fadeInDuration) {
        var index;
        if (typeof (key) === 'number') {
            index = key;
        } else {
            index = this.getPageIndex(key);
        }

        if (index != null) {
            // Override fadeInDuration
            var fadeInDurationSave;
            if (fadeInDuration !== undefined) {
                fadeInDurationSave = this.childrenMap.pages.fadeInDuration;
                this.childrenMap.pages.fadeInDuration = fadeInDuration;
            }

            this.childrenMap.tabs.emitButtonClick(index);

            // Restore fadeInDuration
            if (fadeInDurationSave !== undefined) {
                this.childrenMap.pages.fadeInDuration = fadeInDurationSave;
            }
        }

        return this;
    };

    var SwapFirstPage = function (fadeInDuration) {
        this.swapPage(0, fadeInDuration);
        return this;
    };

    var SwapLastPage = function (fadeInDuration) {
        var index = this.getElement('tabs.buttons').length - 1;
        this.swapPage(index, fadeInDuration);
        return this;
    };


    var SwapPageMethods = {
        swapPage: SwapPage,
        swapFirstPage: SwapFirstPage,
        swapLastPage: SwapLastPage,
    };

    var RemovePageMethods = {
        removePage(key, destroyChild) {
            if (typeof (key) === 'number') {
                key = this.getPageKey(key);
            }

            var tabs = this.childrenMap.tabs;
            var tabGameObject = tabs.getByName(key);
            var pages = this.childrenMap.pages;
            var pageGameObject = pages.getElement(key);
            if (!tabGameObject || !pageGameObject) {
                return this;
            }

            pages.removeChildrenMap(key);

            tabs.removeButton(tabGameObject, destroyChild);
            pages.remove(pageGameObject, destroyChild);

            return this;
        },

        removeAllPages(destroyChild) {
            var buttons = this.getElement('tabs.buttons');
            for (var i = buttons.length - 1; i >= 0; i--) {
                this.removePage(buttons[i].name, destroyChild);
            }

            return this;
        }
    };

    var GetPage = function (key) {
        if (typeof (key) === 'number') {
            key = this.getPageKey(key);
        }
        return this.childrenMap.pages.getPage(key);
    };

    var GetTab = function (key) {
        var index;
        if (typeof (key) === 'number') {
            index = key;
        } else {
            index = this.getPageIndex(key);
        }
        return this.getElement('tabs.buttons')[index];
    };

    var TabsPositionToIndex = {
        top: 1,
        left: 3,
        right: 5,
        bottom: 7
    };

    var TabsPositionToTabsPaddingKey = {
        top: 'bottom',
        left: 'right',
        right: 'left',
        bottom: 'top'
    };

    var SetTabPosition = function (tabsPosition) {
        var newIndex = TabsPositionToIndex[tabsPosition];
        if (newIndex === undefined) {
            return this;
        }

        var tabs = this.childrenMap.tabs;
        var currentIndex = this.sizerChildren.indexOf(tabs);
        if (currentIndex === newIndex) {
            return this;
        }

        this.sizerChildren[currentIndex] = null;
        this.sizerChildren[newIndex] = tabs;

        var tabPadding = this.getSizerConfig(tabs).padding;
        var currentPaddingKey = TabsPositionToTabsPaddingKey[this.tabsPosition];
        var newPaddingKey = TabsPositionToTabsPaddingKey[tabsPosition];
        tabPadding[newPaddingKey] = tabPadding[currentPaddingKey];
        tabPadding[currentPaddingKey] = 0;

        this.tabsPosition = tabsPosition;

        return this;
    };

    var TabPaddingMethods = {
        setTabsPadding(key, value) {
            var tabs = this.childrenMap.tabs;
            tabs.setOuterPadding(key, value);
            return this;
        },

        getTabsPadding(key) {
            var tabs = this.childrenMap.tabs;
            return tabs.getOuterPadding(key);
        }
    };

    var methods$7 = {
        getPageKey: GetPageKeyByIndex,
        getPageIndex: GetPageIndexByKey,
        addPage: AddPage,
        getPage: GetPage,
        getTab: GetTab,
        setTabPosition: SetTabPosition,
    };

    Object.assign(
        methods$7,
        SwapPageMethods,
        RemovePageMethods,
        TabPaddingMethods,
    );

    const GetValue$M = Phaser.Utils.Objects.GetValue;
    const SizerAdd = GridSizer.prototype.add;

    let TabPages$1 = class TabPages extends GridSizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            // Create sizer
            config.column = 3;
            config.row = 3;
            config.columnProportions = [0, 0, 0];
            config.rowProportions = [0, 0, 0];

            var expandPages = GetValue$M(config, 'expand.pages', true);
            if (expandPages) {
                config.columnProportions[1] = 1;
                config.rowProportions[1] = 1;
            }

            super(scene, config);
            this.type = 'rexTabPages';

            // Add elements
            var background = GetValue$M(config, 'background', undefined);
            if (background) {
                this.addBackground(background);
            }

            var pagesConfig = GetValue$M(config, 'pages');
            var pages = new Pages(scene, pagesConfig);
            scene.add.existing(pages);

            var tabsPosition = GetValue$M(config, 'tabsPosition', undefined);
            if (tabsPosition === undefined) {
                tabsPosition = GetValue$M(config, 'tabPosition', 'top');
            }

            var wrapTabs = GetValue$M(config, 'wrapTabs', false);

            var ButtonsClass = (wrapTabs) ? Buttons : Buttons$1;

            var tabsConfig = GetValue$M(config, 'tabs', undefined);
            if (tabsConfig === undefined) {
                tabsConfig = {};
            }
            tabsConfig.orientation = ((tabsPosition === 'top') || (tabsPosition === 'bottom')) ? 'x' : 'y';
            tabsConfig.buttonsType = 'radio';
            if (!wrapTabs && !tabsConfig.hasOwnProperty('expand')) {
                tabsConfig.expand = GetValue$M(config, 'expand.tabs', false);
            }
            var tabs = new ButtonsClass(scene, tabsConfig);
            scene.add.existing(tabs);


            // Add to sizer
            SizerAdd.call(this, pages, {
                column: 1, row: 1,
                expand: expandPages
            });

            var tabColumnIndex, tabRowIndex;
            var tabPadding = GetValue$M(config, 'space.item', 0);  // Backward compatible
            switch (tabsPosition) {
                case 'top':
                    tabColumnIndex = 1;
                    tabRowIndex = 0;
                    tabPadding = { bottom: tabPadding };
                    break;

                case 'bottom':
                    tabColumnIndex = 1;
                    tabRowIndex = 2;
                    tabPadding = { top: tabPadding };
                    break;

                case 'left':
                    tabColumnIndex = 0;
                    tabRowIndex = 1;
                    tabPadding = { right: tabPadding };
                    break;

                case 'right':
                    tabColumnIndex = 2;
                    tabRowIndex = 1;
                    tabPadding = { left: tabPadding };
                    break;
            }

            SizerAdd.call(this, tabs, {
                column: tabColumnIndex, row: tabRowIndex,
                padding: tabPadding,
                expand: (wrapTabs) ? true : GetValue$M(config, 'expand.tabs', false),
                align: GetValue$M(config, 'align.tabs', 'left')
            });

            this.addChildrenMap('background', background);
            this.addChildrenMap('tabs', tabs);
            this.addChildrenMap('pages', pages);

            this.tabsPosition = tabsPosition;

            // Register events
            tabs.on('button.click', function (tab) {
                var key = tab.name;
                if (pages.hasPage(key)) {
                    pages.swapPage(key);
                }
            });

            tabs.on('button.statechange', function (tab, index, value, previousValue) {
                var eventName = (value) ? 'tab.focus' : 'tab.blur';
                this.emit(eventName, tab, tab.name);
            }, this);

            pages.on('pagevisible', function (pageObject, key, pages) {
                this.emit('page.focus', pageObject, key);
            });

            pages.on('pageinvisible', function (pageObject, key, pages) {
                this.emit('page.blur', pageObject, key);
            });

        }

        get currentKey() {
            return this.getElement('pages').currentKey;
        }

        set currentKey(key) {
            this.showPage(key);
        }

        get keys() {
            return this.getElement('pages').keys;
        }

        get currentPage() {
            return this.getElement('pages').currentPage;
        }

        get previousPage() {
            return this.getElement('pages').previousPage;
        }

    };

    Object.assign(
        TabPages$1.prototype,
        methods$7
    );

    ObjectFactory.register('tabPages', function (config) {
        var gameObject = new TabPages$1(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TabPages', TabPages$1);

    class Transition extends OpenCloseTransition {
        constructor(gameObject, config) {
            if (config === undefined) {
                config = {};
            }
            config.destroy = false;
            super(gameObject, config);
        }

        onOpen() {
            this.emit('open', this.parent, this);
            super.onOpen();
        }

        onClose() {
            this.emit('close', this.parent, this);
            super.onClose();
        }

    }

    var ExpandMethods = {
        expand(duration) {
            if (this.expanded === true) {
                return this;
            }

            if (duration === undefined) {
                duration = this.transitionDuration;
            }

            this.expanded = true;

            var title = this.childrenMap.title;
            var child = this.childrenMap.child;

            this.show(child);

            if (this.reLayoutEnable) {
                var layoutTarget = (this.reLayoutTarget) ? this.reLayoutTarget : this.getTopmostSizer();
                layoutTarget.layout();
            }

            title.emit('folder.expand', duration, this);
            child.emit('folder.expand', duration, this);
            this.emit('expand.start', this);

            this.childTransition
                .once('open', function () {
                    this.emit('expand.complete', this);
                }, this)
                .requestOpen(null, duration);

            return this;
        },

        collapse(duration) {
            if (this.expanded === false) {
                return this;
            }

            if (duration === undefined) {
                duration = this.transitionDuration;
            }

            this.expanded = false;

            var title = this.childrenMap.title;
            var child = this.childrenMap.child;

            title.emit('folder.collapse', duration, this);
            child.emit('folder.collapse', duration, this);
            this.emit('collapse.start', this);

            this.childTransition
                .once('close', function () {
                    this.setChildScale(child, 1, 1).hide(child);

                    if (this.reLayoutEnable) {
                        var layoutTarget = (this.reLayoutTarget) ? this.reLayoutTarget : this.getTopmostSizer();
                        layoutTarget.layout();
                    }

                    this.emit('collapse.complete', this);
                }, this)
                .requestClose(null, duration);

            return this;
        },

        toggle(duration) {
            if (this.expanded) {
                this.collapse(duration);
            } else {
                this.expand(duration);
            }

            return this;
        },

        setExpandedState(expanded) {
            this.reLayoutEnable = false;

            if (expanded === undefined) {
                this.expanded = undefined;
            } else if (expanded) {
                this.expand(0);
            } else {
                this.collapse(0);
            }

            this.reLayoutEnable = true;

            return this;
        }
    };

    var DefaultExpandCallback = function (gameObject, duration) {
        methods$z.popUp.call(gameObject, duration, this.expandDirection);
    };

    var DefaultCollapseCallback = function (gameObject, duration) {
        methods$z.scaleDown.call(gameObject, duration, this.expandDirection);
    };

    var ConfigurationMethods$2 = {
        setTransitionDuration(duration) {
            this.transitionDuration = duration;

            this.childTransition
                .setTransitInTime(duration)
                .setTransitOutTime(duration);

            return this;
        },

        setExpandCallback(callback) {
            if (callback === undefined) {
                callback = DefaultExpandCallback.bind(this);
            }
            this.childTransition.setTransitInCallback(callback);
            return this;
        },

        setCollapseCallback(callback) {
            if (callback === undefined) {
                callback = DefaultCollapseCallback.bind(this);
            }
            this.childTransition.setTransitOutCallback(callback);
            return this;
        }
    };

    const GetValue$L = Phaser.Utils.Objects.GetValue;

    let Folder$1 = class Folder extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            if (!config.hasOwnProperty('orientation')) {
                config.orientation = 1;
            }

            super(scene, config);
            this.type = 'rexFolder';

            this.reLayoutEnable = true;
            this.expanded = undefined;
            this.expandDirection = (this.orientation === 1) ? 'y' : 'x';

            var background = config.background;
            var title = config.title;
            var child = config.child;

            // background
            if (background) {
                this.addBackground(background);
            }

            var spaceConfig = GetValue$L(config, 'space');

            // title
            var defaultAlign = (this.orientation === 1) ? 'left' : 'top';
            var align = GetValue$L(config, 'align.title', defaultAlign);
            var expand = GetValue$L(config, 'expand.title', true);
            this.add(
                title,
                {
                    proportion: 0,
                    align: align,
                    expand: expand,
                    padding: {
                        left: GetValue$L(spaceConfig, 'titleLeft', 0),
                        right: GetValue$L(spaceConfig, 'titleRight', 0),
                        top: GetValue$L(spaceConfig, 'titleTop', 0),
                        bottom: GetValue$L(spaceConfig, 'titleBottom', 0)
                    }
                }
            );

            var toggleByTarget = GetValue$L(config, 'toggleByTarget', undefined);
            var toggleClickConfig = GetValue$L(config, 'toggleClickConfig');

            if (toggleByTarget === undefined) {
                toggleByTarget = title;
            }
            if (toggleByTarget) {
                ClickMethods.onClick.call(
                    toggleByTarget,
                    function () {
                        this.toggle();
                    },
                    this,
                    toggleClickConfig
                );
            }

            // child
            this.childTransition = new Transition(child);

            var customOrigin = GetValue$L(config, 'customChildOrigin', false);
            if (!customOrigin) {
                var origin = (!this.rtl) ? 0 : 1;
                child.setOrigin(origin);
            }

            var align = GetValue$L(config, 'align.child', 'left');
            var expand = GetValue$L(config, 'expand.child', true);
            var proportion = (expand) ? 1 : 0;
            this.add(
                child,
                {
                    proportion: proportion,
                    align: align,
                    expand: expand,
                    padding: {
                        left: GetValue$L(spaceConfig, 'childLeft', 0),
                        right: GetValue$L(spaceConfig, 'childRight', 0),
                        top: GetValue$L(spaceConfig, 'childTop', 0),
                        bottom: GetValue$L(spaceConfig, 'childBottom', 0)
                    }
                }
            );

            this.addChildrenMap('title', title);
            this.addChildrenMap('child', child);
            this.addChildrenMap('background', background);

            var transitionConfig = config.transition;
            this.setTransitionDuration(GetValue$L(transitionConfig, 'duration', 200));
            this.setExpandCallback(GetValue$L(transitionConfig, 'expandCallback', undefined));
            this.setCollapseCallback(GetValue$L(transitionConfig, 'collapseCallback', undefined));

            this.reLayoutTarget = GetValue$L(config, 'reLayoutTarget', undefined);

            var onExpandStart = config.onExpandStart;
            if (onExpandStart) {
                this.on('expand.start', onExpandStart);
            }

            var onExpandComplete = config.onExpandComplete;
            if (onExpandComplete) {
                this.on('expand.complete', onExpandComplete);
            }

            var onCollapseStart = config.onCollapseStart;
            if (onCollapseStart) {
                this.on('collapse.start', onCollapseStart);
            }

            var onCollapseComplete = config.onCollapseComplete;
            if (onCollapseComplete) {
                this.on('collapse.complete', onCollapseComplete);
            }

            var expanded = GetValue$L(config, 'expanded', undefined);
            if (expanded !== undefined) {
                this.setExpandedState(expanded);
            }
        }
    };

    Object.assign(
        Folder$1.prototype,
        ExpandMethods,
        ConfigurationMethods$2,
    );

    ObjectFactory.register('folder', function (config) {
        var gameObject = new Folder$1(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Folder', Folder$1);

    var PointToChild$1 = function (x, y, preTest, postTest) {
        for (var nodeKey in this.treesMap) {
            var tree = this.treesMap[nodeKey];

            if (ContainsPoint$1(tree.nodeBody, x, y, preTest, postTest)) {
                return tree;
            }

            var child = tree.pointToChild(x, y, preTest, postTest);
            if (child) {
                return child;
            }
        }

        return null;
    };

    var SetChildrenInteractive = function (config) {
        if (config === undefined) {
            config = {};
        }
        config.targetMode = 'parent';
        config.targetSizers = [this];
        SetChildrenInteractive$1(this, config);
        return this;
    };

    var ExtendNodeClass = function (GOClass) {
        return class Base extends GOClass {
            get isTree() {
                return false;
            }

            get isNode() {
                return false;
            }

            // Wrap text/setText() from nodeBody
            setText(text) {
                this.text = text;
                return this;
            }

            get text() {
                var textObject = this.nodeBody;
                return textObject.text;
            }

            set text(value) {
                var textObject = this.nodeBody;
                if (textObject.setText) {
                    textObject.setText(value);
                }
            }


            // Wrap setTexture() from nodeBody
            setTexture(key, frame) {
                var imageObject = this.nodeBody;
                if (imageObject.setTexture) {
                    imageObject.setTexture(key, frame);
                }
                return this;
            }

            get texture() {
                var imageObject = this.nodeBody;
                if (!imageObject) {
                    return undefined;
                }
                return imageObject.texture;
            }

            get frame() {
                var imageObject = this.nodeBody;
                if (!imageObject) {
                    return undefined;
                }
                return imageObject.frame;
            }
        }
    };

    var PointToChild = function (x, y, preTest, postTest) {
        for (var nodeKey in this.nodesMap) {
            var node = this.nodesMap[nodeKey];
            if (this.isTreeObject(node)) {
                // Is sub-tree
                var tree = node;

                if (ContainsPoint$1(tree.nodeBody, x, y, preTest, postTest)) {
                    return tree;
                }

                var child = tree.pointToChild(x, y, preTest, postTest);
                if (child) {
                    return child;
                }

            } else {
                // Is leaf-node
                if (ContainsPoint$1(node, x, y, preTest, postTest)) {
                    return node;
                }

            }
        }

        return null;
    };

    var ParentMethods = {
        getTreePatent(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }
            if (!gameObject.rexSizer) {
                return undefined;
            }

            return gameObject.rexSizer.treeParent;
        },

        getTreeRoot(gameObject) {
            if (gameObject === undefined) {
                gameObject = this;
            }

            var treeParent;
            while (1) {
                if (!gameObject.rexSizer) {
                    return undefined;
                }

                treeParent = gameObject.rexSizer.treeParent;
                if (treeParent === null) {
                    return gameObject;
                }

                gameObject = treeParent;
            }

            return undefined;
        },

        getTreesSizer(gameObject) {
            var root = this.getTreeRoot(gameObject);
            return (root) ? root.getParentSizer() : null;
        },

        isGrandsonNode(gameObject) {
            if ((gameObject === undefined) || (!gameObject.rexSizer)) {
                return false;
            }

            var treeParent;
            while (1) {
                if (!gameObject.rexSizer) {
                    return false;
                }

                treeParent = gameObject.rexSizer.treeParent;
                if (treeParent === this) {
                    return true;
                } else if (treeParent === null) {
                    return false;
                }

                gameObject = treeParent;
            }

            return false;
        },
    };

    var CreateGameObjectFromConfig = function (
        scene,
        config,
        callbackData,
        defaultCallback,
        isRequired = false
    ) {
        var gameObject;

        if (IsGameObject(config)) {
            gameObject = config;
            delete config[key];  // Remove reference of game object

        } else if (IsFunction(config)) {
            var callback = config;
            gameObject = callback(scene, callbackData);
            if (gameObject) {
                scene.add.existing(gameObject);
            }

        } else if ((isRequired || config) && defaultCallback) {
            gameObject = defaultCallback(scene, config, callbackData);
            // Will add to scene in defaultCallback
        }

        return gameObject;
    };

    var DefaultCreateBackgroundCallback = function (scene, config, createCallbackData) {
        var gameObject = CreateBackground$2(scene, config);

        return gameObject;
    };

    var DefaultCreateNodeBodyCallback = function (scene, config, createCallbackData) {
        var gameObject = new SimpleLabel(scene, config);
        scene.add.existing(gameObject);

        gameObject.resetDisplayContent('');

        return gameObject;
    };

    const GetValue$K = Phaser.Utils.Objects.GetValue;

    class Node extends ExtendNodeClass(Sizer) {
        constructor(scene, config, createCallbackData) {
            var spaceConfig = config.space;

            super(scene, {
                orientation: 'x',
                space: {
                    left: GetValue$K(spaceConfig, 'nodeLeft', 0),
                    right: GetValue$K(spaceConfig, 'nodeRight', 0),
                    top: GetValue$K(spaceConfig, 'nodeTop', 0),
                    bottom: GetValue$K(spaceConfig, 'nodeBottom', 0)
                }
            });
            this.type = 'rexTreeNode';

            var background = CreateGameObjectFromConfig(
                scene,
                GetValue$K(config, 'nodeBackground'),  // config
                createCallbackData,                  // callbackData
                DefaultCreateBackgroundCallback,     // defaultCallback
                false                                // isRequired
            );

            var nodeBody = CreateGameObjectFromConfig(
                scene,
                GetValue$K(config, 'nodeBody'),  // config
                createCallbackData,            // callbackData
                DefaultCreateNodeBodyCallback, // defaultCallback
                true                           // isRequired
            );

            if (background) {
                this.addBackground(background);
            }

            this.add(
                nodeBody,
                { proportion: 1 }
            );

            this.nodeBody = nodeBody;
            this.addChildrenMap('background', background);
            this.addChildrenMap('nodeBody', nodeBody);

        }

        get isNode() {
            return true;
        }

        getTreePatent() {
            return this.rexSizer.treeParent;
        }

        getTreeRoot() {
            var treeParent = this.rexSizer.treeParent;
            if (!treeParent) {
                return null;
            }
            return treeParent.getTreeRoot();
        }

        getTreesSizer() {
            var root = this.getTreeRoot();
            return (root) ? root.getParentSizer() : null;
        }

    }

    var SyncDisplayList = function (sourceGameObject, targetGameObject) {    
        var p3Container = sourceGameObject.parentContainer;
        if (p3Container) {
            if (targetGameObject.isRexContainerLite) {
                // Add containerLite and its children
                targetGameObject.addToContainer(p3Container);
            } else {
                // Add gameObject directly
                p3Container.add(targetGameObject);
            }

            return;
        }

        var layer = sourceGameObject.displayList;
        if (IsLayerGameObject(layer)) {
            if (targetGameObject.isRexContainerLite) {
                // Add containerLite and its children
                targetGameObject.addToLayer(layer);
            } else {
                // Add gameObject directly
                layer.add(targetGameObject);
            }

            return;
        }

        sourceGameObject.scene.add.existing(targetGameObject);
    };

    const UUID$1 = Phaser.Utils.String.UUID;

    var AddNodeMethods = {
        addTree(config, nodeKey) {
            if (IsGameObject(config)) {
                var nodeBody = config;
                config = {
                    nodeBody: nodeBody,
                    nodeKey: nodeKey
                };
            }
            return this.insertTree(undefined, config);
        },

        insertTree(index, config) {
            var nodeKey;
            if (typeof (config) === 'string') {
                nodeKey = config;
                config = undefined;
            } else if (config) {
                nodeKey = config.nodeKey;
                delete config.nodeKey;
            }

            if (nodeKey === undefined) {
                nodeKey = UUID$1();
            }

            var tree = this.createTree(config);
            SyncDisplayList(this, tree);

            this.insertNode(index, tree, { expand: true });

            // See Tree class
            tree._postAddCallback();

            return tree;
        },

        addNode(gameObject, config) {
            return this.insertNode(undefined, gameObject, config)
        },

        insertNode(index, gameObject, config) {
            var nodeKey;

            if (!IsGameObject(gameObject)) {
                config = gameObject;
                gameObject = new Node(this.scene, this.configSave, { isLeaf: true });
            }

            if (typeof (config) === 'string') {
                nodeKey = config;
                config = undefined;
            } else if (config) {
                nodeKey = config.nodeKey;
                delete config.nodeKey;
            }

            if (nodeKey === undefined) {
                nodeKey = UUID$1();
            }

            if (config === undefined) {
                config = {};
            }

            if (!config.hasOwnProperty('expand')) {
                config.expand = true;
            }

            this.removeNode(gameObject, false);

            gameObject.rexSizer.treeParent = this;

            if (this.nodesMap.hasOwnProperty(nodeKey)) {
                console.error(`[Trees] Duplicate nodeKey '${nodeKey}'`);
                this.removeNode(this.nodesMap[nodeKey], true);
            }

            gameObject.nodeKey = nodeKey;
            this.nodesMap[nodeKey] = gameObject;

            var childrenSizer = this.childrenMap.child;
            childrenSizer.insert(index, gameObject, config);

            return gameObject;
        },
    };

    var RemoveNodeMethods = {
        removeNode(gameObject, destroyChild) {
            if (typeof (gameObject) === 'string') {
                gameObject = this.getTree(gameObject);
            }

            if (!gameObject) {
                return this;
            }

            var treeParent = this.getTreePatent(gameObject);
            if (!treeParent) {
                return this;
            }

            delete treeParent.nodesMap[gameObject.nodeKey];
            gameObject.nodeKey = null;
            gameObject.rexSizer.treeParent = null;

            var childrenSizer = treeParent.childrenMap.child;
            childrenSizer.remove(gameObject, destroyChild);
            return this;
        },

        removeAllNodes(destroyChild) {
            var nodesMap = this.nodesMap;
            for (var nodeKey in nodesMap) {
                this.removeNode(nodesMap[nodeKey], destroyChild);
            }
            return this;
        }
    };

    var GetNodeMethods = {
        getNode(mapNameList) {
            if (typeof (mapNameList) === 'string') {
                mapNameList = mapNameList.split('.');
            }
            if (mapNameList.length === 0) {
                return undefined;
            }

            var name = mapNameList.shift();

            var element = this.nodesMap[name];

            if (mapNameList.length === 0) {
                return element;
            } else if (element && this.isTreeObject(element)) {
                return element.getNode(mapNameList);
            } else {
                return null;
            }
        },

        getNodes(out) {
            var nodesMap = this.nodesMap;

            if (!out) {
                out = nodes; // Return internal children array
            } else {
                for (var nodeKey in nodesMap) {
                    out.push(nodesMap[nodeKey]);
                }
                // Copy children
            }
            return out;
        },

        getAllNodes(out) {
            // TODO
        }
    };

    var methods$6 = {
        pointToChild: PointToChild,
    };

    Object.assign(
        methods$6,

        ParentMethods,
        AddNodeMethods,
        RemoveNodeMethods,
        GetNodeMethods,

    );

    var DefaultCreateToggleButtonCallback = function (scene, config, createCallbackData) {
        var gameObject = new Triangle(scene, config);
        scene.add.existing(gameObject);

        gameObject
            .on('expand.start', function (gameObject) {
                gameObject.setDirection('down');
            })
            .on('collapse.complete', function (gameObject) {
                gameObject.setDirection('right');
            });

        return gameObject;
    };

    const GetValue$J = Phaser.Utils.Objects.GetValue;

    var CreateTitleSizer = function (scene, config) {
        var nodeSizer = new Node(scene, config, { isLeaf: false });
        scene.add.existing(nodeSizer);

        var toggleButton = CreateGameObjectFromConfig(
            scene,
            GetValue$J(config, 'toggleButton'),  // config
            { isLeaf: false },                 // callbackData
            DefaultCreateToggleButtonCallback, // defaultCallback
            true                               // isRequired
        );

        nodeSizer.insert(0, toggleButton,
            {
                padding: {
                    right: GetValue$J(config, 'space.toggleButton', 0)
                },
                fitRatio: 1,
            }
        );

        nodeSizer.addChildrenMap('toggleButton', toggleButton);

        return nodeSizer;
    };

    const GetValue$I = Phaser.Utils.Objects.GetValue;

    var CreateChildrenSizer = function (scene, config) {
        var childrenSizer = new Sizer(scene, {
            orientation: GetValue$I(config, 'childrenOrientation', 'y')
        });
        scene.add.existing(childrenSizer);

        var childrenBackground = CreateGameObjectFromConfig(
            scene,
            GetValue$I(config, 'childrenBackground'),  // config
            { isLeaf: false },                       // callbackData
            DefaultCreateBackgroundCallback,         // defaultCallback
            false                                    // isRequired
        );

        if (childrenBackground) {
            childrenSizer.addBackground(childrenBackground);
        }

        return childrenSizer;
    };

    const Clone$1 = Phaser.Utils.Objects.Clone;

    var Merge$2 = function (defaultConfig, overrideConfig) {
        var config = (defaultConfig) ? Clone$1(defaultConfig) : {};

        if (!overrideConfig) {
            return config;
        }

        for (var name in overrideConfig) {
            config[name] = overrideConfig[name];
        }

        return config;
    };

    const GetValue$H = Phaser.Utils.Objects.GetValue;

    class Tree extends ExtendNodeClass(Folder$1) {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            var background = CreateGameObjectFromConfig(
                scene,
                GetValue$H(config, 'background'),   // config
                { isLeaf: false },                // callbackData
                DefaultCreateBackgroundCallback,  // defaultCallback
                false                             // isRequired
            );

            var child = CreateChildrenSizer(scene, config);
            var childrenNodes = child.childrenMap.items;

            var title = CreateTitleSizer(scene, config);
            var toggleButton = title.childrenMap.toggleButton;
            var nodeBody = title.childrenMap.nodeBody;

            var orientation = GetOrientationMode(GetValue$H(config, 'orientation', 'y'));

            var spaceConfig = config.space;
            if (spaceConfig) {
                var indent = GetValue$H(spaceConfig, 'indent', 0);
                spaceConfig.childLeft = GetValue$H(spaceConfig, 'indentLeft', (orientation === 1) ? indent : 0);
                spaceConfig.childRight = GetValue$H(spaceConfig, 'indentRight', 0);
                spaceConfig.childTop = GetValue$H(spaceConfig, 'indentTop', (orientation === 0) ? indent : 0);
                spaceConfig.childBottom = GetValue$H(spaceConfig, 'indentBottom', 0);
            }

            var folderConfig = {
                background: background,
                title: title,
                child: child,

                toggleByTarget: toggleButton,
                transition: config.transition,

                orientation: orientation,
                space: spaceConfig,
                align: config.align,
                expand: config.expand,
            };

            super(scene, folderConfig);
            this.type = 'rexTree';

            this.rexSizer.treeParent = null;
            this.nodesMap = {};
            this.configSave = config;

            this.nodeBody = nodeBody;
            this.addChildrenMap('toggleButton', toggleButton);
            this.addChildrenMap('nodeBody', nodeBody);
            this.addChildrenMap('childrenNodes', childrenNodes);

            // Route events
            this
                .on('expand.start', function () {
                    toggleButton.emit('expand.start', toggleButton);
                    FireTreesSizerEvent(this, 'expand.start');
                }, this)
                .on('expand.complete', function () {
                    toggleButton.emit('expand.complete', toggleButton);
                    FireTreesSizerEvent(this, 'expand.complete');
                })
                .on('collapse.start', function () {
                    toggleButton.emit('collapse.start', toggleButton);
                    FireTreesSizerEvent(this, 'collapse.start');
                })
                .on('collapse.complete', function () {
                    toggleButton.emit('collapse.complete', toggleButton);
                    FireTreesSizerEvent(this, 'collapse.complete');
                });

            // Run this callback after adding to parent tree    
            var tree = this;
            tree._postAddCallback = function () {
                var expanded = GetValue$H(config, 'expanded', true);
                if (expanded !== undefined) {
                    tree.setExpandedState(expanded);
                }
                delete tree._postAddCallback;
            };
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.configSave = undefined;

            Clear(this.nodesMap);
            this.nodesMap = undefined;

            super.destroy(fromScene);
        }

        get isTree() {
            return true;
        }

        createTree(config) {
            return Tree.CreateTree(this.scene, this.configSave, config)
        }

        isTreeObject(gameObject) {
            return gameObject && gameObject instanceof (Tree);
        }
    }

    // Static method
    Tree.CreateTree = function (scene, defaultConfig, overrideConfig) {
        return new Tree(scene, Merge$2(defaultConfig, overrideConfig));
    };

    var FireTreesSizerEvent = function (tree, eventName) {
        var treesSizer = tree.getTreesSizer();
        if (treesSizer) {
            treesSizer.emit(eventName, tree);
        }
    };

    Object.assign(
        Tree.prototype,
        methods$6
    );

    const UUID = Phaser.Utils.String.UUID;

    var AddTreeMethods = {
        addTree(config) {
            if (IsGameObject(config)) {
                var nodeBody = config;
                config = {
                    nodeBody: nodeBody,
                    nodeKey: nodeKey
                };
            }
            return this.insertTree(undefined, config);
        },

        insertTree(index, config) {
            var nodeKey;
            if (typeof (config) === 'string') {
                nodeKey = config;
                config = undefined;
            } else if (config) {
                nodeKey = config.nodeKey;
                delete config.nodeKey;
            }

            if (nodeKey === undefined) {
                nodeKey = UUID();
            }

            var tree = Tree.CreateTree(this.scene, this.treeConfig, config);
            SyncDisplayList(this, tree);

            tree.nodeKey = nodeKey;
            this.treesMap[nodeKey] = tree;

            this.insert(index, tree, { expand: true });

            // See Tree class
            tree._postAddCallback();

            return tree;
        }
    };

    var RemoveTreeMethods = {
        removeTree(gameObject, destroyChild) {
            if (typeof (gameObject) === 'string') {
                gameObject = this.getTree(gameObject);
            }

            if (!gameObject) {
                return this;
            }

            delete this.treesMap[gameObject.nodeKey];
            gameObject.nodeKey = null;

            this.remove(gameObject, destroyChild);
            return this;
        },

        removeAllNodes(destroyChild) {
            var treesMap = this.treesMap;
            for (var nodeKey in treesMap) {
                this.removeTree(treesMap[nodeKey], destroyChild);
            }
            return this;
        }
    };

    var GetTreeMethods = {
        getTree(nodeKey) {
            return this.treesMap[nodeKey];
        },

        getTrees(out) {
            if (out === undefined) {
                out = [];
            }
            for (var nodeKey in this.treesMap) {
                out.push(this.treesMap[nodeKey]);
            }
            return out;
        },

        getNode(nodeKey) {
            var dotIndex = nodeKey.indexOf('.');
            if (dotIndex === -1) {
                return this.getTree(nodeKey);
            }

            var tree = this.getTree(nodeKey.substring(0, dotIndex));
            if (!tree) {
                return undefined;
            }

            return tree.getNode(nodeKey.substring(dotIndex + 1))
        }
    };

    var methods$5 = {
        pointToChild: PointToChild$1,
        setChildrenInteractive: SetChildrenInteractive,
    };

    Object.assign(
        methods$5,
        AddTreeMethods,
        RemoveTreeMethods,
        GetTreeMethods,
    );

    const GetValue$G = Phaser.Utils.Objects.GetValue;

    // TODO extend from TreeNode
    class Trees extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            if (!config.hasOwnProperty('orientation')) {
                config.orientation = 'y';
            }

            super(scene, config);
            this.type = 'rexTrees';

            this.treesMap = {};

            this.treeConfig = GetValue$G(config, 'tree');
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.treeConfig = undefined;

            Clear(this.treesMap);
            this.treesMap = undefined;

            super.destroy(fromScene);
        }

    }

    Object.assign(
        Trees.prototype,
        methods$5
    );

    ObjectFactory.register('trees', function (config) {
        var gameObject = new Trees(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Trees', Trees);

    ObjectFactory.register('textArea', function (config) {
        var gameObject = new TextArea(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TextArea', TextArea);

    var InjectProperties = function (inputText) {
        Object.defineProperty(inputText, 'childOY', {
            configurable: true,
            get: function () {
                return inputText.textOY;
            },
            set: function (value) {
                inputText.textOY = value;
            }
        });
        Object.defineProperty(inputText, 'topChildOY', {
            get: function () {
                return inputText.topTextOY;
            }
        });
        Object.defineProperty(inputText, 'bottomChildOY', {
            get: function () {
                return inputText.bottomTextOY;
            }
        });
        Object.defineProperty(inputText, 'childVisibleHeight', {
            get: function () {
                return inputText.textVisibleHeight;
            }
        });
        Object.defineProperty(inputText, 'childHeight', {
            get: function () {
                return inputText.contentHeight;
            }
        });
    };

    var SetTextMethods = {
        setText(text) {
            var inputText = this.childrenMap.child;
            inputText.setText(text);
            return this;
        },

        appendText(text) {
            this.setText(this.text + text);
            return this;
        }
    };

    var ScrollMethods = {
        scrollToLine(lineIndex) {
            this.setChildOY(-this.lineHeight * lineIndex);
            return this;
        },

        scrollToNextLine(lineCount) {
            if (lineCount === undefined) {
                lineCount = 1;
            }

            var lineIndex = this.lineIndex + lineCount;
            this.scrollToLine(lineIndex);
            return this;
        }
    };

    const GetValue$F = Phaser.Utils.Objects.GetValue;

    class TextAreaInput extends Scrollable$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            // Create inputText
            var inputTextConfig = GetValue$F(config, 'text');
            var inputText;
            if (IsGameObject(inputTextConfig)) {
                inputText = inputTextConfig;
            } else {
                if (inputTextConfig === undefined) {
                    inputTextConfig = {};
                }
                inputTextConfig.textArea = true;
                inputText = new CanvasInput(scene, inputTextConfig);
                scene.add.existing(inputText); // Important: Add to display list for touch detecting
            }

            // Inject properties for scrollable interface
            InjectProperties(inputText);

            // Fill config of scrollable
            var expandInputTextWidth = (inputTextConfig.width === undefined);
            var expandInputTextHeight = (inputTextConfig.height === undefined);
            if (expandInputTextWidth) {
                inputText.minWidth = 0;
            }
            if (expandInputTextHeight) {
                inputText.minHeight = 0;
            }

            config.scrollMode = 0; // Vertical
            config.type = 'rexTextAreaInput';
            config.child = {
                gameObject: inputText,
                expandWidth: expandInputTextWidth,
                expandHeight: expandInputTextHeight,
            };
            var spaceConfig = GetValue$F(config, 'space', undefined);
            if (spaceConfig) {
                spaceConfig.child = GetValue$F(spaceConfig, 'text', 0);
            }
            config.scroller = false; // No scroller supported

            super(scene, config);

            this.addChildrenMap('text', inputText);

            // More setting...

            // Rsize and move slider
            var prevTextOY, prevContentHeight;
            inputText.on('cursorin', function () {
                var textOY = inputText.textOY,
                    contentHeight = inputText.contentHeight;

                var isTextOYChanged = prevTextOY !== textOY;
                var isContentHeightChanged = prevContentHeight !== contentHeight;

                prevTextOY = textOY;
                prevContentHeight = contentHeight;

                if (isContentHeightChanged) {
                    this.resizeController();
                }

                if (isTextOYChanged || isContentHeightChanged) {
                    this.t = inputText.t;
                }

            }, this);

            // Route 'textchange', 'close' events
            inputText
                .on('textchange', function (text) {
                    this.emit('textchange', text, this);
                }, this)
                .on('close', function () {
                    this.emit('close', this.text, this);
                }, this);

            // Set initial text if given
            var content = GetValue$F(config, 'content', undefined);
            if (content) {
                this.setText(content);
            }
        }

        get text() {
            return this.childrenMap.child.text;
        }

        set text(value) {
            if (value == null) {
                value = '';
            } else {
                value = value.toString();
            }
            if (this.childrenMap.child.text === value) {
                return;
            }

            this.setText(value);
        }

        get lineHeight() {
            var inputText = this.childrenMap.child;
            return inputText.lineHeight;
        }

        get lineIndex() {
            return Math.floor(-this.childOY / this.lineHeight);
        }

        get linesCount() {
            var inputText = this.childrenMap.child;
            return inputText.linesCount;
        }

        get contentHeight() {
            var inputText = this.childrenMap.child;
            return inputText.contentHeight;
        }

        get readOnly() {
            var inputText = this.childrenMap.child;
            return inputText.readOnly;
        }

        set readOnly(value) {
            var inputText = this.childrenMap.child;
            inputText.readOnly = value;
        }

        setReadOnly(value) {
            var inputText = this.childrenMap.child;
            inputText.setReadOnly(value);
            return this;
        }

        get value() {
            return this.text;
        }

        set value(value) {
            this.text = value;
        }

    }

    Object.assign(
        TextAreaInput.prototype,
        SetTextMethods,
        ScrollMethods,
    );

    ObjectFactory.register('textAreaInput', function (config) {
        var gameObject = new TextAreaInput(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.TextAreaInput', TextAreaInput);

    ObjectFactory.register('scrollablePanel', function (config) {
        var gameObject = new ScrollablePanel(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ScrollablePanel', ScrollablePanel);

    var DefaultTransitionCallbacks$1 = {
        popUp: function (gameObject, duration) {
            gameObject.popUp(duration);
        },

        scaleDown: function (gameObject, duration) {
            gameObject.scaleDown(duration);
        },

        fadeIn: function (gameObject, duration) {
            gameObject.fadeIn(duration);
        },

        fadeOut: function (gameObject, duration) {
            gameObject.fadeOut(duration);
        },
    };

    const TransitionMode = {
        popUp: 0,
        fadeIn: 1,
        scaleDown: 0,
        fadeOut: 1,
    };

    var ConfigurationMethods$1 = {    
        setDisplayTime(time) {
            this.displayTime = time;
            return this;
        },

        setTransitOutTime(time) {
            this.transitOutTime = time;
            return this;
        },

        setTransitInTime(time) {
            this.transitInTime = time;
            return this;
        },

        setTransitInCallback(callback) {
            if (typeof (callback) === 'string') {
                callback = TransitionMode[callback];
            }

            switch (callback) {
                case TransitionMode.popUp:
                    callback = DefaultTransitionCallbacks$1.popUp;
                    break;
                case TransitionMode.fadeIn:
                    callback = DefaultTransitionCallbacks$1.fadeIn;
                    break;
            }

            if (!callback) {
                callback = NOOP;
            }

            this.transitInCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

        setTransitOutCallback(callback) {
            if (typeof (callback) === 'string') {
                callback = TransitionMode[callback];
            }

            switch (callback) {
                case TransitionMode.scaleDown:
                    callback = DefaultTransitionCallbacks$1.scaleDown;
                    break;
                case TransitionMode.fadeOut:
                    callback = DefaultTransitionCallbacks$1.fadeOut;
                    break;
            }

            if (!callback) {
                callback = NOOP;
            }

            this.transitOutCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

    };

    var MessageMethods$1 = {
        showMessage(message) {
            // Remember first scaleX, scaleY as initial scale
            if (this.scaleX0 === undefined) {
                this.scaleX0 = this.scaleX;
            }
            if (this.scaleY0 === undefined) {
                this.scaleY0 = this.scaleY;
            }

            if (message === undefined) {
                // Try pop up a pendding message
                if (this.messages.length === 0) {
                    return this;
                }
                message = this.messages.shift();
            }

            if (this.player.isPlaying) {
                // Pend message
                this.messages.push(message);
                return this;
            }

            // Recover to initial state
            this
                .setScale(this.scaleX0, this.scaleY0)
                .setVisible(true);
            if (typeof (message) === 'string') {
                this.setText(message);
            } else {
                message(this);
            }
            this.layout();

            var commands = [
                [ // Transit-in
                    0, // time
                    [this.transitInCallback, this, this.transitInTime] // [callback, param, ...]
                ],
                [  // Transit-in event
                    0, // time
                    [this.emit, 'transitin', this, this.transitInTime] // [callback, param, ...]
                ],
                [ // Hold
                    this.transitInTime,
                    [NOOP]
                ],
                [ // Transit-out
                    this.displayTime,
                    [this.transitOutCallback, this, this.transitOutTime]
                ], // Transit-out event
                [
                    0, // time
                    [this.emit, 'transitout', this, this.transitOutTime] // [callback, param, ...]
                ],
                [ // End
                    this.transitOutTime,
                    [this.setVisible, false]
                ],
                [ // Complete - show next message
                    30, // Add a small delay before complete
                    [NOOP]
                ]
            ];

            this.player
                .load(commands, this)
                .once('complete', function () {
                    this.showMessage();
                }, this)
                .start();

            return this;
        },

        removeAllMessages() {
            this.messages.length = 0;
            return this;
        }
    };

    const GetValue$E = Phaser.Utils.Objects.GetValue;

    class Toast extends Label {
        constructor(scene, config) {
            if (config === undefined) {
                config = {
                    text: createDefaultTextObject(scene)
                };
            }

            super(scene, config);
            this.type = 'rexToast';

            this.setTransitInTime(GetValue$E(config, 'duration.in', 200));
            this.setDisplayTime(GetValue$E(config, 'duration.hold', 1200));
            this.setTransitOutTime(GetValue$E(config, 'duration.out', 200));
            this.setTransitInCallback(GetValue$E(config, 'transitIn', TransitionMode.popUp));
            this.setTransitOutCallback(GetValue$E(config, 'transitOut', TransitionMode.scaleDown));

            this.player = new Player(this, { dtMode: 1 });
            this.messages = [];
            this.scaleX0 = undefined;
            this.scaleY0 = undefined;

            this.setVisible(false);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.player.destroy();
            this.player = undefined;
            this.messages = undefined;

            super.destroy(fromScene);
        }

        setScale(scaleX, scaleY) {
            if (scaleY === undefined) {
                scaleY = scaleX;
            }
            // Can override initial scale
            this.scaleX0 = scaleX;
            this.scaleY0 = scaleY;

            super.setScale(scaleX, scaleY);
            return this;
        }

        get isShowingMessage() {
            return this.player.isPlaying;
        }
    }

    Object.assign(
        Toast.prototype,
        ConfigurationMethods$1,
        MessageMethods$1,
    );

    ObjectFactory.register('toast', function (config) {
        var gameObject = new Toast(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Toast', Toast);

    var QueueDirectionMap = {
        'bottom-to-top': 1,
        'top-to-bottom': 0,
        'right-to-left': 1,
        'left-to-right': 0,
    };

    var ConfigurationMethods = {
        setQueueDirection(direction) {
            if (typeof (direction) === 'string') {
                direction = QueueDirectionMap[direction];
            }
            this.rtl = (direction === 0);

            if (this.orientation === 1) {
                if (direction) {
                    // bottom-to-top
                    this.queueDirection = 0;
                } else {
                    // top-to-bottom
                    this.queueDirection = 1;
                }
            } else {
                if (direction) {
                    // right-to-left
                    this.queueDirection = 2;
                } else {
                    // left-to-right
                    this.queueDirection = 3;
                }
            }

            return this;
        },

        setCreateMessageLabelCallback(callback) {
            this.createMessageLabelCallback = callback;
            return this;
        },

        setDisplayTime(time) {
            this.displayTime = time;
            return this;
        },

        setTransitOutTime(time) {
            this.transitOutTime = time;
            return this;
        },

        setTransitInTime(time) {
            this.transitInTime = time;
            return this;
        },

        setTransitInCallback(callback) {
            if (!callback) {
                callback = NOOP;
            }

            this.transitInCallback = callback;
            // callback = function(gameObject, duration, toastQueue) {}
            return this;
        },

        setTransitOutCallback(callback) {
            if (!callback) {
                callback = NOOP;
            }

            this.transitOutCallback = callback;
            // callback = function(gameObject, duration, toastQueue) {}
            return this;
        },
    };

    const OnClick = ClickMethods.onClick;
    const DelayCall = DelayCallMethods$2.delayCall;
    const MoveTo = methods$x.moveTo;

    var CreateChild = function (parent, callback, message) {
        var child = callback(parent.scene, message, parent);

        // Destroy this child when
        // Click
        OnClick.call(child, function () {
            parent.removeMessage(child);
        });

        // Timeout 
        if (parent.displayTime) {
            var delay = parent.transitInTime + parent.displayTime + 10;
            DelayCall.call(child, delay, function () {
                parent.removeMessage(child);
            });
        }

        return child;
    };

    var GetChildrenPosition = function (parent) {
        var children = parent.childrenMap.items,
            child;

        var positionList = [];
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            positionList.push({ x: child.x, y: child.y });
        }

        return positionList;
    };

    var RunLayout = function (parent) {
        var children = parent.childrenMap.items,
            child;

        // Store current scale, reset scale to 1
        var scaleList = [];
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            scaleList.push({ x: child.scaleX, y: child.scaleY });
            child.setScale(1);
        }

        // Run layout, with scale1
        parent.layout();
        var newPositionList = GetChildrenPosition(parent);

        // Restore scale
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var scaleData = scaleList[i];
            children[i].setScale(scaleData.x, scaleData.y);
        }

        return newPositionList;
    };

    var EaseChildren = function (parent, prevPositionList, newPositionList, duration) {
        var children = parent.childrenMap.items;
        var listLength = Math.min(prevPositionList.length, newPositionList.length, children.length);

        var child, prevPositionData, newPostionData;
        var queueDirection = parent.queueDirection;
        for (var i = 0; i < listLength; i++) {
            child = children[i];
            prevPositionData = prevPositionList[i];
            newPostionData = newPositionList[i];

            child.setPosition(prevPositionData.x, prevPositionData.y);

            switch (queueDirection) {
                case 0: // bottom-to-top
                    if (prevPositionData.y <= newPostionData.y) {
                        continue;
                    }
                    break;

                case 1: // top-to-bottom
                    if (prevPositionData.y >= newPostionData.y) {
                        continue;
                    }
                    break;

                case 2: // right-to-left
                    if (prevPositionData.x <= newPostionData.x) {
                        continue;
                    }
                    break;

                case 3: // left-to-right
                    if (prevPositionData.x >= newPostionData.x) {
                        continue;
                    }
                    break;
            }

            MoveTo.call(child, duration, newPostionData.x, newPostionData.y);
        }
    };

    var PushChild = function (parent, child, duration) {
        var prevPositionList = GetChildrenPosition(parent);
        parent.add(child);
        var newPositionList = RunLayout(parent);

        EaseChildren(parent, prevPositionList, newPositionList, duration);

        parent.transitInCallback(child, duration, parent);
    };

    var MessageMethods = {
        showMessage(message) {
            var child = CreateChild(this, this.createMessageLabelCallback, message);
            PushChild(this, child, this.transitInTime);
            return this;
        },

        removeMessage(messageLabel) {
            if (this.getParentSizer(messageLabel) !== this) {
                return this;
            }

            if (messageLabel.__isDestroying) {
                return;
            }

            messageLabel.__isDestroying = true;

            var duration = this.transitOutTime;
            this.transitOutCallback(messageLabel, duration, this);
            DelayCall.call(messageLabel, duration + 10, function () {
                delete messageLabel.__isDestroying;
                messageLabel.destroy();
            });

            return this;
        },

        removeAllMessages() {
            var children = this.childrenMap.items;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                this.removeMessage(children[i]);
            }
            return this;
        }
    };

    var Methods$1 = {};
    Object.assign(
        Methods$1,
        ConfigurationMethods,
        MessageMethods
    );

    var DefaultTransitionCallbacks = {
        transitIn(gameObject, duration, parent) {
            switch (parent.queueDirection) {
                case 0:  // bottom-to-top
                    gameObject.setOrigin(0.5, 1);
                    methods$z.popUp.call(gameObject, duration, 'y');
                    break;
                case 1:  // top-to-bottom
                    gameObject.setOrigin(0.5, 0);
                    methods$z.popUp.call(gameObject, duration, 'y');
                    break;
                case 2: // right-to-left
                    gameObject.setOrigin(1, 0.5);
                    methods$z.popUp.call(gameObject, duration, 'x');
                    break;
                case 3: // left-to-right
                    gameObject.setOrigin(0, 0.5);
                    methods$z.popUp.call(gameObject, duration, 'x');
                    break;
            }

            methods$y.fadeIn.call(gameObject, duration);
        },

        transitOut(gameObject, duration, parent) {
            methods$y.fadeOut.call(gameObject, duration);
        }
    };

    const GetValue$D = Phaser.Utils.Objects.GetValue;

    class ToastQueue extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            if (!config.hasOwnProperty('orientation')) {
                config.orientation = 1;
            }
            super(scene, config);
            this.type = 'rexToastQueue';

            this.setCreateMessageLabelCallback(GetValue$D(config, 'createMessageLabelCallback'));
            this.setQueueDirection(GetValue$D(config, 'queueDirection', 1));        
            this.setTransitInTime(GetValue$D(config, 'duration.in', 200));
            this.setDisplayTime(GetValue$D(config, 'duration.hold', 2000));
            this.setTransitOutTime(GetValue$D(config, 'duration.out', 200));
            this.setTransitInCallback(GetValue$D(config, 'transitIn', DefaultTransitionCallbacks.transitIn));
            this.setTransitOutCallback(GetValue$D(config, 'transitOut', DefaultTransitionCallbacks.transitOut));
        }
    }

    Object.assign(
        ToastQueue.prototype,
        Methods$1
    );

    ObjectFactory.register('toastQueue', function (config) {
        var gameObject = new ToastQueue(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ToastQueue', ToastQueue);

    var CreateSwatch = function (scene, config) {
        if (config === false) {
            return null;
        } else if (IsGameObject(config)) {
            return config;
        }

        var swatch = new RoundRectangle$2(scene, config);
        scene.add.existing(swatch);
        return swatch;
    };

    const Pad = Phaser.Utils.String.Pad;

    var GetHexColorString = function (value, prefix) {
        if (prefix === undefined) {
            prefix = '0x';
        }
        var colorString = value.toString(16).toUpperCase();
        colorString = Pad(colorString, 6, 0, 1);
        colorString = prefix + colorString;
        return colorString;
    };

    var SetSwatchColor = function (swatch, color) {
        if (!swatch) {
            return;
        }

        if (swatch.setTint) {
            swatch.setTint(color);
        } else if (swatch.setFillStyle) {
            swatch.setFillStyle(color);
        }
    };

    const GetValue$C = Phaser.Utils.Objects.GetValue;
    const IsPlainObject$4 = Phaser.Utils.Objects.IsPlainObject;
    const Clamp$2 = Phaser.Math.Clamp;

    let ColorInput$1 = class ColorInput extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            config.orientation = 0;
            super(scene, config);
            this.type = 'rexColorInputLite';

            // Add elements
            var background = GetValue$C(config, 'background', undefined);

            var swatchConfig = GetValue$C(config, 'swatch');
            var swatchSize;
            if (IsPlainObject$4(swatchConfig)) {
                swatchSize = GetValue$C(swatchConfig, 'size');
            }
            var swatch = CreateSwatch(scene, GetValue$C(config, 'swatch'));

            var inputTextConfig = GetValue$C(config, 'inputText', {});
            var inputText;
            if (inputTextConfig) {
                inputText = CreateInputText$1(scene, inputTextConfig);
            }

            if (background) {
                this.addBackground(background);
            }

            if (swatch) {
                swatchSize = GetValue$C(config, 'swatchSize', swatchSize);
                var squareExpandSwatch;
                if (swatchSize !== undefined) {
                    ResizeGameObject(swatch, swatchSize, swatchSize);
                    squareExpandSwatch = false;
                } else {
                    squareExpandSwatch = GetValue$C(config, 'squareExpandSwatch', true);
                }

                var fitRatio = (squareExpandSwatch) ? 1 : 0;
                this.add(
                    swatch,
                    { proportion: 0, expand: true, fitRatio: fitRatio }
                );
            }

            if (inputText) {
                var proportion = (GetValue$C(inputTextConfig, 'width') === undefined) ? 1 : 0;
                var expand = (GetValue$C(inputTextConfig, 'height') === undefined) ? true : false;
                this.add(
                    inputText,
                    { proportion: proportion, expand: expand }
                );
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('swatch', swatch);
            this.addChildrenMap('inputText', inputText);


            if (inputText) {
                inputText.on('close', function () {
                    this.setValue(inputText.value);
                }, this);
            }

            var callback = GetValue$C(config, 'valuechangeCallback', null);
            if (callback !== null) {
                var scope = GetValue$C(config, 'valuechangeCallbackScope', undefined);
                this.on('valuechange', callback, scope);
            }

            this.setValue(GetValue$C(config, 'value', 0x0));
        }

        get value() {
            return this._value;
        }

        set value(value) {
            if (typeof (value) === 'string') {
                value = ColorStringToInteger(value);
                if (value == null) {
                    var inputText = this.childrenMap.inputText;
                    if (inputText) {
                        inputText.setText(GetHexColorString(this._value));
                    }
                    return;
                }
            } else {
                value = Clamp$2(Math.floor(value), 0, 0xffffff);
            }

            if (this._value === value) {
                return;
            }

            this._value = value;

            var swatch = this.childrenMap.swatch;
            if (swatch) {
                SetSwatchColor(swatch, value);
            }

            var inputText = this.childrenMap.inputText;
            if (inputText) {
                inputText.setText(GetHexColorString(value));
            }

            this.emit('valuechange', this._value);
        }

        setValue(value) {
            this.value = value;
            return this;
        }

        get color() {
            return this._value;
        }

        set color(color) {
            this.value = color;
        }

        setColor(color) {
            this.color = color;
            return this;
        }

    };

    var methods$4 = {
        // Color picker
        setCreateColorPickerBackgroundCallback(callback) {
            this.colorPickerCreateBackgroundCallback = callback;
            return this;
        },

        setColorPickerHPalettePosition(position) {
            this.colorPickerHPalettePosition = position;
            return this;
        },

        setColorPickerExpandDirection(direction) {
            if (typeof (direction) === 'string') {
                direction = ColorPickerExpandDirections[direction];
            }
            this.colorPickerExpandDirection = direction;
            return this;
        },

        setColorPickerEaseInDuration(duration) {
            if (duration === undefined) {
                duration = 0;
            }
            this.colorPickerEaseInDuration = duration;
            return this;
        },

        setColorPickerEaseOutDuration(duration) {
            if (duration === undefined) {
                duration = 0;
            }
            this.colorPickerEaseOutDuration = duration;
            return this;
        },

        setColorPickerTransitInCallback(callback) {
            this.colorPickerTransitInCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

        setColorPickerTransitOutCallback(callback) {
            this.colorPickerTransitOutCallback = callback;
            // callback = function(gameObject, duration) {}
            return this;
        },

        setColorPickerBounds(bounds) {
            this.colorPickerBounds = bounds;
            return this;
        },

        setColorPickerWidth(width) {
            this.colorPickerWidth = width;
            return this;
        },

        setColorPickerHeight(height) {
            this.colorPickerHeight = height;
            return this;
        },

        setColorPickerSize(width, height) {
            this.setColorPickerWidth(width).setColorPickerHeight(height);
            return this;
        },

        setColorPickerSpace(space) {
            if (space === undefined) {
                space = {};
            }
            this.colorPickerSpace = space;
            return this;
        },

        // Color components
        setColorComponentsHeight(height) {
            this.colorComponentsHeight = height;
            return this;
        },

        setColorComponentsFormatLabelConfig(config) {
            this.colorComponentsFormatLabelConfig = config;
            return this;
        },

        setColorComponentsInputTextConfig(config) {
            this.colorComponentsInputTextConfig = config;
            return this;
        },

        setColorComponentsSpace(space) {
            if (space === undefined) {
                space = {};
            }
            this.colorComponentsSpace = space;
            return this;
        },
    };

    const ColorPickerExpandDirections = {
        down: 0,
        up: 1
    };

    const Color$3 = Phaser.Display.Color;
    const Percent$2 = Phaser.Math.Percent;

    var DrawHPalette = function (canvas, context, verticalMode) {
        if (verticalMode === undefined) {
            verticalMode = false;
        }
        var width = canvas.width;
        var height = canvas.height;
        var color = new Color$3();
        if (verticalMode) {
            for (var iy = 0; iy < height; iy++) {
                var h = Percent$2(iy, 0, height);
                color.setFromHSV(h, 1, 1);
                context.fillStyle = color.rgba;
                context.fillRect(0, iy, width, 1);
            }
        } else {
            for (var ix = 0; ix < width; ix++) {
                var h = Percent$2(ix, 0, width);
                color.setFromHSV(h, 1, 1);
                context.fillStyle = color.rgba;
                context.fillRect(ix, 0, 1, height);
            }
        }
    };

    var DrawSVPalette = function (canvas, context, h) {
        var width = canvas.width;
        var height = canvas.height;
        var imgData = context.getImageData(0, 0, width, height);
        var data = imgData.data;
        var color = new Color$3();
        for (var iy = 0; iy < height; iy++) {
            for (var ix = 0; ix < width; ix++) {
                var s = Percent$2(ix, 0, width);
                var v = 1 - Percent$2(iy, 0, height);
                color.setFromHSV(h, s, v);
                var i = ((iy * width) + ix) * 4;
                data[i] = color.red;
                data[i + 1] = color.green;
                data[i + 2] = color.blue;
                data[i + 3] = 255;
            }
        }
        context.putImageData(imgData, 0, 0);
    };

    const Color$2 = Phaser.Display.Color;
    const Percent$1 = Phaser.Math.Percent;
    const ColorToRGBA$2 = Phaser.Display.Color.ColorToRGBA;
    const HSVToRGB$2 = Phaser.Display.Color.HSVToRGB;

    class HPaletteCanvas extends Canvas {
        constructor(scene, x, y, width, height, orientation) {
            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 2; }
            if (height === undefined) { height = 2; }

            super(scene, x, y, width, height);
            this.type = 'rexColorPicker.HPaletteCanvas';

            this.colorObject = new Color$2();

            this.setOrientation(orientation);
            this.setSize(width, height);
        }

        setOrientation(orientation) {
            this.orientation = GetOrientationMode(orientation);
            return this;
        }

        updateTexture() {
            DrawHPalette(this.canvas, this.context, this.orientation);
            super.updateTexture();
            return this;
        }

        get color() {
            return this.colorObject.color;
        }

        get hue() {
            return this._hue;
        }

        set hue(value) {
            this._hue = value;
        }

        getHue(localX, localY) {
            if (localX === undefined) {
                return this.hue;
            }

            if (this.orientation === 0) {
                this.hue = Percent$1(localX, 0, this.width);
            } else {
                this.hue = Percent$1(localY, 0, this.height);
            }

            return this.hue;
        }

        getColor(localX, localY) {
            if (localX === undefined) {
                return this.color;
            }

            var h = this.getHue(localX, localY);
            this.colorObject.setFromRGB(HSVToRGB$2(h, 1, 1));
            return this.colorObject.color;
        }

        setColor(color) {
            if (this.color === color) {
                return this;
            }

            return this;
        }

        colorToLocalPosition(color, out) {
            if (out === undefined) {
                out = {};
            } else if (out === true) {
                if (LocalXY$1 === undefined) {
                    LocalXY$1 = {};
                }
                out = LocalXY$1;
            }

            this.colorObject.setFromRGB(ColorToRGBA$2(color));

            if (this.orientation === 0) {
                out.x = this.width * this.colorObject.h;
                out.y = this.height / 2;
            } else {
                out.x = this.width / 2;
                out.y = this.height * this.colorObject.h;
            }

            return out;
        }
    }

    var LocalXY$1 = undefined;

    var RotateAround$1 = Phaser.Math.RotateAround;
    var LocalToWorld = function (gameObject, localX, localY, out) {
        if (out === undefined) {
            out = {};
        } else if (out === true) {
            if (GlobOut === undefined) {
                GlobOut = {};
            }
            out = GlobOut;
        }

        localX -= (gameObject.width * gameObject.originX);
        localY -= (gameObject.height * gameObject.originY);
        var point = {
            x: localX * gameObject.scaleX,
            y: localY * gameObject.scaleY
        };
        RotateAround$1(point, 0, 0, -gameObject.rotation);

        out.x = gameObject.x + localX;
        out.y = gameObject.y + localY;

        return out;
    };

    var GlobOut;

    class HPalette extends OverlapSizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            super(scene, config);

            var orientation = (config.width != null) ? 1 : 0;
            var paletteCanvas = (new HPaletteCanvas(scene))
                .setOrientation(orientation);
            scene.add.existing(paletteCanvas);
            this.type = 'rexColorPicker.HPalette';

            paletteCanvas
                .setInteractive()
                .on('pointerdown', this.onPaletteCanvasPointerDown, this)
                .on('pointermove', this.onPaletteCanvasPointerDown, this);

            var marker = new RoundRectangle$2(scene, { strokeColor: 0xffffff, strokeWidth: 2 });
            scene.add.existing(marker);

            this
                .add(
                    paletteCanvas,
                    { key: 'paletteCanvas', expand: true }
                )
                .add(
                    marker,
                    { key: 'marker', expand: false }
                );
        }

        resize(width, height) {
            if ((this.width === width) && (this.height === height)) {
                return this;
            }

            super.resize(width, height);

            var size = Math.min(width, height);
            this.childrenMap.marker.setSize(size, size);

            return this;
        }

        onPaletteCanvasPointerDown(pointer, localX, localY, event) {
            if (!pointer.isDown) {
                return;
            }

            var paletteCanvas = this.childrenMap.paletteCanvas;
            var color = paletteCanvas.getColor(localX, localY);
            this.setMarkerPosition(color);

            this.emit('input', color);
        }

        get color() {
            return this.childrenMap.paletteCanvas.color;
        }

        setColor(color) {
            if (this.color === color) {
                return this;
            }

            var paletteCanvas = this.childrenMap.paletteCanvas;
            paletteCanvas.setColor(color);
            this.setMarkerPosition(color);

            return this;
        }

        setMarkerPosition(color) {
            var paletteCanvas = this.childrenMap.paletteCanvas;
            var marker = this.childrenMap.marker;

            var localXY = paletteCanvas.colorToLocalPosition(color, true);
            LocalToWorld(paletteCanvas, localXY.x, localXY.y, marker);
            this.resetChildPositionState(marker);

            return this;
        }

        getHue(localX, localY) {
            var paletteCanvas = this.childrenMap.paletteCanvas;
            return paletteCanvas.getHue(localX, localY);
        }
    }

    const Color$1 = Phaser.Display.Color;
    const Percent = Phaser.Math.Percent;
    const ColorToRGBA$1 = Phaser.Display.Color.ColorToRGBA;
    const HSVToRGB$1 = Phaser.Display.Color.HSVToRGB;

    class SVPaletteCanvas extends Canvas {
        constructor(scene, x, y, width, height, hue) {
            if (x === undefined) { x = 0; }
            if (y === undefined) { y = 0; }
            if (width === undefined) { width = 2; }
            if (height === undefined) { height = 2; }

            super(scene, x, y, width, height);
            this.type = 'rexColorPicker.SVPaletteCanvas';

            if (hue === undefined) {
                hue = 1;
            }

            this.colorObject = new Color$1();

            this.setHue(hue);
            this.setSize(width, height);
        }

        get color() {
            return this.colorObject.color;
        }

        get hue() {
            return this._hue;
        }

        set hue(hue) {
            if (this._hue === hue) {
                return;
            }
            this._hue = hue;
            this.colorObject.h = hue;
            this.dirty = true;
        }

        setHue(hue) {
            this.hue = hue;
            return this;
        }

        updateTexture() {
            DrawSVPalette(this.canvas, this.context, this.hue);
            super.updateTexture();
            return this;
        }

        getColor(localX, localY) {
            if (localX === undefined) {
                return this.colorObject.color;
            }

            var s = Percent(localX, 0, this.width);
            var v = 1 - Percent(localY, 0, this.height);
            this.colorObject.setFromRGB(HSVToRGB$1(this.hue, s, v));
            return this.colorObject.color;
        }

        setColor(color) {
            if (this.color === color) {
                return this;
            }

            this.colorObject.setFromRGB(ColorToRGBA$1(color));
            this.setHue(this.colorObject.h);
            return this;
        }

        colorToLocalPosition(color, out) {
            if (out === undefined) {
                out = {};
            } else if (out === true) {
                if (LocalXY === undefined) {
                    LocalXY = {};
                }
                out = LocalXY;
            }

            this.colorObject.setFromRGB(ColorToRGBA$1(color));
            out.x = this.width * this.colorObject.s;
            out.y = this.height * (1 - this.colorObject.v);

            return out;
        }
    }

    var LocalXY = undefined;

    class SVPalette extends OverlapSizer {
        constructor(scene, config) {
            super(scene, config);

            var paletteCanvas = new SVPaletteCanvas(scene);
            scene.add.existing(paletteCanvas);
            this.type = 'rexColorPicker.SVPalette';

            paletteCanvas
                .setInteractive()
                .on('pointerdown', this.onPaletteCanvasPointerDown, this)
                .on('pointermove', this.onPaletteCanvasPointerDown, this);

            var marker = new RoundRectangle$2(scene, { radius: 5, strokeColor: 0xffffff, strokeWidth: 2 });
            scene.add.existing(marker);

            this
                .add(
                    paletteCanvas,
                    { key: 'paletteCanvas', expand: true }
                )
                .add(
                    marker,
                    { key: 'marker', expand: false }
                );
        }

        onPaletteCanvasPointerDown(pointer, localX, localY, event) {
            if (!pointer.isDown) {
                return;
            }

            var paletteCanvas = this.childrenMap.paletteCanvas;
            var color = paletteCanvas.getColor(localX, localY);
            this.setMarkerPosition(color);

            this.emit('input', color);
        }

        get color() {
            return this.childrenMap.paletteCanvas.color;
        }

        setHue(hue) {
            var paletteCanvas = this.childrenMap.paletteCanvas;
            paletteCanvas.setHue(hue);  // Redraw paletteCanvas
            // Position of marker does not change
            return this;
        }

        setColor(color) {
            if (this.color === color) {
                return this;
            }

            var paletteCanvas = this.childrenMap.paletteCanvas;
            paletteCanvas.setColor(color);  // Redraw paletteCanvas
            this.setMarkerPosition(color);
            return this;
        }

        setMarkerPosition(color) {
            var paletteCanvas = this.childrenMap.paletteCanvas;
            var marker = this.childrenMap.marker;

            var localXY = paletteCanvas.colorToLocalPosition(color, true);
            LocalToWorld(paletteCanvas, localXY.x, localXY.y, marker);
            this.resetChildPositionState(marker);

            return this;
        }
    }

    const GetValue$B = Phaser.Utils.Objects.GetValue;

    class ColorPicker extends Sizer {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexColorPicker';
            this.freezePalettes = false;

            // orientation
            var hPalettePosition = GetValue$B(config, 'hPalette.position', 0);
            if (typeof (hPalettePosition) === 'string') {
                hPalettePosition = HPalettePositionNamesMap[hPalettePosition];
            }
            var orientation = (
                (hPalettePosition === 0) ||  // bottom
                (hPalettePosition === 2)     // top
            ) ? 1 :  // y
                0;   // x
            this.setOrientation(orientation);

            // Add elements
            var background = GetValue$B(config, 'background', undefined);

            var hPaletteWidth, hPaletteHeight;
            if (this.orientation === 0) {
                var hPaletteWidth = GetValue$B(config, 'hPalette.width', undefined);
                if (hPaletteWidth === undefined) {
                    hPaletteWidth = GetValue$B(config, 'hPalette.size', 10);
                }
            } else {
                hPaletteHeight = GetValue$B(config, 'hPalette.height', undefined);
                if (hPaletteHeight === undefined) {
                    hPaletteHeight = GetValue$B(config, 'hPalette.size', 10);
                }
            }

            var hPalette = new HPalette(scene, {
                width: hPaletteWidth,
                height: hPaletteHeight
            });
            scene.add.existing(hPalette);

            var svPaletteWidth = GetValue$B(config, 'svPalette.width', undefined);
            var svPaletteHeight = GetValue$B(config, 'svPalette.height', undefined);

            var svPalette = new SVPalette(scene, {
                width: svPaletteWidth,
                height: svPaletteHeight
            });
            scene.add.existing(svPalette);

            if (background) {
                this.addBackground(background);
            }

            var hPaletteAddConfig = {
                proportion: 0, expand: true
            };

            var svPaletteProportion, svPaletteExpand;
            if (this.orientation === 0) {
                svPaletteProportion = (svPaletteWidth === undefined) ? 1 : 0;
                svPaletteExpand = (svPaletteHeight === undefined) ? true : false;
            } else {
                svPaletteProportion = (svPaletteHeight === undefined) ? 1 : 0;
                svPaletteExpand = (svPaletteWidth === undefined) ? true : false;
            }
            var svPaletteAddConfig = {
                proportion: svPaletteProportion, expand: svPaletteExpand
            };

            if ((hPalettePosition === 0) || (hPalettePosition === 3)) {  // bottom, right
                this
                    .add(svPalette, svPaletteAddConfig)
                    .add(hPalette, hPaletteAddConfig);
            } else {  // left, top
                this
                    .add(hPalette, hPaletteAddConfig)
                    .add(svPalette, svPaletteAddConfig);
            }

            hPalette
                .on('input', function () {
                    svPalette.setHue(hPalette.getHue());
                    this.setValue(svPalette.color, true);
                }, this);

            svPalette
                .on('input', function () {
                    this.setValue(svPalette.color, true);
                }, this);

            this.addChildrenMap('background', background);
            this.addChildrenMap('hPalette', hPalette);
            this.addChildrenMap('svPalette', svPalette);

            var callback = GetValue$B(config, 'valuechangeCallback', null);
            if (callback !== null) {
                var scope = GetValue$B(config, 'valuechangeCallbackScope', undefined);
                this.on('valuechange', callback, scope);
            }

            this.setValue(GetValue$B(config, 'value', 0xffffff));
        }

        get value() {
            return this._value;
        }

        set value(value) {
            if (this._value === value) {
                return;
            }

            var oldValue = this._value;
            this._value = value;

            if (!this.freezePalettes) {
                this.updatePalettes();
            }

            this.emit('valuechange', value, oldValue, this);
        }

        setValue(value, freezePalettes) {
            this.freezePalettes = !!freezePalettes;
            this.value = value;
            this.freezePalettes = false;
            return this;
        }

        get color() {
            return this._value;
        }

        set color(color) {
            this.value = color;
        }

        setColor(color) {
            this.color = color;
            return this;
        }

        updatePalettes() {
            this.childrenMap.hPalette.setColor(this.color);
            this.childrenMap.svPalette.setColor(this.color);
            return this;
        }

        postLayout(parent, newWidth, newHeight) {
            this.childrenMap.hPalette.setMarkerPosition(this.value);
            this.childrenMap.svPalette.setMarkerPosition(this.value);
            super.postLayout(parent, newWidth, newHeight);
            return this;
        }

    }

    var HPalettePositionNamesMap = {
        bottom: 0,
        left: 1,
        top: 2,
        right: 3
    };

    const GetValue$A = Phaser.Utils.Objects.GetValue;
    const Color = Phaser.Display.Color;
    const ColorToRGBA = Phaser.Display.Color.ColorToRGBA;
    const HSVToRGB = Phaser.Display.Color.HSVToRGB;
    const Clamp$1 = Phaser.Math.Clamp;

    class ColorComponents extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            config.orientation = 0;
            super(scene, config);
            this.type = 'rexColorComponents';

            this.colorObject = new Color();

            // Add elements
            var background = GetValue$A(config, 'background', undefined);

            var formatLabel = GetValue$A(config, 'formatLabel', undefined);
            if (!IsGameObject(formatLabel)) {
                formatLabel = CreateLabel(scene, formatLabel)
                    .resetDisplayContent();
            }

            var components = [];
            if (config.inputText0 && config.inputText1 && config.inputText2) {
                components.push(config.inputText0);
                components.push(config.inputText1);
                components.push(config.inputText2);
            } else {
                var inputTextConfig = GetValue$A(config, 'inputText');
                for (var i = 0; i < 3; i++) {
                    var inputText = CreateInputText$1(scene, inputTextConfig)
                        .setMaxLength(3)
                        .setNumberInput();

                    components.push(inputText);
                }
            }

            if (background) {
                this.addBackground(background);
            }

            var proportion = GetValue$A(config, 'proportion.formatLabel', 0);
            var defaultExpand = (formatLabel.isRexContainerLite) ? true : false;
            var expand = GetValue$A(config, 'expand.formatLabel', defaultExpand);
            this.add(
                formatLabel,
                { proportion: proportion, expand: expand }
            );

            var proportion = (GetValue$A(inputTextConfig, 'width') === undefined) ? 1 : 0;
            var expand = (GetValue$A(inputTextConfig, 'height') === undefined) ? true : false;
            for (var i = 0, cnt = components.length; i < cnt; i++) {
                this.add(
                    components[i],
                    { proportion: proportion, expand: expand }
                );
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('formatLabel', formatLabel);
            this.addChildrenMap('components', components);

            this.onClick(formatLabel, this.toggleColorFormat, this);

            for (var i = 0, cnt = components.length; i < cnt; i++) {
                components[i].on('close', function () {
                    this.updateColorObject();
                    this.setValue(this.colorObject.color);
                }, this);
            }

            var callback = GetValue$A(config, 'valuechangeCallback', null);
            if (callback !== null) {
                var scope = GetValue$A(config, 'valuechangeCallbackScope', undefined);
                this.on('valuechange', callback, scope);
            }

            formatLabel.setText('RGB');
            this.setValue(GetValue$A(config, 'value', 0xffffff));
        }

        get value() {
            return this._value;
        }

        set value(value) {
            value = Clamp$1(Math.floor(value), 0, 0xffffff);

            if (this._value === value) {
                return;
            }

            this._value = value;

            this.colorObject.setFromRGB(ColorToRGBA(value));
            this.updateComponents();

            this.emit('valuechange', this._value);
        }

        setValue(value) {
            this.value = value;
            return this;
        }

        get color() {
            return this._value;
        }

        set color(color) {
            this.value = color;
        }

        setColor(color) {
            this.color = color;
            return this;
        }

        get colorFormat() {
            return this.childrenMap.formatLabel.text;
        }

        set colorFormat(value) {
            if (this.colorFormat === value) {
                return;
            }
            this.childrenMap.formatLabel.setText(value);
            this.updateComponents();
        }

        setColorFormat(colrType) {
            this.colorFormat = colrType;
            return this;
        }

        toggleColorFormat() {
            this.colorFormat = (this.colorFormat === 'RGB') ? 'HSV' : 'RGB';
            return this;
        }

        updateComponents() {
            var components = this.childrenMap.components;
            var value0, value1, value2;
            if (this.colorFormat === 'RGB') {
                value0 = this.colorObject.red;
                value1 = this.colorObject.green;
                value2 = this.colorObject.blue;
            } else { // colorFormat === 'HSV'
                value0 = Math.floor(this.colorObject.h * 360);
                value1 = Math.floor(this.colorObject.s * 100);
                value2 = Math.floor(this.colorObject.v * 100);
            }

            components[0].setValue(value0);
            components[1].setValue(value1);
            components[2].setValue(value2);
            return this;
        }

        updateColorObject() {
            var components = this.childrenMap.components;
            if (this.colorFormat === 'RGB') {
                var red = Clamp$1(components[0].value, 0, 255);
                var green = Clamp$1(components[1].value, 0, 255);
                var blue = Clamp$1(components[2].value, 0, 255);
                this.colorObject.setTo(red, green, blue);
            } else {
                var h = Clamp$1(components[0].value, 0, 359) / 360;
                var s = Clamp$1(components[1].value, 0, 100) / 100;
                var v = Clamp$1(components[2].value, 0, 100) / 100;
                this.colorObject.setFromRGB(HSVToRGB(h, s, v));
            }
            return this;
        }
    }

    const GetValue$z = Phaser.Utils.Objects.GetValue;

    class ColorPickerPanel extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            config.orientation = 1;
            super(scene, config);
            this.type = 'rexColorInput.ColorPickerPanel';

            // Add elements
            var background = GetValue$z(config, 'background', undefined);

            var colorPicker = new ColorPicker(scene, {
                hPalette: config.hPalette || {},
                svPalette: config.svPalette || {},
                space: {
                    item: GetValue$z(config, 'space.hPalette', 8)
                }
            });
            scene.add.existing(colorPicker);

            var colorComponents;
            if (config.colorComponents) {
                colorComponents = new ColorComponents(scene, config.colorComponents);
                scene.add.existing(colorComponents);
            }

            if (background) {
                this.addBackground(background);
                new TouchEventStop(background, {
                    stopAllLevels: false,
                });
            }

            this.add(
                colorPicker,
                { proportion: 1, expand: true }
            );

            if (colorComponents) {
                this.add(
                    colorComponents,
                    { proportion: 0, expand: true }
                );
            }

            this.addChildrenMap('background', background);
            this.addChildrenMap('colorPicker', colorPicker);
            this.addChildrenMap('colorComponents', colorComponents);

            colorPicker.on('valuechange', function (value) {
                this.setValue(value);
            }, this);

            if (colorComponents) {
                colorComponents.on('valuechange', function (value) {
                    this.setValue(value);
                }, this);
            }

            this.setValue(GetValue$z(config, 'value', 0xffffff));
        }

        get value() {
            return this._value;
        }

        set value(value) {
            if (this._value === value) {
                return;
            }

            this._value = value;

            var colorPicker = this.childrenMap.colorPicker;
            colorPicker.setValue(value);

            var colorComponents = this.childrenMap.colorComponents;
            if (colorComponents) {
                colorComponents.setValue(value);
            }

            this.emit('valuechange', value);
        }

        setValue(value) {
            this.value = value;
            return this;
        }

    }

    Phaser.Utils.Objects.GetValue;

    var CreateColorPicker = function (scene) {
        var scene = this.scene;

        var background;
        var createBackgroundCallback = this.colorPickerCreateBackgroundCallback;
        if (createBackgroundCallback) {
            background = createBackgroundCallback.call(this, scene);
            scene.add.existing(background);
        }

        var width = this.colorPickerWidth;
        if (width === undefined) {
            width = this.width;
        }

        var height = this.colorPickerHeight;
        if (height === undefined) {
            height = width;
        }

        var colorComponentsConfig;
        if (this.colorComponentsHeight > 0) {
            colorComponentsConfig = {
                height: this.colorComponentsHeight,
                formatLabel: this.colorComponentsFormatLabelConfig,
                inputText: this.colorComponentsInputTextConfig,
                space: this.colorComponentsSpace,
            };
        } else {
            colorComponentsConfig = false;
        }

        var colorPicker = new ColorPickerPanel(scene, {
            width: width, height: height,

            background: background,
            space: this.colorPickerSpace,

            hPalette: {
                position: this.colorPickerHPalettePosition,
            },

            colorComponents: colorComponentsConfig,

            value: this.value
        });
        scene.add.existing(colorPicker);

        return colorPicker;
    };

    var OpenColorPicker = function () {
        if (this.colorPicker) {
            return;
        }

        // Layout it to get full height
        var colorPicker = CreateColorPicker.call(this).layout();

        var dropDownBehavior = new DropDown(colorPicker, {
            // Transition
            duration: {
                in: this.colorPickerEaseInDuration,
                out: this.colorPickerEaseOutDuration
            },
            transitIn: this.colorPickerTransitInCallback,
            transitOut: this.colorPickerTransitOutCallback,

            // Position
            expandDirection: this.colorPickerExpandDirection,

            alignTargetX: this,
            alignTargetY: this,

            bounds: this.colorPickerBounds,

            // Close condition
            touchOutsideClose: true,
        })
            .on('open', function () {
                // After popping up
                // Can click
                colorPicker.on('valuechange', function (value) {
                    this.setValue(value);
                }, this);
            }, this)

            .on('close', function () {
                this.colorPicker = undefined;
                this.dropDownBehavior = undefined;
            }, this);

        this.colorPicker = colorPicker;
        this.dropDownBehavior = dropDownBehavior;

        this.pin(colorPicker);

        return this;
    };

    var methods$3 = {
        openColorPicker: OpenColorPicker
    };

    Object.assign(
        methods$3,
        methods$4,
    );

    const GetValue$y = Phaser.Utils.Objects.GetValue;

    class ColorInput extends ColorInput$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            super(scene, config);
            this.type = 'rexColorInput';

            if (!config.hasOwnProperty('colorPicker')) {
                config.colorPicker = {
                    background: { color: 0x0 }
                };
            }

            var colorPickerConfig = config.colorPicker;
            var hasColorPicker = (colorPickerConfig !== false) && (colorPickerConfig !== null);

            if (hasColorPicker) {
                this.setColorPickerSize(
                    GetValue$y(colorPickerConfig, 'width', 160),
                    GetValue$y(colorPickerConfig, 'height', 170)
                );

                var createBackgroundCallback;
                var background = GetValue$y(colorPickerConfig, 'background');
                if (background) {
                    createBackgroundCallback = function (scene) {
                        return CreateBackground$2(scene, background);
                    };
                } else {
                    createBackgroundCallback = GetValue$y(colorPickerConfig, 'createBackgroundCallback');
                }
                this.setCreateColorPickerBackgroundCallback(createBackgroundCallback);

                this.setColorPickerHPalettePosition(GetValue$y(colorPickerConfig, 'hPalettePosition', 0));
                this.setColorPickerExpandDirection(GetValue$y(colorPickerConfig, 'expandDirection'));
                this.setColorPickerEaseInDuration(GetValue$y(colorPickerConfig, 'easeIn', 200));
                this.setColorPickerEaseOutDuration(GetValue$y(colorPickerConfig, 'easeOut', 200));
                this.setColorPickerTransitInCallback(GetValue$y(colorPickerConfig, 'transitIn'));
                this.setColorPickerTransitOutCallback(GetValue$y(colorPickerConfig, 'transitOut'));
                this.setColorPickerBounds(GetValue$y(colorPickerConfig, 'bounds'));

                var colorPickerSpaceConfig = GetValue$y(colorPickerConfig, 'space');
                if (colorPickerSpaceConfig === undefined) {
                    colorPickerSpaceConfig = { left: 10, right: 10, top: 10, bottom: 10, item: 8 };
                }
                this.setColorPickerSpace(colorPickerSpaceConfig);
            }

            var colorComponentsConfig = config.colorComponents;
            var hasColorComponents = (colorComponentsConfig !== false) && (colorComponentsConfig !== null);
            if (hasColorPicker && hasColorComponents) {
                this.setColorComponentsHeight(GetValue$y(colorComponentsConfig, 'height', 30));

                this.setColorComponentsFormatLabelConfig(GetValue$y(colorComponentsConfig, 'formatLabel'));

                var colorComponentsInputTextConfig = GetValue$y(colorComponentsConfig, 'inputText');
                if (!colorComponentsInputTextConfig) {
                    colorComponentsInputTextConfig = GetValue$y(config, 'inputText');
                }
                this.setColorComponentsInputTextConfig(colorComponentsInputTextConfig);

                var colorComponentsSpace = GetValue$y(colorComponentsConfig, 'space');
                if (colorComponentsSpace === undefined) {
                    colorComponentsSpace = { item: 8 };
                }
                this.setColorComponentsSpace(colorComponentsSpace);
            }



            var swatch = this.childrenMap.swatch;
            if (swatch && hasColorPicker) {
                this.onClick(swatch, this.openColorPicker, this);
            }
        }
    }

    Object.assign(
        ColorInput.prototype,
        methods$3,
    );

    ObjectFactory.register('colorInput', function (config) {
        var gameObject = new ColorInput(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ColorInput', ColorInput);

    ObjectFactory.register('colorInputLite', function (config) {
        var gameObject = new ColorInput$1(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ColorInputBase', ColorInput$1);

    ObjectFactory.register('colorPicker', function (config) {
        var gameObject = new ColorPicker(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ColorPicker', ColorPicker);

    ObjectFactory.register('colorComponents', function (config) {
        var gameObject = new ColorComponents(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.ColorComponents', ColorComponents);

    var RequestDrag = function (gameObject) {
        var inputPlugin = gameObject.scene.input;
        var inputManager = inputPlugin.manager;
        var pointersTotal = inputManager.pointersTotal;
        var pointers = inputManager.pointers,
            pointer;
        for (var i = 0; i < pointersTotal; i++) {
            pointer = pointers[i];
            if (
                (!pointer.primaryDown) ||
                (inputPlugin.getDragState(pointer) !== 0) ||
                (!IsPointerInHitArea(gameObject, pointer))
            ) {
                continue;
            }

            // For 3.18.0
            inputPlugin.setDragState(pointer, 1);
            inputPlugin._drag[pointer.id] = [gameObject];
            if ((inputPlugin.dragDistanceThreshold === 0) || (inputPlugin.dragTimeThreshold === 0)) {
                //  No drag criteria, so snap immediately to mode 3
                inputPlugin.setDragState(pointer, 3);
                inputPlugin.processDragStartList(pointer);
            } else {
                //  Check the distance / time on the next event
                inputPlugin.setDragState(pointer, 2);
            }
            // For 3.18.0

            return true;
        }

        return false;
    };

    const GetValue$x = Phaser.Utils.Objects.GetValue;
    const DistanceBetween = Phaser.Math.Distance.Between;
    const RotateAroundDistance = Phaser.Math.RotateAroundDistance;

    class Drag extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject, { eventEmitter: false });
            // No event emitter
            // this.parent = gameObject;

            this._enable = undefined;
            gameObject.setInteractive(GetValue$x(config, "inputConfig", undefined));
            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            this.pointer = undefined;
            this.setEnable(GetValue$x(o, "enable", true));
            this.setAxisMode(GetValue$x(o, "axis", 0));
            this.setAxisRotation(GetValue$x(o, "rotation", 0));
            return this;
        }

        toJSON() {
            return {
                enable: this.enable,
                axis: this.axisMode,
                rotation: this.axisRotation
            };
        }

        boot() {
            var gameObject = this.parent;
            gameObject.on('dragstart', this.onDragStart, this);
            gameObject.on('drag', this.onDrag, this);
            gameObject.on('dragend', this.onDragEnd, this);
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            // GameObject events will be removed when this gameObject destroyed 
            // this.parent.on('dragstart', this.onDragStart, this);
            // this.parent.on('drag', this.onDrag, this);
            // this.parent.on('dragend', this.onDragEnd, this);
            this.pointer = undefined;

            super.shutdown(fromScene);
        }

        get enable() {
            return this._enable;
        }

        set enable(e) {
            if (this._enable === e) {
                return;
            }

            if (!e) {
                this.dragend();
            }
            this._enable = e;
            this.scene.input.setDraggable(this.parent, e);
            return this;
        }

        setEnable(e) {
            if (e === undefined) {
                e = true;
            }

            this.enable = e;
            return this;
        }

        toggleEnable() {
            this.setEnable(!this.enable);
            return this;
        }

        setAxisMode(m) {
            if (typeof (m) === 'string') {
                m = DIRECTIONNODE[m];
            }
            this.axisMode = m;
            return this;
        }

        setAxisRotation(a) {
            this.axisRotation = a;
            return this;
        }

        drag() {
            RequestDrag(this.parent);
            return this;
        }

        dragend() {
            if (!this.isDragging) {
                return;
            }
            this.scene.input.setDragState(this.pointer, 5);
            return this;
        }

        onDragStart(pointer, dragX, dragY) {
            if (this.isDragging) {
                return;
            }
            this.pointer = pointer;
        }

        onDrag(pointer, dragX, dragY) {
            if (this.pointer !== pointer) {
                return;
            }
            var gameObject = this.parent;
            if (this.axisMode === 0) {
                gameObject.x = dragX;
                gameObject.y = dragY;
            } else if (this.axisRotation === 0) {
                if (this.axisMode === 1) {
                    gameObject.x = dragX;
                } else if (this.axisMode === 2) {
                    gameObject.y = dragY;
                }
            } else {
                var dist;
                var p1 = { x: dragX, y: dragY };
                dist = DistanceBetween(p1.x, p1.y, gameObject.x, gameObject.y);
                p1 = RotateAroundDistance(p1, gameObject.x, gameObject.y, -this.axisRotation, dist);

                if (this.axisMode === 1) {
                    p1.y = gameObject.y;
                } else if (this.axisMode === 2) {
                    p1.x = gameObject.x;
                }
                dist = DistanceBetween(p1.x, p1.y, gameObject.x, gameObject.y);
                p1 = RotateAroundDistance(p1, gameObject.x, gameObject.y, this.axisRotation, dist);

                gameObject.x = p1.x;
                gameObject.y = p1.y;
            }

        }

        onDragEnd(pointer, dragX, dragY, dropped) {
            if (this.pointer !== pointer) {
                return;
            }
            this.pointer = undefined;
        }

        get isDragging() {
            return (this.pointer !== undefined);
        }
    }

    const DIRECTIONNODE = {
        'both': 0,
        'h&v': 0,
        'x&y': 0,
        'horizontal': 1,
        'h': 1,
        'x': 1,
        'vertical': 2,
        'v': 2,
        'y': 2
    };

    var OnDragSplitter = function () {
        var firstChild = this.sizerChildren[0];
        var splitter = this.sizerChildren[1];
        var secondChild = this.sizerChildren[2];

        var firstChildSizerPadding = this.getSizerConfig(firstChild).padding,
            splitterSizerPadding = this.getSizerConfig(splitter).padding,
            secondChildSizerPadding = this.getSizerConfig(secondChild).padding;

        if (this.orientation === 0) {
            var firstChildInnerLeft = this.innerLeft + firstChildSizerPadding.left;
            var secondChildInnerRight = this.innerRight - secondChildSizerPadding.right;

            var splitterWidth = GetDisplayWidth(splitter);
            var splitterLeft = splitter.x + (splitterWidth * (0 - splitter.originX));
            var splitterRight = splitter.x + (splitterWidth * (1 - splitter.originX));
            var firstChildInnerRight = splitterLeft - splitterSizerPadding.left - this.space.item - firstChildSizerPadding.right;
            var secondChildInnerLeft = splitterRight + splitterSizerPadding.right + this.space.item + secondChildSizerPadding.left;

            var firstChildInnerWidth = firstChildInnerRight - firstChildInnerLeft;
            var secondChildInnerWidth = secondChildInnerRight - secondChildInnerLeft;
            var totalChildrenInnerWidth = firstChildInnerWidth + secondChildInnerWidth;

            if ((this.minFirstChildSize > 0) && (firstChildInnerWidth < this.minFirstChildSize)) {
                firstChildInnerWidth = this.minFirstChildSize;
                secondChildInnerWidth = totalChildrenInnerWidth - firstChildInnerWidth;
            }

            if ((this.minSecondChildSize > 0) && (secondChildInnerWidth < this.minSecondChildSize)) {
                secondChildInnerWidth = this.minSecondChildSize;
                firstChildInnerWidth = totalChildrenInnerWidth - secondChildInnerWidth;
            }

            this.setSplitRatio(firstChildInnerWidth / totalChildrenInnerWidth);

        } else {
            var firstChildInnerTop = this.innerTop + firstChildSizerPadding.top;
            var secondChildInnerBottom = this.innerBottom - secondChildSizerPadding.bottom;

            var splitterHeight = GetDisplayHeight(splitter);
            var splitterTop = splitter.y + (splitterHeight * (0 - splitter.originY));
            var splitterBottom = splitter.y + (splitterHeight * (1 - splitter.originY));
            var firstChildInnerBottom = splitterTop - splitterSizerPadding.top - this.space.item - firstChildSizerPadding.bottom;
            var secondChildInnerTop = splitterBottom + splitterSizerPadding.bottom + this.space.item + secondChildSizerPadding.top;

            var firstChildInnerHeight = firstChildInnerBottom - firstChildInnerTop;
            var secondChildInnerHeight = secondChildInnerBottom - secondChildInnerTop;
            var totalChildrenInnerHeight = firstChildInnerHeight + secondChildInnerHeight;

            if ((this.minFirstChildSize > 0) && (firstChildInnerHeight < this.minFirstChildSize)) {
                firstChildInnerHeight = this.minFirstChildSize;
                secondChildInnerHeight = totalChildrenInnerHeight - firstChildInnerHeight;
            }

            if ((this.minSecondChildSize > 0) && (secondChildInnerHeight < this.minSecondChildSize)) {
                secondChildInnerHeight = this.minSecondChildSize;
                firstChildInnerHeight = totalChildrenInnerHeight - secondChildInnerHeight;
            }

            this.setSplitRatio(firstChildInnerHeight / totalChildrenInnerHeight);
        }

        var minWidthSave = this.minWidth,
            minHeightSave = this.minHeight;

        this
            .setMinSize(this.width, this.height)
            .layout()
            .setMinSize(minWidthSave, minHeightSave);
    };

    const GetValue$w = Phaser.Utils.Objects.GetValue;
    const Clamp = Phaser.Math.Clamp;


    class SplitPanels extends Sizer {
        constructor(scene, config) {
            if (!config.hasOwnProperty('orientation')) {
                config.orientation = (config.hasOwnProperty('leftPanel')) ? 0 : 1;
            }

            super(scene, config);
            this.type = 'rexSplit';

            // Add elements
            var background = GetValue$w(config, 'background', undefined);
            var firstChildKey, secondChildKey;
            var minFirstChildSizeKey, minSecondChildSizeKey;
            if (this.orientation === 0) {
                firstChildKey = 'leftPanel';
                secondChildKey = 'rightPanel';
                minFirstChildSizeKey = 'minLeftPanelWidth';
                minSecondChildSizeKey = 'minRightPanelWidth';
            } else {
                firstChildKey = 'topPanel';
                secondChildKey = 'bottomPanel';
                minFirstChildSizeKey = 'minTopPanelHeight';
                minSecondChildSizeKey = 'minBottomPanelHeight';
            }

            var firstChild = GetValue$w(config, firstChildKey, undefined);
            var splitter = GetValue$w(config, 'splitter', undefined);
            var secondChild = GetValue$w(config, secondChildKey, undefined);

            if (background) {
                this.addBackground(background);
            }

            var spaceConfig = GetValue$w(config, 'space', undefined);

            this.add(
                firstChild,
                {
                    proportion: 1,
                    expand: true,
                    padding: {
                        left: GetValue$w(spaceConfig, `${firstChildKey}Left`, 0),
                        right: GetValue$w(spaceConfig, `${firstChildKey}Right`, 0),
                        top: GetValue$w(spaceConfig, `${firstChildKey}Top`, 0),
                        bottom: GetValue$w(spaceConfig, `${firstChildKey}Bottom`, 0),
                    }
                }
            );

            this.add(splitter,
                {
                    proportion: 0,
                    expand: true,
                    padding: {
                        left: GetValue$w(spaceConfig, 'splitterLeft', 0),
                        right: GetValue$w(spaceConfig, 'splitterRight', 0),
                        top: GetValue$w(spaceConfig, 'splitterTop', 0),
                        bottom: GetValue$w(spaceConfig, 'splitterBottom', 0),
                    }
                }
            );

            this.add(
                secondChild,
                {
                    proportion: 1,
                    expand: true,
                    padding: {
                        left: GetValue$w(spaceConfig, `${secondChildKey}Left`, 0),
                        right: GetValue$w(spaceConfig, `${secondChildKey}Right`, 0),
                        top: GetValue$w(spaceConfig, `${secondChildKey}Top`, 0),
                        bottom: GetValue$w(spaceConfig, `${secondChildKey}Bottom`, 0),
                    }
                }
            );


            this.addChildrenMap('background', background);
            this.addChildrenMap(firstChildKey, firstChild);
            this.addChildrenMap('splitter', splitter);
            this.addChildrenMap(secondChildKey, secondChild);

            this.minFirstChildSize = GetValue$w(config, minFirstChildSizeKey, 0);
            this.minSecondChildSize = GetValue$w(config, minSecondChildSizeKey, 0);
            this.setSplitRatio(GetValue$w(config, 'splitRatio', 0.5));

            this.splitterDragBehavior = new Drag(splitter, {
                axis: (this.orientation === 0) ? 1 : 2,
            });

            splitter
                .on('dragstart', function () {
                    this.emit('splitter.dragstart', splitter, this.splitRatio);
                }, this)
                .on('dragend', function () {
                    this.emit('splitter.dragend', splitter, this.splitRatio);
                }, this)
                .on('drag', function () {
                    OnDragSplitter.call(this);
                    this.emit('splitter.drag', splitter, this.splitRatio);
                }, this)
                .on('pointerover', function () {
                    this.emit('splitter.over', splitter, this.splitRatio);
                }, this)
                .on('pointerout', function () {
                    this.emit('splitter.out', splitter, this.splitRatio);
                }, this);

        }

        get splitterEnable() {
            return this.splitterDragBehavior.enable;
        }

        set splitterEnable(value) {
            this.splitterDragBehavior.setEnable(value);
        }

        setSplitterEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.splitterEnable = enable;
            return this;
        }

        set minLeftPanelWidth(value) {
            this.minFirstChildSize = value;
        }

        get minLeftPanelWidth() {
            return this.minFirstChildSize;
        }

        set minRightPanelWidth(value) {
            this.minSecondChildSize = value;
        }

        get minRightPanelWidth() {
            return this.minSecondChildSize;
        }

        set minTopPanelHeight(value) {
            this.minFirstChildSize = value;
        }

        get minTopPanelHeight() {
            return this.minFirstChildSize;
        }

        set minBottomPanelHeight(value) {
            this.minSecondChildSize = value;
        }

        get minBottomPanelHeight() {
            return this.minSecondChildSize;
        }

        setMinLeftPanelWidth(value) {
            this.minLeftPanelWidth = value;
            return this;
        }

        setMinRightPanelWidth(value) {
            this.minRightPanelWidth = value;
            return this;
        }

        setMinTopPanelHeight(value) {
            this.minTopPanelHeight = value;
            return this;
        }

        setMinBottomPanelHeight(value) {
            this.minBottomPanelHeight = value;
            return this;
        }

        get splitRatio() {
            return this._splitRatio;
        }

        set splitRatio(value) {
            value = Clamp(value, 0, 1);
            if (this._splitRatio === value) {
                return;
            }

            this._splitRatio = value;
            this.getSizerConfig(this.sizerChildren[0]).proportion = value;
            this.getSizerConfig(this.sizerChildren[2]).proportion = 1 - value;
        }

        setSplitRatio(value) {
            this.splitRatio = value;
            return this;
        }
    }

    ObjectFactory.register('splitPanels', function (config) {
        var gameObject = new SplitPanels(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.SplitPanels', SplitPanels);

    var GetShowCallback$1 = function () {
        return function (child, key, sides, reset) {
            if (key !== 'panel') {
                sides.setChildVisible(child, true);
            }
        }
    };

    var GetHideCallback$1 = function () {
        return function (child, key, sides, reset) {
            if (key !== 'panel') {
                sides.setChildVisible(child, false);
            }
        }
    };

    var VisibleCallbacks = {
        show: GetShowCallback$1,
        hide: GetHideCallback$1
    };

    var GetShowCallback = function (duration, alpha) {
        if (alpha === undefined) {
            alpha = 1;
        }
        return function (child, key, sides, reset) {
            if (key !== 'panel') {
                sides.fadeChild(child, ((reset) ? 0 : duration), alpha);
            }
        }
    };

    var GetHideCallback = function (duration, alpha) {
        if (alpha === undefined) {
            alpha = 0;
        }
        return function (child, key, sides, reset) {
            if (key !== 'panel') {
                sides.fadeChild(child, ((reset) ? 0 : duration), alpha);
            }
        }
    };

    var FadeCallbacks = {
        show: GetShowCallback,
        hide: GetHideCallback
    };

    var GetCallback$1 = function (duration, ease) {
        return function (child, key, sides, reset) {
            if (key !== 'panel') {
                sides.moveChild(child, ((reset) ? 0 : duration), ease);
            }
        }
    };

    var MoveCallbacks = {
        show: GetCallback$1,
        hide: GetCallback$1
    };

    var GetCallback = function (duration, ease) {
        return function (child, key, sides, reset) {
            if (key === 'panel') {
                sides.moveChild(child, ((reset) ? 0 : duration), ease);
            }
        }
    };

    var MovePanelCallbacks = {
        show: GetCallback,
        hide: GetCallback
    };

    const DefaultCallbacks = {
        visible: VisibleCallbacks,
        fade: FadeCallbacks,
        move: MoveCallbacks,
        'move-panel': MovePanelCallbacks
    };

    var GetDefaultCallbacks = function (config) {
        var callbackType, callbackParams;
        [callbackType, ...callbackParams] = (typeof (config) === 'string') ? [config] : config;

        var showCallback, hideCallback;
        if (DefaultCallbacks.hasOwnProperty(callbackType)) {
            showCallback = DefaultCallbacks[callbackType].show.apply(null, callbackParams);
            hideCallback = DefaultCallbacks[callbackType].hide.apply(null, callbackParams);
        } else {
            showCallback = NOOP;
            hideCallback = NOOP;
        }
        return {
            show: showCallback,
            hide: hideCallback
        }
    };

    var ShowChildMethods = {
        showChild(key, reset) {
            var child = this.sizerChildren[key];
            if (child) {
                this.emit('showchild', child, key, this, reset);
                this.resetChildState(child);
            }
            return this;
        },

        hideChild(key, reset) {
            var child = this.sizerChildren[key];
            if (child) {
                this.emit('hidechild', child, key, this, reset);
                this.resetChildState(child);
            }
            return this;
        },

        swapChild(key, reset) {
            if (this.currentChildKey === key) ; else if ((this.currentChildKey === 'panel') || (key === 'panel')) {
                this.previousChildKey = this.currentChildKey;
                this.currentChildKey = key;
                this.hideChild(this.previousChildKey, reset);
                this.showChild(this.currentChildKey, reset);
            } else { // Swap from current side to another side
                this.swapChild('panel', reset);
                this.swapChild(key, reset);
            }
            return this;
        },

        showPanel(reset) {
            this.swapChild('panel', reset);
            return this;
        },

        showLeftSide() {
            this.swapChild('leftSide');
            return this;
        },

        showRightSide() {
            this.swapChild('rightSide');
            return this;
        },

        showTopSide() {
            this.swapChild('topSide');
            return this;
        },

        showBottomSide() {
            this.swapChild('bottomSide');
            return this;
        },

        hideLeftSide() {
            if (this.currentChildKey == 'leftSide') {
                this.showPanel();
            }
            return this;
        },

        hideRightSide() {
            if (this.currentChildKey == 'rightSide') {
                this.showPanel();
            }
            return this;
        },

        hideTopSide() {
            if (this.currentChildKey == 'topSide') {
                this.showPanel();
            }
            return this;
        },

        hideBottomSide() {
            if (this.currentChildKey == 'bottomSide') {
                this.showPanel();
            }
            return this;
        },

        toggleLeftSide() {
            var key = (this.currentChildKey !== 'panel') ? 'panel' : 'leftSide';
            this.swapChild(key);
            return this;
        },

        toggleRightSide() {
            var key = (this.currentChildKey !== 'panel') ? 'panel' : 'rightSide';
            this.swapChild(key);
            return this;
        },

        toggleTopSide() {
            var key = (this.currentChildKey !== 'panel') ? 'panel' : 'topSide';
            this.swapChild(key);
            return this;
        },

        toggleBottomSide() {
            var key = (this.currentChildKey !== 'panel') ? 'panel' : 'bottomSide';
            this.swapChild(key);
            return this;
        }
    };

    const ContainerSetChildVisible = ContainerLite.prototype.setChildVisible;

    var Visible = {
        setChildVisible(child, visible) {
            var key;
            if (typeof (child) === 'string') {
                var key = child;
                child = this.sizerChildren[key];
            } else {
                key = IndexOf(this.sizerChildren, child);
            }
            if (visible === undefined) {
                visible = (this.currentChildKey === key) ? true : false;
            }
            ContainerSetChildVisible.call(this, child, visible);
            return this;
        }
    };

    var Fade = {
        fadeChild(child, duration, alpha) {
            var key;
            if (typeof (child) === 'string') {
                key = child;
                child = this.sizerChildren[key];
            } else {
                key = IndexOf(this.sizerChildren, child);
            }
            if (duration === undefined) {
                duration = 500;
            }
            if (alpha === undefined) {
                alpha = (this.currentChildKey === key) ? 1 : 0;
            }

            child.fadeIn(duration, { start: child.alpha, end: alpha });
            return this;
        },

        fadeChildPromise(child, duration, alpha) {
            if (typeof (child) === 'string') {
                child = this.sizerChildren[key];
            }
            this.fadeChild(child, duration, alpha);

            if (child._fade) {
                return WaitComplete(child._fade);
            } else {
                return Promise.resolve();
            }
        }
    };

    var Move = {
        moveChild(child, duration, ease, distance) {
            var key;
            if (typeof (child) === 'string') {
                key = child;
                child = this.sizerChildren[key];
            } else {
                key = IndexOf(this.sizerChildren, child);
            }

            if (duration === undefined) {
                duration = 500;
            }

            var isShownChild = (this.currentChildKey === key);

            if (distance === undefined) {
                switch (key) {
                    case 'leftSide':
                    case 'rightSide':
                        distance = GetDisplayWidth(child);
                        break;
                    case 'topSide':
                    case 'bottomSide':
                        distance = GetDisplayHeight(child);
                        break;
                    default: // 'panel'
                        if (isShownChild) { // Show panel
                            switch (this.previousChildKey) {
                                case 'leftSide':
                                case 'rightSide':
                                    distance = GetDisplayWidth(this.sizerChildren[this.previousChildKey]);
                                    break;
                                case 'topSide':
                                case 'bottomSide':
                                    distance = GetDisplayHeight(this.sizerChildren[this.previousChildKey]);
                                    break;
                                default:
                                    distance = 0;
                                    break;
                            }
                        } else { // Hide panel
                            switch (this.currentChildKey) {
                                case 'leftSide':
                                case 'rightSide':
                                    distance = GetDisplayWidth(this.sizerChildren[this.currentChildKey]);
                                    break;
                                case 'topSide':
                                case 'bottomSide':
                                    distance = GetDisplayHeight(this.sizerChildren[this.currentChildKey]);
                                    break;
                                default:
                                    distance = 0;
                                    break;
                            }
                        }
                        break;
                }
            }

            var moveLeft, moveRight, moveUp, moveDown;
            if (isShownChild) {
                switch (key) {
                    case 'panel':
                        switch (this.previousChildKey) {
                            case 'leftSide':
                                moveLeft = true;
                                break;
                            case 'rightSide':
                                moveRight = true;
                                break;
                            case 'topSide':
                                moveUp = true;
                                break;
                            case 'bottomSide':
                                moveDown = true;
                                break;
                        }
                        break;
                    case 'leftSide':
                        moveRight = true;
                        break;
                    case 'rightSide':
                        moveLeft = true;
                        break;
                    case 'topSide':
                        moveDown = true;
                        break;
                    case 'bottomSide':
                        moveUp = true;
                        break;
                }
            } else { // Hide
                switch (key) {
                    case 'panel':
                        switch (this.currentChildKey) {
                            case 'leftSide':
                                moveRight = true;
                                break;
                            case 'rightSide':
                                moveLeft = true;
                                break;
                            case 'topSide':
                                moveDown = true;
                                break;
                            case 'bottomSide':
                                moveUp = true;
                                break;
                        }
                        break;
                    case 'leftSide':
                        moveLeft = true;
                        break;
                    case 'rightSide':
                        moveRight = true;
                        break;
                    case 'topSide':
                        moveUp = true;
                        break;
                    case 'bottomSide':
                        moveDown = true;
                        break;
                }
            }

            if (moveLeft) {
                child.moveTo(duration, `-=${distance}`, undefined, ease);
            } else if (moveRight) {
                child.moveTo(duration, `+=${distance}`, undefined, ease);
            } else if (moveUp) {
                child.moveTo(duration, undefined, `-=${distance}`, ease);
            } else if (moveDown) {
                child.moveTo(duration, undefined, `+=${distance}`, ease);
            } else {
                child.moveTo(0);
            }
            return this;
        },

        moveChildPromise(child, duration, ease, distance) {
            if (typeof (child) === 'string') {
                child = this.sizerChildren[key];
            }
            this.moveChild(child, duration, ease, distance);

            if (child._easeMove) {
                return WaitComplete(child._easeMove);
            } else {
                return Promise.resolve();
            }
        }
    };

    var methods$2 = {};

    Object.assign(
        methods$2,
        Visible,
        Fade,
        Move
    );

    const GetValue$v = Phaser.Utils.Objects.GetValue;

    class Sides extends OverlapSizer {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexSides';
            this.childrenMap = this.sizerChildren;
            this.previousChildKey = undefined;
            this.currentChildKey = undefined;

            // Callbacks
            var showChildCallback = GetValue$v(config, 'showChildCallback', undefined);
            if (showChildCallback) { // Has showChildCallback, and hideChildCallback
                if (IsFunction(showChildCallback)) { // Custom callbacks
                    var showChildCallbackScope = GetValue$v(config, 'showChildCallbackScope', undefined);
                    this.on('showchild', showChildCallback, showChildCallbackScope);

                    var hideChildCallback = GetValue$v(config, 'hideChildCallback', undefined);
                    var hideChildCallbackScope = GetValue$v(config, 'hideChildCallbackScope', undefined);
                    this.on('hidechild', hideChildCallback, hideChildCallbackScope);
                } else { // Default callbacks
                    var defaultCallbacks = GetDefaultCallbacks(showChildCallback);
                    this.on('showchild', defaultCallbacks.show);
                    this.on('hidechild', defaultCallbacks.hide);
                }
            }

            // Add elements
            var background = GetValue$v(config, 'background', undefined);
            var panel = GetValue$v(config, 'panel', undefined);
            var leftSide = GetValue$v(config, 'leftSide', undefined);
            var rightSide = GetValue$v(config, 'rightSide', undefined);
            var topSide = GetValue$v(config, 'topSide', undefined);
            var bottomSide = GetValue$v(config, 'bottomSide', undefined);

            if (background) {
                this.addBackground(background);
            }
            if (panel) {
                this.add(panel, 'panel', 'center', 0, true);
            }
            if (leftSide) {
                var expand = GetValue$v(config, 'expand.left', true);
                this.add(leftSide, 'leftSide', 'left-top', 0, { height: expand });
            }
            if (rightSide) {
                var expand = GetValue$v(config, 'expand.right', true);
                this.add(rightSide, 'rightSide', 'right-top', 0, { height: expand });
            }
            if (topSide) {
                var expand = GetValue$v(config, 'expand.top', true);
                this.add(topSide, 'topSide', 'left-top', 0, { width: expand });
            }
            if (bottomSide) {
                var expand = GetValue$v(config, 'expand.bottom', true);
                this.add(bottomSide, 'bottomSide', 'left-bottom', 0, { width: expand });
            }
        }

        reset() {
            this.previousChildKey = undefined;
            this.currentChildKey = 'panel';
            this.showChild('panel', true);
            this.hideChild('leftSide', true);
            this.hideChild('rightSide', true);
            this.hideChild('topSide', true);
            this.hideChild('bottomSide', true);
            return this;
        }
    }

    Object.assign(
        Sides.prototype,
        ShowChildMethods,
        methods$2
    );

    ObjectFactory.register('sides', function (config) {
        var gameObject = new Sides(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Sides', Sides);

    var RegisterInputHandler = function (config) {
        var isValidInputHandler = true;

        if (!config.hasOwnProperty('accept')) {
            isValidInputHandler = false;
            console.error(`[Tweaker] Can't register inputHandler '${config.name}', missing 'accept' callback.`);
        }
        if (!config.hasOwnProperty('build')) {
            isValidInputHandler = false;
            console.error(`[Tweaker] Can't register inputHandler '${config.name}', missing 'build' callback.`);
        }

        if (isValidInputHandler) {
            this.inputHandlers.unshift(config);
        }

        return this;
    };

    const GetFirst = Phaser.Utils.Array.GetFirst;
    const Remove = Phaser.Utils.Array.Remove;

    var RemoveInputHandler = function (name) {
        var handler = GetFirst(this.inputHandlers, 'name', name);
        if (handler) {
            Remove(this.inputHandlers, handler);
        }

        return this;
    };

    class Title extends Label {
        constructor(scene, config) {
            config = BuildLabelConfig(scene, config);
            super(scene, config);
            this.type = 'rexTweaker.Title';
        }

        setTitle(config) {
            config = (config) ? DeepClone(config) : {};

            if (config.hasOwnProperty('text')) ; else if (config.hasOwnProperty('title')) {
                config.text = config.title;
            } else {
                config.text = '';
            }

            this.resetDisplayContent(config);

            return this;
        }
    }

    class FolderTitle extends Title {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            super(scene, config);
            this.type = 'rexTweaker.FolderTitle';

            var expandedIcon = new Triangle(scene, config.expandedIcon);
            scene.add.existing(expandedIcon);

            this
                .addSpace()
                .add(
                    expandedIcon,
                    { proportion: 0, expand: false, padding: 1, fitRatio: 1 }
                );

            this.addChildrenMap('expandedIcon', expandedIcon);
        }

        setExpandedState(expanded) {
            if (expanded === undefined) {
                expanded = true;
            }

            var direction = (expanded) ? 'down' : 'right';
            var expandedIcon = this.childrenMap.expandedIcon;
            expandedIcon.setDirection(direction);

            return this;
        }

    }

    /**
     * @author       Richard Davey <rich@photonstorm.com>
     * @copyright    2019 Photon Storm Ltd.
     * @license      {@link https://opensource.org/licenses/MIT|MIT License}
     */


    /**
     * Creates a new Object using all values from obj1 and obj2.
     * If a value exists in both obj1 and obj2, the value in obj1 is used.
     * 
     * This is only a shallow copy. Deeply nested objects are not cloned, so be sure to only use this
     * function on shallow objects.
     *
     * @function Phaser.Utils.Objects.Merge
     * @since 3.0.0
     *
     * @param {object} obj1 - The first object.
     * @param {object} obj2 - The second object.
     *
     * @return {object} A new object containing the union of obj1's and obj2's properties.
     */
    var Merge$1 = function (obj1, obj2)
    {
        var clone = Clone$2(obj1);

        for (var key in obj2)
        {
            if (!clone.hasOwnProperty(key))
            {
                clone[key] = obj2[key];
            }
        }

        return clone;
    };

    var CreateBackground = function (scene, config, style) {
        return CreateBackground$2(scene, Merge$1(config, style));
    };

    var BindingTargetMethods$5 = {
        setBindingTarget(target) {
            var child = this.childrenMap.child;  // tweaker
            child.setBindingTarget(target);
            return this;
        },
    };

    var InputRowTitleWidthMethods$4 = {
        getMaxInputRowTitleWidth() {
            var child = this.childrenMap.child;  // tweaker
            var titleWidth = child.getMaxInputRowTitleWidth();
            return titleWidth + this.getInnerPadding('left');
        },

        setInputRowTitleWidth(width) {
            width -= this.getInnerPadding('left');

            var child = this.childrenMap.child;  // tweaker
            child.setInputRowTitleWidth(width);
            return this;
        }
    };

    class Folder extends Folder$1 {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            config.orientation = 1;

            super(scene, config);
            this.type = 'rexTweaker.Folder';
        }

        setTitle(config) {
            var title = this.childrenMap.title;
            title.setTitle(config);
            return this;
        }

    }

    Object.assign(
        Folder.prototype,
        BindingTargetMethods$5,
        InputRowTitleWidthMethods$4,
    );

    const GetValue$u = Phaser.Utils.Objects.GetValue;

    var CreateFolder = function (parent, config, style) {
        var scene = parent.scene;

        // Create Folder-title
        var titleStyle = GetValue$u(style, 'title') || {};
        var title = new FolderTitle(scene, titleStyle);
        scene.add.existing(title);

        title
            .on('folder.expand', function () {
                title.setExpandedState(true);
            })
            .on('folder.collapse', function () {
                title.setExpandedState(false);
            });

        var tweakerConfig = {
            root: GetValue$u(style, 'root'),
            styles: GetValue$u(style, 'tweaker'),
            space: GetValue$u(style, 'space') || {}
        };
        var child = parent.createTweaker(tweakerConfig);

        var backgroundStyle = GetValue$u(style, 'background');
        var background = CreateBackground(scene, config, backgroundStyle);

        var folder = new Folder(scene, {
            title: title,
            child: child,
            background: background,
            transition: {
                duration: GetValue$u(style, 'transition.duration', 200)
            },
        });
        scene.add.existing(folder);

        return folder;
    };

    const GetValue$t = Phaser.Utils.Objects.GetValue;

    var AddFolder = function (config) {
        if (config === undefined) {
            config = {};
        }

        // Create folder
        var folderStyle = GetValue$t(this.styles, 'folder') || {};
        folderStyle.tweaker = this.styles;
        folderStyle.root = this.root;
        var folder = CreateFolder(this, config, folderStyle);
        delete folderStyle.tweaker;
        delete folderStyle.root;


        // Add folder
        this.add(
            folder,
            { expand: true }
        );

        // Set content
        folder.setTitle(config);

        var expanded = GetValue$t(config, 'expanded', true);
        if (expanded !== undefined) {
            folder.setExpandedState(expanded);
        }

        var childTweaker = folder.childrenMap.child;

        if (config.key) {
            this.root.addChildrenMap(config.key, childTweaker);
        }

        return childTweaker;
    };

    var BindingTargetMethods$4 = {
        setBindingTarget(target) {
            var children = this.childrenMap.pages.children;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].setBindingTarget(target);
            }
            return this;
        },
    };

    var InputRowTitleWidthMethods$3 = {
        getMaxInputRowTitleWidth() {
            var maxTitleWidth = 0;
            var children = this.childrenMap.pages.children;  // tweaker array
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                maxTitleWidth = Math.max(maxTitleWidth, children[i].getMaxInputRowTitleWidth());
            }

            return maxTitleWidth + this.getInnerPadding('left');
        },

        setInputRowTitleWidth(width) {
            width -= this.getInnerPadding('left');

            var children = this.childrenMap.pages.children;  // tweaker array
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].setInputRowTitleWidth(width);
            }
            return this;
        }
    };

    class TabPages extends TabPages$1 {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexTweaker.TabPages';
        }
    }

    Object.assign(
        TabPages.prototype,
        BindingTargetMethods$4,
        InputRowTitleWidthMethods$3,
    );

    const GetValue$s = Phaser.Utils.Objects.GetValue;

    var CreateTab = function (parent, config, style) {
        var scene = parent.scene;

        var tabPages = new TabPages(scene, style);
        scene.add.existing(tabPages);

        var tabConfig = GetValue$s(style, 'tab');
        var tweakerConfig = {
            root: GetValue$s(style, 'root'),
            styles: GetValue$s(style, 'tweaker')
        };
        var pages = GetValue$s(config, 'pages') || [];
        for (var i = 0, cnt = pages.length; i < cnt; i++) {
            var page = pages[i];
            tabPages.addPage({
                key: page.title,
                tab: CreateLabel(scene, tabConfig)
                    .setActiveState(false)
                    .resetDisplayContent({ text: page.title }),
                page: parent.createTweaker(tweakerConfig)
            });
        }

        tabPages
            .on('tab.focus', function (tab, key) {
                tab.setActiveState(true);
            })
            .on('tab.blur', function (tab, key) {
                tab.setActiveState(false);
            });

        return tabPages;
    };

    const GetValue$r = Phaser.Utils.Objects.GetValue;

    var AddTab = function (config) {
        if (config === undefined) {
            config = {};
        }

        // Create tab
        var tabStyle = GetValue$r(this.styles, 'tab') || {};
        tabStyle.tweaker = this.styles;
        tabStyle.root = this.root;
        var tab = CreateTab(this, config, tabStyle);
        delete tabStyle.tweaker;
        delete tabStyle.root;

        // Add tab
        this.add(
            tab,
            { expand: true }
        );

        var pagesConfig = GetValue$r(config, 'pages') || [];
        var pages = [];
        var shownPageIndex = 0;
        for (var i = 0, cnt = pagesConfig.length; i < cnt; i++) {
            var childTweaker = tab.getPage(i);

            var isPageShown = pagesConfig[i].show;
            if (isPageShown) {
                shownPageIndex = i;
            }

            var key = pagesConfig[i].key;
            if (key) {
                this.root.addChildrenMap(key, childTweaker);
            }

            pages.push(childTweaker);
        }

        tab.swapPage(shownPageIndex, 0);

        return pages;
    };

    var BindingTargetMethods$3 = {
        setBindingTarget(target) {
            var children = this.childrenMap.columns;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].setBindingTarget(target);
            }
            return this;
        },
    };

    var InputRowTitleWidthMethods$2 = {
        getMaxInputRowTitleWidth() {
            var maxTitleWidth = 0;
            var children = this.childrenMap.columns;  // tweaker array
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                maxTitleWidth = Math.max(maxTitleWidth, children[i].getMaxInputRowTitleWidth());
            }

            return maxTitleWidth + this.getInnerPadding('left');
        },

        setInputRowTitleWidth(width) {
            width -= this.getInnerPadding('left');

            var children = this.childrenMap.columns;  // tweaker array
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].setInputRowTitleWidth(width);
            }
            return this;
        }
    };

    const GetValue$q = Phaser.Utils.Objects.GetValue;

    class Columns extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            config.orientation = 'y';

            super(scene, config);
            this.type = 'rexTweaker.Columns';

            // Add elements
            var background = GetValue$q(config, 'background', undefined);
            var title = GetValue$q(config, 'title', undefined);

            if (background) {
                this.addBackground(background);
            }

            if (title) {
                this.add(
                    title,
                    {
                        expand: true,
                        space: {
                            bottom: GetValue$q(config, 'space.title', 0)
                        }
                    }
                );
            }

            var columnsSizer = new Sizer(scene, {
                orientation: 'x',
                space: {
                    item: GetValue$q(config, 'space.column', 0)
                }
            });
            scene.add.existing(columnsSizer);

            var columnConfigArray = GetValue$q(config, 'columns', undefined);
            var columnConfig;
            var columnChild;
            for (var i = 0, cnt = columnConfigArray.length; i < cnt; i++) {
                columnConfig = columnConfigArray[i];
                columnChild = columnConfig.child;
                columnsSizer.add(
                    columnConfig.child,
                    {
                        proportion: (columnChild.minWidth === 0) ? 1 : 0,
                        expand: GetValue$q(columnConfig, 'expand', true)
                    }
                );
            }

            this.add(
                columnsSizer,
                { expand: true }
            );

            this.addChildrenMap('title', title);
            this.addChildrenMap('columnsSizer', columnsSizer);
            this.addChildrenMap('columns', columnsSizer.childrenMap.items);
        }

        setTitle(config) {
            var title = this.childrenMap.title;

            if (config.title || config.icon) {
                title.show().setTitle(config);
            } else {
                title.hide();
            }

            return this;
        }

        getColumns() {
            return this.childrenMap.columns;
        }

        getColumn(index) {
            return this.childrenMap.columns[index];
        }
    }

    Object.assign(
        Columns.prototype,
        BindingTargetMethods$3,
        InputRowTitleWidthMethods$2,
    );

    const GetValue$p = Phaser.Utils.Objects.GetValue;

    var CreateColumns = function (parent, config, style) {
        var scene = parent.scene;

        // Create title
        var titleStyle = GetValue$p(style, 'title') || {};
        var title = new Title(scene, titleStyle);
        scene.add.existing(title);

        var tweakerConfig = {
            root: GetValue$p(style, 'root'),
            styles: GetValue$p(style, 'tweaker')
        };

        var backgroundStyle = GetValue$p(style, 'background');
        if (backgroundStyle && !Array.isArray(backgroundStyle)) {
            backgroundStyle = [backgroundStyle];
        }

        var columnConfigArray = GetValue$p(config, 'columns', 2);
        if (typeof (columnConfigArray) === 'number') {
            var columnCount = columnConfigArray;
            columnConfigArray = [];
            for (var i = 0, cnt = columnCount; i < cnt; i++) {
                columnConfigArray.push({});
            }
        }

        for (var i = 0, cnt = columnConfigArray.length; i < cnt; i++) {
            var columnConfig = columnConfigArray[i];

            if (backgroundStyle) {
                tweakerConfig.background = backgroundStyle[i % backgroundStyle.length];
            }

            tweakerConfig.width = GetValue$p(columnConfig, 'width', 0);

            var tweakerChild = parent.createTweaker(tweakerConfig);

            columnConfig.child = tweakerChild;
        }

        var columns = new Columns(scene, {
            title: title,
            columns: columnConfigArray,
            space: GetValue$p(style, 'space'),
        });
        scene.add.existing(columns);

        return columns;
    };

    const GetValue$o = Phaser.Utils.Objects.GetValue;

    var AddColumns = function (config) {
        if (config === undefined) {
            config = {};
        }
        if (typeof (config) === 'number') {
            config = {
                columns: config
            };
        }

        // Create columns
        var columnsStyle = GetValue$o(this.styles, 'columns') || {};
        columnsStyle.tweaker = this.styles;
        columnsStyle.root = this.root;
        var columns = CreateColumns(this, config, columnsStyle);
        delete columnsStyle.tweaker;
        delete columnsStyle.root;

        // Add columns
        this.add(
            columns,
            { expand: true }
        );

        // Set content
        columns.setTitle(config);

        var columnConfigArray = GetValue$o(config, 'columns', undefined);
        if (columnConfigArray && Array.isArray(columnConfigArray)) {
            for (var i = 0, cnt = columnConfigArray.length; i < cnt; i++) {
                var key = columnConfigArray[i].key;
                if (key) {
                    this.root.addChildrenMap(key, columns.getColumn(i));
                }
            }
        }

        return columns.getColumns();
    };

    var BindingTargetMethods$2 = {
        setBindingTarget(target) {
            var children = this.childrenMap.child;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].setBindingTarget(target);
            }
            return this;
        },
    };

    var InputRowTitleWidthMethods$1 = {
        getMaxInputRowTitleWidth() {
            // Ignore Title of InputRows
            return 0;
        },

        setInputRowTitleWidth(width) {
            // Ignore Title of InputRows
            return this;
        }
    };

    const GetValue$n = Phaser.Utils.Objects.GetValue;

    class Wrap extends Sizer {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }
            config.orientation = 'y';

            super(scene, config);
            this.type = 'rexTweaker.Wrap';

            // Add elements
            var background = GetValue$n(config, 'background', undefined);
            var title = GetValue$n(config, 'title', undefined);

            if (background) {
                this.addBackground(background);
            }

            if (title) {
                this.add(
                    title,
                    {
                        expand: true,
                        space: {
                            bottom: GetValue$n(config, 'space.title', 0)
                        }
                    }
                );
            }

            var child = GetValue$n(config, 'child', undefined);
            this.add(
                child,
                { expand: true }
            );

            this.addChildrenMap('title', title);
            this.addChildrenMap('child', child);
        }

        setTitle(config) {
            var title = this.childrenMap.title;

            if (config.title || config.icon) {
                title.show().setTitle(config);
            } else {
                title.hide();
            }

            return this;
        }
    }

    Object.assign(
        Wrap.prototype,
        BindingTargetMethods$2,
        InputRowTitleWidthMethods$1,
    );

    const GetValue$m = Phaser.Utils.Objects.GetValue;

    var CreateWrap = function (parent, config, style) {
        var scene = parent.scene;

        // Create title
        var titleStyle = GetValue$m(style, 'title') || {};
        var title = new Title(scene, titleStyle);
        scene.add.existing(title);

        var itemWidth = GetValue$m(style, 'itemWidth', 0);
        var itemHeight = GetValue$m(style, 'itemHeight', 0);
        var tweakerConfig = {
            root: GetValue$m(style, 'root'),
            styles: GetValue$m(style, 'tweaker'),
            space: GetValue$m(style, 'space'),
            align: GetValue$m(style, 'align', 5),

            wrap: true,
            itemWidth: GetValue$m(config, 'itemWidth', itemWidth),
            itemHeight: GetValue$m(config, 'itemHeight', itemHeight),
        };

        GetValue$m(style, 'background');

        var tweakerChild = parent.createTweaker(tweakerConfig);

        var wrap = new Wrap(scene, {
            title: title,
            child: tweakerChild,
        });
        scene.add.existing(wrap);

        return wrap;
    };

    const GetValue$l = Phaser.Utils.Objects.GetValue;

    var AddWrap = function (config) {
        if (config === undefined) {
            config = {};
        }

        // Create wrap
        var wrapStyle = GetValue$l(this.styles, 'wrap') || {};
        wrapStyle.tweaker = this.styles;
        wrapStyle.root = this.root;
        var wrap = CreateWrap(this, config, wrapStyle);
        delete wrapStyle.tweaker;
        delete wrapStyle.root;

        // Add wrap
        this.add(
            wrap,
            { expand: true }
        );

        // Set content
        wrap.setTitle(config);

        var childTweaker = wrap.childrenMap.child;

        if (config.key) {
            this.root.addChildrenMap(config.key, childTweaker);
        }

        return childTweaker;
    };

    var BindingTargetMethods$1 = {
        setBindingTarget(target) {
            var child = this.childrenMap.panel;  // tweaker
            child.setBindingTarget(target);
            return this;
        },
    };

    var InputRowTitleWidthMethods = {
        getMaxInputRowTitleWidth() {
            var child = this.childrenMap.panel;  // tweaker
            var titleWidth = child.getMaxInputRowTitleWidth();
            return titleWidth + this.getInnerPadding('left');
        },

        setInputRowTitleWidth(width) {
            width -= this.getInnerPadding('left');

            var child = this.childrenMap.panel;  // tweaker
            child.setInputRowTitleWidth(width);
            return this;
        }
    };

    class Scrollable extends ScrollablePanel {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexTweaker.Scrollable';
        }

        setTitle(config) {
            var title = this.childrenMap.header;

            if (config.title || config.icon) {
                title.show().setTitle(config);
            } else {
                title.hide();
            }

            return this;
        }
    }

    Object.assign(
        Scrollable.prototype,
        BindingTargetMethods$1,
        InputRowTitleWidthMethods,
    );

    const GetValue$k = Phaser.Utils.Objects.GetValue;

    var CreateScrollable = function (parent, config, style) {
        var scene = parent.scene;

        // Create Folder-title
        var titleStyle = GetValue$k(style, 'title') || {};
        var title = new Title(scene, titleStyle);
        scene.add.existing(title);

        var tweakerConfig = {
            root: GetValue$k(style, 'root'),
            styles: GetValue$k(style, 'tweaker'),
            space: GetValue$k(style, 'space') || {}
        };
        var child = parent.createTweaker(tweakerConfig);

        var sliderStyle = GetValue$k(style, 'slider');
        if (sliderStyle) {
            sliderStyle = DeepClone(sliderStyle);
            var trackStyle = sliderStyle.track;
            if (trackStyle) {
                sliderStyle.track = CreateBackground(scene, config, trackStyle);
            }
            var thumbStyle = sliderStyle.thumb;
            if (thumbStyle) {
                sliderStyle.thumb = CreateBackground(scene, config, thumbStyle);
            }
        }

        var backgroundStyle = GetValue$k(style, 'background');
        var background = CreateBackground(scene, config, backgroundStyle);

        var scrollable = new Scrollable(scene, {
            scrollMode: 0,

            header: title,

            panel: {
                child: child,
                mask: {
                    padding: 1,
                },
            },

            slider: sliderStyle,

            background: background,

            height: GetValue$k(config, 'height', 0),

            space: GetValue$k(style, 'space', undefined),
        });
        scene.add.existing(scrollable);

        return scrollable;
    };

    const GetValue$j = Phaser.Utils.Objects.GetValue;

    var AddScrollable = function (config) {
        if (config === undefined) {
            config = {};
        }

        // Create scrollable
        var scrollableStyle = GetValue$j(this.styles, 'scrollable') || {};
        scrollableStyle.tweaker = this.styles;
        scrollableStyle.root = this.root;
        var scrollable = CreateScrollable(this, config, scrollableStyle);
        delete scrollableStyle.tweaker;
        delete scrollableStyle.root;


        // Add scrollable
        this.add(
            scrollable,
            {
                proportion: (scrollable.minWidth === 0) ? 1 : 0,
                expand: true
            }
        );

        // Set content
        scrollable.setTitle(config);

        var childTweaker = scrollable.childrenMap.panel;

        if (config.key) {
            this.root.addChildrenMap(config.key, childTweaker);
        }

        return childTweaker;
    };

    const GetValue$i = Phaser.Utils.Objects.GetValue;

    var BindingTargetMethods = {
        setupBinding() {
            var inputField = this.childrenMap.inputField;
            inputField
                // Set text value to object when closing editor
                .on('valuechange', function (value) {
                    if (!this.autoUpdateEnable) {
                        return;
                    }

                    this.setTargetValue(value);
                }, this);

            return this;
        },

        setAutoUpdateEnable(enable) {
            if (enable === undefined) {
                enable = true;
            }
            this.autoUpdateEnable = enable;
            return this;
        },

        setBindingTarget(target, key) {
            this.bindingTarget = target;

            if (key !== undefined) {
                this.setBindingTargetKey(key);
            }

            this.syncTargetValue();

            var inputField = this.childrenMap.inputField;
            if (inputField.onBindTarget) {
                inputField.onBindTarget(target, key);
            }

            return this;
        },

        setBindingTargetKey(key) {
            this.bindTargetKey = key;
            return this;
        },

        setValueCallbacks(config) {
            this.onGetValue = GetValue$i(config, 'onGetValue');
            this.onSetValue = GetValue$i(config, 'onSetValue');
            return this;
        },

        getTargetValue() {
            if (!this.bindingTarget) {
                return undefined;
            }

            if (this.bindTargetKey != null) {
                return this.bindingTarget[this.bindTargetKey];
            }

            if (this.onGetValue) {
                return this.onGetValue(this.bindingTarget);
            }

            return undefined;
        },

        setTargetValue(value) {
            if (!this.bindingTarget) {
                return this;
            }

            if (this.bindTargetKey != null) {
                this.bindingTarget[this.bindTargetKey] = value;
                return this;
            }

            if (this.onSetValue) {
                this.onSetValue(this.bindingTarget, value);
            }
            return this;
        },

        syncTargetValue() {
            if (!this.bindingTarget) {
                return this;
            }

            var inputField = this.childrenMap.inputField;
            if (inputField.syncValue) {
                inputField.syncValue(this.getTargetValue());
            }

            return this;
        },
    };

    var MonitorTargetMethods = {
        startMonitorTarget() {
            if (this.isMonitoring) {
                return this;
            }

            this.isMonitoring = true;
            this.scene.events.on('postupdate', this.onMonitorTarget, this);
            return this;
        },

        stopMonitorTarget() {
            if (!this.isMonitoring) {
                return this;
            }

            this.isMonitoring = false;
            this.scene.events.off('postupdate', this.onMonitorTarget, this);
            return this;
        },

        onMonitorTarget() {
            if (!this.bindingTarget) {
                return;
            }

            var newValue = this.getTargetValue();
            var inputField = this.childrenMap.inputField;
            if (inputField.value === newValue) {
                return;
            }
            // Sync new value
            inputField.syncValue(newValue);

        },
    };

    var MinTitleWidthMethods = {
        getMinTitleWidth() {
            var title = this.childrenMap.title;
            if (!title || (title.orientation !== 0)) {
                // Don't count vertical input row
                return 0;
            }

            var padding = title.rexSizer.padding;
            var titleWidth = this.getChildWidth(this.childrenMap.title) + ((padding.left + padding.right) * title.scaleX);
            return titleWidth + this.getInnerPadding('left');
        },

        setMinTitleWidth(width) {
            var title = this.childrenMap.title;
            if (!title || (title.orientation !== 0)) {
                // Don't set vertical input row
                return this;
            }

            var padding = title.rexSizer.padding;
            width -= (padding.left + padding.right) * title.scaleX;

            title.minWidth = width;
            return this;
        }
    };

    const GetValue$h = Phaser.Utils.Objects.GetValue;

    class InputRow extends Sizer {
        constructor(scene, config) {
            super(scene, config);
            this.type = 'rexTweaker.InputRow';

            this.bindingTarget = undefined;
            this.bindTargetKey = undefined;
            this.autoUpdateEnable = true;

            var inputTitle = config.inputTitle;
            var inputField = config.inputField;
            var background = config.background;

            var proportion = GetValue$h(config, 'proportion.title', 0);
            var titleSpace = GetValue$h(config, 'space.title', 0);
            var padding;
            if (this.orientation === 0) {
                padding = { right: titleSpace };
            } else {
                padding = { bottom: titleSpace };
            }
            this.add(
                inputTitle,
                { proportion: proportion, expand: true, padding: padding }
            );

            var defaultProportion = inputField.defaultProportion;
            if (defaultProportion === undefined) {
                defaultProportion = (config.defaultExpandWidth) ? 1 : 0;
            }
            var proportion = GetValue$h(config, 'proportion.inputField', defaultProportion);
            this.add(
                inputField,
                { proportion: proportion, expand: true, }
            );

            if (background) {
                this.addBackground(background);
            }

            this.addChildrenMap('title', inputTitle);
            this.addChildrenMap('inputField', inputField);
            this.addChildrenMap('background', background);

            this.setupBinding();

        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            this.stopMonitorTarget();

            super.destroy(fromScene);
        }

        setTitle(config) {
            var title = this.childrenMap.title;
            title.setTitle(config);
            return this;
        }

        preLayout() {
            var title = this.childrenMap.title;
            if (title) {
                title.minWidth = 0;
            }

            super.preLayout();
        }
    }

    Object.assign(
        InputRow.prototype,
        BindingTargetMethods,
        MonitorTargetMethods,
        MinTitleWidthMethods,
    );

    var CreateTitleLabel = function (scene, config, style) {
        var gameObject = new Title(scene, style);
        scene.add.existing(gameObject);

        return gameObject;
    };

    var GenerateInputFieldClass = function (BaseClass) {
        if (BaseClass === undefined) {
            BaseClass = Sizer;
        }

        class InputFiled extends BaseClass {
            get bindingTarget() {
                var inputRow = this.getParentSizer();
                return inputRow.bindingTarget;
            }

            get bindingKey() {
                var inputRow = this.getParentSizer();
                return inputRow.bindTargetKey;
            }

            get value() {
                return this._value;
            }

            get root() {
                var inputRow = this.getParentSizer();
                var tweaker = inputRow.getParentSizer();
                return tweaker.root;
            }

            onBindTarget(target, key) {
                if (this.onBindTargetCallback) {
                    this.onBindTargetCallback(this, target, key);
                }
            }

            validate(newValue) {
                if (this.syncValueFlag || !this.validateCallback) {
                    return true;
                }
                return this.validateCallback(newValue, this._value, this.bindingTarget, this.bindingKey);
            }

            getFotmatText(value) {
                if (this.textFormatCallback) {
                    value = this.textFormatCallback(value);
                } else {
                    value = value.toString();
                }
                return value;
            }

            set value(value) {
                if (this._value === value) {
                    return;
                }
                if (!this.validate(value)) {
                    value = this._value;  // Back to previous value
                }

                if (this.filterValueCallback) {
                    value = this.filterValueCallback(this, value);
                }

                if (this.displayValueCallback) {
                    this.displayValueCallback(this, value);
                }

                if (this._value === value) {
                    return;
                }

                var oldValue = this._value;
                this._value = value;

                if (!this.syncValueFlag) {
                    var bindingTarget = this.bindingTarget;
                    var bindingKey = this.bindingKey;
                    this.emit('valuechange', value, oldValue, bindingTarget, bindingKey);
                    this.root.emit('valuechange', value, oldValue, bindingTarget, bindingKey);
                }
            }

            getValue() {
                return this.value;
            }

            setValue(value) {
                this.value = value;
                return this;
            }

            /* 
            Internal method invoked when 
            - inputRow.setBindingTarget(target), or 
            - inputRow.syncTargetValue()
            */
            syncValue(value) {
                this.syncValueFlag = true;
                this.value = value;
                this.syncValueFlag = false;

                return this;
            }

            setup(config, setDefaults) {
                if (setDefaults === undefined) {
                    setDefaults = false;
                }

                if (setDefaults || config.hasOwnProperty('format')) {
                    this.setTextFormatCallback(config.format);
                }

                if (setDefaults || config.hasOwnProperty('onValidate')) {
                    this.setValidateCallback(config.onValidate);
                }

                if (this.setupCallback) {
                    this.setupCallback(this, config, setDefaults);
                }

                return this;
            }

            setSetupCallback(callback) {
                this.setupCallback = callback;
                return this;
            }

            setFilterValueCallback(callback) {
                this.filterValueCallback = callback;
                return this;
            }

            setDisplayValueCallback(callback) {
                this.displayValueCallback = callback;
                return this;
            }

            setOnBindTargetCallback(callback) {
                this.onBindTargetCallback = callback;
                return this;
            }

            setTextFormatCallback(callback) {
                this.textFormatCallback = callback;
                return this;
            }

            setValidateCallback(callback) {
                this.validateCallback = callback;
                return this;
            }
        }

        return InputFiled;
    };

    var CreateInputField = function (scene, config, style) {
        var inputField;
        var inputHandlers = this.inputHandlers;
        for (var i = 0, cnt = inputHandlers.length; i < cnt; i++) {
            var handler = inputHandlers[i];
            if (handler.accept(config)) {
                var InputFieldClass = GenerateInputFieldClass(handler.baseClass);
                inputField = new InputFieldClass(scene);
                scene.add.existing(inputField);

                inputField
                    .setSetupCallback(handler.setup)
                    .setFilterValueCallback(handler.filterValue)
                    .setDisplayValueCallback(handler.displayValue)
                    .setOnBindTargetCallback(handler.onBindTarget);

                handler.build(inputField, style);

                break;
            }

        }

        if (inputField) {
            // Setup by config
            inputField.setup(config, true);
        }

        return inputField;
    };

    const GetValue$g = Phaser.Utils.Objects.GetValue;

    var CreateInputRow = function (scene, config, style) {
        // InputField
        var inputField = CreateInputField.call(this, scene, config, style);
        if (!inputField) {
            // Can't create inputField
            return null;
        }

        // Title
        var titleStyle = GetValue$g(style, 'title') || {};
        var inputTitle = CreateTitleLabel(scene, config, titleStyle);

        // Background
        var backgroundStyle = GetValue$g(style, 'background') || {};
        var background = CreateBackground$2(scene, backgroundStyle);

        var inputRow = new InputRow(scene, {
            ...style,
            ...config,  // config can overwrite style

            inputTitle: inputTitle,
            inputField: inputField,
            background: background,
        });
        scene.add.existing(inputRow);

        inputRow.setTitle(config);

        inputRow.setValueCallbacks(config);

        return inputRow;
    };

    var AddInput = function (object, key, config) {
        if (arguments.length === 1) {
            config = object;
            object = config.bindingTarget;
            key = config.bindingKey;
        } else {
            if (config === undefined) {
                config = {};
            }
            config.bindingTarget = object;
            config.bindingKey = key;
        }

        if (!config.title) {
            config.title = key;
        }

        if (config.bindingTarget && config.bindingKey) {
            config.value = config.bindingTarget[config.bindingKey];
        } else {
            config.value = undefined;
        }

        // Create InputRow
        var inputRowStyle = this.styles.inputRow || {};

        if (!this.isWrapMode) {
            inputRowStyle.defaultExpandWidth = (this.styles.orientation === 1);
        } else {
            inputRowStyle.defaultExpandWidth = true;
        }

        var inputSizer = CreateInputRow.call(this, this.scene, config, inputRowStyle);
        if (!inputSizer) {
            // Can't create inputField
            console.error(`[Tweaker] Can't add Input
    title: ${config.title}
    view: ${config.view}
`);

            return this;
        }

        // Add InputRow to Tweaker
        if (!this.isWrapMode) {
            var proportion;
            if (this.orientation === 1) { // y
                proportion = 0;
            } else { // x
                proportion = (this.itemWidth > 0) ? 0 : 1;

                if (inputSizer.minWidth === 0) {
                    inputSizer.setMinWidth(this.itemWidth);
                }
            }

            if (inputSizer.minHeight === 0) {
                inputSizer.setMinHeight(this.itemHeight);
            }

            this.add(
                inputSizer,
                { proportion: proportion, expand: true }
            );

        } else {
            inputSizer.setMinWidth(this.itemWidth);
            inputSizer.setMinHeight(this.itemHeight);
            this.add(inputSizer);

        }


        if (config.onValueChange) {
            var inputField = inputSizer.childrenMap.inputField;
            inputField.on('valuechange', config.onValueChange);
        }

        // Bind target
        inputSizer.setAutoUpdateEnable(config.autoUpdate);
        inputSizer.setBindingTarget(object, key);

        if (config.monitor) {
            inputSizer.startMonitorTarget();
        }

        if (config.key) {
            this.root.addChildrenMap(config.key, inputSizer);
        }

        return this;
    };

    var CreateRoundRectangle = function (scene, config) {
        var gameObject = new RoundRectangle$2(scene, config);
        scene.add.existing(gameObject);

        return gameObject;
    };

    const GetValue$f = Phaser.Utils.Objects.GetValue;

    var CreateButtons$2 = function (scene, config) {
        var wrap = GetValue$f(config, 'wrap', false);
        var ButtonClass = (wrap) ? Buttons : Buttons$1;
        var gameObject = new ButtonClass(scene, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    const GetValue$e = Phaser.Utils.Objects.GetValue;

    var CreateButtons$1 = function (scene, config, style) {
        // Title
        var titleStyle = GetValue$e(style, 'title') || {};
        var title = CreateTitleLabel(scene, config, titleStyle);

        // Buttons
        var buttonsConfig = config.buttons;
        var buttonStyle = GetValue$e(style, 'button') || {};
        var buttons = [];
        for (var i = 0, cnt = buttonsConfig.length; i < cnt; i++) {
            var button = CreateLabel(scene, buttonStyle);
            buttons.push(button);

            var buttonConfig = buttonsConfig[i];
            button.resetDisplayContent(buttonConfig.label);
            button.callback = buttonConfig.callback;
        }

        var buttonsSizer = CreateButtons$2(scene, {
            buttons: buttons,
            expand: true,
            wrap: GetValue$e(config, 'wrap', false)
        });
        buttonsSizer.defaultProportion = 1;

        // Background
        var backgroundStyle = GetValue$e(style, 'background') || {};
        var background = CreateRoundRectangle(scene, backgroundStyle);

        // InputRow
        var inputRow = new InputRow(scene, {
            ...style,

            inputTitle: title,
            inputField: buttonsSizer,
            background: background,
        });
        scene.add.existing(inputRow);

        inputRow.setTitle(config);

        buttonsSizer
            .on('button.click', function (button) {
                button.callback(inputRow.bindingTarget);
            });

        return inputRow;
    };

    const GetValue$d = Phaser.Utils.Objects.GetValue;

    var AddButtons = function (config) {
        if (config === undefined) {
            config = {};
        }

        var scene = this.scene;

        var target = config.bindingTarget;
        delete config.bindingTarget;

        // Create buttons
        var buttonsStyle = GetValue$d(this.styles, 'inputRow') || {};
        var buttons = CreateButtons$1(scene, config, buttonsStyle);

        // Add buttons
        this.add(
            buttons,
            { expand: true }
        );

        // Set binding target
        if (target) {
            buttons.setBindingTarget(target);
        }

        if (config.key) {
            this.root.addChildrenMap(config.key, buttons);
        }

        return this;
    };

    var AddButton = function (config) {
        if (config === undefined) {
            config = {};
        }

        config.buttons = [{
            label: config.label,
            callback: config.callback
        }];
        delete config.label;
        delete config.callback;

        this.addButtons(config);
        return this;
    };

    var CreateSeparator = function (scene, config, style) {
        return CreateBackground$2(scene, Merge$1(config, style));
    };

    const GetValue$c = Phaser.Utils.Objects.GetValue;

    var AddSeparator = function (config) {
        if (config === undefined) {
            config = {};
        }

        var scene = this.scene;

        // Create separator
        var separatorStyle = GetValue$c(this.styles, 'separator');
        var separator = CreateSeparator(scene, config, separatorStyle);

        // Add separator
        this.add(
            separator,
            { expand: true }
        );

        return this;
    };

    var AddRows = function (properties, target, monitor) {
        if (typeof (target) === 'boolean') {
            monitor = target;
            target = undefined;
        }

        if (monitor === undefined) {
            monitor = true;
        }

        AddProperties(this, DeepClone(properties), target, monitor);
        return this;
    };

    var AddProperties = function (tweaker, properties, target, monitor) {
        if (!properties) {
            return;
        }

        for (var i = 0, cnt = properties.length; i < cnt; i++) {
            var property = properties[i];

            if (property.hasOwnProperty('$target')) {
                target = property.$target;
                delete property.$target;
            }

            var type = property.$type;
            delete property.$type;

            switch (type) {
                case 'folder':
                    var folder = tweaker.addFolder(property);
                    AddProperties(folder, property.$properties, target, monitor);
                    break;

                case 'tab':
                    var pages = tweaker.addTab(property);
                    for (var pIdx = 0, pcnt = pages.length; pIdx < pcnt; pIdx++) {
                        AddProperties(pages[pIdx], property.pages[pIdx].$properties, target, monitor);
                    }
                    break;

                case 'columns':
                    var columns = tweaker.addColumns(property);
                    for (var pIdx = 0, pcnt = columns.length; pIdx < pcnt; pIdx++) {
                        AddProperties(columns[pIdx], property.columns[pIdx].$properties, target, monitor);
                    }
                    break;

                case 'scrollable':
                    var scrollable = tweaker.addScrollable(property);
                    AddProperties(scrollable, property.$properties, target, monitor);
                    break;

                case 'separator':
                    tweaker.addSeparator();
                    break;

                case 'button':
                    property.bindingTarget = target;
                    tweaker.addButton(property);
                    break;

                case 'buttons':
                    property.bindingTarget = target;
                    tweaker.addButtons(property);
                    break;

                default:
                    var key = property.$key;
                    delete property.$key;
                    if (key.indexOf('.') === -1) {
                        property.bindingTarget = target;
                        property.bindingKey = key;

                    } else {
                        var keys = key.split('.');

                        property.bindingKey = keys.pop();

                        var bindingTarget = target;
                        for (var k = 0, kcnt = keys.length; k < kcnt; k++) {
                            bindingTarget = bindingTarget[keys[k]];
                            if (!target) {
                                console.warn(`[Monitor] Key path '${key}' is invalid`);
                                continue;
                            }
                        }
                        property.bindingTarget = bindingTarget;

                    }

                    if (!property.hasOwnProperty('monitor')) {
                        property.monitor = monitor;
                    }
                    tweaker.addInput(property);
                    break;
            }

        }
    };

    var SetBindingTarget = function (target) {
        var children = this.sizerChildren;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (!child.setBindingTarget) {
                continue;
            }

            child.setBindingTarget(target);
        }

        return this;
    };

    var GetMaxInputRowTitleWidth = function () {
        var maxTitleWidth = 0;
        var children = this.sizerChildren;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (child.rexSizer.hidden) {
                continue;
            }

            if (child.getMinTitleWidth) {  // InputRow
                maxTitleWidth = Math.max(maxTitleWidth, child.getMinTitleWidth());
            } else if (child.getMaxInputRowTitleWidth) {  // Folder, TabPages
                maxTitleWidth = Math.max(maxTitleWidth, child.getMaxInputRowTitleWidth());
            }
        }

        return maxTitleWidth + this.getInnerPadding('left');
    };

    var SetInputRowTitleWidth = function (width) {
        if (!this.isWrapMode) {
            width -= this.getInnerPadding('left');
        }

        var children = this.sizerChildren;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (child.rexSizer.hidden) {
                continue;
            }

            if (child.setMinTitleWidth) {  // InputRow
                child.setMinTitleWidth(width);
            } else if (child.setInputRowTitleWidth) {
                child.setInputRowTitleWidth(width);
            }
        }
        return this;
    };

    var methods$1 = {
        registerInputHandler: RegisterInputHandler,
        removeInputHandler: RemoveInputHandler,

        addFolder: AddFolder,
        addTab: AddTab,
        addColumns: AddColumns,
        addWrap: AddWrap,
        addScrollable: AddScrollable,
        addInput: AddInput,
        addButtons: AddButtons,
        addButton: AddButton,
        addSeparator: AddSeparator,
        addRows: AddRows,

        setBindingTarget: SetBindingTarget,

        getMaxInputRowTitleWidth: GetMaxInputRowTitleWidth,
        setInputRowTitleWidth: SetInputRowTitleWidth,
    };

    const GetValue$b = Phaser.Utils.Objects.GetValue;

    var GenerateTweakerShellClass = function (config) {
        var isWrapMode = GetValue$b(config, 'wrap', false);
        var BaseClass = (!isWrapMode) ? Sizer : FixWidthSizer;

        class TweakerShell extends BaseClass {
            constructor(scene, config) {
                if (config === undefined) {
                    config = {};
                }

                if (config.orientation === undefined) {
                    config.orientation = (!isWrapMode) ? 1 : 0;
                }

                // Create sizer
                super(scene, config);
                this.type = 'rexTweakerShell';
                this.isWrapMode = isWrapMode;

                if (!config.root) {
                    this.root = this;
                    this.inputHandlers = [];
                } else {
                    this.root = config.root;
                    this.inputHandlers = this.root.inputHandlers;
                }

                this.styles = GetValue$b(config, 'styles') || {};
                this.styles.orientation = this.orientation;

                var itemWidth = GetValue$b(config, 'itemWidth');
                if (itemWidth === undefined) {
                    itemWidth = GetValue$b(this.styles, 'itemWidth', 0);
                }
                this.itemWidth = itemWidth;

                var itemHeight = GetValue$b(config, 'itemHeight');
                if (itemHeight === undefined) {
                    itemHeight = GetValue$b(this.styles, 'itemHeight', 0);
                }
                this.itemHeight = itemHeight;

                if (
                    isWrapMode ||
                    ((this.root === this) && (this.orientation === 1))
                ) {

                    var alignTitle = GetValue$b(config, 'inputRow.alignTitle');
                    if (alignTitle === undefined) {
                        var titleProportion = GetValue$b(this.styles, 'inputRow.proportion.title');
                        alignTitle = (!titleProportion);

                    } else {
                        if (alignTitle) {  // Override title proportion to 0
                            SetValue(this.styles, 'inputRow.proportion.title', 0);
                        }

                    }
                    this.alignInputRowTitleStartFlag = alignTitle;

                } else {
                    this.alignInputRowTitleStartFlag = false;

                }


                var background = CreateBackground(scene, undefined, config.background);
                if (background) {
                    this.addBackground(background);
                }
            }

            preLayout() {
                super.preLayout();

                if (this.alignInputRowTitleStartFlag) {
                    this.setInputRowTitleWidth(this.getMaxInputRowTitleWidth());
                }
            }

            createTweaker(config, addToScene) {
                if (addToScene === undefined) {
                    addToScene = true;
                }

                var TweakerShellClass = GenerateTweakerShellClass(config);
                var gameObject = new TweakerShellClass(this.scene, config);
                if (addToScene) {
                    this.scene.add.existing(gameObject);
                }

                return gameObject;
            }

        }

        Object.assign(
            TweakerShell.prototype,
            methods$1
        );

        return TweakerShell;
    };

    var SetInputTextReadOnly$4 = function (gameObject, enable) {
        if (enable === undefined) {
            enable = true;
        }

        var inputText = gameObject.childrenMap.inputText;
        inputText.setReadOnly(enable);
    };

    var TextInputHandler = {
        name: 'TextInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'string')
            }

            return typeof (config.value) === 'string';
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.TextInput';

            var inputTextConfig = style.inputText;
            var inputText = CreateInputText$1(scene, inputTextConfig);

            gameObject.add(
                inputText,
                { proportion: 1, expand: true, key: 'inputText' }
            );

            inputText.on('close', function () {
                gameObject.setValue(inputText.value);
            });
        },

        // Callback inside `setup()`
        setup(gameObject, config, setDefaults) {
            if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
                SetInputTextReadOnly$4(gameObject, !!config.inputTextReadOnly);
            }
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var inputText = gameObject.childrenMap.inputText;
            inputText.setText(gameObject.getFotmatText(value));
        },

    };

    var CreateInputTextArea = function (scene, config, deepCloneConfig) {
        if (deepCloneConfig === undefined) {
            deepCloneConfig = true;
        }

        if (deepCloneConfig) {
            config = (config) ? DeepClone(config) : {};
        } else if (!config) {
            config = {};
        }

        var inputText = new TextAreaInput(scene, config);
        scene.add.existing(inputText);
        return inputText;
    };

    var SetInputTextReadOnly$3 = function (gameObject, enable) {
        if (enable === undefined) {
            enable = true;
        }

        var inputText = gameObject.childrenMap.inputText;
        inputText.setReadOnly(enable);
    };

    var TextAreaInputHandler = {
        name: 'TextAreaInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'textarea')
            }

            return false;
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            this.type = 'rexTweaker.TextAreaInput';

            var inputTextAreaConfig = style.inputTextArea;
            if (inputTextAreaConfig === undefined) {
                inputTextAreaConfig = {};
            }
            if (!inputTextAreaConfig.hasOwnProperty('text')) {
                inputTextAreaConfig.text = style.inputText;
            }
            if (!inputTextAreaConfig.hasOwnProperty('slider')) {
                inputTextAreaConfig.slider = style.slider;
            }

            var inputText = CreateInputTextArea(scene, inputTextAreaConfig);

            gameObject.add(
                inputText,
                { proportion: 1, expand: true, key: 'inputText' }
            );

            inputText.on('close', function () {
                gameObject.setValue(inputText.value);
            });
        },

        // Callback inside `setup()`
        setup(gameObject, config, setDefaults) {
            if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
                SetInputTextReadOnly$3(gameObject, !!config.inputTextReadOnly);
            }
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var inputText = gameObject.childrenMap.inputText;
            inputText.setText(gameObject.getFotmatText(value));
        },

        // Callback inside `setBindingTarget()`
        onBindTarget(gameObject) {
            var inputText = gameObject.childrenMap.inputText;
            inputText.scrollToTop();
        },

    };

    var SetInputTextReadOnly$2 = function (gameObject, enable) {
        if (enable === undefined) {
            enable = true;
        }
        var inputText = gameObject.childrenMap.inputText;
        inputText.setReadOnly(enable);
    };

    var NumberInputHandler = {
        name: 'NumberInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'number');
            }

            return typeof (config.value) === 'number';
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.NumberInput';

            var inputTextConfig = style.inputNumber || style.inputText;
            var inputText = CreateInputText$1(scene, inputTextConfig)
                .setNumberInput();

            gameObject.add(
                inputText,
                { proportion: 1, expand: true, key: 'inputText' }
            );

            inputText.on('close', function () {
                gameObject.setValue(inputText.value);
            });
        },

        // Callback inside `setup()`
        setup(gameObject, config, setDefaults) {
            if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
                SetInputTextReadOnly$2(gameObject, !!config.inputTextReadOnly);
            }

            gameObject.isFloatType = !config.int;
        },

        // Callback inside `setValue()`
        filterValue(gameObject, value) {
            if (gameObject.isFloatType) {
                return value;
            } else {
                return Math.floor(value);
            }
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var inputText = gameObject.childrenMap.inputText;
            inputText.setText(gameObject.getFotmatText(value));
        },
    };

    var CreateSlider = function (scene, config) {
        var gameObject = new Slider(scene, config);
        scene.add.existing(gameObject);

        return gameObject;
    };

    const GetValue$a = Phaser.Utils.Objects.GetValue;
    const Linear$1 = Phaser.Math.Linear;
    const SnapFloor = Phaser.Math.Snap.Floor;

    var SetRange = function (gameObject, min, max, step) {
        gameObject.minValue = min;
        gameObject.maxValue = max;
        gameObject.step = step;

        var slider = gameObject.childrenMap.slider;
        slider.setGap(step, min, max);
    };

    var SetInputTextReadOnly$1 = function (gameObject, enable) {
        if (enable === undefined) {
            enable = true;
        }

        var inputText = gameObject.childrenMap.inputText;
        inputText.setReadOnly(enable);
    };

    var RangeInputHandler = {
        name: 'RangeInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'range')
            }

            return (typeof (config.value) === 'number') &&
                config.hasOwnProperty('min') &&
                config.hasOwnProperty('max');

        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.RangeInput';

            var sliderConfig = style.slider;
            var trackSizeKey = (gameObject.orientation === 0) ? 'track.height' : 'track.width';
            var trackSize = GetValue$a(sliderConfig, trackSizeKey);
            var slider = CreateSlider(scene, sliderConfig);

            var defaultProportion = (style.defaultExpandWidth) ? 2 : 0;
            var proportion = GetValue$a(style, 'proportion.range.slider', defaultProportion);
            var expand = (trackSize === undefined);
            gameObject.add(
                slider,
                { proportion: proportion, expand: expand, key: 'slider' }
            );

            var inputTextConfig = style.inputNumber || style.inputText;
            var inputText = CreateInputText$1(scene, inputTextConfig)
                .setNumberInput();

            var defaultProportion = (style.defaultExpandWidth) ? 1 : 0;
            var proportion = GetValue$a(style, 'proportion.range.inputText', defaultProportion);
            gameObject.add(
                inputText,
                { proportion: proportion, expand: true, key: 'inputText' }
            );

            inputText.on('close', function () {
                gameObject.setValue(inputText.value);
            });

            slider.on('valuechange', function () {
                var value = Linear$1(gameObject.minValue, gameObject.maxValue, slider.value);
                if (gameObject.step) {
                    value = SnapFloor(value, gameObject.step, gameObject.minValue);
                }
                gameObject.setValue(value);
            });
        },

        // Callback inside `setup()`
        setup(gameObject, config, setDefaults) {
            if (setDefaults || config.hasOwnProperty('max')) {
                SetRange(gameObject, config.min, config.max, config.step);
            }

            if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
                SetInputTextReadOnly$1(gameObject, !!config.inputTextReadOnly);
            }
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var slider = gameObject.childrenMap.slider;
            slider.setValue(value, gameObject.minValue, gameObject.maxValue);

            var inputText = gameObject.childrenMap.inputText;
            inputText.setText('').setText(gameObject.getFotmatText(value));

        },
    };

    var CreateButtons = function (scene, config) {
        var gameObject = new Buttons$1(scene, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    const GetValue$9 = Phaser.Utils.Objects.GetValue;

    var SetInputTextReadOnly = function (gameObject, enable) {
        if (enable === undefined) {
            enable = true;
        }

        var inputText = gameObject.childrenMap.inputText;
        inputText.setReadOnly(enable);
    };

    var IncDecInputHandler = {
        name: 'RangeInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'incdec')
            }

            return false;
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.IncDecInput';

            /*
            inputRow <-- buttons
            
            - incButton, inputText, decButton
            - inputText, incButton, decButton
            */

            var incDecConfig = GetValue$9(style, 'incDec') || {};
            var buttonConfigBase = { text: null, action: null };

            // buttons
            var buttons = CreateButtons(scene, {
                expand: false
            });
            var proportion = (style.defaultExpandWidth) ? 1 : 0;
            gameObject.add(
                buttons,
                { proportion: proportion, expand: true }
            );

            // inputText
            var inputTextConfig = style.inputNumber || style.inputText;
            var inputText = CreateInputText$1(scene, inputTextConfig)
                .setNumberInput();

            inputText.on('close', function () {
                gameObject.setValue(inputText.value);
            });

            // incButton
            var incButtonConfig = Object.assign(DeepClone(buttonConfigBase), (incDecConfig.incButton || {}));
            var incButton = CreateLabel(scene, incButtonConfig);

            // decButton
            var decButtonConfig = Object.assign(DeepClone(buttonConfigBase), (incDecConfig.decButton || {}));
            var decButton = CreateLabel(scene, decButtonConfig);

            // inputTextIndex
            buttons.addButton(incButton);
            buttons.addButton(decButton);

            var inputTextIndex = incDecConfig.inputTextIndex || 0;
            buttons.insert(
                inputTextIndex, inputText,
                { proportion: 1, expand: true }
            );

            gameObject.step = 1;
            gameObject.minValue = undefined;
            gameObject.maxValue = undefined;
            buttons.on('button.click', function (button, index, pointer, event) {
                var value = gameObject.value;
                if (index === 0) { // inc
                    value += gameObject.step;
                } else { // dec
                    value -= gameObject.step;
                }
                if ((gameObject.maxValue !== undefined) && (value > gameObject.maxValue)) {
                    value = gameObject.maxValue;
                }
                if ((gameObject.minValue !== undefined) && (value < gameObject.minValue)) {
                    value = gameObject.minValue;
                }
                gameObject.setValue(value);
            });

            gameObject.addChildrenMap('incButton', incButton);
            gameObject.addChildrenMap('decButton', decButton);
            gameObject.addChildrenMap('inputText', inputText);
        },

        // Callback inside `setup()`
        setup(gameObject, config, setDefaults) {
            if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
                SetInputTextReadOnly(gameObject, !!config.inputTextReadOnly);
            }

            if (setDefaults || config.hasOwnProperty('step')) {
                gameObject.step = (config.hasOwnProperty('step')) ? config.step : 1;
            }
            if (setDefaults || config.hasOwnProperty('min')) {
                gameObject.minValue = config.min;
            }
            if (setDefaults || config.hasOwnProperty('max')) {
                gameObject.maxValue = config.max;
            }
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var inputText = gameObject.childrenMap.inputText;
            inputText.setText('').setText(gameObject.getFotmatText(value));

        },
    };

    var CreateColorInput = function (scene, config, deepCloneConfig) {
        if (deepCloneConfig === undefined) {
            deepCloneConfig = true;
        }

        if (deepCloneConfig) {
            config = (config) ? DeepClone(config) : {};
        } else if (!config) {
            config = {};
        }


        var inputText = new ColorInput(scene, config);
        scene.add.existing(inputText);
        return inputText;
    };

    var ColorInputHandler = {
        name: 'ColorInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'color')
            }
            return false;
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.ColorInput';

            var colorInputConfig = style.colorInput;
            if (colorInputConfig === undefined) {
                colorInputConfig = {};
            }
            if (!colorInputConfig.hasOwnProperty('inputText')) {
                colorInputConfig.inputText = style.inputText;
            }
            var colorInput = CreateColorInput(scene, colorInputConfig);

            gameObject.add(
                colorInput,
                { proportion: 1, expand: true, key: 'colorInput' }
            );

            colorInput.on('valuechange', function (value) {
                gameObject.setValue(value);
            });

        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var colorInput = gameObject.childrenMap.colorInput;
            colorInput.setValue(value);
        },
    };

    var CreateCheckbox = function (scene, config) {
        var gameObject = new Checkbox(scene, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    var CheckboxInputHandler = {
        name: 'CheckboxInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'boolean')
            }

            return typeof (config.value) === 'boolean';
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.CheckboxInput';

            var checkboxConfig = style.checkbox;
            var checkbox = CreateCheckbox(scene, checkboxConfig);

            var size = checkboxConfig.size;
            if (size !== undefined) {
                checkbox.setSize(size, size);
            }

            var fitRatio = (size !== undefined) ? 0 : 1;
            gameObject.add(
                checkbox,
                { proportion: 0, expand: false, fitRatio: fitRatio, key: 'checkbox' }
            );

            checkbox.on('valuechange', function (value) {
                gameObject.setValue(value);
            });
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var checkbox = gameObject.childrenMap.checkbox;
            checkbox.setValue(value);
        }
    };

    var CreateToggleSwitch = function (scene, config) {
        var gameObject = new ToggleSwitch(scene, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    var ToggleSwitchInputHandler = {
        name: 'ToggleSwitchInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'toggleSwitch')
            }

            return false;
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.ToggleSwitchInput';

            var toggleSwitchConfig = style.toggleSwitch;
            var toggleSwitch = CreateToggleSwitch(scene, toggleSwitchConfig);

            var size = toggleSwitchConfig.size;
            if (size !== undefined) {
                toggleSwitch.setSize(size, size);
            }

            var fitRatio = (size !== undefined) ? 0 : 1;

            gameObject
                .addSpace()
                .add(
                    toggleSwitch,
                    { proportion: 0, expand: false, fitRatio: fitRatio, key: 'toggleSwitch' }
                );

            toggleSwitch.on('valuechange', function (value) {
                gameObject.setValue(value);
            });
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var toggleSwitch = gameObject.childrenMap.toggleSwitch;
            toggleSwitch.setValue(value);
        },
    };

    var CreateDropDownList = function (scene, config) {
        config = BuildListConfig(scene, config);
        var gameObject = new DropDownList(scene, config);
        scene.add.existing(gameObject);
        return gameObject;
    };

    var GetOptionIndex = function (options, value) {
        for (var i = 0, cnt = options.length; i < cnt; i++) {
            var option = options[i];
            if (option.value === value) {
                return i;
            }
        }
        return undefined;
    };

    var GetOption = function (options, value) {
        var index = GetOptionIndex(options, value);
        if (index == null) {
            return undefined;
        }

        return options[index];
    };

    var SetOptions$1 = function (gameObject, options) {
        var list = gameObject.childrenMap.list;
        list.setOptions(options);
    };

    var ListInputHandler = {
        name: 'ListInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'list')
            }

            return (config.hasOwnProperty('options'));
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.ListInput';

            var list = CreateDropDownList(scene, style.list);

            gameObject.add(
                list,
                { proportion: 1, expand: true, key: 'list' }
            );

            list.on('button.click', function (dropDownList, listPanel, button, index, pointer, event) {
                gameObject.setValue(button.value);
            });
        },

        // Callback inside `setup()`
        setup(gameObject, config, setDefaults) {
            if (setDefaults || config.hasOwnProperty('options')) {
                SetOptions$1(gameObject, config.options);
            }
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var list = gameObject.childrenMap.list;
            var option = GetOption(list.options, value);
            list
                .resetDisplayContent(option)
                .setMinSize(list.width, list.height)
                .layout()
                .setMinSize(0, 0);

        },
    };

    var SetButtonsActiveStateByIndex = function (buttons, index) {
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
            var button = buttons[i];
            if (!button) {
                continue;
            }

            button.setActiveState(i === index);
        }
    };

    const GetValue$8 = Phaser.Utils.Objects.GetValue;

    var SetOptions = function (gameObject, options) {
        var list = gameObject.childrenMap.list;
        list.options = options;

        var scene = gameObject.scene;
        var buttonConfig = list.buttonConfig;
        list.clearButtons(true);
        for (var i = 0, cnt = options.length; i < cnt; i++) {
            var option = options[i];
            var button = CreateLabel(scene, buttonConfig)
                .setActiveState(false)
                .resetDisplayContent({ text: option.text });

            list.addButton(button);
        }
    };

    var ButtonsInputHandler = {
        name: 'ButtonsInput',

        accept(config) {
            if (config.hasOwnProperty('view')) {
                return (config.view === 'buttons')
            }

            return false;
        },

        // Callback after `constructor()`
        build(gameObject, style) {
            var scene = gameObject.scene;

            gameObject.type = 'rexTweaker.ButtonsInput';

            // TODO : DeepClone?
            var buttonConfig = (style.button) ? DeepClone(style.button) : {};
            var buttonExpand = GetValue$8(buttonConfig, 'expand', true);
            if (buttonExpand) {
                buttonConfig.align = 'center';
            }
            delete buttonConfig.expand;

            var list = CreateButtons(scene, {
                expand: buttonExpand
            });
            list.buttonConfig = buttonConfig;

            gameObject.add(
                list,
                { proportion: 1, expand: true, key: 'list' }
            );

            list.on('button.click', function (button, index, pointer, event) {
                var option = list.options[index];
                if (!option) {
                    return;  // ??
                }
                gameObject._selectedIndex = index;
                gameObject.setValue(option.value);
                gameObject._selectedIndex = undefined;
            });

        },

        // Callback inside `setup()`
        setup(gameObject, config, setDefaults) {
            if (setDefaults || config.hasOwnProperty('options')) {
                SetOptions(gameObject, config.options);
            }
        },

        // Callback inside `setValue()`
        displayValue(gameObject, value) {
            var list = gameObject.childrenMap.list;
            var index = gameObject._selectedIndex;  // See list's 'button.click' event
            if (index === undefined) {
                index = GetOptionIndex(list.options, value);
            }
            SetButtonsActiveStateByIndex(list.childrenMap.buttons, index);
        },
    };

    // string

    var RegisterDefaultInputHandlers = function () {
        this
            // string
            .registerInputHandler(TextInputHandler)
            .registerInputHandler(TextAreaInputHandler)
            // number
            .registerInputHandler(NumberInputHandler)
            .registerInputHandler(RangeInputHandler)
            .registerInputHandler(IncDecInputHandler)
            .registerInputHandler(ColorInputHandler)
            // boolean
            .registerInputHandler(CheckboxInputHandler)
            .registerInputHandler(ToggleSwitchInputHandler)
            // options
            .registerInputHandler(ListInputHandler)
            .registerInputHandler(ButtonsInputHandler);

    };

    class Tweaker extends GenerateTweakerShellClass() {
        constructor(scene, config) {
            if (config === undefined) {
                config = {};
            }

            if (config.hasOwnProperty('style')) {
                config.styles = config.style;
            }

            if (config.styles === undefined) {
                config.styles = {};  // TODO: Default styles
            }

            config.background = config.styles.background || {};
            config.space = config.styles.space || {};

            // Create sizer
            super(scene, config);
            this.type = 'rexTweaker';

            RegisterDefaultInputHandlers.call(this);
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            super.destroy(fromScene);

            this.inputHandlers = undefined;
        }
    }

    ObjectFactory.register('tweaker', function (config) {
        var gameObject = new Tweaker(this.scene, config);
        this.scene.add.existing(gameObject);
        return gameObject;
    });

    SetValue(window, 'RexPlugins.UI.Tweaker', Tweaker);

    ObjectFactory.register('click', function (gameObject, config) {
        return new Button(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Click', Button);

    ObjectFactory.register('clickOutside', function (gameObject, config) {
        return new ClickOutside(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.ClickOutside', ClickOutside);

    ObjectFactory.register('inTouching', function (gameObject, config) {
        return new InTouching(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.InTouching', InTouching);

    ObjectFactory.register('tap', function (gameObject, config) {
        if (!IsGameObject(gameObject)) {
            config = gameObject;
            gameObject = this.scene;
        }
        return new Tap(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Tap', Tap);

    ObjectFactory.register('press', function (gameObject, config) {
        if (!IsGameObject(gameObject)) {
            config = gameObject;
            gameObject = this.scene;
        }
        return new Press(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Press', Press);

    ObjectFactory.register('swipe', function (gameObject, config) {
        if (!IsGameObject(gameObject)) {
            config = gameObject;
            gameObject = this.scene;
        }
        return new Swipe(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Swipe', Swipe);

    ObjectFactory.register('pan', function (gameObject, config) {
        if (!IsGameObject(gameObject)) {
            config = gameObject;
            gameObject = this.scene;
        }
        return new Pan(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Pan', Pan);

    ObjectFactory.register('drag', function (gameObject, config) {
        return new Drag(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Drag', Drag);

    ObjectFactory.register('pinch', function (config) {
        return new Pinch(this.scene, config);
    });

    SetValue(window, 'RexPlugins.UI.Pinch', Pinch);

    ObjectFactory.register('rotate', function (config) {
        return new Rotate(this.scene, config);
    });

    SetValue(window, 'RexPlugins.UI.Rotate', Rotate);

    const IsPlainObject$3 = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$7 = Phaser.Utils.Objects.GetValue;

    var GetFrameUpdatingCallback = function (key, frame, gameObject) {
        var callback;
        if (key === undefined) {
            key = gameObject.texture.key;
            frame = gameObject.frame.name;
        } else if (IsPlainObject$3(key)) {
            var config = key;
            key = GetValue$7(config, 'key', gameObject.texture.key);
            frame = GetValue$7(config, 'frame', gameObject.frame.name);
        } else if (typeof (key) === 'string') ; else {
            callback = key;
        }

        if (callback === undefined) {
            callback = function (gameObject) {
                gameObject.setTexture(key, frame);
            };
        }
        return callback;
    };

    const GetValue$6 = Phaser.Utils.Objects.GetValue;
    const GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
    const Linear = Phaser.Math.Linear;

    class Flip extends EaseValueTaskBase {
        constructor(gameObject, config) {
            super(gameObject, config);
            // this.parent = gameObject;
            // this.timer

            this.resetFromJSON(config);
            this.boot();
        }

        resetFromJSON(o) {
            super.resetFromJSON(o);
            this.setDuration(GetAdvancedValue(o, 'duration', 500));
            this.setEase(GetValue$6(o, 'ease', 'Sine'));

            this.setOrientation(GetValue$6(o, 'orientation', 0));
            this.setFrontFace(GetValue$6(o, 'front', undefined));
            this.setBackFace(GetValue$6(o, 'back', undefined));
            this.setFace(GetValue$6(o, 'face', 0));
            return this;
        }

        setOrientation(orientation) {
            if (typeof (orientation) === 'string') {
                orientation = ORIENTATIONMODE[orientation];
            }
            this.orientation = orientation;
            return this;
        }

        get face() {
            return this._face;
        }

        set face(face) {
            if (typeof (face) === 'string') {
                face = FACEMODE[face];
            }
            this._face = face;
            if ((face === 0) && this.frontFaceCallback) {
                this.frontFaceCallback(this.parent);
            } else if ((face === 1) && this.backFaceCallback) {
                this.backFaceCallback(this.parent);
            }
        }

        setFace(face) {
            this.face = face;
            return this;
        }

        toggleFace() {
            var newFace = (this.face === 0) ? 1 : 0;
            this.setFace(newFace);
            return this;
        }

        setFrontFace(key, frame) {
            this.frontFaceCallback = GetFrameUpdatingCallback(key, frame, this.parent);
            return this;
        }

        setBackFace(key, frame) {
            this.backFaceCallback = GetFrameUpdatingCallback(key, frame, this.parent);
            return this;
        }

        start() {
            if (this.timer.isRunning) {
                return this;
            }

            var gameObject = this.parent;
            if (this.orientation === 0) {
                this.scale0 = gameObject.scaleX;
            } else {
                this.scale0 = gameObject.scaleY;
            }

            this.timer
                .setDelay(this.delay)
                .setDuration(this.duration / 2)
                .setRepeat(1);  // 2 times

            super.start();
            return this;
        }

        flip(duration) {
            if (this.isRunning) {
                return this;
            }
            if (duration !== undefined) {
                this.setDuration(duration);
            }
            this.start();
            return this;
        }

        updateTarget(gameObject, timer) {
            if (timer.justRestart) {
                this.toggleFace();
            }

            var t = timer.t;
            if (timer.isOddIteration) {  // Yoyo
                t = 1 - t;
            }
            t = this.easeFn(t);

            var value = Linear(this.scale0, 0, t);
            if (this.orientation === 0) {
                gameObject.scaleX = value;
            } else {
                gameObject.scaleY = value;
            }
        }
    }

    const ORIENTATIONMODE = {
        x: 0,
        horizontal: 0,
        y: 1,
        vertical: 1,
    };

    const FACEMODE = {
        front: 0,
        back: 1,
    };

    ObjectFactory.register('flip', function (gameObject, config) {
        return new Flip(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Flip', Flip);

    ObjectFactory.register('shake', function (gameObject, config) {
        return new ShakePosition(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Shake', ShakePosition);

    ObjectFactory.register('touchEventStop', function (gameObject, config) {
        return new TouchEventStop(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.TouchEventStop', TouchEventStop);

    ObjectFactory.register('perspective', function (gameObject, config) {
        return new ContainerPerspective(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Perspective', ContainerPerspective);

    const RotateAround = Phaser.Math.RotateAround;

    var LocalXYToWorldXY = function (gameObject, localX, localY) {
        var ox = gameObject.width / 2;
        var oy = gameObject.height / 2;
        out.x = localX - ox;
        out.y = localY - oy;
        RotateAround(out, 0, 0, gameObject.rotation);
        out.x *= gameObject.scaleX;
        out.y *= gameObject.scaleY;
        out.x += gameObject.x;
        out.y += gameObject.y;

        return out;
    };

    var WorldXYToLocalXY = function (gameObject, worldX, worldY) {
        var ox = gameObject.width / 2;
        var oy = gameObject.height / 2;

        out.x = worldX - gameObject.x;
        out.y = worldY - gameObject.y;
        out.x /= gameObject.scaleX;
        out.y /= gameObject.scaleY;
        RotateAround(out, 0, 0, -gameObject.rotation);
        out.x += ox;
        out.y += oy;

        return out;
    };

    var out = { x: 0, y: 0 };

    class ControlPoint {
        constructor(parent, vertex) {
            this.parent = parent;
            this.vertex = vertex;
            this._localX = undefined;
            this._localY = undefined;
        }

        destroy() {
            this.parent = undefined;
            this.vertex = undefined;
        }

        updateVertexPosition(x, y) {
            var gameObject = this.parent;
            var srcHeight = gameObject.height;
            var vHalfWidth = (gameObject.frame.cutWidth / srcHeight) / 2;
            var vHalfHeight = (gameObject.frame.cutHeight / srcHeight) / 2;

            var vx = (x / srcHeight) - vHalfWidth;
            var vy = (y / srcHeight) - vHalfHeight;

            var vertex = this.vertex;
            vertex.x = vx;
            vertex.y = -vy;
            gameObject.forceUpdate();
            return this;
        }

        get localX() {
            return this._localX;
        }

        set localX(x) {
            this.setLocalXY(x, this._localY);
        }

        get localY() {
            return this._localY;
        }

        set localY(y) {
            this.setLocalXY(this._localX, y);
        }

        get localXOrigin() {
            return this._localXOrigin;
        }

        get localYOrigin() {
            return this._localYOrigin;
        }

        resetLocalXY(x, y) {
            this._localXOrigin = x;
            this._localYOrigin = y;
            this._localX = x;
            this._localY = y;
            return this;
        }

        setLocalXY(x, y, ignoreUpdateVertex) {
            if ((this._localX === x) && (this._localY === y)) {
                return this;
            }

            this._localX = x;
            this._localY = y;

            if (!ignoreUpdateVertex) {
                this.updateVertexPosition(x, y);
            }

            return this;
        }

        setWorldXY(x, y) {
            if ((this._worldX === x) && (this._worldY === y)) {
                return this;
            }

            var localXY = WorldXYToLocalXY(this.parent, x, y);
            this.setLocalXY(localXY.x, localXY.y);

            return this;
        }

        setPosition(x, y) {
            this.setWorldXY(x, y);
            return this;
        }

        getWorldXY() {
            return LocalXYToWorldXY(this.parent, this._localX, this._localY);
        }

        get x() {
            var worldXY = LocalXYToWorldXY(this.parent, this._localX, this._localY);
            return worldXY.x;
        }

        set x(x) {
            this.setWorldXY(x, this.y);
        }

        get y() {
            var worldXY = LocalXYToWorldXY(this.parent, this._localX, this._localY);
            return worldXY.y;
        }

        set y(y) {
            this.setWorldXY(this.x, y);
        }
    }

    const Vertex = Phaser.Geom.Mesh.Vertex;
    const Face = Phaser.Geom.Mesh.Face;

    var InitFaces = function (quad) {
        var isNinePointMode = quad.isNinePointMode;
        var pointCount = (isNinePointMode) ? 9 : 4;

        var vertices = quad.vertices;
        var faces = quad.faces;
        var controlPoints = quad.controlPoints;
        for (var i = 0; i < pointCount; i++) {
            var vertex = new Vertex();
            vertices.push(vertex);
            controlPoints.push(new ControlPoint(quad, vertex));
        }
        var indices;
        if (isNinePointMode) {
            indices = NinePointsIndices;
        } else {
            if (!quad.fourPointsModeRTL) {
                indices = FourPointsIndices;
            } else {
                indices = FourPointsIndicesRTL;
            }
        }

        for (var i = 0, cnt = indices.length; i < cnt; i += 3) {
            var vert1 = vertices[indices[i + 0]];
            var vert2 = vertices[indices[i + 1]];
            var vert3 = vertices[indices[i + 2]];
            faces.push(new Face(vert1, vert2, vert3));
        }

        if (isNinePointMode) {
            quad.topLeft = controlPoints[0];
            quad.topCenter = controlPoints[1];
            quad.topRight = controlPoints[2];
            quad.centerLeft = controlPoints[3];
            quad.center = controlPoints[4];
            quad.centerRight = controlPoints[5];
            quad.bottomLeft = controlPoints[6];
            quad.bottomCenter = controlPoints[7];
            quad.bottomRight = controlPoints[8];
        } else {
            quad.topLeft = controlPoints[0];
            quad.topRight = controlPoints[1];
            quad.bottomLeft = controlPoints[2];
            quad.bottomRight = controlPoints[3];
        }
    };

    /*
    0, 1,
    2, 3,
    */
    const FourPointsIndices = [
        0, 2, 3,
        0, 3, 1
    ];

    const FourPointsIndicesRTL = [
        1, 3, 2,
        1, 2, 0
    ];


    /*
    0, 1, 2,
    3, 4, 5,
    6, 7, 8
    */
    const NinePointsIndices = [
        0, 3, 4,
        0, 4, 1,
        1, 4, 2,
        4, 5, 2,
        3, 6, 4,
        6, 7, 4,
        4, 7, 8,
        4, 8, 5
    ];

    var GetPointPosition = function (quad) {
        var points;
        var top = 0, bottom = quad.height,
            left = 0, right = quad.width;
        if (quad.isNinePointMode) {
            var centerX = (left + right) / 2;
            var centerY = (top + bottom) / 2;
            points = [
                left, top,        // top-left
                centerX, top,     // top-center
                right, top,       // top-right
                left, centerY,    // center-left
                centerX, centerY, // center-center
                right, centerY,   // top-right
                left, bottom,     // center-left
                centerX, bottom,  // bottom-center
                right, bottom     // bottom-right
            ];
        } else {
            points = [
                left, top,        // top-left
                right, top,       // top-right
                left, bottom,     // bottom-left
                right, bottom     // bottom-right
            ];
        }

        return points;
    };

    const IsPlainObject$2 = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$5 = Phaser.Utils.Objects.GetValue;

    let Image$1 = class Image extends MeshBase {
        constructor(scene, x, y, key, frame, config) {
            if (IsPlainObject$2(x)) {
                config = x;
                x = GetValue$5(config, 'x', 0);
                y = GetValue$5(config, 'y', 0);
                key = GetValue$5(config, 'key', null);
                frame = GetValue$5(config, 'frame', null);
            }

            super(scene, x, y, key, frame);
            this.type = 'rexQuadImage';
            this.isNinePointMode = GetValue$5(config, 'ninePointMode', false);
            this.fourPointsModeRTL = GetValue$5(config, 'rtl', false);
            this.controlPoints = [];

            InitFaces(this);
            this.hideCCW = false;
            this.syncSize();
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            super.destroy(fromScene);

            for (var i = 0, cnt = this.controlPoints.length; i < cnt; i++) {
                this.controlPoints[i].destroy();
            }
            this.controlPoints = undefined;
        }

        resetVerts() {
            // Clear faces and vertices        
            this.dirtyCache[9] = -1;

            var points = GetPointPosition(this);

            // Calculate vertex data
            var srcWidth = this.width;
            var srcHeight = this.height;
            var vHalfWidth = (this.frame.cutWidth / srcHeight) / 2;
            var vHalfHeight = (this.frame.cutHeight / srcHeight) / 2;

            var frameU0 = this.frame.u0;
            var frameU1 = this.frame.u1;
            var frameV0 = this.frame.v0;
            var frameV1 = this.frame.v1;
            var frameU = frameU1 - frameU0;
            var frameV = frameV1 - frameV0;

            // Update vertex
            var controlPoints = this.controlPoints;
            for (var i = 0, cnt = points.length; i < cnt; i += 2) {
                var px = points[i + 0];
                var py = points[i + 1];
                var vertexIndex = i / 2;

                var x = (px / srcHeight) - vHalfWidth;
                var y = (py / srcHeight) - vHalfHeight;
                var u = frameU0 + (frameU * (px / srcWidth));
                var v = frameV0 + (frameV * (py / srcHeight));
                this.vertices[vertexIndex]
                    .set(x, -y, 0)
                    .setUVs(u, v);

                controlPoints[vertexIndex].resetLocalXY(px, py);
            }

            return this;
        }

        syncSize() {
            this.setSizeToFrame();  // Reset size
            this.setOrtho(this.width / this.height, 1);
            this.resetVerts();  // Reset verts
            return this;
        }

    };

    Phaser.Utils.Objects.IsPlainObject;
    Phaser.Utils.Objects.GetValue;

    var Skew = function (gameObject, skewX, skewY) {
        if (skewX === undefined) {
            skewX = 0;
        }
        if (skewY === undefined) {
            skewY = 0;
        }

        var width = gameObject.width,
            height = gameObject.height;
        var ox = width * 0.5;
        var oy = height * 0.5;
        var xOffset = Math.tan(skewX) * oy;
        var yOffset = Math.tan(skewY) * ox;
        var controlPoints = gameObject.controlPoints;
        for (var i = 0, cnt = controlPoints.length; i < cnt; i++) {
            var controlPoint = controlPoints[i];
            var x = controlPoint.localXOrigin;
            var y = controlPoint.localYOrigin;
            controlPoint.localX = x + ((y > oy) ? xOffset : -xOffset);
            controlPoint.localY = y + ((x > ox) ? yOffset : -yOffset);
        }
    };

    const IsPlainObject$1 = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$4 = Phaser.Utils.Objects.GetValue;
    const DegToRad = Phaser.Math.DegToRad;
    const RadToDeg = Phaser.Math.RadToDeg;

    class SkewImage extends Image$1 {
        constructor(scene, x, y, key, frame) {
            if (IsPlainObject$1(x)) {
                var config = x;
                x = GetValue$4(config, 'x', 0);
                y = GetValue$4(config, 'y', 0);
                key = GetValue$4(config, 'key', null);
                frame = GetValue$4(config, 'frame', null);
            }

            super(scene, x, y, key, frame);
            this.type = 'rexSkewmage';

            this._skewX = 0;
            this._skewY = 0;
        }

        get skewX() {
            return this._skewX;
        }

        set skewX(value) {
            this._skewX = value;
            Skew(this, this._skewX, this._skewY);
        }

        get skewXDeg() {
            return RadToDeg(this._skewX);
        }

        set skewXDeg(value) {
            this.skewX = DegToRad(value);
        }

        get skewY() {
            return this._skewY;
        }

        set skewY(value) {
            this._skewY = value;
            Skew(this, this._skewX, this._skewY);
        }

        get skewYDeg() {
            return RadToDeg(this._skewY);
        }

        set skewYDeg(value) {
            this.skewY = DegToRad(value);
        }

        setSkewX(skewX) {
            this.skewX = skewX;
            return this;
        }

        setSkewY(skewY) {
            this.skewY = skewY;
            return this;
        }

        setSkew(skewX, skewY) {
            if (skewY === undefined) {
                skewY = skewX;
            }
            this.skewX = skewX;
            this.skewY = skewY;
            return this;
        }

        setSkewXDeg(skewX) {
            this.skewXDeg = skewX;
            return this;
        }

        setSkewYDeg(skewY) {
            this.skewYDeg = skewY;
            return this;
        }

        setSkewDeg(skewX, skewY) {
            if (skewY === undefined) {
                skewY = skewX;
            }
            this.skewXDeg = skewX;
            this.skewYDeg = skewY;
            return this;
        }

    }

    const IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
    const GetValue$3 = Phaser.Utils.Objects.GetValue;

    class SkewRenderTexture extends SkewImage {
        constructor(scene, x, y, width, height) {
            if (IsPlainObject(x)) {
                var config = x;
                x = GetValue$3(config, 'x', 0);
                y = GetValue$3(config, 'y', 0);
                width = GetValue$3(config, 'width', 32);
                height = GetValue$3(config, 'height', 32);
            }

            // dynamic-texture -> quad-image
            var texture = CreateDynamicTexture(scene, width, height);

            super(scene, x, y, texture, null);
            this.type = 'rexSkewRenderTexture';
            this.rt = this.texture;
        }

        destroy(fromScene) {
            //  This Game Object has already been destroyed
            if (!this.scene || this.ignoreDestroy) {
                return;
            }

            super.destroy(fromScene);

            this.rt.destroy();
            this.rt = null;
        }
    }

    class ContainerSkew extends MeshRenderTextureBase(SkewRenderTexture) {
        get skewState() {
            return this.isRunning;
        }
    }

    ObjectFactory.register('skew', function (gameObject, config) {
        return new ContainerSkew(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Skew', ContainerSkew);

    ObjectFactory.register('anchor', function (gameObject, config) {
        return new Anchor(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.Anchor', Anchor);

    ObjectFactory.register('textTyping', function (gameObject, config) {
        return new TextTyping(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.TextTyping', TextTyping);

    ObjectFactory.register('textPage', function (gameObject, config) {
        return new TextPage(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.TextPage', TextPage);

    var LastOpenedEditor = undefined;

    var SetLastOpenedEditor = function (editor) {
        if (editor === LastOpenedEditor) {
            return;
        }

        if (LastOpenedEditor !== undefined) {
            LastOpenedEditor.close();
        }

        LastOpenedEditor = editor;
    };

    var CloseLastOpenEditor = function (editor) {
        if (editor !== LastOpenedEditor) {
            return;
        }

        // Don't call `LastOpenedEditor.close()`
        LastOpenedEditor = undefined;
    };

    const GetValue$2 = Phaser.Utils.Objects.GetValue;
    const Clone = Phaser.Utils.Objects.Clone;

    var CreateInputText = function (text, config) {
        if (config === undefined) {
            config = {};
        }
        config = Clone(config);

        var scene = text.scene;
        var style = text.style;
        var backgroundColor = GetValue$2(config, 'backgroundColor', style.backgroundColor);
        if (backgroundColor === null) {
            backgroundColor = 'transparent';
        }

        config.text = GetValue$2(config, 'text', text.text);
        config.fontFamily = GetValue$2(config, 'fontFamily', style.fontFamily);
        config.fontSize = GetValue$2(config, 'fontSize', style.fontSize);
        config.color = GetValue$2(config, 'color', style.color);
        config.backgroundColor = backgroundColor;
        config.direction = GetValue$2(config, 'rtl', style.rtl) ? 'rtl' : 'ltr';
        config.align = GetValue$2(config, 'align', GetHAlign(style));

        // Built-in text game object with RTL only has 'right' align
        if ((config.direction === 'rtl') && (IsTextGameObject(text))) {
            config.align = 'right';
        }

        var padding = text.padding;
        if (padding.left > 0) {
            config.paddingLeft = `${padding.left}px`;
        }
        if (padding.right > 0) {
            config.paddingRight = `${padding.right}px`;
        }
        // config.paddingTop = 0;
        // config.paddingBottom = 0;
        // var valign = GetVAlign(style);
        // switch (valign) {
        //     case 'top':
        //         break;
        //     case 'bottom':
        //         break;
        // }

        if (style.backgroundCornerRadius) {
            config.borderRadius = GetValue$2(config, 'borderRadius', `${style.backgroundCornerRadius}px`);
        }


        var inputText = new InputText(scene,
            text.x, text.y,
            GetValue$2(config, 'width', text.width),
            GetValue$2(config, 'height', text.height),
            config
        );

        inputText
            // Sync scale
            .setScale(text.scaleX, text.scaleY)
            // Sync origin
            .setOrigin(text.originX, text.originY)
            // Sync scrollFactor
            .setScrollFactor(text.scrollFactorX, text.scrollFactorY);

        var textParentContainer = text.parentContainer;
        if (!textParentContainer) {
            scene.add.existing(inputText);
        } else {
            textParentContainer.add(inputText);
        }

        return inputText;
    };

    var GetHAlign = function (style) {
        if (style.hasOwnProperty('align')) {
            return style.align;
        } else if (style.hasOwnProperty('halign')) {
            return style.halign;
        } else {
            return 'left';
        }
    };

    var NextTick = function (scene, callback, scope) {
        return scene.time.delayedCall(0, callback, [], scope);
    };

    const GetValue$1 = Phaser.Utils.Objects.GetValue;
    const Merge = Phaser.Utils.Objects.Merge;

    var Open = function (config, onCloseCallback) {
        if (config === undefined) {
            config = {};
        }
        config = Merge(config, this.openConfig);

        SetLastOpenedEditor(this);

        if (IsFunction(config)) {
            onCloseCallback = config;
            config = undefined;
        }

        var textType = GetValue$1(config, 'inputType', undefined);
        if (textType === undefined) {
            textType = GetValue$1(config, 'type', 'text');
        }

        if (onCloseCallback === undefined) {
            onCloseCallback = GetValue$1(config, 'onClose', undefined);
        }

        var onCreateInputTextCallback = GetValue$1(config, 'onCreate', undefined);
        var onOpenCallback = GetValue$1(config, 'onOpen', undefined);
        var customOnTextChanged = GetValue$1(config, 'onTextChanged', undefined);

        this.inputText = CreateInputText(this.parent, config);

        if (onCreateInputTextCallback) {
            onCreateInputTextCallback(this.parent, this.inputText);
        }

        this.inputText
            .on('textchange', function (inputText) {
                var text = inputText.text;
                if (customOnTextChanged) { // Custom on-text-changed callback
                    customOnTextChanged(this.parent, text);
                } else { // Default on-text-changed callback
                    this.parent.text = text;
                }
            }, this)
            .setFocus();

        this.parent.setVisible(false); // Set parent text invisible

        // Attach close event
        this.onClose = onCloseCallback;
        if (GetValue$1(config, 'enterClose', (textType !== 'textarea'))) {
            this.scene.input.keyboard.once('keydown-ENTER', this.close, this);
        }
        // Attach pointerdown (outside of input-text) event, at next tick
        this.delayCall = NextTick(this.scene, function () {
            this.scene.input.once('pointerdown', this.close, this);

            // Open editor completly, invoke onOpenCallback
            if (onOpenCallback) {
                onOpenCallback(this.parent, this.inputText);
            }
            this.emit('open', this.parent, this.inputText);

        }, this);

        return this;
    };

    var Close = function () {
        CloseLastOpenEditor(this);

        this.parent.setVisible(true); // Set parent text visible

        if (this.inputText) {
            this.inputText.destroy();
            this.inputText = undefined;
        }

        if (this.delayCall) {
            this.delayCall.remove();
            this.delayCall = undefined;
        }

        // Remove close event
        this.scene.input.keyboard.off('keydown-ENTER', this.close, this);
        this.scene.input.off('pointerdown', this.close, this);

        if (this.onClose) {
            this.onClose(this.parent);
        }
        this.emit('close', this.parent);

        return this;
    };

    var Methods = {
        open: Open,
        close: Close,
    };

    const GetValue = Phaser.Utils.Objects.GetValue;

    class TextEdit extends ComponentBase {
        constructor(gameObject, config) {
            super(gameObject);
            // this.parent = gameObject;

            this.inputText = undefined;
            this.onClose = undefined;
            this.delayCall = undefined;

            this.setOpenConfig(config);

            var clickEnable = GetValue(config, 'clickEnable', true);
            if (clickEnable) {
                gameObject
                    .on('pointerdown', function () {
                        this.open();
                    }, this)
                    .setInteractive();
            }
        }

        shutdown(fromScene) {
            // Already shutdown
            if (this.isShutdown) {
                return;
            }

            this.close();

            super.shutdown(fromScene);
        }

        setOpenConfig(config) {
            if (config === undefined) {
                config = {};
            }
            this.openConfig = config;
            return this;
        }

        get isOpened() {
            return (this.inputText !== undefined);
        }

        get text() {
            return (this.isOpened) ? this.inputText.text : this.parent.text;
        }
    }

    Object.assign(
        TextEdit.prototype,
        Methods,
    );

    var Edit = function (gameObject, config, onCloseCallback) {
        if (!gameObject._edit) {
            gameObject._edit = new TextEdit(gameObject, {
                clickEnable: false
            });
        }
        gameObject._edit.open(config, onCloseCallback);
        return gameObject._edit;
    };

    ObjectFactory.register('textEdit', function (gameObject, config) {
        return new TextEdit(gameObject, config);
    });

    SetValue(window, 'RexPlugins.UI.TextEdit', TextEdit);

    ObjectFactory.register('layerManager', function (config) {
        return new LayerManager(this.scene, config);
    });

    SetValue(window, 'RexPlugins.UI.LayerManager', LayerManager);

    class UIPlugin extends Phaser.Plugins.ScenePlugin {
        constructor(scene, pluginManager) {
            super(scene, pluginManager);

            this.add = new ObjectFactory(scene);
        }

        boot() {
            var eventEmitter = this.scene.events;
            eventEmitter.on('destroy', this.destroy, this);
        }

        destroy() {
            this.add.destroy();
            super.destroy();
        }

        isInTouching(gameObject, pointer, preTest, postTest) {
            if (!gameObject.visible) {
                return false;
            }
            return IsPointerInBounds(gameObject, pointer, preTest, postTest);
        }

        get viewport() {
            return GetViewport(this.scene, this.scene.cameras.main, true);
        }

    }

    var methods = {
        getParentSizer: GetParent$1,
        getTopmostSizer: GetTopmostParent$1,
        removeFromParent: RemoveFromParent,
        hide: Hide,
        show: Show,
        isShown: IsShown,
        confirmAction: ConfirmAction,
        edit: Edit,
        wrapExpandText: WrapExpandText,
        fontSizeExpandText: FontSizeExpandText,
        fontSizeResize: FontSizeFit,  // Backward compatibility
        setFontSizeToFitWidth: FontSizeFit,
        waitEvent: WaitEvent,
        waitComplete: WaitComplete,
        delayPromise: Delay,
        setChildrenInteractive: SetChildrenInteractive$1,
        fadeIn: FadeIn,
        fadeOutDestroy: FadeOutDestroy,
        easeMoveTo: EaseMoveTo,
        easeMoveFrom: EaseMoveFrom,
        modal: Modal$2,
        modalPromise: ModalPromise,
        modalClose: ModalClose,
        requestDrag: RequestDrag,
        openFileChooser: Open$1,
    };

    Object.assign(
        UIPlugin.prototype,
        methods
    );

    return UIPlugin;

}));
