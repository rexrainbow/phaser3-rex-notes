var e,t;e=void 0,t=function(){const e="rexFilterDissolve";class t extends Phaser.Renderer.WebGL.RenderNodes.BaseFilterShader{static FilterName=e;constructor(t){super(e,t,null,"#pragma phaserTemplate(shaderName)\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision highmedp float;\n// Scene buffer\nuniform sampler2D uMainSampler;\nuniform sampler2D uMainSampler2;\n\nuniform int resizeMode;\nuniform float progress;\nuniform float fromRatio;\nuniform float toRatio;\nvarying vec2 outFragCoord;\n// Effect parameters\nuniform float noiseX;\nuniform float noiseY;\nuniform float noiseZ;\nuniform float fromEdgeStart;\nuniform float fromEdgeWidth;\nuniform float toEdgeStart;\nuniform float toEdgeWidth;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nfloat Perlin(vec3 P) {\n    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));\n    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);\n    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);\n    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0); gx1 = fract(gx1);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\n        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\n        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\n        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\n    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\n}\nfloat Perlin(vec2 P) { return Perlin(vec3(P, 0.0)); }\n\n\nvec4 getFromColor (vec2 uv) {\n  return texture2D(uMainSampler, uv);\n}\n\nvec4 getToColor (vec2 uv) {\n  if (resizeMode == 2) {\n    //  cover\n    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, uv.y) - 0.5) * vec2(min(fromRatio / toRatio, 1.0), min((toRatio / fromRatio), 1.0)));\n  } else if (resizeMode == 1) {\n    //  contain\n    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, uv.y) - 0.5) * vec2(max(fromRatio / toRatio, 1.0), max((toRatio / fromRatio), 1.0)));\n  } else {\n    //  stretch\n    return texture2D(uMainSampler2, vec2(uv.x, uv.y));\n  }\n}\n\nvec4 transition (vec2 uv) {    \n  vec4 colorFront = getFromColor(uv);\n  vec4 colorTo = getToColor(uv);\n\n  float noise = (Perlin(vec3(uv.x * noiseX, uv.y * noiseY, noiseZ)) + 1.0) / 2.0\n    * (1.0 - (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth))\n    + (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth) * 0.5;\n  vec4 colorResult = colorFront * smoothstep(progress - (fromEdgeStart + fromEdgeWidth), progress - fromEdgeStart, noise)\n    + colorTo * smoothstep((1.0 - progress) - (toEdgeStart + toEdgeWidth), (1.0 - progress) - toEdgeStart, (1.0 - noise));\n  return colorResult;\n}\n\n#pragma phaserTemplate(fragmentHeader)\n\nvoid main () {\n  vec2 uv = outFragCoord;\n  gl_FragColor = transition(uv);\n}\n")}setupTextures(e,t,r){t[1]=e.toFrame.glTexture}setupUniforms(e,t){const r=this.programManager;r.setUniform("progress",e.progress),r.setUniform("resizeMode",e.resizeMode),r.setUniform("noiseX",e.noiseX),r.setUniform("noiseY",e.noiseY),r.setUniform("noiseZ",e.noiseZ),r.setUniform("fromEdgeStart",e.fromEdgeStart),r.setUniform("fromEdgeWidth",e.fromEdgeWidth),r.setUniform("toEdgeStart",e.toEdgeStart),r.setUniform("toEdgeWidth",e.toEdgeWidth),r.setUniform("fromRatio",t.width/t.height),r.setUniform("toRatio",e.toRatio),r.setUniform("uMainSampler2",1)}}const r=Phaser.Utils.Objects.GetValue,o=Phaser.Math.Clamp;class n extends Phaser.Filters.Controller{static FilterName=e;constructor(t,r){super(t,e),this._progress=0,this.resizeMode=1,this.noiseX=0,this.noiseY=0,this.noiseZ=0,this.fromEdgeStart=.01,this.fromEdgeWidth=.05,this.toEdgeStart=.01,this.toEdgeWidth=.05,this.toFrame=null,this.toRatio=1,this.resetFromJSON(r)}destroy(){this.toFrame=null,super.destroy()}resetFromJSON(e){return this.setProgress(r(e,"progress",0)),this.setTransitionTargetTexture(r(e,"toTexture","__DEFAULT"),r(e,"toFrame",void 0),r(e,"resizeMode",1)),this.setNoise(r(e,"noiseX",void 0),r(e,"noiseY",void 0),r(e,"noiseZ",void 0)),this.setFromEdge(r(e,"fromEdgeStart",.01),r(e,"fromEdgeWidth",.05)),this.setToEdge(r(e,"toEdgeStart",.01),r(e,"toEdgeWidth",.05)),this}get progress(){return this._progress}set progress(e){this._progress=o(e,0,1)}setProgress(e){return this.progress=e,this}setResizeMode(e){return"string"==typeof e&&(e=i[e]),this.resizeMode=e,this}setNoise(e,t,r){return void 0===e&&(e=4+6*Math.random()),void 0===t&&(t=4+6*Math.random()),void 0===r&&(r=10*Math.random()),this.noiseX=e,this.noiseY=t,this.noiseZ=r,this}setFromEdge(e,t){return this.fromEdgeStart=e,this.fromEdgeWidth=t,this}setToEdge(e,t){this.toEdgeStart=e,this.toEdgeWidth=t}setTransitionTargetTexture(e,t,r){void 0===e&&(e="__DEFAULT");var o=this.camera.scene.sys.textures,n=o.getFrame(e,t);return n||(n=o.getFrame("__DEFAULT")),this.toRatio=n.width/n.height,this.toFrame=n,void 0!==r&&(this.resizeMode=r),this}}const i={stretch:0,contain:1,cover:2},s=Phaser.Game;var a=function(e){return e instanceof s};const g=Phaser.Scene;var f=function(e){return e instanceof g},d=function(e,t){var r,o=t.FilterName,n=(r=e,null==r||"object"!=typeof r?null:a(r)?r:a(r.game)?r.game:f(r)?r.sys.game:f(r.scene)?r.scene.sys.game:void 0).renderer.renderNodes;n.hasNode(o)||n.addNodeConstructor(o,t)},l=function(e,t){return void 0===t&&(t=!1),e.filters||e.enableFilters().focusFilters(),t?e.filters.external:e.filters.internal};const c=Phaser.Utils.Array.SpliceOne;class m extends Phaser.Plugins.BasePlugin{setFilterClass(e,t){return this.FilterClass=e,this.ControllerClass=t,this}setFilterListMethod(e,t){return function(e,t){var r=Phaser.GameObjects.Components.FilterList.prototype;r[e]?console.warn(`FilterList method: ${e} is already defined`):r[e]=t}(e,t),this}start(){var e=this.game.events;e.once("destroy",this.destroy,this),this.game.isRunning?d(this.game,this.FilterClass):e.once("ready",(function(){d(this.game,this.FilterClass)}),this)}add(e,t,r=!1){return function(e,t,r,o){void 0===r&&(r={});var n=l(e,o),i=n.add(new t(n.camera,r));return r.name&&(i.name=r.name),i}(e,this.ControllerClass,t,r)}remove(e,t,r=!1){return function(e,t,r,o){var n=l(e,o).list;if(void 0===r)for(var i=n.length-1;i>=0;i--)(a=n[i])instanceof t&&(a.destroy(),c(a,i));else{i=0;for(var s=n.length;i<s;i++){var a;(a=n[i])instanceof t&&a.name===r&&(a.destroy(),c(a,i))}}}(e,this.ControllerClass,t,r),this}get(e,t,r=!1){return function(e,t,r,o){var n=l(e,o).list;if(void 0===r){for(var i=[],s=0,a=n.length;s<a;s++)(g=n[s])instanceof t&&i.push(g);return i}for(s=0,a=n.length;s<a;s++){var g;if((g=n[s])instanceof t&&g.name===r)return g}}(e,this.ControllerClass,t,r)}}var u=function(e){return null==e||""===e||0===e.length},v=function(e,t,r,o){if(void 0===o&&(o="."),"object"==typeof e){if(u(t)){if(null==r)return;"object"==typeof r&&(e=r)}else{"string"==typeof t&&(t=t.split(o));var n=t.pop(),i=function(e,t,r){var o=e;if(u(t));else{var n;"string"==typeof t&&(t=t.split("."));for(var i=0,s=t.length;i<s;i++){var a;null!=o[n=t[i]]&&"object"==typeof o[n]||(a=i===s-1?void 0===r?{}:r:{},o[n]=a),o=o[n]}}return o}(e,t);i[n]=r}return e}};return v(window,"RexPlugins.Filters.DisolveFilter",t),v(window,"RexPlugins.Filters.DissolveController",n),class extends m{constructor(e){super(e),this.setFilterClass(t,n),this.setFilterListMethod("addRexDissolve",(function(e){return this.add(new n(this.camera,e))}))}}},"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).rexdissolvefilterplugin=t();
