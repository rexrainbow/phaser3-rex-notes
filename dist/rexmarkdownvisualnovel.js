(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.rexmarkdownvisualnovel = factory());
})(this, (function () { 'use strict';

  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function () {
      return !!t;
    })();
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return e;
    };
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function (t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function (t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw new Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(typeof e + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function (e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function () {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function (e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw new Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function (t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function (t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      catch: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);
        var desc;
        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            return false;
          }
          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }
        return true;
      };
    }
    return set(target, property, value, receiver);
  }
  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }
    return value;
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var eventemitter3 = {exports: {}};

  (function (module) {

  	var has = Object.prototype.hasOwnProperty
  	  , prefix = '~';

  	/**
  	 * Constructor to create a storage for our `EE` objects.
  	 * An `Events` instance is a plain object whose properties are event names.
  	 *
  	 * @constructor
  	 * @private
  	 */
  	function Events() {}

  	//
  	// We try to not inherit from `Object.prototype`. In some engines creating an
  	// instance in this way is faster than calling `Object.create(null)` directly.
  	// If `Object.create(null)` is not supported we prefix the event names with a
  	// character to make sure that the built-in object properties are not
  	// overridden or used as an attack vector.
  	//
  	if (Object.create) {
  	  Events.prototype = Object.create(null);

  	  //
  	  // This hack is needed because the `__proto__` property is still inherited in
  	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  	  //
  	  if (!new Events().__proto__) prefix = false;
  	}

  	/**
  	 * Representation of a single event listener.
  	 *
  	 * @param {Function} fn The listener function.
  	 * @param {*} context The context to invoke the listener with.
  	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
  	 * @constructor
  	 * @private
  	 */
  	function EE(fn, context, once) {
  	  this.fn = fn;
  	  this.context = context;
  	  this.once = once || false;
  	}

  	/**
  	 * Add a listener for a given event.
  	 *
  	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
  	 * @param {(String|Symbol)} event The event name.
  	 * @param {Function} fn The listener function.
  	 * @param {*} context The context to invoke the listener with.
  	 * @param {Boolean} once Specify if the listener is a one-time listener.
  	 * @returns {EventEmitter}
  	 * @private
  	 */
  	function addListener(emitter, event, fn, context, once) {
  	  if (typeof fn !== 'function') {
  	    throw new TypeError('The listener must be a function');
  	  }

  	  var listener = new EE(fn, context || emitter, once)
  	    , evt = prefix ? prefix + event : event;

  	  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  	  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  	  else emitter._events[evt] = [emitter._events[evt], listener];

  	  return emitter;
  	}

  	/**
  	 * Clear event by name.
  	 *
  	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
  	 * @param {(String|Symbol)} evt The Event name.
  	 * @private
  	 */
  	function clearEvent(emitter, evt) {
  	  if (--emitter._eventsCount === 0) emitter._events = new Events();
  	  else delete emitter._events[evt];
  	}

  	/**
  	 * Minimal `EventEmitter` interface that is molded against the Node.js
  	 * `EventEmitter` interface.
  	 *
  	 * @constructor
  	 * @public
  	 */
  	function EventEmitter() {
  	  this._events = new Events();
  	  this._eventsCount = 0;
  	}

  	/**
  	 * Return an array listing the events for which the emitter has registered
  	 * listeners.
  	 *
  	 * @returns {Array}
  	 * @public
  	 */
  	EventEmitter.prototype.eventNames = function eventNames() {
  	  var names = []
  	    , events
  	    , name;

  	  if (this._eventsCount === 0) return names;

  	  for (name in (events = this._events)) {
  	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  	  }

  	  if (Object.getOwnPropertySymbols) {
  	    return names.concat(Object.getOwnPropertySymbols(events));
  	  }

  	  return names;
  	};

  	/**
  	 * Return the listeners registered for a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @returns {Array} The registered listeners.
  	 * @public
  	 */
  	EventEmitter.prototype.listeners = function listeners(event) {
  	  var evt = prefix ? prefix + event : event
  	    , handlers = this._events[evt];

  	  if (!handlers) return [];
  	  if (handlers.fn) return [handlers.fn];

  	  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
  	    ee[i] = handlers[i].fn;
  	  }

  	  return ee;
  	};

  	/**
  	 * Return the number of listeners listening to a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @returns {Number} The number of listeners.
  	 * @public
  	 */
  	EventEmitter.prototype.listenerCount = function listenerCount(event) {
  	  var evt = prefix ? prefix + event : event
  	    , listeners = this._events[evt];

  	  if (!listeners) return 0;
  	  if (listeners.fn) return 1;
  	  return listeners.length;
  	};

  	/**
  	 * Calls each of the listeners registered for a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @returns {Boolean} `true` if the event had listeners, else `false`.
  	 * @public
  	 */
  	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  	  var evt = prefix ? prefix + event : event;

  	  if (!this._events[evt]) return false;

  	  var listeners = this._events[evt]
  	    , len = arguments.length
  	    , args
  	    , i;

  	  if (listeners.fn) {
  	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

  	    switch (len) {
  	      case 1: return listeners.fn.call(listeners.context), true;
  	      case 2: return listeners.fn.call(listeners.context, a1), true;
  	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
  	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
  	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
  	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
  	    }

  	    for (i = 1, args = new Array(len -1); i < len; i++) {
  	      args[i - 1] = arguments[i];
  	    }

  	    listeners.fn.apply(listeners.context, args);
  	  } else {
  	    var length = listeners.length
  	      , j;

  	    for (i = 0; i < length; i++) {
  	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

  	      switch (len) {
  	        case 1: listeners[i].fn.call(listeners[i].context); break;
  	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
  	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
  	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
  	        default:
  	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
  	            args[j - 1] = arguments[j];
  	          }

  	          listeners[i].fn.apply(listeners[i].context, args);
  	      }
  	    }
  	  }

  	  return true;
  	};

  	/**
  	 * Add a listener for a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @param {Function} fn The listener function.
  	 * @param {*} [context=this] The context to invoke the listener with.
  	 * @returns {EventEmitter} `this`.
  	 * @public
  	 */
  	EventEmitter.prototype.on = function on(event, fn, context) {
  	  return addListener(this, event, fn, context, false);
  	};

  	/**
  	 * Add a one-time listener for a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @param {Function} fn The listener function.
  	 * @param {*} [context=this] The context to invoke the listener with.
  	 * @returns {EventEmitter} `this`.
  	 * @public
  	 */
  	EventEmitter.prototype.once = function once(event, fn, context) {
  	  return addListener(this, event, fn, context, true);
  	};

  	/**
  	 * Remove the listeners of a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @param {Function} fn Only remove the listeners that match this function.
  	 * @param {*} context Only remove the listeners that have this context.
  	 * @param {Boolean} once Only remove one-time listeners.
  	 * @returns {EventEmitter} `this`.
  	 * @public
  	 */
  	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  	  var evt = prefix ? prefix + event : event;

  	  if (!this._events[evt]) return this;
  	  if (!fn) {
  	    clearEvent(this, evt);
  	    return this;
  	  }

  	  var listeners = this._events[evt];

  	  if (listeners.fn) {
  	    if (
  	      listeners.fn === fn &&
  	      (!once || listeners.once) &&
  	      (!context || listeners.context === context)
  	    ) {
  	      clearEvent(this, evt);
  	    }
  	  } else {
  	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
  	      if (
  	        listeners[i].fn !== fn ||
  	        (once && !listeners[i].once) ||
  	        (context && listeners[i].context !== context)
  	      ) {
  	        events.push(listeners[i]);
  	      }
  	    }

  	    //
  	    // Reset the array, or remove it completely if we have no more listeners.
  	    //
  	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
  	    else clearEvent(this, evt);
  	  }

  	  return this;
  	};

  	/**
  	 * Remove all listeners, or those of the specified event.
  	 *
  	 * @param {(String|Symbol)} [event] The event name.
  	 * @returns {EventEmitter} `this`.
  	 * @public
  	 */
  	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  	  var evt;

  	  if (event) {
  	    evt = prefix ? prefix + event : event;
  	    if (this._events[evt]) clearEvent(this, evt);
  	  } else {
  	    this._events = new Events();
  	    this._eventsCount = 0;
  	  }

  	  return this;
  	};

  	//
  	// Alias methods names because people roll like that.
  	//
  	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  	//
  	// Expose the prefix.
  	//
  	EventEmitter.prefixed = prefix;

  	//
  	// Allow `EventEmitter` to be imported as module namespace.
  	//
  	EventEmitter.EventEmitter = EventEmitter;

  	//
  	// Expose the module.
  	//
  	{
  	  module.exports = EventEmitter;
  	} 
  } (eventemitter3));

  var eventemitter3Exports = eventemitter3.exports;
  var EE = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

  var EventEmitter$2 = /*#__PURE__*/function (_EE) {
    _inherits(EventEmitter, _EE);
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);
      return _callSuper(this, EventEmitter, arguments);
    }
    _createClass(EventEmitter, [{
      key: "shutdown",
      value: function shutdown() {
        this.removeAllListeners();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAllListeners();
      }
    }]);
    return EventEmitter;
  }(EE);

  var IDLE$7 = 0;
  var SUCCESS$1 = 1;
  var FAILURE = 2;
  var RUNNING$1 = 3;
  var ABORT = 5;
  var ERROR$1 = 9;
  var TREE = 'tree';
  var COMPOSITE = 'composite';
  var DECORATOR = 'decorator';
  var ACTION = 'action';
  var SERVICE = 'service';
  var TREE_STATE = '$state';

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */

  /**
   * Creates and returns an RFC4122 version 4 compliant UUID.
   * 
   * The string is in the form: `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx` where each `x` is replaced with a random
   * hexadecimal digit from 0 to f, and `y` is replaced with a random hexadecimal digit from 8 to b.
   *
   * @function Phaser.Utils.String.UUID
   * @since 3.12.0
   *
   * @return {string} The UUID string.
   */
  var HasBuiltRandomUUID = window.crypto && window.crypto.randomUUID;
  var UUID$6 = function UUID() {
    if (HasBuiltRandomUUID) {
      return window.crypto.randomUUID();
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0;
      var v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  var sn = null;
  var snPrefix = '#';
  var SetSerialNumber = function SetSerialNumber(value) {
    if (value === undefined) {
      value = null;
    }
    sn = value;
  };
  var SetSerialNumberPrefix = function SetSerialNumberPrefix(prefix) {
    snPrefix = prefix;
  };
  var GetSerialNumber = function GetSerialNumber() {
    return sn;
  };
  var CreateID = function CreateID() {
    if (sn === null) {
      return UUID$6();
    }
    sn += 1;
    return "".concat(snPrefix).concat(sn);
  };

  var DataMethods$4 = {
    getTreeMemory: function getTreeMemory(blackboard) {
      return blackboard.getTreeMemory(this.id);
    },
    getData: function getData(blackboard, key) {
      return blackboard.get(key, this.id);
    },
    setData: function setData(blackboard, key, value) {
      blackboard.set(key, value, this.id);
      return this;
    },
    getState: function getState(blackboard) {
      return this.getData(blackboard, TREE_STATE);
    },
    resetState: function resetState(blackboard) {
      this.setData(blackboard, TREE_STATE, IDLE$7);
      return this;
    }
  };

  var BreadthFirstSearch$1 = function BreadthFirstSearch(root, callback, scope) {
    var queue = [root];
    while (queue.length > 0) {
      var current = queue.shift();
      var skip = callback.call(scope, current);
      if (skip) {
        continue;
      }
      switch (current.category) {
        case COMPOSITE:
          queue.push.apply(queue, _toConsumableArray(current.children));
          var services = current.services;
          if (services) {
            queue.push.apply(queue, _toConsumableArray(services));
          }
          break;
        case DECORATOR:
          queue.push(current.child);
          break;
        case ACTION:
          var services = current.services;
          if (services) {
            queue.push.apply(queue, _toConsumableArray(services));
          }
          break;
      }
    }
  };

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  /**
   * This is a slightly modified version of jQuery.isPlainObject.
   * A plain object is an object whose internal class property is [object Object].
   *
   * @function Phaser.Utils.Objects.IsPlainObject
   * @since 3.0.0
   *
   * @param {object} obj - The object to inspect.
   *
   * @return {boolean} `true` if the object is plain, otherwise `false`.
   */
  var IsPlainObject$Q = function IsPlainObject(obj) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (_typeof(obj) !== 'object' || obj.nodeType || obj === obj.window) {
      return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try {
      if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {
        return false;
      }
    } catch (e) {
      return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
  };

  var DeepClone = function DeepClone(inObject) {
    var outObject;
    var value;
    var key;
    if (inObject == null || _typeof(inObject) !== 'object') {
      //  inObject is not an object
      return inObject;
    }

    //  Create an array or object to hold the values
    outObject = Array.isArray(inObject) ? [] : {};
    if (IsPlainObject$Q(inObject)) {
      for (key in inObject) {
        value = inObject[key];

        //  Recursively (deep) copy for nested objects, including arrays
        outObject[key] = DeepClone(value);
      }
    } else {
      outObject = inObject;
    }
    return outObject;
  };

  var Dump = function Dump() {
    var data = {
      sn: GetSerialNumber(),
      id: this.id,
      title: this.title,
      description: this.description,
      root: this.root ? this.root.id : null,
      properties: DeepClone(this.properties),
      nodes: []
    };
    if (!this.root) {
      return data;
    }
    var nodes = [];
    BreadthFirstSearch$1(this.root, function (child) {
      nodes.push(child);
    });
    for (var i = 0, cnt = nodes.length; i < cnt; i++) {
      var node = nodes[i];
      var spec = {
        id: node.id,
        name: node.name,
        title: node.title,
        description: node.description,
        properties: DeepClone(node.properties)
      };
      switch (node.category) {
        case COMPOSITE:
          spec.children = node.children.map(function (child) {
            return child.id;
          });
          if (node.services) {
            spec.services = node.services.map(function (child) {
              return child.id;
            });
          }
          break;
        case DECORATOR:
          if (node.child) {
            spec.child = node.child.id;
          }
          break;
        case ACTION:
          if (node.services) {
            spec.services = node.services.map(function (child) {
              return child.id;
            });
          }
          break;
      }
      data.nodes.push(spec);
    }
    return data;
  };

  var BaseExpression = /*#__PURE__*/function () {
    function BaseExpression() {
      _classCallCheck(this, BaseExpression);
    }
    _createClass(BaseExpression, [{
      key: "setExpressionHandler",
      value: function setExpressionHandler(callback) {
        this.expressionHandler = callback;
        return this;
      }
    }, {
      key: "eval",
      value: function _eval(context) {
        return this.expressionHandler(context);
      }
    }]);
    return BaseExpression;
  }();

  function commonjsRequire(path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var parser$3 = {};

  /* parser generated by jison 0.4.18 */
  (function (exports) {
    /*
      Returns a Parser object of the following structure:
    
      Parser: {
        yy: {}
      }
    
      Parser.prototype: {
        yy: {},
        trace: function(),
        symbols_: {associative list: name ==> number},
        terminals_: {associative list: number ==> name},
        productions_: [...],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
        table: [...],
        defaultActions: {...},
        parseError: function(str, hash),
        parse: function(input),
    
        lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),
    
            options: {
                ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },
    
            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
        }
      }
    
    
      token location info (@$, _$, etc.): {
        first_line: n,
        last_line: n,
        first_column: n,
        last_column: n,
        range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
      }
    
    
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
        text:        (matched text)
        token:       (the produced terminal token, if any)
        line:        (yylineno)
      }
      while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
        loc:         (yylloc)
        expected:    (string describing the set of expected tokens)
        recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
      }
    */
    var parser = function () {
      var o = function o(k, v, _o, l) {
          for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v);
          return _o;
        },
        $V0 = [1, 11],
        $V1 = [1, 3],
        $V2 = [1, 4],
        $V3 = [1, 5],
        $V4 = [1, 6],
        $V5 = [1, 8],
        $V6 = [1, 9],
        $V7 = [1, 10],
        $V8 = [1, 13],
        $V9 = [1, 14],
        $Va = [1, 15],
        $Vb = [1, 16],
        $Vc = [1, 17],
        $Vd = [1, 18],
        $Ve = [1, 19],
        $Vf = [1, 20],
        $Vg = [1, 21],
        $Vh = [1, 22],
        $Vi = [1, 23],
        $Vj = [1, 24],
        $Vk = [1, 25],
        $Vl = [1, 26],
        $Vm = [5, 7, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 30],
        $Vn = [5, 7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30],
        $Vo = [5, 7, 12, 13, 14, 19, 20, 21, 22, 23, 24, 25, 26, 28, 30],
        $Vp = [5, 7, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 28, 30],
        $Vq = [5, 7, 12, 19, 20, 21, 22, 23, 24, 25, 26, 28, 30],
        $Vr = [5, 7, 12, 25, 26, 28, 30],
        $Vs = [7, 28];
      var parser = {
        trace: function trace() {},
        yy: {},
        symbols_: {
          "error": 2,
          "expressions": 3,
          "e": 4,
          "EOF": 5,
          "expression_list": 6,
          ",": 7,
          "dot_name": 8,
          ".": 9,
          "NAME": 10,
          "[": 11,
          "]": 12,
          "+": 13,
          "-": 14,
          "*": 15,
          "/": 16,
          "%": 17,
          "^": 18,
          ">": 19,
          "<": 20,
          "==": 21,
          "!=": 22,
          ">=": 23,
          "<=": 24,
          "||": 25,
          "&&": 26,
          "(": 27,
          ")": 28,
          "?": 29,
          ":": 30,
          "true": 31,
          "false": 32,
          "QUOTED_STRING": 33,
          "NUMBER": 34,
          "HEXNUMBER": 35,
          "$accept": 0,
          "$end": 1
        },
        terminals_: {
          2: "error",
          5: "EOF",
          7: ",",
          9: ".",
          10: "NAME",
          11: "[",
          12: "]",
          13: "+",
          14: "-",
          15: "*",
          16: "/",
          17: "%",
          18: "^",
          19: ">",
          20: "<",
          21: "==",
          22: "!=",
          23: ">=",
          24: "<=",
          25: "||",
          26: "&&",
          27: "(",
          28: ")",
          29: "?",
          30: ":",
          31: "true",
          32: "false",
          33: "QUOTED_STRING",
          34: "NUMBER",
          35: "HEXNUMBER"
        },
        productions_: [0, [3, 2], [6, 3], [6, 1], [8, 3], [8, 4], [8, 1], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 2], [4, 3], [4, 7], [4, 1], [4, 1], [4, 1], [4, 3], [4, 4], [4, 1], [4, 1], [4, 1]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
          /* this == yyval */

          var $0 = $$.length - 1;
          switch (yystate) {
            case 1:
              var result = $$[$0 - 1];
              if (typeof result === 'function') {
                return result;
              } else {
                return function (ctx) {
                  return result;
                };
              }
            case 2:
            case 4:
              this.$ = $$[$0 - 2].concat([$$[$0]]);
              break;
            case 3:
            case 6:
              this.$ = [$$[$0]];
              break;
            case 5:
              this.$ = $$[$0 - 3].concat([$$[$0 - 1]]);
              break;
            case 7:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_add', [$$[$0 - 2], $$[$0]]);
              };
              break;
            case 8:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_subtract', [$$[$0 - 2], $$[$0]]);
              };
              break;
            case 9:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_multiply', [$$[$0 - 2], $$[$0]]);
              };
              break;
            case 10:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_divide', [$$[$0 - 2], $$[$0]]);
              };
              break;
            case 11:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_mod', [$$[$0 - 2], $$[$0]]);
              };
              break;
            case 12:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_pow', [$$[$0 - 2], $$[$0]]);
              };
              break;
            case 13:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_greaterThen', [$$[$0 - 2], $$[$0]]) == true;
              };
              break;
            case 14:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_lessThen', [$$[$0 - 2], $$[$0]]) == true;
              };
              break;
            case 15:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_equalTo', [$$[$0 - 2], $$[$0]]) == true;
              };
              break;
            case 16:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_equalTo', [$$[$0 - 2], $$[$0]]) == false;
              };
              break;
            case 17:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_lessThen', [$$[$0 - 2], $$[$0]]) == false;
              };
              break;
            case 18:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_greaterThen', [$$[$0 - 2], $$[$0]]) == false;
              };
              break;
            case 19:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_or', [$$[$0 - 2], $$[$0]]) == true;
              };
              break;
            case 20:
              this.$ = function (ctx) {
                return runBuildInMethod(yy.parser, ctx, '_and', [$$[$0 - 2], $$[$0]]) == true;
              };
              break;
            case 21:
              this.$ = function (ctx) {
                return -runFn($$[$0], ctx);
              };
              break;
            case 22:
              this.$ = function (ctx) {
                return runFn($$[$0 - 1], ctx);
              };
              break;
            case 23:
              this.$ = function (ctx) {
                return runFn($$[$0 - 5], ctx) ? runFn($$[$0 - 2], ctx) : runFn($$[$0], ctx);
              };
              break;
            case 24:
              this.$ = true;
              break;
            case 25:
              this.$ = false;
              break;
            case 26:
              this.$ = function (ctx) {
                return yy.parser.getDotProperty(ctx, mapArgs($$[$0], ctx), 0);
              };
              break;
            case 27:
              this.$ = function (ctx) {
                return runMethod(yy.parser, ctx, mapArgs($$[$0 - 2], ctx), undefined, true);
              };
              break;
            case 28:
              this.$ = function (ctx) {
                return runMethod(yy.parser, ctx, mapArgs($$[$0 - 3], ctx), $$[$0 - 1], true);
              };
              break;
            case 29:
              this.$ = yytext.slice(1, -1);
              break;
            case 30:
              this.$ = Number(yytext);
              break;
            case 31:
              this.$ = parseInt(yytext, 16);
              break;
          }
        },
        table: [{
          3: 1,
          4: 2,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          1: [3]
        }, {
          5: [1, 12],
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj,
          25: $Vk,
          26: $Vl
        }, {
          4: 27,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 28,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, o($Vm, [2, 24]), o($Vm, [2, 25]), o($Vm, [2, 26], {
          9: [1, 30],
          11: [1, 31],
          27: [1, 29]
        }), o($Vm, [2, 29]), o($Vm, [2, 30]), o($Vm, [2, 31]), o($Vn, [2, 6]), {
          1: [2, 1]
        }, {
          4: 32,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 33,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 34,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 35,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 36,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 37,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 38,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 39,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 40,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 41,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 42,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 43,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 44,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          4: 45,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, o($Vm, [2, 21]), {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj,
          25: $Vk,
          26: $Vl,
          28: [1, 46]
        }, {
          4: 49,
          6: 48,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          28: [1, 47],
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, {
          10: [1, 50]
        }, {
          4: 51,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, o($Vo, [2, 7], {
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd
        }), o($Vo, [2, 8], {
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd
        }), o($Vp, [2, 9], {
          18: $Vd
        }), o($Vp, [2, 10], {
          18: $Vd
        }), o([5, 7, 12, 13, 14, 17, 19, 20, 21, 22, 23, 24, 25, 26, 28, 30], [2, 11], {
          15: $Va,
          16: $Vb,
          18: $Vd
        }), o($Vm, [2, 12]), o($Vq, [2, 13], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd
        }), o($Vq, [2, 14], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd
        }), o($Vq, [2, 15], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd
        }), o($Vq, [2, 16], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd
        }), o($Vq, [2, 17], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd
        }), o($Vq, [2, 18], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd
        }), o($Vr, [2, 19], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj
        }), o($Vr, [2, 20], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj
        }), o($Vm, [2, 22], {
          29: [1, 52]
        }), o($Vm, [2, 27]), {
          7: [1, 54],
          28: [1, 53]
        }, o($Vs, [2, 3], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj,
          25: $Vk,
          26: $Vl
        }), o($Vn, [2, 4]), {
          12: [1, 55],
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj,
          25: $Vk,
          26: $Vl
        }, {
          4: 56,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, o($Vm, [2, 28]), {
          4: 57,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, o($Vn, [2, 5]), {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj,
          25: $Vk,
          26: $Vl,
          30: [1, 58]
        }, o($Vs, [2, 2], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj,
          25: $Vk,
          26: $Vl
        }), {
          4: 59,
          8: 7,
          10: $V0,
          14: $V1,
          27: $V2,
          31: $V3,
          32: $V4,
          33: $V5,
          34: $V6,
          35: $V7
        }, o([5, 7, 12, 28, 30], [2, 23], {
          13: $V8,
          14: $V9,
          15: $Va,
          16: $Vb,
          17: $Vc,
          18: $Vd,
          19: $Ve,
          20: $Vf,
          21: $Vg,
          22: $Vh,
          23: $Vi,
          24: $Vj,
          25: $Vk,
          26: $Vl
        })],
        defaultActions: {
          12: [2, 1]
        },
        parseError: function parseError(str, hash) {
          if (hash.recoverable) {
            this.trace(str);
          } else {
            var error = new Error(str);
            error.hash = hash;
            throw error;
          }
        },
        parse: function parse(input) {
          var self = this,
            stack = [0],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
          var args = lstack.slice.call(arguments, 1);
          var lexer = Object.create(this.lexer);
          var sharedState = {
            yy: {}
          };
          for (var k in this.yy) {
            if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
              sharedState.yy[k] = this.yy[k];
            }
          }
          lexer.setInput(input, sharedState.yy);
          sharedState.yy.lexer = lexer;
          sharedState.yy.parser = this;
          if (typeof lexer.yylloc == 'undefined') {
            lexer.yylloc = {};
          }
          var yyloc = lexer.yylloc;
          lstack.push(yyloc);
          var ranges = lexer.options && lexer.options.ranges;
          if (typeof sharedState.yy.parseError === 'function') {
            this.parseError = sharedState.yy.parseError;
          } else {
            this.parseError = Object.getPrototypeOf(this).parseError;
          }
          var lex = function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
              token = self.symbols_[token] || token;
            }
            return token;
          };
          var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
              }
              action = table[state] && table[state][symbol];
            }
            if (typeof action === 'undefined' || !action.length || !action[0]) {
              var errStr = '';
              expected = [];
              for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                  expected.push('\'' + this.terminals_[p] + '\'');
                }
              }
              if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
              } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
              }
              this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
              });
            }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
              case 1:
                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]);
                symbol = null;
                {
                  yyleng = lexer.yyleng;
                  yytext = lexer.yytext;
                  yylineno = lexer.yylineno;
                  yyloc = lexer.yylloc;
                }
                break;
              case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = {
                  first_line: lstack[lstack.length - (len || 1)].first_line,
                  last_line: lstack[lstack.length - 1].last_line,
                  first_column: lstack[lstack.length - (len || 1)].first_column,
                  last_column: lstack[lstack.length - 1].last_column
                };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                }
                r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
                if (typeof r !== 'undefined') {
                  return r;
                }
                if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
              case 3:
                return true;
            }
          }
          return true;
        }
      };
      function runFn(arg, ctx) {
        return typeof arg === 'function' ? arg(ctx) : arg;
      }
      function mapArgs(args, ctx) {
        if (args) {
          args = args.map(function (arg) {
            return runFn(arg, ctx);
          });
        }
        return args;
      }
      function runBuildInMethod(self, ctx, name, args) {
        var callback = self[name];
        return callback.apply(self, mapArgs(args, ctx));
      }
      function runMethod(self, ctx, name, args, dotMode) {
        var names;
        if (typeof name === 'string') {
          if (dotMode) {
            names = name.split('.');
          } else {
            names = [name];
          }
        } else {
          names = name;
        }
        var callback, scope;
        if (names.length > 1) {
          var callbackName = names.pop();
          scope = self.getDotProperty(ctx, names);
          callback = scope[callbackName];
        } else {
          callback = self.getProperty(ctx, name);
          scope = self;
        }
        if (callback == null) {
          callback = self.getProperty(ctx, 'defaultHandler');
          scope = self;
        }
        return callback.apply(scope, mapArgs(args, ctx));
      }
      /* generated by jison-lex 0.3.4 */
      var lexer = function () {
        var lexer = {
          EOF: 1,
          parseError: function parseError(str, hash) {
            if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
            } else {
              throw new Error(str);
            }
          },
          // resets the lexer, sets new input
          setInput: function setInput(input, yy) {
            this.yy = yy || this.yy || {};
            this._input = input;
            this._more = this._backtrack = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = '';
            this.conditionStack = ['INITIAL'];
            this.yylloc = {
              first_line: 1,
              first_column: 0,
              last_line: 1,
              last_column: 0
            };
            if (this.options.ranges) {
              this.yylloc.range = [0, 0];
            }
            this.offset = 0;
            return this;
          },
          // consumes and returns one char from the input
          input: function input() {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/(?:\r\n?|\n).*/g);
            if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
            } else {
              this.yylloc.last_column++;
            }
            if (this.options.ranges) {
              this.yylloc.range[1]++;
            }
            this._input = this._input.slice(1);
            return ch;
          },
          // unshifts one char (or a string) into the input
          unput: function unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len);
            //this.yyleng -= len;
            this.offset -= len;
            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
            this.match = this.match.substr(0, this.match.length - 1);
            this.matched = this.matched.substr(0, this.matched.length - 1);
            if (lines.length - 1) {
              this.yylineno -= lines.length - 1;
            }
            var r = this.yylloc.range;
            this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
            };
            if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
            }
            this.yyleng = this.yytext.length;
            return this;
          },
          // When called from action, caches matched text and appends it on next action
          more: function more() {
            this._more = true;
            return this;
          },
          // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
          reject: function reject() {
            if (this.options.backtrack_lexer) {
              this._backtrack = true;
            } else {
              return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
              });
            }
            return this;
          },
          // retain first n characters of the match
          less: function less(n) {
            this.unput(this.match.slice(n));
          },
          // displays already matched input, i.e. for error messages
          pastInput: function pastInput() {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
          },
          // displays upcoming input, i.e. for error messages
          upcomingInput: function upcomingInput() {
            var next = this.match;
            if (next.length < 20) {
              next += this._input.substr(0, 20 - next.length);
            }
            return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
          },
          // displays the character position where the lexing error occurred, i.e. for error messages
          showPosition: function showPosition() {
            var pre = this.pastInput();
            var c = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c + "^";
          },
          // test the lexed token: return FALSE when not a match, otherwise return token
          test_match: function test_match(match, indexed_rule) {
            var token, lines, backup;
            if (this.options.backtrack_lexer) {
              // save context
              backup = {
                yylineno: this.yylineno,
                yylloc: {
                  first_line: this.yylloc.first_line,
                  last_line: this.last_line,
                  first_column: this.yylloc.first_column,
                  last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
              };
              if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
              }
            }
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) {
              this.yylineno += lines.length;
            }
            this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
            };
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._backtrack = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input) {
              this.done = false;
            }
            if (token) {
              return token;
            } else if (this._backtrack) {
              // recover context
              for (var k in backup) {
                this[k] = backup[k];
              }
              return false; // rule action called reject() implying the next rule should be tested instead.
            }
            return false;
          },
          // return next match in input
          next: function next() {
            if (this.done) {
              return this.EOF;
            }
            if (!this._input) {
              this.done = true;
            }
            var token, match, tempMatch, index;
            if (!this._more) {
              this.yytext = '';
              this.match = '';
            }
            var rules = this._currentRules();
            for (var i = 0; i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                  token = this.test_match(tempMatch, rules[i]);
                  if (token !== false) {
                    return token;
                  } else if (this._backtrack) {
                    match = false;
                    continue; // rule action called reject() implying a rule MISmatch.
                  } else {
                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                    return false;
                  }
                } else if (!this.options.flex) {
                  break;
                }
              }
            }
            if (match) {
              token = this.test_match(match, rules[index]);
              if (token !== false) {
                return token;
              }
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
            if (this._input === "") {
              return this.EOF;
            } else {
              return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
              });
            }
          },
          // return next match that has a token
          lex: function lex() {
            var r = this.next();
            if (r) {
              return r;
            } else {
              return this.lex();
            }
          },
          // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
          begin: function begin(condition) {
            this.conditionStack.push(condition);
          },
          // pop the previously active lexer condition state off the condition stack
          popState: function popState() {
            var n = this.conditionStack.length - 1;
            if (n > 0) {
              return this.conditionStack.pop();
            } else {
              return this.conditionStack[0];
            }
          },
          // produce the lexer rule set which is active for the currently active lexer condition state
          _currentRules: function _currentRules() {
            if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            } else {
              return this.conditions["INITIAL"].rules;
            }
          },
          // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
          topState: function topState(n) {
            n = this.conditionStack.length - 1 - Math.abs(n || 0);
            if (n >= 0) {
              return this.conditionStack[n];
            } else {
              return "INITIAL";
            }
          },
          // alias for begin(condition)
          pushState: function pushState(condition) {
            this.begin(condition);
          },
          // return the number of states currently on the stack
          stateStackSize: function stateStackSize() {
            return this.conditionStack.length;
          },
          options: {},
          performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            switch ($avoiding_name_collisions) {
              case 0:
                /* skip whitespace */
                break;
              case 1:
                return 34;
              case 2:
                return 35;
              case 3:
                return 15;
              case 4:
                return 16;
              case 5:
                return 14;
              case 6:
                return 13;
              case 7:
                return 18;
              case 8:
                return 17;
              case 9:
                return ">=";
              case 10:
                return "<=";
              case 11:
                return 19;
              case 12:
                return 20;
              case 13:
                return "==";
              case 14:
                return "!=";
              case 15:
                return "||";
              case 16:
                return "&&";
              case 17:
                return "?";
              case 18:
                return ":";
              case 19:
                return 27;
              case 20:
                return 28;
              case 21:
                return 11;
              case 22:
                return 12;
              case 23:
                return 7;
              case 24:
                return 9;
              case 25:
                return 31;
              case 26:
                return 32;
              case 27:
                return 10;
              case 28:
                return 33;
              case 29:
                return 5;
              case 30:
                return 'INVALID';
            }
          },
          rules: [/^(?:\s+)/, /^(?:[0-9]+(\.[0-9]+)?\b)/, /^(?:\b0x[0-9A-Fa-f]+\b)/, /^(?:\*)/, /^(?:\/)/, /^(?:-)/, /^(?:\+)/, /^(?:\^)/, /^(?:%)/, /^(?:>=)/, /^(?:<=)/, /^(?:>)/, /^(?:<)/, /^(?:==)/, /^(?:!=)/, /^(?:\|\|)/, /^(?:&&)/, /^(?:\?)/, /^(?::)/, /^(?:\()/, /^(?:\))/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:\.)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:[^\s\*\/\-\+\^\%\>\=\<\!\|\&\?\:\(\)\[\]\,\.]+)/, /^(?:"(\\.|[^\"\\])*"|'(\\.|[^\'\\])*')/, /^(?:$)/, /^(?:.)/],
          conditions: {
            "INITIAL": {
              "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
              "inclusive": true
            }
          }
        };
        return lexer;
      }();
      parser.lexer = lexer;
      function Parser() {
        this.yy = {};
      }
      Parser.prototype = parser;
      parser.Parser = Parser;
      return new Parser();
    }();
    if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
      exports.parser = parser;
      exports.Parser = parser.Parser;
      exports.parse = function () {
        return parser.parse.apply(parser, arguments);
      };
    }
  })(parser$3);
  var parser$2 = /*@__PURE__*/getDefaultExportFromCjs(parser$3);

  var GetProperty$1 = function GetProperty(context, key, defaultValue, dotMode) {
    if (dotMode === undefined) {
      dotMode = true;
    }
    if (!context || typeof context === 'number' || typeof context === 'string') {
      return defaultValue;
    } else if (key in context) {
      return context[key];
    } else if (dotMode && (Array.isArray(key) || key.indexOf('.') !== -1)) {
      var keys = Array.isArray(key) ? key : key.split('.');
      var value = context;
      //  Use for loop here so we can break early
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key in value) {
          value = value[key];
        } else {
          value = defaultValue;
          break;
        }
      }
      return value;
    } else {
      return defaultValue;
    }
  };

  var FormulaParser = /*#__PURE__*/function (_parser$Parser) {
    _inherits(FormulaParser, _parser$Parser);
    function FormulaParser() {
      _classCallCheck(this, FormulaParser);
      return _callSuper(this, FormulaParser, arguments);
    }
    _createClass(FormulaParser, [{
      key: "getProperty",
      value: function getProperty(context, name, defaultValue) {
        var value = GetProperty$1(context, name, undefined, false);
        if (value !== undefined) {
          return value;
        }
        return GetProperty$1(this, name, defaultValue, false);
      }
    }, {
      key: "getDotProperty",
      value: function getDotProperty(context, name, defaultValue) {
        var value = GetProperty$1(context, name, undefined, true);
        if (value !== undefined) {
          return value;
        }
        return GetProperty$1(this, name, defaultValue, true);
      }
    }, {
      key: "_add",
      value: function _add(a, b) {
        return a + b;
      }
    }, {
      key: "_subtract",
      value: function _subtract(a, b) {
        return a - b;
      }
    }, {
      key: "_multiply",
      value: function _multiply(a, b) {
        return a * b;
      }
    }, {
      key: "_divide",
      value: function _divide(a, b) {
        return a / b;
      }
    }, {
      key: "_mod",
      value: function _mod(a, b) {
        return a % b;
      }
    }, {
      key: "_pow",
      value: function _pow(a, b) {
        return Math.pow(a, b);
      }
    }, {
      key: "_greaterThen",
      value: function _greaterThen(a, b) {
        return a > b;
      }
    }, {
      key: "_lessThen",
      value: function _lessThen(a, b) {
        return a < b;
      }
    }, {
      key: "_equalTo",
      value: function _equalTo(a, b) {
        return a == b;
      }
    }, {
      key: "_or",
      value: function _or(a, b) {
        return a || b;
      }
    }, {
      key: "_and",
      value: function _and(a, b) {
        return a && b;
      }
    }, {
      key: "defaultHandler",
      value: function defaultHandler(name, args) {
        return 0;
      }
    }, {
      key: "compile",
      value: function compile(input) {
        return this.parse(input);
      }
    }, {
      key: "exec",
      value: function exec(input, data) {
        if (typeof input === 'string') {
          input = this.compile(input);
        }
        return input(data);
      }
    }], [{
      key: "GetProperty",
      value: function GetProperty(context, key, defaultValue, dotMode) {
        return GetProperty$1(context, key, defaultValue, dotMode);
      }
    }]);
    return FormulaParser;
  }(parser$2.Parser);

  var parser$1 = new FormulaParser();
  var Compile$1 = function Compile(expression) {
    return parser$1.compile(expression);
  };

  var Expression = /*#__PURE__*/function (_BaseExpression) {
    _inherits(Expression, _BaseExpression);
    function Expression(expression) {
      var _this;
      _classCallCheck(this, Expression);
      _this = _callSuper(this, Expression);
      var callback;
      if (typeof expression === 'number') {
        callback = function callback() {
          return expression;
        };
      } else {
        callback = Compile$1(expression);
      }
      _this.setExpressionHandler(callback);
      return _this;
    }
    return _createClass(Expression);
  }(BaseExpression);

  var BooleanExpression = /*#__PURE__*/function (_Expression) {
    _inherits(BooleanExpression, _Expression);
    function BooleanExpression() {
      _classCallCheck(this, BooleanExpression);
      return _callSuper(this, BooleanExpression, arguments);
    }
    _createClass(BooleanExpression, [{
      key: "eval",
      value: function _eval(context) {
        return !!_get(_getPrototypeOf(BooleanExpression.prototype), "eval", this).call(this, context);
      }
    }]);
    return BooleanExpression;
  }(Expression);

  var StringTemplate = /*#__PURE__*/function () {
    function StringTemplate(config) {
      _classCallCheck(this, StringTemplate);
      if (config === undefined) {
        config = {};
      }
      // Brackets and generate regex
      var delimiters = config.delimiters;
      if (delimiters === undefined) {
        delimiters = ['{{', '}}'];
      }
      this.setDelimiters(delimiters[0], delimiters[1]);
      var expressionParser = config.expressionParser;
      if (expressionParser === undefined) {
        expressionParser = new FormulaParser();
      }
      this.setExpressionParser(expressionParser);
    }
    _createClass(StringTemplate, [{
      key: "setDelimiters",
      value: function setDelimiters(delimiterLeft, delimiterRight) {
        if (delimiterRight === undefined) {
          delimiterRight = delimiterLeft[1];
          delimiterLeft = delimiterLeft[0];
        }
        this.delimiterLeft = delimiterLeft;
        this.delimiterRight = delimiterRight;
        this.reDelimiter = RegExp("".concat(delimiterLeft, "|").concat(delimiterRight), 'gi');
        this.reSplit = RegExp("".concat(delimiterLeft, ".*?").concat(delimiterRight), 'gi');
        return this;
      }
    }, {
      key: "setExpressionParser",
      value: function setExpressionParser(expressionParser) {
        this.expressionParser = expressionParser;
        return this;
      }
    }, {
      key: "compile",
      value: function compile(content, config) {
        // Store previous setting
        // Override current setting        
        var delimiterLeftSave, delimiterRightSave;
        var expressionParserSave;
        if (config) {
          var delimiters = config.delimiters;
          if (delimiters) {
            delimiterLeftSave = this.delimiterLeft;
            delimiterRightSave = this.delimiterRight;
            this.setDelimiters(delimiters[0], delimiters[1]);
          }
          var expressionParser = config.expressionParser;
          if (expressionParser) {
            expressionParserSave = this.expressionParser;
            this.setExpressionParser(expressionParser);
          }
        }

        // Parse context
        var reDelimiter = this.reDelimiter;
        var reSplit = this.reSplit;
        var expressionParser = this.expressionParser;
        var result = [];
        var charIdx = 0;
        while (true) {
          var regexResult = reSplit.exec(content);
          if (!regexResult) {
            break;
          }
          var match = regexResult[0];
          var matchEnd = reSplit.lastIndex;
          var matchStart = matchEnd - match.length;
          if (charIdx < matchStart) {
            result.push(content.substring(charIdx, matchStart));
          }
          var s = content.substring(matchStart, matchEnd).replace(reDelimiter, '');
          result.push(expressionParser.compile(s));
          charIdx = matchEnd;
        }
        var totalLen = content.length;
        if (charIdx < totalLen) {
          // Push remainder string
          result.push(content.substring(charIdx, totalLen));
        }

        // Restore previous setting
        if (delimiterLeftSave) {
          this.setDelimiters(delimiterLeftSave, delimiterRightSave);
        }
        if (expressionParserSave) {
          this.setExpressionParser(expressionParserSave);
        }

        // Return render callback
        return function (view) {
          return result.map(function (item) {
            if (typeof item === 'function') {
              item = item(view);
            }
            return item;
          }).join('');
        };
      }
    }, {
      key: "render",
      value: function render(content, view, config) {
        var f;
        if (typeof content === 'string') {
          f = this.compile(content, config);
        } else {
          f = content;
        }
        return f(view);
      }
    }]);
    return StringTemplate;
  }();

  var stringTemplate = new StringTemplate();
  var Compile = function Compile(content, config) {
    return stringTemplate.compile(content, config);
  };

  var StringTemplateExpression = /*#__PURE__*/function (_BaseExpression) {
    _inherits(StringTemplateExpression, _BaseExpression);
    function StringTemplateExpression(expression) {
      var _this;
      _classCallCheck(this, StringTemplateExpression);
      _this = _callSuper(this, StringTemplateExpression);
      var callback = Compile(expression);
      _this.setExpressionHandler(callback);
      return _this;
    }
    return _createClass(StringTemplateExpression);
  }(BaseExpression);

  var BaseNode = /*#__PURE__*/function () {
    function BaseNode() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id,
        category = _ref.category,
        name = _ref.name,
        title = _ref.title,
        description = _ref.description,
        properties = _ref.properties;
      _classCallCheck(this, BaseNode);
      if (id === undefined) {
        id = CreateID();
      }
      this.parent = null;
      this.id = id;
      this.category = category || '';
      this.name = name || '';
      this.title = title || this.name;
      this.description = description || '';
      this.properties = properties || {};
    }
    _createClass(BaseNode, [{
      key: "setTitle",
      value: function setTitle(title) {
        this.title = title;
        return this;
      }
    }, {
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "setDescription",
      value: function setDescription(description) {
        this.description = description;
        return this;
      }
    }, {
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent;
        return this;
      }
    }, {
      key: "getParent",
      value: function getParent() {
        return this.parent;
      }
    }, {
      key: "getTree",
      value: function getTree(tick) {
        if (tick) {
          return tick.tree;
        } else {
          var parent = this.parent;
          while (parent) {
            if (parent.category === TREE) {
              return parent;
            }
            parent = parent.parent;
          }
          return null;
        }
      }
    }, {
      key: "addExpression",
      value: function addExpression(expression) {
        return new Expression(expression);
      }
    }, {
      key: "addBooleanExpression",
      value: function addBooleanExpression(expression) {
        return new BooleanExpression(expression);
      }
    }, {
      key: "addStringTemplateExpression",
      value: function addStringTemplateExpression(expression) {
        // TODO: Use mustache or handlebars ?
        return new StringTemplateExpression(expression);
      }
    }, {
      key: "_execute",
      value: function _execute(tick) {
        // ENTER
        this._enter(tick);

        // OPEN
        if (!this.getOpenState(tick)) {
          this._open(tick);
        }

        // TICK
        var status = this._tick(tick);

        // CLOSE
        if (status === SUCCESS$1 || status === FAILURE || status === ABORT || status === ERROR$1) {
          this._close(tick);
        }

        // EXIT
        this._exit(tick);
        return status;
      }
    }, {
      key: "_enter",
      value: function _enter(tick) {
        tick._enterNode(this);
        this.enter(tick);
      }
    }, {
      key: "_open",
      value: function _open(tick) {
        tick._openNode(this);
        this.setOpenState(tick, true);
        this.open(tick);
      }
    }, {
      key: "_tick",
      value: function _tick(tick) {
        tick._tickNode(this);
        return this.tick(tick);
      }
    }, {
      key: "_close",
      value: function _close(tick) {
        tick._closeNode(this);
        this.setOpenState(tick, false);
        this.close(tick);
        // Children will be closed before parent, otherwise abort children
        this.abortChildren(tick);
      }
    }, {
      key: "_exit",
      value: function _exit(tick) {
        tick._exitNode(this);
        this.exit(tick);
      }
    }, {
      key: "_abort",
      value: function _abort(tick) {
        this._close(tick);
        this.abort(tick);
      }
    }, {
      key: "enter",
      value: function enter(tick) {}
    }, {
      key: "open",
      value: function open(tick) {}
    }, {
      key: "tick",
      value: function tick(_tick2) {}
    }, {
      key: "close",
      value: function close(tick) {}
    }, {
      key: "exit",
      value: function exit(tick) {}
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {}
    }, {
      key: "abort",
      value: function abort(tick) {}

      // open state of this node
    }, {
      key: "getNodeMemory",
      value: function getNodeMemory(tick) {
        return tick.getNodeMemory(this.id);
      }
    }, {
      key: "getOpenState",
      value: function getOpenState(tick) {
        return this.getNodeMemory(tick).$isOpen;
      }
    }, {
      key: "setOpenState",
      value: function setOpenState(tick, state) {
        if (state === undefined) {
          state = true;
        }
        this.getNodeMemory(tick).$isOpen = state;
        return this;
      }

      // Return state value
    }, {
      key: "SUCCESS",
      get: function get() {
        return SUCCESS$1;
      }
    }, {
      key: "FAILURE",
      get: function get() {
        return FAILURE;
      }
    }, {
      key: "RUNNING",
      get: function get() {
        return RUNNING$1;
      }
    }, {
      key: "ERROR",
      get: function get() {
        return ERROR$1;
      }
    }]);
    return BaseNode;
  }();

  var Action = /*#__PURE__*/function (_BaseNode) {
    _inherits(Action, _BaseNode);
    function Action() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Action' : _ref$name,
        title = _ref.title,
        properties = _ref.properties,
        services = _ref.services;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Action);
      _this = _callSuper(this, Action, [{
        category: ACTION,
        name: name,
        title: title,
        properties: properties
      }]);
      if (services) {
        for (var i = 0, cnt = services.length; i < cnt; i++) {
          _this.addService(services[i], nodePool);
        }
      }
      return _this;
    }
    _createClass(Action, [{
      key: "addService",
      value: function addService(node, nodePool) {
        if (typeof node === 'string') {
          // Node ID
          node = nodePool[node];
        }
        if (this.services === undefined) {
          this.services = [];
        }
        if (this.services.indexOf(node) === -1) {
          this.services.push(node);
          node.setParent(this);
        }
        return this;
      }
    }, {
      key: "_tick",
      value: function _tick(tick) {
        tick._tickNode(this);
        if (this.services) {
          for (var i = 0, cnt = this.services.length; i < cnt; i++) {
            this.services[i]._tick(tick);
          }
        }
        return this.tick(tick);
      }
    }]);
    return Action;
  }(BaseNode);

  var Composite = /*#__PURE__*/function (_BaseNode) {
    _inherits(Composite, _BaseNode);
    function Composite() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Composite' : _ref$name,
        title = _ref.title,
        properties = _ref.properties,
        services = _ref.services;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Composite);
      _this = _callSuper(this, Composite, [{
        category: COMPOSITE,
        name: name,
        title: title,
        properties: properties
      }]);
      _this.children = [];
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        _this.addChild(children[i], nodePool);
      }
      if (services) {
        for (var i = 0, cnt = services.length; i < cnt; i++) {
          _this.addService(services[i], nodePool);
        }
      }
      return _this;
    }
    _createClass(Composite, [{
      key: "insertChild",
      value: function insertChild(node, nodePool, index) {
        if (typeof node === 'string') {
          // Node ID
          node = nodePool[node];
        }
        if (this.children.indexOf(node) === -1) {
          if (index < 0) {
            index = this.children.length + index;
          }
          if (index === undefined || index >= this.children.length) {
            this.children.push(node);
          } else {
            this.children.splice(index, 0, node);
          }
          node.setParent(this);
        }
        return this;
      }
    }, {
      key: "addChild",
      value: function addChild(node, nodePool) {
        this.insertChild(node, nodePool);
        return this;
      }
    }, {
      key: "addService",
      value: function addService(node, nodePool) {
        if (typeof node === 'string') {
          // Node ID
          node = nodePool[node];
        }
        if (this.services === undefined) {
          this.services = [];
        }
        if (this.services.indexOf(node) === -1) {
          this.services.push(node);
          node.setParent(this);
        }
        return this;
      }
    }, {
      key: "_tick",
      value: function _tick(tick) {
        tick._tickNode(this);
        if (this.services) {
          for (var i = 0, cnt = this.services.length; i < cnt; i++) {
            this.services[i]._tick(tick);
          }
        }
        return this.tick(tick);
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
          var childNode = this.children[i];
          if (childNode.getOpenState(tick)) {
            childNode._abort(tick);
          }
        }
      }
    }]);
    return Composite;
  }(BaseNode);

  var Decorator = /*#__PURE__*/function (_BaseNode) {
    _inherits(Decorator, _BaseNode);
    function Decorator() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Decorator' : _ref$name,
        title = _ref.title,
        properties = _ref.properties;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Decorator);
      _this = _callSuper(this, Decorator, [{
        category: DECORATOR,
        name: name,
        title: title,
        properties: properties
      }]);
      _this.child = null;
      if (child) {
        _this.addChild(child, nodePool);
      }
      return _this;
    }
    _createClass(Decorator, [{
      key: "addChild",
      value: function addChild(node, nodePool) {
        if (typeof node === 'string') {
          // Node ID
          node = nodePool[node];
        }
        this.child = node;
        node.setParent(this);
        return this;
      }
    }, {
      key: "isChildRunning",
      value: function isChildRunning(tick) {
        return this.child.getOpenState(tick);
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        if (this.isChildRunning(tick)) {
          this.child._abort(tick);
        }
      }
    }, {
      key: "openChild",
      value: function openChild(tick) {
        this.child.setOpenState(tick, true);
        return this;
      }
    }]);
    return Decorator;
  }(BaseNode);

  var Service = /*#__PURE__*/function (_BaseNode) {
    _inherits(Service, _BaseNode);
    function Service() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$interval = _ref.interval,
        interval = _ref$interval === void 0 ? 0 : _ref$interval,
        _ref$randomDeviation = _ref.randomDeviation,
        randomDeviation = _ref$randomDeviation === void 0 ? 0 : _ref$randomDeviation,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Service' : _ref$name,
        title = _ref.title,
        properties = _ref.properties;
      _classCallCheck(this, Service);
      if (properties === undefined) {
        properties = {};
      }
      properties.interval = interval;
      properties.randomDeviation = randomDeviation;
      _this = _callSuper(this, Service, [{
        category: SERVICE,
        name: name,
        title: title,
        properties: properties
      }]);
      _this.intervalExpression = _this.addExpression(interval);
      _this.randomDeviationExpression = _this.addExpression(randomDeviation);
      return _this;
    }
    _createClass(Service, [{
      key: "_tick",
      value: function _tick(tick) {
        if (this.canTick(tick)) {
          this.tick(tick);
        }
      }
    }, {
      key: "canTick",
      value: function canTick(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var currTime = tick.currentTime;
        var lastEndTime = nodeMemory.$lastEndTime;
        var interval = nodeMemory.$interval;
        var canTick = lastEndTime === undefined || currTime - lastEndTime >= interval;
        if (canTick) {
          nodeMemory.$lastEndTime = currTime;
          var interval = tick.evalExpression(this.intervalExpression);
          var randomDeviation = tick.evalExpression(this.randomDeviationExpression);
          if (randomDeviation > 0) {
            interval += (0.5 - Math.random()) * randomDeviation;
          }
          nodeMemory.$interval = interval;
        }
        return canTick;
      }
    }]);
    return Service;
  }(BaseNode);

  var Succeeder = /*#__PURE__*/function (_Action) {
    _inherits(Succeeder, _Action);
    function Succeeder() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Succeeder' : _ref$name;
      _classCallCheck(this, Succeeder);
      return _callSuper(this, Succeeder, [{
        services: services,
        title: title,
        name: name
      }]);
    }
    _createClass(Succeeder, [{
      key: "tick",
      value: function tick(_tick) {
        return SUCCESS$1;
      }
    }]);
    return Succeeder;
  }(Action);

  var Failer = /*#__PURE__*/function (_Action) {
    _inherits(Failer, _Action);
    function Failer() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Failer' : _ref$name;
      _classCallCheck(this, Failer);
      return _callSuper(this, Failer, [{
        services: services,
        title: title,
        name: name
      }]);
    }
    _createClass(Failer, [{
      key: "tick",
      value: function tick(_tick) {
        return FAILURE;
      }
    }]);
    return Failer;
  }(Action);

  var Runner = /*#__PURE__*/function (_Action) {
    _inherits(Runner, _Action);
    function Runner() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Runner' : _ref$name;
      _classCallCheck(this, Runner);
      return _callSuper(this, Runner, [{
        services: services,
        title: title,
        name: name
      }]);
    }
    _createClass(Runner, [{
      key: "tick",
      value: function tick(_tick) {
        return RUNNING$1;
      }
    }]);
    return Runner;
  }(Action);

  var Error$1 = /*#__PURE__*/function (_Action) {
    _inherits(Error, _Action);
    function Error() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Error' : _ref$name;
      _classCallCheck(this, Error);
      return _callSuper(this, Error, [{
        services: services,
        title: title,
        name: name
      }]);
    }
    _createClass(Error, [{
      key: "tick",
      value: function tick(_tick) {
        return ERROR$1;
      }
    }]);
    return Error;
  }(Action);

  var Wait$3 = /*#__PURE__*/function (_Action) {
    _inherits(Wait, _Action);
    function Wait() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 0 : _ref$duration,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Wait' : _ref$name;
      _classCallCheck(this, Wait);
      _this = _callSuper(this, Wait, [{
        title: title,
        name: name,
        properties: {
          duration: duration
        },
        services: services
      }]);
      _this.durationExpression = _this.addExpression(duration);
      return _this;
    }
    _createClass(Wait, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$startTime = tick.currentTime;
        nodeMemory.$duration = tick.evalExpression(this.durationExpression);
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        var nodeMemory = this.getNodeMemory(_tick);
        var currTime = _tick.currentTime;
        var startTime = nodeMemory.$startTime;
        var duration = nodeMemory.$duration;
        if (duration > 0) {
          if (currTime - startTime < duration) {
            return RUNNING$1;
          }
        } else if (duration === 0) {
          // Wait 1 tick            
          if (currTime === startTime) {
            return RUNNING$1;
          }
        }
        return SUCCESS$1;
      }
    }]);
    return Wait;
  }(Action);

  var Abort = /*#__PURE__*/function (_Action) {
    _inherits(Abort, _Action);
    function Abort() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Abort' : _ref$name;
      _classCallCheck(this, Abort);
      return _callSuper(this, Abort, [{
        services: services,
        title: title,
        name: name
      }]);
    }
    _createClass(Abort, [{
      key: "tick",
      value: function tick(_tick) {
        return ABORT;
      }
    }]);
    return Abort;
  }(Action);

  var Selector = /*#__PURE__*/function (_Composite) {
    _inherits(Selector, _Composite);
    function Selector() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Selector' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Selector);
      return _callSuper(this, Selector, [{
        children: children,
        services: services,
        title: title,
        name: name
      }, nodePool]);
    }
    _createClass(Selector, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$runningChild = -1; // No running child
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (this.children.length === 0) {
          return ERROR$1;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var childIndex = nodeMemory.$runningChild;
        var status;
        if (childIndex < 0) {
          for (var i = 0, cnt = this.children.length; i < cnt; i++) {
            status = this.children[i]._execute(_tick);
            if (status === RUNNING$1 || status === SUCCESS$1 || status === ABORT) {
              childIndex = i;
              break;
            }
          }
        } else {
          var child = this.children[childIndex];
          status = child._execute(_tick);
        }
        nodeMemory.$runningChild = status === RUNNING$1 ? childIndex : -1;
        return status;
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var child = this.children[nodeMemory.$runningChild];
        if (child) {
          child._abort(tick);
          nodeMemory.$runningChild = -1;
        }
      }
    }]);
    return Selector;
  }(Composite);

  var Sequence = /*#__PURE__*/function (_Composite) {
    _inherits(Sequence, _Composite);
    function Sequence() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Sequence' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Sequence);
      return _callSuper(this, Sequence, [{
        children: children,
        services: services,
        title: title,
        name: name
      }, nodePool]);
    }
    _createClass(Sequence, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$runningChild = 0;
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (this.children.length === 0) {
          return ERROR$1;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var childIndex = nodeMemory.$runningChild;
        var status;
        for (var i = childIndex, cnt = this.children.length; i < cnt; i++) {
          status = this.children[i]._execute(_tick);
          if (status === RUNNING$1 || status === FAILURE || status === ABORT) {
            break;
          }
        }
        nodeMemory.$runningChild = status === RUNNING$1 ? i : -1;
        return status;
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var child = this.children[nodeMemory.$runningChild];
        if (child) {
          child._abort(tick);
          nodeMemory.$runningChild = -1;
        }
      }
    }]);
    return Sequence;
  }(Composite);

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  /**
   * Removes a single item from an array and returns it without creating gc, like the native splice does.
   * Based on code by Mike Reinstein.
   *
   * @function Phaser.Utils.Array.SpliceOne
   * @since 3.0.0
   *
   * @param {array} array - The array to splice from.
   * @param {integer} index - The index of the item which should be spliced.
   *
   * @return {*} The item which was spliced (removed).
   */
  var SpliceOne$3 = function SpliceOne(array, index) {
    if (index >= array.length) {
      return;
    }
    var len = array.length - 1;
    var item = array[index];
    for (var i = index; i < len; i++) {
      array[i] = array[i + 1];
    }
    array.length = len;
    return item;
  };

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */


  /**
   * Removes the given item, or array of items, from the array.
   * 
   * The array is modified in-place.
   * 
   * You can optionally specify a callback to be invoked for each item successfully removed from the array.
   *
   * @function Phaser.Utils.Array.Remove
   * @since 3.4.0
   *
   * @param {array} array - The array to be modified.
   * @param {*|Array.<*>} item - The item, or array of items, to be removed from the array.
   * @param {function} [callback] - A callback to be invoked for each item successfully removed from the array.
   * @param {object} [context] - The context in which the callback is invoked.
   *
   * @return {*|Array.<*>} The item, or array of items, that were successfully removed from the array.
   */
  var Remove$4 = function Remove(array, item, callback, context) {
    if (context === undefined) {
      context = array;
    }
    var index;

    //  Fast path to avoid array mutation and iteration
    if (!Array.isArray(item)) {
      index = array.indexOf(item);
      if (index !== -1) {
        SpliceOne$3(array, index);
        if (callback) {
          callback.call(context, item);
        }
        return item;
      } else {
        return null;
      }
    }

    //  If we got this far, we have an array of items to remove

    var itemLength = item.length - 1;
    while (itemLength >= 0) {
      var entry = item[itemLength];
      index = array.indexOf(entry);
      if (index !== -1) {
        SpliceOne$3(array, index);
        if (callback) {
          callback.call(context, entry);
        }
      } else {
        //  Item wasn't found in the array, so remove it from our return results
        item.pop();
      }
      itemLength--;
    }
    return item;
  };

  var Parallel = /*#__PURE__*/function (_Composite) {
    _inherits(Parallel, _Composite);
    function Parallel() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$finishMode = _ref.finishMode,
        finishMode = _ref$finishMode === void 0 ? 0 : _ref$finishMode,
        _ref$returnSuccess = _ref.returnSuccess,
        returnSuccess = _ref$returnSuccess === void 0 ? true : _ref$returnSuccess,
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Parallel' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Parallel);
      _this = _callSuper(this, Parallel, [{
        children: children,
        services: services,
        title: title,
        name: name,
        properties: {
          finishMode: finishMode,
          returnSuccess: returnSuccess
        }
      }, nodePool]);
      _this.finishMode = finishMode;
      _this.returnSuccess = returnSuccess;
      return _this;
    }
    _createClass(Parallel, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$runningChildren = this.children.map(function (child, index) {
          return index;
        });
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (this.children.length === 0) {
          return ERROR$1;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var childIndexes = nodeMemory.$runningChildren;
        var statusMap = {};
        var hasAnyFinishStatus = false;
        var hasAnyRunningStatus = false;
        var hasAnyAbortStatus = false;
        var hasAnyErrorStatus = false;
        for (var i = 0, cnt = childIndexes.length; i < cnt; i++) {
          var childIndex = childIndexes[i];
          var status = this.children[childIndex]._execute(_tick);
          statusMap[childIndex] = status;
          if (childIndex === 0) {
            nodeMemory.$mainTaskStatus = status;
          }
          switch (status) {
            case SUCCESS$1:
            case FAILURE:
              hasAnyFinishStatus = true;
              break;
            case RUNNING$1:
              hasAnyRunningStatus = true;
              break;
            case ABORT:
              hasAnyAbortStatus = true;
              break;
            case ERROR$1:
              hasAnyErrorStatus = true;
              break;
          }
        }

        // Clear none-running child
        if (hasAnyFinishStatus) {
          for (var childIndex in statusMap) {
            var status = statusMap[childIndex];
            if (status === SUCCESS$1 || status === FAILURE) {
              Remove$4(childIndexes, parseInt(childIndex));
            }
          }
        }
        if (this.finishMode === 0) {
          return nodeMemory.$mainTaskStatus;
        } else {
          if (hasAnyErrorStatus) {
            return ERROR$1;
          } else if (hasAnyAbortStatus) {
            return ABORT;
          } else if (hasAnyRunningStatus) {
            return RUNNING$1;
          } else if (this.returnSuccess) {
            return SUCCESS$1;
          } else {
            return nodeMemory.$mainTaskStatus;
          }
        }
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var childIndexes = nodeMemory.$runningChildren;
        for (var i = 0, cnt = childIndexes.length; i < cnt; i++) {
          var childIndex = childIndexes[i];
          this.children[childIndex]._abort(tick);
        }
        nodeMemory.$runningChildren.length = 0;
      }
    }]);
    return Parallel;
  }(Composite);

  var IfSelector = /*#__PURE__*/function (_Composite) {
    _inherits(IfSelector, _Composite);
    function IfSelector() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$expression = _ref.expression,
        expression = _ref$expression === void 0 ? 'true' : _ref$expression,
        _ref$conditionEvalBre = _ref.conditionEvalBreak,
        conditionEvalBreak = _ref$conditionEvalBre === void 0 ? false : _ref$conditionEvalBre,
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'IfSelector' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, IfSelector);
      _this = _callSuper(this, IfSelector, [{
        children: children,
        services: services,
        title: title,
        name: name,
        properties: {
          expression: expression,
          conditionEvalBreak: conditionEvalBreak
        }
      }, nodePool]);
      _this.expression = _this.addBooleanExpression(expression);
      _this.conditionEvalBreak = conditionEvalBreak;
      _this.forceSelectChildIndex = undefined;
      return _this;
    }
    _createClass(IfSelector, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$runningChild = -1; // No running child
      }
    }, {
      key: "setSelectChildIndex",
      value: function setSelectChildIndex(index) {
        this.forceSelectChildIndex = index;
        return this;
      }
    }, {
      key: "evalCondition",
      value: function evalCondition(tick) {
        if (this.forceSelectChildIndex !== undefined) {
          return this.forceSelectChildIndex;
        }
        return tick.evalExpression(this.expression) ? 0 : 1;
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (this.children.length === 0) {
          return ERROR$1;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var childIndex = nodeMemory.$runningChild;
        if (childIndex < 0) {
          childIndex = this.evalCondition(_tick);
          if (this.conditionEvalBreak) {
            // Resolve runningChild index, but not run child now
            nodeMemory.$runningChild = childIndex;
            return RUNNING$1;
          }
        }
        var child = this.children[childIndex];
        var status = child._execute(_tick);
        nodeMemory.$runningChild = status === RUNNING$1 ? childIndex : -1;
        return status;
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var child = this.children[nodeMemory.$runningChild];
        if (child) {
          child._abort(tick);
          nodeMemory.$runningChild = -1;
        }
      }
    }]);
    return IfSelector;
  }(Composite);

  var SwitchSelector = /*#__PURE__*/function (_Composite) {
    _inherits(SwitchSelector, _Composite);
    function SwitchSelector() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$expression = _ref.expression,
        expression = _ref$expression === void 0 ? null : _ref$expression,
        _ref$keys = _ref.keys,
        keys = _ref$keys === void 0 ? undefined : _ref$keys,
        _ref$conditionEvalBre = _ref.conditionEvalBreak,
        conditionEvalBreak = _ref$conditionEvalBre === void 0 ? false : _ref$conditionEvalBre,
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? {} : _ref$children,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'SwitchSelector' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, SwitchSelector);
      if (keys === undefined) {
        keys = Object.keys(children);
        children = Object.values(children);
      }
      _this = _callSuper(this, SwitchSelector, [{
        children: children,
        services: services,
        title: title,
        name: name,
        properties: {
          expression: expression,
          keys: keys,
          conditionEvalBreak: conditionEvalBreak
        }
      }, nodePool]);
      _this.expression = _this.addExpression(expression);
      _this.keys = keys; // Index of children
      _this.conditionEvalBreak = conditionEvalBreak;
      _this.forceSelectChildIndex = undefined;
      return _this;
    }
    _createClass(SwitchSelector, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$runningChild = -1; // No running child
      }
    }, {
      key: "setSelectChildIndex",
      value: function setSelectChildIndex(index) {
        this.forceSelectChildIndex = index;
        return this;
      }
    }, {
      key: "evalCondition",
      value: function evalCondition(tick) {
        if (this.forceSelectChildIndex !== undefined) {
          if (typeof this.forceSelectChildIndex === 'number') {
            return this.forceSelectChildIndex;
          } else {
            return this.keys.indexOf(this.forceSelectChildIndex);
          }
        }
        var key = tick.evalExpression(this.expression);
        return this.keys.indexOf(key);
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (this.children.length === 0) {
          return ERROR$1;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var childIndex = nodeMemory.$runningChild;
        if (childIndex < 0) {
          childIndex = this.evalCondition(_tick);
          if (childIndex === -1) {
            childIndex = this.keys.indexOf('default');
          }
          if (childIndex === -1) {
            return ERROR$1;
          }
          if (this.conditionEvalBreak) {
            // Resolve runningChild index, but not run child now
            nodeMemory.$runningChild = childIndex;
            return RUNNING$1;
          }
        }
        var child = this.children[childIndex];
        var status = child._execute(_tick);
        nodeMemory.$runningChild = status === RUNNING$1 ? childIndex : -1;
        return status;
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var child = this.children[nodeMemory.$runningChild];
        if (child) {
          child._abort(tick);
          nodeMemory.$runningChild = -1;
        }
      }
    }]);
    return SwitchSelector;
  }(Composite);

  var WeightSelector = /*#__PURE__*/function (_Composite) {
    _inherits(WeightSelector, _Composite);
    function WeightSelector() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$expression = _ref.expression,
        expression = _ref$expression === void 0 ? null : _ref$expression,
        _ref$weights = _ref.weights,
        weights = _ref$weights === void 0 ? undefined : _ref$weights,
        _ref$conditionEvalBre = _ref.conditionEvalBreak,
        conditionEvalBreak = _ref$conditionEvalBre === void 0 ? false : _ref$conditionEvalBre,
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'WeightSelector' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, WeightSelector);
      if (weights === undefined) {
        weights = [];
        var totalWeight = 0;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          var child = children[i];
          var weight;
          if (child instanceof BaseNode || typeof child === 'string') {
            weight = 1;
          } else {
            weight = child.weight;
            children[i] = child.node;
          }
          weights.push(weight);
          totalWeight += weight;
        }
        for (var i = 0, cnt = weights.length; i < cnt; i++) {
          weights[i] /= totalWeight;
        }
      }
      _this = _callSuper(this, WeightSelector, [{
        children: children,
        services: services,
        title: title,
        name: name,
        properties: {
          expression: expression,
          weights: weights,
          conditionEvalBreak: conditionEvalBreak
        }
      }, nodePool]);
      _this.expression = expression ? _this.addExpression(expression) : null;
      _this.weights = weights;
      _this.conditionEvalBreak = conditionEvalBreak;
      _this.forceSelectChildIndex = undefined;
      return _this;
    }
    _createClass(WeightSelector, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$runningChild = -1; // No running child
      }
    }, {
      key: "setSelectChildIndex",
      value: function setSelectChildIndex(index) {
        if (this.forceSelectChildIndex !== undefined) {
          return this.forceSelectChildIndex;
        }
        this.forceSelectChildIndex = index;
        return this;
      }
    }, {
      key: "evalCondition",
      value: function evalCondition(tick) {
        if (this.forceSelectChildIndex !== undefined) {
          return this.forceSelectChildIndex;
        }
        var value = this.expression ? tick.evalExpression(this.expression) : Math.random();
        for (var i = 0, cnt = this.weights.length; i < cnt; i++) {
          value -= this.weights[i];
          if (value < 0) {
            return i;
          }
        }
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (this.children.length === 0) {
          return ERROR$1;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var childIndex = nodeMemory.$runningChild;
        if (childIndex < 0) {
          childIndex = this.evalCondition(_tick);
          if (childIndex === undefined) {
            childIndex = this.children.length - 1;
          }
          if (this.conditionEvalBreak) {
            // Resolve runningChild index, but not run child now
            nodeMemory.$runningChild = childIndex;
            return RUNNING$1;
          }
        }
        var child = this.children[childIndex];
        var status = child._execute(_tick);
        nodeMemory.$runningChild = status === RUNNING$1 ? childIndex : -1;
        return status;
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var child = this.children[nodeMemory.$runningChild];
        if (child) {
          child._abort(tick);
          nodeMemory.$runningChild = -1;
        }
      }
    }]);
    return WeightSelector;
  }(Composite);

  var RandomSelector = /*#__PURE__*/function (_Composite) {
    _inherits(RandomSelector, _Composite);
    function RandomSelector() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'RandomSelector' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, RandomSelector);
      return _callSuper(this, RandomSelector, [{
        children: children,
        services: services,
        title: title,
        name: name
      }, nodePool]);
    }
    _createClass(RandomSelector, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$runningChild = -1; // No running child
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (this.children.length === 0) {
          return ERROR;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var childIndex = nodeMemory.$runningChild;
        if (childIndex < 0) {
          childIndex = Math.floor(Math.random() * this.children.length);
        }
        var child = this.children[childIndex];
        var status = child._execute(_tick);
        nodeMemory.$runningChild = status === RUNNING ? childIndex : -1;
        return status;
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var child = this.children[nodeMemory.$runningChild];
        if (child) {
          child._abort(tick);
          nodeMemory.$runningChild = -1;
        }
      }
    }]);
    return RandomSelector;
  }(Composite);

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  /**
   * Shuffles the contents of the given array using the Fisher-Yates implementation.
   *
   * The original array is modified directly and returned.
   *
   * @function Phaser.Utils.Array.Shuffle
   * @since 3.0.0
   *
   * @param {array} array - The array to shuffle. This array is modified in place.
   *
   * @return {array} The shuffled array.
   */
  var Shuffle = function Shuffle(array) {
    for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
    return array;
  };

  var ShuffleSelector = /*#__PURE__*/function (_Composite) {
    _inherits(ShuffleSelector, _Composite);
    function ShuffleSelector() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? [] : _ref$children,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'ShuffleSelector' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, ShuffleSelector);
      return _callSuper(this, ShuffleSelector, [{
        children: children,
        services: services,
        title: title,
        name: name
      }, nodePool]);
    }
    _createClass(ShuffleSelector, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$runningChild = 0;
        if (!nodeMemory.$children) {
          nodeMemory.$children = this.children.map(function (child, index) {
            return index;
          });
        }
        Shuffle(nodeMemory.$children);
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (this.children.length === 0) {
          return ERROR$1;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var childIndex = nodeMemory.$runningChild;
        var children = nodeMemory.$children;
        var status;
        for (var i = childIndex, cnt = children.length; i < cnt; i++) {
          status = this.children[children[i]]._execute(_tick);
          if (status === RUNNING$1 || status === SUCCESS$1 || status === ABORT) {
            break;
          }
        }
        nodeMemory.$runningChild = status === RUNNING$1 ? i : -1;
        return status;
      }
    }, {
      key: "abortChildren",
      value: function abortChildren(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        var child = this.children[nodeMemory.$runningChild];
        if (child) {
          child._abort(tick);
          nodeMemory.$runningChild = -1;
        }
      }
    }]);
    return ShuffleSelector;
  }(Composite);

  var Bypass = /*#__PURE__*/function (_Decorator) {
    _inherits(Bypass, _Decorator);
    function Bypass() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Bypass' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Bypass);
      return _callSuper(this, Bypass, [{
        child: child,
        title: title,
        name: name
      }, nodePool]);
    }
    _createClass(Bypass, [{
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // Won't abort child
        var status = this.child._execute(_tick);
        return status;
      }
    }]);
    return Bypass;
  }(Decorator);

  var ForceSuccess = /*#__PURE__*/function (_Decorator) {
    _inherits(ForceSuccess, _Decorator);
    function ForceSuccess() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'ForceSuccess' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, ForceSuccess);
      return _callSuper(this, ForceSuccess, [{
        child: child,
        title: title,
        name: name,
        properties: {}
      }, nodePool]);
    }
    _createClass(ForceSuccess, [{
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }
        var status = this.child._execute(_tick);
        if (status === FAILURE) {
          return SUCCESS$1;
        }
        return status;
      }
    }]);
    return ForceSuccess;
  }(Decorator);

  var ForceFailure = /*#__PURE__*/function (_Decorator) {
    _inherits(ForceFailure, _Decorator);
    function ForceFailure() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'ForceFailure' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, ForceFailure);
      return _callSuper(this, ForceFailure, [{
        child: child,
        title: title,
        name: name,
        properties: {}
      }, nodePool]);
    }
    _createClass(ForceFailure, [{
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }
        var status = this.child._execute(_tick);
        if (status === SUCCESS$1) {
          return FAILURE;
        }
        return status;
      }
    }]);
    return ForceFailure;
  }(Decorator);

  var Invert = /*#__PURE__*/function (_Decorator) {
    _inherits(Invert, _Decorator);
    function Invert() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Invert' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Invert);
      return _callSuper(this, Invert, [{
        child: child,
        title: title,
        name: name
      }, nodePool]);
    }
    _createClass(Invert, [{
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }
        var status = this.child._execute(_tick);
        if (status === SUCCESS$1) {
          status = FAILURE;
        } else if (status === FAILURE) {
          status = SUCCESS$1;
        }
        return status;
      }
    }]);
    return Invert;
  }(Decorator);

  var TimeLimit = /*#__PURE__*/function (_Decorator) {
    _inherits(TimeLimit, _Decorator);
    function TimeLimit() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 0 : _ref$duration,
        _ref$returnSuccess = _ref.returnSuccess,
        returnSuccess = _ref$returnSuccess === void 0 ? true : _ref$returnSuccess,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'TimeLimit' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, TimeLimit);
      _this = _callSuper(this, TimeLimit, [{
        child: child,
        title: title,
        name: name,
        properties: {
          duration: duration,
          returnSuccess: returnSuccess
        }
      }, nodePool]);
      _this.durationExpression = _this.addExpression(duration);
      _this.returnSuccess = returnSuccess;
      return _this;
    }
    _createClass(TimeLimit, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$startTime = tick.currentTime;
        nodeMemory.$duration = tick.evalExpression(this.durationExpression);
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // Abort child when timeout
        var nodeMemory = this.getNodeMemory(_tick);
        var currTime = _tick.currentTime;
        var startTime = nodeMemory.$startTime;
        var duration = nodeMemory.$duration;
        if (currTime - startTime >= duration) {
          return this.returnSuccess ? SUCCESS : FAILURE;
        }
        var status = this.child._execute(_tick);
        return status;
      }
    }]);
    return TimeLimit;
  }(Decorator);

  var Cooldown$1 = /*#__PURE__*/function (_Decorator) {
    _inherits(Cooldown, _Decorator);
    function Cooldown() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 0 : _ref$duration,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Cooldown' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Cooldown);
      _this = _callSuper(this, Cooldown, [{
        child: child,
        title: title,
        name: name,
        properties: {
          duration: duration
        }
      }, nodePool]);
      _this.durationExpression = _this.addExpression(duration);
      return _this;
    }
    _createClass(Cooldown, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$cooldownTime = tick.evalExpression(this.durationExpression);
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // Won't abort child
        var nodeMemory = this.getNodeMemory(_tick);
        var currTime = _tick.currentTime;
        var lastEndTime = nodeMemory.$lastEndTime;
        var cooldownTime = nodeMemory.$cooldownTime;

        // Open child after cooldown timeout
        if (lastEndTime !== undefined && currTime - lastEndTime < cooldownTime) {
          return FAILURE;
        }
        var status = this.child._execute(_tick);
        if (status === SUCCESS$1 || status === FAILURE || status === ABORT) {
          nodeMemory.$lastEndTime = currTime;
        }
        return status;
      }
    }]);
    return Cooldown;
  }(Decorator);

  var Repeat = /*#__PURE__*/function (_Decorator) {
    _inherits(Repeat, _Decorator);
    function Repeat() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxLoop = _ref.maxLoop,
        maxLoop = _ref$maxLoop === void 0 ? -1 : _ref$maxLoop,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Repeat' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Repeat);
      _this = _callSuper(this, Repeat, [{
        child: child,
        title: title,
        name: name,
        properties: {
          maxLoop: maxLoop
        }
      }, nodePool]);
      _this.maxLoopExpression = _this.addExpression(maxLoop);
      return _this;
    }
    _createClass(Repeat, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$maxLoop = tick.evalExpression(this.maxLoopExpression);
        nodeMemory.$i = 0;
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }
        var nodeMemory = this.getNodeMemory(_tick);
        var maxLoop = nodeMemory.$maxLoop;
        var i = nodeMemory.$i;
        var status = SUCCESS$1;

        // Open child before exceed maxLoop
        // Execute child many times in a tick
        while (maxLoop < 0 || i < maxLoop) {
          status = this.child._execute(_tick);
          if (status === SUCCESS$1 || status === FAILURE) {
            i++;
          } else {
            break;
          }
        }
        nodeMemory.$i = i;
        return status;
      }
    }]);
    return Repeat;
  }(Decorator);

  var RepeatUntilFailure = /*#__PURE__*/function (_Decorator) {
    _inherits(RepeatUntilFailure, _Decorator);
    function RepeatUntilFailure() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxLoop = _ref.maxLoop,
        maxLoop = _ref$maxLoop === void 0 ? -1 : _ref$maxLoop,
        _ref$returnSuccess = _ref.returnSuccess,
        returnSuccess = _ref$returnSuccess === void 0 ? false : _ref$returnSuccess,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'RepeatUntilFailure' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, RepeatUntilFailure);
      _this = _callSuper(this, RepeatUntilFailure, [{
        child: child,
        title: title,
        name: name,
        properties: {
          returnSuccess: returnSuccess,
          maxLoop: maxLoop
        }
      }, nodePool]);
      _this.maxLoopExpression = _this.addExpression(maxLoop);
      _this.returnSuccess = returnSuccess;
      return _this;
    }
    _createClass(RepeatUntilFailure, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$maxLoop = tick.evalExpression(this.maxLoopExpression);
        nodeMemory.$i = 0;
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // Won't abort child
        var nodeMemory = this.getNodeMemory(_tick);
        var maxLoop = nodeMemory.$maxLoop;
        var i = nodeMemory.$i;
        var status = ERROR$1;

        // Open child before exceed maxLoop
        // Execute child many times in a tick
        while (maxLoop < 0 || i < maxLoop) {
          status = this.child._execute(_tick);
          if (status === SUCCESS$1) {
            i++;
          } else {
            break;
          }
        }
        nodeMemory.$i = i;
        if (status === this.FAILURE && this.returnSuccess) {
          status = SUCCESS$1;
        }
        return status;
      }
    }]);
    return RepeatUntilFailure;
  }(Decorator);

  var RepeatUntilSuccess = /*#__PURE__*/function (_Decorator) {
    _inherits(RepeatUntilSuccess, _Decorator);
    function RepeatUntilSuccess() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxLoop = _ref.maxLoop,
        maxLoop = _ref$maxLoop === void 0 ? -1 : _ref$maxLoop,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'RepeatUntilSuccess' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, RepeatUntilSuccess);
      _this = _callSuper(this, RepeatUntilSuccess, [{
        child: child,
        title: title,
        name: name,
        properties: {
          maxLoop: maxLoop
        }
      }, nodePool]);
      _this.maxLoopExpression = _this.addExpression(maxLoop);
      return _this;
    }
    _createClass(RepeatUntilSuccess, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$maxLoop = tick.evalExpression(this.maxLoopExpression);
        nodeMemory.$i = 0;
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // Won't abort child
        var nodeMemory = this.getNodeMemory(_tick);
        var maxLoop = nodeMemory.$maxLoop;
        var i = nodeMemory.$i;
        var status = ERROR$1;

        // Open child before exceed maxLoop
        // Execute child many times in a tick
        while (maxLoop < 0 || i < maxLoop) {
          status = this.child._execute(_tick);
          if (status === FAILURE) {
            i++;
          } else {
            break;
          }
        }
        nodeMemory.$i = i;
        return status;
      }
    }]);
    return RepeatUntilSuccess;
  }(Decorator);

  var Limiter = /*#__PURE__*/function (_Decorator) {
    _inherits(Limiter, _Decorator);
    function Limiter() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxLoop = _ref.maxLoop,
        maxLoop = _ref$maxLoop === void 0 ? 1 : _ref$maxLoop,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'Limiter' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Limiter);
      _this = _callSuper(this, Limiter, [{
        child: child,
        title: title,
        name: name,
        properties: {
          maxLoop: maxLoop
        }
      }, nodePool]);
      _this.maxLoopExpression = _this.addExpression(maxLoop);
      return _this;
    }
    _createClass(Limiter, [{
      key: "open",
      value: function open(tick) {
        var nodeMemory = this.getNodeMemory(tick);
        nodeMemory.$maxLoop = tick.evalExpression(this.maxLoopExpression);
        nodeMemory.$i = 0;
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // Won't abort child
        var nodeMemory = this.getNodeMemory(_tick);
        var maxLoop = nodeMemory.$maxLoop;
        var i = nodeMemory.$i;

        // Open child before exceed maxLoop
        // Execute child 1 time in a tick
        if (i >= maxLoop) {
          return FAILURE;
        }
        var status = this.child._execute(_tick);
        if (status === SUCCESS$1 || status === FAILURE) {
          nodeMemory.$i = i + 1;
        }
        return status;
      }
    }]);
    return Limiter;
  }(Decorator);

  var If = /*#__PURE__*/function (_Decorator) {
    _inherits(If, _Decorator);
    function If() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$expression = _ref.expression,
        expression = _ref$expression === void 0 ? 'true' : _ref$expression,
        _ref$conditionEvalBre = _ref.conditionEvalBreak,
        conditionEvalBreak = _ref$conditionEvalBre === void 0 ? false : _ref$conditionEvalBre,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'If' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, If);
      _this = _callSuper(this, If, [{
        child: child,
        title: title,
        name: name,
        properties: {
          expression: expression,
          conditionEvalBreak: conditionEvalBreak
        }
      }, nodePool]);
      _this.expression = _this.addBooleanExpression(expression);
      _this.conditionEvalBreak = conditionEvalBreak;
      return _this;
    }
    _createClass(If, [{
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // child is not running
        if (!this.isChildRunning(_tick)) {
          // Return FAILURE to run next node
          if (!_tick.evalExpression(this.expression)) {
            return FAILURE;
          } else if (this.conditionEvalBreak) {
            // Open child but not run it now
            this.openChild();
            return RUNNING;
          }
        }
        var status = this.child._execute(_tick);
        return status;
      }
    }]);
    return If;
  }(Decorator);

  var ContinueIf = /*#__PURE__*/function (_Decorator) {
    _inherits(ContinueIf, _Decorator);
    function ContinueIf() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$expression = _ref.expression,
        expression = _ref$expression === void 0 ? 'true' : _ref$expression,
        _ref$returnSuccess = _ref.returnSuccess,
        returnSuccess = _ref$returnSuccess === void 0 ? true : _ref$returnSuccess,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'ContinueIf' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, ContinueIf);
      _this = _callSuper(this, ContinueIf, [{
        child: child,
        title: title,
        name: name,
        properties: {
          expression: expression,
          returnSuccess: returnSuccess
        }
      }, nodePool]);
      _this.expression = _this.addBooleanExpression(expression);
      _this.returnSuccess = returnSuccess;
      return _this;
    }
    _createClass(ContinueIf, [{
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // child is running
        if (this.isChildRunning(_tick)) {
          // Abort child if eval result is false
          if (!_tick.evalExpression(this.expression)) {
            return this.returnSuccess ? SUCCESS$1 : FAILURE;
          }
        }
        var status = this.child._execute(_tick);
        return status;
      }
    }]);
    return ContinueIf;
  }(Decorator);

  var AbortIf = /*#__PURE__*/function (_Decorator) {
    _inherits(AbortIf, _Decorator);
    function AbortIf() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$expression = _ref.expression,
        expression = _ref$expression === void 0 ? 'true' : _ref$expression,
        _ref$returnSuccess = _ref.returnSuccess,
        returnSuccess = _ref$returnSuccess === void 0 ? true : _ref$returnSuccess,
        _ref$child = _ref.child,
        child = _ref$child === void 0 ? null : _ref$child,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'AbortIf' : _ref$name;
      var nodePool = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, AbortIf);
      _this = _callSuper(this, AbortIf, [{
        child: child,
        title: title,
        name: name,
        properties: {
          expression: expression,
          returnSuccess: returnSuccess
        }
      }, nodePool]);
      _this.expression = _this.addBooleanExpression(expression);
      _this.returnSuccess = returnSuccess;
      return _this;
    }
    _createClass(AbortIf, [{
      key: "tick",
      value: function tick(_tick) {
        if (!this.child) {
          return ERROR$1;
        }

        // child is running
        if (this.isChildRunning(_tick)) {
          // Abort child if eval result is true
          if (_tick.evalExpression(this.expression)) {
            return this.returnSuccess ? SUCCESS$1 : FAILURE;
          }
        }
        var status = this.child._execute(_tick);
        return status;
      }
    }]);
    return AbortIf;
  }(Decorator);

  var Nodes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Abort: Abort,
    AbortIf: AbortIf,
    Action: Action,
    BaseNode: BaseNode,
    Bypass: Bypass,
    Composite: Composite,
    ContinueIf: ContinueIf,
    Cooldown: Cooldown$1,
    Decorator: Decorator,
    Error: Error$1,
    Failer: Failer,
    ForceFailure: ForceFailure,
    ForceSuccess: ForceSuccess,
    If: If,
    IfSelector: IfSelector,
    Invert: Invert,
    Limiter: Limiter,
    Parallel: Parallel,
    RandomSelector: RandomSelector,
    Repeat: Repeat,
    RepeatUntilFailure: RepeatUntilFailure,
    RepeatUntilSuccess: RepeatUntilSuccess,
    Runner: Runner,
    Selector: Selector,
    Sequence: Sequence,
    Service: Service,
    ShuffleSelector: ShuffleSelector,
    Succeeder: Succeeder,
    SwitchSelector: SwitchSelector,
    TimeLimit: TimeLimit,
    Wait: Wait$3,
    WeightSelector: WeightSelector
  });

  var Load = function Load(data, names) {
    var sn = data.sn;
    if (sn != null) {
      SetSerialNumber(Math.max(GetSerialNumber(), sn));
    }
    names = names || {};
    this.title = data.title || this.title;
    this.description = data.description || this.description;
    this.properties = data.properties || this.properties;
    var nodeData = data.nodes;
    var nodes = {};
    for (var i = nodeData.length - 1; i >= 0; i--) {
      // Create nodes from bottom to top
      var spec = nodeData[i],
        className = spec.name;
      var Cls;
      if (className in names) {
        // Look for the name in custom nodes
        Cls = names[className];
      } else if (className in Nodes) {
        // Look for the name in default nodes
        Cls = Nodes[className];
      } else {
        // Invalid node name
        throw new EvalError("BehaviorTree.load: Invalid node name \"".concat(className, "\"."));
      }
      var config = {};
      if (spec.hasOwnProperty('children')) {
        config.children = spec.children;
      }
      if (spec.hasOwnProperty('child')) {
        config.child = spec.child;
      }
      if (spec.hasOwnProperty('services')) {
        config.services = spec.services;
      }
      config = Object.assign(config, spec.properties);
      var node = new Cls(config, nodes);
      node.id = spec.id || node.id;
      node.title = spec.title || node.title;
      node.description = spec.description || node.description;
      node.properties = spec.properties || node.properties;
      nodes[node.id] = node;
    }
    this.root = nodes[data.root];
    return this;
  };

  var Tick = /*#__PURE__*/function () {
    function Tick() {
      _classCallCheck(this, Tick);
      // set by BehaviorTree

      this.tree = null;
      this.blackboard = null;
      this.target = null;

      // updated during the tick signal

      this._openNodes = []; // Open nodes of current tick

      this._nodeCount = 0;
      this._currentNode = null;
      this._currentTime = undefined;
    }

    // Set members
    _createClass(Tick, [{
      key: "setTree",
      value: function setTree(tree) {
        this.tree = tree;
        return this;
      }
    }, {
      key: "setBlackBoard",
      value: function setBlackBoard(blackboard) {
        this.blackboard = blackboard;
        return this;
      }
    }, {
      key: "setTarget",
      value: function setTarget(target) {
        this.target = target;
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        this._openNodes.length = 0;
        this._nodeCount = 0;
        this._currentTime = undefined;
        return this;
      }
    }, {
      key: "getGlobalMemory",
      value: function getGlobalMemory() {
        return this.blackboard.getGlobalMemory();
      }
    }, {
      key: "getTreeMemory",
      value: function getTreeMemory() {
        return this.blackboard.getTreeMemory(this.tree.id);
      }
    }, {
      key: "getNodeMemory",
      value: function getNodeMemory(nodeID) {
        return this.blackboard.getNodeMemory(this.tree.id, nodeID);
      }
    }, {
      key: "currentTime",
      get: function get() {
        if (this.blackboard.hasValidCurrentTime()) {
          // Inject current-time through blackboard
          return this.blackboard.getCurrentTime();
        } else {
          if (this._currentTime === undefined) {
            this._currentTime = new Date().getTime();
          }
          return this._currentTime;
        }
      }
    }, {
      key: "evalExpression",
      value: function evalExpression(expression) {
        return expression.eval(this.blackboard.getGlobalMemory());
      }
    }, {
      key: "_enterNode",
      value: function _enterNode(node) {
        this._nodeCount++;
        this._openNodes.push(node);
        this._currentNode = node;
      }
    }, {
      key: "_openNode",
      value: function _openNode(node) {
        this._currentNode = node;
      }
    }, {
      key: "_tickNode",
      value: function _tickNode(node) {
        this._currentNode = node;
      }
    }, {
      key: "_closeNode",
      value: function _closeNode(node) {
        Remove$4(this._openNodes, node);
        this._currentNode = node;
      }
    }, {
      key: "_exitNode",
      value: function _exitNode(node) {
        this._currentNode = node;
      }
    }]);
    return Tick;
  }();

  var BehaviorTree = /*#__PURE__*/function () {
    function BehaviorTree() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id,
        title = _ref.title,
        description = _ref.description,
        properties = _ref.properties,
        _ref$root = _ref.root,
        root = _ref$root === void 0 ? null : _ref$root;
      _classCallCheck(this, BehaviorTree);
      if (id === undefined) {
        id = CreateID();
      }
      this.id = id;
      this.category = TREE;
      this.title = title || '';
      this.description = description || '';
      this.properties = properties || {};
      this._root = root;
      this.ticker = new Tick().setTree(this);
    }
    _createClass(BehaviorTree, [{
      key: "setTitle",
      value: function setTitle(title) {
        this.title = title;
        return this;
      }
    }, {
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "setDescription",
      value: function setDescription(description) {
        this.description = description;
        return this;
      }
    }, {
      key: "setRoot",
      value: function setRoot(node) {
        this.root = node;
        return this;
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this.root;
      }
    }, {
      key: "root",
      get: function get() {
        return this._root;
      },
      set: function set(node) {
        if (node) {
          this._root = node;
          node.setParent(this);
        } else {
          if (this._root) {
            this._root.setParent(null);
          }
          this._root = null;
        }
      }
    }, {
      key: "forEachNode",
      value: function forEachNode(callback, scope) {
        BreadthFirstSearch$1(this.root, callback, scope);
        return this;
      }
    }, {
      key: "getAllNodes",
      value: function getAllNodes(out) {
        if (out === undefined) {
          out = [];
        }
        this.forEachNode(function (node) {
          out.push(node);
        });
        return out;
      }
    }, {
      key: "getChildrenNodes",
      value: function getChildrenNodes(parent, out) {
        if (parent === undefined) {
          parent = this.root;
        }
        if (out === undefined) {
          out = [];
        }
        BreadthFirstSearch$1(parent, function (node) {
          out.push(node);
        });
        return out;
      }
    }, {
      key: "tick",
      value: function tick(blackboard, target) {
        if (!blackboard) {
          throw 'The blackboard parameter is obligatory and must be an instance of Blackboard';
        }
        var ticker = this.ticker;
        ticker.setBlackBoard(blackboard).setTarget(target).reset();

        /* TICK NODE */
        var state = this.root._execute(ticker);

        /* POPULATE BLACKBOARD */
        // blackboard.set('$openNodes', ticker._openNodes.slice(0), this.id);
        // blackboard.set('$nodeCount', ticker._nodeCount, this.id);
        blackboard.set(TREE_STATE, state, this.id);
        return state;
      }
    }, {
      key: "abort",
      value: function abort(blackboard, target) {
        if (!blackboard) {
          throw 'The blackboard parameter is obligatory and must be an instance of Blackboard';
        }
        var ticker = this.ticker;
        ticker.setBlackBoard(blackboard).setTarget(target).reset();

        /* ABORT NODE */
        this.root.abortChildren(ticker);

        /* POPULATE BLACKBOARD */
        blackboard.set(TREE_STATE, IDLE$7, this.id);
        return IDLE$7;
      }
    }], [{
      key: "setStartIDValue",
      value: function setStartIDValue(value) {
        SetSerialNumber(value);
      }
    }, {
      key: "getSerialNumber",
      value: function getSerialNumber() {
        return GetSerialNumber();
      }
    }, {
      key: "setSerialIDPrefix",
      value: function setSerialIDPrefix(prefix) {
        SetSerialNumberPrefix(prefix);
      }
    }]);
    return BehaviorTree;
  }();
  var Methods$p = {
    dump: Dump,
    load: Load
  };
  Object.assign(BehaviorTree.prototype, Methods$p, DataMethods$4);

  var Blackboard$1 = /*#__PURE__*/function () {
    function Blackboard() {
      _classCallCheck(this, Blackboard);
      this._baseMemory = {};
      this._treeMemory = {};

      // Global memory : this._baseMemory
      // Tree memory : this._treeMemory[treeID]
      // Node memory : this._treeMemory[treeID].nodeMemory[nodeID]
    }
    _createClass(Blackboard, [{
      key: "_getTreeMemory",
      value: function _getTreeMemory(treeID) {
        if (!this._treeMemory[treeID]) {
          this._treeMemory[treeID] = {
            'nodeMemory': {}
          };
        }
        return this._treeMemory[treeID];
      }
    }, {
      key: "_getNodeMemory",
      value: function _getNodeMemory(treeMemory, nodeID) {
        var memory = treeMemory.nodeMemory;
        if (!memory[nodeID]) {
          memory[nodeID] = {};
        }
        return memory[nodeID];
      }
    }, {
      key: "_getMemory",
      value: function _getMemory(treeID, nodeID) {
        var memory;
        if (treeID !== undefined) {
          memory = this._getTreeMemory(treeID);
          if (nodeID !== undefined) {
            memory = this._getNodeMemory(memory, nodeID);
          }
        } else {
          memory = this._baseMemory;
        }
        return memory;
      }
    }, {
      key: "set",
      value: function set(key, value, treeID, nodeID) {
        var memory = this._getMemory(treeID, nodeID);
        memory[key] = value;
        return this;
      }
    }, {
      key: "setData",
      value: function setData(key, value, treeID, nodeID) {
        return this.set(key, value, treeID, nodeID);
      }
    }, {
      key: "get",
      value: function get(key, treeID, nodeID) {
        var memory = this._getMemory(treeID, nodeID);
        return memory[key];
      }
    }, {
      key: "getData",
      value: function getData(key, treeID, nodeID) {
        return this.get(key, treeID, nodeID);
      }
    }, {
      key: "has",
      value: function has(key, treeID, nodeID) {
        var memory;
        if (treeID !== undefined) {
          memory = this._treeMemory[treeID];
          if (memory && nodeID !== undefined) {
            memory = treeMemory.nodeMemory[nodeID];
          }
        } else {
          memory = this._baseMemory;
        }
        if (memory) {
          return memory.hasOwnProperty(key);
        } else {
          return false;
        }
      }
    }, {
      key: "hasData",
      value: function hasData(key, treeID, nodeID) {
        return this.has(key, treeID, nodeID);
      }
    }, {
      key: "inc",
      value: function inc(key, _inc, treeID, nodeID, startValue) {
        var newValue;
        if (!this.has(key, treeID, nodeID)) {
          if (startValue === undefined) {
            startValue = 0;
          }
          newValue = startValue;
        } else {
          newValue = this.get(key, treeID, nodeID) + _inc;
        }
        this.set(key, newValue, treeID, nodeID);
        return this;
      }
    }, {
      key: "incData",
      value: function incData(key, inc, treeID, nodeID, startValue) {
        return this.inc(key, inc, treeID, nodeID, startValue);
      }
    }, {
      key: "toggle",
      value: function toggle(key, treeID, nodeID, startValue) {
        var newValue;
        if (!this.has(key, treeID, nodeID)) {
          if (startValue === undefined) {
            startValue = false;
          }
          newValue = startValue;
        } else {
          newValue = !this.get(key, treeID, nodeID);
        }
        this.set(key, newValue, treeID, nodeID);
        return this;
      }
    }, {
      key: "toggleData",
      value: function toggleData(key, treeID, nodeID, startValue) {
        return this.toggle(key, treeID, nodeID, startValue);
      }
    }, {
      key: "removeTree",
      value: function removeTree(treeID) {
        if (this._treeMemory[treeID]) {
          delete this._treeMemory[treeID];
        }
        return this;
      }
    }, {
      key: "removeTreeData",
      value: function removeTreeData(treeID) {
        return this.removeTree(treeID);
      }
    }, {
      key: "removeNode",
      value: function removeNode(treeID, nodeID) {
        var treeMemory = this._treeMemory[treeID];
        if (treeMemory && treeMemory.nodeMemory[nodeID]) {
          delete treeMemory.nodeMemory[nodeID];
        }
        return this;
      }
    }, {
      key: "removeNodeData",
      value: function removeNodeData(treeID, nodeID) {
        return this.removeNode(treeID, nodeID);
      }
    }, {
      key: "getGlobalMemory",
      value: function getGlobalMemory() {
        return this._baseMemory;
      }
    }, {
      key: "getTreeMemory",
      value: function getTreeMemory(treeID) {
        return this._getTreeMemory(treeID);
      }
    }, {
      key: "getNodeMemory",
      value: function getNodeMemory(treeID, nodeID) {
        return this._getNodeMemory(this._getTreeMemory(treeID), nodeID);
      }
    }, {
      key: "dump",
      value: function dump() {
        return {
          base: DeepClone(this._baseMemory),
          tree: DeepClone(this._treeMemory)
        };
      }
    }, {
      key: "load",
      value: function load(data) {
        this._baseMemory = DeepClone(data.base);
        this._treeMemory = DeepClone(data.tree);
        return this;
      }
    }]);
    return Blackboard;
  }();

  var Blackboard = /*#__PURE__*/function (_Base) {
    _inherits(Blackboard, _Base);
    function Blackboard() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$currentTimeKey = _ref.currentTimeKey,
        currentTimeKey = _ref$currentTimeKey === void 0 ? '$currentTime' : _ref$currentTimeKey;
      _classCallCheck(this, Blackboard);
      _this = _callSuper(this, Blackboard);
      _this.currentTimeKey = currentTimeKey;
      return _this;
    }
    _createClass(Blackboard, [{
      key: "getTreeState",
      value: function getTreeState(treeID) {
        return this.get(TREE_STATE, treeID);
      }
    }, {
      key: "setTreeState",
      value: function setTreeState(treeID, state) {
        this.set(TREE_STATE, state, treeID);
        return this;
      }
    }, {
      key: "hasValidCurrentTime",
      value: function hasValidCurrentTime() {
        return this.has(this.currentTimeKey);
      }
    }, {
      key: "setCurrentTime",
      value: function setCurrentTime(time) {
        this.set(this.currentTimeKey, time);
        return this;
      }
    }, {
      key: "getCurrentTime",
      value: function getCurrentTime() {
        return this.get(this.currentTimeKey);
      }
    }, {
      key: "incCurrentTime",
      value: function incCurrentTime(time) {
        this.inc(this.currentTimeKey, time);
        return this;
      }
    }]);
    return Blackboard;
  }(Blackboard$1);

  var TreeMethods$1 = {
    getTree: function getTree(title) {
      var trees = this.trees;
      for (var i = 0, cnt = trees.length; i < cnt; i++) {
        var eventsheet = trees[i];
        if (eventsheet.title === title) {
          return eventsheet;
        }
      }
    },
    getTreeState: function getTreeState(eventsheet) {
      var treeID = typeof eventsheet === 'string' ? eventsheet : eventsheet.id;
      return this.blackboard.getTreeState(treeID);
    },
    getEventSheetTitleList: function getEventSheetTitleList(out) {
      if (out === undefined) {
        out = [];
      }
      this.trees.forEach(function (eventsheet) {
        out.push(eventsheet.title);
      });
      return out;
    }
  };

  var AddTreeMethods$2 = {
    addTree: function addTree(eventsheet) {
      this.trees.push(eventsheet);
      return this;
    }
  };

  var RemoveTreeMethods$2 = {
    removeAllEventSheets: function removeAllEventSheets() {
      this.trees.forEach(function (eventsheet) {
        this.blackboard.removeTreeData(eventsheet.id);
      }, this);
      this.trees.length = 0;
      this.pendingTrees.length = 0;
      return this;
    },
    removeEventSheet: function removeEventSheet(title) {
      var removedTrees = [];
      this.trees.forEach(function (eventsheet) {
        if (!eventsheet.title === title) {
          return;
        }
        var status = this.getTreeState(eventsheet);
        if (status === RUNNING) {
          // Can't remove RUNNING eventsheet
          return;
        }
        removedTrees.push(eventsheet);
        this.blackboard.removeTreeData(eventsheet.id);
      }, this);
      if (removedTrees.length > 0) {
        Remove$4(this.trees, removedTrees);
        Remove$4(this.pendingTrees, removedTrees);
      }
      return this;
    }
  };

  var TreeActiveStateMethods$1 = {
    getTreeActiveState: function getTreeActiveState(title) {
      var eventsheet = this.getTree(title);
      if (!eventsheet) {
        return null;
      }
      return eventsheet.active;
    },
    setTreeActiveState: function setTreeActiveState(title, active) {
      var eventsheet = this.getTree(title);
      if (eventsheet) {
        eventsheet.setActive(active);
      }
      return this;
    }
  };

  var TaskSequence = /*#__PURE__*/function (_Sequence) {
    _inherits(TaskSequence, _Sequence);
    function TaskSequence() {
      _classCallCheck(this, TaskSequence);
      return _callSuper(this, TaskSequence, arguments);
    }
    _createClass(TaskSequence, [{
      key: "open",
      value: function open(tick) {
        _get(_getPrototypeOf(TaskSequence.prototype), "open", this).call(this, tick);
        var blackboard = tick.blackboard;
        var treeManager = blackboard.treeManager;
        var eventsheet = tick.tree;
        var eventSheetGroup = eventsheet.eventSheetGroup;
        treeManager.emit('label.enter', this.title, eventsheet.title, eventSheetGroup.name, treeManager);
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        var status = _get(_getPrototypeOf(TaskSequence.prototype), "tick", this).call(this, _tick);
        // Turn FAILURE by SUCCESS
        if (status === FAILURE) {
          status = SUCCESS$1;
        }
        return status;
      }
    }, {
      key: "close",
      value: function close(tick) {
        _get(_getPrototypeOf(TaskSequence.prototype), "close", this).call(this, tick);
        var blackboard = tick.blackboard;
        var treeManager = blackboard.treeManager;
        var eventsheet = tick.tree;
        var eventSheetGroup = eventsheet.eventSheetGroup;
        treeManager.emit('label.exit', this.title, eventsheet.title, eventSheetGroup.name, treeManager);
      }
    }]);
    return TaskSequence;
  }(Sequence);

  var IsEventEmitter = function IsEventEmitter(obj) {
    if (obj && _typeof(obj) === 'object') {
      return !!obj.on;
    }
    return false;
  };

  /*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   */

  var objectToString = Object.prototype.toString;
  var isArray$1 = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction$1 (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray$1(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  /**
   * Safe way of detecting whether or not the given thing is a primitive and
   * whether it has the given property
   */
  function primitiveHasOwnProperty (primitive, propName) {
    return (
      primitive != null
      && typeof primitive !== 'object'
      && primitive.hasOwnProperty
      && primitive.hasOwnProperty(propName)
    );
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   *
   * Tokens for partials also contain two more elements: 1) a string value of
   * indendation prior to that tag and 2) the index of that tag on that line -
   * eg a value of 2 indicates the partial is the third tag on this line.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];
    var lineHasNonSpace = false;
    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?
    var indentation = '';  // Tracks indentation for tags that use it
    var tagIndex = 0;      // Stores a count of number of tags encountered on a line

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray$1(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
            indentation += chr;
          } else {
            nonSpace = true;
            lineHasNonSpace = true;
            indentation += ' ';
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n') {
            stripSpace();
            indentation = '';
            tagIndex = 0;
            lineHasNonSpace = false;
          }
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      if (type == '>') {
        token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];
      } else {
        token = [ type, value, start, scanner.pos ];
      }
      tagIndex++;
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    stripSpace();

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, intermediateValue, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          intermediateValue = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           *
           * In the case where dot notation is used, we consider the lookup
           * to be successful even if the last "object" in the path is
           * not actually an object but a primitive (e.g., a string, or an
           * integer), because it is sometimes useful to access a property
           * of an autoboxed primitive, such as the length of a string.
           **/
          while (intermediateValue != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = (
                hasProperty(intermediateValue, names[index])
                || primitiveHasOwnProperty(intermediateValue, names[index])
              );

            intermediateValue = intermediateValue[names[index++]];
          }
        } else {
          intermediateValue = context.view[name];

          /**
           * Only checking against `hasProperty`, which always returns `false` if
           * `context.view` is not an object. Deliberately omitting the check
           * against `primitiveHasOwnProperty` if dot notation is not used.
           *
           * Consider this example:
           * ```
           * Mustache.render("The length of a football field is {{#length}}{{length}}{{/length}}.", {length: "100 yards"})
           * ```
           *
           * If we were to check also against `primitiveHasOwnProperty`, as we do
           * in the dot notation case, then render call would return:
           *
           * "The length of a football field is 9."
           *
           * rather than the expected:
           *
           * "The length of a football field is 100 yards."
           **/
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit) {
          value = intermediateValue;
          break;
        }

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction$1(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.templateCache = {
      _cache: {},
      set: function set (key, value) {
        this._cache[key] = value;
      },
      get: function get (key) {
        return this._cache[key];
      },
      clear: function clear () {
        this._cache = {};
      }
    };
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    if (typeof this.templateCache !== 'undefined') {
      this.templateCache.clear();
    }
  };

  /**
   * Parses and caches the given `template` according to the given `tags` or
   * `mustache.tags` if `tags` is omitted,  and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.templateCache;
    var cacheKey = template + ':' + (tags || mustache.tags).join(':');
    var isCacheEnabled = typeof cache !== 'undefined';
    var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;

    if (tokens == undefined) {
      tokens = parseTemplate(template, tags);
      isCacheEnabled && cache.set(cacheKey, tokens);
    }
    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   *
   * If the optional `config` argument is given here, then it should be an
   * object with a `tags` attribute or an `escape` attribute or both.
   * If an array is passed, then it will be interpreted the same way as
   * a `tags` attribute on a `config` object.
   *
   * The `tags` attribute of a `config` object must be an array with two
   * string values: the opening and closing tags used in the template (e.g.
   * [ "<%", "%>" ]). The default is to mustache.tags.
   *
   * The `escape` attribute of a `config` object must be a function which
   * accepts a string as input and outputs a safely escaped string.
   * If an `escape` function is not provided, then an HTML-safe string
   * escaping function is used as the default.
   */
  Writer.prototype.render = function render (template, view, partials, config) {
    var tags = this.getConfigTags(config);
    var tokens = this.parse(template, tags);
    var context = (view instanceof Context) ? view : new Context(view, undefined);
    return this.renderTokens(tokens, context, partials, template, config);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, config);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context, config);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials, config);
    }

    if (!value) return;

    if (isArray$1(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
    } else if (isFunction$1(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray$1(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate, config);
  };

  Writer.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {
    var filteredIndentation = indentation.replace(/[^ \t]/g, '');
    var partialByNl = partial.split('\n');
    for (var i = 0; i < partialByNl.length; i++) {
      if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
        partialByNl[i] = filteredIndentation + partialByNl[i];
      }
    }
    return partialByNl.join('\n');
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials, config) {
    if (!partials) return;
    var tags = this.getConfigTags(config);

    var value = isFunction$1(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null) {
      var lineHasNonSpace = token[6];
      var tagIndex = token[5];
      var indentation = token[4];
      var indentedValue = value;
      if (tagIndex == 0 && indentation) {
        indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
      }
      var tokens = this.parse(indentedValue, tags);
      return this.renderTokens(tokens, context, partials, indentedValue, config);
    }
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context, config) {
    var escape = this.getConfigEscape(config) || mustache.escape;
    var value = context.lookup(token[1]);
    if (value != null)
      return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  Writer.prototype.getConfigTags = function getConfigTags (config) {
    if (isArray$1(config)) {
      return config;
    }
    else if (config && typeof config === 'object') {
      return config.tags;
    }
    else {
      return undefined;
    }
  };

  Writer.prototype.getConfigEscape = function getConfigEscape (config) {
    if (config && typeof config === 'object' && !isArray$1(config)) {
      return config.escape;
    }
    else {
      return undefined;
    }
  };

  var mustache = {
    name: 'mustache.js',
    version: '4.2.0',
    tags: [ '{{', '}}' ],
    clearCache: undefined,
    escape: undefined,
    parse: undefined,
    render: undefined,
    Scanner: undefined,
    Context: undefined,
    Writer: undefined,
    /**
     * Allows a user to override the default caching strategy, by providing an
     * object with set, get and clear methods. This can also be used to disable
     * the cache by setting it to the literal `undefined`.
     */
    set templateCache (cache) {
      defaultWriter.templateCache = cache;
    },
    /**
     * Gets the default or overridden caching object from the default writer.
     */
    get templateCache () {
      return defaultWriter.templateCache;
    }
  };

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view`, `partials`, and `config`
   * using the default writer.
   */
  mustache.render = function render (template, view, partials, config) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials, config);
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

  var TaskAction = /*#__PURE__*/function (_Action) {
    _inherits(TaskAction, _Action);
    function TaskAction(config) {
      var _this;
      _classCallCheck(this, TaskAction);
      // config: {name, parameters:{...} }        
      _this = _callSuper(this, TaskAction, [{
        name: 'TaskAction',
        title: config.name,
        properties: config
      }]);
      _this.isRunning = false;
      var sourceParameters = config.parameters;
      var taskParameters = {};
      for (var name in sourceParameters) {
        taskParameters[name] = CompileExpression(sourceParameters[name]);
      }
      _this.taskParameters = taskParameters;
      return _this;
    }
    _createClass(TaskAction, [{
      key: "open",
      value: function open(tick) {
        this.isRunning = false;
        var taskData = this.properties;
        var taskName = taskData.name;
        if (!taskName) {
          return;
        }
        var blackboard = tick.blackboard;
        var treeManager = blackboard.treeManager;
        var eventsheet = tick.tree;
        var eventSheetGroup = eventsheet.eventSheetGroup;
        var memory = treeManager.memory;
        var taskParameters = this.taskParameters;
        var parametersCopy = {};
        for (var name in taskParameters) {
          var value = taskParameters[name];
          if (typeof value === 'function') {
            value = value(memory);
          }
          parametersCopy[name] = value;
        }
        var commandExecutor = tick.target;
        var eventEmitter;
        var handler = commandExecutor[taskName];
        if (handler) {
          eventEmitter = handler.call(commandExecutor, parametersCopy, treeManager, eventsheet);
        } else {
          handler = commandExecutor.defaultHandler;
          if (handler) {
            eventEmitter = handler.call(commandExecutor, taskName, parametersCopy, treeManager, eventsheet);
          }
        }
        if (IsEventEmitter(eventEmitter)) {
          this.isRunning = true;
          eventEmitter.once('complete', this.onTaskComplete, this);
          this.continueCallback = eventSheetGroup["continue"].bind(eventSheetGroup);
          this.continueEE = eventEmitter;
        }
      }
    }, {
      key: "onTaskComplete",
      value: function onTaskComplete() {
        this.isRunning = false;
        this.continueEE = undefined;
        this.continueCallback();
      }
    }, {
      key: "tick",
      value: function tick(_tick) {
        return this.isRunning ? this.RUNNING : this.SUCCESS;
      }
    }, {
      key: "close",
      value: function close(tick) {}
    }, {
      key: "abort",
      value: function abort(tick) {
        if (this.continueEE) {
          this.continueEE.off('complete', this.onTaskComplete, this);
          this.continueEE = undefined;
        }
      }
    }]);
    return TaskAction;
  }(Action);
  var CompileExpression = function CompileExpression(s) {
    if (typeof s === 'string') {
      if (s.startsWith('#(') && s.endsWith(')')) {
        // Eval string to get number/boolean
        s = Compile$1(s.substring(2, s.length - 1));
      } else if (s.indexOf('{{') > -1 && s.indexOf('}}') > -1) {
        // Might be a string template
        var template = s;
        s = function s(data) {
          return mustache.render(template, data);
        };
      }
    }
    return s;
  };

  var WaitNextRound = /*#__PURE__*/function (_Wait) {
    _inherits(WaitNextRound, _Wait);
    function WaitNextRound() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 1 : _ref$duration,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'NextRound' : _ref$name;
      _classCallCheck(this, WaitNextRound);
      return _callSuper(this, WaitNextRound, [{
        duration: duration,
        services: services,
        title: title,
        name: name
      }]);
    }
    _createClass(WaitNextRound, [{
      key: "tick",
      value: function tick(_tick) {
        var state = _get(_getPrototypeOf(WaitNextRound.prototype), "tick", this).call(this, _tick);
        if (state === RUNNING$1) {
          this.getTree(_tick).roundComplete = true;
        }
        return state;
      }
    }]);
    return WaitNextRound;
  }(Wait$3);

  var ActivateAction = /*#__PURE__*/function (_Action) {
    _inherits(ActivateAction, _Action);
    function ActivateAction() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        activateTreeTitle = _ref.activateTreeTitle,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'ActivateTree' : _ref$name;
      _classCallCheck(this, ActivateAction);
      _this = _callSuper(this, ActivateAction, [{
        name: name,
        title: title,
        properties: {
          activateTreeTitle: activateTreeTitle
        },
        services: services
      }]);
      _this.activateTreeTitle = activateTreeTitle;
      return _this;
    }
    _createClass(ActivateAction, [{
      key: "tick",
      value: function tick(_tick) {
        var eventsheet = this.getTree(_tick);
        if (!this.activateTreeTitle || this.activateTreeTitle === '') {
          eventsheet.setActive(true);
        } else {
          eventsheet.treeManager.setEventSheetActiveState(this.activateTreeTitle, eventsheet.groupName, true);
        }
        return this.SUCCESS;
      }
    }]);
    return ActivateAction;
  }(Action);

  var DeactivateAction = /*#__PURE__*/function (_Action) {
    _inherits(DeactivateAction, _Action);
    function DeactivateAction() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        deactivateTreeTitle = _ref.deactivateTreeTitle,
        services = _ref.services,
        title = _ref.title,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'DeactivateTree' : _ref$name;
      _classCallCheck(this, DeactivateAction);
      _this = _callSuper(this, DeactivateAction, [{
        name: name,
        title: title,
        properties: {
          deactivateTreeTitle: deactivateTreeTitle
        },
        services: services
      }]);
      _this.deactivateTreeTitle = deactivateTreeTitle;
      return _this;
    }
    _createClass(DeactivateAction, [{
      key: "tick",
      value: function tick(_tick) {
        var eventsheet = this.getTree(_tick);
        if (!this.deactivateTreeTitle || this.deactivateTreeTitle === '') {
          eventsheet.setActive(false);
        } else {
          eventsheet.treeManager.setEventSheetActiveState(this.deactivateTreeTitle, eventsheet.groupName, false);
        }
        return this.SUCCESS;
      }
    }]);
    return DeactivateAction;
  }(Action);

  var CustomNodeMapping = {
    TaskSequence: TaskSequence,
    TaskAction: TaskAction,
    WaitNextRound: WaitNextRound,
    ActivateAction: ActivateAction,
    DeactivateAction: DeactivateAction
  };

  var SaveLoadTreeMethods = {
    dumpEventSheetGroup: function dumpEventSheetGroup() {
      return this.trees.map(function (eventsheet) {
        return eventsheet.dump();
      });
    },
    loadEventSheetGroup: function loadEventSheetGroup(data) {
      data.forEach(function (treeData) {
        var eventsheet = new BehaviorTree({
          id: treeData.id,
          title: treeData.title,
          properties: DeepClone(treeData.properties)
        });
        eventsheet.load(treeData, CustomNodeMapping);
        this.trees.push(eventsheet);
      }, this);
      return this;
    }
  };

  var StateMethods$1 = {
    dumpState: function dumpState() {
      var includeTree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var state = {
        isRunning: this.isRunning,
        pendingTrees: this.pendingTrees.filter(function (eventsheet) {
          // roundComplete eventsheet will be removed from pendingTrees
          return !eventsheet.roundComplete;
        }).map(function (eventsheet) {
          return eventsheet.id;
        })
      };
      if (includeTree) {
        state.trees = this.dumpEventSheetGroup();
      }
      return state;
    },
    loadState: function loadState(state) {
      this.stop();
      if (state.trees) {
        this.trees.length = 0;
        this.loadEventSheetGroup(state.trees);
      }
      this.isRunning = state.isRunning;
      var pendingTrees = this.pendingTrees;
      pendingTrees.length = 0;
      this.trees.forEach(function (eventsheet) {
        if (state.pendingTrees.indexOf(eventsheet.id) > -1) {
          pendingTrees.push(eventsheet);
        }
      });
      return this;
    }
  };

  var OpenEventSheet = function OpenEventSheet(treeManager, eventsheet) {
    var blackboard = treeManager.blackboard;
    var commandExecutor = treeManager.commandExecutor;
    var result = eventsheet.start(blackboard, commandExecutor);
    if (!result) {
      return;
    }
    if (eventsheet.conditionPassed) {
      treeManager.emit('eventsheet.enter', eventsheet.title, this.name, treeManager);
    } else {
      treeManager.emit('eventsheet.catch', eventsheet.title, this.name, treeManager);
    }
  };
  var TickEventSheet = function TickEventSheet(treeManager, eventsheet) {
    var blackboard = treeManager.blackboard;
    var commandExecutor = treeManager.commandExecutor;
    var status = eventsheet.tick(blackboard, commandExecutor);
    return status;
  };
  var CloseEventSheet = function CloseEventSheet(treeManager, eventsheet) {
    if (eventsheet.conditionPassed) {
      treeManager.emit('eventsheet.exit', eventsheet.title, this.name, treeManager);
    }
  };
  var RunMethods$1 = {
    /*
    A round : 
    
    - Normal case : 
        - Start from condition-eval, 
        - End to eventsheet.roundComplete (SUCCESS/FAILURE/ERROR state)
    - Cross rounds : 
        - Start from condition-eval or RUNNING state, 
        - End to eventsheet.roundComplete (RUNNING/SUCCESS/FAILURE/ERROR state)
    */
    start: function start() {
      /*
      Start a round :
      
      - sequence : Add all trees to pendingTrees
      - parallel : Open all event sheets(eventsheet), add them to pendingTrees
        Then, invoke continue()
      */

      if (this.isRunning) {
        return this;
      }
      this.isRunning = true;
      var treeManager = this.parent;
      var trees = this.trees;
      var pendingTrees = this.pendingTrees;
      var blackboard = treeManager.blackboard;

      // pendingTrees.length = 0;

      // Run parallel eventsheet, will return running, or failure
      for (var i = 0, cnt = trees.length; i < cnt; i++) {
        var eventsheet = trees[i];
        if (!eventsheet.active) {
          continue;
        }
        eventsheet.resetState(blackboard);
        if (eventsheet.parallel) {
          // Open all event sheets
          OpenEventSheet.call(this, treeManager, eventsheet);
        }
        pendingTrees.push(eventsheet);
      }
      this["continue"]();
      return this;
    },
    "continue": function _continue() {
      /*
      Tick event sheets(eventsheet) until all trees are at SUCCESS/FAILURE/ERROR state
        - Open (if not opened) and tick event sheet(eventsheet)        
      - TaskAction's complete event will invoke this method to run remainder nodes
      - Close(remove from pendingTrees) SUCCESS/FAILURE/ERROR event sheets(eventsheet)
      - Complete this round if pendingTrees is empty. i.e. all trees are return SUCCESS/FAILURE/ERROR.
      */

      if (!this.isRunning) {
        return this;
      }
      var treeManager = this.parent;
      var trees = this.pendingTrees;
      var closedTrees = this.closedTrees;
      var blackboard = treeManager.blackboard;
      closedTrees.length = 0;
      for (var i = 0, cnt = trees.length; i < cnt; i++) {
        var eventsheet = trees[i];

        // Do nothing if event sheet has been opened
        OpenEventSheet.call(this, treeManager, eventsheet);
        if (!this.isRunning) {
          // Can break here
          break;
        }

        // Will goto RUNNING, or SUCCESS/FAILURE/ERROR state
        var status = TickEventSheet(treeManager, eventsheet);
        if (eventsheet.roundComplete) {
          closedTrees.push(eventsheet);
          CloseEventSheet.call(this, treeManager, eventsheet);
        } else if (status === RUNNING$1) {
          // Stall command execution here
          break;
        }
        if (!this.isRunning) {
          // Can break here
          break;
        }
      }
      blackboard.eventSheetGroup = undefined;
      if (closedTrees.length > 0) {
        Remove$4(trees, closedTrees);
      }
      if (trees.length === 0) {
        this.isRunning = false;
        treeManager.emit('complete', this.name, treeManager);
      }
      return this;
    },
    stop: function stop() {
      this.isRunning = false;
      var treeManager = this.parent;
      var blackboard = treeManager.blackboard;
      var commandExecutor = treeManager.commandExecutor;
      this.pendingTrees.forEach(function (eventsheet) {
        eventsheet.abort(blackboard, commandExecutor);
      });
      this.pendingTrees.length = 0;
      return this;
    },
    startTree: function startTree(title) {
      var ignoreCondition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      // Run a single event sheet(eventsheet)

      if (this.isRunning) {
        return this;
      }
      var eventsheet = this.getTree(title);
      if (!eventsheet) {
        return this;
      }
      this.isRunning = true;
      var treeManager = this.parent;
      var pendingTrees = this.pendingTrees;
      var blackboard = treeManager.blackboard;
      pendingTrees.length = 0;
      eventsheet.resetState(blackboard);
      eventsheet.setConditionEnable(!ignoreCondition);
      OpenEventSheet.call(this, treeManager, eventsheet);
      eventsheet.setConditionEnable(true);
      pendingTrees.push(eventsheet);
      this["continue"]();
      return this;
    }
  };

  var Methods$o = {};
  Object.assign(Methods$o, TreeMethods$1, AddTreeMethods$2, RemoveTreeMethods$2, TreeActiveStateMethods$1, SaveLoadTreeMethods, StateMethods$1, RunMethods$1);

  var EventBehaviorTreeGroup = /*#__PURE__*/_createClass(function EventBehaviorTreeGroup(parent) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? '' : _ref$name;
    _classCallCheck(this, EventBehaviorTreeGroup);
    this.parent = parent;
    this.name = name;
    this.trees = [];
    this.pendingTrees = [];
    this.closedTrees = []; // Temporary eventsheet array

    this.isRunning = false;
    this._threadKey = null;
  });
  Object.assign(EventBehaviorTreeGroup.prototype, Methods$o);

  var TreeMethods = {
    hasTreeGroup: function hasTreeGroup(name) {
      return this.treeGroups.hasOwnProperty(name);
    },
    getTreeGroup: function getTreeGroup(name) {
      if (!this.hasTreeGroup(name)) {
        this.treeGroups[name] = new EventBehaviorTreeGroup(this, {
          name: name
        });
      }
      return this.treeGroups[name];
    },
    getTree: function getTree(eventsheet, groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      return this.getTreeGroup(groupName).getTree(eventsheet);
    },
    getTreeState: function getTreeState(eventsheet, groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      return this.getTreeGroup(groupName).getTreeState(eventsheet);
    },
    getEventSheetTitleList: function getEventSheetTitleList(out, groupName) {
      if (out === undefined) {
        out = [];
      }
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      this.getTreeGroup(groupName).getEventSheetTitleList(out);
      return out;
    }
  };

  var AddTreeMethods$1 = {
    // Override it
    addEventSheet: function addEventSheet(s, groupName, config) {
      return this;
    },
    addTree: function addTree(eventsheet, groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      this.getTreeGroup(groupName).addTree(eventsheet);
      return this;
    }
  };

  var RemoveTreeMethods$1 = {
    removeAllEventSheets: function removeAllEventSheets(groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      this.getTreeGroup(groupName).removeAllEventSheets();
      return this;
    },
    removeEventSheet: function removeEventSheet(title, groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      this.getTreeGroup(groupName).removeEventSheet(title);
      return this;
    }
  };

  var TreeActiveStateMethods = {
    getEventSheetActiveState: function getEventSheetActiveState(title, groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      return this.getTreeGroup(groupName).getTreeActiveState(title);
    },
    setEventSheetActiveState: function setEventSheetActiveState(title, groupName, active) {
      if (typeof groupName === 'boolean') {
        active = groupName;
        groupName = undefined;
      }
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      return this.getTreeGroup(groupName).setTreeActiveState(title, active);
    }
  };

  var SaveLoadTreesMethods = {
    dumpEventSheetGroup: function dumpEventSheetGroup(groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      return this.getTreeGroup(groupName).dumpEventSheetGroup();
    },
    loadEventSheetGroup: function loadEventSheetGroup(data, groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      this.getTreeGroup(groupName).loadEventSheetGroup(data);
      return this;
    }
  };

  var DataMethods$3 = {
    setData: function setData(key, value) {
      this.blackboard.setData(key, value);
      return this;
    },
    hasData: function hasData(key) {
      return this.blackboard.hasData(key);
    },
    incData: function incData(key, inc) {
      this.blackboard.incData(key, inc);
      return this;
    },
    toggleData: function toggleData(key) {
      this.blackboard.toggleData(key);
      return this;
    },
    getData: function getData(key) {
      return this.blackboard.getData(key);
    }
  };

  var StateMethods = {
    dumpState: function dumpState() {
      var includeTree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var state = {
        blackboard: this.blackboard.dump(),
        treeGroups: {}
      };
      var treeGroups = state.treeGroups;
      for (var name in this.treeGroups) {
        treeGroups[name] = this.treeGroups[name].dumpState(includeTree);
      }
      return state;
    },
    loadState: function loadState(state) {
      if (!state) {
        return this;
      }
      this.blackboard.load(state.blackboard);
      var treeGroups = state.treeGroups;
      for (var name in treeGroups) {
        this.getTreeGroup(name).loadState(treeGroups[name]);
      }
      for (var name in treeGroups) {
        this.getTreeGroup(name)["continue"]();
      }
      return this;
    }
  };

  var handlebars$1 = {exports: {}};

  var handlebars_runtime = {exports: {}};

  var base$1 = {};

  var utils = {};

  utils.__esModule = true;
  utils.extend = extend;
  utils.indexOf = indexOf;
  utils.escapeExpression = escapeExpression;
  utils.isEmpty = isEmpty;
  utils.createFrame = createFrame;
  utils.blockParams = blockParams;
  utils.appendContextPath = appendContextPath;
  var escape = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  var badChars = /[&<>"'`=]/g,
      possible = /[&<>"'`=]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  var toString = Object.prototype.toString;

  utils.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  /* eslint-disable func-style */
  var isFunction = function isFunction(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    utils.isFunction = isFunction = function (value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  utils.isFunction = isFunction;

  /* eslint-enable func-style */

  /* istanbul ignore next */
  var isArray = Array.isArray || function (value) {
    return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
  };

  utils.isArray = isArray;
  // Older IE versions do not directly support indexOf so we must implement our own, sadly.

  function indexOf(array, value) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  }

  function escapeExpression(string) {
    if (typeof string !== 'string') {
      // don't escape SafeStrings, since they're already safe
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return '';
      } else if (!string) {
        return string + '';
      }

      // Force a string conversion as this will be done by the append regardless and
      // the regex test will do this transparently behind the scenes, causing issues if
      // an object's to string has escaped characters in it.
      string = '' + string;
    }

    if (!possible.test(string)) {
      return string;
    }
    return string.replace(badChars, escapeChar);
  }

  function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  function createFrame(object) {
    var frame = extend({}, object);
    frame._parent = object;
    return frame;
  }

  function blockParams(params, ids) {
    params.path = ids;
    return params;
  }

  function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }

  var exception = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];

  	function Exception(message, node) {
  	  var loc = node && node.loc,
  	      line = undefined,
  	      endLineNumber = undefined,
  	      column = undefined,
  	      endColumn = undefined;

  	  if (loc) {
  	    line = loc.start.line;
  	    endLineNumber = loc.end.line;
  	    column = loc.start.column;
  	    endColumn = loc.end.column;

  	    message += ' - ' + line + ':' + column;
  	  }

  	  var tmp = Error.prototype.constructor.call(this, message);

  	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  	  for (var idx = 0; idx < errorProps.length; idx++) {
  	    this[errorProps[idx]] = tmp[errorProps[idx]];
  	  }

  	  /* istanbul ignore else */
  	  if (Error.captureStackTrace) {
  	    Error.captureStackTrace(this, Exception);
  	  }

  	  try {
  	    if (loc) {
  	      this.lineNumber = line;
  	      this.endLineNumber = endLineNumber;

  	      // Work around issue under safari where we can't directly set the column value
  	      /* istanbul ignore next */
  	      if (Object.defineProperty) {
  	        Object.defineProperty(this, 'column', {
  	          value: column,
  	          enumerable: true
  	        });
  	        Object.defineProperty(this, 'endColumn', {
  	          value: endColumn,
  	          enumerable: true
  	        });
  	      } else {
  	        this.column = column;
  	        this.endColumn = endColumn;
  	      }
  	    }
  	  } catch (nop) {
  	    /* Ignore if the browser is very particular */
  	  }
  	}

  	Exception.prototype = new Error();

  	exports['default'] = Exception;
  	module.exports = exports['default'];
  	
  } (exception, exception.exports));

  var exceptionExports = exception.exports;

  var helpers$1 = {};

  var blockHelperMissing = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;

  	var _utils = utils;

  	exports['default'] = function (instance) {
  	  instance.registerHelper('blockHelperMissing', function (context, options) {
  	    var inverse = options.inverse,
  	        fn = options.fn;

  	    if (context === true) {
  	      return fn(this);
  	    } else if (context === false || context == null) {
  	      return inverse(this);
  	    } else if (_utils.isArray(context)) {
  	      if (context.length > 0) {
  	        if (options.ids) {
  	          options.ids = [options.name];
  	        }

  	        return instance.helpers.each(context, options);
  	      } else {
  	        return inverse(this);
  	      }
  	    } else {
  	      if (options.data && options.ids) {
  	        var data = _utils.createFrame(options.data);
  	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
  	        options = { data: data };
  	      }

  	      return fn(context, options);
  	    }
  	  });
  	};

  	module.exports = exports['default'];
  	
  } (blockHelperMissing, blockHelperMissing.exports));

  var blockHelperMissingExports = blockHelperMissing.exports;

  var each = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	var _utils = utils;

  	var _exception = exceptionExports;

  	var _exception2 = _interopRequireDefault(_exception);

  	exports['default'] = function (instance) {
  	  instance.registerHelper('each', function (context, options) {
  	    if (!options) {
  	      throw new _exception2['default']('Must pass iterator to #each');
  	    }

  	    var fn = options.fn,
  	        inverse = options.inverse,
  	        i = 0,
  	        ret = '',
  	        data = undefined,
  	        contextPath = undefined;

  	    if (options.data && options.ids) {
  	      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
  	    }

  	    if (_utils.isFunction(context)) {
  	      context = context.call(this);
  	    }

  	    if (options.data) {
  	      data = _utils.createFrame(options.data);
  	    }

  	    function execIteration(field, index, last) {
  	      if (data) {
  	        data.key = field;
  	        data.index = index;
  	        data.first = index === 0;
  	        data.last = !!last;

  	        if (contextPath) {
  	          data.contextPath = contextPath + field;
  	        }
  	      }

  	      ret = ret + fn(context[field], {
  	        data: data,
  	        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
  	      });
  	    }

  	    if (context && typeof context === 'object') {
  	      if (_utils.isArray(context)) {
  	        for (var j = context.length; i < j; i++) {
  	          if (i in context) {
  	            execIteration(i, i, i === context.length - 1);
  	          }
  	        }
  	      } else if (typeof Symbol === 'function' && context[Symbol.iterator]) {
  	        var newContext = [];
  	        var iterator = context[Symbol.iterator]();
  	        for (var it = iterator.next(); !it.done; it = iterator.next()) {
  	          newContext.push(it.value);
  	        }
  	        context = newContext;
  	        for (var j = context.length; i < j; i++) {
  	          execIteration(i, i, i === context.length - 1);
  	        }
  	      } else {
  	        (function () {
  	          var priorKey = undefined;

  	          Object.keys(context).forEach(function (key) {
  	            // We're running the iterations one step out of sync so we can detect
  	            // the last iteration without have to scan the object twice and create
  	            // an itermediate keys array.
  	            if (priorKey !== undefined) {
  	              execIteration(priorKey, i - 1);
  	            }
  	            priorKey = key;
  	            i++;
  	          });
  	          if (priorKey !== undefined) {
  	            execIteration(priorKey, i - 1, true);
  	          }
  	        })();
  	      }
  	    }

  	    if (i === 0) {
  	      ret = inverse(this);
  	    }

  	    return ret;
  	  });
  	};

  	module.exports = exports['default'];
  	
  } (each, each.exports));

  var eachExports = each.exports;

  var helperMissing = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	var _exception = exceptionExports;

  	var _exception2 = _interopRequireDefault(_exception);

  	exports['default'] = function (instance) {
  	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
  	    if (arguments.length === 1) {
  	      // A missing field in a {{foo}} construct.
  	      return undefined;
  	    } else {
  	      // Someone is actually trying to call something, blow up.
  	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
  	    }
  	  });
  	};

  	module.exports = exports['default'];
  	
  } (helperMissing, helperMissing.exports));

  var helperMissingExports = helperMissing.exports;

  var _if = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	var _utils = utils;

  	var _exception = exceptionExports;

  	var _exception2 = _interopRequireDefault(_exception);

  	exports['default'] = function (instance) {
  	  instance.registerHelper('if', function (conditional, options) {
  	    if (arguments.length != 2) {
  	      throw new _exception2['default']('#if requires exactly one argument');
  	    }
  	    if (_utils.isFunction(conditional)) {
  	      conditional = conditional.call(this);
  	    }

  	    // Default behavior is to render the positive path if the value is truthy and not empty.
  	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
  	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
  	    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
  	      return options.inverse(this);
  	    } else {
  	      return options.fn(this);
  	    }
  	  });

  	  instance.registerHelper('unless', function (conditional, options) {
  	    if (arguments.length != 2) {
  	      throw new _exception2['default']('#unless requires exactly one argument');
  	    }
  	    return instance.helpers['if'].call(this, conditional, {
  	      fn: options.inverse,
  	      inverse: options.fn,
  	      hash: options.hash
  	    });
  	  });
  	};

  	module.exports = exports['default'];
  	
  } (_if, _if.exports));

  var _ifExports = _if.exports;

  var log$1 = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;

  	exports['default'] = function (instance) {
  	  instance.registerHelper('log', function () /* message, options */{
  	    var args = [undefined],
  	        options = arguments[arguments.length - 1];
  	    for (var i = 0; i < arguments.length - 1; i++) {
  	      args.push(arguments[i]);
  	    }

  	    var level = 1;
  	    if (options.hash.level != null) {
  	      level = options.hash.level;
  	    } else if (options.data && options.data.level != null) {
  	      level = options.data.level;
  	    }
  	    args[0] = level;

  	    instance.log.apply(instance, args);
  	  });
  	};

  	module.exports = exports['default'];
  	
  } (log$1, log$1.exports));

  var logExports = log$1.exports;

  var lookup = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;

  	exports['default'] = function (instance) {
  	  instance.registerHelper('lookup', function (obj, field, options) {
  	    if (!obj) {
  	      // Note for 5.0: Change to "obj == null" in 5.0
  	      return obj;
  	    }
  	    return options.lookupProperty(obj, field);
  	  });
  	};

  	module.exports = exports['default'];
  	
  } (lookup, lookup.exports));

  var lookupExports = lookup.exports;

  var _with = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	var _utils = utils;

  	var _exception = exceptionExports;

  	var _exception2 = _interopRequireDefault(_exception);

  	exports['default'] = function (instance) {
  	  instance.registerHelper('with', function (context, options) {
  	    if (arguments.length != 2) {
  	      throw new _exception2['default']('#with requires exactly one argument');
  	    }
  	    if (_utils.isFunction(context)) {
  	      context = context.call(this);
  	    }

  	    var fn = options.fn;

  	    if (!_utils.isEmpty(context)) {
  	      var data = options.data;
  	      if (options.data && options.ids) {
  	        data = _utils.createFrame(options.data);
  	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
  	      }

  	      return fn(context, {
  	        data: data,
  	        blockParams: _utils.blockParams([context], [data && data.contextPath])
  	      });
  	    } else {
  	      return options.inverse(this);
  	    }
  	  });
  	};

  	module.exports = exports['default'];
  	
  } (_with, _with.exports));

  var _withExports = _with.exports;

  helpers$1.__esModule = true;
  helpers$1.registerDefaultHelpers = registerDefaultHelpers;
  helpers$1.moveHelperToHooks = moveHelperToHooks;
  // istanbul ignore next

  function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _helpersBlockHelperMissing = blockHelperMissingExports;

  var _helpersBlockHelperMissing2 = _interopRequireDefault$7(_helpersBlockHelperMissing);

  var _helpersEach = eachExports;

  var _helpersEach2 = _interopRequireDefault$7(_helpersEach);

  var _helpersHelperMissing = helperMissingExports;

  var _helpersHelperMissing2 = _interopRequireDefault$7(_helpersHelperMissing);

  var _helpersIf = _ifExports;

  var _helpersIf2 = _interopRequireDefault$7(_helpersIf);

  var _helpersLog = logExports;

  var _helpersLog2 = _interopRequireDefault$7(_helpersLog);

  var _helpersLookup = lookupExports;

  var _helpersLookup2 = _interopRequireDefault$7(_helpersLookup);

  var _helpersWith = _withExports;

  var _helpersWith2 = _interopRequireDefault$7(_helpersWith);

  function registerDefaultHelpers(instance) {
    _helpersBlockHelperMissing2['default'](instance);
    _helpersEach2['default'](instance);
    _helpersHelperMissing2['default'](instance);
    _helpersIf2['default'](instance);
    _helpersLog2['default'](instance);
    _helpersLookup2['default'](instance);
    _helpersWith2['default'](instance);
  }

  function moveHelperToHooks(instance, helperName, keepHelper) {
    if (instance.helpers[helperName]) {
      instance.hooks[helperName] = instance.helpers[helperName];
      if (!keepHelper) {
        delete instance.helpers[helperName];
      }
    }
  }

  var decorators = {};

  var inline = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;

  	var _utils = utils;

  	exports['default'] = function (instance) {
  	  instance.registerDecorator('inline', function (fn, props, container, options) {
  	    var ret = fn;
  	    if (!props.partials) {
  	      props.partials = {};
  	      ret = function (context, options) {
  	        // Create a new partials stack frame prior to exec.
  	        var original = container.partials;
  	        container.partials = _utils.extend({}, original, props.partials);
  	        var ret = fn(context, options);
  	        container.partials = original;
  	        return ret;
  	      };
  	    }

  	    props.partials[options.args[0]] = options.fn;

  	    return ret;
  	  });
  	};

  	module.exports = exports['default'];
  	
  } (inline, inline.exports));

  var inlineExports = inline.exports;

  decorators.__esModule = true;
  decorators.registerDefaultDecorators = registerDefaultDecorators;
  // istanbul ignore next

  function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _decoratorsInline = inlineExports;

  var _decoratorsInline2 = _interopRequireDefault$6(_decoratorsInline);

  function registerDefaultDecorators(instance) {
    _decoratorsInline2['default'](instance);
  }

  var logger = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;

  	var _utils = utils;

  	var logger = {
  	  methodMap: ['debug', 'info', 'warn', 'error'],
  	  level: 'info',

  	  // Maps a given level value to the `methodMap` indexes above.
  	  lookupLevel: function lookupLevel(level) {
  	    if (typeof level === 'string') {
  	      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
  	      if (levelMap >= 0) {
  	        level = levelMap;
  	      } else {
  	        level = parseInt(level, 10);
  	      }
  	    }

  	    return level;
  	  },

  	  // Can be overridden in the host environment
  	  log: function log(level) {
  	    level = logger.lookupLevel(level);

  	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
  	      var method = logger.methodMap[level];
  	      // eslint-disable-next-line no-console
  	      if (!console[method]) {
  	        method = 'log';
  	      }

  	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  	        message[_key - 1] = arguments[_key];
  	      }

  	      console[method].apply(console, message); // eslint-disable-line no-console
  	    }
  	  }
  	};

  	exports['default'] = logger;
  	module.exports = exports['default'];
  	
  } (logger, logger.exports));

  var loggerExports = logger.exports;

  var protoAccess = {};

  var createNewLookupObject$1 = {};

  createNewLookupObject$1.__esModule = true;
  createNewLookupObject$1.createNewLookupObject = createNewLookupObject;

  var _utils$4 = utils;

  /**
   * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
   * The resulting object can be used with "object[property]" to check if a property exists
   * @param {...object} sources a varargs parameter of source objects that will be merged
   * @returns {object}
   */

  function createNewLookupObject() {
    for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }

    return _utils$4.extend.apply(undefined, [Object.create(null)].concat(sources));
  }

  protoAccess.__esModule = true;
  protoAccess.createProtoAccessControl = createProtoAccessControl;
  protoAccess.resultIsAllowed = resultIsAllowed;
  protoAccess.resetLoggedProperties = resetLoggedProperties;
  // istanbul ignore next

  function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _createNewLookupObject = createNewLookupObject$1;

  var _logger$1 = loggerExports;

  var _logger2$1 = _interopRequireDefault$5(_logger$1);

  var loggedProperties = Object.create(null);

  function createProtoAccessControl(runtimeOptions) {
    var defaultMethodWhiteList = Object.create(null);
    defaultMethodWhiteList['constructor'] = false;
    defaultMethodWhiteList['__defineGetter__'] = false;
    defaultMethodWhiteList['__defineSetter__'] = false;
    defaultMethodWhiteList['__lookupGetter__'] = false;

    var defaultPropertyWhiteList = Object.create(null);
    // eslint-disable-next-line no-proto
    defaultPropertyWhiteList['__proto__'] = false;

    return {
      properties: {
        whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
        defaultValue: runtimeOptions.allowProtoPropertiesByDefault
      },
      methods: {
        whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
        defaultValue: runtimeOptions.allowProtoMethodsByDefault
      }
    };
  }

  function resultIsAllowed(result, protoAccessControl, propertyName) {
    if (typeof result === 'function') {
      return checkWhiteList(protoAccessControl.methods, propertyName);
    } else {
      return checkWhiteList(protoAccessControl.properties, propertyName);
    }
  }

  function checkWhiteList(protoAccessControlForType, propertyName) {
    if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
      return protoAccessControlForType.whitelist[propertyName] === true;
    }
    if (protoAccessControlForType.defaultValue !== undefined) {
      return protoAccessControlForType.defaultValue;
    }
    logUnexpecedPropertyAccessOnce(propertyName);
    return false;
  }

  function logUnexpecedPropertyAccessOnce(propertyName) {
    if (loggedProperties[propertyName] !== true) {
      loggedProperties[propertyName] = true;
      _logger2$1['default'].log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
    }
  }

  function resetLoggedProperties() {
    Object.keys(loggedProperties).forEach(function (propertyName) {
      delete loggedProperties[propertyName];
    });
  }

  base$1.__esModule = true;
  base$1.HandlebarsEnvironment = HandlebarsEnvironment;
  // istanbul ignore next

  function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _utils$3 = utils;

  var _exception$3 = exceptionExports;

  var _exception2$3 = _interopRequireDefault$4(_exception$3);

  var _helpers$2 = helpers$1;

  var _decorators = decorators;

  var _logger = loggerExports;

  var _logger2 = _interopRequireDefault$4(_logger);

  var _internalProtoAccess$1 = protoAccess;

  var VERSION = '4.7.8';
  base$1.VERSION = VERSION;
  var COMPILER_REVISION = 8;
  base$1.COMPILER_REVISION = COMPILER_REVISION;
  var LAST_COMPATIBLE_COMPILER_REVISION = 7;

  base$1.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '== 1.x.x',
    5: '== 2.0.0-alpha.x',
    6: '>= 2.0.0-beta.1',
    7: '>= 4.0.0 <4.3.0',
    8: '>= 4.3.0'
  };

  base$1.REVISION_CHANGES = REVISION_CHANGES;
  var objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials, decorators) {
    this.helpers = helpers || {};
    this.partials = partials || {};
    this.decorators = decorators || {};

    _helpers$2.registerDefaultHelpers(this);
    _decorators.registerDefaultDecorators(this);
  }

  HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: _logger2['default'],
    log: _logger2['default'].log,

    registerHelper: function registerHelper(name, fn) {
      if (_utils$3.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2$3['default']('Arg not supported with multiple helpers');
        }
        _utils$3.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function unregisterHelper(name) {
      delete this.helpers[name];
    },

    registerPartial: function registerPartial(name, partial) {
      if (_utils$3.toString.call(name) === objectType) {
        _utils$3.extend(this.partials, name);
      } else {
        if (typeof partial === 'undefined') {
          throw new _exception2$3['default']('Attempting to register a partial called "' + name + '" as undefined');
        }
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function unregisterPartial(name) {
      delete this.partials[name];
    },

    registerDecorator: function registerDecorator(name, fn) {
      if (_utils$3.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2$3['default']('Arg not supported with multiple decorators');
        }
        _utils$3.extend(this.decorators, name);
      } else {
        this.decorators[name] = fn;
      }
    },
    unregisterDecorator: function unregisterDecorator(name) {
      delete this.decorators[name];
    },
    /**
     * Reset the memory of illegal property accesses that have already been logged.
     * @deprecated should only be used in handlebars test-cases
     */
    resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
      _internalProtoAccess$1.resetLoggedProperties();
    }
  };

  var log = _logger2['default'].log;

  base$1.log = log;
  base$1.createFrame = _utils$3.createFrame;
  base$1.logger = _logger2['default'];

  var safeString = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	function SafeString(string) {
  	  this.string = string;
  	}

  	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  	  return '' + this.string;
  	};

  	exports['default'] = SafeString;
  	module.exports = exports['default'];
  	
  } (safeString, safeString.exports));

  var safeStringExports = safeString.exports;

  var runtime = {};

  var wrapHelper$1 = {};

  wrapHelper$1.__esModule = true;
  wrapHelper$1.wrapHelper = wrapHelper;

  function wrapHelper(helper, transformOptionsFn) {
    if (typeof helper !== 'function') {
      // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
      // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
      return helper;
    }
    var wrapper = function wrapper() /* dynamic arguments */{
      var options = arguments[arguments.length - 1];
      arguments[arguments.length - 1] = transformOptionsFn(options);
      return helper.apply(this, arguments);
    };
    return wrapper;
  }

  runtime.__esModule = true;
  runtime.checkRevision = checkRevision;
  runtime.template = template;
  runtime.wrapProgram = wrapProgram;
  runtime.resolvePartial = resolvePartial;
  runtime.invokePartial = invokePartial;
  runtime.noop = noop;
  // istanbul ignore next

  function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  // istanbul ignore next

  function _interopRequireWildcard$1(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  var _utils$2 = utils;

  var Utils$4 = _interopRequireWildcard$1(_utils$2);

  var _exception$2 = exceptionExports;

  var _exception2$2 = _interopRequireDefault$3(_exception$2);

  var _base = base$1;

  var _helpers$1 = helpers$1;

  var _internalWrapHelper = wrapHelper$1;

  var _internalProtoAccess = protoAccess;

  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = _base.COMPILER_REVISION;

    if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
      return;
    }

    if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2$2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2$2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }

  function template(templateSpec, env) {
    /* istanbul ignore next */
    if (!env) {
      throw new _exception2$2['default']('No environment passed to template');
    }
    if (!templateSpec || !templateSpec.main) {
      throw new _exception2$2['default']('Unknown template object: ' + typeof templateSpec);
    }

    templateSpec.main.decorator = templateSpec.main_d;

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as pseudo-supported APIs.
    env.VM.checkRevision(templateSpec.compiler);

    // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
    var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;

    function invokePartialWrapper(partial, context, options) {
      if (options.hash) {
        context = Utils$4.extend({}, context, options.hash);
        if (options.ids) {
          options.ids[0] = true;
        }
      }
      partial = env.VM.resolvePartial.call(this, partial, context, options);

      var extendedOptions = Utils$4.extend({}, options, {
        hooks: this.hooks,
        protoAccessControl: this.protoAccessControl
      });

      var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);

      if (result == null && env.compile) {
        options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
        result = options.partials[options.name](context, extendedOptions);
      }
      if (result != null) {
        if (options.indent) {
          var lines = result.split('\n');
          for (var i = 0, l = lines.length; i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }

            lines[i] = options.indent + lines[i];
          }
          result = lines.join('\n');
        }
        return result;
      } else {
        throw new _exception2$2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
      }
    }

    // Just add water
    var container = {
      strict: function strict(obj, name, loc) {
        if (!obj || !(name in obj)) {
          throw new _exception2$2['default']('"' + name + '" not defined in ' + obj, {
            loc: loc
          });
        }
        return container.lookupProperty(obj, name);
      },
      lookupProperty: function lookupProperty(parent, propertyName) {
        var result = parent[propertyName];
        if (result == null) {
          return result;
        }
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return result;
        }

        if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
          return result;
        }
        return undefined;
      },
      lookup: function lookup(depths, name) {
        var len = depths.length;
        for (var i = 0; i < len; i++) {
          var result = depths[i] && container.lookupProperty(depths[i], name);
          if (result != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function lambda(current, context) {
        return typeof current === 'function' ? current.call(context) : current;
      },

      escapeExpression: Utils$4.escapeExpression,
      invokePartial: invokePartialWrapper,

      fn: function fn(i) {
        var ret = templateSpec[i];
        ret.decorator = templateSpec[i + '_d'];
        return ret;
      },

      programs: [],
      program: function program(i, data, declaredBlockParams, blockParams, depths) {
        var programWrapper = this.programs[i],
            fn = this.fn(i);
        if (data || depths || blockParams || declaredBlockParams) {
          programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = wrapProgram(this, i, fn);
        }
        return programWrapper;
      },

      data: function data(value, depth) {
        while (value && depth--) {
          value = value._parent;
        }
        return value;
      },
      mergeIfNeeded: function mergeIfNeeded(param, common) {
        var obj = param || common;

        if (param && common && param !== common) {
          obj = Utils$4.extend({}, common, param);
        }

        return obj;
      },
      // An empty object to use as replacement for null-contexts
      nullContext: Object.seal({}),

      noop: env.VM.noop,
      compilerInfo: templateSpec.compiler
    };

    function ret(context) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var data = options.data;

      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths = undefined,
          blockParams = templateSpec.useBlockParams ? [] : undefined;
      if (templateSpec.useDepths) {
        if (options.depths) {
          depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
        } else {
          depths = [context];
        }
      }

      function main(context /*, options*/) {
        return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
      }

      main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
      return main(context, options);
    }

    ret.isTop = true;

    ret._setup = function (options) {
      if (!options.partial) {
        var mergedHelpers = Utils$4.extend({}, env.helpers, options.helpers);
        wrapHelpersToPassLookupProperty(mergedHelpers, container);
        container.helpers = mergedHelpers;

        if (templateSpec.usePartial) {
          // Use mergeIfNeeded here to prevent compiling global partials multiple times
          container.partials = container.mergeIfNeeded(options.partials, env.partials);
        }
        if (templateSpec.usePartial || templateSpec.useDecorators) {
          container.decorators = Utils$4.extend({}, env.decorators, options.decorators);
        }

        container.hooks = {};
        container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);

        var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
        _helpers$1.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
        _helpers$1.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
      } else {
        container.protoAccessControl = options.protoAccessControl; // internal option
        container.helpers = options.helpers;
        container.partials = options.partials;
        container.decorators = options.decorators;
        container.hooks = options.hooks;
      }
    };

    ret._child = function (i, data, blockParams, depths) {
      if (templateSpec.useBlockParams && !blockParams) {
        throw new _exception2$2['default']('must pass block params');
      }
      if (templateSpec.useDepths && !depths) {
        throw new _exception2$2['default']('must pass parent depths');
      }

      return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
    };
    return ret;
  }

  function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
    function prog(context) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var currentDepths = depths;
      if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
        currentDepths = [context].concat(depths);
      }

      return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
    }

    prog = executeDecorators(fn, prog, container, depths, data, blockParams);

    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    prog.blockParams = declaredBlockParams || 0;
    return prog;
  }

  /**
   * This is currently part of the official API, therefore implementation details should not be changed.
   */

  function resolvePartial(partial, context, options) {
    if (!partial) {
      if (options.name === '@partial-block') {
        partial = options.data['partial-block'];
      } else {
        partial = options.partials[options.name];
      }
    } else if (!partial.call && !options.name) {
      // This is a dynamic partial that returned a string
      options.name = partial;
      partial = options.partials[partial];
    }
    return partial;
  }

  function invokePartial(partial, context, options) {
    // Use the current closure context to save the partial-block if this partial
    var currentPartialBlock = options.data && options.data['partial-block'];
    options.partial = true;
    if (options.ids) {
      options.data.contextPath = options.ids[0] || options.data.contextPath;
    }

    var partialBlock = undefined;
    if (options.fn && options.fn !== noop) {
      (function () {
        options.data = _base.createFrame(options.data);
        // Wrapper function to get access to currentPartialBlock from the closure
        var fn = options.fn;
        partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

          // Restore the partial-block from the closure for the execution of the block
          // i.e. the part inside the block of the partial call.
          options.data = _base.createFrame(options.data);
          options.data['partial-block'] = currentPartialBlock;
          return fn(context, options);
        };
        if (fn.partials) {
          options.partials = Utils$4.extend({}, options.partials, fn.partials);
        }
      })();
    }

    if (partial === undefined && partialBlock) {
      partial = partialBlock;
    }

    if (partial === undefined) {
      throw new _exception2$2['default']('The partial ' + options.name + ' could not be found');
    } else if (partial instanceof Function) {
      return partial(context, options);
    }
  }

  function noop() {
    return '';
  }

  function initData(context, data) {
    if (!data || !('root' in data)) {
      data = data ? _base.createFrame(data) : {};
      data.root = context;
    }
    return data;
  }

  function executeDecorators(fn, prog, container, depths, data, blockParams) {
    if (fn.decorator) {
      var props = {};
      prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
      Utils$4.extend(prog, props);
    }
    return prog;
  }

  function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
    Object.keys(mergedHelpers).forEach(function (helperName) {
      var helper = mergedHelpers[helperName];
      mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
    });
  }

  function passLookupPropertyOption(helper, container) {
    var lookupProperty = container.lookupProperty;
    return _internalWrapHelper.wrapHelper(helper, function (options) {
      return Utils$4.extend({ lookupProperty: lookupProperty }, options);
    });
  }

  var noConflict = {exports: {}};

  /* global globalThis */

  (function (module, exports) {

  	exports.__esModule = true;

  	exports['default'] = function (Handlebars) {
  	  /* istanbul ignore next */
  	  // https://mathiasbynens.be/notes/globalthis
  	  (function () {
  	    if (typeof globalThis === 'object') return;
  	    Object.prototype.__defineGetter__('__magic__', function () {
  	      return this;
  	    });
  	    __magic__.globalThis = __magic__; // eslint-disable-line no-undef
  	    delete Object.prototype.__magic__;
  	  })();

  	  var $Handlebars = globalThis.Handlebars;

  	  /* istanbul ignore next */
  	  Handlebars.noConflict = function () {
  	    if (globalThis.Handlebars === Handlebars) {
  	      globalThis.Handlebars = $Handlebars;
  	    }
  	    return Handlebars;
  	  };
  	};

  	module.exports = exports['default'];
  	
  } (noConflict, noConflict.exports));

  var noConflictExports = noConflict.exports;

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	// istanbul ignore next

  	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  	var _handlebarsBase = base$1;

  	var base = _interopRequireWildcard(_handlebarsBase);

  	// Each of these augment the Handlebars object. No need to setup here.
  	// (This is done to easily share code between commonjs and browse envs)

  	var _handlebarsSafeString = safeStringExports;

  	var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

  	var _handlebarsException = exceptionExports;

  	var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

  	var _handlebarsUtils = utils;

  	var Utils = _interopRequireWildcard(_handlebarsUtils);

  	var _handlebarsRuntime = runtime;

  	var runtime$1 = _interopRequireWildcard(_handlebarsRuntime);

  	var _handlebarsNoConflict = noConflictExports;

  	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

  	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
  	function create() {
  	  var hb = new base.HandlebarsEnvironment();

  	  Utils.extend(hb, base);
  	  hb.SafeString = _handlebarsSafeString2['default'];
  	  hb.Exception = _handlebarsException2['default'];
  	  hb.Utils = Utils;
  	  hb.escapeExpression = Utils.escapeExpression;

  	  hb.VM = runtime$1;
  	  hb.template = function (spec) {
  	    return runtime$1.template(spec, hb);
  	  };

  	  return hb;
  	}

  	var inst = create();
  	inst.create = create;

  	_handlebarsNoConflict2['default'](inst);

  	inst['default'] = inst;

  	exports['default'] = inst;
  	module.exports = exports['default'];
  	
  } (handlebars_runtime, handlebars_runtime.exports));

  var handlebars_runtimeExports = handlebars_runtime.exports;

  var ast = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	var AST = {
  	  // Public API used to evaluate derived attributes regarding AST nodes
  	  helpers: {
  	    // a mustache is definitely a helper if:
  	    // * it is an eligible helper, and
  	    // * it has at least one parameter or hash segment
  	    helperExpression: function helperExpression(node) {
  	      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
  	    },

  	    scopedId: function scopedId(path) {
  	      return (/^\.|this\b/.test(path.original)
  	      );
  	    },

  	    // an ID is simple if it only has one part, and that part is not
  	    // `..` or `this`.
  	    simpleId: function simpleId(path) {
  	      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
  	    }
  	  }
  	};

  	// Must be exported as an object rather than the root of the module as the jison lexer
  	// must modify the object to operate properly.
  	exports['default'] = AST;
  	module.exports = exports['default'];
  	
  } (ast, ast.exports));

  var astExports = ast.exports;

  var base = {};

  var parser = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	var handlebars = (function () {
  	    var parser = { trace: function trace() {},
  	        yy: {},
  	        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
  	        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
  	        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
  	        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

  	            var $0 = $$.length - 1;
  	            switch (yystate) {
  	                case 1:
  	                    return $$[$0 - 1];
  	                case 2:
  	                    this.$ = yy.prepareProgram($$[$0]);
  	                    break;
  	                case 3:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 4:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 5:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 6:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 7:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 8:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 9:
  	                    this.$ = {
  	                        type: 'CommentStatement',
  	                        value: yy.stripComment($$[$0]),
  	                        strip: yy.stripFlags($$[$0], $$[$0]),
  	                        loc: yy.locInfo(this._$)
  	                    };

  	                    break;
  	                case 10:
  	                    this.$ = {
  	                        type: 'ContentStatement',
  	                        original: $$[$0],
  	                        value: $$[$0],
  	                        loc: yy.locInfo(this._$)
  	                    };

  	                    break;
  	                case 11:
  	                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
  	                    break;
  	                case 12:
  	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
  	                    break;
  	                case 13:
  	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
  	                    break;
  	                case 14:
  	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
  	                    break;
  	                case 15:
  	                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
  	                    break;
  	                case 16:
  	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
  	                    break;
  	                case 17:
  	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
  	                    break;
  	                case 18:
  	                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
  	                    break;
  	                case 19:
  	                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
  	                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
  	                    program.chained = true;

  	                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

  	                    break;
  	                case 20:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 21:
  	                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
  	                    break;
  	                case 22:
  	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
  	                    break;
  	                case 23:
  	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
  	                    break;
  	                case 24:
  	                    this.$ = {
  	                        type: 'PartialStatement',
  	                        name: $$[$0 - 3],
  	                        params: $$[$0 - 2],
  	                        hash: $$[$0 - 1],
  	                        indent: '',
  	                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
  	                        loc: yy.locInfo(this._$)
  	                    };

  	                    break;
  	                case 25:
  	                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
  	                    break;
  	                case 26:
  	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
  	                    break;
  	                case 27:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 28:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 29:
  	                    this.$ = {
  	                        type: 'SubExpression',
  	                        path: $$[$0 - 3],
  	                        params: $$[$0 - 2],
  	                        hash: $$[$0 - 1],
  	                        loc: yy.locInfo(this._$)
  	                    };

  	                    break;
  	                case 30:
  	                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
  	                    break;
  	                case 31:
  	                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
  	                    break;
  	                case 32:
  	                    this.$ = yy.id($$[$0 - 1]);
  	                    break;
  	                case 33:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 34:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 35:
  	                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
  	                    break;
  	                case 36:
  	                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
  	                    break;
  	                case 37:
  	                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
  	                    break;
  	                case 38:
  	                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
  	                    break;
  	                case 39:
  	                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
  	                    break;
  	                case 40:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 41:
  	                    this.$ = $$[$0];
  	                    break;
  	                case 42:
  	                    this.$ = yy.preparePath(true, $$[$0], this._$);
  	                    break;
  	                case 43:
  	                    this.$ = yy.preparePath(false, $$[$0], this._$);
  	                    break;
  	                case 44:
  	                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
  	                    break;
  	                case 45:
  	                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
  	                    break;
  	                case 46:
  	                    this.$ = [];
  	                    break;
  	                case 47:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 48:
  	                    this.$ = [];
  	                    break;
  	                case 49:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 50:
  	                    this.$ = [];
  	                    break;
  	                case 51:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 58:
  	                    this.$ = [];
  	                    break;
  	                case 59:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 64:
  	                    this.$ = [];
  	                    break;
  	                case 65:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 70:
  	                    this.$ = [];
  	                    break;
  	                case 71:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 78:
  	                    this.$ = [];
  	                    break;
  	                case 79:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 82:
  	                    this.$ = [];
  	                    break;
  	                case 83:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 86:
  	                    this.$ = [];
  	                    break;
  	                case 87:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 90:
  	                    this.$ = [];
  	                    break;
  	                case 91:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 94:
  	                    this.$ = [];
  	                    break;
  	                case 95:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 98:
  	                    this.$ = [$$[$0]];
  	                    break;
  	                case 99:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	                case 100:
  	                    this.$ = [$$[$0]];
  	                    break;
  	                case 101:
  	                    $$[$0 - 1].push($$[$0]);
  	                    break;
  	            }
  	        },
  	        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
  	        defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
  	        parseError: function parseError(str, hash) {
  	            throw new Error(str);
  	        },
  	        parse: function parse(input) {
  	            var self = this,
  	                stack = [0],
  	                vstack = [null],
  	                lstack = [],
  	                table = this.table,
  	                yytext = "",
  	                yylineno = 0,
  	                yyleng = 0;
  	            this.lexer.setInput(input);
  	            this.lexer.yy = this.yy;
  	            this.yy.lexer = this.lexer;
  	            this.yy.parser = this;
  	            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
  	            var yyloc = this.lexer.yylloc;
  	            lstack.push(yyloc);
  	            var ranges = this.lexer.options && this.lexer.options.ranges;
  	            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
  	            function lex() {
  	                var token;
  	                token = self.lexer.lex() || 1;
  	                if (typeof token !== "number") {
  	                    token = self.symbols_[token] || token;
  	                }
  	                return token;
  	            }
  	            var symbol,
  	                state,
  	                action,
  	                r,
  	                yyval = {},
  	                p,
  	                len,
  	                newState,
  	                expected;
  	            while (true) {
  	                state = stack[stack.length - 1];
  	                if (this.defaultActions[state]) {
  	                    action = this.defaultActions[state];
  	                } else {
  	                    if (symbol === null || typeof symbol == "undefined") {
  	                        symbol = lex();
  	                    }
  	                    action = table[state] && table[state][symbol];
  	                }
  	                if (typeof action === "undefined" || !action.length || !action[0]) {
  	                    var errStr = "";
  	                    {
  	                        expected = [];
  	                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
  	                            expected.push("'" + this.terminals_[p] + "'");
  	                        }
  	                        if (this.lexer.showPosition) {
  	                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
  	                        } else {
  	                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
  	                        }
  	                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
  	                    }
  	                }
  	                if (action[0] instanceof Array && action.length > 1) {
  	                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
  	                }
  	                switch (action[0]) {
  	                    case 1:
  	                        stack.push(symbol);
  	                        vstack.push(this.lexer.yytext);
  	                        lstack.push(this.lexer.yylloc);
  	                        stack.push(action[1]);
  	                        symbol = null;
  	                        {
  	                            yyleng = this.lexer.yyleng;
  	                            yytext = this.lexer.yytext;
  	                            yylineno = this.lexer.yylineno;
  	                            yyloc = this.lexer.yylloc;
  	                        }
  	                        break;
  	                    case 2:
  	                        len = this.productions_[action[1]][1];
  	                        yyval.$ = vstack[vstack.length - len];
  	                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
  	                        if (ranges) {
  	                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
  	                        }
  	                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
  	                        if (typeof r !== "undefined") {
  	                            return r;
  	                        }
  	                        if (len) {
  	                            stack = stack.slice(0, -1 * len * 2);
  	                            vstack = vstack.slice(0, -1 * len);
  	                            lstack = lstack.slice(0, -1 * len);
  	                        }
  	                        stack.push(this.productions_[action[1]][0]);
  	                        vstack.push(yyval.$);
  	                        lstack.push(yyval._$);
  	                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
  	                        stack.push(newState);
  	                        break;
  	                    case 3:
  	                        return true;
  	                }
  	            }
  	            return true;
  	        }
  	    };
  	    /* Jison generated lexer */
  	    var lexer = (function () {
  	        var lexer = { EOF: 1,
  	            parseError: function parseError(str, hash) {
  	                if (this.yy.parser) {
  	                    this.yy.parser.parseError(str, hash);
  	                } else {
  	                    throw new Error(str);
  	                }
  	            },
  	            setInput: function setInput(input) {
  	                this._input = input;
  	                this._more = this._less = this.done = false;
  	                this.yylineno = this.yyleng = 0;
  	                this.yytext = this.matched = this.match = '';
  	                this.conditionStack = ['INITIAL'];
  	                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
  	                if (this.options.ranges) this.yylloc.range = [0, 0];
  	                this.offset = 0;
  	                return this;
  	            },
  	            input: function input() {
  	                var ch = this._input[0];
  	                this.yytext += ch;
  	                this.yyleng++;
  	                this.offset++;
  	                this.match += ch;
  	                this.matched += ch;
  	                var lines = ch.match(/(?:\r\n?|\n).*/g);
  	                if (lines) {
  	                    this.yylineno++;
  	                    this.yylloc.last_line++;
  	                } else {
  	                    this.yylloc.last_column++;
  	                }
  	                if (this.options.ranges) this.yylloc.range[1]++;

  	                this._input = this._input.slice(1);
  	                return ch;
  	            },
  	            unput: function unput(ch) {
  	                var len = ch.length;
  	                var lines = ch.split(/(?:\r\n?|\n)/g);

  	                this._input = ch + this._input;
  	                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
  	                //this.yyleng -= len;
  	                this.offset -= len;
  	                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
  	                this.match = this.match.substr(0, this.match.length - 1);
  	                this.matched = this.matched.substr(0, this.matched.length - 1);

  	                if (lines.length - 1) this.yylineno -= lines.length - 1;
  	                var r = this.yylloc.range;

  	                this.yylloc = { first_line: this.yylloc.first_line,
  	                    last_line: this.yylineno + 1,
  	                    first_column: this.yylloc.first_column,
  	                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
  	                };

  	                if (this.options.ranges) {
  	                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
  	                }
  	                return this;
  	            },
  	            more: function more() {
  	                this._more = true;
  	                return this;
  	            },
  	            less: function less(n) {
  	                this.unput(this.match.slice(n));
  	            },
  	            pastInput: function pastInput() {
  	                var past = this.matched.substr(0, this.matched.length - this.match.length);
  	                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
  	            },
  	            upcomingInput: function upcomingInput() {
  	                var next = this.match;
  	                if (next.length < 20) {
  	                    next += this._input.substr(0, 20 - next.length);
  	                }
  	                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
  	            },
  	            showPosition: function showPosition() {
  	                var pre = this.pastInput();
  	                var c = new Array(pre.length + 1).join("-");
  	                return pre + this.upcomingInput() + "\n" + c + "^";
  	            },
  	            next: function next() {
  	                if (this.done) {
  	                    return this.EOF;
  	                }
  	                if (!this._input) this.done = true;

  	                var token, match, tempMatch, index, lines;
  	                if (!this._more) {
  	                    this.yytext = '';
  	                    this.match = '';
  	                }
  	                var rules = this._currentRules();
  	                for (var i = 0; i < rules.length; i++) {
  	                    tempMatch = this._input.match(this.rules[rules[i]]);
  	                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
  	                        match = tempMatch;
  	                        index = i;
  	                        if (!this.options.flex) break;
  	                    }
  	                }
  	                if (match) {
  	                    lines = match[0].match(/(?:\r\n?|\n).*/g);
  	                    if (lines) this.yylineno += lines.length;
  	                    this.yylloc = { first_line: this.yylloc.last_line,
  	                        last_line: this.yylineno + 1,
  	                        first_column: this.yylloc.last_column,
  	                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
  	                    this.yytext += match[0];
  	                    this.match += match[0];
  	                    this.matches = match;
  	                    this.yyleng = this.yytext.length;
  	                    if (this.options.ranges) {
  	                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
  	                    }
  	                    this._more = false;
  	                    this._input = this._input.slice(match[0].length);
  	                    this.matched += match[0];
  	                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
  	                    if (this.done && this._input) this.done = false;
  	                    if (token) return token;else return;
  	                }
  	                if (this._input === "") {
  	                    return this.EOF;
  	                } else {
  	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
  	                }
  	            },
  	            lex: function lex() {
  	                var r = this.next();
  	                if (typeof r !== 'undefined') {
  	                    return r;
  	                } else {
  	                    return this.lex();
  	                }
  	            },
  	            begin: function begin(condition) {
  	                this.conditionStack.push(condition);
  	            },
  	            popState: function popState() {
  	                return this.conditionStack.pop();
  	            },
  	            _currentRules: function _currentRules() {
  	                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
  	            },
  	            topState: function topState() {
  	                return this.conditionStack[this.conditionStack.length - 2];
  	            },
  	            pushState: function begin(condition) {
  	                this.begin(condition);
  	            } };
  	        lexer.options = {};
  	        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

  	            function strip(start, end) {
  	                return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
  	            }
  	            switch ($avoiding_name_collisions) {
  	                case 0:
  	                    if (yy_.yytext.slice(-2) === "\\\\") {
  	                        strip(0, 1);
  	                        this.begin("mu");
  	                    } else if (yy_.yytext.slice(-1) === "\\") {
  	                        strip(0, 1);
  	                        this.begin("emu");
  	                    } else {
  	                        this.begin("mu");
  	                    }
  	                    if (yy_.yytext) return 15;

  	                    break;
  	                case 1:
  	                    return 15;
  	                case 2:
  	                    this.popState();
  	                    return 15;
  	                case 3:
  	                    this.begin('raw');return 15;
  	                case 4:
  	                    this.popState();
  	                    // Should be using `this.topState()` below, but it currently
  	                    // returns the second top instead of the first top. Opened an
  	                    // issue about it at https://github.com/zaach/jison/issues/291
  	                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
  	                        return 15;
  	                    } else {
  	                        strip(5, 9);
  	                        return 'END_RAW_BLOCK';
  	                    }
  	                case 5:
  	                    return 15;
  	                case 6:
  	                    this.popState();
  	                    return 14;
  	                case 7:
  	                    return 65;
  	                case 8:
  	                    return 68;
  	                case 9:
  	                    return 19;
  	                case 10:
  	                    this.popState();
  	                    this.begin('raw');
  	                    return 23;
  	                case 11:
  	                    return 55;
  	                case 12:
  	                    return 60;
  	                case 13:
  	                    return 29;
  	                case 14:
  	                    return 47;
  	                case 15:
  	                    this.popState();return 44;
  	                case 16:
  	                    this.popState();return 44;
  	                case 17:
  	                    return 34;
  	                case 18:
  	                    return 39;
  	                case 19:
  	                    return 51;
  	                case 20:
  	                    return 48;
  	                case 21:
  	                    this.unput(yy_.yytext);
  	                    this.popState();
  	                    this.begin('com');

  	                    break;
  	                case 22:
  	                    this.popState();
  	                    return 14;
  	                case 23:
  	                    return 48;
  	                case 24:
  	                    return 73;
  	                case 25:
  	                    return 72;
  	                case 26:
  	                    return 72;
  	                case 27:
  	                    return 87;
  	                case 28:
  	                    // ignore whitespace
  	                    break;
  	                case 29:
  	                    this.popState();return 54;
  	                case 30:
  	                    this.popState();return 33;
  	                case 31:
  	                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
  	                case 32:
  	                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
  	                case 33:
  	                    return 85;
  	                case 34:
  	                    return 82;
  	                case 35:
  	                    return 82;
  	                case 36:
  	                    return 83;
  	                case 37:
  	                    return 84;
  	                case 38:
  	                    return 81;
  	                case 39:
  	                    return 75;
  	                case 40:
  	                    return 77;
  	                case 41:
  	                    return 72;
  	                case 42:
  	                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
  	                case 43:
  	                    return 'INVALID';
  	                case 44:
  	                    return 5;
  	            }
  	        };
  	        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
  	        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
  	        return lexer;
  	    })();
  	    parser.lexer = lexer;
  	    function Parser() {
  	        this.yy = {};
  	    }Parser.prototype = parser;parser.Parser = Parser;
  	    return new Parser();
  	})();exports["default"] = handlebars;
  	module.exports = exports["default"];
  	
  } (parser, parser.exports));

  var parserExports = parser.exports;

  var whitespaceControl = {exports: {}};

  var visitor = {exports: {}};

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	var _exception = exceptionExports;

  	var _exception2 = _interopRequireDefault(_exception);

  	function Visitor() {
  	  this.parents = [];
  	}

  	Visitor.prototype = {
  	  constructor: Visitor,
  	  mutating: false,

  	  // Visits a given value. If mutating, will replace the value if necessary.
  	  acceptKey: function acceptKey(node, name) {
  	    var value = this.accept(node[name]);
  	    if (this.mutating) {
  	      // Hacky sanity check: This may have a few false positives for type for the helper
  	      // methods but will generally do the right thing without a lot of overhead.
  	      if (value && !Visitor.prototype[value.type]) {
  	        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
  	      }
  	      node[name] = value;
  	    }
  	  },

  	  // Performs an accept operation with added sanity check to ensure
  	  // required keys are not removed.
  	  acceptRequired: function acceptRequired(node, name) {
  	    this.acceptKey(node, name);

  	    if (!node[name]) {
  	      throw new _exception2['default'](node.type + ' requires ' + name);
  	    }
  	  },

  	  // Traverses a given array. If mutating, empty respnses will be removed
  	  // for child elements.
  	  acceptArray: function acceptArray(array) {
  	    for (var i = 0, l = array.length; i < l; i++) {
  	      this.acceptKey(array, i);

  	      if (!array[i]) {
  	        array.splice(i, 1);
  	        i--;
  	        l--;
  	      }
  	    }
  	  },

  	  accept: function accept(object) {
  	    if (!object) {
  	      return;
  	    }

  	    /* istanbul ignore next: Sanity code */
  	    if (!this[object.type]) {
  	      throw new _exception2['default']('Unknown type: ' + object.type, object);
  	    }

  	    if (this.current) {
  	      this.parents.unshift(this.current);
  	    }
  	    this.current = object;

  	    var ret = this[object.type](object);

  	    this.current = this.parents.shift();

  	    if (!this.mutating || ret) {
  	      return ret;
  	    } else if (ret !== false) {
  	      return object;
  	    }
  	  },

  	  Program: function Program(program) {
  	    this.acceptArray(program.body);
  	  },

  	  MustacheStatement: visitSubExpression,
  	  Decorator: visitSubExpression,

  	  BlockStatement: visitBlock,
  	  DecoratorBlock: visitBlock,

  	  PartialStatement: visitPartial,
  	  PartialBlockStatement: function PartialBlockStatement(partial) {
  	    visitPartial.call(this, partial);

  	    this.acceptKey(partial, 'program');
  	  },

  	  ContentStatement: function ContentStatement() /* content */{},
  	  CommentStatement: function CommentStatement() /* comment */{},

  	  SubExpression: visitSubExpression,

  	  PathExpression: function PathExpression() /* path */{},

  	  StringLiteral: function StringLiteral() /* string */{},
  	  NumberLiteral: function NumberLiteral() /* number */{},
  	  BooleanLiteral: function BooleanLiteral() /* bool */{},
  	  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
  	  NullLiteral: function NullLiteral() /* literal */{},

  	  Hash: function Hash(hash) {
  	    this.acceptArray(hash.pairs);
  	  },
  	  HashPair: function HashPair(pair) {
  	    this.acceptRequired(pair, 'value');
  	  }
  	};

  	function visitSubExpression(mustache) {
  	  this.acceptRequired(mustache, 'path');
  	  this.acceptArray(mustache.params);
  	  this.acceptKey(mustache, 'hash');
  	}
  	function visitBlock(block) {
  	  visitSubExpression.call(this, block);

  	  this.acceptKey(block, 'program');
  	  this.acceptKey(block, 'inverse');
  	}
  	function visitPartial(partial) {
  	  this.acceptRequired(partial, 'name');
  	  this.acceptArray(partial.params);
  	  this.acceptKey(partial, 'hash');
  	}

  	exports['default'] = Visitor;
  	module.exports = exports['default'];
  	
  } (visitor, visitor.exports));

  var visitorExports = visitor.exports;

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	var _visitor = visitorExports;

  	var _visitor2 = _interopRequireDefault(_visitor);

  	function WhitespaceControl() {
  	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  	  this.options = options;
  	}
  	WhitespaceControl.prototype = new _visitor2['default']();

  	WhitespaceControl.prototype.Program = function (program) {
  	  var doStandalone = !this.options.ignoreStandalone;

  	  var isRoot = !this.isRootSeen;
  	  this.isRootSeen = true;

  	  var body = program.body;
  	  for (var i = 0, l = body.length; i < l; i++) {
  	    var current = body[i],
  	        strip = this.accept(current);

  	    if (!strip) {
  	      continue;
  	    }

  	    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
  	        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
  	        openStandalone = strip.openStandalone && _isPrevWhitespace,
  	        closeStandalone = strip.closeStandalone && _isNextWhitespace,
  	        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

  	    if (strip.close) {
  	      omitRight(body, i, true);
  	    }
  	    if (strip.open) {
  	      omitLeft(body, i, true);
  	    }

  	    if (doStandalone && inlineStandalone) {
  	      omitRight(body, i);

  	      if (omitLeft(body, i)) {
  	        // If we are on a standalone node, save the indent info for partials
  	        if (current.type === 'PartialStatement') {
  	          // Pull out the whitespace from the final line
  	          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
  	        }
  	      }
  	    }
  	    if (doStandalone && openStandalone) {
  	      omitRight((current.program || current.inverse).body);

  	      // Strip out the previous content node if it's whitespace only
  	      omitLeft(body, i);
  	    }
  	    if (doStandalone && closeStandalone) {
  	      // Always strip the next node
  	      omitRight(body, i);

  	      omitLeft((current.inverse || current.program).body);
  	    }
  	  }

  	  return program;
  	};

  	WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
  	  this.accept(block.program);
  	  this.accept(block.inverse);

  	  // Find the inverse program that is involed with whitespace stripping.
  	  var program = block.program || block.inverse,
  	      inverse = block.program && block.inverse,
  	      firstInverse = inverse,
  	      lastInverse = inverse;

  	  if (inverse && inverse.chained) {
  	    firstInverse = inverse.body[0].program;

  	    // Walk the inverse chain to find the last inverse that is actually in the chain.
  	    while (lastInverse.chained) {
  	      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
  	    }
  	  }

  	  var strip = {
  	    open: block.openStrip.open,
  	    close: block.closeStrip.close,

  	    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
  	    // so our parent can determine if we actually are standalone
  	    openStandalone: isNextWhitespace(program.body),
  	    closeStandalone: isPrevWhitespace((firstInverse || program).body)
  	  };

  	  if (block.openStrip.close) {
  	    omitRight(program.body, null, true);
  	  }

  	  if (inverse) {
  	    var inverseStrip = block.inverseStrip;

  	    if (inverseStrip.open) {
  	      omitLeft(program.body, null, true);
  	    }

  	    if (inverseStrip.close) {
  	      omitRight(firstInverse.body, null, true);
  	    }
  	    if (block.closeStrip.open) {
  	      omitLeft(lastInverse.body, null, true);
  	    }

  	    // Find standalone else statments
  	    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
  	      omitLeft(program.body);
  	      omitRight(firstInverse.body);
  	    }
  	  } else if (block.closeStrip.open) {
  	    omitLeft(program.body, null, true);
  	  }

  	  return strip;
  	};

  	WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
  	  return mustache.strip;
  	};

  	WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
  	  /* istanbul ignore next */
  	  var strip = node.strip || {};
  	  return {
  	    inlineStandalone: true,
  	    open: strip.open,
  	    close: strip.close
  	  };
  	};

  	function isPrevWhitespace(body, i, isRoot) {
  	  if (i === undefined) {
  	    i = body.length;
  	  }

  	  // Nodes that end with newlines are considered whitespace (but are special
  	  // cased for strip operations)
  	  var prev = body[i - 1],
  	      sibling = body[i - 2];
  	  if (!prev) {
  	    return isRoot;
  	  }

  	  if (prev.type === 'ContentStatement') {
  	    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
  	  }
  	}
  	function isNextWhitespace(body, i, isRoot) {
  	  if (i === undefined) {
  	    i = -1;
  	  }

  	  var next = body[i + 1],
  	      sibling = body[i + 2];
  	  if (!next) {
  	    return isRoot;
  	  }

  	  if (next.type === 'ContentStatement') {
  	    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
  	  }
  	}

  	// Marks the node to the right of the position as omitted.
  	// I.e. {{foo}}' ' will mark the ' ' node as omitted.
  	//
  	// If i is undefined, then the first child will be marked as such.
  	//
  	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  	// content is met.
  	function omitRight(body, i, multiple) {
  	  var current = body[i == null ? 0 : i + 1];
  	  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
  	    return;
  	  }

  	  var original = current.value;
  	  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
  	  current.rightStripped = current.value !== original;
  	}

  	// Marks the node to the left of the position as omitted.
  	// I.e. ' '{{foo}} will mark the ' ' node as omitted.
  	//
  	// If i is undefined then the last child will be marked as such.
  	//
  	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  	// content is met.
  	function omitLeft(body, i, multiple) {
  	  var current = body[i == null ? body.length - 1 : i - 1];
  	  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
  	    return;
  	  }

  	  // We omit the last node if it's whitespace only and not preceded by a non-content node.
  	  var original = current.value;
  	  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
  	  current.leftStripped = current.value !== original;
  	  return current.leftStripped;
  	}

  	exports['default'] = WhitespaceControl;
  	module.exports = exports['default'];
  	
  } (whitespaceControl, whitespaceControl.exports));

  var whitespaceControlExports = whitespaceControl.exports;

  var helpers = {};

  helpers.__esModule = true;
  helpers.SourceLocation = SourceLocation;
  helpers.id = id$1;
  helpers.stripFlags = stripFlags;
  helpers.stripComment = stripComment;
  helpers.preparePath = preparePath;
  helpers.prepareMustache = prepareMustache;
  helpers.prepareRawBlock = prepareRawBlock;
  helpers.prepareBlock = prepareBlock;
  helpers.prepareProgram = prepareProgram;
  helpers.preparePartialBlock = preparePartialBlock;
  // istanbul ignore next

  function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _exception$1 = exceptionExports;

  var _exception2$1 = _interopRequireDefault$2(_exception$1);

  function validateClose(open, close) {
    close = close.path ? close.path.original : close;

    if (open.path.original !== close) {
      var errorNode = { loc: open.path.loc };

      throw new _exception2$1['default'](open.path.original + " doesn't match " + close, errorNode);
    }
  }

  function SourceLocation(source, locInfo) {
    this.source = source;
    this.start = {
      line: locInfo.first_line,
      column: locInfo.first_column
    };
    this.end = {
      line: locInfo.last_line,
      column: locInfo.last_column
    };
  }

  function id$1(token) {
    if (/^\[.*\]$/.test(token)) {
      return token.substring(1, token.length - 1);
    } else {
      return token;
    }
  }

  function stripFlags(open, close) {
    return {
      open: open.charAt(2) === '~',
      close: close.charAt(close.length - 3) === '~'
    };
  }

  function stripComment(comment) {
    return comment.replace(/^\{\{~?!-?-?/, '').replace(/-?-?~?\}\}$/, '');
  }

  function preparePath(data, parts, loc) {
    loc = this.locInfo(loc);

    var original = data ? '@' : '',
        dig = [],
        depth = 0;

    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i].part,

      // If we have [] syntax then we do not treat path references as operators,
      // i.e. foo.[this] resolves to approximately context.foo['this']
      isLiteral = parts[i].original !== part;
      original += (parts[i].separator || '') + part;

      if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
        if (dig.length > 0) {
          throw new _exception2$1['default']('Invalid path: ' + original, { loc: loc });
        } else if (part === '..') {
          depth++;
        }
      } else {
        dig.push(part);
      }
    }

    return {
      type: 'PathExpression',
      data: data,
      depth: depth,
      parts: dig,
      original: original,
      loc: loc
    };
  }

  function prepareMustache(path, params, hash, open, strip, locInfo) {
    // Must use charAt to support IE pre-10
    var escapeFlag = open.charAt(3) || open.charAt(2),
        escaped = escapeFlag !== '{' && escapeFlag !== '&';

    var decorator = /\*/.test(open);
    return {
      type: decorator ? 'Decorator' : 'MustacheStatement',
      path: path,
      params: params,
      hash: hash,
      escaped: escaped,
      strip: strip,
      loc: this.locInfo(locInfo)
    };
  }

  function prepareRawBlock(openRawBlock, contents, close, locInfo) {
    validateClose(openRawBlock, close);

    locInfo = this.locInfo(locInfo);
    var program = {
      type: 'Program',
      body: contents,
      strip: {},
      loc: locInfo
    };

    return {
      type: 'BlockStatement',
      path: openRawBlock.path,
      params: openRawBlock.params,
      hash: openRawBlock.hash,
      program: program,
      openStrip: {},
      inverseStrip: {},
      closeStrip: {},
      loc: locInfo
    };
  }

  function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
    if (close && close.path) {
      validateClose(openBlock, close);
    }

    var decorator = /\*/.test(openBlock.open);

    program.blockParams = openBlock.blockParams;

    var inverse = undefined,
        inverseStrip = undefined;

    if (inverseAndProgram) {
      if (decorator) {
        throw new _exception2$1['default']('Unexpected inverse block on decorator', inverseAndProgram);
      }

      if (inverseAndProgram.chain) {
        inverseAndProgram.program.body[0].closeStrip = close.strip;
      }

      inverseStrip = inverseAndProgram.strip;
      inverse = inverseAndProgram.program;
    }

    if (inverted) {
      inverted = inverse;
      inverse = program;
      program = inverted;
    }

    return {
      type: decorator ? 'DecoratorBlock' : 'BlockStatement',
      path: openBlock.path,
      params: openBlock.params,
      hash: openBlock.hash,
      program: program,
      inverse: inverse,
      openStrip: openBlock.strip,
      inverseStrip: inverseStrip,
      closeStrip: close && close.strip,
      loc: this.locInfo(locInfo)
    };
  }

  function prepareProgram(statements, loc) {
    if (!loc && statements.length) {
      var firstLoc = statements[0].loc,
          lastLoc = statements[statements.length - 1].loc;

      /* istanbul ignore else */
      if (firstLoc && lastLoc) {
        loc = {
          source: firstLoc.source,
          start: {
            line: firstLoc.start.line,
            column: firstLoc.start.column
          },
          end: {
            line: lastLoc.end.line,
            column: lastLoc.end.column
          }
        };
      }
    }

    return {
      type: 'Program',
      body: statements,
      strip: {},
      loc: loc
    };
  }

  function preparePartialBlock(open, program, close, locInfo) {
    validateClose(open, close);

    return {
      type: 'PartialBlockStatement',
      name: open.path,
      params: open.params,
      hash: open.hash,
      program: program,
      openStrip: open.strip,
      closeStrip: close && close.strip,
      loc: this.locInfo(locInfo)
    };
  }

  base.__esModule = true;
  base.parseWithoutProcessing = parseWithoutProcessing;
  base.parse = parse;
  // istanbul ignore next

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  // istanbul ignore next

  function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _parser = parserExports;

  var _parser2 = _interopRequireDefault$1(_parser);

  var _whitespaceControl = whitespaceControlExports;

  var _whitespaceControl2 = _interopRequireDefault$1(_whitespaceControl);

  var _helpers = helpers;

  var Helpers = _interopRequireWildcard(_helpers);

  var _utils$1 = utils;

  base.parser = _parser2['default'];

  var yy = {};
  _utils$1.extend(yy, Helpers);

  function parseWithoutProcessing(input, options) {
    // Just return if an already-compiled AST was passed in.
    if (input.type === 'Program') {
      return input;
    }

    _parser2['default'].yy = yy;

    // Altering the shared object here, but this is ok as parser is a sync operation
    yy.locInfo = function (locInfo) {
      return new yy.SourceLocation(options && options.srcName, locInfo);
    };

    var ast = _parser2['default'].parse(input);

    return ast;
  }

  function parse(input, options) {
    var ast = parseWithoutProcessing(input, options);
    var strip = new _whitespaceControl2['default'](options);

    return strip.accept(ast);
  }

  var compiler = {};

  /* eslint-disable new-cap */

  compiler.__esModule = true;
  compiler.Compiler = Compiler;
  compiler.precompile = precompile;
  compiler.compile = compile;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _exception = exceptionExports;

  var _exception2 = _interopRequireDefault(_exception);

  var _utils = utils;

  var _ast = astExports;

  var _ast2 = _interopRequireDefault(_ast);

  var slice = [].slice;

  function Compiler() {}

  // the foundHelper register will disambiguate helper lookup from finding a
  // function in a context. This is necessary for mustache compatibility, which
  // requires that context functions in blocks are evaluated by blockHelperMissing,
  // and then proceed as if the resulting value was provided to blockHelperMissing.

  Compiler.prototype = {
    compiler: Compiler,

    equals: function equals(other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        var opcode = this.opcodes[i],
            otherOpcode = other.opcodes[i];
        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
          return false;
        }
      }

      // We know that length is the same between the two arrays because they are directly tied
      // to the opcode behavior above.
      len = this.children.length;
      for (var i = 0; i < len; i++) {
        if (!this.children[i].equals(other.children[i])) {
          return false;
        }
      }

      return true;
    },

    guid: 0,

    compile: function compile(program, options) {
      this.sourceNode = [];
      this.opcodes = [];
      this.children = [];
      this.options = options;
      this.stringParams = options.stringParams;
      this.trackIds = options.trackIds;

      options.blockParams = options.blockParams || [];

      options.knownHelpers = _utils.extend(Object.create(null), {
        helperMissing: true,
        blockHelperMissing: true,
        each: true,
        'if': true,
        unless: true,
        'with': true,
        log: true,
        lookup: true
      }, options.knownHelpers);

      return this.accept(program);
    },

    compileProgram: function compileProgram(program) {
      var childCompiler = new this.compiler(),
          // eslint-disable-line new-cap
      result = childCompiler.compile(program, this.options),
          guid = this.guid++;

      this.usePartial = this.usePartial || result.usePartial;

      this.children[guid] = result;
      this.useDepths = this.useDepths || result.useDepths;

      return guid;
    },

    accept: function accept(node) {
      /* istanbul ignore next: Sanity code */
      if (!this[node.type]) {
        throw new _exception2['default']('Unknown type: ' + node.type, node);
      }

      this.sourceNode.unshift(node);
      var ret = this[node.type](node);
      this.sourceNode.shift();
      return ret;
    },

    Program: function Program(program) {
      this.options.blockParams.unshift(program.blockParams);

      var body = program.body,
          bodyLength = body.length;
      for (var i = 0; i < bodyLength; i++) {
        this.accept(body[i]);
      }

      this.options.blockParams.shift();

      this.isSimple = bodyLength === 1;
      this.blockParams = program.blockParams ? program.blockParams.length : 0;

      return this;
    },

    BlockStatement: function BlockStatement(block) {
      transformLiteralToPath(block);

      var program = block.program,
          inverse = block.inverse;

      program = program && this.compileProgram(program);
      inverse = inverse && this.compileProgram(inverse);

      var type = this.classifySexpr(block);

      if (type === 'helper') {
        this.helperSexpr(block, program, inverse);
      } else if (type === 'simple') {
        this.simpleSexpr(block);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('blockValue', block.path.original);
      } else {
        this.ambiguousSexpr(block, program, inverse);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('ambiguousBlockValue');
      }

      this.opcode('append');
    },

    DecoratorBlock: function DecoratorBlock(decorator) {
      var program = decorator.program && this.compileProgram(decorator.program);
      var params = this.setupFullMustacheParams(decorator, program, undefined),
          path = decorator.path;

      this.useDecorators = true;
      this.opcode('registerDecorator', params.length, path.original);
    },

    PartialStatement: function PartialStatement(partial) {
      this.usePartial = true;

      var program = partial.program;
      if (program) {
        program = this.compileProgram(partial.program);
      }

      var params = partial.params;
      if (params.length > 1) {
        throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
      } else if (!params.length) {
        if (this.options.explicitPartialContext) {
          this.opcode('pushLiteral', 'undefined');
        } else {
          params.push({ type: 'PathExpression', parts: [], depth: 0 });
        }
      }

      var partialName = partial.name.original,
          isDynamic = partial.name.type === 'SubExpression';
      if (isDynamic) {
        this.accept(partial.name);
      }

      this.setupFullMustacheParams(partial, program, undefined, true);

      var indent = partial.indent || '';
      if (this.options.preventIndent && indent) {
        this.opcode('appendContent', indent);
        indent = '';
      }

      this.opcode('invokePartial', isDynamic, partialName, indent);
      this.opcode('append');
    },
    PartialBlockStatement: function PartialBlockStatement(partialBlock) {
      this.PartialStatement(partialBlock);
    },

    MustacheStatement: function MustacheStatement(mustache) {
      this.SubExpression(mustache);

      if (mustache.escaped && !this.options.noEscape) {
        this.opcode('appendEscaped');
      } else {
        this.opcode('append');
      }
    },
    Decorator: function Decorator(decorator) {
      this.DecoratorBlock(decorator);
    },

    ContentStatement: function ContentStatement(content) {
      if (content.value) {
        this.opcode('appendContent', content.value);
      }
    },

    CommentStatement: function CommentStatement() {},

    SubExpression: function SubExpression(sexpr) {
      transformLiteralToPath(sexpr);
      var type = this.classifySexpr(sexpr);

      if (type === 'simple') {
        this.simpleSexpr(sexpr);
      } else if (type === 'helper') {
        this.helperSexpr(sexpr);
      } else {
        this.ambiguousSexpr(sexpr);
      }
    },
    ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
      var path = sexpr.path,
          name = path.parts[0],
          isBlock = program != null || inverse != null;

      this.opcode('getContext', path.depth);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      path.strict = true;
      this.accept(path);

      this.opcode('invokeAmbiguous', name, isBlock);
    },

    simpleSexpr: function simpleSexpr(sexpr) {
      var path = sexpr.path;
      path.strict = true;
      this.accept(path);
      this.opcode('resolvePossibleLambda');
    },

    helperSexpr: function helperSexpr(sexpr, program, inverse) {
      var params = this.setupFullMustacheParams(sexpr, program, inverse),
          path = sexpr.path,
          name = path.parts[0];

      if (this.options.knownHelpers[name]) {
        this.opcode('invokeKnownHelper', params.length, name);
      } else if (this.options.knownHelpersOnly) {
        throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
      } else {
        path.strict = true;
        path.falsy = true;

        this.accept(path);
        this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
      }
    },

    PathExpression: function PathExpression(path) {
      this.addDepth(path.depth);
      this.opcode('getContext', path.depth);

      var name = path.parts[0],
          scoped = _ast2['default'].helpers.scopedId(path),
          blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

      if (blockParamId) {
        this.opcode('lookupBlockParam', blockParamId, path.parts);
      } else if (!name) {
        // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
        this.opcode('pushContext');
      } else if (path.data) {
        this.options.data = true;
        this.opcode('lookupData', path.depth, path.parts, path.strict);
      } else {
        this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
      }
    },

    StringLiteral: function StringLiteral(string) {
      this.opcode('pushString', string.value);
    },

    NumberLiteral: function NumberLiteral(number) {
      this.opcode('pushLiteral', number.value);
    },

    BooleanLiteral: function BooleanLiteral(bool) {
      this.opcode('pushLiteral', bool.value);
    },

    UndefinedLiteral: function UndefinedLiteral() {
      this.opcode('pushLiteral', 'undefined');
    },

    NullLiteral: function NullLiteral() {
      this.opcode('pushLiteral', 'null');
    },

    Hash: function Hash(hash) {
      var pairs = hash.pairs,
          i = 0,
          l = pairs.length;

      this.opcode('pushHash');

      for (; i < l; i++) {
        this.pushParam(pairs[i].value);
      }
      while (i--) {
        this.opcode('assignToHash', pairs[i].key);
      }
      this.opcode('popHash');
    },

    // HELPERS
    opcode: function opcode(name) {
      this.opcodes.push({
        opcode: name,
        args: slice.call(arguments, 1),
        loc: this.sourceNode[0].loc
      });
    },

    addDepth: function addDepth(depth) {
      if (!depth) {
        return;
      }

      this.useDepths = true;
    },

    classifySexpr: function classifySexpr(sexpr) {
      var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

      var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

      // a mustache is an eligible helper if:
      // * its id is simple (a single part, not `this` or `..`)
      var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

      // if a mustache is an eligible helper but not a definite
      // helper, it is ambiguous, and will be resolved in a later
      // pass or at runtime.
      var isEligible = !isBlockParam && (isHelper || isSimple);

      // if ambiguous, we can possibly resolve the ambiguity now
      // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
      if (isEligible && !isHelper) {
        var _name = sexpr.path.parts[0],
            options = this.options;
        if (options.knownHelpers[_name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }

      if (isHelper) {
        return 'helper';
      } else if (isEligible) {
        return 'ambiguous';
      } else {
        return 'simple';
      }
    },

    pushParams: function pushParams(params) {
      for (var i = 0, l = params.length; i < l; i++) {
        this.pushParam(params[i]);
      }
    },

    pushParam: function pushParam(val) {
      var value = val.value != null ? val.value : val.original || '';

      if (this.stringParams) {
        if (value.replace) {
          value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
        }

        if (val.depth) {
          this.addDepth(val.depth);
        }
        this.opcode('getContext', val.depth || 0);
        this.opcode('pushStringParam', value, val.type);

        if (val.type === 'SubExpression') {
          // SubExpressions get evaluated and passed in
          // in string params mode.
          this.accept(val);
        }
      } else {
        if (this.trackIds) {
          var blockParamIndex = undefined;
          if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
            blockParamIndex = this.blockParamIndex(val.parts[0]);
          }
          if (blockParamIndex) {
            var blockParamChild = val.parts.slice(1).join('.');
            this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
          } else {
            value = val.original || value;
            if (value.replace) {
              value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
            }

            this.opcode('pushId', val.type, value);
          }
        }
        this.accept(val);
      }
    },

    setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
      var params = sexpr.params;
      this.pushParams(params);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      if (sexpr.hash) {
        this.accept(sexpr.hash);
      } else {
        this.opcode('emptyHash', omitEmpty);
      }

      return params;
    },

    blockParamIndex: function blockParamIndex(name) {
      for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
        var blockParams = this.options.blockParams[depth],
            param = blockParams && _utils.indexOf(blockParams, name);
        if (blockParams && param >= 0) {
          return [depth, param];
        }
      }
    }
  };

  function precompile(input, options, env) {
    if (input == null || typeof input !== 'string' && input.type !== 'Program') {
      throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
    }

    options = options || {};
    if (!('data' in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }

    var ast = env.parse(input, options),
        environment = new env.Compiler().compile(ast, options);
    return new env.JavaScriptCompiler().compile(environment, options);
  }

  function compile(input, options, env) {
    if (options === undefined) options = {};

    if (input == null || typeof input !== 'string' && input.type !== 'Program') {
      throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
    }

    options = _utils.extend({}, options);
    if (!('data' in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }

    var compiled = undefined;

    function compileInput() {
      var ast = env.parse(input, options),
          environment = new env.Compiler().compile(ast, options),
          templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
      return env.template(templateSpec);
    }

    // Template is only compiled on first use and cached after that point.
    function ret(context, execOptions) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled.call(this, context, execOptions);
    }
    ret._setup = function (setupOptions) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._setup(setupOptions);
    };
    ret._child = function (i, data, blockParams, depths) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._child(i, data, blockParams, depths);
    };
    return ret;
  }

  function argEquals(a, b) {
    if (a === b) {
      return true;
    }

    if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
      for (var i = 0; i < a.length; i++) {
        if (!argEquals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
  }

  function transformLiteralToPath(sexpr) {
    if (!sexpr.path.parts) {
      var literal = sexpr.path;
      // Casting to string here to make false and 0 literal values play nicely with the rest
      // of the system.
      sexpr.path = {
        type: 'PathExpression',
        data: false,
        depth: 0,
        parts: [literal.original + ''],
        original: literal.original + '',
        loc: literal.loc
      };
    }
  }

  var javascriptCompiler = {exports: {}};

  var codeGen = {exports: {}};

  var sourceMap = {};

  var sourceMapGenerator = {};

  var base64Vlq = {};

  var base64 = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredBase64;

  function requireBase64 () {
  	if (hasRequiredBase64) return base64;
  	hasRequiredBase64 = 1;
  	/*
  	 * Copyright 2011 Mozilla Foundation and contributors
  	 * Licensed under the New BSD license. See LICENSE or:
  	 * http://opensource.org/licenses/BSD-3-Clause
  	 */

  	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  	/**
  	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
  	 */
  	base64.encode = function (number) {
  	  if (0 <= number && number < intToCharMap.length) {
  	    return intToCharMap[number];
  	  }
  	  throw new TypeError("Must be between 0 and 63: " + number);
  	};

  	/**
  	 * Decode a single base 64 character code digit to an integer. Returns -1 on
  	 * failure.
  	 */
  	base64.decode = function (charCode) {
  	  var bigA = 65;     // 'A'
  	  var bigZ = 90;     // 'Z'

  	  var littleA = 97;  // 'a'
  	  var littleZ = 122; // 'z'

  	  var zero = 48;     // '0'
  	  var nine = 57;     // '9'

  	  var plus = 43;     // '+'
  	  var slash = 47;    // '/'

  	  var littleOffset = 26;
  	  var numberOffset = 52;

  	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  	  if (bigA <= charCode && charCode <= bigZ) {
  	    return (charCode - bigA);
  	  }

  	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  	  if (littleA <= charCode && charCode <= littleZ) {
  	    return (charCode - littleA + littleOffset);
  	  }

  	  // 52 - 61: 0123456789
  	  if (zero <= charCode && charCode <= nine) {
  	    return (charCode - zero + numberOffset);
  	  }

  	  // 62: +
  	  if (charCode == plus) {
  	    return 62;
  	  }

  	  // 63: /
  	  if (charCode == slash) {
  	    return 63;
  	  }

  	  // Invalid base64 digit.
  	  return -1;
  	};
  	return base64;
  }

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredBase64Vlq;

  function requireBase64Vlq () {
  	if (hasRequiredBase64Vlq) return base64Vlq;
  	hasRequiredBase64Vlq = 1;
  	/*
  	 * Copyright 2011 Mozilla Foundation and contributors
  	 * Licensed under the New BSD license. See LICENSE or:
  	 * http://opensource.org/licenses/BSD-3-Clause
  	 *
  	 * Based on the Base 64 VLQ implementation in Closure Compiler:
  	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
  	 *
  	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
  	 * Redistribution and use in source and binary forms, with or without
  	 * modification, are permitted provided that the following conditions are
  	 * met:
  	 *
  	 *  * Redistributions of source code must retain the above copyright
  	 *    notice, this list of conditions and the following disclaimer.
  	 *  * Redistributions in binary form must reproduce the above
  	 *    copyright notice, this list of conditions and the following
  	 *    disclaimer in the documentation and/or other materials provided
  	 *    with the distribution.
  	 *  * Neither the name of Google Inc. nor the names of its
  	 *    contributors may be used to endorse or promote products derived
  	 *    from this software without specific prior written permission.
  	 *
  	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	 */

  	var base64 = requireBase64();

  	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
  	// length quantities we use in the source map spec, the first bit is the sign,
  	// the next four bits are the actual value, and the 6th bit is the
  	// continuation bit. The continuation bit tells us whether there are more
  	// digits in this value following this digit.
  	//
  	//   Continuation
  	//   |    Sign
  	//   |    |
  	//   V    V
  	//   101011

  	var VLQ_BASE_SHIFT = 5;

  	// binary: 100000
  	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  	// binary: 011111
  	var VLQ_BASE_MASK = VLQ_BASE - 1;

  	// binary: 100000
  	var VLQ_CONTINUATION_BIT = VLQ_BASE;

  	/**
  	 * Converts from a two-complement value to a value where the sign bit is
  	 * placed in the least significant bit.  For example, as decimals:
  	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
  	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
  	 */
  	function toVLQSigned(aValue) {
  	  return aValue < 0
  	    ? ((-aValue) << 1) + 1
  	    : (aValue << 1) + 0;
  	}

  	/**
  	 * Converts to a two-complement value from a value where the sign bit is
  	 * placed in the least significant bit.  For example, as decimals:
  	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
  	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
  	 */
  	function fromVLQSigned(aValue) {
  	  var isNegative = (aValue & 1) === 1;
  	  var shifted = aValue >> 1;
  	  return isNegative
  	    ? -shifted
  	    : shifted;
  	}

  	/**
  	 * Returns the base 64 VLQ encoded value.
  	 */
  	base64Vlq.encode = function base64VLQ_encode(aValue) {
  	  var encoded = "";
  	  var digit;

  	  var vlq = toVLQSigned(aValue);

  	  do {
  	    digit = vlq & VLQ_BASE_MASK;
  	    vlq >>>= VLQ_BASE_SHIFT;
  	    if (vlq > 0) {
  	      // There are still more digits in this value, so we must make sure the
  	      // continuation bit is marked.
  	      digit |= VLQ_CONTINUATION_BIT;
  	    }
  	    encoded += base64.encode(digit);
  	  } while (vlq > 0);

  	  return encoded;
  	};

  	/**
  	 * Decodes the next base 64 VLQ value from the given string and returns the
  	 * value and the rest of the string via the out parameter.
  	 */
  	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  	  var strLen = aStr.length;
  	  var result = 0;
  	  var shift = 0;
  	  var continuation, digit;

  	  do {
  	    if (aIndex >= strLen) {
  	      throw new Error("Expected more digits in base 64 VLQ value.");
  	    }

  	    digit = base64.decode(aStr.charCodeAt(aIndex++));
  	    if (digit === -1) {
  	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
  	    }

  	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
  	    digit &= VLQ_BASE_MASK;
  	    result = result + (digit << shift);
  	    shift += VLQ_BASE_SHIFT;
  	  } while (continuation);

  	  aOutParam.value = fromVLQSigned(result);
  	  aOutParam.rest = aIndex;
  	};
  	return base64Vlq;
  }

  var util = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredUtil;

  function requireUtil () {
  	if (hasRequiredUtil) return util;
  	hasRequiredUtil = 1;
  	(function (exports) {
  		/*
  		 * Copyright 2011 Mozilla Foundation and contributors
  		 * Licensed under the New BSD license. See LICENSE or:
  		 * http://opensource.org/licenses/BSD-3-Clause
  		 */

  		/**
  		 * This is a helper function for getting values from parameter/options
  		 * objects.
  		 *
  		 * @param args The object we are extracting values from
  		 * @param name The name of the property we are getting.
  		 * @param defaultValue An optional value to return if the property is missing
  		 * from the object. If this is not specified and the property is missing, an
  		 * error will be thrown.
  		 */
  		function getArg(aArgs, aName, aDefaultValue) {
  		  if (aName in aArgs) {
  		    return aArgs[aName];
  		  } else if (arguments.length === 3) {
  		    return aDefaultValue;
  		  } else {
  		    throw new Error('"' + aName + '" is a required argument.');
  		  }
  		}
  		exports.getArg = getArg;

  		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  		var dataUrlRegexp = /^data:.+\,.+$/;

  		function urlParse(aUrl) {
  		  var match = aUrl.match(urlRegexp);
  		  if (!match) {
  		    return null;
  		  }
  		  return {
  		    scheme: match[1],
  		    auth: match[2],
  		    host: match[3],
  		    port: match[4],
  		    path: match[5]
  		  };
  		}
  		exports.urlParse = urlParse;

  		function urlGenerate(aParsedUrl) {
  		  var url = '';
  		  if (aParsedUrl.scheme) {
  		    url += aParsedUrl.scheme + ':';
  		  }
  		  url += '//';
  		  if (aParsedUrl.auth) {
  		    url += aParsedUrl.auth + '@';
  		  }
  		  if (aParsedUrl.host) {
  		    url += aParsedUrl.host;
  		  }
  		  if (aParsedUrl.port) {
  		    url += ":" + aParsedUrl.port;
  		  }
  		  if (aParsedUrl.path) {
  		    url += aParsedUrl.path;
  		  }
  		  return url;
  		}
  		exports.urlGenerate = urlGenerate;

  		/**
  		 * Normalizes a path, or the path portion of a URL:
  		 *
  		 * - Replaces consecutive slashes with one slash.
  		 * - Removes unnecessary '.' parts.
  		 * - Removes unnecessary '<dir>/..' parts.
  		 *
  		 * Based on code in the Node.js 'path' core module.
  		 *
  		 * @param aPath The path or url to normalize.
  		 */
  		function normalize(aPath) {
  		  var path = aPath;
  		  var url = urlParse(aPath);
  		  if (url) {
  		    if (!url.path) {
  		      return aPath;
  		    }
  		    path = url.path;
  		  }
  		  var isAbsolute = exports.isAbsolute(path);

  		  var parts = path.split(/\/+/);
  		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
  		    part = parts[i];
  		    if (part === '.') {
  		      parts.splice(i, 1);
  		    } else if (part === '..') {
  		      up++;
  		    } else if (up > 0) {
  		      if (part === '') {
  		        // The first part is blank if the path is absolute. Trying to go
  		        // above the root is a no-op. Therefore we can remove all '..' parts
  		        // directly after the root.
  		        parts.splice(i + 1, up);
  		        up = 0;
  		      } else {
  		        parts.splice(i, 2);
  		        up--;
  		      }
  		    }
  		  }
  		  path = parts.join('/');

  		  if (path === '') {
  		    path = isAbsolute ? '/' : '.';
  		  }

  		  if (url) {
  		    url.path = path;
  		    return urlGenerate(url);
  		  }
  		  return path;
  		}
  		exports.normalize = normalize;

  		/**
  		 * Joins two paths/URLs.
  		 *
  		 * @param aRoot The root path or URL.
  		 * @param aPath The path or URL to be joined with the root.
  		 *
  		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
  		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
  		 *   first.
  		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
  		 *   is updated with the result and aRoot is returned. Otherwise the result
  		 *   is returned.
  		 *   - If aPath is absolute, the result is aPath.
  		 *   - Otherwise the two paths are joined with a slash.
  		 * - Joining for example 'http://' and 'www.example.com' is also supported.
  		 */
  		function join(aRoot, aPath) {
  		  if (aRoot === "") {
  		    aRoot = ".";
  		  }
  		  if (aPath === "") {
  		    aPath = ".";
  		  }
  		  var aPathUrl = urlParse(aPath);
  		  var aRootUrl = urlParse(aRoot);
  		  if (aRootUrl) {
  		    aRoot = aRootUrl.path || '/';
  		  }

  		  // `join(foo, '//www.example.org')`
  		  if (aPathUrl && !aPathUrl.scheme) {
  		    if (aRootUrl) {
  		      aPathUrl.scheme = aRootUrl.scheme;
  		    }
  		    return urlGenerate(aPathUrl);
  		  }

  		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
  		    return aPath;
  		  }

  		  // `join('http://', 'www.example.com')`
  		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
  		    aRootUrl.host = aPath;
  		    return urlGenerate(aRootUrl);
  		  }

  		  var joined = aPath.charAt(0) === '/'
  		    ? aPath
  		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  		  if (aRootUrl) {
  		    aRootUrl.path = joined;
  		    return urlGenerate(aRootUrl);
  		  }
  		  return joined;
  		}
  		exports.join = join;

  		exports.isAbsolute = function (aPath) {
  		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
  		};

  		/**
  		 * Make a path relative to a URL or another path.
  		 *
  		 * @param aRoot The root path or URL.
  		 * @param aPath The path or URL to be made relative to aRoot.
  		 */
  		function relative(aRoot, aPath) {
  		  if (aRoot === "") {
  		    aRoot = ".";
  		  }

  		  aRoot = aRoot.replace(/\/$/, '');

  		  // It is possible for the path to be above the root. In this case, simply
  		  // checking whether the root is a prefix of the path won't work. Instead, we
  		  // need to remove components from the root one by one, until either we find
  		  // a prefix that fits, or we run out of components to remove.
  		  var level = 0;
  		  while (aPath.indexOf(aRoot + '/') !== 0) {
  		    var index = aRoot.lastIndexOf("/");
  		    if (index < 0) {
  		      return aPath;
  		    }

  		    // If the only part of the root that is left is the scheme (i.e. http://,
  		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
  		    // have exhausted all components, so the path is not relative to the root.
  		    aRoot = aRoot.slice(0, index);
  		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
  		      return aPath;
  		    }

  		    ++level;
  		  }

  		  // Make sure we add a "../" for each component we removed from the root.
  		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  		}
  		exports.relative = relative;

  		var supportsNullProto = (function () {
  		  var obj = Object.create(null);
  		  return !('__proto__' in obj);
  		}());

  		function identity (s) {
  		  return s;
  		}

  		/**
  		 * Because behavior goes wacky when you set `__proto__` on objects, we
  		 * have to prefix all the strings in our set with an arbitrary character.
  		 *
  		 * See https://github.com/mozilla/source-map/pull/31 and
  		 * https://github.com/mozilla/source-map/issues/30
  		 *
  		 * @param String aStr
  		 */
  		function toSetString(aStr) {
  		  if (isProtoString(aStr)) {
  		    return '$' + aStr;
  		  }

  		  return aStr;
  		}
  		exports.toSetString = supportsNullProto ? identity : toSetString;

  		function fromSetString(aStr) {
  		  if (isProtoString(aStr)) {
  		    return aStr.slice(1);
  		  }

  		  return aStr;
  		}
  		exports.fromSetString = supportsNullProto ? identity : fromSetString;

  		function isProtoString(s) {
  		  if (!s) {
  		    return false;
  		  }

  		  var length = s.length;

  		  if (length < 9 /* "__proto__".length */) {
  		    return false;
  		  }

  		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
  		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
  		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
  		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
  		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
  		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
  		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
  		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
  		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
  		    return false;
  		  }

  		  for (var i = length - 10; i >= 0; i--) {
  		    if (s.charCodeAt(i) !== 36 /* '$' */) {
  		      return false;
  		    }
  		  }

  		  return true;
  		}

  		/**
  		 * Comparator between two mappings where the original positions are compared.
  		 *
  		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
  		 * mappings with the same original source/line/column, but different generated
  		 * line and column the same. Useful when searching for a mapping with a
  		 * stubbed out mapping.
  		 */
  		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  		  var cmp = strcmp(mappingA.source, mappingB.source);
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.originalLine - mappingB.originalLine;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.originalColumn - mappingB.originalColumn;
  		  if (cmp !== 0 || onlyCompareOriginal) {
  		    return cmp;
  		  }

  		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.generatedLine - mappingB.generatedLine;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  return strcmp(mappingA.name, mappingB.name);
  		}
  		exports.compareByOriginalPositions = compareByOriginalPositions;

  		/**
  		 * Comparator between two mappings with deflated source and name indices where
  		 * the generated positions are compared.
  		 *
  		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
  		 * mappings with the same generated line and column, but different
  		 * source/name/original line and column the same. Useful when searching for a
  		 * mapping with a stubbed out mapping.
  		 */
  		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  		  if (cmp !== 0 || onlyCompareGenerated) {
  		    return cmp;
  		  }

  		  cmp = strcmp(mappingA.source, mappingB.source);
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.originalLine - mappingB.originalLine;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.originalColumn - mappingB.originalColumn;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  return strcmp(mappingA.name, mappingB.name);
  		}
  		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  		function strcmp(aStr1, aStr2) {
  		  if (aStr1 === aStr2) {
  		    return 0;
  		  }

  		  if (aStr1 === null) {
  		    return 1; // aStr2 !== null
  		  }

  		  if (aStr2 === null) {
  		    return -1; // aStr1 !== null
  		  }

  		  if (aStr1 > aStr2) {
  		    return 1;
  		  }

  		  return -1;
  		}

  		/**
  		 * Comparator between two mappings with inflated source and name strings where
  		 * the generated positions are compared.
  		 */
  		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = strcmp(mappingA.source, mappingB.source);
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.originalLine - mappingB.originalLine;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  cmp = mappingA.originalColumn - mappingB.originalColumn;
  		  if (cmp !== 0) {
  		    return cmp;
  		  }

  		  return strcmp(mappingA.name, mappingB.name);
  		}
  		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

  		/**
  		 * Strip any JSON XSSI avoidance prefix from the string (as documented
  		 * in the source maps specification), and then parse the string as
  		 * JSON.
  		 */
  		function parseSourceMapInput(str) {
  		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
  		}
  		exports.parseSourceMapInput = parseSourceMapInput;

  		/**
  		 * Compute the URL of a source given the the source root, the source's
  		 * URL, and the source map's URL.
  		 */
  		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  		  sourceURL = sourceURL || '';

  		  if (sourceRoot) {
  		    // This follows what Chrome does.
  		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
  		      sourceRoot += '/';
  		    }
  		    // The spec says:
  		    //   Line 4: An optional source root, useful for relocating source
  		    //   files on a server or removing repeated values in the
  		    //   sources entry.  This value is prepended to the individual
  		    //   entries in the source field.
  		    sourceURL = sourceRoot + sourceURL;
  		  }

  		  // Historically, SourceMapConsumer did not take the sourceMapURL as
  		  // a parameter.  This mode is still somewhat supported, which is why
  		  // this code block is conditional.  However, it's preferable to pass
  		  // the source map URL to SourceMapConsumer, so that this function
  		  // can implement the source URL resolution algorithm as outlined in
  		  // the spec.  This block is basically the equivalent of:
  		  //    new URL(sourceURL, sourceMapURL).toString()
  		  // ... except it avoids using URL, which wasn't available in the
  		  // older releases of node still supported by this library.
  		  //
  		  // The spec says:
  		  //   If the sources are not absolute URLs after prepending of the
  		  //   sourceRoot, the sources are resolved relative to the
  		  //   SourceMap (like resolving script src in a html document).
  		  if (sourceMapURL) {
  		    var parsed = urlParse(sourceMapURL);
  		    if (!parsed) {
  		      throw new Error("sourceMapURL could not be parsed");
  		    }
  		    if (parsed.path) {
  		      // Strip the last path component, but keep the "/".
  		      var index = parsed.path.lastIndexOf('/');
  		      if (index >= 0) {
  		        parsed.path = parsed.path.substring(0, index + 1);
  		      }
  		    }
  		    sourceURL = join(urlGenerate(parsed), sourceURL);
  		  }

  		  return normalize(sourceURL);
  		}
  		exports.computeSourceURL = computeSourceURL; 
  	} (util));
  	return util;
  }

  var arraySet = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredArraySet;

  function requireArraySet () {
  	if (hasRequiredArraySet) return arraySet;
  	hasRequiredArraySet = 1;
  	/*
  	 * Copyright 2011 Mozilla Foundation and contributors
  	 * Licensed under the New BSD license. See LICENSE or:
  	 * http://opensource.org/licenses/BSD-3-Clause
  	 */

  	var util = requireUtil();
  	var has = Object.prototype.hasOwnProperty;
  	var hasNativeMap = typeof Map !== "undefined";

  	/**
  	 * A data structure which is a combination of an array and a set. Adding a new
  	 * member is O(1), testing for membership is O(1), and finding the index of an
  	 * element is O(1). Removing elements from the set is not supported. Only
  	 * strings are supported for membership.
  	 */
  	function ArraySet() {
  	  this._array = [];
  	  this._set = hasNativeMap ? new Map() : Object.create(null);
  	}

  	/**
  	 * Static method for creating ArraySet instances from an existing array.
  	 */
  	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  	  var set = new ArraySet();
  	  for (var i = 0, len = aArray.length; i < len; i++) {
  	    set.add(aArray[i], aAllowDuplicates);
  	  }
  	  return set;
  	};

  	/**
  	 * Return how many unique items are in this ArraySet. If duplicates have been
  	 * added, than those do not count towards the size.
  	 *
  	 * @returns Number
  	 */
  	ArraySet.prototype.size = function ArraySet_size() {
  	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  	};

  	/**
  	 * Add the given string to this set.
  	 *
  	 * @param String aStr
  	 */
  	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  	  var idx = this._array.length;
  	  if (!isDuplicate || aAllowDuplicates) {
  	    this._array.push(aStr);
  	  }
  	  if (!isDuplicate) {
  	    if (hasNativeMap) {
  	      this._set.set(aStr, idx);
  	    } else {
  	      this._set[sStr] = idx;
  	    }
  	  }
  	};

  	/**
  	 * Is the given string a member of this set?
  	 *
  	 * @param String aStr
  	 */
  	ArraySet.prototype.has = function ArraySet_has(aStr) {
  	  if (hasNativeMap) {
  	    return this._set.has(aStr);
  	  } else {
  	    var sStr = util.toSetString(aStr);
  	    return has.call(this._set, sStr);
  	  }
  	};

  	/**
  	 * What is the index of the given string in the array?
  	 *
  	 * @param String aStr
  	 */
  	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  	  if (hasNativeMap) {
  	    var idx = this._set.get(aStr);
  	    if (idx >= 0) {
  	        return idx;
  	    }
  	  } else {
  	    var sStr = util.toSetString(aStr);
  	    if (has.call(this._set, sStr)) {
  	      return this._set[sStr];
  	    }
  	  }

  	  throw new Error('"' + aStr + '" is not in the set.');
  	};

  	/**
  	 * What is the element at the given index?
  	 *
  	 * @param Number aIdx
  	 */
  	ArraySet.prototype.at = function ArraySet_at(aIdx) {
  	  if (aIdx >= 0 && aIdx < this._array.length) {
  	    return this._array[aIdx];
  	  }
  	  throw new Error('No element indexed by ' + aIdx);
  	};

  	/**
  	 * Returns the array representation of this set (which has the proper indices
  	 * indicated by indexOf). Note that this is a copy of the internal array used
  	 * for storing the members so that no one can mess with internal state.
  	 */
  	ArraySet.prototype.toArray = function ArraySet_toArray() {
  	  return this._array.slice();
  	};

  	arraySet.ArraySet = ArraySet;
  	return arraySet;
  }

  var mappingList = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredMappingList;

  function requireMappingList () {
  	if (hasRequiredMappingList) return mappingList;
  	hasRequiredMappingList = 1;
  	/*
  	 * Copyright 2014 Mozilla Foundation and contributors
  	 * Licensed under the New BSD license. See LICENSE or:
  	 * http://opensource.org/licenses/BSD-3-Clause
  	 */

  	var util = requireUtil();

  	/**
  	 * Determine whether mappingB is after mappingA with respect to generated
  	 * position.
  	 */
  	function generatedPositionAfter(mappingA, mappingB) {
  	  // Optimized for most common case
  	  var lineA = mappingA.generatedLine;
  	  var lineB = mappingB.generatedLine;
  	  var columnA = mappingA.generatedColumn;
  	  var columnB = mappingB.generatedColumn;
  	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
  	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  	}

  	/**
  	 * A data structure to provide a sorted view of accumulated mappings in a
  	 * performance conscious manner. It trades a neglibable overhead in general
  	 * case for a large speedup in case of mappings being added in order.
  	 */
  	function MappingList() {
  	  this._array = [];
  	  this._sorted = true;
  	  // Serves as infimum
  	  this._last = {generatedLine: -1, generatedColumn: 0};
  	}

  	/**
  	 * Iterate through internal items. This method takes the same arguments that
  	 * `Array.prototype.forEach` takes.
  	 *
  	 * NOTE: The order of the mappings is NOT guaranteed.
  	 */
  	MappingList.prototype.unsortedForEach =
  	  function MappingList_forEach(aCallback, aThisArg) {
  	    this._array.forEach(aCallback, aThisArg);
  	  };

  	/**
  	 * Add the given source mapping.
  	 *
  	 * @param Object aMapping
  	 */
  	MappingList.prototype.add = function MappingList_add(aMapping) {
  	  if (generatedPositionAfter(this._last, aMapping)) {
  	    this._last = aMapping;
  	    this._array.push(aMapping);
  	  } else {
  	    this._sorted = false;
  	    this._array.push(aMapping);
  	  }
  	};

  	/**
  	 * Returns the flat, sorted array of mappings. The mappings are sorted by
  	 * generated position.
  	 *
  	 * WARNING: This method returns internal data without copying, for
  	 * performance. The return value must NOT be mutated, and should be treated as
  	 * an immutable borrow. If you want to take ownership, you must make your own
  	 * copy.
  	 */
  	MappingList.prototype.toArray = function MappingList_toArray() {
  	  if (!this._sorted) {
  	    this._array.sort(util.compareByGeneratedPositionsInflated);
  	    this._sorted = true;
  	  }
  	  return this._array;
  	};

  	mappingList.MappingList = MappingList;
  	return mappingList;
  }

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredSourceMapGenerator;

  function requireSourceMapGenerator () {
  	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  	hasRequiredSourceMapGenerator = 1;
  	/*
  	 * Copyright 2011 Mozilla Foundation and contributors
  	 * Licensed under the New BSD license. See LICENSE or:
  	 * http://opensource.org/licenses/BSD-3-Clause
  	 */

  	var base64VLQ = requireBase64Vlq();
  	var util = requireUtil();
  	var ArraySet = requireArraySet().ArraySet;
  	var MappingList = requireMappingList().MappingList;

  	/**
  	 * An instance of the SourceMapGenerator represents a source map which is
  	 * being built incrementally. You may pass an object with the following
  	 * properties:
  	 *
  	 *   - file: The filename of the generated source.
  	 *   - sourceRoot: A root for all relative URLs in this source map.
  	 */
  	function SourceMapGenerator(aArgs) {
  	  if (!aArgs) {
  	    aArgs = {};
  	  }
  	  this._file = util.getArg(aArgs, 'file', null);
  	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  	  this._sources = new ArraySet();
  	  this._names = new ArraySet();
  	  this._mappings = new MappingList();
  	  this._sourcesContents = null;
  	}

  	SourceMapGenerator.prototype._version = 3;

  	/**
  	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
  	 *
  	 * @param aSourceMapConsumer The SourceMap.
  	 */
  	SourceMapGenerator.fromSourceMap =
  	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  	    var sourceRoot = aSourceMapConsumer.sourceRoot;
  	    var generator = new SourceMapGenerator({
  	      file: aSourceMapConsumer.file,
  	      sourceRoot: sourceRoot
  	    });
  	    aSourceMapConsumer.eachMapping(function (mapping) {
  	      var newMapping = {
  	        generated: {
  	          line: mapping.generatedLine,
  	          column: mapping.generatedColumn
  	        }
  	      };

  	      if (mapping.source != null) {
  	        newMapping.source = mapping.source;
  	        if (sourceRoot != null) {
  	          newMapping.source = util.relative(sourceRoot, newMapping.source);
  	        }

  	        newMapping.original = {
  	          line: mapping.originalLine,
  	          column: mapping.originalColumn
  	        };

  	        if (mapping.name != null) {
  	          newMapping.name = mapping.name;
  	        }
  	      }

  	      generator.addMapping(newMapping);
  	    });
  	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
  	      var sourceRelative = sourceFile;
  	      if (sourceRoot !== null) {
  	        sourceRelative = util.relative(sourceRoot, sourceFile);
  	      }

  	      if (!generator._sources.has(sourceRelative)) {
  	        generator._sources.add(sourceRelative);
  	      }

  	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
  	      if (content != null) {
  	        generator.setSourceContent(sourceFile, content);
  	      }
  	    });
  	    return generator;
  	  };

  	/**
  	 * Add a single mapping from original source line and column to the generated
  	 * source's line and column for this source map being created. The mapping
  	 * object should have the following properties:
  	 *
  	 *   - generated: An object with the generated line and column positions.
  	 *   - original: An object with the original line and column positions.
  	 *   - source: The original source file (relative to the sourceRoot).
  	 *   - name: An optional original token name for this mapping.
  	 */
  	SourceMapGenerator.prototype.addMapping =
  	  function SourceMapGenerator_addMapping(aArgs) {
  	    var generated = util.getArg(aArgs, 'generated');
  	    var original = util.getArg(aArgs, 'original', null);
  	    var source = util.getArg(aArgs, 'source', null);
  	    var name = util.getArg(aArgs, 'name', null);

  	    if (!this._skipValidation) {
  	      this._validateMapping(generated, original, source, name);
  	    }

  	    if (source != null) {
  	      source = String(source);
  	      if (!this._sources.has(source)) {
  	        this._sources.add(source);
  	      }
  	    }

  	    if (name != null) {
  	      name = String(name);
  	      if (!this._names.has(name)) {
  	        this._names.add(name);
  	      }
  	    }

  	    this._mappings.add({
  	      generatedLine: generated.line,
  	      generatedColumn: generated.column,
  	      originalLine: original != null && original.line,
  	      originalColumn: original != null && original.column,
  	      source: source,
  	      name: name
  	    });
  	  };

  	/**
  	 * Set the source content for a source file.
  	 */
  	SourceMapGenerator.prototype.setSourceContent =
  	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  	    var source = aSourceFile;
  	    if (this._sourceRoot != null) {
  	      source = util.relative(this._sourceRoot, source);
  	    }

  	    if (aSourceContent != null) {
  	      // Add the source content to the _sourcesContents map.
  	      // Create a new _sourcesContents map if the property is null.
  	      if (!this._sourcesContents) {
  	        this._sourcesContents = Object.create(null);
  	      }
  	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
  	    } else if (this._sourcesContents) {
  	      // Remove the source file from the _sourcesContents map.
  	      // If the _sourcesContents map is empty, set the property to null.
  	      delete this._sourcesContents[util.toSetString(source)];
  	      if (Object.keys(this._sourcesContents).length === 0) {
  	        this._sourcesContents = null;
  	      }
  	    }
  	  };

  	/**
  	 * Applies the mappings of a sub-source-map for a specific source file to the
  	 * source map being generated. Each mapping to the supplied source file is
  	 * rewritten using the supplied source map. Note: The resolution for the
  	 * resulting mappings is the minimium of this map and the supplied map.
  	 *
  	 * @param aSourceMapConsumer The source map to be applied.
  	 * @param aSourceFile Optional. The filename of the source file.
  	 *        If omitted, SourceMapConsumer's file property will be used.
  	 * @param aSourceMapPath Optional. The dirname of the path to the source map
  	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
  	 *        This parameter is needed when the two source maps aren't in the same
  	 *        directory, and the source map to be applied contains relative source
  	 *        paths. If so, those relative source paths need to be rewritten
  	 *        relative to the SourceMapGenerator.
  	 */
  	SourceMapGenerator.prototype.applySourceMap =
  	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  	    var sourceFile = aSourceFile;
  	    // If aSourceFile is omitted, we will use the file property of the SourceMap
  	    if (aSourceFile == null) {
  	      if (aSourceMapConsumer.file == null) {
  	        throw new Error(
  	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
  	          'or the source map\'s "file" property. Both were omitted.'
  	        );
  	      }
  	      sourceFile = aSourceMapConsumer.file;
  	    }
  	    var sourceRoot = this._sourceRoot;
  	    // Make "sourceFile" relative if an absolute Url is passed.
  	    if (sourceRoot != null) {
  	      sourceFile = util.relative(sourceRoot, sourceFile);
  	    }
  	    // Applying the SourceMap can add and remove items from the sources and
  	    // the names array.
  	    var newSources = new ArraySet();
  	    var newNames = new ArraySet();

  	    // Find mappings for the "sourceFile"
  	    this._mappings.unsortedForEach(function (mapping) {
  	      if (mapping.source === sourceFile && mapping.originalLine != null) {
  	        // Check if it can be mapped by the source map, then update the mapping.
  	        var original = aSourceMapConsumer.originalPositionFor({
  	          line: mapping.originalLine,
  	          column: mapping.originalColumn
  	        });
  	        if (original.source != null) {
  	          // Copy mapping
  	          mapping.source = original.source;
  	          if (aSourceMapPath != null) {
  	            mapping.source = util.join(aSourceMapPath, mapping.source);
  	          }
  	          if (sourceRoot != null) {
  	            mapping.source = util.relative(sourceRoot, mapping.source);
  	          }
  	          mapping.originalLine = original.line;
  	          mapping.originalColumn = original.column;
  	          if (original.name != null) {
  	            mapping.name = original.name;
  	          }
  	        }
  	      }

  	      var source = mapping.source;
  	      if (source != null && !newSources.has(source)) {
  	        newSources.add(source);
  	      }

  	      var name = mapping.name;
  	      if (name != null && !newNames.has(name)) {
  	        newNames.add(name);
  	      }

  	    }, this);
  	    this._sources = newSources;
  	    this._names = newNames;

  	    // Copy sourcesContents of applied map.
  	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
  	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
  	      if (content != null) {
  	        if (aSourceMapPath != null) {
  	          sourceFile = util.join(aSourceMapPath, sourceFile);
  	        }
  	        if (sourceRoot != null) {
  	          sourceFile = util.relative(sourceRoot, sourceFile);
  	        }
  	        this.setSourceContent(sourceFile, content);
  	      }
  	    }, this);
  	  };

  	/**
  	 * A mapping can have one of the three levels of data:
  	 *
  	 *   1. Just the generated position.
  	 *   2. The Generated position, original position, and original source.
  	 *   3. Generated and original position, original source, as well as a name
  	 *      token.
  	 *
  	 * To maintain consistency, we validate that any new mapping being added falls
  	 * in to one of these categories.
  	 */
  	SourceMapGenerator.prototype._validateMapping =
  	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
  	                                              aName) {
  	    // When aOriginal is truthy but has empty values for .line and .column,
  	    // it is most likely a programmer error. In this case we throw a very
  	    // specific error message to try to guide them the right way.
  	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
  	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
  	        throw new Error(
  	            'original.line and original.column are not numbers -- you probably meant to omit ' +
  	            'the original mapping entirely and only map the generated position. If so, pass ' +
  	            'null for the original mapping instead of an object with empty or null values.'
  	        );
  	    }

  	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
  	        && aGenerated.line > 0 && aGenerated.column >= 0
  	        && !aOriginal && !aSource && !aName) {
  	      // Case 1.
  	      return;
  	    }
  	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
  	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
  	             && aGenerated.line > 0 && aGenerated.column >= 0
  	             && aOriginal.line > 0 && aOriginal.column >= 0
  	             && aSource) {
  	      // Cases 2 and 3.
  	      return;
  	    }
  	    else {
  	      throw new Error('Invalid mapping: ' + JSON.stringify({
  	        generated: aGenerated,
  	        source: aSource,
  	        original: aOriginal,
  	        name: aName
  	      }));
  	    }
  	  };

  	/**
  	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
  	 * specified by the source map format.
  	 */
  	SourceMapGenerator.prototype._serializeMappings =
  	  function SourceMapGenerator_serializeMappings() {
  	    var previousGeneratedColumn = 0;
  	    var previousGeneratedLine = 1;
  	    var previousOriginalColumn = 0;
  	    var previousOriginalLine = 0;
  	    var previousName = 0;
  	    var previousSource = 0;
  	    var result = '';
  	    var next;
  	    var mapping;
  	    var nameIdx;
  	    var sourceIdx;

  	    var mappings = this._mappings.toArray();
  	    for (var i = 0, len = mappings.length; i < len; i++) {
  	      mapping = mappings[i];
  	      next = '';

  	      if (mapping.generatedLine !== previousGeneratedLine) {
  	        previousGeneratedColumn = 0;
  	        while (mapping.generatedLine !== previousGeneratedLine) {
  	          next += ';';
  	          previousGeneratedLine++;
  	        }
  	      }
  	      else {
  	        if (i > 0) {
  	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
  	            continue;
  	          }
  	          next += ',';
  	        }
  	      }

  	      next += base64VLQ.encode(mapping.generatedColumn
  	                                 - previousGeneratedColumn);
  	      previousGeneratedColumn = mapping.generatedColumn;

  	      if (mapping.source != null) {
  	        sourceIdx = this._sources.indexOf(mapping.source);
  	        next += base64VLQ.encode(sourceIdx - previousSource);
  	        previousSource = sourceIdx;

  	        // lines are stored 0-based in SourceMap spec version 3
  	        next += base64VLQ.encode(mapping.originalLine - 1
  	                                   - previousOriginalLine);
  	        previousOriginalLine = mapping.originalLine - 1;

  	        next += base64VLQ.encode(mapping.originalColumn
  	                                   - previousOriginalColumn);
  	        previousOriginalColumn = mapping.originalColumn;

  	        if (mapping.name != null) {
  	          nameIdx = this._names.indexOf(mapping.name);
  	          next += base64VLQ.encode(nameIdx - previousName);
  	          previousName = nameIdx;
  	        }
  	      }

  	      result += next;
  	    }

  	    return result;
  	  };

  	SourceMapGenerator.prototype._generateSourcesContent =
  	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  	    return aSources.map(function (source) {
  	      if (!this._sourcesContents) {
  	        return null;
  	      }
  	      if (aSourceRoot != null) {
  	        source = util.relative(aSourceRoot, source);
  	      }
  	      var key = util.toSetString(source);
  	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
  	        ? this._sourcesContents[key]
  	        : null;
  	    }, this);
  	  };

  	/**
  	 * Externalize the source map.
  	 */
  	SourceMapGenerator.prototype.toJSON =
  	  function SourceMapGenerator_toJSON() {
  	    var map = {
  	      version: this._version,
  	      sources: this._sources.toArray(),
  	      names: this._names.toArray(),
  	      mappings: this._serializeMappings()
  	    };
  	    if (this._file != null) {
  	      map.file = this._file;
  	    }
  	    if (this._sourceRoot != null) {
  	      map.sourceRoot = this._sourceRoot;
  	    }
  	    if (this._sourcesContents) {
  	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  	    }

  	    return map;
  	  };

  	/**
  	 * Render the source map being generated to a string.
  	 */
  	SourceMapGenerator.prototype.toString =
  	  function SourceMapGenerator_toString() {
  	    return JSON.stringify(this.toJSON());
  	  };

  	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  	return sourceMapGenerator;
  }

  var sourceMapConsumer = {};

  var binarySearch = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredBinarySearch;

  function requireBinarySearch () {
  	if (hasRequiredBinarySearch) return binarySearch;
  	hasRequiredBinarySearch = 1;
  	(function (exports) {
  		/*
  		 * Copyright 2011 Mozilla Foundation and contributors
  		 * Licensed under the New BSD license. See LICENSE or:
  		 * http://opensource.org/licenses/BSD-3-Clause
  		 */

  		exports.GREATEST_LOWER_BOUND = 1;
  		exports.LEAST_UPPER_BOUND = 2;

  		/**
  		 * Recursive implementation of binary search.
  		 *
  		 * @param aLow Indices here and lower do not contain the needle.
  		 * @param aHigh Indices here and higher do not contain the needle.
  		 * @param aNeedle The element being searched for.
  		 * @param aHaystack The non-empty array being searched.
  		 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
  		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
  		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
  		 *     closest element that is smaller than or greater than the one we are
  		 *     searching for, respectively, if the exact element cannot be found.
  		 */
  		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  		  // This function terminates when one of the following is true:
  		  //
  		  //   1. We find the exact element we are looking for.
  		  //
  		  //   2. We did not find the exact element, but we can return the index of
  		  //      the next-closest element.
  		  //
  		  //   3. We did not find the exact element, and there is no next-closest
  		  //      element than the one we are searching for, so we return -1.
  		  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  		  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  		  if (cmp === 0) {
  		    // Found the element we are looking for.
  		    return mid;
  		  }
  		  else if (cmp > 0) {
  		    // Our needle is greater than aHaystack[mid].
  		    if (aHigh - mid > 1) {
  		      // The element is in the upper half.
  		      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
  		    }

  		    // The exact needle element was not found in this haystack. Determine if
  		    // we are in termination case (3) or (2) and return the appropriate thing.
  		    if (aBias == exports.LEAST_UPPER_BOUND) {
  		      return aHigh < aHaystack.length ? aHigh : -1;
  		    } else {
  		      return mid;
  		    }
  		  }
  		  else {
  		    // Our needle is less than aHaystack[mid].
  		    if (mid - aLow > 1) {
  		      // The element is in the lower half.
  		      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
  		    }

  		    // we are in termination case (3) or (2) and return the appropriate thing.
  		    if (aBias == exports.LEAST_UPPER_BOUND) {
  		      return mid;
  		    } else {
  		      return aLow < 0 ? -1 : aLow;
  		    }
  		  }
  		}

  		/**
  		 * This is an implementation of binary search which will always try and return
  		 * the index of the closest element if there is no exact hit. This is because
  		 * mappings between original and generated line/col pairs are single points,
  		 * and there is an implicit region between each of them, so a miss just means
  		 * that you aren't on the very start of a region.
  		 *
  		 * @param aNeedle The element you are looking for.
  		 * @param aHaystack The array that is being searched.
  		 * @param aCompare A function which takes the needle and an element in the
  		 *     array and returns -1, 0, or 1 depending on whether the needle is less
  		 *     than, equal to, or greater than the element, respectively.
  		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
  		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
  		 *     closest element that is smaller than or greater than the one we are
  		 *     searching for, respectively, if the exact element cannot be found.
  		 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
  		 */
  		exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  		  if (aHaystack.length === 0) {
  		    return -1;
  		  }

  		  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
  		                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  		  if (index < 0) {
  		    return -1;
  		  }

  		  // We have found either the exact element, or the next-closest element than
  		  // the one we are searching for. However, there may be more than one such
  		  // element. Make sure we always return the smallest of these.
  		  while (index - 1 >= 0) {
  		    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
  		      break;
  		    }
  		    --index;
  		  }

  		  return index;
  		}; 
  	} (binarySearch));
  	return binarySearch;
  }

  var quickSort = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredQuickSort;

  function requireQuickSort () {
  	if (hasRequiredQuickSort) return quickSort;
  	hasRequiredQuickSort = 1;
  	/*
  	 * Copyright 2011 Mozilla Foundation and contributors
  	 * Licensed under the New BSD license. See LICENSE or:
  	 * http://opensource.org/licenses/BSD-3-Clause
  	 */

  	// It turns out that some (most?) JavaScript engines don't self-host
  	// `Array.prototype.sort`. This makes sense because C++ will likely remain
  	// faster than JS when doing raw CPU-intensive sorting. However, when using a
  	// custom comparator function, calling back and forth between the VM's C++ and
  	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
  	// worse generated code for the comparator function than would be optimal. In
  	// fact, when sorting with a comparator, these costs outweigh the benefits of
  	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  	// a ~3500ms mean speed-up in `bench/bench.html`.

  	/**
  	 * Swap the elements indexed by `x` and `y` in the array `ary`.
  	 *
  	 * @param {Array} ary
  	 *        The array.
  	 * @param {Number} x
  	 *        The index of the first item.
  	 * @param {Number} y
  	 *        The index of the second item.
  	 */
  	function swap(ary, x, y) {
  	  var temp = ary[x];
  	  ary[x] = ary[y];
  	  ary[y] = temp;
  	}

  	/**
  	 * Returns a random integer within the range `low .. high` inclusive.
  	 *
  	 * @param {Number} low
  	 *        The lower bound on the range.
  	 * @param {Number} high
  	 *        The upper bound on the range.
  	 */
  	function randomIntInRange(low, high) {
  	  return Math.round(low + (Math.random() * (high - low)));
  	}

  	/**
  	 * The Quick Sort algorithm.
  	 *
  	 * @param {Array} ary
  	 *        An array to sort.
  	 * @param {function} comparator
  	 *        Function to use to compare two items.
  	 * @param {Number} p
  	 *        Start index of the array
  	 * @param {Number} r
  	 *        End index of the array
  	 */
  	function doQuickSort(ary, comparator, p, r) {
  	  // If our lower bound is less than our upper bound, we (1) partition the
  	  // array into two pieces and (2) recurse on each half. If it is not, this is
  	  // the empty array and our base case.

  	  if (p < r) {
  	    // (1) Partitioning.
  	    //
  	    // The partitioning chooses a pivot between `p` and `r` and moves all
  	    // elements that are less than or equal to the pivot to the before it, and
  	    // all the elements that are greater than it after it. The effect is that
  	    // once partition is done, the pivot is in the exact place it will be when
  	    // the array is put in sorted order, and it will not need to be moved
  	    // again. This runs in O(n) time.

  	    // Always choose a random pivot so that an input array which is reverse
  	    // sorted does not cause O(n^2) running time.
  	    var pivotIndex = randomIntInRange(p, r);
  	    var i = p - 1;

  	    swap(ary, pivotIndex, r);
  	    var pivot = ary[r];

  	    // Immediately after `j` is incremented in this loop, the following hold
  	    // true:
  	    //
  	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
  	    //
  	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
  	    for (var j = p; j < r; j++) {
  	      if (comparator(ary[j], pivot) <= 0) {
  	        i += 1;
  	        swap(ary, i, j);
  	      }
  	    }

  	    swap(ary, i + 1, j);
  	    var q = i + 1;

  	    // (2) Recurse on each half.

  	    doQuickSort(ary, comparator, p, q - 1);
  	    doQuickSort(ary, comparator, q + 1, r);
  	  }
  	}

  	/**
  	 * Sort the given array in-place with the given comparator function.
  	 *
  	 * @param {Array} ary
  	 *        An array to sort.
  	 * @param {function} comparator
  	 *        Function to use to compare two items.
  	 */
  	quickSort.quickSort = function (ary, comparator) {
  	  doQuickSort(ary, comparator, 0, ary.length - 1);
  	};
  	return quickSort;
  }

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredSourceMapConsumer;

  function requireSourceMapConsumer () {
  	if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  	hasRequiredSourceMapConsumer = 1;
  	/*
  	 * Copyright 2011 Mozilla Foundation and contributors
  	 * Licensed under the New BSD license. See LICENSE or:
  	 * http://opensource.org/licenses/BSD-3-Clause
  	 */

  	var util = requireUtil();
  	var binarySearch = requireBinarySearch();
  	var ArraySet = requireArraySet().ArraySet;
  	var base64VLQ = requireBase64Vlq();
  	var quickSort = requireQuickSort().quickSort;

  	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  	  var sourceMap = aSourceMap;
  	  if (typeof aSourceMap === 'string') {
  	    sourceMap = util.parseSourceMapInput(aSourceMap);
  	  }

  	  return sourceMap.sections != null
  	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
  	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  	}

  	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  	};

  	/**
  	 * The version of the source mapping spec that we are consuming.
  	 */
  	SourceMapConsumer.prototype._version = 3;

  	// `__generatedMappings` and `__originalMappings` are arrays that hold the
  	// parsed mapping coordinates from the source map's "mappings" attribute. They
  	// are lazily instantiated, accessed via the `_generatedMappings` and
  	// `_originalMappings` getters respectively, and we only parse the mappings
  	// and create these arrays once queried for a source location. We jump through
  	// these hoops because there can be many thousands of mappings, and parsing
  	// them is expensive, so we only want to do it if we must.
  	//
  	// Each object in the arrays is of the form:
  	//
  	//     {
  	//       generatedLine: The line number in the generated code,
  	//       generatedColumn: The column number in the generated code,
  	//       source: The path to the original source file that generated this
  	//               chunk of code,
  	//       originalLine: The line number in the original source that
  	//                     corresponds to this chunk of generated code,
  	//       originalColumn: The column number in the original source that
  	//                       corresponds to this chunk of generated code,
  	//       name: The name of the original symbol which generated this chunk of
  	//             code.
  	//     }
  	//
  	// All properties except for `generatedLine` and `generatedColumn` can be
  	// `null`.
  	//
  	// `_generatedMappings` is ordered by the generated positions.
  	//
  	// `_originalMappings` is ordered by the original positions.

  	SourceMapConsumer.prototype.__generatedMappings = null;
  	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  	  configurable: true,
  	  enumerable: true,
  	  get: function () {
  	    if (!this.__generatedMappings) {
  	      this._parseMappings(this._mappings, this.sourceRoot);
  	    }

  	    return this.__generatedMappings;
  	  }
  	});

  	SourceMapConsumer.prototype.__originalMappings = null;
  	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  	  configurable: true,
  	  enumerable: true,
  	  get: function () {
  	    if (!this.__originalMappings) {
  	      this._parseMappings(this._mappings, this.sourceRoot);
  	    }

  	    return this.__originalMappings;
  	  }
  	});

  	SourceMapConsumer.prototype._charIsMappingSeparator =
  	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  	    var c = aStr.charAt(index);
  	    return c === ";" || c === ",";
  	  };

  	/**
  	 * Parse the mappings in a string in to a data structure which we can easily
  	 * query (the ordered arrays in the `this.__generatedMappings` and
  	 * `this.__originalMappings` properties).
  	 */
  	SourceMapConsumer.prototype._parseMappings =
  	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  	    throw new Error("Subclasses must implement _parseMappings");
  	  };

  	SourceMapConsumer.GENERATED_ORDER = 1;
  	SourceMapConsumer.ORIGINAL_ORDER = 2;

  	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  	/**
  	 * Iterate over each mapping between an original source/line/column and a
  	 * generated line/column in this source map.
  	 *
  	 * @param Function aCallback
  	 *        The function that is called with each mapping.
  	 * @param Object aContext
  	 *        Optional. If specified, this object will be the value of `this` every
  	 *        time that `aCallback` is called.
  	 * @param aOrder
  	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
  	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
  	 *        iterate over the mappings sorted by the generated file's line/column
  	 *        order or the original's source/line/column order, respectively. Defaults to
  	 *        `SourceMapConsumer.GENERATED_ORDER`.
  	 */
  	SourceMapConsumer.prototype.eachMapping =
  	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  	    var context = aContext || null;
  	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

  	    var mappings;
  	    switch (order) {
  	    case SourceMapConsumer.GENERATED_ORDER:
  	      mappings = this._generatedMappings;
  	      break;
  	    case SourceMapConsumer.ORIGINAL_ORDER:
  	      mappings = this._originalMappings;
  	      break;
  	    default:
  	      throw new Error("Unknown order of iteration.");
  	    }

  	    var sourceRoot = this.sourceRoot;
  	    mappings.map(function (mapping) {
  	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
  	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
  	      return {
  	        source: source,
  	        generatedLine: mapping.generatedLine,
  	        generatedColumn: mapping.generatedColumn,
  	        originalLine: mapping.originalLine,
  	        originalColumn: mapping.originalColumn,
  	        name: mapping.name === null ? null : this._names.at(mapping.name)
  	      };
  	    }, this).forEach(aCallback, context);
  	  };

  	/**
  	 * Returns all generated line and column information for the original source,
  	 * line, and column provided. If no column is provided, returns all mappings
  	 * corresponding to a either the line we are searching for or the next
  	 * closest line that has any mappings. Otherwise, returns all mappings
  	 * corresponding to the given line and either the column we are searching for
  	 * or the next closest column that has any offsets.
  	 *
  	 * The only argument is an object with the following properties:
  	 *
  	 *   - source: The filename of the original source.
  	 *   - line: The line number in the original source.  The line number is 1-based.
  	 *   - column: Optional. the column number in the original source.
  	 *    The column number is 0-based.
  	 *
  	 * and an array of objects is returned, each with the following properties:
  	 *
  	 *   - line: The line number in the generated source, or null.  The
  	 *    line number is 1-based.
  	 *   - column: The column number in the generated source, or null.
  	 *    The column number is 0-based.
  	 */
  	SourceMapConsumer.prototype.allGeneratedPositionsFor =
  	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  	    var line = util.getArg(aArgs, 'line');

  	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  	    // returns the index of the closest mapping less than the needle. By
  	    // setting needle.originalColumn to 0, we thus find the last mapping for
  	    // the given line, provided such a mapping exists.
  	    var needle = {
  	      source: util.getArg(aArgs, 'source'),
  	      originalLine: line,
  	      originalColumn: util.getArg(aArgs, 'column', 0)
  	    };

  	    needle.source = this._findSourceIndex(needle.source);
  	    if (needle.source < 0) {
  	      return [];
  	    }

  	    var mappings = [];

  	    var index = this._findMapping(needle,
  	                                  this._originalMappings,
  	                                  "originalLine",
  	                                  "originalColumn",
  	                                  util.compareByOriginalPositions,
  	                                  binarySearch.LEAST_UPPER_BOUND);
  	    if (index >= 0) {
  	      var mapping = this._originalMappings[index];

  	      if (aArgs.column === undefined) {
  	        var originalLine = mapping.originalLine;

  	        // Iterate until either we run out of mappings, or we run into
  	        // a mapping for a different line than the one we found. Since
  	        // mappings are sorted, this is guaranteed to find all mappings for
  	        // the line we found.
  	        while (mapping && mapping.originalLine === originalLine) {
  	          mappings.push({
  	            line: util.getArg(mapping, 'generatedLine', null),
  	            column: util.getArg(mapping, 'generatedColumn', null),
  	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
  	          });

  	          mapping = this._originalMappings[++index];
  	        }
  	      } else {
  	        var originalColumn = mapping.originalColumn;

  	        // Iterate until either we run out of mappings, or we run into
  	        // a mapping for a different line than the one we were searching for.
  	        // Since mappings are sorted, this is guaranteed to find all mappings for
  	        // the line we are searching for.
  	        while (mapping &&
  	               mapping.originalLine === line &&
  	               mapping.originalColumn == originalColumn) {
  	          mappings.push({
  	            line: util.getArg(mapping, 'generatedLine', null),
  	            column: util.getArg(mapping, 'generatedColumn', null),
  	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
  	          });

  	          mapping = this._originalMappings[++index];
  	        }
  	      }
  	    }

  	    return mappings;
  	  };

  	sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

  	/**
  	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
  	 * query for information about the original file positions by giving it a file
  	 * position in the generated source.
  	 *
  	 * The first parameter is the raw source map (either as a JSON string, or
  	 * already parsed to an object). According to the spec, source maps have the
  	 * following attributes:
  	 *
  	 *   - version: Which version of the source map spec this map is following.
  	 *   - sources: An array of URLs to the original source files.
  	 *   - names: An array of identifiers which can be referrenced by individual mappings.
  	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
  	 *   - sourcesContent: Optional. An array of contents of the original source files.
  	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
  	 *   - file: Optional. The generated file this source map is associated with.
  	 *
  	 * Here is an example source map, taken from the source map spec[0]:
  	 *
  	 *     {
  	 *       version : 3,
  	 *       file: "out.js",
  	 *       sourceRoot : "",
  	 *       sources: ["foo.js", "bar.js"],
  	 *       names: ["src", "maps", "are", "fun"],
  	 *       mappings: "AA,AB;;ABCDE;"
  	 *     }
  	 *
  	 * The second parameter, if given, is a string whose value is the URL
  	 * at which the source map was found.  This URL is used to compute the
  	 * sources array.
  	 *
  	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
  	 */
  	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  	  var sourceMap = aSourceMap;
  	  if (typeof aSourceMap === 'string') {
  	    sourceMap = util.parseSourceMapInput(aSourceMap);
  	  }

  	  var version = util.getArg(sourceMap, 'version');
  	  var sources = util.getArg(sourceMap, 'sources');
  	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  	  // requires the array) to play nice here.
  	  var names = util.getArg(sourceMap, 'names', []);
  	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  	  var mappings = util.getArg(sourceMap, 'mappings');
  	  var file = util.getArg(sourceMap, 'file', null);

  	  // Once again, Sass deviates from the spec and supplies the version as a
  	  // string rather than a number, so we use loose equality checking here.
  	  if (version != this._version) {
  	    throw new Error('Unsupported version: ' + version);
  	  }

  	  if (sourceRoot) {
  	    sourceRoot = util.normalize(sourceRoot);
  	  }

  	  sources = sources
  	    .map(String)
  	    // Some source maps produce relative source paths like "./foo.js" instead of
  	    // "foo.js".  Normalize these first so that future comparisons will succeed.
  	    // See bugzil.la/1090768.
  	    .map(util.normalize)
  	    // Always ensure that absolute sources are internally stored relative to
  	    // the source root, if the source root is absolute. Not doing this would
  	    // be particularly problematic when the source root is a prefix of the
  	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  	    .map(function (source) {
  	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
  	        ? util.relative(sourceRoot, source)
  	        : source;
  	    });

  	  // Pass `true` below to allow duplicate names and sources. While source maps
  	  // are intended to be compressed and deduplicated, the TypeScript compiler
  	  // sometimes generates source maps with duplicates in them. See Github issue
  	  // #72 and bugzil.la/889492.
  	  this._names = ArraySet.fromArray(names.map(String), true);
  	  this._sources = ArraySet.fromArray(sources, true);

  	  this._absoluteSources = this._sources.toArray().map(function (s) {
  	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  	  });

  	  this.sourceRoot = sourceRoot;
  	  this.sourcesContent = sourcesContent;
  	  this._mappings = mappings;
  	  this._sourceMapURL = aSourceMapURL;
  	  this.file = file;
  	}

  	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  	/**
  	 * Utility function to find the index of a source.  Returns -1 if not
  	 * found.
  	 */
  	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  	  var relativeSource = aSource;
  	  if (this.sourceRoot != null) {
  	    relativeSource = util.relative(this.sourceRoot, relativeSource);
  	  }

  	  if (this._sources.has(relativeSource)) {
  	    return this._sources.indexOf(relativeSource);
  	  }

  	  // Maybe aSource is an absolute URL as returned by |sources|.  In
  	  // this case we can't simply undo the transform.
  	  var i;
  	  for (i = 0; i < this._absoluteSources.length; ++i) {
  	    if (this._absoluteSources[i] == aSource) {
  	      return i;
  	    }
  	  }

  	  return -1;
  	};

  	/**
  	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
  	 *
  	 * @param SourceMapGenerator aSourceMap
  	 *        The source map that will be consumed.
  	 * @param String aSourceMapURL
  	 *        The URL at which the source map can be found (optional)
  	 * @returns BasicSourceMapConsumer
  	 */
  	BasicSourceMapConsumer.fromSourceMap =
  	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  	    var smc = Object.create(BasicSourceMapConsumer.prototype);

  	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  	    smc.sourceRoot = aSourceMap._sourceRoot;
  	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
  	                                                            smc.sourceRoot);
  	    smc.file = aSourceMap._file;
  	    smc._sourceMapURL = aSourceMapURL;
  	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
  	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  	    });

  	    // Because we are modifying the entries (by converting string sources and
  	    // names to indices into the sources and names ArraySets), we have to make
  	    // a copy of the entry or else bad things happen. Shared mutable state
  	    // strikes again! See github issue #191.

  	    var generatedMappings = aSourceMap._mappings.toArray().slice();
  	    var destGeneratedMappings = smc.__generatedMappings = [];
  	    var destOriginalMappings = smc.__originalMappings = [];

  	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
  	      var srcMapping = generatedMappings[i];
  	      var destMapping = new Mapping;
  	      destMapping.generatedLine = srcMapping.generatedLine;
  	      destMapping.generatedColumn = srcMapping.generatedColumn;

  	      if (srcMapping.source) {
  	        destMapping.source = sources.indexOf(srcMapping.source);
  	        destMapping.originalLine = srcMapping.originalLine;
  	        destMapping.originalColumn = srcMapping.originalColumn;

  	        if (srcMapping.name) {
  	          destMapping.name = names.indexOf(srcMapping.name);
  	        }

  	        destOriginalMappings.push(destMapping);
  	      }

  	      destGeneratedMappings.push(destMapping);
  	    }

  	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

  	    return smc;
  	  };

  	/**
  	 * The version of the source mapping spec that we are consuming.
  	 */
  	BasicSourceMapConsumer.prototype._version = 3;

  	/**
  	 * The list of original sources.
  	 */
  	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  	  get: function () {
  	    return this._absoluteSources.slice();
  	  }
  	});

  	/**
  	 * Provide the JIT with a nice shape / hidden class.
  	 */
  	function Mapping() {
  	  this.generatedLine = 0;
  	  this.generatedColumn = 0;
  	  this.source = null;
  	  this.originalLine = null;
  	  this.originalColumn = null;
  	  this.name = null;
  	}

  	/**
  	 * Parse the mappings in a string in to a data structure which we can easily
  	 * query (the ordered arrays in the `this.__generatedMappings` and
  	 * `this.__originalMappings` properties).
  	 */
  	BasicSourceMapConsumer.prototype._parseMappings =
  	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  	    var generatedLine = 1;
  	    var previousGeneratedColumn = 0;
  	    var previousOriginalLine = 0;
  	    var previousOriginalColumn = 0;
  	    var previousSource = 0;
  	    var previousName = 0;
  	    var length = aStr.length;
  	    var index = 0;
  	    var cachedSegments = {};
  	    var temp = {};
  	    var originalMappings = [];
  	    var generatedMappings = [];
  	    var mapping, str, segment, end, value;

  	    while (index < length) {
  	      if (aStr.charAt(index) === ';') {
  	        generatedLine++;
  	        index++;
  	        previousGeneratedColumn = 0;
  	      }
  	      else if (aStr.charAt(index) === ',') {
  	        index++;
  	      }
  	      else {
  	        mapping = new Mapping();
  	        mapping.generatedLine = generatedLine;

  	        // Because each offset is encoded relative to the previous one,
  	        // many segments often have the same encoding. We can exploit this
  	        // fact by caching the parsed variable length fields of each segment,
  	        // allowing us to avoid a second parse if we encounter the same
  	        // segment again.
  	        for (end = index; end < length; end++) {
  	          if (this._charIsMappingSeparator(aStr, end)) {
  	            break;
  	          }
  	        }
  	        str = aStr.slice(index, end);

  	        segment = cachedSegments[str];
  	        if (segment) {
  	          index += str.length;
  	        } else {
  	          segment = [];
  	          while (index < end) {
  	            base64VLQ.decode(aStr, index, temp);
  	            value = temp.value;
  	            index = temp.rest;
  	            segment.push(value);
  	          }

  	          if (segment.length === 2) {
  	            throw new Error('Found a source, but no line and column');
  	          }

  	          if (segment.length === 3) {
  	            throw new Error('Found a source and line, but no column');
  	          }

  	          cachedSegments[str] = segment;
  	        }

  	        // Generated column.
  	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
  	        previousGeneratedColumn = mapping.generatedColumn;

  	        if (segment.length > 1) {
  	          // Original source.
  	          mapping.source = previousSource + segment[1];
  	          previousSource += segment[1];

  	          // Original line.
  	          mapping.originalLine = previousOriginalLine + segment[2];
  	          previousOriginalLine = mapping.originalLine;
  	          // Lines are stored 0-based
  	          mapping.originalLine += 1;

  	          // Original column.
  	          mapping.originalColumn = previousOriginalColumn + segment[3];
  	          previousOriginalColumn = mapping.originalColumn;

  	          if (segment.length > 4) {
  	            // Original name.
  	            mapping.name = previousName + segment[4];
  	            previousName += segment[4];
  	          }
  	        }

  	        generatedMappings.push(mapping);
  	        if (typeof mapping.originalLine === 'number') {
  	          originalMappings.push(mapping);
  	        }
  	      }
  	    }

  	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  	    this.__generatedMappings = generatedMappings;

  	    quickSort(originalMappings, util.compareByOriginalPositions);
  	    this.__originalMappings = originalMappings;
  	  };

  	/**
  	 * Find the mapping that best matches the hypothetical "needle" mapping that
  	 * we are searching for in the given "haystack" of mappings.
  	 */
  	BasicSourceMapConsumer.prototype._findMapping =
  	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
  	                                         aColumnName, aComparator, aBias) {
  	    // To return the position we are searching for, we must first find the
  	    // mapping for the given position and then return the opposite position it
  	    // points to. Because the mappings are sorted, we can use binary search to
  	    // find the best mapping.

  	    if (aNeedle[aLineName] <= 0) {
  	      throw new TypeError('Line must be greater than or equal to 1, got '
  	                          + aNeedle[aLineName]);
  	    }
  	    if (aNeedle[aColumnName] < 0) {
  	      throw new TypeError('Column must be greater than or equal to 0, got '
  	                          + aNeedle[aColumnName]);
  	    }

  	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  	  };

  	/**
  	 * Compute the last column for each generated mapping. The last column is
  	 * inclusive.
  	 */
  	BasicSourceMapConsumer.prototype.computeColumnSpans =
  	  function SourceMapConsumer_computeColumnSpans() {
  	    for (var index = 0; index < this._generatedMappings.length; ++index) {
  	      var mapping = this._generatedMappings[index];

  	      // Mappings do not contain a field for the last generated columnt. We
  	      // can come up with an optimistic estimate, however, by assuming that
  	      // mappings are contiguous (i.e. given two consecutive mappings, the
  	      // first mapping ends where the second one starts).
  	      if (index + 1 < this._generatedMappings.length) {
  	        var nextMapping = this._generatedMappings[index + 1];

  	        if (mapping.generatedLine === nextMapping.generatedLine) {
  	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
  	          continue;
  	        }
  	      }

  	      // The last mapping for each line spans the entire line.
  	      mapping.lastGeneratedColumn = Infinity;
  	    }
  	  };

  	/**
  	 * Returns the original source, line, and column information for the generated
  	 * source's line and column positions provided. The only argument is an object
  	 * with the following properties:
  	 *
  	 *   - line: The line number in the generated source.  The line number
  	 *     is 1-based.
  	 *   - column: The column number in the generated source.  The column
  	 *     number is 0-based.
  	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
  	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
  	 *     closest element that is smaller than or greater than the one we are
  	 *     searching for, respectively, if the exact element cannot be found.
  	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
  	 *
  	 * and an object is returned with the following properties:
  	 *
  	 *   - source: The original source file, or null.
  	 *   - line: The line number in the original source, or null.  The
  	 *     line number is 1-based.
  	 *   - column: The column number in the original source, or null.  The
  	 *     column number is 0-based.
  	 *   - name: The original identifier, or null.
  	 */
  	BasicSourceMapConsumer.prototype.originalPositionFor =
  	  function SourceMapConsumer_originalPositionFor(aArgs) {
  	    var needle = {
  	      generatedLine: util.getArg(aArgs, 'line'),
  	      generatedColumn: util.getArg(aArgs, 'column')
  	    };

  	    var index = this._findMapping(
  	      needle,
  	      this._generatedMappings,
  	      "generatedLine",
  	      "generatedColumn",
  	      util.compareByGeneratedPositionsDeflated,
  	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
  	    );

  	    if (index >= 0) {
  	      var mapping = this._generatedMappings[index];

  	      if (mapping.generatedLine === needle.generatedLine) {
  	        var source = util.getArg(mapping, 'source', null);
  	        if (source !== null) {
  	          source = this._sources.at(source);
  	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
  	        }
  	        var name = util.getArg(mapping, 'name', null);
  	        if (name !== null) {
  	          name = this._names.at(name);
  	        }
  	        return {
  	          source: source,
  	          line: util.getArg(mapping, 'originalLine', null),
  	          column: util.getArg(mapping, 'originalColumn', null),
  	          name: name
  	        };
  	      }
  	    }

  	    return {
  	      source: null,
  	      line: null,
  	      column: null,
  	      name: null
  	    };
  	  };

  	/**
  	 * Return true if we have the source content for every source in the source
  	 * map, false otherwise.
  	 */
  	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
  	    if (!this.sourcesContent) {
  	      return false;
  	    }
  	    return this.sourcesContent.length >= this._sources.size() &&
  	      !this.sourcesContent.some(function (sc) { return sc == null; });
  	  };

  	/**
  	 * Returns the original source content. The only argument is the url of the
  	 * original source file. Returns null if no original source content is
  	 * available.
  	 */
  	BasicSourceMapConsumer.prototype.sourceContentFor =
  	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  	    if (!this.sourcesContent) {
  	      return null;
  	    }

  	    var index = this._findSourceIndex(aSource);
  	    if (index >= 0) {
  	      return this.sourcesContent[index];
  	    }

  	    var relativeSource = aSource;
  	    if (this.sourceRoot != null) {
  	      relativeSource = util.relative(this.sourceRoot, relativeSource);
  	    }

  	    var url;
  	    if (this.sourceRoot != null
  	        && (url = util.urlParse(this.sourceRoot))) {
  	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
  	      // many users. We can help them out when they expect file:// URIs to
  	      // behave like it would if they were running a local HTTP server. See
  	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
  	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
  	      if (url.scheme == "file"
  	          && this._sources.has(fileUriAbsPath)) {
  	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
  	      }

  	      if ((!url.path || url.path == "/")
  	          && this._sources.has("/" + relativeSource)) {
  	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
  	      }
  	    }

  	    // This function is used recursively from
  	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  	    // don't want to throw if we can't find the source - we just want to
  	    // return null, so we provide a flag to exit gracefully.
  	    if (nullOnMissing) {
  	      return null;
  	    }
  	    else {
  	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  	    }
  	  };

  	/**
  	 * Returns the generated line and column information for the original source,
  	 * line, and column positions provided. The only argument is an object with
  	 * the following properties:
  	 *
  	 *   - source: The filename of the original source.
  	 *   - line: The line number in the original source.  The line number
  	 *     is 1-based.
  	 *   - column: The column number in the original source.  The column
  	 *     number is 0-based.
  	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
  	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
  	 *     closest element that is smaller than or greater than the one we are
  	 *     searching for, respectively, if the exact element cannot be found.
  	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
  	 *
  	 * and an object is returned with the following properties:
  	 *
  	 *   - line: The line number in the generated source, or null.  The
  	 *     line number is 1-based.
  	 *   - column: The column number in the generated source, or null.
  	 *     The column number is 0-based.
  	 */
  	BasicSourceMapConsumer.prototype.generatedPositionFor =
  	  function SourceMapConsumer_generatedPositionFor(aArgs) {
  	    var source = util.getArg(aArgs, 'source');
  	    source = this._findSourceIndex(source);
  	    if (source < 0) {
  	      return {
  	        line: null,
  	        column: null,
  	        lastColumn: null
  	      };
  	    }

  	    var needle = {
  	      source: source,
  	      originalLine: util.getArg(aArgs, 'line'),
  	      originalColumn: util.getArg(aArgs, 'column')
  	    };

  	    var index = this._findMapping(
  	      needle,
  	      this._originalMappings,
  	      "originalLine",
  	      "originalColumn",
  	      util.compareByOriginalPositions,
  	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
  	    );

  	    if (index >= 0) {
  	      var mapping = this._originalMappings[index];

  	      if (mapping.source === needle.source) {
  	        return {
  	          line: util.getArg(mapping, 'generatedLine', null),
  	          column: util.getArg(mapping, 'generatedColumn', null),
  	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
  	        };
  	      }
  	    }

  	    return {
  	      line: null,
  	      column: null,
  	      lastColumn: null
  	    };
  	  };

  	sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

  	/**
  	 * An IndexedSourceMapConsumer instance represents a parsed source map which
  	 * we can query for information. It differs from BasicSourceMapConsumer in
  	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
  	 * input.
  	 *
  	 * The first parameter is a raw source map (either as a JSON string, or already
  	 * parsed to an object). According to the spec for indexed source maps, they
  	 * have the following attributes:
  	 *
  	 *   - version: Which version of the source map spec this map is following.
  	 *   - file: Optional. The generated file this source map is associated with.
  	 *   - sections: A list of section definitions.
  	 *
  	 * Each value under the "sections" field has two fields:
  	 *   - offset: The offset into the original specified at which this section
  	 *       begins to apply, defined as an object with a "line" and "column"
  	 *       field.
  	 *   - map: A source map definition. This source map could also be indexed,
  	 *       but doesn't have to be.
  	 *
  	 * Instead of the "map" field, it's also possible to have a "url" field
  	 * specifying a URL to retrieve a source map from, but that's currently
  	 * unsupported.
  	 *
  	 * Here's an example source map, taken from the source map spec[0], but
  	 * modified to omit a section which uses the "url" field.
  	 *
  	 *  {
  	 *    version : 3,
  	 *    file: "app.js",
  	 *    sections: [{
  	 *      offset: {line:100, column:10},
  	 *      map: {
  	 *        version : 3,
  	 *        file: "section.js",
  	 *        sources: ["foo.js", "bar.js"],
  	 *        names: ["src", "maps", "are", "fun"],
  	 *        mappings: "AAAA,E;;ABCDE;"
  	 *      }
  	 *    }],
  	 *  }
  	 *
  	 * The second parameter, if given, is a string whose value is the URL
  	 * at which the source map was found.  This URL is used to compute the
  	 * sources array.
  	 *
  	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
  	 */
  	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  	  var sourceMap = aSourceMap;
  	  if (typeof aSourceMap === 'string') {
  	    sourceMap = util.parseSourceMapInput(aSourceMap);
  	  }

  	  var version = util.getArg(sourceMap, 'version');
  	  var sections = util.getArg(sourceMap, 'sections');

  	  if (version != this._version) {
  	    throw new Error('Unsupported version: ' + version);
  	  }

  	  this._sources = new ArraySet();
  	  this._names = new ArraySet();

  	  var lastOffset = {
  	    line: -1,
  	    column: 0
  	  };
  	  this._sections = sections.map(function (s) {
  	    if (s.url) {
  	      // The url field will require support for asynchronicity.
  	      // See https://github.com/mozilla/source-map/issues/16
  	      throw new Error('Support for url field in sections not implemented.');
  	    }
  	    var offset = util.getArg(s, 'offset');
  	    var offsetLine = util.getArg(offset, 'line');
  	    var offsetColumn = util.getArg(offset, 'column');

  	    if (offsetLine < lastOffset.line ||
  	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
  	      throw new Error('Section offsets must be ordered and non-overlapping.');
  	    }
  	    lastOffset = offset;

  	    return {
  	      generatedOffset: {
  	        // The offset fields are 0-based, but we use 1-based indices when
  	        // encoding/decoding from VLQ.
  	        generatedLine: offsetLine + 1,
  	        generatedColumn: offsetColumn + 1
  	      },
  	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
  	    }
  	  });
  	}

  	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  	/**
  	 * The version of the source mapping spec that we are consuming.
  	 */
  	IndexedSourceMapConsumer.prototype._version = 3;

  	/**
  	 * The list of original sources.
  	 */
  	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  	  get: function () {
  	    var sources = [];
  	    for (var i = 0; i < this._sections.length; i++) {
  	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
  	        sources.push(this._sections[i].consumer.sources[j]);
  	      }
  	    }
  	    return sources;
  	  }
  	});

  	/**
  	 * Returns the original source, line, and column information for the generated
  	 * source's line and column positions provided. The only argument is an object
  	 * with the following properties:
  	 *
  	 *   - line: The line number in the generated source.  The line number
  	 *     is 1-based.
  	 *   - column: The column number in the generated source.  The column
  	 *     number is 0-based.
  	 *
  	 * and an object is returned with the following properties:
  	 *
  	 *   - source: The original source file, or null.
  	 *   - line: The line number in the original source, or null.  The
  	 *     line number is 1-based.
  	 *   - column: The column number in the original source, or null.  The
  	 *     column number is 0-based.
  	 *   - name: The original identifier, or null.
  	 */
  	IndexedSourceMapConsumer.prototype.originalPositionFor =
  	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  	    var needle = {
  	      generatedLine: util.getArg(aArgs, 'line'),
  	      generatedColumn: util.getArg(aArgs, 'column')
  	    };

  	    // Find the section containing the generated position we're trying to map
  	    // to an original position.
  	    var sectionIndex = binarySearch.search(needle, this._sections,
  	      function(needle, section) {
  	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
  	        if (cmp) {
  	          return cmp;
  	        }

  	        return (needle.generatedColumn -
  	                section.generatedOffset.generatedColumn);
  	      });
  	    var section = this._sections[sectionIndex];

  	    if (!section) {
  	      return {
  	        source: null,
  	        line: null,
  	        column: null,
  	        name: null
  	      };
  	    }

  	    return section.consumer.originalPositionFor({
  	      line: needle.generatedLine -
  	        (section.generatedOffset.generatedLine - 1),
  	      column: needle.generatedColumn -
  	        (section.generatedOffset.generatedLine === needle.generatedLine
  	         ? section.generatedOffset.generatedColumn - 1
  	         : 0),
  	      bias: aArgs.bias
  	    });
  	  };

  	/**
  	 * Return true if we have the source content for every source in the source
  	 * map, false otherwise.
  	 */
  	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  	    return this._sections.every(function (s) {
  	      return s.consumer.hasContentsOfAllSources();
  	    });
  	  };

  	/**
  	 * Returns the original source content. The only argument is the url of the
  	 * original source file. Returns null if no original source content is
  	 * available.
  	 */
  	IndexedSourceMapConsumer.prototype.sourceContentFor =
  	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  	    for (var i = 0; i < this._sections.length; i++) {
  	      var section = this._sections[i];

  	      var content = section.consumer.sourceContentFor(aSource, true);
  	      if (content) {
  	        return content;
  	      }
  	    }
  	    if (nullOnMissing) {
  	      return null;
  	    }
  	    else {
  	      throw new Error('"' + aSource + '" is not in the SourceMap.');
  	    }
  	  };

  	/**
  	 * Returns the generated line and column information for the original source,
  	 * line, and column positions provided. The only argument is an object with
  	 * the following properties:
  	 *
  	 *   - source: The filename of the original source.
  	 *   - line: The line number in the original source.  The line number
  	 *     is 1-based.
  	 *   - column: The column number in the original source.  The column
  	 *     number is 0-based.
  	 *
  	 * and an object is returned with the following properties:
  	 *
  	 *   - line: The line number in the generated source, or null.  The
  	 *     line number is 1-based. 
  	 *   - column: The column number in the generated source, or null.
  	 *     The column number is 0-based.
  	 */
  	IndexedSourceMapConsumer.prototype.generatedPositionFor =
  	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  	    for (var i = 0; i < this._sections.length; i++) {
  	      var section = this._sections[i];

  	      // Only consider this section if the requested source is in the list of
  	      // sources of the consumer.
  	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
  	        continue;
  	      }
  	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
  	      if (generatedPosition) {
  	        var ret = {
  	          line: generatedPosition.line +
  	            (section.generatedOffset.generatedLine - 1),
  	          column: generatedPosition.column +
  	            (section.generatedOffset.generatedLine === generatedPosition.line
  	             ? section.generatedOffset.generatedColumn - 1
  	             : 0)
  	        };
  	        return ret;
  	      }
  	    }

  	    return {
  	      line: null,
  	      column: null
  	    };
  	  };

  	/**
  	 * Parse the mappings in a string in to a data structure which we can easily
  	 * query (the ordered arrays in the `this.__generatedMappings` and
  	 * `this.__originalMappings` properties).
  	 */
  	IndexedSourceMapConsumer.prototype._parseMappings =
  	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  	    this.__generatedMappings = [];
  	    this.__originalMappings = [];
  	    for (var i = 0; i < this._sections.length; i++) {
  	      var section = this._sections[i];
  	      var sectionMappings = section.consumer._generatedMappings;
  	      for (var j = 0; j < sectionMappings.length; j++) {
  	        var mapping = sectionMappings[j];

  	        var source = section.consumer._sources.at(mapping.source);
  	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
  	        this._sources.add(source);
  	        source = this._sources.indexOf(source);

  	        var name = null;
  	        if (mapping.name) {
  	          name = section.consumer._names.at(mapping.name);
  	          this._names.add(name);
  	          name = this._names.indexOf(name);
  	        }

  	        // The mappings coming from the consumer for the section have
  	        // generated positions relative to the start of the section, so we
  	        // need to offset them to be relative to the start of the concatenated
  	        // generated file.
  	        var adjustedMapping = {
  	          source: source,
  	          generatedLine: mapping.generatedLine +
  	            (section.generatedOffset.generatedLine - 1),
  	          generatedColumn: mapping.generatedColumn +
  	            (section.generatedOffset.generatedLine === mapping.generatedLine
  	            ? section.generatedOffset.generatedColumn - 1
  	            : 0),
  	          originalLine: mapping.originalLine,
  	          originalColumn: mapping.originalColumn,
  	          name: name
  	        };

  	        this.__generatedMappings.push(adjustedMapping);
  	        if (typeof adjustedMapping.originalLine === 'number') {
  	          this.__originalMappings.push(adjustedMapping);
  	        }
  	      }
  	    }

  	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  	  };

  	sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  	return sourceMapConsumer;
  }

  var sourceNode = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  var hasRequiredSourceNode;

  function requireSourceNode () {
  	if (hasRequiredSourceNode) return sourceNode;
  	hasRequiredSourceNode = 1;
  	/*
  	 * Copyright 2011 Mozilla Foundation and contributors
  	 * Licensed under the New BSD license. See LICENSE or:
  	 * http://opensource.org/licenses/BSD-3-Clause
  	 */

  	var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  	var util = requireUtil();

  	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  	// operating systems these days (capturing the result).
  	var REGEX_NEWLINE = /(\r?\n)/;

  	// Newline character code for charCodeAt() comparisons
  	var NEWLINE_CODE = 10;

  	// Private symbol for identifying `SourceNode`s when multiple versions of
  	// the source-map library are loaded. This MUST NOT CHANGE across
  	// versions!
  	var isSourceNode = "$$$isSourceNode$$$";

  	/**
  	 * SourceNodes provide a way to abstract over interpolating/concatenating
  	 * snippets of generated JavaScript source code while maintaining the line and
  	 * column information associated with the original source code.
  	 *
  	 * @param aLine The original line number.
  	 * @param aColumn The original column number.
  	 * @param aSource The original source's filename.
  	 * @param aChunks Optional. An array of strings which are snippets of
  	 *        generated JS, or other SourceNodes.
  	 * @param aName The original identifier.
  	 */
  	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  	  this.children = [];
  	  this.sourceContents = {};
  	  this.line = aLine == null ? null : aLine;
  	  this.column = aColumn == null ? null : aColumn;
  	  this.source = aSource == null ? null : aSource;
  	  this.name = aName == null ? null : aName;
  	  this[isSourceNode] = true;
  	  if (aChunks != null) this.add(aChunks);
  	}

  	/**
  	 * Creates a SourceNode from generated code and a SourceMapConsumer.
  	 *
  	 * @param aGeneratedCode The generated code
  	 * @param aSourceMapConsumer The SourceMap for the generated code
  	 * @param aRelativePath Optional. The path that relative sources in the
  	 *        SourceMapConsumer should be relative to.
  	 */
  	SourceNode.fromStringWithSourceMap =
  	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  	    // The SourceNode we want to fill with the generated code
  	    // and the SourceMap
  	    var node = new SourceNode();

  	    // All even indices of this array are one line of the generated code,
  	    // while all odd indices are the newlines between two adjacent lines
  	    // (since `REGEX_NEWLINE` captures its match).
  	    // Processed fragments are accessed by calling `shiftNextLine`.
  	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  	    var remainingLinesIndex = 0;
  	    var shiftNextLine = function() {
  	      var lineContents = getNextLine();
  	      // The last line of a file might not have a newline.
  	      var newLine = getNextLine() || "";
  	      return lineContents + newLine;

  	      function getNextLine() {
  	        return remainingLinesIndex < remainingLines.length ?
  	            remainingLines[remainingLinesIndex++] : undefined;
  	      }
  	    };

  	    // We need to remember the position of "remainingLines"
  	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

  	    // The generate SourceNodes we need a code range.
  	    // To extract it current and last mapping is used.
  	    // Here we store the last mapping.
  	    var lastMapping = null;

  	    aSourceMapConsumer.eachMapping(function (mapping) {
  	      if (lastMapping !== null) {
  	        // We add the code from "lastMapping" to "mapping":
  	        // First check if there is a new line in between.
  	        if (lastGeneratedLine < mapping.generatedLine) {
  	          // Associate first line with "lastMapping"
  	          addMappingWithCode(lastMapping, shiftNextLine());
  	          lastGeneratedLine++;
  	          lastGeneratedColumn = 0;
  	          // The remaining code is added without mapping
  	        } else {
  	          // There is no new line in between.
  	          // Associate the code between "lastGeneratedColumn" and
  	          // "mapping.generatedColumn" with "lastMapping"
  	          var nextLine = remainingLines[remainingLinesIndex] || '';
  	          var code = nextLine.substr(0, mapping.generatedColumn -
  	                                        lastGeneratedColumn);
  	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
  	                                              lastGeneratedColumn);
  	          lastGeneratedColumn = mapping.generatedColumn;
  	          addMappingWithCode(lastMapping, code);
  	          // No more remaining code, continue
  	          lastMapping = mapping;
  	          return;
  	        }
  	      }
  	      // We add the generated code until the first mapping
  	      // to the SourceNode without any mapping.
  	      // Each line is added as separate string.
  	      while (lastGeneratedLine < mapping.generatedLine) {
  	        node.add(shiftNextLine());
  	        lastGeneratedLine++;
  	      }
  	      if (lastGeneratedColumn < mapping.generatedColumn) {
  	        var nextLine = remainingLines[remainingLinesIndex] || '';
  	        node.add(nextLine.substr(0, mapping.generatedColumn));
  	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
  	        lastGeneratedColumn = mapping.generatedColumn;
  	      }
  	      lastMapping = mapping;
  	    }, this);
  	    // We have processed all mappings.
  	    if (remainingLinesIndex < remainingLines.length) {
  	      if (lastMapping) {
  	        // Associate the remaining code in the current line with "lastMapping"
  	        addMappingWithCode(lastMapping, shiftNextLine());
  	      }
  	      // and add the remaining lines without any mapping
  	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
  	    }

  	    // Copy sourcesContent into SourceNode
  	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
  	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
  	      if (content != null) {
  	        if (aRelativePath != null) {
  	          sourceFile = util.join(aRelativePath, sourceFile);
  	        }
  	        node.setSourceContent(sourceFile, content);
  	      }
  	    });

  	    return node;

  	    function addMappingWithCode(mapping, code) {
  	      if (mapping === null || mapping.source === undefined) {
  	        node.add(code);
  	      } else {
  	        var source = aRelativePath
  	          ? util.join(aRelativePath, mapping.source)
  	          : mapping.source;
  	        node.add(new SourceNode(mapping.originalLine,
  	                                mapping.originalColumn,
  	                                source,
  	                                code,
  	                                mapping.name));
  	      }
  	    }
  	  };

  	/**
  	 * Add a chunk of generated JS to this source node.
  	 *
  	 * @param aChunk A string snippet of generated JS code, another instance of
  	 *        SourceNode, or an array where each member is one of those things.
  	 */
  	SourceNode.prototype.add = function SourceNode_add(aChunk) {
  	  if (Array.isArray(aChunk)) {
  	    aChunk.forEach(function (chunk) {
  	      this.add(chunk);
  	    }, this);
  	  }
  	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
  	    if (aChunk) {
  	      this.children.push(aChunk);
  	    }
  	  }
  	  else {
  	    throw new TypeError(
  	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
  	    );
  	  }
  	  return this;
  	};

  	/**
  	 * Add a chunk of generated JS to the beginning of this source node.
  	 *
  	 * @param aChunk A string snippet of generated JS code, another instance of
  	 *        SourceNode, or an array where each member is one of those things.
  	 */
  	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  	  if (Array.isArray(aChunk)) {
  	    for (var i = aChunk.length-1; i >= 0; i--) {
  	      this.prepend(aChunk[i]);
  	    }
  	  }
  	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
  	    this.children.unshift(aChunk);
  	  }
  	  else {
  	    throw new TypeError(
  	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
  	    );
  	  }
  	  return this;
  	};

  	/**
  	 * Walk over the tree of JS snippets in this node and its children. The
  	 * walking function is called once for each snippet of JS and is passed that
  	 * snippet and the its original associated source's line/column location.
  	 *
  	 * @param aFn The traversal function.
  	 */
  	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  	  var chunk;
  	  for (var i = 0, len = this.children.length; i < len; i++) {
  	    chunk = this.children[i];
  	    if (chunk[isSourceNode]) {
  	      chunk.walk(aFn);
  	    }
  	    else {
  	      if (chunk !== '') {
  	        aFn(chunk, { source: this.source,
  	                     line: this.line,
  	                     column: this.column,
  	                     name: this.name });
  	      }
  	    }
  	  }
  	};

  	/**
  	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
  	 * each of `this.children`.
  	 *
  	 * @param aSep The separator.
  	 */
  	SourceNode.prototype.join = function SourceNode_join(aSep) {
  	  var newChildren;
  	  var i;
  	  var len = this.children.length;
  	  if (len > 0) {
  	    newChildren = [];
  	    for (i = 0; i < len-1; i++) {
  	      newChildren.push(this.children[i]);
  	      newChildren.push(aSep);
  	    }
  	    newChildren.push(this.children[i]);
  	    this.children = newChildren;
  	  }
  	  return this;
  	};

  	/**
  	 * Call String.prototype.replace on the very right-most source snippet. Useful
  	 * for trimming whitespace from the end of a source node, etc.
  	 *
  	 * @param aPattern The pattern to replace.
  	 * @param aReplacement The thing to replace the pattern with.
  	 */
  	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  	  var lastChild = this.children[this.children.length - 1];
  	  if (lastChild[isSourceNode]) {
  	    lastChild.replaceRight(aPattern, aReplacement);
  	  }
  	  else if (typeof lastChild === 'string') {
  	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  	  }
  	  else {
  	    this.children.push(''.replace(aPattern, aReplacement));
  	  }
  	  return this;
  	};

  	/**
  	 * Set the source content for a source file. This will be added to the SourceMapGenerator
  	 * in the sourcesContent field.
  	 *
  	 * @param aSourceFile The filename of the source file
  	 * @param aSourceContent The content of the source file
  	 */
  	SourceNode.prototype.setSourceContent =
  	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  	  };

  	/**
  	 * Walk over the tree of SourceNodes. The walking function is called for each
  	 * source file content and is passed the filename and source content.
  	 *
  	 * @param aFn The traversal function.
  	 */
  	SourceNode.prototype.walkSourceContents =
  	  function SourceNode_walkSourceContents(aFn) {
  	    for (var i = 0, len = this.children.length; i < len; i++) {
  	      if (this.children[i][isSourceNode]) {
  	        this.children[i].walkSourceContents(aFn);
  	      }
  	    }

  	    var sources = Object.keys(this.sourceContents);
  	    for (var i = 0, len = sources.length; i < len; i++) {
  	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  	    }
  	  };

  	/**
  	 * Return the string representation of this source node. Walks over the tree
  	 * and concatenates all the various snippets together to one string.
  	 */
  	SourceNode.prototype.toString = function SourceNode_toString() {
  	  var str = "";
  	  this.walk(function (chunk) {
  	    str += chunk;
  	  });
  	  return str;
  	};

  	/**
  	 * Returns the string representation of this source node along with a source
  	 * map.
  	 */
  	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  	  var generated = {
  	    code: "",
  	    line: 1,
  	    column: 0
  	  };
  	  var map = new SourceMapGenerator(aArgs);
  	  var sourceMappingActive = false;
  	  var lastOriginalSource = null;
  	  var lastOriginalLine = null;
  	  var lastOriginalColumn = null;
  	  var lastOriginalName = null;
  	  this.walk(function (chunk, original) {
  	    generated.code += chunk;
  	    if (original.source !== null
  	        && original.line !== null
  	        && original.column !== null) {
  	      if(lastOriginalSource !== original.source
  	         || lastOriginalLine !== original.line
  	         || lastOriginalColumn !== original.column
  	         || lastOriginalName !== original.name) {
  	        map.addMapping({
  	          source: original.source,
  	          original: {
  	            line: original.line,
  	            column: original.column
  	          },
  	          generated: {
  	            line: generated.line,
  	            column: generated.column
  	          },
  	          name: original.name
  	        });
  	      }
  	      lastOriginalSource = original.source;
  	      lastOriginalLine = original.line;
  	      lastOriginalColumn = original.column;
  	      lastOriginalName = original.name;
  	      sourceMappingActive = true;
  	    } else if (sourceMappingActive) {
  	      map.addMapping({
  	        generated: {
  	          line: generated.line,
  	          column: generated.column
  	        }
  	      });
  	      lastOriginalSource = null;
  	      sourceMappingActive = false;
  	    }
  	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
  	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
  	        generated.line++;
  	        generated.column = 0;
  	        // Mappings end at eol
  	        if (idx + 1 === length) {
  	          lastOriginalSource = null;
  	          sourceMappingActive = false;
  	        } else if (sourceMappingActive) {
  	          map.addMapping({
  	            source: original.source,
  	            original: {
  	              line: original.line,
  	              column: original.column
  	            },
  	            generated: {
  	              line: generated.line,
  	              column: generated.column
  	            },
  	            name: original.name
  	          });
  	        }
  	      } else {
  	        generated.column++;
  	      }
  	    }
  	  });
  	  this.walkSourceContents(function (sourceFile, sourceContent) {
  	    map.setSourceContent(sourceFile, sourceContent);
  	  });

  	  return { code: generated.code, map: map };
  	};

  	sourceNode.SourceNode = SourceNode;
  	return sourceNode;
  }

  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var hasRequiredSourceMap;

  function requireSourceMap () {
  	if (hasRequiredSourceMap) return sourceMap;
  	hasRequiredSourceMap = 1;
  	sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  	sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  	sourceMap.SourceNode = requireSourceNode().SourceNode;
  	return sourceMap;
  }

  /* global define, require */

  (function (module, exports) {

  	exports.__esModule = true;

  	var _utils = utils;

  	var SourceNode = undefined;

  	try {
  	  /* istanbul ignore next */
  	  if (typeof undefined !== 'function' || !undefined.amd) {
  	    // We don't support this in AMD environments. For these environments, we assume that
  	    // they are running on the browser and thus have no need for the source-map library.
  	    var SourceMap = requireSourceMap();
  	    SourceNode = SourceMap.SourceNode;
  	  }
  	} catch (err) {}
  	/* NOP */

  	/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
  	if (!SourceNode) {
  	  SourceNode = function (line, column, srcFile, chunks) {
  	    this.src = '';
  	    if (chunks) {
  	      this.add(chunks);
  	    }
  	  };
  	  /* istanbul ignore next */
  	  SourceNode.prototype = {
  	    add: function add(chunks) {
  	      if (_utils.isArray(chunks)) {
  	        chunks = chunks.join('');
  	      }
  	      this.src += chunks;
  	    },
  	    prepend: function prepend(chunks) {
  	      if (_utils.isArray(chunks)) {
  	        chunks = chunks.join('');
  	      }
  	      this.src = chunks + this.src;
  	    },
  	    toStringWithSourceMap: function toStringWithSourceMap() {
  	      return { code: this.toString() };
  	    },
  	    toString: function toString() {
  	      return this.src;
  	    }
  	  };
  	}

  	function castChunk(chunk, codeGen, loc) {
  	  if (_utils.isArray(chunk)) {
  	    var ret = [];

  	    for (var i = 0, len = chunk.length; i < len; i++) {
  	      ret.push(codeGen.wrap(chunk[i], loc));
  	    }
  	    return ret;
  	  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
  	    // Handle primitives that the SourceNode will throw up on
  	    return chunk + '';
  	  }
  	  return chunk;
  	}

  	function CodeGen(srcFile) {
  	  this.srcFile = srcFile;
  	  this.source = [];
  	}

  	CodeGen.prototype = {
  	  isEmpty: function isEmpty() {
  	    return !this.source.length;
  	  },
  	  prepend: function prepend(source, loc) {
  	    this.source.unshift(this.wrap(source, loc));
  	  },
  	  push: function push(source, loc) {
  	    this.source.push(this.wrap(source, loc));
  	  },

  	  merge: function merge() {
  	    var source = this.empty();
  	    this.each(function (line) {
  	      source.add(['  ', line, '\n']);
  	    });
  	    return source;
  	  },

  	  each: function each(iter) {
  	    for (var i = 0, len = this.source.length; i < len; i++) {
  	      iter(this.source[i]);
  	    }
  	  },

  	  empty: function empty() {
  	    var loc = this.currentLocation || { start: {} };
  	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
  	  },
  	  wrap: function wrap(chunk) {
  	    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

  	    if (chunk instanceof SourceNode) {
  	      return chunk;
  	    }

  	    chunk = castChunk(chunk, this, loc);

  	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
  	  },

  	  functionCall: function functionCall(fn, type, params) {
  	    params = this.generateList(params);
  	    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
  	  },

  	  quotedString: function quotedString(str) {
  	    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
  	    .replace(/\u2029/g, '\\u2029') + '"';
  	  },

  	  objectLiteral: function objectLiteral(obj) {
  	    // istanbul ignore next

  	    var _this = this;

  	    var pairs = [];

  	    Object.keys(obj).forEach(function (key) {
  	      var value = castChunk(obj[key], _this);
  	      if (value !== 'undefined') {
  	        pairs.push([_this.quotedString(key), ':', value]);
  	      }
  	    });

  	    var ret = this.generateList(pairs);
  	    ret.prepend('{');
  	    ret.add('}');
  	    return ret;
  	  },

  	  generateList: function generateList(entries) {
  	    var ret = this.empty();

  	    for (var i = 0, len = entries.length; i < len; i++) {
  	      if (i) {
  	        ret.add(',');
  	      }

  	      ret.add(castChunk(entries[i], this));
  	    }

  	    return ret;
  	  },

  	  generateArray: function generateArray(entries) {
  	    var ret = this.generateList(entries);
  	    ret.prepend('[');
  	    ret.add(']');

  	    return ret;
  	  }
  	};

  	exports['default'] = CodeGen;
  	module.exports = exports['default'];
  	
  } (codeGen, codeGen.exports));

  var codeGenExports = codeGen.exports;

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	var _base = base$1;

  	var _exception = exceptionExports;

  	var _exception2 = _interopRequireDefault(_exception);

  	var _utils = utils;

  	var _codeGen = codeGenExports;

  	var _codeGen2 = _interopRequireDefault(_codeGen);

  	function Literal(value) {
  	  this.value = value;
  	}

  	function JavaScriptCompiler() {}

  	JavaScriptCompiler.prototype = {
  	  // PUBLIC API: You can override these methods in a subclass to provide
  	  // alternative compiled forms for name lookup and buffering semantics
  	  nameLookup: function nameLookup(parent, name /*,  type */) {
  	    return this.internalNameLookup(parent, name);
  	  },
  	  depthedLookup: function depthedLookup(name) {
  	    return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];
  	  },

  	  compilerInfo: function compilerInfo() {
  	    var revision = _base.COMPILER_REVISION,
  	        versions = _base.REVISION_CHANGES[revision];
  	    return [revision, versions];
  	  },

  	  appendToBuffer: function appendToBuffer(source, location, explicit) {
  	    // Force a source as this simplifies the merge logic.
  	    if (!_utils.isArray(source)) {
  	      source = [source];
  	    }
  	    source = this.source.wrap(source, location);

  	    if (this.environment.isSimple) {
  	      return ['return ', source, ';'];
  	    } else if (explicit) {
  	      // This is a case where the buffer operation occurs as a child of another
  	      // construct, generally braces. We have to explicitly output these buffer
  	      // operations to ensure that the emitted code goes in the correct location.
  	      return ['buffer += ', source, ';'];
  	    } else {
  	      source.appendToBuffer = true;
  	      return source;
  	    }
  	  },

  	  initializeBuffer: function initializeBuffer() {
  	    return this.quotedString('');
  	  },
  	  // END PUBLIC API
  	  internalNameLookup: function internalNameLookup(parent, name) {
  	    this.lookupPropertyFunctionIsUsed = true;
  	    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];
  	  },

  	  lookupPropertyFunctionIsUsed: false,

  	  compile: function compile(environment, options, context, asObject) {
  	    this.environment = environment;
  	    this.options = options;
  	    this.stringParams = this.options.stringParams;
  	    this.trackIds = this.options.trackIds;
  	    this.precompile = !asObject;

  	    this.name = this.environment.name;
  	    this.isChild = !!context;
  	    this.context = context || {
  	      decorators: [],
  	      programs: [],
  	      environments: []
  	    };

  	    this.preamble();

  	    this.stackSlot = 0;
  	    this.stackVars = [];
  	    this.aliases = {};
  	    this.registers = { list: [] };
  	    this.hashes = [];
  	    this.compileStack = [];
  	    this.inlineStack = [];
  	    this.blockParams = [];

  	    this.compileChildren(environment, options);

  	    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
  	    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

  	    var opcodes = environment.opcodes,
  	        opcode = undefined,
  	        firstLoc = undefined,
  	        i = undefined,
  	        l = undefined;

  	    for (i = 0, l = opcodes.length; i < l; i++) {
  	      opcode = opcodes[i];

  	      this.source.currentLocation = opcode.loc;
  	      firstLoc = firstLoc || opcode.loc;
  	      this[opcode.opcode].apply(this, opcode.args);
  	    }

  	    // Flush any trailing content that might be pending.
  	    this.source.currentLocation = firstLoc;
  	    this.pushSource('');

  	    /* istanbul ignore next */
  	    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
  	      throw new _exception2['default']('Compile completed with content left on stack');
  	    }

  	    if (!this.decorators.isEmpty()) {
  	      this.useDecorators = true;

  	      this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\n']);
  	      this.decorators.push('return fn;');

  	      if (asObject) {
  	        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
  	      } else {
  	        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
  	        this.decorators.push('}\n');
  	        this.decorators = this.decorators.merge();
  	      }
  	    } else {
  	      this.decorators = undefined;
  	    }

  	    var fn = this.createFunctionContext(asObject);
  	    if (!this.isChild) {
  	      var ret = {
  	        compiler: this.compilerInfo(),
  	        main: fn
  	      };

  	      if (this.decorators) {
  	        ret.main_d = this.decorators; // eslint-disable-line camelcase
  	        ret.useDecorators = true;
  	      }

  	      var _context = this.context;
  	      var programs = _context.programs;
  	      var decorators = _context.decorators;

  	      for (i = 0, l = programs.length; i < l; i++) {
  	        if (programs[i]) {
  	          ret[i] = programs[i];
  	          if (decorators[i]) {
  	            ret[i + '_d'] = decorators[i];
  	            ret.useDecorators = true;
  	          }
  	        }
  	      }

  	      if (this.environment.usePartial) {
  	        ret.usePartial = true;
  	      }
  	      if (this.options.data) {
  	        ret.useData = true;
  	      }
  	      if (this.useDepths) {
  	        ret.useDepths = true;
  	      }
  	      if (this.useBlockParams) {
  	        ret.useBlockParams = true;
  	      }
  	      if (this.options.compat) {
  	        ret.compat = true;
  	      }

  	      if (!asObject) {
  	        ret.compiler = JSON.stringify(ret.compiler);

  	        this.source.currentLocation = { start: { line: 1, column: 0 } };
  	        ret = this.objectLiteral(ret);

  	        if (options.srcName) {
  	          ret = ret.toStringWithSourceMap({ file: options.destName });
  	          ret.map = ret.map && ret.map.toString();
  	        } else {
  	          ret = ret.toString();
  	        }
  	      } else {
  	        ret.compilerOptions = this.options;
  	      }

  	      return ret;
  	    } else {
  	      return fn;
  	    }
  	  },

  	  preamble: function preamble() {
  	    // track the last context pushed into place to allow skipping the
  	    // getContext opcode when it would be a noop
  	    this.lastContext = 0;
  	    this.source = new _codeGen2['default'](this.options.srcName);
  	    this.decorators = new _codeGen2['default'](this.options.srcName);
  	  },

  	  createFunctionContext: function createFunctionContext(asObject) {
  	    // istanbul ignore next

  	    var _this = this;

  	    var varDeclarations = '';

  	    var locals = this.stackVars.concat(this.registers.list);
  	    if (locals.length > 0) {
  	      varDeclarations += ', ' + locals.join(', ');
  	    }

  	    // Generate minimizer alias mappings
  	    //
  	    // When using true SourceNodes, this will update all references to the given alias
  	    // as the source nodes are reused in situ. For the non-source node compilation mode,
  	    // aliases will not be used, but this case is already being run on the client and
  	    // we aren't concern about minimizing the template size.
  	    var aliasCount = 0;
  	    Object.keys(this.aliases).forEach(function (alias) {
  	      var node = _this.aliases[alias];
  	      if (node.children && node.referenceCount > 1) {
  	        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
  	        node.children[0] = 'alias' + aliasCount;
  	      }
  	    });

  	    if (this.lookupPropertyFunctionIsUsed) {
  	      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();
  	    }

  	    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

  	    if (this.useBlockParams || this.useDepths) {
  	      params.push('blockParams');
  	    }
  	    if (this.useDepths) {
  	      params.push('depths');
  	    }

  	    // Perform a second pass over the output to merge content when possible
  	    var source = this.mergeSource(varDeclarations);

  	    if (asObject) {
  	      params.push(source);

  	      return Function.apply(this, params);
  	    } else {
  	      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
  	    }
  	  },
  	  mergeSource: function mergeSource(varDeclarations) {
  	    var isSimple = this.environment.isSimple,
  	        appendOnly = !this.forceBuffer,
  	        appendFirst = undefined,
  	        sourceSeen = undefined,
  	        bufferStart = undefined,
  	        bufferEnd = undefined;
  	    this.source.each(function (line) {
  	      if (line.appendToBuffer) {
  	        if (bufferStart) {
  	          line.prepend('  + ');
  	        } else {
  	          bufferStart = line;
  	        }
  	        bufferEnd = line;
  	      } else {
  	        if (bufferStart) {
  	          if (!sourceSeen) {
  	            appendFirst = true;
  	          } else {
  	            bufferStart.prepend('buffer += ');
  	          }
  	          bufferEnd.add(';');
  	          bufferStart = bufferEnd = undefined;
  	        }

  	        sourceSeen = true;
  	        if (!isSimple) {
  	          appendOnly = false;
  	        }
  	      }
  	    });

  	    if (appendOnly) {
  	      if (bufferStart) {
  	        bufferStart.prepend('return ');
  	        bufferEnd.add(';');
  	      } else if (!sourceSeen) {
  	        this.source.push('return "";');
  	      }
  	    } else {
  	      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

  	      if (bufferStart) {
  	        bufferStart.prepend('return buffer + ');
  	        bufferEnd.add(';');
  	      } else {
  	        this.source.push('return buffer;');
  	      }
  	    }

  	    if (varDeclarations) {
  	      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
  	    }

  	    return this.source.merge();
  	  },

  	  lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
  	    return '\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    '.trim();
  	  },

  	  // [blockValue]
  	  //
  	  // On stack, before: hash, inverse, program, value
  	  // On stack, after: return value of blockHelperMissing
  	  //
  	  // The purpose of this opcode is to take a block of the form
  	  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
  	  // replace it on the stack with the result of properly
  	  // invoking blockHelperMissing.
  	  blockValue: function blockValue(name) {
  	    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
  	        params = [this.contextName(0)];
  	    this.setupHelperArgs(name, 0, params);

  	    var blockName = this.popStack();
  	    params.splice(1, 0, blockName);

  	    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
  	  },

  	  // [ambiguousBlockValue]
  	  //
  	  // On stack, before: hash, inverse, program, value
  	  // Compiler value, before: lastHelper=value of last found helper, if any
  	  // On stack, after, if no lastHelper: same as [blockValue]
  	  // On stack, after, if lastHelper: value
  	  ambiguousBlockValue: function ambiguousBlockValue() {
  	    // We're being a bit cheeky and reusing the options value from the prior exec
  	    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
  	        params = [this.contextName(0)];
  	    this.setupHelperArgs('', 0, params, true);

  	    this.flushInline();

  	    var current = this.topStack();
  	    params.splice(1, 0, current);

  	    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
  	  },

  	  // [appendContent]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: ...
  	  //
  	  // Appends the string value of `content` to the current buffer
  	  appendContent: function appendContent(content) {
  	    if (this.pendingContent) {
  	      content = this.pendingContent + content;
  	    } else {
  	      this.pendingLocation = this.source.currentLocation;
  	    }

  	    this.pendingContent = content;
  	  },

  	  // [append]
  	  //
  	  // On stack, before: value, ...
  	  // On stack, after: ...
  	  //
  	  // Coerces `value` to a String and appends it to the current buffer.
  	  //
  	  // If `value` is truthy, or 0, it is coerced into a string and appended
  	  // Otherwise, the empty string is appended
  	  append: function append() {
  	    if (this.isInline()) {
  	      this.replaceStack(function (current) {
  	        return [' != null ? ', current, ' : ""'];
  	      });

  	      this.pushSource(this.appendToBuffer(this.popStack()));
  	    } else {
  	      var local = this.popStack();
  	      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
  	      if (this.environment.isSimple) {
  	        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
  	      }
  	    }
  	  },

  	  // [appendEscaped]
  	  //
  	  // On stack, before: value, ...
  	  // On stack, after: ...
  	  //
  	  // Escape `value` and append it to the buffer
  	  appendEscaped: function appendEscaped() {
  	    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
  	  },

  	  // [getContext]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: ...
  	  // Compiler value, after: lastContext=depth
  	  //
  	  // Set the value of the `lastContext` compiler value to the depth
  	  getContext: function getContext(depth) {
  	    this.lastContext = depth;
  	  },

  	  // [pushContext]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: currentContext, ...
  	  //
  	  // Pushes the value of the current context onto the stack.
  	  pushContext: function pushContext() {
  	    this.pushStackLiteral(this.contextName(this.lastContext));
  	  },

  	  // [lookupOnContext]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: currentContext[name], ...
  	  //
  	  // Looks up the value of `name` on the current context and pushes
  	  // it onto the stack.
  	  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
  	    var i = 0;

  	    if (!scoped && this.options.compat && !this.lastContext) {
  	      // The depthed query is expected to handle the undefined logic for the root level that
  	      // is implemented below, so we evaluate that directly in compat mode
  	      this.push(this.depthedLookup(parts[i++]));
  	    } else {
  	      this.pushContext();
  	    }

  	    this.resolvePath('context', parts, i, falsy, strict);
  	  },

  	  // [lookupBlockParam]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: blockParam[name], ...
  	  //
  	  // Looks up the value of `parts` on the given block param and pushes
  	  // it onto the stack.
  	  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
  	    this.useBlockParams = true;

  	    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
  	    this.resolvePath('context', parts, 1);
  	  },

  	  // [lookupData]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: data, ...
  	  //
  	  // Push the data lookup operator
  	  lookupData: function lookupData(depth, parts, strict) {
  	    if (!depth) {
  	      this.pushStackLiteral('data');
  	    } else {
  	      this.pushStackLiteral('container.data(data, ' + depth + ')');
  	    }

  	    this.resolvePath('data', parts, 0, true, strict);
  	  },

  	  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
  	    // istanbul ignore next

  	    var _this2 = this;

  	    if (this.options.strict || this.options.assumeObjects) {
  	      this.push(strictLookup(this.options.strict && strict, this, parts, i, type));
  	      return;
  	    }

  	    var len = parts.length;
  	    for (; i < len; i++) {
  	      /* eslint-disable no-loop-func */
  	      this.replaceStack(function (current) {
  	        var lookup = _this2.nameLookup(current, parts[i], type);
  	        // We want to ensure that zero and false are handled properly if the context (falsy flag)
  	        // needs to have the special handling for these values.
  	        if (!falsy) {
  	          return [' != null ? ', lookup, ' : ', current];
  	        } else {
  	          // Otherwise we can use generic falsy handling
  	          return [' && ', lookup];
  	        }
  	      });
  	      /* eslint-enable no-loop-func */
  	    }
  	  },

  	  // [resolvePossibleLambda]
  	  //
  	  // On stack, before: value, ...
  	  // On stack, after: resolved value, ...
  	  //
  	  // If the `value` is a lambda, replace it on the stack by
  	  // the return value of the lambda
  	  resolvePossibleLambda: function resolvePossibleLambda() {
  	    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
  	  },

  	  // [pushStringParam]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: string, currentContext, ...
  	  //
  	  // This opcode is designed for use in string mode, which
  	  // provides the string value of a parameter along with its
  	  // depth rather than resolving it immediately.
  	  pushStringParam: function pushStringParam(string, type) {
  	    this.pushContext();
  	    this.pushString(type);

  	    // If it's a subexpression, the string result
  	    // will be pushed after this opcode.
  	    if (type !== 'SubExpression') {
  	      if (typeof string === 'string') {
  	        this.pushString(string);
  	      } else {
  	        this.pushStackLiteral(string);
  	      }
  	    }
  	  },

  	  emptyHash: function emptyHash(omitEmpty) {
  	    if (this.trackIds) {
  	      this.push('{}'); // hashIds
  	    }
  	    if (this.stringParams) {
  	      this.push('{}'); // hashContexts
  	      this.push('{}'); // hashTypes
  	    }
  	    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
  	  },
  	  pushHash: function pushHash() {
  	    if (this.hash) {
  	      this.hashes.push(this.hash);
  	    }
  	    this.hash = { values: {}, types: [], contexts: [], ids: [] };
  	  },
  	  popHash: function popHash() {
  	    var hash = this.hash;
  	    this.hash = this.hashes.pop();

  	    if (this.trackIds) {
  	      this.push(this.objectLiteral(hash.ids));
  	    }
  	    if (this.stringParams) {
  	      this.push(this.objectLiteral(hash.contexts));
  	      this.push(this.objectLiteral(hash.types));
  	    }

  	    this.push(this.objectLiteral(hash.values));
  	  },

  	  // [pushString]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: quotedString(string), ...
  	  //
  	  // Push a quoted version of `string` onto the stack
  	  pushString: function pushString(string) {
  	    this.pushStackLiteral(this.quotedString(string));
  	  },

  	  // [pushLiteral]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: value, ...
  	  //
  	  // Pushes a value onto the stack. This operation prevents
  	  // the compiler from creating a temporary variable to hold
  	  // it.
  	  pushLiteral: function pushLiteral(value) {
  	    this.pushStackLiteral(value);
  	  },

  	  // [pushProgram]
  	  //
  	  // On stack, before: ...
  	  // On stack, after: program(guid), ...
  	  //
  	  // Push a program expression onto the stack. This takes
  	  // a compile-time guid and converts it into a runtime-accessible
  	  // expression.
  	  pushProgram: function pushProgram(guid) {
  	    if (guid != null) {
  	      this.pushStackLiteral(this.programExpression(guid));
  	    } else {
  	      this.pushStackLiteral(null);
  	    }
  	  },

  	  // [registerDecorator]
  	  //
  	  // On stack, before: hash, program, params..., ...
  	  // On stack, after: ...
  	  //
  	  // Pops off the decorator's parameters, invokes the decorator,
  	  // and inserts the decorator into the decorators list.
  	  registerDecorator: function registerDecorator(paramSize, name) {
  	    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
  	        options = this.setupHelperArgs(name, paramSize);

  	    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
  	  },

  	  // [invokeHelper]
  	  //
  	  // On stack, before: hash, inverse, program, params..., ...
  	  // On stack, after: result of helper invocation
  	  //
  	  // Pops off the helper's parameters, invokes the helper,
  	  // and pushes the helper's return value onto the stack.
  	  //
  	  // If the helper is not found, `helperMissing` is called.
  	  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
  	    var nonHelper = this.popStack(),
  	        helper = this.setupHelper(paramSize, name);

  	    var possibleFunctionCalls = [];

  	    if (isSimple) {
  	      // direct call to helper
  	      possibleFunctionCalls.push(helper.name);
  	    }
  	    // call a function from the input object
  	    possibleFunctionCalls.push(nonHelper);
  	    if (!this.options.strict) {
  	      possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));
  	    }

  	    var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];
  	    var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);
  	    this.push(functionCall);
  	  },

  	  itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
  	    var result = [];
  	    result.push(items[0]);
  	    for (var i = 1; i < items.length; i++) {
  	      result.push(separator, items[i]);
  	    }
  	    return result;
  	  },
  	  // [invokeKnownHelper]
  	  //
  	  // On stack, before: hash, inverse, program, params..., ...
  	  // On stack, after: result of helper invocation
  	  //
  	  // This operation is used when the helper is known to exist,
  	  // so a `helperMissing` fallback is not required.
  	  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
  	    var helper = this.setupHelper(paramSize, name);
  	    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
  	  },

  	  // [invokeAmbiguous]
  	  //
  	  // On stack, before: hash, inverse, program, params..., ...
  	  // On stack, after: result of disambiguation
  	  //
  	  // This operation is used when an expression like `{{foo}}`
  	  // is provided, but we don't know at compile-time whether it
  	  // is a helper or a path.
  	  //
  	  // This operation emits more code than the other options,
  	  // and can be avoided by passing the `knownHelpers` and
  	  // `knownHelpersOnly` flags at compile-time.
  	  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
  	    this.useRegister('helper');

  	    var nonHelper = this.popStack();

  	    this.emptyHash();
  	    var helper = this.setupHelper(0, name, helperCall);

  	    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

  	    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
  	    if (!this.options.strict) {
  	      lookup[0] = '(helper = ';
  	      lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));
  	    }

  	    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
  	  },

  	  // [invokePartial]
  	  //
  	  // On stack, before: context, ...
  	  // On stack after: result of partial invocation
  	  //
  	  // This operation pops off a context, invokes a partial with that context,
  	  // and pushes the result of the invocation back.
  	  invokePartial: function invokePartial(isDynamic, name, indent) {
  	    var params = [],
  	        options = this.setupParams(name, 1, params);

  	    if (isDynamic) {
  	      name = this.popStack();
  	      delete options.name;
  	    }

  	    if (indent) {
  	      options.indent = JSON.stringify(indent);
  	    }
  	    options.helpers = 'helpers';
  	    options.partials = 'partials';
  	    options.decorators = 'container.decorators';

  	    if (!isDynamic) {
  	      params.unshift(this.nameLookup('partials', name, 'partial'));
  	    } else {
  	      params.unshift(name);
  	    }

  	    if (this.options.compat) {
  	      options.depths = 'depths';
  	    }
  	    options = this.objectLiteral(options);
  	    params.push(options);

  	    this.push(this.source.functionCall('container.invokePartial', '', params));
  	  },

  	  // [assignToHash]
  	  //
  	  // On stack, before: value, ..., hash, ...
  	  // On stack, after: ..., hash, ...
  	  //
  	  // Pops a value off the stack and assigns it to the current hash
  	  assignToHash: function assignToHash(key) {
  	    var value = this.popStack(),
  	        context = undefined,
  	        type = undefined,
  	        id = undefined;

  	    if (this.trackIds) {
  	      id = this.popStack();
  	    }
  	    if (this.stringParams) {
  	      type = this.popStack();
  	      context = this.popStack();
  	    }

  	    var hash = this.hash;
  	    if (context) {
  	      hash.contexts[key] = context;
  	    }
  	    if (type) {
  	      hash.types[key] = type;
  	    }
  	    if (id) {
  	      hash.ids[key] = id;
  	    }
  	    hash.values[key] = value;
  	  },

  	  pushId: function pushId(type, name, child) {
  	    if (type === 'BlockParam') {
  	      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
  	    } else if (type === 'PathExpression') {
  	      this.pushString(name);
  	    } else if (type === 'SubExpression') {
  	      this.pushStackLiteral('true');
  	    } else {
  	      this.pushStackLiteral('null');
  	    }
  	  },

  	  // HELPERS

  	  compiler: JavaScriptCompiler,

  	  compileChildren: function compileChildren(environment, options) {
  	    var children = environment.children,
  	        child = undefined,
  	        compiler = undefined;

  	    for (var i = 0, l = children.length; i < l; i++) {
  	      child = children[i];
  	      compiler = new this.compiler(); // eslint-disable-line new-cap

  	      var existing = this.matchExistingProgram(child);

  	      if (existing == null) {
  	        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
  	        var index = this.context.programs.length;
  	        child.index = index;
  	        child.name = 'program' + index;
  	        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
  	        this.context.decorators[index] = compiler.decorators;
  	        this.context.environments[index] = child;

  	        this.useDepths = this.useDepths || compiler.useDepths;
  	        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
  	        child.useDepths = this.useDepths;
  	        child.useBlockParams = this.useBlockParams;
  	      } else {
  	        child.index = existing.index;
  	        child.name = 'program' + existing.index;

  	        this.useDepths = this.useDepths || existing.useDepths;
  	        this.useBlockParams = this.useBlockParams || existing.useBlockParams;
  	      }
  	    }
  	  },
  	  matchExistingProgram: function matchExistingProgram(child) {
  	    for (var i = 0, len = this.context.environments.length; i < len; i++) {
  	      var environment = this.context.environments[i];
  	      if (environment && environment.equals(child)) {
  	        return environment;
  	      }
  	    }
  	  },

  	  programExpression: function programExpression(guid) {
  	    var child = this.environment.children[guid],
  	        programParams = [child.index, 'data', child.blockParams];

  	    if (this.useBlockParams || this.useDepths) {
  	      programParams.push('blockParams');
  	    }
  	    if (this.useDepths) {
  	      programParams.push('depths');
  	    }

  	    return 'container.program(' + programParams.join(', ') + ')';
  	  },

  	  useRegister: function useRegister(name) {
  	    if (!this.registers[name]) {
  	      this.registers[name] = true;
  	      this.registers.list.push(name);
  	    }
  	  },

  	  push: function push(expr) {
  	    if (!(expr instanceof Literal)) {
  	      expr = this.source.wrap(expr);
  	    }

  	    this.inlineStack.push(expr);
  	    return expr;
  	  },

  	  pushStackLiteral: function pushStackLiteral(item) {
  	    this.push(new Literal(item));
  	  },

  	  pushSource: function pushSource(source) {
  	    if (this.pendingContent) {
  	      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
  	      this.pendingContent = undefined;
  	    }

  	    if (source) {
  	      this.source.push(source);
  	    }
  	  },

  	  replaceStack: function replaceStack(callback) {
  	    var prefix = ['('],
  	        stack = undefined,
  	        createdStack = undefined,
  	        usedLiteral = undefined;

  	    /* istanbul ignore next */
  	    if (!this.isInline()) {
  	      throw new _exception2['default']('replaceStack on non-inline');
  	    }

  	    // We want to merge the inline statement into the replacement statement via ','
  	    var top = this.popStack(true);

  	    if (top instanceof Literal) {
  	      // Literals do not need to be inlined
  	      stack = [top.value];
  	      prefix = ['(', stack];
  	      usedLiteral = true;
  	    } else {
  	      // Get or create the current stack name for use by the inline
  	      createdStack = true;
  	      var _name = this.incrStack();

  	      prefix = ['((', this.push(_name), ' = ', top, ')'];
  	      stack = this.topStack();
  	    }

  	    var item = callback.call(this, stack);

  	    if (!usedLiteral) {
  	      this.popStack();
  	    }
  	    if (createdStack) {
  	      this.stackSlot--;
  	    }
  	    this.push(prefix.concat(item, ')'));
  	  },

  	  incrStack: function incrStack() {
  	    this.stackSlot++;
  	    if (this.stackSlot > this.stackVars.length) {
  	      this.stackVars.push('stack' + this.stackSlot);
  	    }
  	    return this.topStackName();
  	  },
  	  topStackName: function topStackName() {
  	    return 'stack' + this.stackSlot;
  	  },
  	  flushInline: function flushInline() {
  	    var inlineStack = this.inlineStack;
  	    this.inlineStack = [];
  	    for (var i = 0, len = inlineStack.length; i < len; i++) {
  	      var entry = inlineStack[i];
  	      /* istanbul ignore if */
  	      if (entry instanceof Literal) {
  	        this.compileStack.push(entry);
  	      } else {
  	        var stack = this.incrStack();
  	        this.pushSource([stack, ' = ', entry, ';']);
  	        this.compileStack.push(stack);
  	      }
  	    }
  	  },
  	  isInline: function isInline() {
  	    return this.inlineStack.length;
  	  },

  	  popStack: function popStack(wrapped) {
  	    var inline = this.isInline(),
  	        item = (inline ? this.inlineStack : this.compileStack).pop();

  	    if (!wrapped && item instanceof Literal) {
  	      return item.value;
  	    } else {
  	      if (!inline) {
  	        /* istanbul ignore next */
  	        if (!this.stackSlot) {
  	          throw new _exception2['default']('Invalid stack pop');
  	        }
  	        this.stackSlot--;
  	      }
  	      return item;
  	    }
  	  },

  	  topStack: function topStack() {
  	    var stack = this.isInline() ? this.inlineStack : this.compileStack,
  	        item = stack[stack.length - 1];

  	    /* istanbul ignore if */
  	    if (item instanceof Literal) {
  	      return item.value;
  	    } else {
  	      return item;
  	    }
  	  },

  	  contextName: function contextName(context) {
  	    if (this.useDepths && context) {
  	      return 'depths[' + context + ']';
  	    } else {
  	      return 'depth' + context;
  	    }
  	  },

  	  quotedString: function quotedString(str) {
  	    return this.source.quotedString(str);
  	  },

  	  objectLiteral: function objectLiteral(obj) {
  	    return this.source.objectLiteral(obj);
  	  },

  	  aliasable: function aliasable(name) {
  	    var ret = this.aliases[name];
  	    if (ret) {
  	      ret.referenceCount++;
  	      return ret;
  	    }

  	    ret = this.aliases[name] = this.source.wrap(name);
  	    ret.aliasable = true;
  	    ret.referenceCount = 1;

  	    return ret;
  	  },

  	  setupHelper: function setupHelper(paramSize, name, blockHelper) {
  	    var params = [],
  	        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
  	    var foundHelper = this.nameLookup('helpers', name, 'helper'),
  	        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

  	    return {
  	      params: params,
  	      paramsInit: paramsInit,
  	      name: foundHelper,
  	      callParams: [callContext].concat(params)
  	    };
  	  },

  	  setupParams: function setupParams(helper, paramSize, params) {
  	    var options = {},
  	        contexts = [],
  	        types = [],
  	        ids = [],
  	        objectArgs = !params,
  	        param = undefined;

  	    if (objectArgs) {
  	      params = [];
  	    }

  	    options.name = this.quotedString(helper);
  	    options.hash = this.popStack();

  	    if (this.trackIds) {
  	      options.hashIds = this.popStack();
  	    }
  	    if (this.stringParams) {
  	      options.hashTypes = this.popStack();
  	      options.hashContexts = this.popStack();
  	    }

  	    var inverse = this.popStack(),
  	        program = this.popStack();

  	    // Avoid setting fn and inverse if neither are set. This allows
  	    // helpers to do a check for `if (options.fn)`
  	    if (program || inverse) {
  	      options.fn = program || 'container.noop';
  	      options.inverse = inverse || 'container.noop';
  	    }

  	    // The parameters go on to the stack in order (making sure that they are evaluated in order)
  	    // so we need to pop them off the stack in reverse order
  	    var i = paramSize;
  	    while (i--) {
  	      param = this.popStack();
  	      params[i] = param;

  	      if (this.trackIds) {
  	        ids[i] = this.popStack();
  	      }
  	      if (this.stringParams) {
  	        types[i] = this.popStack();
  	        contexts[i] = this.popStack();
  	      }
  	    }

  	    if (objectArgs) {
  	      options.args = this.source.generateArray(params);
  	    }

  	    if (this.trackIds) {
  	      options.ids = this.source.generateArray(ids);
  	    }
  	    if (this.stringParams) {
  	      options.types = this.source.generateArray(types);
  	      options.contexts = this.source.generateArray(contexts);
  	    }

  	    if (this.options.data) {
  	      options.data = 'data';
  	    }
  	    if (this.useBlockParams) {
  	      options.blockParams = 'blockParams';
  	    }
  	    return options;
  	  },

  	  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
  	    var options = this.setupParams(helper, paramSize, params);
  	    options.loc = JSON.stringify(this.source.currentLocation);
  	    options = this.objectLiteral(options);
  	    if (useRegister) {
  	      this.useRegister('options');
  	      params.push('options');
  	      return ['options=', options];
  	    } else if (params) {
  	      params.push(options);
  	      return '';
  	    } else {
  	      return options;
  	    }
  	  }
  	};

  	(function () {
  	  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

  	  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

  	  for (var i = 0, l = reservedWords.length; i < l; i++) {
  	    compilerWords[reservedWords[i]] = true;
  	  }
  	})();

  	/**
  	 * @deprecated May be removed in the next major version
  	 */
  	JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
  	  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
  	};

  	function strictLookup(requireTerminal, compiler, parts, i, type) {
  	  var stack = compiler.popStack(),
  	      len = parts.length;
  	  if (requireTerminal) {
  	    len--;
  	  }

  	  for (; i < len; i++) {
  	    stack = compiler.nameLookup(stack, parts[i], type);
  	  }

  	  if (requireTerminal) {
  	    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];
  	  } else {
  	    return stack;
  	  }
  	}

  	exports['default'] = JavaScriptCompiler;
  	module.exports = exports['default'];
  	
  } (javascriptCompiler, javascriptCompiler.exports));

  var javascriptCompilerExports = javascriptCompiler.exports;

  (function (module, exports) {

  	exports.__esModule = true;
  	// istanbul ignore next

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  	var _handlebarsRuntime = handlebars_runtimeExports;

  	var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

  	// Compiler imports

  	var _handlebarsCompilerAst = astExports;

  	var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

  	var _handlebarsCompilerBase = base;

  	var _handlebarsCompilerCompiler = compiler;

  	var _handlebarsCompilerJavascriptCompiler = javascriptCompilerExports;

  	var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

  	var _handlebarsCompilerVisitor = visitorExports;

  	var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

  	var _handlebarsNoConflict = noConflictExports;

  	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

  	var _create = _handlebarsRuntime2['default'].create;
  	function create() {
  	  var hb = _create();

  	  hb.compile = function (input, options) {
  	    return _handlebarsCompilerCompiler.compile(input, options, hb);
  	  };
  	  hb.precompile = function (input, options) {
  	    return _handlebarsCompilerCompiler.precompile(input, options, hb);
  	  };

  	  hb.AST = _handlebarsCompilerAst2['default'];
  	  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
  	  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
  	  hb.Parser = _handlebarsCompilerBase.parser;
  	  hb.parse = _handlebarsCompilerBase.parse;
  	  hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;

  	  return hb;
  	}

  	var inst = create();
  	inst.create = create;

  	_handlebarsNoConflict2['default'](inst);

  	inst.Visitor = _handlebarsCompilerVisitor2['default'];

  	inst['default'] = inst;

  	exports['default'] = inst;
  	module.exports = exports['default'];
  	
  } (handlebars$1, handlebars$1.exports));

  var handlebarsExports = handlebars$1.exports;
  var handlebars = /*@__PURE__*/getDefaultExportFromCjs(handlebarsExports);

  var ValueConvertMethods = {
    evalExpression: function evalExpression(s) {
      if (typeof s !== 'string') {
        return s;
      }
      return Compile$1(s)(this.memory);
    },
    renderString: function renderString(s) {
      if (typeof s !== 'string') {
        return '';
      }
      return handlebars.render(s, this.memory);
    }
  };

  var RunMethods = {
    start: function start() {
      var argumentsCount = arguments.length;
      switch (argumentsCount) {
        case 0:
          this.getTreeGroup(this.defaultTreeGroupName).start();
          break;
        case 1:
          var name = arguments[0];
          if (this.hasTreeGroup(name)) {
            this.getTreeGroup(name).start();
          } else {
            this.getTreeGroup(this.defaultTreeGroupName).startTree(name);
          }
          break;
        case 2:
          var title = arguments[0];
          var ignoreCondition, groupName;
          if (typeof arguments[1] === 'string') {
            ignoreCondition = true;
            groupName = arguments[1];
          } else {
            ignoreCondition = arguments[1];
            groupName = this.defaultTreeGroupName;
          }
          this.getTreeGroup(groupName).startTree(title, ignoreCondition);
          break;
        default:
          var title = arguments[0];
          var groupName = arguments[1];
          var ignoreCondition = arguments[2];
          this.getTreeGroup(groupName).startTree(title, ignoreCondition);
          break;
      }
      return this;
    },
    "continue": function _continue(groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      this.getTreeGroup(groupName)["continue"]();
      return this;
    },
    stop: function stop(groupName) {
      if (groupName === undefined) {
        groupName = this.defaultTreeGroupName;
      }
      this.getTreeGroup(groupName).stop();
      return this;
    }
  };

  var RoundCounterMethods = {
    getRoundCounter: function getRoundCounter() {
      return this.blackboard.getCurrentTime();
    },
    setRoundCounter: function setRoundCounter(value) {
      this.blackboard.setCurrentTime(value);
      return this;
    },
    updateRoundCounter: function updateRoundCounter(value) {
      if (value === undefined) {
        this.blackboard.incCurrentTime(1);
      } else {
        this.blackboard.setCurrentTime(value);
      }
      return this;
    }
  };

  var Methods$n = {};
  Object.assign(Methods$n, TreeMethods, AddTreeMethods$1, RemoveTreeMethods$1, TreeActiveStateMethods, SaveLoadTreesMethods, DataMethods$3, StateMethods, ValueConvertMethods, RunMethods, RoundCounterMethods);

  BehaviorTree.setStartIDValue(0);
  var EventSheetManager = /*#__PURE__*/function (_EventEmitter) {
    _inherits(EventSheetManager, _EventEmitter);
    function EventSheetManager() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        commandExecutor = _ref.commandExecutor,
        _ref$parallel = _ref.parallel,
        parallel = _ref$parallel === void 0 ? false : _ref$parallel;
      _classCallCheck(this, EventSheetManager);
      _this = _callSuper(this, EventSheetManager);
      _this.defaultTreeGroupName = '_';
      _this.setCommandExecutor(commandExecutor);
      _this.parallel = parallel;
      _this.blackboard = new Blackboard({
        currentTimeKey: '$roundCounter'
      });
      _this.blackboard.treeManager = _assertThisInitialized(_this); // For TaskAction

      _this.treeGroups = {};
      _this.setRoundCounter(0);
      return _this;
    }
    _createClass(EventSheetManager, [{
      key: "memory",
      get: function get() {
        return this.blackboard.getGlobalMemory();
      }
    }, {
      key: "$roundCounter",
      get: function get() {
        return this.getRoundCounter();
      },
      set: function set(value) {
        this.setRoundCounter(value);
      }
    }, {
      key: "setCommandExecutor",
      value: function setCommandExecutor(commandExecutor) {
        this.commandExecutor = commandExecutor;
        return this;
      }
    }]);
    return EventSheetManager;
  }(EventEmitter$2);
  Object.assign(EventSheetManager.prototype, Methods$n);

  var RoundIdle = 0;
  var RoundRun = 1;
  var RoundComplete = 2;
  var PropertyTable = {
    'parallel': {
      defaultValue: false,
      rewritable: true
    },
    'active': {
      defaultValue: true,
      rewritable: true
    },
    'once': {
      defaultValue: false,
      rewritable: true
    },
    'roundState': {
      defaultValue: RoundIdle,
      rewritable: false
    },
    'conditionPassed': {
      defaultValue: undefined,
      rewritable: false
    }
  };
  var EventSheet = /*#__PURE__*/function (_BehaviorTree) {
    _inherits(EventSheet, _BehaviorTree);
    function EventSheet(treeManager, config) {
      var _this;
      _classCallCheck(this, EventSheet);
      if (config === undefined) {
        config = {};
      }
      var _config = config,
        groupName = _config.groupName;
      delete config.groupName;
      var _config2 = config,
        _config2$condition = _config2.condition,
        condition = _config2$condition === void 0 ? true : _config2$condition;
      delete config.condition;
      var properties = config.properties;
      delete config.properties;
      _this = _callSuper(this, EventSheet, [config]);

      // Store default properties
      for (var propertyKey in PropertyTable) {
        var _PropertyTable$proper = PropertyTable[propertyKey],
          defaultValue = _PropertyTable$proper.defaultValue,
          rewritable = _PropertyTable$proper.rewritable;
        _this.wrapProperty(propertyKey);
        if (rewritable) {
          if (propertyKey in properties) {
            _this[propertyKey] = properties[propertyKey];
            delete properties[propertyKey];
          } else {
            _this[propertyKey] = defaultValue;
          }
        } else {
          _this[propertyKey] = defaultValue;
        }
      }

      // Store custom properties
      for (var propertyKey in properties) {
        _this.wrapProperty(propertyKey);
        _this[propertyKey] = properties[propertyKey];
      }

      // Store references
      _this.treeManager = treeManager;
      _this.blackboard = treeManager.blackboard;
      _this.setTreeGroup(groupName);
      var root = new IfSelector({
        title: _this.title,
        expression: condition,
        conditionEvalBreak: true // Return RUNNING instead of SUCCESS for condition eval
      });
      _this.setRoot(root);
      return _this;
    }
    _createClass(EventSheet, [{
      key: "wrapProperty",
      value: function wrapProperty(key) {
        var treeProperties = this.properties;
        Object.defineProperty(this, key, {
          get: function get() {
            return treeProperties[key];
          },
          set: function set(newValue) {
            treeProperties[key] = newValue;
          },
          enumerable: true,
          configurable: true
        });
        return this;
      }
    }, {
      key: "setTreeGroup",
      value: function setTreeGroup(groupName) {
        this.groupName = groupName;
        this.eventSheetGroup = this.treeManager.getTreeGroup(groupName);
        return this;
      }
    }, {
      key: "setActive",
      value: function setActive(active) {
        if (active === undefined) {
          active = true;
        }
        this.active = active;
        return this;
      }
    }, {
      key: "roundComplete",
      get: function get() {
        return this.roundState === RoundComplete;
      },
      set: function set(value) {
        this.roundState = value ? RoundComplete : RoundRun;
      }
    }, {
      key: "setConditionEnable",
      value: function setConditionEnable() {
        var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var selectChildIndex = enable ? undefined : 0;
        this.root.setSelectChildIndex(selectChildIndex);
        return this;
      }
    }, {
      key: "start",
      value: function start(blackboard, target) {
        if (this.roundState === RoundRun) {
          return false;
        }
        var startFromTop = this.getState(blackboard) !== RUNNING$1;
        if (startFromTop) {
          this.resetState(blackboard);
        }
        this.roundState = RoundRun;

        // First tick, condition-eval
        _get(_getPrototypeOf(EventSheet.prototype), "tick", this).call(this, blackboard, target);
        if (startFromTop) {
          var nodeMemory = this.root.getNodeMemory(this.ticker);
          this.conditionPassed = nodeMemory.$runningChild === 0;
        }
        return true;
      }
    }, {
      key: "tick",
      value: function tick(blackboard, target) {
        var state = _get(_getPrototypeOf(EventSheet.prototype), "tick", this).call(this, blackboard, target);
        if (state !== RUNNING$1) {
          // Will remove from pendingTrees
          this.roundState = RoundComplete;
          if (this.conditionPassed && this.properties.once) {
            this.setActive(false);
          }
        }
        return state;
      }
    }, {
      key: "abort",
      value: function abort(blackboard, target) {
        this.roundState = RoundIdle;
        _get(_getPrototypeOf(EventSheet.prototype), "abort", this).call(this, blackboard, target);
      }
    }]);
    return EventSheet;
  }(BehaviorTree);

  var marked_min = {exports: {}};

  (function (module, exports) {
    !function (e, t) {
      t(exports) ;
    }(commonjsGlobal, function (r) {

      function i(e, t) {
        for (var u = 0; u < t.length; u++) {
          var n = t[u];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, function (e) {
            e = function (e, t) {
              if ("object" != _typeof(e) || null === e) return e;
              var u = e[Symbol.toPrimitive];
              if (void 0 === u) return ("string" === t ? String : Number)(e);
              u = u.call(e, t || "default");
              if ("object" != _typeof(u)) return u;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }(e, "string");
            return "symbol" == _typeof(e) ? e : String(e);
          }(n.key), n);
        }
      }
      function d() {
        return (d = Object.assign ? Object.assign.bind() : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var u,
              n = arguments[t];
            for (u in n) Object.prototype.hasOwnProperty.call(n, u) && (e[u] = n[u]);
          }
          return e;
        }).apply(this, arguments);
      }
      function s(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var u = 0, n = new Array(t); u < t; u++) n[u] = e[u];
        return n;
      }
      function D(e, t) {
        var u,
          n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
        if (n) return (n = n.call(e)).next.bind(n);
        if (Array.isArray(e) || (n = function (e, t) {
          var u;
          if (e) return "string" == typeof e ? s(e, t) : "Map" === (u = "Object" === (u = Object.prototype.toString.call(e).slice(8, -1)) && e.constructor ? e.constructor.name : u) || "Set" === u ? Array.from(e) : "Arguments" === u || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u) ? s(e, t) : void 0;
        }(e)) || t && e && "number" == typeof e.length) return n && (e = n), u = 0, function () {
          return u >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[u++]
          };
        };
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function e() {
        return {
          async: !1,
          baseUrl: null,
          breaks: !1,
          extensions: null,
          gfm: !0,
          headerIds: !0,
          headerPrefix: "",
          highlight: null,
          hooks: null,
          langPrefix: "language-",
          mangle: !0,
          pedantic: !1,
          renderer: null,
          sanitize: !1,
          sanitizer: null,
          silent: !1,
          smartypants: !1,
          tokenizer: null,
          walkTokens: null,
          xhtml: !1
        };
      }
      r.defaults = e();
      function u(e) {
        return t[e];
      }
      var n = /[&<>"']/,
        a = new RegExp(n.source, "g"),
        o = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
        l = new RegExp(o.source, "g"),
        t = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
      function A(e, t) {
        if (t) {
          if (n.test(e)) return e.replace(a, u);
        } else if (o.test(e)) return e.replace(l, u);
        return e;
      }
      var c = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
      function m(e) {
        return e.replace(c, function (e, t) {
          return "colon" === (t = t.toLowerCase()) ? ":" : "#" === t.charAt(0) ? "x" === t.charAt(1) ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : "";
        });
      }
      var p = /(^|[^\[])\^/g;
      function h(u, e) {
        u = "string" == typeof u ? u : u.source, e = e || "";
        var n = {
          replace: function replace(e, t) {
            return t = (t = t.source || t).replace(p, "$1"), u = u.replace(e, t), n;
          },
          getRegex: function getRegex() {
            return new RegExp(u, e);
          }
        };
        return n;
      }
      var j = /[^\w:]/g,
        Z = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
      function f(e, t, u) {
        if (e) {
          try {
            n = decodeURIComponent(m(u)).replace(j, "").toLowerCase();
          } catch (e) {
            return null;
          }
          if (0 === n.indexOf("javascript:") || 0 === n.indexOf("vbscript:") || 0 === n.indexOf("data:")) return null;
        }
        var n;
        t && !Z.test(u) && (e = u, g[" " + (n = t)] || (O.test(n) ? g[" " + n] = n + "/" : g[" " + n] = C(n, "/", !0)), t = -1 === (n = g[" " + n]).indexOf(":"), u = "//" === e.substring(0, 2) ? t ? e : n.replace(q, "$1") + e : "/" === e.charAt(0) ? t ? e : n.replace(P, "$1") + e : n + e);
        try {
          u = encodeURI(u).replace(/%25/g, "%");
        } catch (e) {
          return null;
        }
        return u;
      }
      var g = {},
        O = /^[^:]+:\/*[^/]*$/,
        q = /^([^:]+:)[\s\S]*$/,
        P = /^([^:]+:\/*[^/]*)[\s\S]*$/;
      var F = {
        exec: function exec() {}
      };
      function k(e, t) {
        var u = e.replace(/\|/g, function (e, t, u) {
            for (var n = !1, r = t; 0 <= --r && "\\" === u[r];) n = !n;
            return n ? "|" : " |";
          }).split(/ \|/),
          n = 0;
        if (u[0].trim() || u.shift(), 0 < u.length && !u[u.length - 1].trim() && u.pop(), u.length > t) u.splice(t);else for (; u.length < t;) u.push("");
        for (; n < u.length; n++) u[n] = u[n].trim().replace(/\\\|/g, "|");
        return u;
      }
      function C(e, t, u) {
        var n = e.length;
        if (0 === n) return "";
        for (var r = 0; r < n;) {
          var i = e.charAt(n - r - 1);
          if ((i !== t || u) && (i === t || !u)) break;
          r++;
        }
        return e.slice(0, n - r);
      }
      function E(e, t) {
        if (t < 1) return "";
        for (var u = ""; 1 < t;) 1 & t && (u += e), t >>= 1, e += e;
        return u + e;
      }
      function x(e, t, u, n) {
        var r = t.href,
          t = t.title ? A(t.title) : null,
          i = e[1].replace(/\\([\[\]])/g, "$1");
        return "!" !== e[0].charAt(0) ? (n.state.inLink = !0, e = {
          type: "link",
          raw: u,
          href: r,
          title: t,
          text: i,
          tokens: n.inlineTokens(i)
        }, n.state.inLink = !1, e) : {
          type: "image",
          raw: u,
          href: r,
          title: t,
          text: A(i)
        };
      }
      var b = function () {
          function e(e) {
            this.options = e || r.defaults;
          }
          var t = e.prototype;
          return t.space = function (e) {
            e = this.rules.block.newline.exec(e);
            if (e && 0 < e[0].length) return {
              type: "space",
              raw: e[0]
            };
          }, t.code = function (e) {
            var t,
              e = this.rules.block.code.exec(e);
            if (e) return t = e[0].replace(/^ {1,4}/gm, ""), {
              type: "code",
              raw: e[0],
              codeBlockStyle: "indented",
              text: this.options.pedantic ? t : C(t, "\n")
            };
          }, t.fences = function (e) {
            var t,
              u,
              n,
              r,
              e = this.rules.block.fences.exec(e);
            if (e) return t = e[0], u = t, n = e[3] || "", u = null === (u = t.match(/^(\s+)(?:```)/)) ? n : (r = u[1], n.split("\n").map(function (e) {
              var t = e.match(/^\s+/);
              return null !== t && t[0].length >= r.length ? e.slice(r.length) : e;
            }).join("\n")), {
              type: "code",
              raw: t,
              lang: e[2] && e[2].trim().replace(this.rules.inline._escapes, "$1"),
              text: u
            };
          }, t.heading = function (e) {
            var t,
              u,
              e = this.rules.block.heading.exec(e);
            if (e) return t = e[2].trim(), /#$/.test(t) && (u = C(t, "#"), !this.options.pedantic && u && !/ $/.test(u) || (t = u.trim())), {
              type: "heading",
              raw: e[0],
              depth: e[1].length,
              text: t,
              tokens: this.lexer.inline(t)
            };
          }, t.hr = function (e) {
            e = this.rules.block.hr.exec(e);
            if (e) return {
              type: "hr",
              raw: e[0]
            };
          }, t.blockquote = function (e) {
            var t,
              u,
              n,
              e = this.rules.block.blockquote.exec(e);
            if (e) return t = e[0].replace(/^ *>[ \t]?/gm, ""), u = this.lexer.state.top, this.lexer.state.top = !0, n = this.lexer.blockTokens(t), this.lexer.state.top = u, {
              type: "blockquote",
              raw: e[0],
              tokens: n,
              text: t
            };
          }, t.list = function (e) {
            var t = this.rules.block.list.exec(e);
            if (t) {
              var u,
                n,
                r,
                i,
                s,
                a,
                o,
                l,
                D,
                c,
                p,
                h = 1 < (g = t[1].trim()).length,
                f = {
                  type: "list",
                  raw: "",
                  ordered: h,
                  start: h ? +g.slice(0, -1) : "",
                  loose: !1,
                  items: []
                },
                g = h ? "\\d{1,9}\\" + g.slice(-1) : "\\" + g;
              this.options.pedantic && (g = h ? g : "[*+-]");
              for (var F = new RegExp("^( {0,3}" + g + ")((?:[\t ][^\\n]*)?(?:\\n|$))"); e && (p = !1, t = F.exec(e)) && !this.rules.block.hr.test(e);) {
                if (u = t[0], e = e.substring(u.length), o = t[2].split("\n", 1)[0].replace(/^\t+/, function (e) {
                  return " ".repeat(3 * e.length);
                }), l = e.split("\n", 1)[0], this.options.pedantic ? (i = 2, c = o.trimLeft()) : (i = t[2].search(/[^ ]/), c = o.slice(i = 4 < i ? 1 : i), i += t[1].length), s = !1, !o && /^ *$/.test(l) && (u += l + "\n", e = e.substring(l.length + 1), p = !0), !p) for (var d = new RegExp("^ {0," + Math.min(3, i - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))"), A = new RegExp("^ {0," + Math.min(3, i - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"), k = new RegExp("^ {0," + Math.min(3, i - 1) + "}(?:```|~~~)"), C = new RegExp("^ {0," + Math.min(3, i - 1) + "}#"); e && (l = D = e.split("\n", 1)[0], this.options.pedantic && (l = l.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !k.test(l)) && !C.test(l) && !d.test(l) && !A.test(e);) {
                  if (l.search(/[^ ]/) >= i || !l.trim()) c += "\n" + l.slice(i);else {
                    if (s) break;
                    if (4 <= o.search(/[^ ]/)) break;
                    if (k.test(o)) break;
                    if (C.test(o)) break;
                    if (A.test(o)) break;
                    c += "\n" + l;
                  }
                  s || l.trim() || (s = !0), u += D + "\n", e = e.substring(D.length + 1), o = l.slice(i);
                }
                f.loose || (a ? f.loose = !0 : /\n *\n *$/.test(u) && (a = !0)), this.options.gfm && (n = /^\[[ xX]\] /.exec(c)) && (r = "[ ] " !== n[0], c = c.replace(/^\[[ xX]\] +/, "")), f.items.push({
                  type: "list_item",
                  raw: u,
                  task: !!n,
                  checked: r,
                  loose: !1,
                  text: c
                }), f.raw += u;
              }
              f.items[f.items.length - 1].raw = u.trimRight(), f.items[f.items.length - 1].text = c.trimRight(), f.raw = f.raw.trimRight();
              for (var E, m = f.items.length, x = 0; x < m; x++) this.lexer.state.top = !1, f.items[x].tokens = this.lexer.blockTokens(f.items[x].text, []), f.loose || (E = 0 < (E = f.items[x].tokens.filter(function (e) {
                return "space" === e.type;
              })).length && E.some(function (e) {
                return /\n.*\n/.test(e.raw);
              }), f.loose = E);
              if (f.loose) for (x = 0; x < m; x++) f.items[x].loose = !0;
              return f;
            }
          }, t.html = function (e) {
            var t,
              e = this.rules.block.html.exec(e);
            if (e) return t = {
              type: "html",
              block: !0,
              raw: e[0],
              pre: !this.options.sanitizer && ("pre" === e[1] || "script" === e[1] || "style" === e[1]),
              text: e[0]
            }, this.options.sanitize && (e = this.options.sanitizer ? this.options.sanitizer(e[0]) : A(e[0]), t.type = "paragraph", t.text = e, t.tokens = this.lexer.inline(e)), t;
          }, t.def = function (e) {
            var t,
              u,
              n,
              e = this.rules.block.def.exec(e);
            if (e) return t = e[1].toLowerCase().replace(/\s+/g, " "), u = e[2] ? e[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "", n = e[3] && e[3].substring(1, e[3].length - 1).replace(this.rules.inline._escapes, "$1"), {
              type: "def",
              tag: t,
              raw: e[0],
              href: u,
              title: n
            };
          }, t.table = function (e) {
            e = this.rules.block.table.exec(e);
            if (e) {
              var t = {
                type: "table",
                header: k(e[1]).map(function (e) {
                  return {
                    text: e
                  };
                }),
                align: e[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                rows: e[3] && e[3].trim() ? e[3].replace(/\n[ \t]*$/, "").split("\n") : []
              };
              if (t.header.length === t.align.length) {
                t.raw = e[0];
                for (var u, n, r, i = t.align.length, s = 0; s < i; s++) /^ *-+: *$/.test(t.align[s]) ? t.align[s] = "right" : /^ *:-+: *$/.test(t.align[s]) ? t.align[s] = "center" : /^ *:-+ *$/.test(t.align[s]) ? t.align[s] = "left" : t.align[s] = null;
                for (i = t.rows.length, s = 0; s < i; s++) t.rows[s] = k(t.rows[s], t.header.length).map(function (e) {
                  return {
                    text: e
                  };
                });
                for (i = t.header.length, u = 0; u < i; u++) t.header[u].tokens = this.lexer.inline(t.header[u].text);
                for (i = t.rows.length, u = 0; u < i; u++) for (r = t.rows[u], n = 0; n < r.length; n++) r[n].tokens = this.lexer.inline(r[n].text);
                return t;
              }
            }
          }, t.lheading = function (e) {
            e = this.rules.block.lheading.exec(e);
            if (e) return {
              type: "heading",
              raw: e[0],
              depth: "=" === e[2].charAt(0) ? 1 : 2,
              text: e[1],
              tokens: this.lexer.inline(e[1])
            };
          }, t.paragraph = function (e) {
            var t,
              e = this.rules.block.paragraph.exec(e);
            if (e) return t = "\n" === e[1].charAt(e[1].length - 1) ? e[1].slice(0, -1) : e[1], {
              type: "paragraph",
              raw: e[0],
              text: t,
              tokens: this.lexer.inline(t)
            };
          }, t.text = function (e) {
            e = this.rules.block.text.exec(e);
            if (e) return {
              type: "text",
              raw: e[0],
              text: e[0],
              tokens: this.lexer.inline(e[0])
            };
          }, t.escape = function (e) {
            e = this.rules.inline.escape.exec(e);
            if (e) return {
              type: "escape",
              raw: e[0],
              text: A(e[1])
            };
          }, t.tag = function (e) {
            e = this.rules.inline.tag.exec(e);
            if (e) return !this.lexer.state.inLink && /^<a /i.test(e[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(e[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(e[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0]) && (this.lexer.state.inRawBlock = !1), {
              type: this.options.sanitize ? "text" : "html",
              raw: e[0],
              inLink: this.lexer.state.inLink,
              inRawBlock: this.lexer.state.inRawBlock,
              block: !1,
              text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(e[0]) : A(e[0]) : e[0]
            };
          }, t.link = function (e) {
            e = this.rules.inline.link.exec(e);
            if (e) {
              var t = e[2].trim();
              if (!this.options.pedantic && /^</.test(t)) {
                if (!/>$/.test(t)) return;
                var u = C(t.slice(0, -1), "\\");
                if ((t.length - u.length) % 2 == 0) return;
              } else {
                u = function (e, t) {
                  if (-1 !== e.indexOf(t[1])) for (var u = e.length, n = 0, r = 0; r < u; r++) if ("\\" === e[r]) r++;else if (e[r] === t[0]) n++;else if (e[r] === t[1] && --n < 0) return r;
                  return -1;
                }(e[2], "()");
                -1 < u && (r = (0 === e[0].indexOf("!") ? 5 : 4) + e[1].length + u, e[2] = e[2].substring(0, u), e[0] = e[0].substring(0, r).trim(), e[3] = "");
              }
              var n,
                u = e[2],
                r = "";
              return this.options.pedantic ? (n = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(u)) && (u = n[1], r = n[3]) : r = e[3] ? e[3].slice(1, -1) : "", u = u.trim(), x(e, {
                href: (u = /^</.test(u) ? this.options.pedantic && !/>$/.test(t) ? u.slice(1) : u.slice(1, -1) : u) && u.replace(this.rules.inline._escapes, "$1"),
                title: r && r.replace(this.rules.inline._escapes, "$1")
              }, e[0], this.lexer);
            }
          }, t.reflink = function (e, t) {
            var u;
            if (u = (u = this.rules.inline.reflink.exec(e)) || this.rules.inline.nolink.exec(e)) return (e = t[(e = (u[2] || u[1]).replace(/\s+/g, " ")).toLowerCase()]) ? x(u, e, u[0], this.lexer) : {
              type: "text",
              raw: t = u[0].charAt(0),
              text: t
            };
          }, t.emStrong = function (e, t, u) {
            void 0 === u && (u = "");
            var n = this.rules.inline.emStrong.lDelim.exec(e);
            if (n && (!n[3] || !u.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDF50-\uDF59\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEC0-\uDED3\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDCD0-\uDCEB\uDCF0-\uDCF9\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])/))) {
              var r = n[1] || n[2] || "";
              if (!r || "" === u || this.rules.inline.punctuation.exec(u)) {
                var i = n[0].length - 1,
                  s = i,
                  a = 0,
                  o = "*" === n[0][0] ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
                for (o.lastIndex = 0, t = t.slice(-1 * e.length + i); null != (n = o.exec(t));) {
                  var l,
                    D = n[1] || n[2] || n[3] || n[4] || n[5] || n[6];
                  if (D) if (l = D.length, n[3] || n[4]) s += l;else if ((n[5] || n[6]) && i % 3 && !((i + l) % 3)) a += l;else if (!(0 < (s -= l))) return l = Math.min(l, l + s + a), D = e.slice(0, i + n.index + (n[0].length - D.length) + l), Math.min(i, l) % 2 ? (l = D.slice(1, -1), {
                    type: "em",
                    raw: D,
                    text: l,
                    tokens: this.lexer.inlineTokens(l)
                  }) : (l = D.slice(2, -2), {
                    type: "strong",
                    raw: D,
                    text: l,
                    tokens: this.lexer.inlineTokens(l)
                  });
                }
              }
            }
          }, t.codespan = function (e) {
            var t,
              u,
              n,
              e = this.rules.inline.code.exec(e);
            if (e) return n = e[2].replace(/\n/g, " "), t = /[^ ]/.test(n), u = /^ /.test(n) && / $/.test(n), n = A(n = t && u ? n.substring(1, n.length - 1) : n, !0), {
              type: "codespan",
              raw: e[0],
              text: n
            };
          }, t.br = function (e) {
            e = this.rules.inline.br.exec(e);
            if (e) return {
              type: "br",
              raw: e[0]
            };
          }, t.del = function (e) {
            e = this.rules.inline.del.exec(e);
            if (e) return {
              type: "del",
              raw: e[0],
              text: e[2],
              tokens: this.lexer.inlineTokens(e[2])
            };
          }, t.autolink = function (e, t) {
            var u,
              e = this.rules.inline.autolink.exec(e);
            if (e) return t = "@" === e[2] ? "mailto:" + (u = A(this.options.mangle ? t(e[1]) : e[1])) : u = A(e[1]), {
              type: "link",
              raw: e[0],
              text: u,
              href: t,
              tokens: [{
                type: "text",
                raw: u,
                text: u
              }]
            };
          }, t.url = function (e, t) {
            var u, n, r, i;
            if (u = this.rules.inline.url.exec(e)) {
              if ("@" === u[2]) r = "mailto:" + (n = A(this.options.mangle ? t(u[0]) : u[0]));else {
                for (; i = u[0], u[0] = this.rules.inline._backpedal.exec(u[0])[0], i !== u[0];);
                n = A(u[0]), r = "www." === u[1] ? "http://" + u[0] : u[0];
              }
              return {
                type: "link",
                raw: u[0],
                text: n,
                href: r,
                tokens: [{
                  type: "text",
                  raw: n,
                  text: n
                }]
              };
            }
          }, t.inlineText = function (e, t) {
            e = this.rules.inline.text.exec(e);
            if (e) return t = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(e[0]) : A(e[0]) : e[0] : A(this.options.smartypants ? t(e[0]) : e[0]), {
              type: "text",
              raw: e[0],
              text: t
            };
          }, e;
        }(),
        B = {
          newline: /^(?: *(?:\n|$))+/,
          code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
          fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
          hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
          heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
          blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
          list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
          html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
          def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
          table: F,
          lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
          _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
          text: /^[^\n]+/,
          _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/,
          _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/
        },
        w = (B.def = h(B.def).replace("label", B._label).replace("title", B._title).getRegex(), B.bullet = /(?:[*+-]|\d{1,9}[.)])/, B.listItemStart = h(/^( *)(bull) */).replace("bull", B.bullet).getRegex(), B.list = h(B.list).replace(/bull/g, B.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + B.def.source + ")").getRegex(), B._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", B._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, B.html = h(B.html, "i").replace("comment", B._comment).replace("tag", B._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), B.paragraph = h(B._paragraph).replace("hr", B.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", B._tag).getRegex(), B.blockquote = h(B.blockquote).replace("paragraph", B.paragraph).getRegex(), B.normal = d({}, B), B.gfm = d({}, B.normal, {
          table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
        }), B.gfm.table = h(B.gfm.table).replace("hr", B.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", B._tag).getRegex(), B.gfm.paragraph = h(B._paragraph).replace("hr", B.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", B.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", B._tag).getRegex(), B.pedantic = d({}, B.normal, {
          html: h("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment", B._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
          def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
          heading: /^(#{1,6})(.*)(?:\n+|$)/,
          fences: F,
          lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
          paragraph: h(B.normal._paragraph).replace("hr", B.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", B.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
        }), {
          escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
          autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
          url: F,
          tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
          link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
          reflink: /^!?\[(label)\]\[(ref)\]/,
          nolink: /^!?\[(ref)\](?:\[\])?/,
          reflinkSearch: "reflink|nolink(?!\\()",
          emStrong: {
            lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
            rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
            rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
          },
          code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
          br: /^( {2,}|\\)\n(?!\s*$)/,
          del: F,
          text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
          punctuation: /^([\spunctuation])/
        });
      function L(e) {
        return e.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
      }
      function v(e) {
        for (var t, u = "", n = e.length, r = 0; r < n; r++) t = e.charCodeAt(r), u += "&#" + (t = .5 < Math.random() ? "x" + t.toString(16) : t) + ";";
        return u;
      }
      w._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", w.punctuation = h(w.punctuation).replace(/punctuation/g, w._punctuation).getRegex(), w.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, w.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g, w._comment = h(B._comment).replace("(?:--\x3e|$)", "--\x3e").getRegex(), w.emStrong.lDelim = h(w.emStrong.lDelim).replace(/punct/g, w._punctuation).getRegex(), w.emStrong.rDelimAst = h(w.emStrong.rDelimAst, "g").replace(/punct/g, w._punctuation).getRegex(), w.emStrong.rDelimUnd = h(w.emStrong.rDelimUnd, "g").replace(/punct/g, w._punctuation).getRegex(), w._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, w._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, w._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, w.autolink = h(w.autolink).replace("scheme", w._scheme).replace("email", w._email).getRegex(), w._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, w.tag = h(w.tag).replace("comment", w._comment).replace("attribute", w._attribute).getRegex(), w._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, w._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, w._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, w.link = h(w.link).replace("label", w._label).replace("href", w._href).replace("title", w._title).getRegex(), w.reflink = h(w.reflink).replace("label", w._label).replace("ref", B._label).getRegex(), w.nolink = h(w.nolink).replace("ref", B._label).getRegex(), w.reflinkSearch = h(w.reflinkSearch, "g").replace("reflink", w.reflink).replace("nolink", w.nolink).getRegex(), w.normal = d({}, w), w.pedantic = d({}, w.normal, {
        strong: {
          start: /^__|\*\*/,
          middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
          endAst: /\*\*(?!\*)/g,
          endUnd: /__(?!_)/g
        },
        em: {
          start: /^_|\*/,
          middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
          endAst: /\*(?!\*)/g,
          endUnd: /_(?!_)/g
        },
        link: h(/^!?\[(label)\]\((.*?)\)/).replace("label", w._label).getRegex(),
        reflink: h(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", w._label).getRegex()
      }), w.gfm = d({}, w.normal, {
        escape: h(w.escape).replace("])", "~|])").getRegex(),
        _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
        url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
        _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
      }), w.gfm.url = h(w.gfm.url, "i").replace("email", w.gfm._extended_email).getRegex(), w.breaks = d({}, w.gfm, {
        br: h(w.br).replace("{2,}", "*").getRegex(),
        text: h(w.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
      });
      var y = function () {
          function u(e) {
            this.tokens = [], this.tokens.links = Object.create(null), this.options = e || r.defaults, this.options.tokenizer = this.options.tokenizer || new b(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, (this.tokenizer.lexer = this).inlineQueue = [], this.state = {
              inLink: !1,
              inRawBlock: !1,
              top: !0
            };
            e = {
              block: B.normal,
              inline: w.normal
            };
            this.options.pedantic ? (e.block = B.pedantic, e.inline = w.pedantic) : this.options.gfm && (e.block = B.gfm, this.options.breaks ? e.inline = w.breaks : e.inline = w.gfm), this.tokenizer.rules = e;
          }
          u.lex = function (e, t) {
            return new u(t).lex(e);
          }, u.lexInline = function (e, t) {
            return new u(t).inlineTokens(e);
          };
          var e,
            t,
            n = u.prototype;
          return n.lex = function (e) {
            var t;
            for (e = e.replace(/\r\n|\r/g, "\n"), this.blockTokens(e, this.tokens); t = this.inlineQueue.shift();) this.inlineTokens(t.src, t.tokens);
            return this.tokens;
          }, n.blockTokens = function (r, i) {
            var s,
              a,
              o,
              l,
              D = this;
            for (void 0 === i && (i = []), r = this.options.pedantic ? r.replace(/\t/g, "    ").replace(/^ +$/gm, "") : r.replace(/^( *)(\t+)/gm, function (e, t, u) {
              return t + "    ".repeat(u.length);
            }); r;) {
              var e = function () {
                if (D.options.extensions && D.options.extensions.block && D.options.extensions.block.some(function (e) {
                  return !!(s = e.call({
                    lexer: D
                  }, r, i)) && (r = r.substring(s.raw.length), i.push(s), !0);
                })) return "continue";
                if (s = D.tokenizer.space(r)) return r = r.substring(s.raw.length), 1 === s.raw.length && 0 < i.length ? i[i.length - 1].raw += "\n" : i.push(s), "continue";
                if (s = D.tokenizer.code(r)) return r = r.substring(s.raw.length), !(a = i[i.length - 1]) || "paragraph" !== a.type && "text" !== a.type ? i.push(s) : (a.raw += "\n" + s.raw, a.text += "\n" + s.text, D.inlineQueue[D.inlineQueue.length - 1].src = a.text), "continue";
                if (s = D.tokenizer.fences(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = D.tokenizer.heading(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = D.tokenizer.hr(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = D.tokenizer.blockquote(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = D.tokenizer.list(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = D.tokenizer.html(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = D.tokenizer.def(r)) return r = r.substring(s.raw.length), !(a = i[i.length - 1]) || "paragraph" !== a.type && "text" !== a.type ? D.tokens.links[s.tag] || (D.tokens.links[s.tag] = {
                  href: s.href,
                  title: s.title
                }) : (a.raw += "\n" + s.raw, a.text += "\n" + s.raw, D.inlineQueue[D.inlineQueue.length - 1].src = a.text), "continue";
                if (s = D.tokenizer.table(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = D.tokenizer.lheading(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                var t, u, n;
                if (o = r, D.options.extensions && D.options.extensions.startBlock && (t = 1 / 0, u = r.slice(1), D.options.extensions.startBlock.forEach(function (e) {
                  "number" == typeof (n = e.call({
                    lexer: this
                  }, u)) && 0 <= n && (t = Math.min(t, n));
                }), t < 1 / 0) && 0 <= t && (o = r.substring(0, t + 1)), D.state.top && (s = D.tokenizer.paragraph(o))) return a = i[i.length - 1], l && "paragraph" === a.type ? (a.raw += "\n" + s.raw, a.text += "\n" + s.text, D.inlineQueue.pop(), D.inlineQueue[D.inlineQueue.length - 1].src = a.text) : i.push(s), l = o.length !== r.length, r = r.substring(s.raw.length), "continue";
                if (s = D.tokenizer.text(r)) return r = r.substring(s.raw.length), (a = i[i.length - 1]) && "text" === a.type ? (a.raw += "\n" + s.raw, a.text += "\n" + s.text, D.inlineQueue.pop(), D.inlineQueue[D.inlineQueue.length - 1].src = a.text) : i.push(s), "continue";
                if (r) {
                  var e = "Infinite loop on byte: " + r.charCodeAt(0);
                  if (D.options.silent) return console.error(e), "break";
                  throw new Error(e);
                }
              }();
              if ("continue" !== e && "break" === e) break;
            }
            return this.state.top = !0, i;
          }, n.inline = function (e, t) {
            return this.inlineQueue.push({
              src: e,
              tokens: t = void 0 === t ? [] : t
            }), t;
          }, n.inlineTokens = function (r, i) {
            var s,
              a,
              o,
              e,
              l,
              D,
              c = this,
              p = (void 0 === i && (i = []), r);
            if (this.tokens.links) {
              var t = Object.keys(this.tokens.links);
              if (0 < t.length) for (; null != (e = this.tokenizer.rules.inline.reflinkSearch.exec(p));) t.includes(e[0].slice(e[0].lastIndexOf("[") + 1, -1)) && (p = p.slice(0, e.index) + "[" + E("a", e[0].length - 2) + "]" + p.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
            }
            for (; null != (e = this.tokenizer.rules.inline.blockSkip.exec(p));) p = p.slice(0, e.index) + "[" + E("a", e[0].length - 2) + "]" + p.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            for (; null != (e = this.tokenizer.rules.inline.escapedEmSt.exec(p));) p = p.slice(0, e.index + e[0].length - 2) + "++" + p.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex), this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
            for (; r;) {
              var u = function () {
                if (l || (D = ""), l = !1, c.options.extensions && c.options.extensions.inline && c.options.extensions.inline.some(function (e) {
                  return !!(s = e.call({
                    lexer: c
                  }, r, i)) && (r = r.substring(s.raw.length), i.push(s), !0);
                })) return "continue";
                if (s = c.tokenizer.escape(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = c.tokenizer.tag(r)) return r = r.substring(s.raw.length), (a = i[i.length - 1]) && "text" === s.type && "text" === a.type ? (a.raw += s.raw, a.text += s.text) : i.push(s), "continue";
                if (s = c.tokenizer.link(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = c.tokenizer.reflink(r, c.tokens.links)) return r = r.substring(s.raw.length), (a = i[i.length - 1]) && "text" === s.type && "text" === a.type ? (a.raw += s.raw, a.text += s.text) : i.push(s), "continue";
                if (s = c.tokenizer.emStrong(r, p, D)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = c.tokenizer.codespan(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = c.tokenizer.br(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = c.tokenizer.del(r)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (s = c.tokenizer.autolink(r, v)) return r = r.substring(s.raw.length), i.push(s), "continue";
                if (!c.state.inLink && (s = c.tokenizer.url(r, v))) return r = r.substring(s.raw.length), i.push(s), "continue";
                var t, u, n;
                if (o = r, c.options.extensions && c.options.extensions.startInline && (t = 1 / 0, u = r.slice(1), c.options.extensions.startInline.forEach(function (e) {
                  "number" == typeof (n = e.call({
                    lexer: this
                  }, u)) && 0 <= n && (t = Math.min(t, n));
                }), t < 1 / 0) && 0 <= t && (o = r.substring(0, t + 1)), s = c.tokenizer.inlineText(o, L)) return r = r.substring(s.raw.length), "_" !== s.raw.slice(-1) && (D = s.raw.slice(-1)), l = !0, (a = i[i.length - 1]) && "text" === a.type ? (a.raw += s.raw, a.text += s.text) : i.push(s), "continue";
                if (r) {
                  var e = "Infinite loop on byte: " + r.charCodeAt(0);
                  if (c.options.silent) return console.error(e), "break";
                  throw new Error(e);
                }
              }();
              if ("continue" !== u && "break" === u) break;
            }
            return i;
          }, n = u, t = [{
            key: "rules",
            get: function get() {
              return {
                block: B,
                inline: w
              };
            }
          }], (e = null) && i(n.prototype, e), t && i(n, t), Object.defineProperty(n, "prototype", {
            writable: !1
          }), u;
        }(),
        _ = function () {
          function e(e) {
            this.options = e || r.defaults;
          }
          var t = e.prototype;
          return t.code = function (e, t, u) {
            var n,
              t = (t || "").match(/\S*/)[0];
            return this.options.highlight && null != (n = this.options.highlight(e, t)) && n !== e && (u = !0, e = n), e = e.replace(/\n$/, "") + "\n", t ? '<pre><code class="' + this.options.langPrefix + A(t) + '">' + (u ? e : A(e, !0)) + "</code></pre>\n" : "<pre><code>" + (u ? e : A(e, !0)) + "</code></pre>\n";
          }, t.blockquote = function (e) {
            return "<blockquote>\n" + e + "</blockquote>\n";
          }, t.html = function (e, t) {
            return e;
          }, t.heading = function (e, t, u, n) {
            return this.options.headerIds ? "<h" + t + ' id="' + (this.options.headerPrefix + n.slug(u)) + '">' + e + "</h" + t + ">\n" : "<h" + t + ">" + e + "</h" + t + ">\n";
          }, t.hr = function () {
            return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
          }, t.list = function (e, t, u) {
            var n = t ? "ol" : "ul";
            return "<" + n + (t && 1 !== u ? ' start="' + u + '"' : "") + ">\n" + e + "</" + n + ">\n";
          }, t.listitem = function (e) {
            return "<li>" + e + "</li>\n";
          }, t.checkbox = function (e) {
            return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
          }, t.paragraph = function (e) {
            return "<p>" + e + "</p>\n";
          }, t.table = function (e, t) {
            return "<table>\n<thead>\n" + e + "</thead>\n" + (t = t && "<tbody>" + t + "</tbody>") + "</table>\n";
          }, t.tablerow = function (e) {
            return "<tr>\n" + e + "</tr>\n";
          }, t.tablecell = function (e, t) {
            var u = t.header ? "th" : "td";
            return (t.align ? "<" + u + ' align="' + t.align + '">' : "<" + u + ">") + e + "</" + u + ">\n";
          }, t.strong = function (e) {
            return "<strong>" + e + "</strong>";
          }, t.em = function (e) {
            return "<em>" + e + "</em>";
          }, t.codespan = function (e) {
            return "<code>" + e + "</code>";
          }, t.br = function () {
            return this.options.xhtml ? "<br/>" : "<br>";
          }, t.del = function (e) {
            return "<del>" + e + "</del>";
          }, t.link = function (e, t, u) {
            return null === (e = f(this.options.sanitize, this.options.baseUrl, e)) ? u : (e = '<a href="' + e + '"', t && (e += ' title="' + t + '"'), e + ">" + u + "</a>");
          }, t.image = function (e, t, u) {
            return null === (e = f(this.options.sanitize, this.options.baseUrl, e)) ? u : (e = '<img src="' + e + '" alt="' + u + '"', t && (e += ' title="' + t + '"'), e + (this.options.xhtml ? "/>" : ">"));
          }, t.text = function (e) {
            return e;
          }, e;
        }(),
        z = function () {
          function e() {}
          var t = e.prototype;
          return t.strong = function (e) {
            return e;
          }, t.em = function (e) {
            return e;
          }, t.codespan = function (e) {
            return e;
          }, t.del = function (e) {
            return e;
          }, t.html = function (e) {
            return e;
          }, t.text = function (e) {
            return e;
          }, t.link = function (e, t, u) {
            return "" + u;
          }, t.image = function (e, t, u) {
            return "" + u;
          }, t.br = function () {
            return "";
          }, e;
        }(),
        $ = function () {
          function e() {
            this.seen = {};
          }
          var t = e.prototype;
          return t.serialize = function (e) {
            return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
          }, t.getNextSafeSlug = function (e, t) {
            var u = e,
              n = 0;
            if (this.seen.hasOwnProperty(u)) for (n = this.seen[e]; u = e + "-" + ++n, this.seen.hasOwnProperty(u););
            return t || (this.seen[e] = n, this.seen[u] = 0), u;
          }, t.slug = function (e, t) {
            void 0 === t && (t = {});
            e = this.serialize(e);
            return this.getNextSafeSlug(e, t.dryrun);
          }, e;
        }(),
        S = function () {
          function u(e) {
            this.options = e || r.defaults, this.options.renderer = this.options.renderer || new _(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new z(), this.slugger = new $();
          }
          u.parse = function (e, t) {
            return new u(t).parse(e);
          }, u.parseInline = function (e, t) {
            return new u(t).parseInline(e);
          };
          var e = u.prototype;
          return e.parse = function (e, t) {
            void 0 === t && (t = !0);
            for (var u, n, r, i, s, a, o, l, D, c, p, h, f, g, F, d, A = "", k = e.length, C = 0; C < k; C++) if (l = e[C], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[l.type] && (!1 !== (d = this.options.extensions.renderers[l.type].call({
              parser: this
            }, l)) || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(l.type))) A += d || "";else switch (l.type) {
              case "space":
                continue;
              case "hr":
                A += this.renderer.hr();
                continue;
              case "heading":
                A += this.renderer.heading(this.parseInline(l.tokens), l.depth, m(this.parseInline(l.tokens, this.textRenderer)), this.slugger);
                continue;
              case "code":
                A += this.renderer.code(l.text, l.lang, l.escaped);
                continue;
              case "table":
                for (a = D = "", r = l.header.length, u = 0; u < r; u++) a += this.renderer.tablecell(this.parseInline(l.header[u].tokens), {
                  header: !0,
                  align: l.align[u]
                });
                for (D += this.renderer.tablerow(a), o = "", r = l.rows.length, u = 0; u < r; u++) {
                  for (a = "", i = (s = l.rows[u]).length, n = 0; n < i; n++) a += this.renderer.tablecell(this.parseInline(s[n].tokens), {
                    header: !1,
                    align: l.align[n]
                  });
                  o += this.renderer.tablerow(a);
                }
                A += this.renderer.table(D, o);
                continue;
              case "blockquote":
                o = this.parse(l.tokens), A += this.renderer.blockquote(o);
                continue;
              case "list":
                for (D = l.ordered, E = l.start, c = l.loose, r = l.items.length, o = "", u = 0; u < r; u++) f = (h = l.items[u]).checked, g = h.task, p = "", h.task && (F = this.renderer.checkbox(f), c ? 0 < h.tokens.length && "paragraph" === h.tokens[0].type ? (h.tokens[0].text = F + " " + h.tokens[0].text, h.tokens[0].tokens && 0 < h.tokens[0].tokens.length && "text" === h.tokens[0].tokens[0].type && (h.tokens[0].tokens[0].text = F + " " + h.tokens[0].tokens[0].text)) : h.tokens.unshift({
                  type: "text",
                  text: F
                }) : p += F), p += this.parse(h.tokens, c), o += this.renderer.listitem(p, g, f);
                A += this.renderer.list(o, D, E);
                continue;
              case "html":
                A += this.renderer.html(l.text, l.block);
                continue;
              case "paragraph":
                A += this.renderer.paragraph(this.parseInline(l.tokens));
                continue;
              case "text":
                for (o = l.tokens ? this.parseInline(l.tokens) : l.text; C + 1 < k && "text" === e[C + 1].type;) o += "\n" + ((l = e[++C]).tokens ? this.parseInline(l.tokens) : l.text);
                A += t ? this.renderer.paragraph(o) : o;
                continue;
              default:
                var E = 'Token with "' + l.type + '" type was not found.';
                if (this.options.silent) return void console.error(E);
                throw new Error(E);
            }
            return A;
          }, e.parseInline = function (e, t) {
            t = t || this.renderer;
            for (var u, n, r = "", i = e.length, s = 0; s < i; s++) if (u = e[s], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[u.type] && (!1 !== (n = this.options.extensions.renderers[u.type].call({
              parser: this
            }, u)) || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(u.type))) r += n || "";else switch (u.type) {
              case "escape":
                r += t.text(u.text);
                break;
              case "html":
                r += t.html(u.text);
                break;
              case "link":
                r += t.link(u.href, u.title, this.parseInline(u.tokens, t));
                break;
              case "image":
                r += t.image(u.href, u.title, u.text);
                break;
              case "strong":
                r += t.strong(this.parseInline(u.tokens, t));
                break;
              case "em":
                r += t.em(this.parseInline(u.tokens, t));
                break;
              case "codespan":
                r += t.codespan(u.text);
                break;
              case "br":
                r += t.br();
                break;
              case "del":
                r += t.del(this.parseInline(u.tokens, t));
                break;
              case "text":
                r += t.text(u.text);
                break;
              default:
                var a = 'Token with "' + u.type + '" type was not found.';
                if (this.options.silent) return void console.error(a);
                throw new Error(a);
            }
            return r;
          }, u;
        }(),
        T = function () {
          function e(e) {
            this.options = e || r.defaults;
          }
          var t = e.prototype;
          return t.preprocess = function (e) {
            return e;
          }, t.postprocess = function (e) {
            return e;
          }, e;
        }();
      function R(g, F) {
        return function (e, u, n) {
          "function" == typeof u && (n = u, u = null);
          var r,
            i,
            s,
            t,
            a = d({}, u),
            o = (u = d({}, I.defaults, a), r = u.silent, i = u.async, s = n, function (e) {
              var t;
              if (e.message += "\nPlease report this to https://github.com/markedjs/marked.", r) return t = "<p>An error occurred:</p><pre>" + A(e.message + "", !0) + "</pre>", i ? Promise.resolve(t) : s ? void s(null, t) : t;
              if (i) return Promise.reject(e);
              if (!s) throw e;
              s(e);
            });
          if (null == e) return o(new Error("marked(): input parameter is undefined or null"));
          if ("string" != typeof e) return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"));
          if (a = n, (t = u) && !t.silent && (a && console.warn("marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async"), (t.sanitize || t.sanitizer) && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options"), !t.highlight && "language-" === t.langPrefix || console.warn("marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight."), t.mangle && console.warn("marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`."), t.baseUrl && console.warn("marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url."), t.smartypants && console.warn("marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants."), t.xhtml && console.warn("marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml."), t.headerIds || t.headerPrefix) && console.warn("marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`."), u.hooks && (u.hooks.options = u), n) {
            var l,
              D = u.highlight;
            try {
              u.hooks && (e = u.hooks.preprocess(e)), l = g(e, u);
            } catch (e) {
              return o(e);
            }
            var c,
              p = function p(t) {
                var e;
                if (!t) try {
                  u.walkTokens && I.walkTokens(l, u.walkTokens), e = F(l, u), u.hooks && (e = u.hooks.postprocess(e));
                } catch (e) {
                  t = e;
                }
                return u.highlight = D, t ? o(t) : n(null, e);
              };
            return !D || D.length < 3 ? p() : (delete u.highlight, l.length ? (c = 0, I.walkTokens(l, function (u) {
              "code" === u.type && (c++, setTimeout(function () {
                D(u.text, u.lang, function (e, t) {
                  if (e) return p(e);
                  null != t && t !== u.text && (u.text = t, u.escaped = !0), 0 === --c && p();
                });
              }, 0));
            }), void (0 === c && p())) : p());
          }
          if (u.async) return Promise.resolve(u.hooks ? u.hooks.preprocess(e) : e).then(function (e) {
            return g(e, u);
          }).then(function (e) {
            return u.walkTokens ? Promise.all(I.walkTokens(e, u.walkTokens)).then(function () {
              return e;
            }) : e;
          }).then(function (e) {
            return F(e, u);
          }).then(function (e) {
            return u.hooks ? u.hooks.postprocess(e) : e;
          })["catch"](o);
          try {
            u.hooks && (e = u.hooks.preprocess(e));
            var h = g(e, u),
              f = (u.walkTokens && I.walkTokens(h, u.walkTokens), F(h, u));
            return f = u.hooks ? u.hooks.postprocess(f) : f;
          } catch (e) {
            return o(e);
          }
        };
      }
      function I(e, t, u) {
        return R(y.lex, S.parse)(e, t, u);
      }
      T.passThroughHooks = new Set(["preprocess", "postprocess"]), I.options = I.setOptions = function (e) {
        return I.defaults = d({}, I.defaults, e), e = I.defaults, r.defaults = e, I;
      }, I.getDefaults = e, I.defaults = r.defaults, I.use = function () {
        for (var D = I.defaults.extensions || {
            renderers: {},
            childTokens: {}
          }, e = arguments.length, t = new Array(e), u = 0; u < e; u++) t[u] = arguments[u];
        t.forEach(function (s) {
          var u,
            e = d({}, s);
          if (e.async = I.defaults.async || e.async || !1, s.extensions && (s.extensions.forEach(function (r) {
            if (!r.name) throw new Error("extension name required");
            var i;
            if (r.renderer && (i = D.renderers[r.name], D.renderers[r.name] = i ? function () {
              for (var e = arguments.length, t = new Array(e), u = 0; u < e; u++) t[u] = arguments[u];
              var n = r.renderer.apply(this, t);
              return n = !1 === n ? i.apply(this, t) : n;
            } : r.renderer), r.tokenizer) {
              if (!r.level || "block" !== r.level && "inline" !== r.level) throw new Error("extension level must be 'block' or 'inline'");
              D[r.level] ? D[r.level].unshift(r.tokenizer) : D[r.level] = [r.tokenizer], r.start && ("block" === r.level ? D.startBlock ? D.startBlock.push(r.start) : D.startBlock = [r.start] : "inline" === r.level && (D.startInline ? D.startInline.push(r.start) : D.startInline = [r.start]));
            }
            r.childTokens && (D.childTokens[r.name] = r.childTokens);
          }), e.extensions = D), s.renderer) {
            var t,
              a = I.defaults.renderer || new _();
            for (t in s.renderer) !function (r) {
              var i = a[r];
              a[r] = function () {
                for (var e = arguments.length, t = new Array(e), u = 0; u < e; u++) t[u] = arguments[u];
                var n = s.renderer[r].apply(a, t);
                return n = !1 === n ? i.apply(a, t) : n;
              };
            }(t);
            e.renderer = a;
          }
          if (s.tokenizer) {
            var n,
              o = I.defaults.tokenizer || new b();
            for (n in s.tokenizer) !function (r) {
              var i = o[r];
              o[r] = function () {
                for (var e = arguments.length, t = new Array(e), u = 0; u < e; u++) t[u] = arguments[u];
                var n = s.tokenizer[r].apply(o, t);
                return n = !1 === n ? i.apply(o, t) : n;
              };
            }(n);
            e.tokenizer = o;
          }
          if (s.hooks) {
            var r,
              l = I.defaults.hooks || new T();
            for (r in s.hooks) !function (r) {
              var i = l[r];
              T.passThroughHooks.has(r) ? l[r] = function (e) {
                return I.defaults.async ? Promise.resolve(s.hooks[r].call(l, e)).then(function (e) {
                  return i.call(l, e);
                }) : (e = s.hooks[r].call(l, e), i.call(l, e));
              } : l[r] = function () {
                for (var e = arguments.length, t = new Array(e), u = 0; u < e; u++) t[u] = arguments[u];
                var n = s.hooks[r].apply(l, t);
                return n = !1 === n ? i.apply(l, t) : n;
              };
            }(r);
            e.hooks = l;
          }
          s.walkTokens && (u = I.defaults.walkTokens, e.walkTokens = function (e) {
            var t = [];
            return t.push(s.walkTokens.call(this, e)), t = u ? t.concat(u.call(this, e)) : t;
          }), I.setOptions(e);
        });
      }, I.walkTokens = function (e, a) {
        for (var o, l = [], t = D(e); !(o = t()).done;) !function () {
          var t = o.value;
          switch (l = l.concat(a.call(I, t)), t.type) {
            case "table":
              for (var e = D(t.header); !(u = e()).done;) {
                var u = u.value;
                l = l.concat(I.walkTokens(u.tokens, a));
              }
              for (var n, r = D(t.rows); !(n = r()).done;) for (var i = D(n.value); !(s = i()).done;) {
                var s = s.value;
                l = l.concat(I.walkTokens(s.tokens, a));
              }
              break;
            case "list":
              l = l.concat(I.walkTokens(t.items, a));
              break;
            default:
              I.defaults.extensions && I.defaults.extensions.childTokens && I.defaults.extensions.childTokens[t.type] ? I.defaults.extensions.childTokens[t.type].forEach(function (e) {
                l = l.concat(I.walkTokens(t[e], a));
              }) : t.tokens && (l = l.concat(I.walkTokens(t.tokens, a)));
          }
        }();
        return l;
      }, I.parseInline = R(y.lexInline, S.parseInline), I.Parser = S, I.parser = S.parse, I.Renderer = _, I.TextRenderer = z, I.Lexer = y, I.lexer = y.lex, I.Tokenizer = b, I.Slugger = $, I.Hooks = T;
      var F = (I.parse = I).options,
        U = I.setOptions,
        Q = I.use,
        M = I.walkTokens,
        N = I.parseInline,
        H = I,
        X = S.parse,
        G = y.lex;
      r.Hooks = T, r.Lexer = y, r.Parser = S, r.Renderer = _, r.Slugger = $, r.TextRenderer = z, r.Tokenizer = b, r.getDefaults = e, r.lexer = G, r.marked = I, r.options = F, r.parse = H, r.parseInline = N, r.parser = X, r.setOptions = U, r.use = Q, r.walkTokens = M;
    });
  })(marked_min, marked_min.exports);
  var marked_minExports = marked_min.exports;
  var marked = /*@__PURE__*/getDefaultExportFromCjs(marked_minExports);

  var GetHeadingTree = function GetHeadingTree(text) {
    var items = marked.lexer(text);
    var eventsheet = null;
    var parents = [];
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      switch (item.type) {
        case 'heading':
          var level = item.depth - 1;
          // First node
          if (eventsheet === null) {
            if (level === 0) {
              var node = CreateNewNode(item.text);
              parents.push(node);
              eventsheet = node;
            }
            // Ignore items if eventsheet is null
          } else {
            if (level <= parents.length) {
              var node = CreateNewNode(item.text);
              parents.length = level;
              var lastNode = parents[parents.length - 1];
              lastNode.children.push(node);
              parents.push(node);
            }
            // Ignore items if out of parents
          }
          break;
        case 'paragraph':
        case 'code':
          if (parents.length === 0) {
            continue;
          }
          // Append raw to last-node
          var lastNode = parents[parents.length - 1];
          var node = {
            text: item.text
          };
          if (item.lang) {
            node.block = item.lang;
          }
          lastNode.paragraphs.push(node);
          break;

        // Ignore other kinds of items
      }
    }
    return eventsheet;
  };
  var CreateNewNode = function CreateNewNode(title) {
    return {
      title: title,
      paragraphs: [],
      children: []
    };
  };

  var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
  var HEX = /^0x[0-9A-F]+$/i;
  var TypeConvert = function TypeConvert(s) {
    if (typeof s !== 'string') {
      return s;
    }
    if (s === '') {
      s = null;
    } else if (FLOAT.test(s)) {
      s = parseFloat(s);
    } else if (HEX.test(s)) {
      s = parseInt(s, 16);
    } else {
      switch (s) {
        case 'false':
          s = false;
          break;
        case 'true':
          s = true;
          break;
        case 'null':
          s = null;
          break;
        case 'undefined':
          s = undefined;
          break;
      }
    }
    return s;
  };

  var ParseProperty = function ParseProperty(s, out) {
    var index = s.indexOf('=');
    if (index === -1) {
      out[s] = true;
    } else {
      var name = s.substring(0, index);
      var expression = s.substring(index + 1);
      out[name] = TypeConvert(expression);
    }
    return out;
  };

  var GetTreeConfig = function GetTreeConfig(paragraphs, commentLineStart) {
    // TODO: YAML format? 
    var config = {};
    paragraphs.forEach(function (paragraph) {
      var lines = paragraph.text.split('\n');
      lines.forEach(function (line) {
        if (line.startsWith(commentLineStart)) {
          return;
        }
        ParseProperty(line, config);
      });
    });
    return config;
  };

  var TopLevelCommandTypes = [{
    name: 'condition'
  }, {
    name: 'catch'
  }];
  var HeadingCommand = [{
    name: 'if',
    pattern: new RegExp('^if\\s*(.*)', 'i')
  }, {
    name: 'else'
  }, {
    name: 'else if',
    pattern: new RegExp('^else if\\s*(.*)', 'i')
  }, {
    name: 'while',
    pattern: new RegExp('^while\\s*(.*)', 'i')
  }, {
    name: 'repeat',
    pattern: new RegExp('^repeat\\s*(.*)', 'i')
  }];
  var ActionCommandTypes = [{
    name: 'exit'
  }, {
    name: 'break'
  }, {
    name: 'next round',
    pattern: new RegExp('^next\\s*(.*)\\s*round', 'i')
  }, {
    name: 'activate',
    pattern: new RegExp('^activate\\s*(.*)', 'i')
  }, {
    name: 'deactivate',
    pattern: new RegExp('^deactivate\\s*(.*)', 'i')
  }];

  var ParseType = function ParseType(s, patterns) {
    s = s.trim();
    if (s[0] === '[' && s[s.length - 1] === ']') {
      s = s.substring(1, s.length - 1);
      var lowCaseString = s.toLowerCase();
      for (var i = 0, cnt = patterns.length; i < cnt; i++) {
        var pattern = patterns[i];
        var patternName = pattern.name;
        var testPattern = pattern.pattern;
        if (testPattern) {
          var result = s.match(testPattern);
          if (result) {
            return {
              type: patternName,
              match: result
            };
          }
        } else if (patternName === lowCaseString) {
          return {
            type: patternName
          };
        }
      }
    }
    return null;
  };

  var STATE_CONDITION = 1;
  var STATE_TASK = 2;
  var STATE_CATCH = 3;
  var ParseTopLevelNodes = function ParseTopLevelNodes(nodes) {
    var conditionNodes = [];
    var mainTaskNodes = [];
    var catchNodes = [];
    var state = STATE_CONDITION;
    var result = ParseType(nodes[0].title, TopLevelCommandTypes);
    var nextNodeType = result ? result.type : '';
    for (var i = 0, cnt = nodes.length; i < cnt; i++) {
      var node = nodes[i];
      if (state === STATE_CONDITION) {
        if (nextNodeType === '') {
          state = STATE_TASK;
        } else if (nextNodeType === 'catch') {
          state = STATE_CATCH;
        }
      } else if (state === STATE_TASK) {
        if (nextNodeType === 'catch') {
          state = STATE_CATCH;
        }
      }
      switch (state) {
        case STATE_CONDITION:
          conditionNodes.push(node);
          break;
        case STATE_TASK:
          mainTaskNodes.push(node);
          break;
        case STATE_CATCH:
          catchNodes.push(node);
          break;
      }
      if (i + 1 < cnt) {
        result = ParseType(nodes[i + 1].title, TopLevelCommandTypes);
        nextNodeType = result ? result.type : '';
      }
    }
    return {
      conditionNodes: conditionNodes,
      mainTaskNodes: mainTaskNodes,
      catchNodes: catchNodes
    };
  };

  var GetConditionExpression$1 = function GetConditionExpression(nodes) {
    if (!Array.isArray(nodes)) {
      return GetANDExpression(nodes);
    }
    var expression;
    switch (nodes.length) {
      case 0:
        expression = 'true';
        break;
      case 1:
        expression = GetANDExpression(nodes[0]);
        break;
      default:
        expression = nodes.map(function (node) {
          return "(".concat(GetANDExpression(node), ")");
        }).join(' || ');
        break;
    }
    return expression;
  };
  var GetANDExpression = function GetANDExpression(node) {
    var paragraphs = node.paragraphs;
    var lines = [];
    for (var i = 0, cnt = paragraphs.length; i < cnt; i++) {
      var paragraph = paragraphs[i];
      if (paragraph.hasOwnProperty('block')) {
        continue;
      }
      lines.push.apply(lines, _toConsumableArray(paragraph.text.split('\n')));
    }
    var expression;
    switch (lines.length) {
      case 0:
        expression = 'true';
        break;
      case 1:
        expression = lines[0];
        break;
      default:
        expression = lines.map(function (line) {
          return "(".concat(line, ")");
        }).join(' && ');
        break;
    }
    return expression;
  };

  var CreateActionNode = function CreateActionNode(paragraph, config) {
    var commandData = GetCommandData(paragraph, config);
    if (!commandData) {
      return;
    }
    var actionNode;
    switch (commandData.type) {
      case 'exit':
        actionNode = new Abort({
          title: '[exit]'
        });
        break;
      case 'break':
        actionNode = new Failer({
          title: '[break]'
        });
        break;
      case 'next round':
        var duration = commandData.match[1].trim();
        if (duration === '') {
          duration = 1;
        }
        actionNode = new WaitNextRound({
          title: '[next round]',
          duration: duration
        });
        break;
      case 'activate':
        var activateTreeTitle = commandData.match[1].trim();
        actionNode = new ActivateAction({
          title: '[activate]',
          activateTreeTitle: activateTreeTitle
        });
        break;
      case 'deactivate':
        var deactivateTreeTitle = commandData.match[1].trim();
        actionNode = new DeactivateAction({
          title: '[deactivate]',
          deactivateTreeTitle: deactivateTreeTitle
        });
        break;
      default:
        delete commandData.type;
        actionNode = new TaskAction(commandData);
        break;
    }
    return actionNode;
  };
  var GetCommandData = function GetCommandData(paragraph, config) {
    var commandData;
    if (paragraph.hasOwnProperty('block')) {
      commandData = ParseCommandString(paragraph.block, ',', config);
      commandData.parameters.text = paragraph.text;
    } else {
      commandData = ParseCommandString(paragraph.text, '\n', config);
    }
    return commandData;
  };
  var ParseCommandString = function ParseCommandString(commandString, delimiter) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$lineBreak = _ref.lineBreak,
      lineBreak = _ref$lineBreak === void 0 ? '\\' : _ref$lineBreak,
      _ref$commentLineStart = _ref.commentLineStart,
      commentLineStart = _ref$commentLineStart === void 0 ? '\/\/' : _ref$commentLineStart;
    var lines = commandString.split(delimiter);
    if (delimiter === '\n') {
      // Discard comment lines
      lines = lines.filter(function (line) {
        return !line.trimLeft().startsWith(commentLineStart);
      });
      if (lines.length === 0) {
        return null;
      } else if (lines.length === 1) {
        var line = lines[0];
        var result = ParseType(line, ActionCommandTypes);
        if (result) {
          return result;
        }
        if (line.indexOf(',') !== -1) {
          lines = commandString.split(',');
        }
      }
    }
    var commandData = {
      type: 'task',
      name: TrimString(lines[0], lineBreak),
      parameters: {}
    };
    var parameters = commandData.parameters;
    for (var i = 1, cnt = lines.length; i < cnt; i++) {
      ParseProperty(TrimString(lines[i], lineBreak), parameters);
    }
    return commandData;
  };
  var TrimString = function TrimString(s, lineBreak) {
    if (lineBreak && s.at(-1) === lineBreak) {
      s = s.substring(0, s.length - 1);
    }
    return s.trimLeft();
  };

  var CreateActionSequence = function CreateActionSequence(node, config) {
    var sequence = new TaskSequence({
      title: node.title
    });
    var paragraphs = node.paragraphs; // paragraphs -> TaskAction[]
    var actionNode;
    for (var i = 0, cnt = paragraphs.length; i < cnt; i++) {
      actionNode = CreateActionNode(paragraphs[i], config);
      if (!actionNode) {
        continue;
      }
      sequence.addChild(actionNode);
    }
    return sequence;
  };

  var ExtraNumberExpression = function ExtraNumberExpression(s) {
    if (s.startsWith('#(') && s.endsWith(')')) {
      return s.substring(2, s.length - 1);
    }
    return s;
  };

  var CreateParentNode = function CreateParentNode(node, config, output) {
    if (Array.isArray(node)) {
      var nodes = node;
      if (nodes.length === 1) {
        return CreateParentNode(nodes[0], config);
      } else {
        // Create sequence from node.children
        var sequence = output ? output : new Sequence();
        var lastIfSelector;
        for (var i = 0, cnt = nodes.length; i < cnt; i++) {
          var node = nodes[i];
          var child = CreateParentNode(node, config);
          if (!child) {
            continue;
          }

          // Construct if-branch selector
          switch (child.title) {
            case '[if]':
              sequence.addChild(child);
              lastIfSelector = child;
              break;
            case '[else]':
            case '[else if]':
              if (lastIfSelector) {
                lastIfSelector.insertChild(child, null, -1);
              } else {
                // No [If] heading before this [else] heading
                console.warn("Can't find [If] heading before '".concat(node.title, "'"));
              }
              break;
            default:
              // Normal tasks
              sequence.addChild(child);
              lastIfSelector = null;
              break;
          }
        }
        return sequence;
      }
    }
    var result = ParseType(node.title, HeadingCommand);
    if (result) {
      switch (result.type) {
        case 'if':
          var selector = new Selector({
            title: '[if]'
          });
          var ifDecorator;
          var expression = GetConditionExpression(result.match[1], node);
          try {
            ifDecorator = new If({
              expression: expression
            });
          } catch (e) {
            console.error("[EventSheet] Parse expression '".concat(expression, "' at Heading ").concat(node.title, " failed, replace expression by 'false'"));
            console.error(e);
            ifDecorator = new If({
              expression: 'false'
            });
          }
          if (node.children.length > 0) {
            ifDecorator.addChild(CreateParentNode(node.children, config));
          } else {
            ifDecorator.addChild(CreateActionSequence(node, config));
          }
          selector.addChild(ifDecorator);
          var succeeder = new Succeeder();
          selector.addChild(succeeder);
          return selector;
        case 'else':
        case 'else if':
          var nodeTypeName = result.type;
          var ifDecorator;
          var expression = nodeTypeName === 'else' ? 'true' : GetConditionExpression(result.match[1], node);
          try {
            ifDecorator = new If({
              title: "[".concat(nodeTypeName, "]"),
              expression: expression
            });
          } catch (e) {
            console.error("[EventSheet] Parse expression '".concat(expression, "' at Heading ").concat(node.title, " failed, replace expression by 'false'"));
            console.error(e);
            ifDecorator = new If({
              title: "[".concat(nodeTypeName, "]"),
              expression: 'false'
            });
          }
          if (node.children.length > 0) {
            ifDecorator.addChild(CreateParentNode(node.children, config));
          } else {
            ifDecorator.addChild(CreateActionSequence(node, config));
          }
          return ifDecorator;
        case 'while':
          var whileDecorator = new RepeatUntilFailure({
            title: '[while]',
            returnSuccess: true
          });
          var ifDecorator;
          var expression = GetConditionExpression(result.match[1], node);
          try {
            ifDecorator = new If({
              title: '[while-IF]',
              expression: expression
            });
          } catch (e) {
            console.error("[EventSheet] Parse expression '".concat(expression, "' at Heading ").concat(node.title, " failed, replace expression by 'false'"));
            console.error(e);
            ifDecorator = new If({
              title: '[while-IF]',
              expression: 'false'
            });
          }
          if (node.children.length > 0) {
            ifDecorator.addChild(CreateParentNode(node.children, config));
          } else {
            ifDecorator.addChild(CreateActionSequence(node, config));
          }
          whileDecorator.addChild(ifDecorator);
          return whileDecorator;
        case 'repeat':
          var repeatCount = ExtraNumberExpression(result.match[1]);
          var repeatDecorator = new Repeat({
            title: '[repeat]',
            maxLoop: repeatCount
          });
          if (node.children.length > 0) {
            repeatDecorator.addChild(CreateParentNode(node.children, config));
          } else {
            repeatDecorator.addChild(CreateActionSequence(node, config));
          }
          return repeatDecorator;
        default:
          // Error
          console.error("Missing ".concat(result.type, "'s handler"));
          break;
      }
    } else {
      var sequence;
      if (node.children.length > 0) {
        // A node has paragraphs and children
        sequence = new Sequence();
        if (node.paragraphs.length > 0) {
          // Create ActionSequence from paragraphs
          sequence.addChild(CreateActionSequence(node, config));
        }

        // Append nodes from node.children
        CreateParentNode(node.children, config, sequence);
      } else {
        // A node has paragraphs only
        sequence = CreateActionSequence(node, config);
        // Always create a sequence no matter has paragraphs or not
      }
      return sequence;
    }
  };
  var GetConditionExpression = function GetConditionExpression(payloadExpression, node) {
    var expression = payloadExpression.trim();
    if (expression === '') {
      expression = GetConditionExpression$1(node);
    }
    return expression;
  };

  var Marked2Tree = function Marked2Tree(treeManager, markedString) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      groupName = _ref.groupName,
      _ref$lineBreak = _ref.lineBreak,
      lineBreak = _ref$lineBreak === void 0 ? '\\' : _ref$lineBreak,
      _ref$commentLineStart = _ref.commentLineStart,
      commentLineStart = _ref$commentLineStart === void 0 ? '\/\/' : _ref$commentLineStart,
      _ref$parallel = _ref.parallel,
      parallel = _ref$parallel === void 0 ? false : _ref$parallel,
      _ref$active = _ref.active,
      active = _ref$active === void 0 ? true : _ref$active,
      _ref$once = _ref.once,
      once = _ref$once === void 0 ? false : _ref$once;
    var headingTree = GetHeadingTree(markedString);
    var _ParseTopLevelNodes = ParseTopLevelNodes(headingTree.children),
      conditionNodes = _ParseTopLevelNodes.conditionNodes,
      mainTaskNodes = _ParseTopLevelNodes.mainTaskNodes,
      catchNodes = _ParseTopLevelNodes.catchNodes;
    var treeConfig = Object.assign({
      parallel: parallel,
      active: active,
      once: once
    }, GetTreeConfig(headingTree.paragraphs, commentLineStart));
    var taskSequenceConfig = {
      lineBreak: lineBreak,
      commentLineStart: commentLineStart
    };
    var eventsheet = new EventSheet(treeManager, {
      title: headingTree.title,
      groupName: groupName,
      condition: GetConditionExpression$1(conditionNodes),
      properties: treeConfig
    });
    var rootNode = eventsheet.root;
    rootNode.addChild(CreateParentNode(mainTaskNodes, taskSequenceConfig));
    var forceFailure = new ForceFailure();
    if (catchNodes.length > 0) {
      forceFailure.addChild(CreateParentNode(catchNodes[0], taskSequenceConfig));
    } else {
      forceFailure.addChild(new Succeeder());
    }
    rootNode.addChild(forceFailure);
    return eventsheet;
  };

  var MarkedEventSheets = /*#__PURE__*/function (_EventSheetManager) {
    _inherits(MarkedEventSheets, _EventSheetManager);
    function MarkedEventSheets() {
      _classCallCheck(this, MarkedEventSheets);
      return _callSuper(this, MarkedEventSheets, arguments);
    }
    _createClass(MarkedEventSheets, [{
      key: "addEventSheet",
      value: function addEventSheet(markedString, groupName, config) {
        if (typeof groupName !== 'string') {
          config = groupName;
          groupName = undefined;
        }
        if (groupName === undefined) {
          groupName = this.defaultTreeGroupName;
        }
        if (config === undefined) {
          config = {};
        }
        var _config = config,
          _config$lineBreak = _config.lineBreak,
          lineBreak = _config$lineBreak === void 0 ? '\\' : _config$lineBreak,
          _config$commentLineSt = _config.commentLineStart,
          commentLineStart = _config$commentLineSt === void 0 ? '\/\/' : _config$commentLineSt,
          _config$parallel = _config.parallel,
          parallel = _config$parallel === void 0 ? this.parallel : _config$parallel;
        var eventsheet = Marked2Tree(this, markedString, {
          groupName: groupName,
          lineBreak: lineBreak,
          commentLineStart: commentLineStart,
          parallel: parallel
        });
        this.addTree(eventsheet, groupName);
        return this;
      }
    }]);
    return MarkedEventSheets;
  }(EventSheetManager);

  var papaparse_min = {exports: {}};

  /* @license
  Papa Parse
  v5.4.1
  https://github.com/mholt/PapaParse
  License: MIT
  */

  (function (module, exports) {
  	!function(e,t){module.exports=t();}(commonjsGlobal,function s(){var f="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=f.IS_PAPA_WORKER||!1,a={},u=0,b={parse:function(e,t){var r=(t=t||{}).dynamicTyping||!1;J(r)&&(t.dynamicTypingFunction=r,r={});if(t.dynamicTyping=r,t.transform=!!J(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var i=function(){if(!b.WORKERS_SUPPORTED)return !1;var e=(r=f.URL||f.webkitURL||null,i=s.toString(),b.BLOB_URL||(b.BLOB_URL=r.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ","(",i,")();"],{type:"text/javascript"})))),t=new f.Worker(e);var r,i;return t.onmessage=_,t.id=u++,a[t.id]=t}();return i.userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=J(t.step),t.chunk=J(t.chunk),t.complete=J(t.complete),t.error=J(t.error),delete t.worker,void i.postMessage({input:e,config:t,workerId:i.id})}var n=null;b.NODE_STREAM_INPUT,"string"==typeof e?(e=function(e){if(65279===e.charCodeAt(0))return e.slice(1);return e}(e),n=t.download?new l(t):new p(t)):!0===e.readable&&J(e.read)&&J(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=",",y="\r\n",s='"',a=s+s,r=!1,i=null,o=!1;!function(){if("object"!=typeof t)return;"string"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return -1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);("boolean"==typeof t.quotes||"function"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(r=t.skipEmptyLines);"string"==typeof t.newline&&(y=t.newline);"string"==typeof t.quoteChar&&(s=t.quoteChar);"boolean"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");i=t.columns;}void 0!==t.escapeChar&&(a=t.escapeChar+s);("boolean"==typeof t.escapeFormulae||t.escapeFormulae instanceof RegExp)&&(o=t.escapeFormulae instanceof RegExp?t.escapeFormulae:/^[=+\-@\t\r].*$/);}();var u=new RegExp(Q(s),"g");"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return h(null,e,r);if("object"==typeof e[0])return h(i||Object.keys(e[0]),e,r)}else if("object"==typeof e)return "string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||i),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:"object"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),h(e.fields||[],e.data||[],r);throw new Error("Unable to serialize unrecognized input");function h(e,t,r){var i="";"string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(i+=m),i+=v(e[a],a);0<t.length&&(i+=y);}for(var o=0;o<t.length;o++){var u=n?e.length:t[o].length,h=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(r&&!n&&(h="greedy"===r?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===r&&n){for(var d=[],l=0;l<u;l++){var c=s?e[l]:l;d.push(t[o][c]);}h=""===d.join("").trim();}if(!h){for(var p=0;p<u;p++){0<p&&!f&&(i+=m);var g=n&&s?e[p]:p;i+=v(t[o][g],p);}o<t.length-1&&(!r||0<u&&!f)&&(i+=y);}}return i}function v(e,t){if(null==e)return "";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var r=!1;o&&"string"==typeof e&&o.test(e)&&(e="'"+e,r=!0);var i=e.toString().replace(u,a);return (r=r||!0===n||"function"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var r=0;r<t.length;r++)if(-1<e.indexOf(t[r]))return !0;return !1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||" "===i.charAt(0)||" "===i.charAt(i.length-1))?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK="\ufeff",b.BAD_DELIMITERS=["\r","\n",'"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=",",b.Parser=E,b.ParserHandle=r,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var r=o.config||{},u=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return !0;for(var t=0;t<this.files.length;t++)u.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},r)});}),e(),this;function e(){if(0!==u.length){var e,t,r,i,n=u[0];if(J(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,r=n.inputElem,i=s.reason,void(J(o.error)&&o.error({name:e},t,r,i));if("skip"===s.action)return void h();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config));}else if("skip"===s)return void h()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){J(a)&&a(e,n.file,n.inputElem),h();},b.parse(n.file,n.instanceConfig);}else J(o.complete)&&o.complete();}function h(){u.splice(0,1),e();}};}function h(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=w(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new r(t),(this._handle.streamer=this)._config=t;}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&J(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(e);void 0!==r&&(e=r);}this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+e;this._partialLine="";var n=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=i.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(J(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0;}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!J(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0;},this._sendError=function(e){J(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1});};}function l(e){var i;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),h.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded();}:function(){this._readChunk();},this.stream=function(e){this._input=e,this._nextChunk();},this._readChunk=function(){if(this._finished)this._chunkLoaded();else {if(i=new XMLHttpRequest,this._config.withCredentials&&(i.withCredentials=this._config.withCredentials),n||(i.onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)),i.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)i.setRequestHeader(t,e[t]);}if(this._config.chunkSize){var r=this._start+this._config.chunkSize-1;i.setRequestHeader("Range","bytes="+this._start+"-"+r);}try{i.send(this._config.downloadRequestBody);}catch(e){this._chunkError(e.message);}n&&0===i.status&&this._chunkError();}},this._chunkLoaded=function(){4===i.readyState&&(i.status<200||400<=i.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:i.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader("Content-Range");if(null===t)return -1;return parseInt(t.substring(t.lastIndexOf("/")+1))}(i),this.parseChunk(i.responseText)));},this._chunkError=function(e){var t=i.statusText||e;this._sendError(new Error(t));};}function c(e){var i,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),h.call(this,e);var s="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((i=new FileReader).onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)):i=new FileReaderSync,this._nextChunk();},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk();},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t);}var r=i.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:r}});},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result);},this._chunkError=function(){this._sendError(i.error);};}function p(e){var r;h.call(this,e=e||{}),this.stream=function(e){return r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=r.substring(0,t),r=r.substring(t)):(e=r,r=""),this._finished=!r,this.parseChunk(e)}};}function g(e){h.call(this,e=e||{});var t=[],r=!0,i=!1;this.pause=function(){h.prototype.pause.apply(this,arguments),this._input.pause();},this.resume=function(){h.prototype.resume.apply(this,arguments),this._input.resume();},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError);},this._checkIsFinished=function(){i&&1===t.length&&(this._finished=!0);},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):r=!0;},this._streamData=v(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(t.shift()));}catch(e){this._streamError(e);}},this),this._streamError=v(function(e){this._streamCleanUp(),this._sendError(e);},this),this._streamEnd=v(function(){this._streamCleanUp(),i=!0,this._streamData("");},this),this._streamCleanUp=v(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError);},this);}function r(m){var a,o,u,i=Math.pow(2,53),n=-i,s=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,h=/^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,t=this,r=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(J(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else {if(g(),0===c.data.length)return;r+=e.data.length,m.preview&&r>m.preview?o.abort():(c.data=c.data[0],p(c,t));}};}function y(e){return "greedy"===m.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function g(){return c&&u&&(k("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+b.DefaultDelimiter+"'"),u=!1),m.skipEmptyLines&&(c.data=c.data.filter(function(e){return !y(e)})),_()&&function(){if(!c)return;function e(e,t){J(m.transformHeader)&&(e=m.transformHeader(e,t)),l.push(e);}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1);}else c.data.forEach(e);}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var r,i=m.header?{}:[];for(r=0;r<e.length;r++){var n=r,s=e[r];m.header&&(n=r>=l.length?"__parsed_extra":l[r]),m.transform&&(s=m.transform(s,n)),s=v(n,s),"__parsed_extra"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s;}return m.header&&(r>l.length?k("FieldMismatch","TooManyFields","Too many fields: expected "+l.length+" fields but parsed "+r,f+t):r<l.length&&k("FieldMismatch","TooFewFields","Too few fields: expected "+l.length+" fields but parsed "+r,f+t)),i}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function v(e,t){return r=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[r]&&(m.dynamicTyping[r]=m.dynamicTypingFunction(r)),!0===(m.dynamicTyping[r]||m.dynamicTyping)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<i)return !0}return !1}(t)?parseFloat(t):h.test(t)?new Date(t):""===t?null:t):t;var r;}function k(e,t,r,i){var n={type:e,code:t,message:r};void 0!==i&&(n.row=i),c.errors.push(n);}this.parse=function(e,t,r){var i=m.quoteChar||'"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var r=new RegExp(Q(t)+"([^]*?)"+Q(t),"gm"),i=(e=e.replace(r,"")).split("\r"),n=e.split("\n"),s=1<n.length&&n[0].length<i[0].length;if(1===i.length||s)return "\n";for(var a=0,o=0;o<i.length;o++)"\n"===i[o][0]&&a++;return a>=i.length/2?"\r\n":"\r"}(e,i)),u=!1,m.delimiter)J(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else {var n=function(e,t,r,i,n){var s,a,o,u;n=n||[",","\t","|",";",b.RECORD_SEP,b.UNIT_SEP];for(var h=0;h<n.length;h++){var f=n[h],d=0,l=0,c=0;o=void 0;for(var p=new E({comments:i,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(r&&y(p.data[g]))c++;else {var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_;}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===u||u<l)&&1.99<l&&(a=d,s=f,u=l);}return {successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(u=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter;}var s=w(m);return m.preview&&m.header&&s.preview++,a=e,o=new E(s),c=o.parse(a,t,r),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=J(m.chunk)?"":a.substring(o.getCharIndex());},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3);},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,J(m.complete)&&m.complete(c),a="";};}function Q(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(j){var z,M=(j=j||{}).delimiter,P=j.newline,U=j.comments,q=j.step,N=j.preview,B=j.fastMode,K=z=void 0===j.quoteChar||null===j.quoteChar?'"':j.quoteChar;if(void 0!==j.escapeChar&&(K=j.escapeChar),("string"!=typeof M||-1<b.BAD_DELIMITERS.indexOf(M))&&(M=","),U===M)throw new Error("Comment character same as delimiter");!0===U?U="#":("string"!=typeof U||-1<b.BAD_DELIMITERS.indexOf(U))&&(U=!1),"\n"!==P&&"\r"!==P&&"\r\n"!==P&&(P="\n");var W=0,H=!1;this.parse=function(i,t,r){if("string"!=typeof i)throw new Error("Input must be a string");var n=i.length,e=M.length,s=P.length,a=U.length,o=J(q),u=[],h=[],f=[],d=W=0;if(!i)return L();if(j.header&&!t){var l=i.split(P)[0].split(M),c=[],p={},g=!1;for(var _ in l){var m=l[_];J(j.transformHeader)&&(m=j.transformHeader(m,_));var y=m,v=p[m]||0;for(0<v&&(g=!0,y=m+"_"+v),p[m]=v+1;c.includes(y);)y=y+"_"+v;c.push(y);}if(g){var k=i.split(P);k[0]=c.join(M),i=k.join(P);}}if(B||!1!==B&&-1===i.indexOf(z)){for(var b=i.split(P),E=0;E<b.length;E++){if(f=b[E],W+=f.length,E!==b.length-1)W+=P.length;else if(r)return L();if(!U||f.substring(0,a)!==U){if(o){if(u=[],I(f.split(M)),F(),H)return L()}else I(f.split(M));if(N&&N<=E)return u=u.slice(0,N),L(!0)}}return L()}for(var w=i.indexOf(M,W),R=i.indexOf(P,W),C=new RegExp(Q(K)+Q(z),"g"),S=i.indexOf(z,W);;)if(i[W]!==z)if(U&&0===f.length&&i.substring(W,W+a)===U){if(-1===R)return L();W=R+s,R=i.indexOf(P,W),w=i.indexOf(M,W);}else if(-1!==w&&(w<R||-1===R))f.push(i.substring(W,w)),W=w+e,w=i.indexOf(M,W);else {if(-1===R)break;if(f.push(i.substring(W,R)),D(R+s),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0)}else for(S=W,W++;;){if(-1===(S=i.indexOf(z,S+1)))return r||h.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:u.length,index:W}),T();if(S===n-1)return T(i.substring(W,S).replace(C,z));if(z!==K||i[S+1]!==K){if(z===K||0===S||i[S-1]!==K){-1!==w&&w<S+1&&(w=i.indexOf(M,S+1)),-1!==R&&R<S+1&&(R=i.indexOf(P,S+1));var O=A(-1===R?w:Math.min(w,R));if(i.substr(S+1+O,e)===M){f.push(i.substring(W,S).replace(C,z)),i[W=S+1+O+e]!==z&&(S=i.indexOf(z,W)),w=i.indexOf(M,W),R=i.indexOf(P,W);break}var x=A(R);if(i.substring(S+1+x,S+1+x+s)===P){if(f.push(i.substring(W,S).replace(C,z)),D(S+1+x+s),w=i.indexOf(M,W),S=i.indexOf(z,W),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0);break}h.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:u.length,index:W}),S++;}}else S++;}return T();function I(e){u.push(e),d=W;}function A(e){var t=0;if(-1!==e){var r=i.substring(S+1,e);r&&""===r.trim()&&(t=r.length);}return t}function T(e){return r||(void 0===e&&(e=i.substring(W)),f.push(e),W=n,I(f),o&&F()),L()}function D(e){W=e,I(f),f=[],R=i.indexOf(P,W);}function L(e){return {data:u,errors:h,meta:{delimiter:M,linebreak:P,aborted:H,truncated:!!e,cursor:d+(t||0)}}}function F(){q(L()),u=[],h=[];}},this.abort=function(){H=!0;},this.getCharIndex=function(){return W};}function _(e){var t=e.data,r=a[t.workerId],i=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){i=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}});},pause:y,resume:y};if(J(r.userStep)){for(var s=0;s<t.results.data.length&&(r.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!i);s++);delete t.results;}else J(r.userChunk)&&(r.userChunk(t.results,n,t.file),delete t.results);}t.finished&&!i&&m(t.workerId,t.results);}function m(e,t){var r=a[e];J(r.userComplete)&&r.userComplete(t),r.terminate(),delete a[e];}function y(){throw new Error("Not implemented.")}function w(e){if("object"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var r in e)t[r]=w(e[r]);return t}function v(e,t){return function(){e.apply(t,arguments);}}function J(e){return "function"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if("string"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var r=b.parse(t.input,t.config);r&&f.postMessage({workerId:b.WORKER_ID,results:r,finished:!0});}}),(l.prototype=Object.create(h.prototype)).constructor=l,(c.prototype=Object.create(h.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(h.prototype)).constructor=g,b}); 
  } (papaparse_min));

  var EventEmitterMethods$1 = {
    setEventEmitter: function setEventEmitter(eventEmitter, EventEmitterClass) {
      if (EventEmitterClass === undefined) {
        EventEmitterClass = Phaser.Events.EventEmitter; // Use built-in EventEmitter class by default
      }
      this._privateEE = eventEmitter === true || eventEmitter === undefined;
      this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
      return this;
    },
    destroyEventEmitter: function destroyEventEmitter() {
      if (this._eventEmitter && this._privateEE) {
        this._eventEmitter.shutdown();
      }
      return this;
    },
    getEventEmitter: function getEventEmitter() {
      return this._eventEmitter;
    },
    on: function on() {
      if (this._eventEmitter) {
        this._eventEmitter.on.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    once: function once() {
      if (this._eventEmitter) {
        this._eventEmitter.once.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    off: function off() {
      if (this._eventEmitter) {
        this._eventEmitter.off.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    emit: function emit(event) {
      if (this._eventEmitter && event) {
        this._eventEmitter.emit.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    addListener: function addListener() {
      if (this._eventEmitter) {
        this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    removeListener: function removeListener() {
      if (this._eventEmitter) {
        this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    removeAllListeners: function removeAllListeners() {
      if (this._eventEmitter) {
        this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    listenerCount: function listenerCount() {
      if (this._eventEmitter) {
        return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
      }
      return 0;
    },
    listeners: function listeners() {
      if (this._eventEmitter) {
        return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
      }
      return [];
    },
    eventNames: function eventNames() {
      if (this._eventEmitter) {
        return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
      }
      return [];
    }
  };

  var PropertyMethods$1 = {
    hasProperty: function hasProperty(property) {
      var gameObject = this.gameObject;
      if (gameObject.hasOwnProperty(property)) {
        return true;
      } else {
        var value = gameObject[property];
        return value !== undefined;
      }
    },
    getProperty: function getProperty(property) {
      return this.gameObject[property];
    },
    setProperty: function setProperty(property, value) {
      this.gameObject[property] = value;
      return this;
    },
    easeProperty: function easeProperty(property, value, duration, ease, repeat, isYoyo, _onComplete, target) {
      if (target === undefined) {
        target = this.gameObject;
      }
      var tweenTasks = this.tweens;
      var tweenTask = tweenTasks[property];
      if (tweenTask) {
        tweenTask.remove();
      }
      var config = {
        targets: target,
        duration: duration,
        ease: ease,
        repeat: repeat,
        yoyo: isYoyo,
        onComplete: function onComplete() {
          tweenTasks[property].remove();
          tweenTasks[property] = null;
          if (_onComplete) {
            _onComplete(target, property);
          }
        },
        onCompleteScope: this
      };
      config[property] = value;
      tweenTask = this.scene.tweens.add(config);
      tweenTask.timeScale = this.timeScale;
      tweenTasks[property] = tweenTask;
      return this;
    },
    getTweenTask: function getTweenTask(property) {
      return this.tweens[property];
    },
    freeTweens: function freeTweens() {
      var tweenTasks = this.tweens,
        tweenTask;
      for (var propName in tweenTasks) {
        tweenTask = tweenTasks[propName];
        if (tweenTask) {
          tweenTask.remove();
        }
        tweenTasks[propName] = null;
      }
      return this;
    }
  };

  var CallMethods$1 = {
    hasMethod: function hasMethod(methodName) {
      return typeof this.gameObject[methodName] === 'function';
    },
    call: function call(methodName) {
      if (!this.hasMethod(methodName)) {
        console.warn("[GameObjectManager] Game object '".concat(this.name, "' does not have method '").concat(methodName, "'"));
        return this;
      }
      var gameObject = this.gameObject;
      for (var _len = arguments.length, parameters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        parameters[_key - 1] = arguments[_key];
      }
      gameObject[methodName].apply(gameObject, parameters);
      return this;
    }
  };

  var DataMethods$2 = {
    hasData: function hasData(dataKey) {
      var gameObject = this.gameObject;
      return gameObject.data ? gameObject.data.has(dataKey) : false;
    },
    getData: function getData(dataKey) {
      return this.gameObject.getData(dataKey);
    },
    setData: function setData(dataKey, value) {
      this.gameObject.setData(dataKey, value);
      return this;
    }
  };

  var BobBase = /*#__PURE__*/function () {
    function BobBase(GOManager, gameObject, name) {
      _classCallCheck(this, BobBase);
      this.GOManager = GOManager;
      this.tweens = {};
      this.effects = {};
      this.setGO(gameObject, name);
    }
    _createClass(BobBase, [{
      key: "scene",
      get: function get() {
        return this.GOManager.scene;
      }
    }, {
      key: "timeScale",
      get: function get() {
        return this.GOManager.timeScale;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.freeGO();
        this.GOManager = undefined;
      }
    }, {
      key: "freeGO",
      value: function freeGO() {
        this.freeTweens();
        this.gameObject.destroy();
        this.gameObject = undefined;
        return this;
      }
    }, {
      key: "setGO",
      value: function setGO(gameObject, name) {
        gameObject.setName(name);
        this.gameObject = gameObject;
        this.name = name;
        this.freeTweens();
        return this;
      }
    }, {
      key: "setTimeScale",
      value: function setTimeScale(timeScale) {
        var tweenTasks = this.tweens;
        for (var key in tweenTasks) {
          var tweenTask = tweenTasks[key];
          if (tweenTask) {
            tweenTask.timeScale = timeScale;
          }
        }
        return this;
      }
    }]);
    return BobBase;
  }();
  Object.assign(BobBase.prototype, PropertyMethods$1, CallMethods$1, DataMethods$2);

  var IsEmpty = function IsEmpty(source) {
    for (var k in source) {
      return false;
    }
    return true;
  };

  var GetMethods = {
    has: function has(name) {
      return this.bobs.hasOwnProperty(name);
    },
    exists: function exists(name) {
      return this.bobs.hasOwnProperty(name);
    },
    get: function get(name) {
      return this.bobs[name];
    },
    getGO: function getGO(name) {
      var bob = this.get(name);
      return bob ? bob.gameObject : null;
    },
    forEachGO: function forEachGO(callback, scope) {
      for (var name in this.bobs) {
        var gameObject = this.bobs[name].gameObject;
        var stopLoop;
        if (scope) {
          stopLoop = callback.call(scope, gameObject, name, this);
        } else {
          stopLoop = callback(gameObject, name, this);
        }
        if (stopLoop) {
          break;
        }
      }
      return this;
    },
    getAllGO: function getAllGO(out) {
      if (out === undefined) {
        out = [];
      }
      for (var name in this.bobs) {
        var gameObject = this.bobs[name].gameObject;
        out.push(gameObject);
      }
      return out;
    }
  };

  var GetR = function GetR(colorInt) {
    return colorInt >> 16 & 0xff;
  };
  var GetG = function GetG(colorInt) {
    return colorInt >> 8 & 0xff;
  };
  var GetB = function GetB(colorInt) {
    return colorInt & 0xff;
  };

  var MaskR = ~(0xff << 16) & 0xffffff;
  var MaskG = ~(0xff << 8) & 0xffffff;
  var MaskB = ~0xff & 0xffffff;
  var SetR = function SetR(colorInt, r) {
    return (r & 0xff) << 16 | colorInt & MaskR;
  };
  var SetG = function SetG(colorInt, g) {
    return (g & 0xff) << 8 | colorInt & MaskG;
  };
  var SetB = function SetB(colorInt, b) {
    return b & 0xff | colorInt & MaskB;
  };
  var SetRGB = function SetRGB(colorInt, r, g, b) {
    return (r & 0xff) << 16 | (g & 0xff) << 8 | b & 0xff;
  };

  var AddTintRGBProperties = function AddTintRGBProperties(gameObject, tintRGB) {
    // Don't attach properties again
    if (gameObject.hasOwnProperty('tintR')) {
      return gameObject;
    }
    if (tintRGB === undefined) {
      tintRGB = 0xffffff;
    }
    var tintR = GetR(tintRGB);
    var tintG = GetG(tintRGB);
    var tintB = GetB(tintRGB);

    // Override tint property
    Object.defineProperty(gameObject, 'tint', {
      get: function get() {
        return tintRGB;
      },
      set: function set(value) {
        value = Math.floor(value) & 0xffffff;
        if (gameObject.setTint) {
          gameObject.setTint(value);
        }
        if (tintRGB !== value) {
          tintRGB = value;
          tintR = GetR(tintRGB);
          tintG = GetG(tintRGB);
          tintB = GetB(tintRGB);
          // gameObject.emit('_tintchange', value, tintR, tintG, tintB);
        }
      }
    });
    Object.defineProperty(gameObject, 'tintR', {
      get: function get() {
        return tintR;
      },
      set: function set(value) {
        value = Math.floor(value) & 0xff;
        if (tintR !== value) {
          tintR = value;
          gameObject.tint = SetR(tintRGB, value);
        }
      }
    });
    Object.defineProperty(gameObject, 'tintG', {
      get: function get() {
        return tintG;
      },
      set: function set(value) {
        value = Math.floor(value) & 0xff;
        if (tintG !== value) {
          tintG = value;
          gameObject.tint = SetG(tintRGB, value);
        }
      }
    });
    Object.defineProperty(gameObject, 'tintB', {
      get: function get() {
        return tintB;
      },
      set: function set(value) {
        value = Math.floor(value) & 0xff;
        if (tintB !== value) {
          tintB = value;
          gameObject.tint = SetB(tintRGB, value);
        }
      }
    });
    Object.defineProperty(gameObject, 'tintGray', {
      get: function get() {
        return Math.floor((tintR + tintG + tintB) / 3);
      },
      set: function set(value) {
        value = Math.floor(value) & 0xff;
        if (tintR !== value || tintG !== value || tintB !== value) {
          tintR = value;
          tintG = value;
          tintB = value;
          gameObject.tint = SetRGB(tintRGB, value, value, value);
        }
      }
    });
    gameObject.tint = tintRGB;
    return gameObject;
  };

  var EventEmitter$1 = Phaser.Events.EventEmitter;
  var MonitorViewport = function MonitorViewport(viewport) {
    if (viewport.events) {
      return viewport;
    }
    var events = new EventEmitter$1();
    var x = viewport.x;
    Object.defineProperty(viewport, 'x', {
      get: function get() {
        return x;
      },
      set: function set(value) {
        if (x !== value) {
          x = value;
          events.emit('update', viewport);
        }
      }
    });
    var y = viewport.y;
    Object.defineProperty(viewport, 'y', {
      get: function get() {
        return y;
      },
      set: function set(value) {
        if (y !== value) {
          y = value;
          events.emit('update', viewport);
        }
      }
    });
    var width = viewport.width;
    Object.defineProperty(viewport, 'width', {
      get: function get() {
        return width;
      },
      set: function set(value) {
        if (width !== value) {
          width = value;
          events.emit('update', viewport);
        }
      }
    });
    var height = viewport.height;
    Object.defineProperty(viewport, 'height', {
      get: function get() {
        return height;
      },
      set: function set(value) {
        if (height !== value) {
          height = value;
          events.emit('update', viewport);
        }
      }
    });
    viewport.events = events;
    return viewport;
  };

  var VPXYToXY = function VPXYToXY(vpx, vpy, vpxOffset, vpyOffset, viewport, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = GlobXY;
    }
    if (typeof vpxOffset !== 'number') {
      vpxOffset = 0;
      vpyOffset = 0;
    }
    out.x = viewport.x + viewport.width * vpx + vpxOffset;
    out.y = viewport.y + viewport.height * vpy + vpyOffset;
    return out;
  };
  var GlobXY = {};

  var AddViewportCoordinateProperties = function AddViewportCoordinateProperties(gameObject, viewport, vpx, vpy, vpxOffset, vpyOffset, transformCallback) {
    // Don't attach properties again
    if (gameObject.hasOwnProperty('vp')) {
      return gameObject;
    }
    if (typeof vpx === 'function') {
      transformCallback = vpx;
      vpx = undefined;
    }
    if (typeof vpxOffset === 'function') {
      transformCallback = vpxOffset;
      vpxOffset = undefined;
    }
    if (vpx === undefined) {
      vpx = 0.5;
    }
    if (vpy === undefined) {
      vpy = 0.5;
    }
    if (vpxOffset === undefined) {
      vpxOffset = 0;
    }
    if (vpyOffset === undefined) {
      vpyOffset = 0;
    }
    if (transformCallback === undefined) {
      transformCallback = VPXYToXY;
    }
    MonitorViewport(viewport);
    var events = viewport.events;
    gameObject.vp = viewport;

    // Set position of game object when view-port changed.
    var Transform = function Transform() {
      transformCallback(vpx, vpy, vpxOffset, vpyOffset, viewport, gameObject);
    };
    events.on('update', Transform);
    gameObject.once('destroy', function () {
      events.off('update', Transform);
      gameObject.vp = undefined;
    });
    Object.defineProperty(gameObject, 'vpx', {
      get: function get() {
        return vpx;
      },
      set: function set(value) {
        if (vpx !== value) {
          vpx = value;
          Transform();
        }
      }
    });
    Object.defineProperty(gameObject, 'vpy', {
      get: function get() {
        return vpy;
      },
      set: function set(value) {
        if (vpy !== value) {
          vpy = value;
          Transform();
        }
      }
    });
    Object.defineProperty(gameObject, 'vpxOffset', {
      get: function get() {
        return vpxOffset;
      },
      set: function set(value) {
        if (vpxOffset !== value) {
          vpxOffset = value;
          Transform();
        }
      }
    });
    Object.defineProperty(gameObject, 'vpyOffset', {
      get: function get() {
        return vpyOffset;
      },
      set: function set(value) {
        if (vpyOffset !== value) {
          vpyOffset = value;
          Transform();
        }
      }
    });
    Transform();
  };

  var HasProperty = function HasProperty(obj, prop) {
    if (!obj) {
      return false;
    }
    if (obj.hasOwnProperty(prop)) {
      return true;
    }
    while (obj) {
      if (Object.getOwnPropertyDescriptor(obj, prop)) {
        return true;
      }
      obj = obj.__proto__;
    }
    return false;
  };

  var GetFXFactory = function GetFXFactory(gameObject) {
    if (gameObject.preFX) {
      return gameObject.preFX;
    }
    if (gameObject.postFX) {
      return gameObject.postFX;
    }
    return null;
  };

  var AddClearEffectCallback = function AddClearEffectCallback(gameObject, effectSwitchName) {
    if (!gameObject._effectSwitchNames) {
      gameObject._effectSwitchNames = [];
      gameObject.clearAllEffects = function () {
        var effectSwitchNames = gameObject._effectSwitchNames;
        for (var i = 0, cnt = effectSwitchNames.length; i < cnt; i++) {
          gameObject[effectSwitchNames[i]] = null;
        }
        return gameObject;
      };
      gameObject.on('destroy', gameObject.clearAllEffects, gameObject);
    }
    gameObject._effectSwitchNames.push(effectSwitchName);
  };

  var AddBarrelProperties = function AddBarrelProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'barrel')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var barrel;
    Object.defineProperty(gameObject, 'barrel', {
      get: function get() {
        return barrel;
      },
      set: function set(value) {
        if (barrel === value) {
          return;
        }
        barrel = value;
        if (barrel === null || barrel === false) {
          if (gameObject._barrelEffect) {
            fxFactory.remove(gameObject._barrelEffect);
            gameObject._barrelEffect = undefined;
          }
        } else {
          if (!gameObject._barrelEffect) {
            gameObject._barrelEffect = fxFactory.addBarrel();
          }
          gameObject._barrelEffect.amount = barrel;
        }
      }
    });
    gameObject.barrel = null;
    AddClearEffectCallback(gameObject, 'barrel');
    return gameObject;
  };

  var AddColorMatrixEffectPropertiesBase = function AddColorMatrixEffectPropertiesBase(gameObject, effectName, inputMode) {
    // Don't attach properties again
    if (HasProperty(gameObject, effectName)) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var EffectInstancePropertyName = "_".concat(effectName, "Effect");
    var currentValue;
    Object.defineProperty(gameObject, effectName, {
      get: function get() {
        return currentValue;
      },
      set: function set(value) {
        if (currentValue === value) {
          return;
        }
        currentValue = value;
        if (currentValue === null || currentValue === false) {
          if (gameObject[EffectInstancePropertyName]) {
            fxFactory.remove(gameObject[EffectInstancePropertyName]);
            gameObject[EffectInstancePropertyName] = undefined;
          }
        } else {
          if (!gameObject[EffectInstancePropertyName]) {
            gameObject[EffectInstancePropertyName] = fxFactory.addColorMatrix();
          }
          var effectInstance = gameObject[EffectInstancePropertyName];
          effectInstance[effectName](inputMode === 1 ? value : undefined);
        }
      }
    });
    gameObject[effectName] = null;
    AddClearEffectCallback(gameObject, effectName);
    return gameObject;
  };

  var AddBlackWhiteProperties = function AddBlackWhiteProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'blackWhite');
    return gameObject;
  };

  var AddBloomProperties = function AddBloomProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'bloomColor')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var bloomColor,
      bloomOffsetX = 1,
      bloomOffsetY = 1,
      bloomBlurStrength = 1,
      bloomStrength = 1,
      bloomSteps = 4;
    Object.defineProperty(gameObject, 'bloomColor', {
      get: function get() {
        return bloomColor;
      },
      set: function set(value) {
        if (bloomColor === value) {
          return;
        }
        bloomColor = value;
        if (bloomColor === null || bloomColor === false) {
          if (gameObject._bloom) {
            fxFactory.remove(gameObject._bloom);
            gameObject._bloom = undefined;
            fxFactory.setPadding(0);
          }
        } else {
          if (!gameObject._bloom) {
            gameObject._bloom = fxFactory.addBloom(bloomColor, bloomOffsetX, bloomOffsetY, bloomBlurStrength, bloomStrength, bloomSteps);
            fxFactory.setPadding(Math.max(bloomOffsetX, bloomOffsetY) + 1);
          }
          gameObject._bloom.color = bloomColor;
        }
      }
    });
    Object.defineProperty(gameObject, 'bloomOffsetX', {
      get: function get() {
        return bloomOffsetX;
      },
      set: function set(value) {
        if (bloomOffsetX === value) {
          return;
        }
        bloomOffsetX = value;
        if (gameObject._bloom) {
          var offset = Math.max(bloomOffsetX, bloomOffsetY);
          fxFactory.setPadding(offset + 1);
          gameObject._bloom.offsetX = bloomOffsetX;
        }
      }
    });
    Object.defineProperty(gameObject, 'bloomOffsetY', {
      get: function get() {
        return bloomOffsetY;
      },
      set: function set(value) {
        if (bloomOffsetY === value) {
          return;
        }
        bloomOffsetY = value;
        if (gameObject._bloom) {
          var offset = Math.max(bloomOffsetX, bloomOffsetY);
          fxFactory.setPadding(offset + 1);
          gameObject._bloom.offsetY = bloomOffsetY;
        }
      }
    });
    Object.defineProperty(gameObject, 'bloomBlurStrength', {
      get: function get() {
        return bloomBlurStrength;
      },
      set: function set(value) {
        if (bloomBlurStrength === value) {
          return;
        }
        bloomBlurStrength = value;
        if (gameObject._bloom) {
          gameObject._bloom.blurStrength = bloomBlurStrength;
        }
      }
    });
    Object.defineProperty(gameObject, 'bloomStrength', {
      get: function get() {
        return bloomStrength;
      },
      set: function set(value) {
        if (bloomStrength === value) {
          return;
        }
        bloomStrength = value;
        if (gameObject._bloom) {
          gameObject._bloom.strength = bloomStrength;
        }
      }
    });
    Object.defineProperty(gameObject, 'bloomSteps', {
      get: function get() {
        return bloomSteps;
      },
      set: function set(value) {
        if (bloomSteps === value) {
          return;
        }
        bloomSteps = value;
        if (gameObject._bloom) {
          gameObject._bloom.steps = bloomSteps;
        }
      }
    });
    gameObject.bloomColor = null;
    AddClearEffectCallback(gameObject, 'bloomColor');
    return gameObject;
  };

  var AddBlurProperties = function AddBlurProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'blurColor')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var blurColor,
      blurQuality = 0,
      blurX = 1,
      blurY = 1,
      blurStrength = 1,
      blurSteps = 4;
    Object.defineProperty(gameObject, 'blurColor', {
      get: function get() {
        return blurColor;
      },
      set: function set(value) {
        if (blurColor === value) {
          return;
        }
        blurColor = value;
        if (blurColor === null || blurColor === false) {
          if (gameObject._blur) {
            fxFactory.remove(gameObject._blur);
            gameObject._blur = undefined;
            fxFactory.setPadding(0);
          }
        } else {
          if (!gameObject._blur) {
            gameObject._blur = fxFactory.addBlur(blurQuality, blurX, blurY, blurStrength, blurColor, blurSteps);
            fxFactory.setPadding(Math.max(blurX, blurY) + 1);
          }
          gameObject._blur.color = blurColor;
        }
      }
    });
    Object.defineProperty(gameObject, 'blurQuality', {
      get: function get() {
        return blurQuality;
      },
      set: function set(value) {
        if (blurQuality === value) {
          return;
        }
        blurQuality = value;
        if (gameObject._blur) {
          gameObject._blur.quality = blurQuality;
        }
      }
    });
    Object.defineProperty(gameObject, 'blurX', {
      get: function get() {
        return blurX;
      },
      set: function set(value) {
        if (blurX === value) {
          return;
        }
        blurX = value;
        if (gameObject._blur) {
          var offset = Math.max(blurX, blurY);
          fxFactory.setPadding(offset + 1);
          gameObject._blur.x = blurX;
        }
      }
    });
    Object.defineProperty(gameObject, 'blurY', {
      get: function get() {
        return blurY;
      },
      set: function set(value) {
        if (blurY === value) {
          return;
        }
        blurY = value;
        if (gameObject._blur) {
          var offset = Math.max(blurX, blurY);
          fxFactory.setPadding(offset + 1);
          gameObject._blur.y = blurY;
        }
      }
    });
    Object.defineProperty(gameObject, 'blurStrength', {
      get: function get() {
        return blurStrength;
      },
      set: function set(value) {
        if (blurStrength === value) {
          return;
        }
        blurStrength = value;
        if (gameObject._blur) {
          gameObject._blur.strength = blurStrength;
        }
      }
    });
    Object.defineProperty(gameObject, 'blurSteps', {
      get: function get() {
        return blurSteps;
      },
      set: function set(value) {
        if (blurSteps === value) {
          return;
        }
        blurSteps = value;
        if (gameObject._blur) {
          gameObject._blur.steps = blurSteps;
        }
      }
    });
    gameObject.blurColor = null;
    AddClearEffectCallback(gameObject, 'blurColor');
    return gameObject;
  };

  var AddBokehProperties = function AddBokehProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'bokehRadius')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var bokehRadius,
      bokehAmount = 1,
      bokehContrast = 0.2;
    Object.defineProperty(gameObject, 'bokehRadius', {
      get: function get() {
        return bokehRadius;
      },
      set: function set(value) {
        if (bokehRadius === value) {
          return;
        }
        bokehRadius = value;
        if (bokehRadius === null || bokehRadius === false) {
          if (gameObject._bokeh) {
            fxFactory.remove(gameObject._bokeh);
            gameObject._bokeh = undefined;
          }
        } else {
          if (!gameObject._bokeh) {
            gameObject._bokeh = fxFactory.addBokeh(bokehRadius, bokehAmount, bokehContrast);
          }
          gameObject._bokeh.radius = bokehRadius;
        }
      }
    });
    Object.defineProperty(gameObject, 'bokehAmount', {
      get: function get() {
        return bokehAmount;
      },
      set: function set(value) {
        if (bokehAmount === value) {
          return;
        }
        bokehAmount = value;
        if (gameObject._bokeh) {
          gameObject._bokeh.amount = bokehAmount;
        }
      }
    });
    Object.defineProperty(gameObject, 'bokehContrast', {
      get: function get() {
        return bokehContrast;
      },
      set: function set(value) {
        if (bokehContrast === value) {
          return;
        }
        bokehContrast = value;
        if (gameObject._bokeh) {
          gameObject._bokeh.contrast = bokehContrast;
        }
      }
    });
    gameObject.bokehRadius = null;
    AddClearEffectCallback(gameObject, 'bokehRadius');
    return gameObject;
  };

  var AddBrightnessProperties = function AddBrightnessProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'brightness', 1);
    return gameObject;
  };

  var AddBrownProperties = function AddBrownProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'brown');
    return gameObject;
  };

  var AddCircleProperties = function AddCircleProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'circleColor')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var circleColor,
      circleThickness = 8,
      circleBackgroundColor = 0x000000,
      circleBackgroundAlpha = 0.4,
      circleScale = 1,
      circleFeather = 0.005;
    Object.defineProperty(gameObject, 'circleColor', {
      get: function get() {
        return circleColor;
      },
      set: function set(value) {
        if (circleColor === value) {
          return;
        }
        circleColor = value;
        if (circleColor === null || circleColor === false) {
          if (gameObject._circle) {
            fxFactory.remove(gameObject._circle);
            gameObject._circle = undefined;
          }
        } else {
          if (!gameObject._circle) {
            gameObject._circle = fxFactory.addCircle(circleThickness, circleColor, circleBackgroundColor, circleScale, circleFeather);
            gameObject.circleBackgroundAlpha = circleBackgroundAlpha;
          }
          gameObject._circle.color = circleColor;
        }
      }
    });
    Object.defineProperty(gameObject, 'circleThickness', {
      get: function get() {
        return circleThickness;
      },
      set: function set(value) {
        if (circleThickness === value) {
          return;
        }
        circleThickness = value;
        if (gameObject._circle) {
          gameObject._circle.thickness = circleThickness;
        }
      }
    });
    Object.defineProperty(gameObject, 'circleBackgroundColor', {
      get: function get() {
        return circleBackgroundColor;
      },
      set: function set(value) {
        if (circleBackgroundColor === value) {
          return;
        }
        circleBackgroundColor = value;
        if (gameObject._circle) {
          gameObject._circle.backgroundColor = circleBackgroundColor;
        }
      }
    });
    Object.defineProperty(gameObject, 'circleBackgroundAlpha', {
      get: function get() {
        return circleBackgroundAlpha;
      },
      set: function set(value) {
        if (circleBackgroundAlpha === value) {
          return;
        }
        circleBackgroundAlpha = value;
        if (gameObject._circle) {
          gameObject._circle.glcolor2[3] = circleBackgroundAlpha;
        }
      }
    });
    Object.defineProperty(gameObject, 'circleScale', {
      get: function get() {
        return circleScale;
      },
      set: function set(value) {
        if (circleScale === value) {
          return;
        }
        circleScale = value;
        if (gameObject._circle) {
          gameObject._circle.scale = circleScale;
        }
      }
    });
    Object.defineProperty(gameObject, 'circleFeather', {
      get: function get() {
        return circleFeather;
      },
      set: function set(value) {
        if (circleFeather === value) {
          return;
        }
        circleFeather = value;
        if (gameObject._circle) {
          gameObject._circle.feather = circleFeather;
        }
      }
    });
    gameObject.circleColor = null;
    AddClearEffectCallback(gameObject, 'circleColor');
    return gameObject;
  };

  var AddContrastProperties = function AddContrastProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'contrast', 1);
    return gameObject;
  };

  var AddDesaturateProperties = function AddDesaturateProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'desaturate', 1);
    return gameObject;
  };

  var AddDesaturateLuminanceProperties = function AddDesaturateLuminanceProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'desaturateLuminance');
    return gameObject;
  };

  var AddDisplacementProperties = function AddDisplacementProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'displacementKey')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var displacementKey,
      displacementX = 0.005,
      displacementY = 0.005;
    Object.defineProperty(gameObject, 'displacementKey', {
      get: function get() {
        return displacementKey;
      },
      set: function set(value) {
        if (displacementKey === value) {
          return;
        }
        displacementKey = value;
        if (displacementKey === null || displacementKey === false) {
          if (gameObject._displacement) {
            fxFactory.remove(gameObject._displacement);
            gameObject._displacement = undefined;
          }
        } else {
          if (!gameObject._displacement) {
            gameObject._displacement = fxFactory.addDisplacement(displacementKey, displacementX, displacementY);
          }
          gameObject._displacement.setTexture(displacementKey);
        }
      }
    });
    Object.defineProperty(gameObject, 'displacementX', {
      get: function get() {
        return displacementX;
      },
      set: function set(value) {
        if (displacementX === value) {
          return;
        }
        displacementX = value;
        if (gameObject._displacement) {
          gameObject._displacement.x = displacementX;
        }
      }
    });
    Object.defineProperty(gameObject, 'displacementY', {
      get: function get() {
        return displacementY;
      },
      set: function set(value) {
        if (displacementY === value) {
          return;
        }
        displacementY = value;
        if (gameObject._displacement) {
          gameObject._displacement.y = displacementY;
        }
      }
    });
    gameObject.displacementKey = null;
    AddClearEffectCallback(gameObject, 'displacementKey');
    return gameObject;
  };

  var AddGlowProperties = function AddGlowProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'glowColor')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var glowColor,
      glowOuterStrength = 4,
      glowInnerStrength = 0;
    Object.defineProperty(gameObject, 'glowColor', {
      get: function get() {
        return glowColor;
      },
      set: function set(value) {
        if (glowColor === value) {
          return;
        }
        glowColor = value;
        if (glowColor === null || glowColor === false) {
          if (gameObject._glow) {
            fxFactory.remove(gameObject._glow);
            gameObject._glow = undefined;
            fxFactory.setPadding(0);
          }
        } else {
          if (!gameObject._glow) {
            gameObject._glow = fxFactory.addGlow(glowColor, glowOuterStrength, glowInnerStrength);
            fxFactory.setPadding(glowOuterStrength + 1);
          }
          gameObject._glow.color = glowColor;
        }
      }
    });
    Object.defineProperty(gameObject, 'glowOuterStrength', {
      get: function get() {
        return glowOuterStrength;
      },
      set: function set(value) {
        if (glowOuterStrength === value) {
          return;
        }
        glowOuterStrength = value;
        if (gameObject._glow) {
          fxFactory.setPadding(glowOuterStrength + 1);
          gameObject._glow.outerStrength = glowOuterStrength;
        }
      }
    });
    Object.defineProperty(gameObject, 'glowInnerStrength', {
      get: function get() {
        return glowInnerStrength;
      },
      set: function set(value) {
        if (glowInnerStrength === value) {
          return;
        }
        glowInnerStrength = value;
        if (gameObject._glow) {
          gameObject._glow.innerStrength = glowInnerStrength;
        }
      }
    });
    gameObject.glowColor = null;
    AddClearEffectCallback(gameObject, 'glowColor');
    return gameObject;
  };

  var AddGradientProperties = function AddGradientProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'gradientColor')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var gradientColor1,
      gradientColor2,
      gradientAlpha = 0.5,
      gradientFromX = 0,
      gradientFromY = 0,
      gradientToX = 0,
      gradientToY = 1,
      gradientSize = 0;
    Object.defineProperty(gameObject, 'gradientColor', {
      get: function get() {
        return [gradientColor1, gradientColor2];
      },
      set: function set(value) {
        var color1, color2;
        if (value === null || value === false) {
          color1 = null;
          color2 = null;
        } else {
          color1 = value[0];
          color2 = value[1];
        }
        if (gradientColor1 === color1 && gradientColor2 === color2) {
          return;
        }
        gradientColor1 = color1;
        gradientColor2 = color2;
        if (gradientColor1 === null || gradientColor1 === false) {
          if (gameObject._gradient) {
            fxFactory.remove(gameObject._gradient);
            gameObject._gradient = undefined;
          }
        } else {
          if (!gameObject._gradient) {
            gameObject._gradient = fxFactory.addGradient(gradientColor1, gradientColor2, gradientAlpha, gradientFromX, gradientFromY, gradientToX, gradientToY, gradientSize);
          }
          gameObject._gradient.color1 = gradientColor1;
          gameObject._gradient.color2 = gradientColor2;
        }
      }
    });
    Object.defineProperty(gameObject, 'gradientColor1', {
      get: function get() {
        return gradientColor1;
      },
      set: function set(value) {
        if (value === null || value === false) {
          gameObject.gradientColor = value;
          return;
        }
        if (gradientColor1 === value) {
          return;
        }
        gradientColor1 = value;
        if (gameObject._gradient) {
          gameObject._gradient.color1 = gradientColor1;
        }
      }
    });
    Object.defineProperty(gameObject, 'gradientColor2', {
      get: function get() {
        return gradientColor2;
      },
      set: function set(value) {
        if (value === null || value === false) {
          gameObject.gradientColor = value;
          return;
        }
        if (gradientColor2 === value) {
          return;
        }
        gradientColor2 = value;
        if (gameObject._gradient) {
          gameObject._gradient.color2 = gradientColor2;
        }
      }
    });
    Object.defineProperty(gameObject, 'gradientAlpha', {
      get: function get() {
        return gradientAlpha;
      },
      set: function set(value) {
        if (gradientAlpha === value) {
          return;
        }
        gradientAlpha = value;
        if (gameObject._gradient) {
          gameObject._gradient.alpha = gradientAlpha;
        }
      }
    });
    Object.defineProperty(gameObject, 'gradientFromX', {
      get: function get() {
        return gradientFromX;
      },
      set: function set(value) {
        if (gradientFromX === value) {
          return;
        }
        gradientFromX = value;
        if (gameObject._gradient) {
          gameObject._gradient.fromX = gradientFromX;
        }
      }
    });
    Object.defineProperty(gameObject, 'gradientFromY', {
      get: function get() {
        return gradientFromY;
      },
      set: function set(value) {
        if (gradientFromY === value) {
          return;
        }
        gradientFromY = value;
        if (gameObject._gradient) {
          gameObject._gradient.fromY = gradientFromY;
        }
      }
    });
    Object.defineProperty(gameObject, 'gradientToX', {
      get: function get() {
        return gradientToX;
      },
      set: function set(value) {
        if (gradientToX === value) {
          return;
        }
        gradientToX = value;
        if (gameObject._gradient) {
          gameObject._gradient.toX = gradientToX;
        }
      }
    });
    Object.defineProperty(gameObject, 'gradientToY', {
      get: function get() {
        return gradientToY;
      },
      set: function set(value) {
        if (gradientToY === value) {
          return;
        }
        gradientToY = value;
        if (gameObject._gradient) {
          gameObject._gradient.toY = gradientToY;
        }
      }
    });
    Object.defineProperty(gameObject, 'gradientSize', {
      get: function get() {
        return gradientSize;
      },
      set: function set(value) {
        if (gradientSize === value) {
          return;
        }
        gradientSize = value;
        if (gameObject._gradient) {
          gameObject._gradient.size = gradientSize;
        }
      }
    });
    gameObject.gradientColor = null;
    AddClearEffectCallback(gameObject, 'gradientColor');
    return gameObject;
  };

  var AddGrayscaleProperties = function AddGrayscaleProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'grayscale', 1);
    return gameObject;
  };

  var AddHueProperties = function AddHueProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'hue', 1);
    return gameObject;
  };

  var AddKodachromeProperties = function AddKodachromeProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'kodachrome');
    return gameObject;
  };

  var AddLSDProperties = function AddLSDProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'lsd');
    return gameObject;
  };

  var AddNegativeProperties = function AddNegativeProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'negative');
    return gameObject;
  };

  var AddPixelateProperties = function AddPixelateProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'pixelate')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var pixelate;
    Object.defineProperty(gameObject, 'pixelate', {
      get: function get() {
        return pixelate;
      },
      set: function set(value) {
        if (pixelate === value) {
          return;
        }
        pixelate = value;
        if (pixelate === null || pixelate === false) {
          if (gameObject._pixelateEffect) {
            fxFactory.remove(gameObject._pixelateEffect);
            gameObject._pixelateEffect = undefined;
          }
        } else {
          if (!gameObject._pixelateEffect) {
            gameObject._pixelateEffect = fxFactory.addPixelate();
          }
          gameObject._pixelateEffect.amount = pixelate;
        }
      }
    });
    gameObject.pixelate = null;
    AddClearEffectCallback(gameObject, 'pixelate');
    return gameObject;
  };

  var AddPolaroidProperties = function AddPolaroidProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'polaroid');
    return gameObject;
  };

  var AddRevealProperties = function AddRevealProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'revealLeft')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var revealLeft,
      revealRight,
      revealUp,
      revealDown,
      revealWidth = 0.1;
    var ClearRevealFlags = function ClearRevealFlags() {
      revealLeft = null;
      revealRight = null;
      revealUp = null;
      revealDown = null;
    };
    var RemoveEffect = function RemoveEffect(gameObject) {
      if (gameObject._revealEffect) {
        fxFactory.remove(gameObject._revealEffect);
        gameObject._revealEffect = undefined;
      }
    };
    Object.defineProperty(gameObject, 'revealLeft', {
      get: function get() {
        return revealLeft;
      },
      set: function set(value) {
        if (revealLeft === value) {
          return;
        }
        ClearRevealFlags();
        revealLeft = value;
        if (revealLeft === null || revealLeft === false) {
          RemoveEffect(gameObject);
        } else {
          if (!gameObject._revealEffect) {
            gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
          }
          gameObject._revealEffect.direction = 1;
          gameObject._revealEffect.axis = 0;
          gameObject._revealEffect.progress = revealLeft;
        }
      }
    });
    Object.defineProperty(gameObject, 'revealRight', {
      get: function get() {
        return revealRight;
      },
      set: function set(value) {
        if (revealRight === value) {
          return;
        }
        ClearRevealFlags();
        revealRight = value;
        if (revealRight === null || revealRight === false) {
          RemoveEffect(gameObject);
        } else {
          if (!gameObject._revealEffect) {
            gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
          }
          gameObject._revealEffect.direction = 0;
          gameObject._revealEffect.axis = 0;
          gameObject._revealEffect.progress = revealRight;
        }
      }
    });
    Object.defineProperty(gameObject, 'revealUp', {
      get: function get() {
        return revealUp;
      },
      set: function set(value) {
        if (revealUp === value) {
          return;
        }
        ClearRevealFlags();
        revealUp = value;
        if (revealUp === null || revealUp === false) {
          RemoveEffect(gameObject);
        } else {
          if (!gameObject._revealEffect) {
            gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
          }
          gameObject._revealEffect.direction = 1;
          gameObject._revealEffect.axis = 1;
          gameObject._revealEffect.progress = revealUp;
        }
      }
    });
    Object.defineProperty(gameObject, 'revealDown', {
      get: function get() {
        return revealDown;
      },
      set: function set(value) {
        if (revealDown === value) {
          return;
        }
        ClearRevealFlags();
        revealDown = value;
        if (revealDown === null || revealDown === false) {
          RemoveEffect(gameObject);
        } else {
          if (!gameObject._revealEffect) {
            gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
          }
          gameObject._revealEffect.direction = 0;
          gameObject._revealEffect.axis = 1;
          gameObject._revealEffect.progress = revealDown;
        }
      }
    });
    Object.defineProperty(gameObject, 'revealWidth', {
      get: function get() {
        return revealWidth;
      },
      set: function set(value) {
        if (revealWidth === value) {
          return;
        }
        revealWidth = value;
        if (gameObject._revealEffect) {
          gameObject._revealEffect.wipeWidth = revealWidth;
        }
      }
    });
    gameObject.revealLeft = null;
    AddClearEffectCallback(gameObject, 'revealLeft');
    AddClearEffectCallback(gameObject, 'revealRight');
    AddClearEffectCallback(gameObject, 'revealUp');
    AddClearEffectCallback(gameObject, 'revealDown');
    return gameObject;
  };

  var AddSaturateProperties = function AddSaturateProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'saturate', 1);
    return gameObject;
  };

  var AddSepiaProperties = function AddSepiaProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'sepia');
    return gameObject;
  };

  var AddShadowProperties = function AddShadowProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'shadowColor')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var shadowColor,
      shadowX = 0,
      shadowY = 0,
      shadowDecay = 0.1,
      shadowPower = 1,
      shadowSamples = 6,
      shadowIntensity = 1;
    Object.defineProperty(gameObject, 'shadowColor', {
      get: function get() {
        return shadowColor;
      },
      set: function set(value) {
        if (shadowColor === value) {
          return;
        }
        shadowColor = value;
        if (shadowColor === null || shadowColor === false) {
          if (gameObject._shadow) {
            fxFactory.remove(gameObject._shadow);
            gameObject._shadow = undefined;
          }
        } else {
          if (!gameObject._shadow) {
            gameObject._shadow = fxFactory.addShadow(shadowX, shadowY, shadowDecay, shadowPower, shadowColor, shadowSamples, shadowIntensity);
          }
          gameObject._shadow.color = shadowColor;
        }
      }
    });
    Object.defineProperty(gameObject, 'shadowX', {
      get: function get() {
        return shadowX;
      },
      set: function set(value) {
        if (shadowX === value) {
          return;
        }
        shadowX = value;
        if (gameObject._shadow) {
          gameObject._shadow.x = shadowX;
        }
      }
    });
    Object.defineProperty(gameObject, 'shadowY', {
      get: function get() {
        return shadowY;
      },
      set: function set(value) {
        if (shadowY === value) {
          return;
        }
        shadowY = value;
        if (gameObject._shadow) {
          gameObject._shadow.y = shadowY;
        }
      }
    });
    Object.defineProperty(gameObject, 'decay', {
      get: function get() {
        return shadowDecay;
      },
      set: function set(value) {
        if (shadowDecay === value) {
          return;
        }
        shadowDecay = value;
        if (gameObject._shadow) {
          gameObject._shadow.decay = shadowDecay;
        }
      }
    });
    Object.defineProperty(gameObject, 'shadowPower', {
      get: function get() {
        return shadowPower;
      },
      set: function set(value) {
        if (shadowPower === value) {
          return;
        }
        shadowPower = value;
        if (gameObject._shadow) {
          gameObject._shadow.power = shadowPower;
        }
      }
    });
    Object.defineProperty(gameObject, 'shadowSamples', {
      get: function get() {
        return shadowSamples;
      },
      set: function set(value) {
        if (shadowSamples === value) {
          return;
        }
        shadowSamples = value;
        if (gameObject._shadow) {
          gameObject._shadow.samples = shadowSamples;
        }
      }
    });
    Object.defineProperty(gameObject, 'shadowIntensity', {
      get: function get() {
        return shadowIntensity;
      },
      set: function set(value) {
        if (shadowIntensity === value) {
          return;
        }
        shadowIntensity = value;
        if (gameObject._shadow) {
          gameObject._shadow.intensity = shadowIntensity;
        }
      }
    });
    gameObject.shadowColor = null;
    AddClearEffectCallback(gameObject, 'shadowColor');
    return gameObject;
  };

  var AddShiftToBGRProperties = function AddShiftToBGRProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'shiftToBGR');
    return gameObject;
  };

  var AddShineProperties = function AddShineProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'shineSpeed')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var shineSpeed,
      shineLineWidth = 0.5,
      shineGradient = 3;
    Object.defineProperty(gameObject, 'shineSpeed', {
      get: function get() {
        return shineSpeed;
      },
      set: function set(value) {
        if (shineSpeed === value) {
          return;
        }
        shineSpeed = value;
        if (shineSpeed === null || shineSpeed === false) {
          if (gameObject._shine) {
            fxFactory.remove(gameObject._shine);
            gameObject._shine = undefined;
          }
        } else {
          if (!gameObject._shine) {
            gameObject._shine = fxFactory.addShine(shineSpeed, shineLineWidth, shineGradient);
          }
          gameObject._shine.speed = shineSpeed;
        }
      }
    });
    Object.defineProperty(gameObject, 'shineLineWidth', {
      get: function get() {
        return shineLineWidth;
      },
      set: function set(value) {
        if (shineLineWidth === value) {
          return;
        }
        shineLineWidth = value;
        if (gameObject._shine) {
          gameObject._shine.lineWidth = shineLineWidth;
        }
      }
    });
    Object.defineProperty(gameObject, 'shineGradient', {
      get: function get() {
        return shineGradient;
      },
      set: function set(value) {
        if (shineGradient === value) {
          return;
        }
        shineGradient = value;
        if (gameObject._shine) {
          gameObject._shine.gradient = shineGradient;
        }
      }
    });
    gameObject.shineSpeed = null;
    AddClearEffectCallback(gameObject, 'shineSpeed');
    return gameObject;
  };

  var AddTechnicolorProperties = function AddTechnicolorProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'technicolor');
    return gameObject;
  };

  var AddTiltShiftProperties = function AddTiltShiftProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'tiltShiftRadius')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var tiltShiftRadius,
      tiltShiftAmount = 1,
      tiltShiftContrast = 0.2,
      tiltShiftBlurX = 1,
      tiltShiftBlurY = 1,
      tiltShiftStrength = 1;
    Object.defineProperty(gameObject, 'tiltShiftRadius', {
      get: function get() {
        return tiltShiftRadius;
      },
      set: function set(value) {
        if (tiltShiftRadius === value) {
          return;
        }
        tiltShiftRadius = value;
        if (tiltShiftRadius === null || tiltShiftRadius === false) {
          if (gameObject._tiltShift) {
            fxFactory.remove(gameObject._tiltShift);
            gameObject._tiltShift = undefined;
          }
        } else {
          if (!gameObject._tiltShift) {
            gameObject._tiltShift = fxFactory.addTiltShift(tiltShiftRadius, tiltShiftAmount, tiltShiftContrast, tiltShiftBlurX, tiltShiftBlurY, tiltShiftStrength);
          }
          gameObject._tiltShift.radius = tiltShiftRadius;
        }
      }
    });
    Object.defineProperty(gameObject, 'tiltShiftAmount', {
      get: function get() {
        return tiltShiftAmount;
      },
      set: function set(value) {
        if (tiltShiftAmount === value) {
          return;
        }
        tiltShiftAmount = value;
        if (gameObject._tiltShift) {
          gameObject._tiltShift.amount = tiltShiftAmount;
        }
      }
    });
    Object.defineProperty(gameObject, 'tiltShiftContrast', {
      get: function get() {
        return tiltShiftContrast;
      },
      set: function set(value) {
        if (tiltShiftContrast === value) {
          return;
        }
        tiltShiftContrast = value;
        if (gameObject._tiltShift) {
          gameObject._tiltShift.contrast = tiltShiftContrast;
        }
      }
    });
    Object.defineProperty(gameObject, 'tiltShiftBlurX', {
      get: function get() {
        return tiltShiftBlurX;
      },
      set: function set(value) {
        if (tiltShiftBlurX === value) {
          return;
        }
        tiltShiftBlurX = value;
        if (gameObject._tiltShift) {
          gameObject._tiltShift.blurX = tiltShiftBlurX;
        }
      }
    });
    Object.defineProperty(gameObject, 'tiltShiftBlurY', {
      get: function get() {
        return tiltShiftBlurY;
      },
      set: function set(value) {
        if (tiltShiftBlurY === value) {
          return;
        }
        tiltShiftBlurY = value;
        if (gameObject._tiltShift) {
          gameObject._tiltShift.blurY = tiltShiftBlurY;
        }
      }
    });
    Object.defineProperty(gameObject, 'tiltShiftStrength', {
      get: function get() {
        return tiltShiftStrength;
      },
      set: function set(value) {
        if (tiltShiftStrength === value) {
          return;
        }
        tiltShiftStrength = value;
        if (gameObject._tiltShift) {
          gameObject._tiltShift.strength = tiltShiftStrength;
        }
      }
    });
    gameObject.tiltShiftRadius = null;
    AddClearEffectCallback(gameObject, 'tiltShiftRadius');
    return gameObject;
  };

  var AddVignetteProperties = function AddVignetteProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'vignetteColor')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var vignetteRadius,
      vignetteX = 0.5,
      vignetteY = 0.5,
      vignetteStrength = 0.5;
    Object.defineProperty(gameObject, 'vignetteRadius', {
      get: function get() {
        return vignetteRadius;
      },
      set: function set(value) {
        if (vignetteRadius === value) {
          return;
        }
        vignetteRadius = value;
        if (vignetteRadius === null || vignetteRadius === false) {
          if (gameObject._vignette) {
            fxFactory.remove(gameObject._vignette);
            gameObject._vignette = undefined;
          }
        } else {
          if (!gameObject._vignette) {
            gameObject._vignette = fxFactory.addVignette(vignetteX, vignetteY, vignetteRadius, vignetteStrength);
          }
          gameObject._vignette.radius = vignetteRadius;
        }
      }
    });
    Object.defineProperty(gameObject, 'vignetteX', {
      get: function get() {
        return vignetteX;
      },
      set: function set(value) {
        if (vignetteX === value) {
          return;
        }
        vignetteX = value;
        if (gameObject._vignette) {
          gameObject._vignette.x = vignetteX;
        }
      }
    });
    Object.defineProperty(gameObject, 'vignetteY', {
      get: function get() {
        return vignetteY;
      },
      set: function set(value) {
        if (vignetteY === value) {
          return;
        }
        vignetteY = value;
        if (gameObject._vignette) {
          gameObject._vignette.y = vignetteY;
        }
      }
    });
    Object.defineProperty(gameObject, 'vignetteStrength', {
      get: function get() {
        return vignetteStrength;
      },
      set: function set(value) {
        if (vignetteStrength === value) {
          return;
        }
        vignetteStrength = value;
        if (gameObject._vignette) {
          gameObject._vignette.strength = vignetteStrength;
        }
      }
    });
    gameObject.vignetteRadius = null;
    AddClearEffectCallback(gameObject, 'vignetteRadius');
    return gameObject;
  };

  var AddVintagePinholeProperties = function AddVintagePinholeProperties(gameObject) {
    AddColorMatrixEffectPropertiesBase(gameObject, 'vintagePinhole');
    return gameObject;
  };

  var AddWipeProperties = function AddWipeProperties(gameObject) {
    // Don't attach properties again
    if (HasProperty(gameObject, 'wipeLeft')) {
      return gameObject;
    }
    var fxFactory = GetFXFactory(gameObject);
    if (!fxFactory) {
      return gameObject;
    }
    var wipeLeft,
      wipeRight,
      wipeUp,
      wipeDown,
      wipeWidth = 0.1;
    var ClearWipeFlags = function ClearWipeFlags() {
      wipeLeft = null;
      wipeRight = null;
      wipeUp = null;
      wipeDown = null;
    };
    var RemoveEffect = function RemoveEffect(gameObject) {
      if (gameObject._wipeEffect) {
        fxFactory.remove(gameObject._wipeEffect);
        gameObject._wipeEffect = undefined;
      }
    };
    Object.defineProperty(gameObject, 'wipeLeft', {
      get: function get() {
        return wipeLeft;
      },
      set: function set(value) {
        if (wipeLeft === value) {
          return;
        }
        ClearWipeFlags();
        wipeLeft = value;
        if (wipeLeft === null || wipeLeft === false) {
          RemoveEffect(gameObject);
        } else {
          if (!gameObject._wipeEffect) {
            gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
          }
          gameObject._wipeEffect.direction = 1;
          gameObject._wipeEffect.axis = 0;
          gameObject._wipeEffect.progress = wipeLeft;
        }
      }
    });
    Object.defineProperty(gameObject, 'wipeRight', {
      get: function get() {
        return wipeRight;
      },
      set: function set(value) {
        if (wipeRight === value) {
          return;
        }
        ClearWipeFlags();
        wipeRight = value;
        if (wipeRight === null || wipeRight === false) {
          RemoveEffect(gameObject);
        } else {
          if (!gameObject._wipeEffect) {
            gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
          }
          gameObject._wipeEffect.direction = 0;
          gameObject._wipeEffect.axis = 0;
          gameObject._wipeEffect.progress = wipeRight;
        }
      }
    });
    Object.defineProperty(gameObject, 'wipeUp', {
      get: function get() {
        return wipeUp;
      },
      set: function set(value) {
        if (wipeUp === value) {
          return;
        }
        ClearWipeFlags();
        wipeUp = value;
        if (wipeUp === null || wipeUp === false) {
          RemoveEffect(gameObject);
        } else {
          if (!gameObject._wipeEffect) {
            gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
          }
          gameObject._wipeEffect.direction = 1;
          gameObject._wipeEffect.axis = 1;
          gameObject._wipeEffect.progress = wipeUp;
        }
      }
    });
    Object.defineProperty(gameObject, 'wipeDown', {
      get: function get() {
        return wipeDown;
      },
      set: function set(value) {
        if (wipeDown === value) {
          return;
        }
        ClearWipeFlags();
        wipeDown = value;
        if (wipeDown === null || wipeDown === false) {
          RemoveEffect(gameObject);
        } else {
          if (!gameObject._wipeEffect) {
            gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
          }
          gameObject._wipeEffect.direction = 0;
          gameObject._wipeEffect.axis = 1;
          gameObject._wipeEffect.progress = wipeDown;
        }
      }
    });
    Object.defineProperty(gameObject, 'wipeWidth', {
      get: function get() {
        return wipeWidth;
      },
      set: function set(value) {
        if (wipeWidth === value) {
          return;
        }
        wipeWidth = value;
        if (gameObject._wipeEffect) {
          gameObject._wipeEffect.wipeWidth = wipeWidth;
        }
      }
    });
    gameObject.wipeLeft = null;
    AddClearEffectCallback(gameObject, 'wipeLeft');
    AddClearEffectCallback(gameObject, 'wipeRight');
    AddClearEffectCallback(gameObject, 'wipeUp');
    AddClearEffectCallback(gameObject, 'wipeDown');
    return gameObject;
  };

  var EffectMap = {
    barrel: AddBarrelProperties,
    blackWhite: AddBlackWhiteProperties,
    bloom: AddBloomProperties,
    blur: AddBlurProperties,
    bokeh: AddBokehProperties,
    brightness: AddBrightnessProperties,
    brown: AddBrownProperties,
    circle: AddCircleProperties,
    contrast: AddContrastProperties,
    desaturate: AddDesaturateProperties,
    desaturateLuminance: AddDesaturateLuminanceProperties,
    displacement: AddDisplacementProperties,
    glow: AddGlowProperties,
    gradient: AddGradientProperties,
    grayscale: AddGrayscaleProperties,
    hue: AddHueProperties,
    kodachrome: AddKodachromeProperties,
    lsd: AddLSDProperties,
    negative: AddNegativeProperties,
    pixelate: AddPixelateProperties,
    polaroid: AddPolaroidProperties,
    reveal: AddRevealProperties,
    saturate: AddSaturateProperties,
    sepia: AddSepiaProperties,
    shadow: AddShadowProperties,
    shiftToBGR: AddShiftToBGRProperties,
    shine: AddShineProperties,
    technicolor: AddTechnicolorProperties,
    tiltShift: AddTiltShiftProperties,
    vignette: AddVignetteProperties,
    vintagePinhole: AddVintagePinholeProperties,
    wipe: AddWipeProperties
  };

  var AddEffectProperties = function AddEffectProperties(gameObject, config) {
    if (config === undefined) {
      config = true;
    } else if (typeof config === 'string') {
      config = {
        config: true
      };
    } else if (Array.isArray(config)) {
      var nameList = config;
      var config = {};
      for (var i = 0, cnt = nameList.length; i < cnt; i++) {
        config[nameList[i]] = true;
      }
    }
    if (config === true) {
      // Enable all effect properties
      for (var name in EffectMap) {
        EffectMap[name](gameObject);
      }
    } else {
      for (var name in config) {
        if (config[name] && EffectMap[name]) {
          EffectMap[name](gameObject);
        }
      }
    }
    return gameObject;
  };

  var RemoveItem$d = Phaser.Utils.Array.Remove;
  var AddMethods$1 = {
    addGO: function addGO(name, gameObject) {
      this.remove(name, true);
      if (this.useTintFadeEffect(gameObject)) {
        AddTintRGBProperties(gameObject);
      }
      if (this.viewportCoordinateEnable) {
        AddViewportCoordinateProperties(gameObject, this.viewport);
      }
      if (this.effectPropertiesConfig) {
        AddEffectProperties(gameObject, this.effectPropertiesConfig);
      }
      gameObject.once('destroy', function () {
        RemoveItem$d(this.removedGOs, gameObject);
        if (this.isEmpty) {
          this.emit('empty');
        }
      }, this);
      var bob = new this.BobClass(this, gameObject, name);
      this.bobs[name] = bob;
      return this;
    },
    add: function add(name) {
      var callback = this.createGameObjectCallback;
      var scope = this.createGameObjectScope;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var gameObject = callback.call.apply(callback, [scope, this.scene].concat(args));
      this.addGO(name, gameObject);
      if (this.gameObjectDepth != null) {
        // Not undefined, null
        gameObject.setDepth(this.gameObjectDepth);
      }
      var bob = this.get(name);
      this.fadeBob(bob, 0, 1);
      return this;
    }
  };

  var RemoveMethods$1 = {
    remove: function remove(name, ignoreFade) {
      if (!this.has(name)) {
        return this;
      }
      var bob = this.get(name);
      delete this.bobs[name];
      this.removedGOs.push(bob.gameObject);
      if (!ignoreFade) {
        this.fadeBob(bob,
        // bob
        undefined,
        // fromValue
        0,
        // toValue
        function () {
          // onComplete
          bob.destroy();
        });
      } else {
        bob.destroy();
      }
      return this;
    },
    removeAll: function removeAll() {
      var bobs = this.bobs;
      for (var name in bobs) {
        this.remove(name);
      }
      return this;
    },
    clear: function clear(destroyChild) {
      if (destroyChild === undefined) {
        destroyChild = true;
      }
      var bobs = this.bobs;
      for (var name in bobs) {
        if (destroyChild) {
          bobs[name].destroy();
        }
        delete bobs[name];
      }
      this.removedGOs.length = 0;
      return this;
    }
  };

  var PropertyMethods = {
    hasProperty: function hasProperty(name, property) {
      if (!this.has(name)) {
        return false;
      }
      return this.get(name).hasProperty(property);
    },
    getProperty: function getProperty(name, property) {
      if (!this.has(name)) {
        return undefined;
      }
      return this.get(name).getProperty(property);
    },
    isNumberProperty: function isNumberProperty(name, property) {
      var value = this.getProperty(name, property);
      return typeof value === 'number';
    },
    setProperty: function setProperty(name, property, value) {
      if (!this.has(name)) {
        return this;
      }
      if (this.symbols && typeof value === 'string' && this.isNumberProperty(name, property)) {
        if (value in this.symbols) {
          value = this.symbols[value];
        } else {
          console.warn("Can't find symbol ".concat(value));
        }
      }
      this.get(name).setProperty(property, value);
      return this;
    },
    easeProperty: function easeProperty(name, property, value, duration, ease, repeat, isYoyo, onComplete) {
      if (!this.has(name)) {
        return this;
      }
      if (duration === undefined) {
        duration = 1000;
      }
      if (ease === undefined) {
        ease = 'Linear';
      }
      if (repeat === undefined) {
        repeat = 0;
      }
      if (isYoyo === undefined) {
        isYoyo = false;
      }
      if (this.symbols && typeof value === 'string' && this.isNumberProperty(name, property)) {
        if (value in this.symbols) {
          value = this.symbols[value];
        } else {
          console.warn("Can't find symbol ".concat(value));
        }
      }
      this.get(name).easeProperty(property, value, duration, ease, repeat, isYoyo, onComplete);
      return this;
    },
    hasTweenTask: function hasTweenTask(name, property) {
      if (!this.has(name)) {
        return false;
      }
      var tweenTasks = this.get(name).tweens;
      return tweenTasks.hasOwnProperty(property);
    },
    getTweenTask: function getTweenTask(name, property) {
      if (!this.has(name)) {
        return null;
      }
      var tweenTasks = this.get(name).tweens;
      var tweenTask = tweenTasks[property];
      return tweenTask ? tweenTask : null;
    }
  };

  var CallMethods = {
    hasMethod: function hasMethod(name, methodName) {
      if (!this.has(name)) {
        return false;
      }
      return this.get(name).hasMethod(methodName);
    },
    call: function call(name, methodName) {
      var _this$get;
      if (!this.has(name)) {
        return this;
      }
      for (var _len = arguments.length, parameters = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        parameters[_key - 2] = arguments[_key];
      }
      (_this$get = this.get(name)).call.apply(_this$get, [methodName].concat(parameters));
      return this;
    }
  };

  var DataMethods$1 = {
    hasData: function hasData(name, dataKey) {
      if (!this.has(name)) {
        return false;
      }
      return this.get(name).hasData(dataKey);
    },
    getData: function getData(name, dataKey) {
      if (!this.has(name)) {
        return undefined;
      }
      return this.get(name).getData(dataKey);
    },
    setData: function setData(name, dataKey, value) {
      if (!this.has(name)) {
        return this;
      }
      this.get(name).setData(dataKey, value);
      return this;
    }
  };

  var FadeTint = 0;
  var FadeAlpha = 1;
  var FadeRevealUp = 2;
  var FadeRevealDown = 3;
  var FadeRevealLeft = 4;
  var FadeRevealRight = 5;
  var FadeMode = {
    tint: FadeTint,
    alpha: FadeAlpha,
    revealUp: FadeRevealUp,
    revealDown: FadeRevealDown,
    revealLeft: FadeRevealLeft,
    revealRight: FadeRevealRight
  };
  var FadeMethods$1 = {
    setGOFadeMode: function setGOFadeMode(fadeMode) {
      if (typeof fadeMode === 'string') {
        fadeMode = FadeMode[fadeMode];
      }
      this.fadeMode = fadeMode;
      return this;
    },
    setGOFadeTime: function setGOFadeTime(time) {
      this.fadeTime = time;
      return this;
    },
    useTintFadeEffect: function useTintFadeEffect(gameObject) {
      return (this.fadeMode === undefined || this.fadeMode === FadeTint) && this.fadeTime > 0 && gameObject.setTint !== undefined;
    },
    useAlphaFadeEffect: function useAlphaFadeEffect(gameObject) {
      return (this.fadeMode === undefined || this.fadeMode === FadeAlpha) && this.fadeTime > 0 && gameObject.setAlpha !== undefined;
    },
    useRevealEffect: function useRevealEffect(gameObject) {
      return this.fadeMode >= FadeRevealUp && this.fadeMode <= FadeRevealRight && this.fadeTime > 0 && (gameObject.preFX || gameObject.postFX);
    },
    fadeBob: function fadeBob(bob, fromValue, toValue, onComplete) {
      var gameObject = bob.gameObject;
      if (this.useTintFadeEffect(gameObject)) {
        if (fromValue !== undefined) {
          bob.setProperty('tintGray', 255 * fromValue);
        }
        bob.easeProperty('tintGray',
        // property
        Math.floor(255 * toValue),
        // to value
        this.fadeTime,
        // duration
        'Linear',
        // ease
        0,
        // repeat
        false,
        // yoyo
        onComplete // onComplete
        );
      } else if (this.useAlphaFadeEffect(gameObject)) {
        if (fromValue !== undefined) {
          bob.setProperty('alpha', fromValue);
        }
        bob.easeProperty('alpha',
        // property
        toValue,
        // to value
        this.fadeTime,
        // duration
        'Linear',
        // ease
        0,
        // repeat
        false,
        // yoyo
        onComplete // onComplete
        );
      } else if (this.useRevealEffect(gameObject)) {
        AddEffectProperties(gameObject, 'reveal');
        var propertyName;
        switch (this.fadeMode) {
          case FadeRevealUp:
            propertyName = 'revealUp';
            break;
          case FadeRevealDown:
            propertyName = 'revealDown';
            break;
          case FadeRevealLeft:
            propertyName = 'revealLeft';
            break;
          case FadeRevealRight:
            propertyName = 'revealRight';
            break;
        }
        if (fromValue === undefined) {
          fromValue = 0;
        }
        gameObject[propertyName] = fromValue;
        bob.easeProperty(propertyName,
        // property
        toValue,
        // to value
        this.fadeTime,
        // duration
        'Linear',
        // ease
        0,
        // repeat
        false,
        // yoyo
        onComplete // onComplete
        );
        bob.getTweenTask(propertyName).once('complete', function () {
          gameObject[propertyName] = null;
        });
      } else {
        if (onComplete) {
          onComplete(gameObject);
        }
      }
      return this;
    }
  };

  var GetDisplayWidth = function GetDisplayWidth(gameObject) {
    if (gameObject.displayWidth !== undefined) {
      return gameObject.displayWidth;
    } else {
      return gameObject.width;
    }
  };
  var GetDisplayHeight = function GetDisplayHeight(gameObject) {
    if (gameObject.displayHeight !== undefined) {
      return gameObject.displayHeight;
    } else {
      return gameObject.height;
    }
  };

  var Rectangle$6 = Phaser.Geom.Rectangle;
  var Vector2 = Phaser.Math.Vector2;
  var RotateAround$8 = Phaser.Math.RotateAround;
  var GetBounds = function GetBounds(gameObject, output) {
    if (output === undefined) {
      output = new Rectangle$6();
    } else if (output === true) {
      if (GlobRect$2 === undefined) {
        GlobRect$2 = new Rectangle$6();
      }
      output = GlobRect$2;
    }
    if (gameObject.getBounds) {
      return gameObject.getBounds(output);
    }

    //  We can use the output object to temporarily store the x/y coords in:

    var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;

    // Instead of doing a check if parent container is
    // defined per corner we only do it once.
    if (gameObject.parentContainer) {
      var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();
      GetTopLeft(gameObject, output);
      parentMatrix.transformPoint(output.x, output.y, output);
      TLx = output.x;
      TLy = output.y;
      GetTopRight(gameObject, output);
      parentMatrix.transformPoint(output.x, output.y, output);
      TRx = output.x;
      TRy = output.y;
      GetBottomLeft(gameObject, output);
      parentMatrix.transformPoint(output.x, output.y, output);
      BLx = output.x;
      BLy = output.y;
      GetBottomRight(gameObject, output);
      parentMatrix.transformPoint(output.x, output.y, output);
      BRx = output.x;
      BRy = output.y;
    } else {
      GetTopLeft(gameObject, output);
      TLx = output.x;
      TLy = output.y;
      GetTopRight(gameObject, output);
      TRx = output.x;
      TRy = output.y;
      GetBottomLeft(gameObject, output);
      BLx = output.x;
      BLy = output.y;
      GetBottomRight(gameObject, output);
      BRx = output.x;
      BRy = output.y;
    }
    output.x = Math.min(TLx, TRx, BLx, BRx);
    output.y = Math.min(TLy, TRy, BLy, BRy);
    output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
    output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
    return output;
  };
  var GlobRect$2 = undefined;
  var GetTopLeft = function GetTopLeft(gameObject, output, includeParent) {
    if (output === undefined) {
      output = new Vector2();
    } else if (output === true) {
      if (GlobVector === undefined) {
        GlobVector = new Vector2();
      }
      output = GlobVector;
    }
    if (gameObject.getTopLeft) {
      return gameObject.getTopLeft(output);
    }
    output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX;
    output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY;
    return PrepareBoundsOutput(gameObject, output, includeParent);
  };
  var GetTopRight = function GetTopRight(gameObject, output, includeParent) {
    if (output === undefined) {
      output = new Vector2();
    } else if (output === true) {
      if (GlobVector === undefined) {
        GlobVector = new Vector2();
      }
      output = GlobVector;
    }
    if (gameObject.getTopRight) {
      return gameObject.getTopRight(output);
    }
    output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX + GetDisplayWidth(gameObject);
    output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY;
    return PrepareBoundsOutput(gameObject, output, includeParent);
  };
  var GetBottomLeft = function GetBottomLeft(gameObject, output, includeParent) {
    if (output === undefined) {
      output = new Vector2();
    } else if (output === true) {
      if (GlobVector === undefined) {
        GlobVector = new Vector2();
      }
      output = GlobVector;
    }
    if (gameObject.getBottomLeft) {
      return gameObject.getBottomLeft(output);
    }
    output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX;
    output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY + GetDisplayHeight(gameObject);
    return PrepareBoundsOutput(gameObject, output, includeParent);
  };
  var GetBottomRight = function GetBottomRight(gameObject, output, includeParent) {
    if (output === undefined) {
      output = new Vector2();
    } else if (output === true) {
      if (GlobVector === undefined) {
        GlobVector = new Vector2();
      }
      output = GlobVector;
    }
    if (gameObject.getBottomRight) {
      return gameObject.getBottomRight(output);
    }
    output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX + GetDisplayWidth(gameObject);
    output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY + GetDisplayHeight(gameObject);
    return PrepareBoundsOutput(gameObject, output, includeParent);
  };
  var GlobVector = undefined;
  var PrepareBoundsOutput = function PrepareBoundsOutput(gameObject, output, includeParent) {
    if (includeParent === undefined) {
      includeParent = false;
    }
    if (gameObject.rotation !== 0) {
      RotateAround$8(output, gameObject.x, gameObject.y, gameObject.rotation);
    }
    if (includeParent && gameObject.parentContainer) {
      var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();
      parentMatrix.transformPoint(output.x, output.y, output);
    }
    return output;
  };

  var GetValue$3o = Phaser.Utils.Objects.GetValue;
  var DrawBounds$2 = function DrawBounds(gameObjects, graphics, config) {
    var strokeColor, lineWidth, fillColor, fillAlpha, padding;
    if (typeof config === 'number') {
      strokeColor = config;
    } else {
      strokeColor = GetValue$3o(config, 'color');
      lineWidth = GetValue$3o(config, 'lineWidth');
      fillColor = GetValue$3o(config, 'fillColor');
      fillAlpha = GetValue$3o(config, 'fillAlpha', 1);
      padding = GetValue$3o(config, 'padding', 0);
    }
    if (Array.isArray(gameObjects)) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Draw(gameObjects[i], graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
      }
    } else {
      Draw(gameObjects, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
    }
  };
  var Draw = function Draw(gameObject, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding) {
    var canDrawBound = gameObject.getBounds || gameObject.width !== undefined && gameObject.height !== undefined;
    if (!canDrawBound) {
      return;
    }
    if (strokeColor === undefined) {
      strokeColor = 0xffffff;
    }
    if (lineWidth === undefined) {
      lineWidth = 1;
    }
    if (fillColor === undefined) {
      fillColor = null;
    }
    if (fillAlpha === undefined) {
      fillAlpha = 1;
    }
    if (padding === undefined) {
      padding = 0;
    }
    var p0 = GetTopLeft(gameObject, Points[0]);
    p0.x -= padding;
    p0.y -= padding;
    var p1 = GetTopRight(gameObject, Points[1]);
    p1.x += padding;
    p1.y -= padding;
    var p2 = GetBottomRight(gameObject, Points[2]);
    p2.x += padding;
    p2.y += padding;
    var p3 = GetBottomLeft(gameObject, Points[3]);
    p3.x -= padding;
    p3.y += padding;
    if (fillColor !== null) {
      graphics.fillStyle(fillColor, fillAlpha).fillPoints(Points, true, true);
    }
    if (strokeColor !== null) {
      graphics.lineStyle(lineWidth, strokeColor).strokePoints(Points, true, true);
    }
  };
  var Points = [{
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }];

  var DrawGameObjectsBounds = function DrawGameObjectsBounds(graphics, config) {
    this.forEachGO(function (gameObject) {
      if (gameObject.drawBounds) {
        gameObject.drawBounds(graphics, config);
      } else {
        DrawBounds$2(gameObject, graphics, config);
      }
    });
    return this;
  };

  var Methods$m = {
    drawGameObjectsBounds: DrawGameObjectsBounds
  };
  Object.assign(Methods$m, GetMethods, AddMethods$1, RemoveMethods$1, PropertyMethods, CallMethods, DataMethods$1, FadeMethods$1);

  var CameraClass = Phaser.Cameras.Scene2D.BaseCamera;
  var IsCameraObject = function IsCameraObject(object) {
    return object instanceof CameraClass;
  };

  var Rectangle$5 = Phaser.Geom.Rectangle;
  var GetViewport = function GetViewport(scene, camera, out) {
    if (!IsCameraObject(camera)) {
      out = camera;
      camera = undefined;
    }
    if (out === undefined) {
      out = new Rectangle$5();
    } else if (out === true) {
      out = globRect;
    }
    if (camera) {
      return scene.scale.getViewPort(camera, out);
    } else {
      return scene.scale.getViewPort(out);
    }
  };
  var globRect = new Rectangle$5();

  var GetValue$3n = Phaser.Utils.Objects.GetValue;
  var GOManager = /*#__PURE__*/function () {
    function GOManager(scene, config) {
      _classCallCheck(this, GOManager);
      this.scene = scene;
      this.BobClass = GetValue$3n(config, 'BobClass', BobBase);
      this.setCreateGameObjectCallback(GetValue$3n(config, 'createGameObject'), GetValue$3n(config, 'createGameObjectScope'));
      this.setEventEmitter(GetValue$3n(config, 'eventEmitter', undefined));
      this.setGameObjectDepth(GetValue$3n(config, 'depth', undefined));
      var fadeConfig = GetValue$3n(config, 'fade', 500);
      if (typeof fadeConfig === 'number') {
        this.setGOFadeMode();
        this.setGOFadeTime(fadeConfig);
      } else {
        this.setGOFadeMode(GetValue$3n(fadeConfig, 'mode'));
        this.setGOFadeTime(GetValue$3n(fadeConfig, 'time', 500));
      }
      var viewportCoordinateConfig = GetValue$3n(config, 'viewportCoordinate', false);
      if (viewportCoordinateConfig !== false) {
        this.setViewportCoordinateEnable(GetValue$3n(config, 'enable', true));
        this.setViewport(GetValue$3n(viewportCoordinateConfig, 'viewport'));
      } else {
        this.setViewportCoordinateEnable(false);
      }
      var effectPropertiesConfig = GetValue$3n(config, 'effectProperties', false);
      this.setEffectPropertiesConfig(effectPropertiesConfig);
      this.setSymbols(GetValue$3n(config, 'symbols'));
      this.bobs = {};
      this.removedGOs = [];
      this._timeScale = 1;
    }
    _createClass(GOManager, [{
      key: "destroy",
      value: function destroy(fromScene) {
        this.clear(!fromScene);
        this.createGameObjectCallback = undefined;
        this.viewport = undefined;
        this.scene = undefined;
      }
    }, {
      key: "timeScale",
      get: function get() {
        return this._timeScale;
      },
      set: function set(timeScale) {
        if (this._timeScale === timeScale) {
          return;
        }
        this._timeScale = timeScale;
        var bobs = this.bobs;
        for (var name in bobs) {
          bobs[name].setTimeScale(timeScale);
        }
      }
    }, {
      key: "setTimeScale",
      value: function setTimeScale(timeScale) {
        this.timeScale = timeScale;
        return this;
      }
    }, {
      key: "setCreateGameObjectCallback",
      value: function setCreateGameObjectCallback(callback, scope) {
        this.createGameObjectCallback = callback;
        this.createGameObjectScope = scope;
        return this;
      }
    }, {
      key: "setGameObjectDepth",
      value: function setGameObjectDepth(depth) {
        this.gameObjectDepth = depth;
        return this;
      }
    }, {
      key: "setViewportCoordinateEnable",
      value: function setViewportCoordinateEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.viewportCoordinateEnable = enable;
        return this;
      }
    }, {
      key: "setEffectPropertiesConfig",
      value: function setEffectPropertiesConfig(config) {
        if (config === undefined) {
          config = true;
        }
        this.effectPropertiesConfig = config;
        return this;
      }
    }, {
      key: "setViewport",
      value: function setViewport(viewport) {
        if (viewport === undefined) {
          viewport = GetViewport(this.scene, this.scene.cameras.main);
        }
        this.viewport = viewport;
        return this;
      }
    }, {
      key: "setSymbols",
      value: function setSymbols(symbols) {
        this.symbols = symbols;
        return this;
      }
    }, {
      key: "isEmpty",
      get: function get() {
        return IsEmpty(this.bobs) && this.removedGOs.length === 0;
      }
    }]);
    return GOManager;
  }();
  Object.assign(GOManager.prototype, EventEmitterMethods$1, Methods$m);

  var SortGameObjectsByDepth = function SortGameObjectsByDepth(gameObjects, descending) {
    if (gameObjects.length <= 1) {
      return gameObjects;
    }
    if (descending === undefined) {
      descending = false;
    }
    var itemList;
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var gameObject = gameObjects[i];
      if (gameObject.displayList) {
        // Inside a scene or a layer
        itemList = gameObject.displayList; // displayList
      } else if (gameObject.parentContainer) {
        // Inside a container
        itemList = gameObject.parentContainer.list; // array
      }
      if (itemList) {
        break;
      }
    }
    if (!itemList) {
      itemList = gameObject.scene.sys.displayList; // displayList
      // ??
    }
    if (itemList.depthSort) {
      // Is a displayList object
      itemList.depthSort();
      itemList = itemList.list;
      // itemList is an array now
    }

    // itemList is an array
    if (descending) {
      gameObjects.sort(function (childA, childB) {
        return itemList.indexOf(childB) - itemList.indexOf(childA);
      });
    } else {
      gameObjects.sort(function (childA, childB) {
        return itemList.indexOf(childA) - itemList.indexOf(childB);
      });
    }
    return gameObjects;
  };

  var GetValue$3m = Phaser.Utils.Objects.GetValue;
  var LayerManager = /*#__PURE__*/function (_GOManager) {
    _inherits(LayerManager, _GOManager);
    function LayerManager(scene, config) {
      var _this;
      _classCallCheck(this, LayerManager);
      if (config === undefined) {
        config = {};
      } else if (Array.isArray(config)) {
        config = {
          layers: config
        };
      }
      if (!config.hasOwnProperty('fade')) {
        config.fade = 0;
      }
      config.viewportCoordinate = false;
      _this = _callSuper(this, LayerManager, [scene, config]);
      var rootLayer = GetValue$3m(config, 'rootLayer');
      _this.setRootLayer(rootLayer);
      var initLayers = GetValue$3m(config, 'layers');
      if (initLayers) {
        for (var i = 0, cnt = initLayers.length; i < cnt; i++) {
          _this.add(initLayers[i]);
        }
      }
      return _this;
    }
    _createClass(LayerManager, [{
      key: "setCreateGameObjectCallback",
      value: function setCreateGameObjectCallback(callback, scope) {
        if (!callback) {
          callback = CreateLayer;
        }
        _get(_getPrototypeOf(LayerManager.prototype), "setCreateGameObjectCallback", this).call(this, callback, scope);
        return this;
      }
    }, {
      key: "setRootLayer",
      value: function setRootLayer(rootLayer) {
        if (rootLayer === this.rootLayer) {
          return this;
        }
        var currentLayers = this.getAllGO();
        if (rootLayer) {
          rootLayer.add(currentLayers);
        } else {
          this.scene.displayList.add(currentLayers);
        }
        this.rootLayer = rootLayer;
        return this;
      }

      // Override
    }, {
      key: "addGO",
      value: function addGO(name, gameObject) {
        _get(_getPrototypeOf(LayerManager.prototype), "addGO", this).call(this, name, gameObject);
        gameObject.name = name;
        if (this.rootLayer) {
          this.rootLayer.add(gameObject);
        }
        return this;
      }

      // New methods
    }, {
      key: "getLayer",
      value: function getLayer(name) {
        return this.getGO(name);
      }
    }, {
      key: "getLayers",
      value: function getLayers(out) {
        if (out === undefined) {
          out = [];
        }
        this.forEachGO(function (gameObject) {
          out.push(gameObject);
        });
        SortGameObjectsByDepth(out, false);
        return out;
      }
    }, {
      key: "addToLayer",
      value: function addToLayer(name, gameObject) {
        var layer = this.getGO(name);
        if (!layer) {
          console.warn("[LayerManager] Can't get layer \"".concat(name, "\""));
          return;
        }
        if (gameObject.isRexContainerLite) {
          gameObject.addToLayer(layer);
        } else {
          layer.add(gameObject);
        }
        return this;
      }
    }, {
      key: "removeFromLayer",
      value: function removeFromLayer(name, gameObject, addToScene) {
        var layer = this.getGO(name);
        if (!layer) {
          console.warn("[LayerManager] Can't get layer \"".concat(name, "\""));
          return;
        }
        if (addToScene === undefined) {
          addToScene = true;
        }
        if (gameObject.isRexContainerLite) {
          gameObject.removeFromLayer(layer, addToScene);
        } else {
          layer.remove(gameObject);
          if (addToScene) {
            gameObject.addToDisplayList();
          }
        }
        return this;
      }
    }, {
      key: "clearLayer",
      value: function clearLayer(name, destroyChildren) {
        if (destroyChildren === undefined) {
          destroyChildren = true;
        }
        var layer = this.getGO(name);
        if (!layer) {
          console.warn("Can't get layer \"".concat(name, "\""));
          return;
        }
        if (destroyChildren) {
          var children = layer.getAll();
          for (var i = 0, cnt = children.length; i < cnt; i++) {
            children.destroy();
          }
        } else {
          layer.removeAll();
        }
        return this;
      }
    }]);
    return LayerManager;
  }(GOManager);
  var CreateLayer = function CreateLayer(scene, depth) {
    var layer = scene.add.layer();
    if (depth !== undefined) {
      layer.setDepth(depth);
    }
    return layer;
  };

  var SceneClass = Phaser.Scene;
  var IsSceneObject = function IsSceneObject(object) {
    return object instanceof SceneClass;
  };

  var GetSoundManager = function GetSoundManager(game) {
    if (IsSceneObject(game)) {
      return game.sys.sound;
    }
    return game.sound;
  };

  var HasaAudio = function HasaAudio(key) {
    return this.sound.game.cache.audio.has(key);
  };

  var GetSceneObject = function GetSceneObject(object) {
    if (object == null || _typeof(object) !== 'object') {
      return null;
    } else if (IsSceneObject(object)) {
      // object = scene
      return object;
    } else if (object.scene && IsSceneObject(object.scene)) {
      // object = game object
      return object.scene;
    } else if (object.parent && object.parent.scene && IsSceneObject(object.parent.scene)) {
      // parent = bob object
      return object.parent.scene;
    } else {
      return null;
    }
  };

  var GameClass = Phaser.Game;
  var IsGame = function IsGame(object) {
    return object instanceof GameClass;
  };

  var GetGame = function GetGame(object) {
    if (object == null || _typeof(object) !== 'object') {
      return null;
    } else if (IsGame(object)) {
      return object;
    } else if (IsGame(object.game)) {
      return object.game;
    } else if (IsSceneObject(object)) {
      // object = scene object
      return object.sys.game;
    } else if (IsSceneObject(object.scene)) {
      // object = game object
      return object.scene.sys.game;
    }
  };

  var GetValue$3l = Phaser.Utils.Objects.GetValue;
  var ComponentBase = /*#__PURE__*/function () {
    function ComponentBase(parent, config) {
      _classCallCheck(this, ComponentBase);
      this.setParent(parent); // gameObject, scene, or game

      this.isShutdown = false;

      // Event emitter, default is private event emitter
      this.setEventEmitter(GetValue$3l(config, 'eventEmitter', true));

      // Register callback of parent destroy event, also see `shutdown` method
      if (this.parent) {
        if (this.parent === this.scene) {
          // parent is a scene
          this.scene.sys.events.once('shutdown', this.onEnvDestroy, this);
        } else if (this.parent === this.game) {
          // parent is game
          this.game.events.once('shutdown', this.onEnvDestroy, this);
        } else if (this.parent.once) {
          // parent is game object or something else
          this.parent.once('destroy', this.onParentDestroy, this);
        }

        // bob object does not have event emitter
      }
    }
    _createClass(ComponentBase, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        // parent might not be shutdown yet
        if (this.parent) {
          if (this.parent === this.scene) {
            // parent is a scene
            this.scene.sys.events.off('shutdown', this.onEnvDestroy, this);
          } else if (this.parent === this.game) {
            // parent is game
            this.game.events.off('shutdown', this.onEnvDestroy, this);
          } else if (this.parent.once) {
            // parent is game object or something else
            this.parent.off('destroy', this.onParentDestroy, this);
          }

          // bob object does not have event emitter
        }
        this.destroyEventEmitter();
        this.parent = undefined;
        this.scene = undefined;
        this.game = undefined;
        this.isShutdown = true;
      }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        this.shutdown(fromScene);
      }
    }, {
      key: "onEnvDestroy",
      value: function onEnvDestroy() {
        this.destroy(true);
      }
    }, {
      key: "onParentDestroy",
      value: function onParentDestroy(parent, fromScene) {
        this.destroy(fromScene);
      }
    }, {
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent; // gameObject, scene, or game

        this.scene = GetSceneObject(parent);
        this.game = GetGame(parent);
        return this;
      }
    }]);
    return ComponentBase;
  }();
  Object.assign(ComponentBase.prototype, EventEmitterMethods$1);

  var GetValue$3k = Phaser.Utils.Objects.GetValue;
  var TickTask = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TickTask, _ComponentBase);
    function TickTask(parent, config) {
      var _this;
      _classCallCheck(this, TickTask);
      _this = _callSuper(this, TickTask, [parent, config]);
      _this._isRunning = false;
      _this.isPaused = false;
      _this.tickingState = false;
      _this.setTickingMode(GetValue$3k(config, 'tickingMode', 1));
      // boot() later
      return _this;
    }

    // override
    _createClass(TickTask, [{
      key: "boot",
      value: function boot() {
        if (this.tickingMode === 2 && !this.tickingState) {
          this.startTicking();
        }
      }

      // override
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        this.stop();
        if (this.tickingState) {
          this.stopTicking();
        }
        _get(_getPrototypeOf(TickTask.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "setTickingMode",
      value: function setTickingMode(mode) {
        if (typeof mode === 'string') {
          mode = TICKINGMODE[mode];
        }
        this.tickingMode = mode;
      }

      // override
    }, {
      key: "startTicking",
      value: function startTicking() {
        this.tickingState = true;
      }

      // override
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        this.tickingState = false;
      }
    }, {
      key: "isRunning",
      get: function get() {
        return this._isRunning;
      },
      set: function set(value) {
        if (this._isRunning === value) {
          return;
        }
        this._isRunning = value;
        if (this.tickingMode === 1 && value != this.tickingState) {
          if (value) {
            this.startTicking();
          } else {
            this.stopTicking();
          }
        }
      }
    }, {
      key: "start",
      value: function start() {
        this.isPaused = false;
        this.isRunning = true;
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        // Only can ba paused in running state
        if (this.isRunning) {
          this.isPaused = true;
          this.isRunning = false;
        }
        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        // Only can ba resumed in paused state (paused from running state)
        if (this.isPaused) {
          this.isRunning = true;
        }
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.isPaused = false;
        this.isRunning = false;
        return this;
      }
    }, {
      key: "complete",
      value: function complete() {
        this.isPaused = false;
        this.isRunning = false;
        this.emit('complete', this.parent, this);
      }
    }]);
    return TickTask;
  }(ComponentBase);
  var TICKINGMODE = {
    'no': 0,
    'lazy': 1,
    'always': 2
  };

  var GetValue$3j = Phaser.Utils.Objects.GetValue;
  var SceneUpdateTickTask = /*#__PURE__*/function (_TickTask) {
    _inherits(SceneUpdateTickTask, _TickTask);
    function SceneUpdateTickTask(parent, config) {
      var _this;
      _classCallCheck(this, SceneUpdateTickTask);
      _this = _callSuper(this, SceneUpdateTickTask, [parent, config]);

      // scene update : update, preupdate, postupdate, prerender, render
      // game update : step, poststep, 

      // If this.scene is not available, use game's 'step' event
      var defaultEventName = _this.scene ? 'update' : 'step';
      _this.tickEventName = GetValue$3j(config, 'tickEventName', defaultEventName);
      _this.isSceneTicker = !IsGameUpdateEvent(_this.tickEventName);
      return _this;
    }
    _createClass(SceneUpdateTickTask, [{
      key: "startTicking",
      value: function startTicking() {
        _get(_getPrototypeOf(SceneUpdateTickTask.prototype), "startTicking", this).call(this);
        if (this.isSceneTicker) {
          this.scene.sys.events.on(this.tickEventName, this.update, this);
        } else {
          this.game.events.on(this.tickEventName, this.update, this);
        }
      }
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        _get(_getPrototypeOf(SceneUpdateTickTask.prototype), "stopTicking", this).call(this);
        if (this.isSceneTicker && this.scene) {
          // Scene might be destoryed
          this.scene.sys.events.off(this.tickEventName, this.update, this);
        } else if (this.game) {
          this.game.events.off(this.tickEventName, this.update, this);
        }
      }

      // update(time, delta) {
      //     
      // }
    }]);
    return SceneUpdateTickTask;
  }(TickTask);
  var IsGameUpdateEvent = function IsGameUpdateEvent(eventName) {
    return eventName === 'step' || eventName === 'poststep';
  };

  var GetValue$3i = Phaser.Utils.Objects.GetValue;
  var Clamp$f = Phaser.Math.Clamp;
  var Timer$1 = /*#__PURE__*/function () {
    function Timer(config) {
      _classCallCheck(this, Timer);
      this.resetFromJSON(config);
    }
    _createClass(Timer, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.state = GetValue$3i(o, 'state', IDLE$6);
        this.timeScale = GetValue$3i(o, 'timeScale', 1);
        this.delay = GetValue$3i(o, 'delay', 0);
        this.repeat = GetValue$3i(o, 'repeat', 0);
        this.repeatCounter = GetValue$3i(o, 'repeatCounter', 0);
        this.repeatDelay = GetValue$3i(o, 'repeatDelay', 0);
        this.duration = GetValue$3i(o, 'duration', 0);
        this.nowTime = GetValue$3i(o, 'nowTime', 0);
        this.justRestart = GetValue$3i(o, 'justRestart', false);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          state: this.state,
          timeScale: this.timeScale,
          delay: this.delay,
          repeat: this.repeat,
          repeatCounter: this.repeatCounter,
          repeatDelay: this.repeatDelay,
          duration: this.duration,
          nowTime: this.nowTime,
          justRestart: this.justRestart
        };
      }
    }, {
      key: "destroy",
      value: function destroy() {}
    }, {
      key: "setTimeScale",
      value: function setTimeScale(timeScale) {
        this.timeScale = timeScale;
        return this;
      }
    }, {
      key: "setDelay",
      value: function setDelay(delay) {
        if (delay === undefined) {
          delay = 0;
        }
        this.delay = delay;
        return this;
      }
    }, {
      key: "setDuration",
      value: function setDuration(duration) {
        this.duration = duration;
        return this;
      }
    }, {
      key: "setRepeat",
      value: function setRepeat(repeat) {
        this.repeat = repeat;
        return this;
      }
    }, {
      key: "setRepeatInfinity",
      value: function setRepeatInfinity() {
        this.repeat = -1;
        return this;
      }
    }, {
      key: "setRepeatDelay",
      value: function setRepeatDelay(repeatDelay) {
        this.repeatDelay = repeatDelay;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        this.nowTime = this.delay > 0 ? -this.delay : 0;
        this.state = this.nowTime >= 0 ? COUNTDOWN : DELAY;
        this.repeatCounter = 0;
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.state = IDLE$6;
        return this;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (this.state === IDLE$6 || this.state === DONE || delta === 0 || this.timeScale === 0) {
          return;
        }
        this.nowTime += delta * this.timeScale;
        this.justRestart = false;
        if (this.nowTime >= this.duration) {
          if (this.repeat === -1 || this.repeatCounter < this.repeat) {
            this.repeatCounter++;
            this.justRestart = true;
            this.nowTime -= this.duration;
            if (this.repeatDelay > 0) {
              this.nowTime -= this.repeatDelay;
              this.state = REPEATDELAY;
            }
          } else {
            this.nowTime = this.duration;
            this.state = DONE;
          }
        } else if (this.nowTime >= 0) {
          this.state = COUNTDOWN;
        }
      }
    }, {
      key: "t",
      get: function get() {
        var t;
        switch (this.state) {
          case IDLE$6:
          case DELAY:
          case REPEATDELAY:
            t = 0;
            break;
          case COUNTDOWN:
            t = this.nowTime / this.duration;
            break;
          case DONE:
            t = 1;
            break;
        }
        return Clamp$f(t, 0, 1);
      },
      set: function set(value) {
        value = Clamp$f(value, -1, 1);
        if (value < 0) {
          this.state = DELAY;
          this.nowTime = -this.delay * value;
        } else {
          this.state = COUNTDOWN;
          this.nowTime = this.duration * value;
          if (value === 1 && this.repeat !== 0) {
            this.repeatCounter++;
          }
        }
      }
    }, {
      key: "setT",
      value: function setT(t) {
        this.t = t;
        return this;
      }
    }, {
      key: "isIdle",
      get: function get() {
        return this.state === IDLE$6;
      }
    }, {
      key: "isDelay",
      get: function get() {
        return this.state === DELAY;
      }
    }, {
      key: "isCountDown",
      get: function get() {
        return this.state === COUNTDOWN;
      }
    }, {
      key: "isRunning",
      get: function get() {
        return this.state === DELAY || this.state === COUNTDOWN;
      }
    }, {
      key: "isDone",
      get: function get() {
        return this.state === DONE;
      }
    }, {
      key: "isOddIteration",
      get: function get() {
        return (this.repeatCounter & 1) === 1;
      }
    }, {
      key: "isEvenIteration",
      get: function get() {
        return (this.repeatCounter & 1) === 0;
      }
    }]);
    return Timer;
  }();
  var IDLE$6 = 0;
  var DELAY = 1;
  var COUNTDOWN = 2;
  var REPEATDELAY = 3;
  var DONE = -1;

  var TimerTickTask = /*#__PURE__*/function (_TickTask) {
    _inherits(TimerTickTask, _TickTask);
    function TimerTickTask(parent, config) {
      var _this;
      _classCallCheck(this, TimerTickTask);
      _this = _callSuper(this, TimerTickTask, [parent, config]);
      _this.timer = new Timer$1();
      // boot() later 
      return _this;
    }

    // override
    _createClass(TimerTickTask, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        _get(_getPrototypeOf(TimerTickTask.prototype), "shutdown", this).call(this, fromScene);
        this.timer.destroy();
        this.timer = undefined;
      }
    }, {
      key: "start",
      value: function start() {
        this.timer.start();
        _get(_getPrototypeOf(TimerTickTask.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.timer.stop();
        _get(_getPrototypeOf(TimerTickTask.prototype), "stop", this).call(this);
        return this;
      }
    }, {
      key: "complete",
      value: function complete() {
        this.timer.stop();
        _get(_getPrototypeOf(TimerTickTask.prototype), "complete", this).call(this);
        return this;
      }
    }]);
    return TimerTickTask;
  }(SceneUpdateTickTask);

  var GetValue$3h = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$5 = Phaser.Utils.Objects.GetAdvancedValue;
  var GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;
  var EaseValueTaskBase = /*#__PURE__*/function (_TimerTask) {
    _inherits(EaseValueTaskBase, _TimerTask);
    function EaseValueTaskBase() {
      _classCallCheck(this, EaseValueTaskBase);
      return _callSuper(this, EaseValueTaskBase, arguments);
    }
    _createClass(EaseValueTaskBase, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.timer.resetFromJSON(GetValue$3h(o, 'timer'));
        this.setEnable(GetValue$3h(o, 'enable', true));
        this.setTarget(GetValue$3h(o, 'target', this.parent));
        this.setDelay(GetAdvancedValue$5(o, 'delay', 0));
        this.setDuration(GetAdvancedValue$5(o, 'duration', 1000));
        this.setEase(GetValue$3h(o, 'ease', 'Linear'));
        this.setRepeat(GetValue$3h(o, 'repeat', 0));
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e == undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "setTarget",
      value: function setTarget(target) {
        if (target === undefined) {
          target = this.parent;
        }
        this.target = target;
        return this;
      }
    }, {
      key: "setDelay",
      value: function setDelay(time) {
        this.delay = time;
        // Assign `this.timer.setRepeat(repeat)` manually
        return this;
      }
    }, {
      key: "setDuration",
      value: function setDuration(time) {
        this.duration = time;
        return this;
      }
    }, {
      key: "setRepeat",
      value: function setRepeat(repeat) {
        this.repeat = repeat;
        // Assign `this.timer.setRepeat(repeat)` manually
        return this;
      }
    }, {
      key: "setRepeatDelay",
      value: function setRepeatDelay(repeatDelay) {
        this.repeatDelay = repeatDelay;
        // Assign `this.timer.setRepeatDelay(repeatDelay)` manually
        return this;
      }
    }, {
      key: "setEase",
      value: function setEase(ease) {
        if (ease === undefined) {
          ease = 'Linear';
        }
        this.ease = ease;
        this.easeFn = GetEaseFunction(ease);
        return this;
      }

      // Override
    }, {
      key: "start",
      value: function start() {
        // Ignore start if timer is running, i.e. in DELAY, o RUN state
        if (this.timer.isRunning) {
          return this;
        }
        _get(_getPrototypeOf(EaseValueTaskBase.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "restart",
      value: function restart() {
        this.timer.stop();
        this.start.apply(this, arguments);
        return this;
      }
    }, {
      key: "stop",
      value: function stop(toEnd) {
        if (toEnd === undefined) {
          toEnd = false;
        }
        _get(_getPrototypeOf(EaseValueTaskBase.prototype), "stop", this).call(this);
        if (toEnd) {
          this.timer.setT(1);
          this.updateGameObject(this.target, this.timer);
          this.complete();
        }
        return this;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (!this.isRunning || !this.enable || !this.parent.active) {
          return this;
        }
        var target = this.target,
          timer = this.timer;
        timer.update(time, delta);

        // isDelay, isCountDown, isDone
        if (!timer.isDelay) {
          this.updateGameObject(target, timer);
        }
        this.emit('update', target, this);
        if (timer.isDone) {
          this.complete();
        }
        return this;
      }

      // Override
    }, {
      key: "updateGameObject",
      value: function updateGameObject(target, timer) {}
    }]);
    return EaseValueTaskBase;
  }(TimerTickTask);

  var SoundObjectClass = Phaser.Sound.BaseSound;
  var IsSoundObject = function IsSoundObject(object) {
    return object instanceof SoundObjectClass;
  };

  var GetValue$3g = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$4 = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear$b = Phaser.Math.Linear;
  var Fade$3 = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(Fade, _EaseValueTaskBase);
    function Fade(scene, sound, config) {
      var _this;
      _classCallCheck(this, Fade);
      if (IsSoundObject(scene)) {
        config = sound;
        sound = scene;
        scene = undefined;
      }
      sound.active = true;
      sound.scene = scene;
      sound.game = sound.manager.game;
      _this = _callSuper(this, Fade, [sound, config]);
      // this.parent = parent
      // this.timer

      _this.volume = {};
      _this.resetFromJSON(config);
      return _this;
    }
    _createClass(Fade, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Fade.prototype), "resetFromJSON", this).call(this, o);
        this.setMode(GetValue$3g(o, 'mode', 0));
        this.setEnable(GetValue$3g(o, 'enable', true));
        this.setVolumeRange(GetAdvancedValue$4(o, 'volume.start', this.parent.volume), GetAdvancedValue$4(o, 'volume.end', 0));
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = MODE$4[m];
        }
        this.mode = m;
        return this;
      }
    }, {
      key: "setVolumeRange",
      value: function setVolumeRange(start, end) {
        this.volume.start = start;
        this.volume.end = end;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }
        this.parent.setVolume(this.volume.start);
        this.timer.setDelay(this.delay).setDuration(this.duration);
        _get(_getPrototypeOf(Fade.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(parent, timer) {
        parent.volume = Linear$b(this.volume.start, this.volume.end, timer.t);
      }
    }, {
      key: "complete",
      value: function complete() {
        _get(_getPrototypeOf(Fade.prototype), "complete", this).call(this);
        switch (this.mode) {
          case 1:
            this.parent.stop();
            break;
          case 2:
            this.parent.stop();
            this.parent.destroy();
            break;
        }
        return this;
      }
    }]);
    return Fade;
  }(EaseValueTaskBase);
  var MODE$4 = {
    stop: 1,
    destroy: 2
  };

  var FadeIn$1 = function FadeIn(scene, sound, duration, endVolume, startVolume) {
    if (IsSoundObject(scene)) {
      startVolume = endVolume;
      endVolume = duration;
      duration = sound;
      sound = scene;
      scene = undefined;
    }
    if (endVolume === undefined) {
      endVolume = 1;
    }
    if (startVolume === undefined) {
      startVolume = 0;
    }
    var config = {
      mode: 0,
      volume: {
        start: startVolume,
        end: endVolume
      },
      duration: duration
    };

    // create sound instance by key
    if (typeof sound === 'string') {
      sound = scene.sys.sound.add(sound);
    }
    var fade;
    if (sound.hasOwnProperty('_fade')) {
      fade = sound._fade;
      fade.stop().resetFromJSON(config);
    } else {
      fade = new Fade$3(scene, sound, config);
      sound._fade = fade;
    }
    fade.start();
    if (!sound.isPlaying) {
      sound.setVolume(startVolume).play();
    }
    return sound;
  };

  var FadeOut = function FadeOut(scene, sound, duration, destroy) {
    if (IsSoundObject(scene)) {
      destroy = duration;
      duration = sound;
      sound = scene;
      scene = undefined;
    }
    if (destroy === undefined) {
      destroy = true;
    }
    var config = {
      mode: destroy ? 2 : 1,
      // 1: stop, 2: destroy
      volume: {
        start: sound.volume,
        end: 0
      },
      duration: duration
    };
    var fade;
    if (sound.hasOwnProperty('_fade')) {
      fade = sound._fade;
      fade.stop().resetFromJSON(config);
    } else {
      fade = new Fade$3(scene, sound, config);
      sound._fade = fade;
    }
    fade.start();
    if (!sound.isPlaying) {
      sound.play();
    }
    return sound;
  };

  var GetValue$3f = Phaser.Utils.Objects.GetValue;
  var BackgroundMusicMethods$1 = {
    setBackgroundMusicLoop: function setBackgroundMusicLoop(value) {
      if (value === undefined) {
        value = true;
      }
      this.backgroundMusicLoop = value;
      return this;
    },
    setBackgroundMusicFadeTime: function setBackgroundMusicFadeTime(time) {
      this.backgroundMusicFadeTime = time;
      return this;
    },
    getBackgroundMusic: function getBackgroundMusic() {
      return this.backgroundMusic;
    },
    // Internal method
    setCurrentBackgroundMusic: function setCurrentBackgroundMusic(music) {
      this.backgroundMusic = music;
      if (music) {
        music.once('complete', function () {
          if (this.backgroundMusic === music) {
            this.backgroundMusic.destroy();
            this.backgroundMusic = undefined;
          }
        }, this).once('destroy', function () {
          if (this.backgroundMusic === music) {
            this.backgroundMusic = undefined;
          }
        }, this);
        if (!music.isPlaying) {
          music.play();
        }
      }
      return this;
    },
    playBackgroundMusic: function playBackgroundMusic(key, config) {
      if (!this.hasAudio(key)) {
        console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
        return this;
      }

      // Don't re-play the same background music
      if (this.backgroundMusic && this.backgroundMusic.key === key) {
        return this;
      }
      this.stopBackgroundMusic(); // Stop previous background music

      var music = this.sound.add(key, {
        loop: GetValue$3f(config, 'loop', this.backgroundMusicLoop),
        mute: GetValue$3f(config, 'mute', this.backgroundMusicMute),
        volume: GetValue$3f(config, 'volume', this.backgroundMusicVolume),
        detune: GetValue$3f(config, 'detune', 0),
        rate: GetValue$3f(config, 'rate', 1)
      });
      this.setCurrentBackgroundMusic(music);

      // Fade volume
      if (this.backgroundMusicFadeTime > 0) {
        this.fadeInBackgroundMusic(this.backgroundMusicFadeTime);
      }
      return this;
    },
    pauseBackgroundMusic: function pauseBackgroundMusic() {
      if (this.backgroundMusic) {
        this.backgroundMusic.pause();
      }
      return this;
    },
    resumeBackgroundMusic: function resumeBackgroundMusic() {
      if (this.backgroundMusic) {
        this.backgroundMusic.resume();
      }
      return this;
    },
    stopBackgroundMusic: function stopBackgroundMusic() {
      if (this.backgroundMusic) {
        if (this.backgroundMusicFadeTime > 0) {
          this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, true);
        } else {
          this.backgroundMusic.stop();
          this.backgroundMusic.destroy();
          this.backgroundMusic = undefined;
        }
      }
      return this;
    },
    fadeInBackgroundMusic: function fadeInBackgroundMusic(time) {
      if (this.backgroundMusic) {
        FadeIn$1(this.backgroundMusic, time, this.backgroundMusicVolume, 0);
      }
      return this;
    },
    fadeOutBackgroundMusic: function fadeOutBackgroundMusic(time, isStopped) {
      if (this.backgroundMusic) {
        FadeOut(this.backgroundMusic, time, isStopped);
      }
      return this;
    },
    crossFadeBackgroundMusic: function crossFadeBackgroundMusic(key, time) {
      if (!this.hasAudio(key)) {
        console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
        return this;
      }
      var backgroundMusicFadeTimeSave = this.backgroundMusicFadeTime;
      this.backgroundMusicFadeTime = 0;
      this.fadeOutBackgroundMusic(time, true).playBackgroundMusic(key).fadeInBackgroundMusic(time);
      this.backgroundMusicFadeTime = backgroundMusicFadeTimeSave;
      return this;
    },
    setBackgroundMusicMute: function setBackgroundMusicMute(mute) {
      if (mute === undefined) {
        mute = true;
      }
      this.backgroundMusicMute = mute;
      return this;
    },
    setBackgroundMusicVolume: function setBackgroundMusicVolume(volume) {
      this.backgroundMusicVolume = volume;
      return this;
    },
    setBackgroundMusicRate: function setBackgroundMusicRate(rate) {
      if (this.backgroundMusic) {
        this.backgroundMusic.setRate(rate);
      }
      return this;
    },
    setBackgroundMusicDetune: function setBackgroundMusicDetune(detune) {
      if (this.backgroundMusic) {
        this.backgroundMusic.setDetune(detune);
      }
      return this;
    }
  };

  var GetValue$3e = Phaser.Utils.Objects.GetValue;
  var BackgroundMusic2Methods$1 = {
    setBackgroundMusic2Loop: function setBackgroundMusic2Loop(value) {
      if (value === undefined) {
        value = true;
      }
      this.backgroundMusic2Loop = value;
      return this;
    },
    setBackgroundMusic2FadeTime: function setBackgroundMusic2FadeTime(time) {
      this.backgroundMusic2FadeTime = time;
      return this;
    },
    getBackgroundMusic2: function getBackgroundMusic2() {
      return this.backgroundMusic2;
    },
    // Internal method
    setCurrentBackgroundMusic2: function setCurrentBackgroundMusic2(music) {
      this.backgroundMusic2 = music;
      if (music) {
        music.once('complete', function () {
          if (this.backgroundMusic2 === music) {
            this.backgroundMusic2.destroy();
            this.backgroundMusic2 = undefined;
          }
        }, this).once('destroy', function () {
          if (this.backgroundMusic2 === music) {
            this.backgroundMusic2 = undefined;
          }
        }, this);
        if (!music.isPlaying) {
          music.play();
        }
      }
      return this;
    },
    playBackgroundMusic2: function playBackgroundMusic2(key, config) {
      if (!this.hasAudio(key)) {
        console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
        return this;
      }

      // Don't re-play the same background music
      if (this.backgroundMusic2 && this.backgroundMusic2.key === key) {
        return this;
      }
      this.stopBackgroundMusic2(); // Stop previous background music

      var music = this.sound.add(key, {
        loop: GetValue$3e(config, 'loop', this.backgroundMusicLoop),
        mute: GetValue$3e(config, 'mute', this.backgroundMusic2Mute),
        volume: GetValue$3e(config, 'volume', this.backgroundMusic2Volume),
        detune: GetValue$3e(config, 'detune', 0),
        rate: GetValue$3e(config, 'rate', 1)
      });
      this.setCurrentBackgroundMusic2(music);

      // Fade volume
      if (this.backgroundMusic2FadeTime > 0) {
        this.fadeInBackgroundMusic2(this.backgroundMusic2FadeTime);
      }
      return this;
    },
    pauseBackgroundMusic2: function pauseBackgroundMusic2() {
      if (this.backgroundMusic2) {
        this.backgroundMusic2.pause();
      }
      return this;
    },
    resumeBackgroundMusic2: function resumeBackgroundMusic2() {
      if (this.backgroundMusic2) {
        this.backgroundMusic2.resume();
      }
      return this;
    },
    stopBackgroundMusic2: function stopBackgroundMusic2() {
      if (this.backgroundMusic2) {
        if (this.backgroundMusic2FadeTime > 0) {
          this.fadeOutBackgroundMusic2(this.backgroundMusic2FadeTime, true);
        } else {
          this.backgroundMusic2.stop();
          this.backgroundMusic2.destroy();
          this.backgroundMusic2 = undefined;
        }
      }
      return this;
    },
    fadeInBackgroundMusic2: function fadeInBackgroundMusic2(time) {
      if (this.backgroundMusic2) {
        FadeIn$1(this.backgroundMusic2, time, this.backgroundMusic2Volume, 0);
      }
      return this;
    },
    fadeOutBackgroundMusic2: function fadeOutBackgroundMusic2(time, isStopped) {
      if (this.backgroundMusic2) {
        FadeOut(this.backgroundMusic2, time, isStopped);
      }
      return this;
    },
    crossFadeBackgroundMusic2: function crossFadeBackgroundMusic2(key, time) {
      if (!this.hasAudio(key)) {
        console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
        return this;
      }
      var backgroundMusic2FadeTimeSave = this.backgroundMusic2FadeTime;
      this.backgroundMusic2FadeTime = 0;
      this.fadeOutBackgroundMusic2(time, true).playBackgroundMusic2(key).fadeInBackgroundMusic2(time);
      this.backgroundMusic2FadeTime = backgroundMusic2FadeTimeSave;
      return this;
    },
    setBackgroundMusic2Mute: function setBackgroundMusic2Mute(mute) {
      if (mute === undefined) {
        mute = true;
      }
      this.backgroundMusic2Mute = mute;
      return this;
    },
    setBackgroundMusic2Volume: function setBackgroundMusic2Volume(volume) {
      this.backgroundMusic2Volume = volume;
      return this;
    },
    setBackgroundMusic2Rate: function setBackgroundMusic2Rate(rate) {
      if (this.backgroundMusic2) {
        this.backgroundMusic2.setRate(rate);
      }
      return this;
    },
    setBackgroundMusic2Detune: function setBackgroundMusic2Detune(detune) {
      if (this.backgroundMusic2) {
        this.backgroundMusic2.setDetune(detune);
      }
      return this;
    }
  };

  var RemoveItem$c = Phaser.Utils.Array.Remove;
  var GetValue$3d = Phaser.Utils.Objects.GetValue;
  var SoundEffectsMethods$1 = {
    getSoundEffects: function getSoundEffects() {
      return this.soundEffects;
    },
    getLastSoundEffect: function getLastSoundEffect() {
      return this.soundEffects[this.soundEffects.length - 1];
    },
    playSoundEffect: function playSoundEffect(key, config) {
      if (!this.hasAudio(key)) {
        console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
        return this;
      }
      var music = this.sound.add(key, {
        mute: GetValue$3d(config, 'mute', this.soundEffectsMute),
        volume: GetValue$3d(config, 'volume', this.soundEffectsVolume),
        detune: GetValue$3d(config, 'detune', 0),
        rate: GetValue$3d(config, 'rate', 1)
      });
      this.soundEffects.push(music);
      music.once('complete', function () {
        music.destroy();

        // SoundManager has been destroyed
        if (!this.sound) {
          return;
        }
        RemoveItem$c(this.soundEffects, music);
      }, this).once('destroy', function () {
        // SoundManager has been destroyed
        if (!this.sound) {
          return;
        }
        RemoveItem$c(this.soundEffects, music);
      }, this).play();
      return this;
    },
    stopAllSoundEffects: function stopAllSoundEffects() {
      for (var i = this.soundEffects.length - 1; i >= 0; i--) {
        var soundEffect = this.soundEffects[i];
        soundEffect.stop();
        soundEffect.destroy();
      }
      return this;
    },
    fadeInSoundEffect: function fadeInSoundEffect(time) {
      var soundEffect = this.getLastSoundEffect();
      if (soundEffect) {
        FadeIn$1(soundEffect, time, this.soundEffectsVolume, 0);
      }
      return this;
    },
    fadeOutSoundEffect: function fadeOutSoundEffect(time, isStopped) {
      var soundEffect = this.getLastSoundEffect();
      if (soundEffect) {
        FadeOut(soundEffect, time, isStopped);
      }
      return this;
    },
    fadeOutAllSoundEffects: function fadeOutAllSoundEffects(time, isStopped) {
      for (var i = this.soundEffects.length - 1; i >= 0; i--) {
        FadeOut(this.soundEffects[i], time, isStopped);
      }
      return this;
    },
    setSoundEffectMute: function setSoundEffectMute(mute, lastSoundEffect) {
      if (mute === undefined) {
        mute = true;
      }
      if (lastSoundEffect === undefined) {
        lastSoundEffect = false;
      }
      if (lastSoundEffect) {
        // Set volume of last sound effect
        var soundEffect = this.getLastSoundEffect();
        if (soundEffect) {
          soundEffect.setMute(mute);
        }
      } else {
        // Set volume of all sound effects
        this.soundEffectsMute = mute;
      }
      return this;
    },
    setSoundEffectVolume: function setSoundEffectVolume(volume, lastSoundEffect) {
      if (lastSoundEffect === undefined) {
        lastSoundEffect = false;
      }
      if (lastSoundEffect) {
        // Set volume of last sound effect
        var soundEffect = this.getLastSoundEffect();
        if (soundEffect) {
          soundEffect.setVolume(volume);
        }
      } else {
        // Set volume of all sound effects
        this.soundEffectsVolume = volume;
      }
      return this;
    },
    setSoundEffectDetune: function setSoundEffectDetune(detune, lastSoundEffect) {
      if (lastSoundEffect === undefined) {
        lastSoundEffect = false;
      }
      var soundEffects;
      if (lastSoundEffect) {
        soundEffects = [this.getLastSoundEffect()];
      } else {
        soundEffects = this.soundEffects;
      }
      for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
        soundEffects[i].setDetune(detune);
      }
      return this;
    },
    setSoundEffectRate: function setSoundEffectRate(rate, lastSoundEffect) {
      if (lastSoundEffect === undefined) {
        lastSoundEffect = false;
      }
      var soundEffects;
      if (lastSoundEffect) {
        soundEffects = [this.getLastSoundEffect()];
      } else {
        soundEffects = this.soundEffects;
      }
      for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
        soundEffects[i].setRate(rate);
      }
      return this;
    }
  };

  var RemoveItem$b = Phaser.Utils.Array.Remove;
  var GetValue$3c = Phaser.Utils.Objects.GetValue;
  var SoundEffects2Methods$1 = {
    getSoundEffects2: function getSoundEffects2() {
      return this.soundEffects2;
    },
    getLastSoundEffect2: function getLastSoundEffect2() {
      return this.soundEffects2[this.soundEffects2.length - 1];
    },
    playSoundEffect2: function playSoundEffect2(key, config) {
      if (!this.hasAudio(key)) {
        console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
        return this;
      }
      var music = this.sound.add(key, {
        mute: GetValue$3c(config, 'mute', this.soundEffects2Mute),
        volume: GetValue$3c(config, 'volume', this.soundEffects2Volume),
        detune: GetValue$3c(config, 'detune', 0),
        rate: GetValue$3c(config, 'rate', 1)
      });
      this.soundEffects2.push(music);
      music.once('complete', function () {
        music.destroy();

        // SoundManager has been destroyed
        if (!this.sound) {
          return;
        }
        RemoveItem$b(this.soundEffects2, music);
      }, this).once('destroy', function () {
        // SoundManager has been destroyed
        if (!this.sound) {
          return;
        }
        RemoveItem$b(this.soundEffects2, music);
      }, this).play();
      return this;
    },
    stopAllSoundEffects2: function stopAllSoundEffects2() {
      for (var i = this.soundEffects.length - 1; i >= 0; i--) {
        var soundEffect = this.soundEffects[i];
        soundEffect.stop();
        soundEffect.destroy();
      }
      return this;
    },
    fadeInSoundEffect2: function fadeInSoundEffect2(time) {
      var soundEffect = this.getLastSoundEffect2();
      if (soundEffect) {
        FadeIn$1(soundEffect, time, this.soundEffects2Volume, 0);
      }
      return this;
    },
    fadeOutSoundEffect2: function fadeOutSoundEffect2(time, isStopped) {
      var soundEffect = this.getLastSoundEffect2();
      if (soundEffect) {
        FadeOut(soundEffect, time, isStopped);
      }
      return this;
    },
    fadeOutAllSoundEffects2: function fadeOutAllSoundEffects2(time, isStopped) {
      for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
        FadeOut(this.soundEffects2[i], time, isStopped);
      }
      return this;
    },
    setSoundEffect2Mute: function setSoundEffect2Mute(mute, lastSoundEffect) {
      if (mute === undefined) {
        mute = true;
      }
      if (lastSoundEffect === undefined) {
        lastSoundEffect = false;
      }
      if (lastSoundEffect) {
        // Set volume of last sound effect
        var soundEffect = this.getLastSoundEffect2();
        if (soundEffect) {
          soundEffect.setMute(mute);
        }
      } else {
        // Set volume of all sound effects
        this.soundEffects2Mute = mute;
      }
      return this;
    },
    setSoundEffect2Volume: function setSoundEffect2Volume(volume, lastSoundEffect) {
      if (lastSoundEffect === undefined) {
        lastSoundEffect = false;
      }
      if (lastSoundEffect) {
        // Set volume of last sound effect
        var soundEffect = this.getLastSoundEffect2();
        if (soundEffect) {
          soundEffect.setVolume(volume);
        }
      } else {
        // Set volume of all sound effects
        this.soundEffects2Volume = volume;
      }
      return this;
    },
    setSoundEffect2Detune: function setSoundEffect2Detune(detune, lastSoundEffect) {
      if (lastSoundEffect === undefined) {
        lastSoundEffect = false;
      }
      var soundEffects;
      if (lastSoundEffect) {
        soundEffects = [this.getLastSoundEffect2()];
      } else {
        soundEffects = this.soundEffects2;
      }
      for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
        soundEffects[i].setDetune(detune);
      }
      return this;
    },
    setSoundEffect2Rate: function setSoundEffect2Rate(rate, lastSoundEffect) {
      if (lastSoundEffect === undefined) {
        lastSoundEffect = false;
      }
      var soundEffects;
      if (lastSoundEffect) {
        soundEffects = [this.getLastSoundEffect2()];
      } else {
        soundEffects = this.soundEffects2;
      }
      for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
        soundEffects[i].setRate(rate);
      }
      return this;
    }
  };

  var Methods$l = {
    hasAudio: HasaAudio
  };
  Object.assign(Methods$l, BackgroundMusicMethods$1, BackgroundMusic2Methods$1, SoundEffectsMethods$1, SoundEffects2Methods$1);

  var GetValue$3b = Phaser.Utils.Objects.GetValue;
  var SoundManager = /*#__PURE__*/function () {
    function SoundManager(game, config) {
      _classCallCheck(this, SoundManager);
      this.sound = GetSoundManager(game);

      // Background music will be (fade out)destroyed when play next one.
      this.backgroundMusic = undefined;
      this._backgroundMusicVolume = GetValue$3b(config, 'bgm.volume', 1);
      this._backgroundMusicMute = GetValue$3b(config, 'bgm.mute', false);
      this.setBackgroundMusicLoop(GetValue$3b(config, 'bgm.loop', true));
      this.setBackgroundMusicFadeTime(GetValue$3b(config, 'bgm.fade', 500));
      this.backgroundMusic2 = undefined;
      this._backgroundMusic2Volume = GetValue$3b(config, 'bgm2.volume', 1);
      this._backgroundMusic2Mute = GetValue$3b(config, 'bgm2.mute', false);
      this.setBackgroundMusic2Loop(GetValue$3b(config, 'bgm2.loop', true));
      this.setBackgroundMusic2FadeTime(GetValue$3b(config, 'bgm2.fade', 500));

      // Sound effect will be destroyed when completed
      this.soundEffects = [];
      this._soundEffectsVolume = GetValue$3b(config, 'soundEffect.volume', 1);
      this.soundEffects2 = [];
      this._soundEffects2Volume = GetValue$3b(config, 'soundEffect2.volume', 1);
      var initialBackgroundMusic = GetValue$3b(config, 'bgm.initial', undefined);
      if (initialBackgroundMusic) {
        this.setCurrentBackgroundMusic(initialBackgroundMusic);
      }
      var initialBackgroundMusic2 = GetValue$3b(config, 'bgm2.initial', undefined);
      if (initialBackgroundMusic2) {
        this.setCurrentBackgroundMusic2(initialBackgroundMusic2);
      }
    }
    _createClass(SoundManager, [{
      key: "destroy",
      value: function destroy() {
        if (this.backgroundMusic) {
          this.backgroundMusic.destroy();
        }
        this.backgroundMusic = undefined;
        if (this.backgroundMusic2) {
          this.backgroundMusic2.destroy();
        }
        this.backgroundMusic2 = undefined;
        if (this.soundEffects.length) {
          for (var i = this.soundEffects.length - 1; i >= 0; i--) {
            this.soundEffects[i].destroy();
          }
        }
        this.soundEffects.length = 0;
        if (this.soundEffects2.length) {
          for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
            this.soundEffects2[i].destroy();
          }
        }
        this.soundEffects2.length = 0;
        this.sound = undefined;
        return this;
      }

      // backgroundMusic
      // mute
    }, {
      key: "backgroundMusicMute",
      get: function get() {
        return this._backgroundMusicMute;
      },
      set: function set(value) {
        this._backgroundMusicMute = value;
        if (this.backgroundMusic) {
          this.backgroundMusic.setMute(mute);
        }
      }

      // volume
    }, {
      key: "backgroundMusicVolume",
      get: function get() {
        return this._backgroundMusicVolume;
      },
      set: function set(value) {
        this._backgroundMusicVolume = value;
        if (this.backgroundMusic) {
          this.backgroundMusic.setVolume(value);
        }
      }

      // backgroundMusic2
      // mute
    }, {
      key: "backgroundMusic2Mute",
      get: function get() {
        return this._backgroundMusic2Mute;
      },
      set: function set(value) {
        this._backgroundMusic2Mute = value;
        if (this.backgroundMusic2) {
          this.backgroundMusic2.setMute(mute);
        }
      }

      // volume
    }, {
      key: "backgroundMusic2Volume",
      get: function get() {
        return this._backgroundMusic2Volume;
      },
      set: function set(value) {
        this._backgroundMusic2Volume = value;
        if (this.backgroundMusic2) {
          this.backgroundMusic2.setVolume(value);
        }
      }

      // soundEffects
      // mute
    }, {
      key: "soundEffectsMute",
      get: function get() {
        return this._soundEffectsMute;
      },
      set: function set(value) {
        this._soundEffectsMute = value;
        var soundEffects = this.soundEffects;
        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
          soundEffects[i].setMute(value);
        }
      }

      // volume
    }, {
      key: "soundEffectsVolume",
      get: function get() {
        return this._soundEffectsVolume;
      },
      set: function set(value) {
        this._soundEffectsVolume = value;
        var soundEffects = this.soundEffects;
        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
          soundEffects[i].setVolume(value);
        }
      }

      // soundEffects2
      // mute
    }, {
      key: "soundEffects2Mute",
      get: function get() {
        return this._soundEffects2Mute;
      },
      set: function set(value) {
        this._soundEffects2Mute = value;
        var soundEffects = this.soundEffects;
        for (var i = 0, cnt = soundEffects2.length; i < cnt; i++) {
          soundEffects[i].setMute(value);
        }
      }

      // volume
    }, {
      key: "soundEffects2Volume",
      get: function get() {
        return this._soundEffects2Volume;
      },
      set: function set(value) {
        this._soundEffects2Volume = value;
        var soundEffects = this.soundEffects2;
        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
          soundEffects[i].setVolume(value);
        }
      }
    }]);
    return SoundManager;
  }();
  Object.assign(SoundManager.prototype, Methods$l);

  var GetValue$3a = Phaser.Utils.Objects.GetValue;
  var BaseClock = /*#__PURE__*/function (_TickTask) {
    _inherits(BaseClock, _TickTask);
    function BaseClock(parent, config) {
      var _this;
      _classCallCheck(this, BaseClock);
      _this = _callSuper(this, BaseClock, [parent, config]);
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(BaseClock, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.isRunning = GetValue$3a(o, 'isRunning', false);
        this.timeScale = GetValue$3a(o, 'timeScale', 1);
        this.now = GetValue$3a(o, 'now', 0);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          isRunning: this.isRunning,
          timeScale: this.timeScale,
          now: this.now,
          tickingMode: this.tickingMode
        };
      }

      // Override
      // startTicking() { }

      // Override
      // stopTicking() {}
    }, {
      key: "start",
      value: function start(startAt) {
        if (startAt === undefined) {
          startAt = 0;
        }
        this.delta = 0;
        this.now = startAt;
        _get(_getPrototypeOf(BaseClock.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "seek",
      value: function seek(time) {
        this.now = time;
        return this;
      }
    }, {
      key: "setTimeScale",
      value: function setTimeScale(value) {
        this.timeScale = value;
        return this;
      }
    }, {
      key: "tick",
      value: function tick(delta) {
        delta *= this.timeScale;
        this.now += delta;
        this.delta = delta;
        this.emit('update', this.now, this.delta);
        return this;
      }
    }]);
    return BaseClock;
  }(TickTask);

  var Clock = /*#__PURE__*/function (_BaseClock) {
    _inherits(Clock, _BaseClock);
    function Clock() {
      _classCallCheck(this, Clock);
      return _callSuper(this, Clock, arguments);
    }
    _createClass(Clock, [{
      key: "startTicking",
      value: function startTicking() {
        _get(_getPrototypeOf(Clock.prototype), "startTicking", this).call(this);
        this.scene.sys.events.on('update', this.update, this);
      }
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        _get(_getPrototypeOf(Clock.prototype), "stopTicking", this).call(this);
        if (this.scene) {
          // Scene might be destoryed
          this.scene.sys.events.off('update', this.update, this);
        }
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (!this.isRunning || this.timeScale === 0) {
          return this;
        }
        this.tick(delta);
        return this;
      }
    }]);
    return Clock;
  }(BaseClock);

  var Yoyo$1 = function Yoyo(t, threshold) {
    if (threshold === undefined) {
      threshold = 0.5;
    }
    if (t <= threshold) {
      t = t / threshold;
    } else {
      t = 1 - (t - threshold) / (1 - threshold);
    }
    return t;
  };

  var Clamp$e = Phaser.Math.Clamp;
  var Timer = /*#__PURE__*/function () {
    function Timer(timeline, config) {
      _classCallCheck(this, Timer);
      this.setTimeline(timeline).reset(config);
    }
    _createClass(Timer, [{
      key: "setTimeline",
      value: function setTimeline(timeline) {
        this.timeline = timeline;
        return this;
      }
    }, {
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "setCallbacks",
      value: function setCallbacks(target, onStart, onProgress, onComplete) {
        this.target = target;
        this.onStart = onStart;
        this.onProgress = onProgress;
        this.onComplete = onComplete;
        return this;
      }
    }, {
      key: "setDuration",
      value: function setDuration(duration, yoyo) {
        if (yoyo === undefined) {
          yoyo = false;
        }
        this.duration = duration;
        this.remainder = duration;
        this.t = 0;
        this.yoyo = yoyo;
        return this;
      }
    }, {
      key: "setPaused",
      value: function setPaused(state) {
        this.isPaused = state;
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        this.isPaused = true;
        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        this.isPaused = false;
        return this;
      }
    }, {
      key: "setRemoved",
      value: function setRemoved(state) {
        this.removed = state;
        return this;
      }
    }, {
      key: "remove",
      value: function remove() {
        this.removed = true;
        return this;
      }
    }, {
      key: "seek",
      value: function seek(t) {
        this.remainder = this.duration * (1 - t);
        return this;
      }
    }, {
      key: "reset",
      value: function reset(o) {
        this.setName(o.name).setDuration(o.duration, o.yoyo).setCallbacks(o.target, o.onStart, o.onProgress, o.onComplete).setPaused(false).setRemoved(false);
        return this;
      }
    }, {
      key: "onFree",
      value: function onFree() {
        this.setTimeline().setCallbacks();
      }
    }, {
      key: "getProgress",
      value: function getProgress() {
        var value = 1 - this.remainder / this.duration;
        value = Clamp$e(value, 0, 1);
        if (this.yoyo) {
          value = Yoyo$1(value);
        }
        return value;
      }
    }, {
      key: "setProgress",
      value: function setProgress(value) {
        value = Clamp$e(value, 0, 1);
        this.remainder = this.duration * (1 - value);
      }
    }, {
      key: "runCallback",
      value: function runCallback(callback) {
        if (!callback) {
          return;
        }
        callback(this.target, this.t, this);
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (this.removed) {
          return true;
        } else if (this.isPaused) {
          return false;
        }
        this.remainder -= delta;
        this.t = this.getProgress();
        this.runCallback(this.onProgress);
        var isCompleted = this.remainder <= 0;
        if (isCompleted) {
          this.runCallback(this.onComplete);
        }
        return isCompleted;
      }
    }]);
    return Timer;
  }();

  var Stack = /*#__PURE__*/function () {
    function Stack() {
      _classCallCheck(this, Stack);
      this.items = [];
    }
    _createClass(Stack, [{
      key: "destroy",
      value: function destroy() {
        this.clear();
        this.items = undefined;
      }
    }, {
      key: "pop",
      value: function pop() {
        return this.items.length > 0 ? this.items.pop() : null;
      }
    }, {
      key: "push",
      value: function push(l) {
        this.items.push(l);
        return this;
      }
    }, {
      key: "pushMultiple",
      value: function pushMultiple(arr) {
        this.items.push.apply(this.items, arr);
        arr.length = 0;
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.items.length = 0;
        return this;
      }
    }]);
    return Stack;
  }();

  var TimerPool$1 = /*#__PURE__*/function (_Pool) {
    _inherits(TimerPool, _Pool);
    function TimerPool() {
      _classCallCheck(this, TimerPool);
      return _callSuper(this, TimerPool, arguments);
    }
    _createClass(TimerPool, [{
      key: "allocate",
      value: function allocate() {
        return this.pop();
      }
    }, {
      key: "free",
      value: function free(timer) {
        timer.onFree();
        this.push(timer);
      }
    }, {
      key: "freeMultiple",
      value: function freeMultiple(arr) {
        for (var i = 0, cnt = arr.length; i < cnt; i++) {
          this.free(arr[i]);
        }
        return this;
      }
    }]);
    return TimerPool;
  }(Stack);

  var GetValue$39 = Phaser.Utils.Objects.GetValue;
  var TimerPool = new TimerPool$1();
  var Timeline = /*#__PURE__*/function (_Clock) {
    _inherits(Timeline, _Clock);
    function Timeline(parent, config) {
      var _this;
      _classCallCheck(this, Timeline);
      _this = _callSuper(this, Timeline, [parent, config]);
      _this.addedTimers = [];
      _this.timers = [];
      _this.timerPool = GetValue$39(config, 'pool', TimerPool);
      return _this;
    }
    _createClass(Timeline, [{
      key: "shutdown",
      value: function shutdown() {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        this.timerPool.freeMultiple(this.addedTimers).freeMultiple(this.timers);
        this.timerPool = undefined;
        this.addedTimers = undefined;
        this.timers = undefined;
        _get(_getPrototypeOf(Timeline.prototype), "shutdown", this).call(this);
      }
    }, {
      key: "addTimer",
      value: function addTimer(config) {
        var timer = this.timerPool.allocate();
        if (!timer) {
          timer = new Timer(this, config);
        } else {
          timer.setTimeline(this).reset(config);
        }
        this.addedTimers.push(timer);
        timer.runCallback(timer.onStart);
        if (!this.isRunning) {
          this.start();
        }
        return timer;
      }
    }, {
      key: "delayCall",
      value: function delayCall(delay, callback, args, scope) {
        var timer = this.addTimer({
          duration: delay,
          onComplete: function onComplete(target, t, timer) {
            if (args === undefined) {
              args = [];
            }
            args.push(timer);
            callback.apply(scope, args);
          }
        });
        return timer;
      }
    }, {
      key: "delayEvent",
      value: function delayEvent(delay, eventName) {
        this.removeDelayEvent(eventName);
        // Clear existed event

        var timer = this.delayCall(delay, function () {
          this.removeDelayEvent(eventName); // Clear this timer
          this.emit(eventName);
        }, [], this);
        this.once("_remove.".concat(eventName), function () {
          timer.remove();
          timer = undefined;
        });
        return this;
      }
    }, {
      key: "removeDelayEvent",
      value: function removeDelayEvent(eventName) {
        this.emit("_remove.".concat(eventName));
        return this;
      }
    }, {
      key: "getTimers",
      value: function getTimers(name) {
        var timers = [];
        var timerQueues = [this.addedTimers, this.timers];
        for (var ti = 0, tcnt = timerQueues.length; ti < tcnt; ti++) {
          var timerQueue = timerQueues[ti];
          for (var i = 0, cnt = timerQueue.length; i < cnt; i++) {
            var timer = timerQueue[i];
            if (timer.name === name) {
              timers.push(timer);
            }
          }
        }
        return timers;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        var _this$timers;
        _get(_getPrototypeOf(Timeline.prototype), "update", this).call(this, time, delta);
        if (!this.isRunning) {
          return;
        }
        (_this$timers = this.timers).push.apply(_this$timers, _toConsumableArray(this.addedTimers));
        this.addedTimers.length = 0;
        var pendingTimers = [];
        for (var i = 0, cnt = this.timers.length; i < cnt; i++) {
          var timer = this.timers[i];
          var isStopped = timer.update(this.now, this.delta);
          if (isStopped) {
            this.timerPool.free(timer); // Free timer
          } else {
            pendingTimers.push(timer); // Add to timer queue
          }
        }
        this.timers = pendingTimers;
        if (this.timers.length === 0 && this.addedTimers.length === 0) {
          this.complete(); // Emit 'complete' event
        }
      }
    }]);
    return Timeline;
  }(Clock);

  var WaitCompleteEvent = '_wait.complete';
  var RemoveWaitEvents = '_remove.wait';

  var PreUpdateDelayCall = function PreUpdateDelayCall(gameObject, delay, callback, scope, args) {
    // Invoke callback under scene's 'preupdate' event
    var scene = GetSceneObject(gameObject);
    var timer = scene.time.delayedCall(delay, function () {
      scene.sys.events.once('preupdate', function () {
        callback.call(scope, args);
      });
    });
    return timer;
  };

  var WaitEvent$1 = /*#__PURE__*/function () {
    function WaitEvent(parent) {
      _classCallCheck(this, WaitEvent);
      if (!parent) {
        this.setEventEmitter(true);
        parent = this;
      }
      this.parent = parent;
      this.waitId = 0;

      // Override it
      this.waitCompleteEventName = WaitCompleteEvent;
      this.removeWaitEventsEventName = RemoveWaitEvents;
    }
    _createClass(WaitEvent, [{
      key: "destroy",
      value: function destroy() {
        this.removeWaitEvents();
        this.clearWaitCompleteCallbacks();
        this.parent = null;
      }
    }, {
      key: "waitEvent",
      value: function waitEvent(eventEmitter, eventName, completeNextTick) {
        var callback = this.getWaitCompleteTriggerCallback(completeNextTick);
        eventEmitter.once(eventName, callback, this);
        this.parent.once(this.removeWaitEventsEventName, function () {
          eventEmitter.off(eventName, callback, this);
        });
        return this.parent;
      }
    }, {
      key: "getWaitCompleteTriggerCallback",
      value: function getWaitCompleteTriggerCallback(completeNextTick) {
        if (completeNextTick === undefined) {
          completeNextTick = true;
        }
        var waitId = this.waitId;
        var self = this;
        var completeCallback = function completeCallback() {
          if (waitId < self.waitId) {
            return;
          }
          self.waitId++;
          self.removeWaitEvents();
          self.parent.emit(self.waitCompleteEventName);
        };
        if (completeNextTick) {
          var completeCallbackNextTick = function completeCallbackNextTick() {
            PreUpdateDelayCall(self.parent, 0, completeCallback);
          };
          return completeCallbackNextTick;
        } else {
          return completeCallback;
        }
      }
    }, {
      key: "removeWaitEvents",
      value: function removeWaitEvents() {
        this.parent.emit(this.removeWaitEventsEventName);
        return this;
      }
    }, {
      key: "addWaitCompleteCallback",
      value: function addWaitCompleteCallback(callback, scope) {
        this.parent.on(this.waitCompleteEventName, callback, scope);
        return this;
      }
    }, {
      key: "clearWaitCompleteCallbacks",
      value: function clearWaitCompleteCallbacks() {
        this.parent.off(this.waitCompleteEventName);
        return this;
      }
    }]);
    return WaitEvent;
  }();
  Object.assign(WaitEvent$1.prototype, EventEmitterMethods$1);

  var WaitTimeMethods = {
    waitTime: function waitTime(duration) {
      var timeline = this.parent.timeline;
      timeline.delayEvent(duration, 'delay');

      // Clear delay event on timeline manually
      this.parent.once(this.removeWaitEventsEventName, function () {
        timeline.removeDelayEvent('delay');
      });
      return this.waitEvent(timeline, 'delay');
    }
  };

  var Split = function Split(s, delimiter) {
    var regexString = "(?<!\\\\)\\".concat(delimiter);
    var escapeString = "\\".concat(delimiter);
    return s.split(new RegExp(regexString, 'g')).map(function (s) {
      return s.replace(escapeString, delimiter);
    });
  };

  var WaitInputMethods = {
    setClickTarget: function setClickTarget(target) {
      this.clickTarget = target;
      if (!target) {
        this.clickEE = null;
      } else if (IsSceneObject(target)) {
        this.clickEE = target.input;
      } else {
        // Assume that target is a gameObject
        this.clickEE = target.setInteractive();
      }
    },
    waitClick: function waitClick() {
      if (!this.clickEE) {
        return this.waitTime(0);
      }
      return this.waitEvent(this.clickEE, 'pointerdown');
    },
    waitKeyDown: function waitKeyDown(key) {
      var eventEmitter = this.scene.input.keyboard;
      if (typeof key === 'string') {
        if (key.indexOf('|') === -1) {
          return this.waitEvent(eventEmitter, "keydown-".concat(key.toUpperCase()));
        } else {
          var keys = Split(key, '|');
          for (var i = 0, cnt = keys.length; i < cnt; i++) {
            this.waitEvent(eventEmitter, "keydown-".concat(key.toUpperCase()));
          }
          return this.parent;
        }
      } else {
        return this.waitEvent(eventEmitter, 'keydown');
      }
    }
  };

  var WaitGameObjectMethods = {
    waitGameObjectTweenComplete: function waitGameObjectTweenComplete(goType, name, property) {
      var tweenTask = this.parent.getGameObjectTweenTask(goType, name, property);
      if (tweenTask) {
        return this.waitEvent(tweenTask, 'complete');
      }
      return this.waitTime(0);
    },
    waitGameObjectDataFlag: function waitGameObjectDataFlag(goType, name, dataKey, trueFlag) {
      var gameObject = this.parent.getGameObject(goType, name);
      if (!gameObject) {
        return this.waitTime(0);
      }
      if (gameObject.getData(dataKey) === trueFlag) {
        return this.waitTime(0);
      }
      var eventName = "changedata-".concat(dataKey);
      var callback = function callback(gameObject, value, previousValue) {
        value = !!value;
        if (value === trueFlag) {
          gameObject.emit('_dataFlagMatch');
        }
      };
      gameObject.on(eventName, callback);
      // Clear changedata event on gameobject manually
      this.parent.once(this.removeWaitEventsEventName, function () {
        gameObject.off(eventName, callback);
      });
      return this.waitEvent(gameObject, '_dataFlagMatch');
    },
    waitGameObjectDestroy: function waitGameObjectDestroy(goType, name) {
      var gameObject = this.parent.getGameObject(goType, name);
      if (!gameObject) {
        return this.waitTime(0);
      }
      return this.waitEvent(gameObject, 'destroy');
    },
    waitGameObjectManagerEmpty: function waitGameObjectManagerEmpty(goType) {
      if (goType) {
        var gameObjectManager = this.parent.getGameObjectManager(goType);
        if (!gameObjectManager) {
          return this.waitTime(0);
        }
        return this.waitEvent(gameObjectManager, 'empty');
      } else {
        var gameObjectManagers = this.parent.gameObjectManagers;
        var hasAnyWaitEvent = false;
        for (var name in gameObjectManagers) {
          hasAnyWaitEvent = true;
          this.waitEvent(gameObjectManagers[name], 'empty');
        }
        if (!hasAnyWaitEvent) {
          return this.waitTime(0);
        }
        return this.parent;
      }
    }
  };

  var WaitCameraMethods = {
    setCameraTarget: function setCameraTarget(camera) {
      this.cameraTarget = camera;
      return this;
    },
    waitCameraEffectComplete: function waitCameraEffectComplete(effectName) {
      var camera = this.cameraTarget;
      if (!camera) {
        return this.waitTime(0);
      }
      var effect, completeEventName;
      switch (effectName) {
        case 'camera.fadein':
          effect = camera.fadeEffect;
          completeEventName = 'camerafadeincomplete';
          break;
        case 'camera.fadeout':
          effect = camera.fadeEffect;
          completeEventName = 'camerafadeoutcomplete';
          break;
        case 'camera.flash':
          effect = camera.flashEffect;
          completeEventName = 'cameraflashcomplete';
          break;
        case 'camera.shake':
          effect = camera.shakeEffect;
          completeEventName = 'camerashakecomplete';
          break;
        case 'camera.zoom':
          effect = camera.zoomEffect;
          completeEventName = 'camerazoomcomplete';
          break;
        case 'camera.rotate':
          effect = camera.rotateToEffect;
          completeEventName = 'camerarotatecomplete';
          break;
        case 'camera.scroll':
          effect = camera.panEffect;
          completeEventName = 'camerapancomplete';
          break;
      }
      if (!effect.isRunning) {
        return this.waitTime(0);
      }
      return this.waitEvent(camera, completeEventName);
    }
  };

  var WaitMusicMethods = {
    waitSoundEffectComplete: function waitSoundEffectComplete() {
      if (!this.parent.soundManager) {
        return this.waitTime(0);
      }
      var music = this.parent.soundManager.getLastSoundEffect();
      if (!music) {
        return this.waitTime(0);
      }
      return this.waitEvent(music, 'complete');
    },
    waitSoundEffect2Complete: function waitSoundEffect2Complete() {
      if (!this.parent.soundManager) {
        return this.waitTime(0);
      }
      var music = this.parent.soundManager.getLastSoundEffect2();
      if (!music) {
        return this.waitTime(0);
      }
      return this.waitEvent(music, 'complete');
    },
    waitBackgroundMusicComplete: function waitBackgroundMusicComplete() {
      if (!this.parent.soundManager) {
        return this.waitTime(0);
      }
      var music = this.parent.soundManager.getBackgroundMusic();
      if (!music) {
        return this.waitTime(0);
      }
      return this.waitEvent(music, 'complete');
    },
    waitBackgroundMusic2Complete: function waitBackgroundMusic2Complete() {
      if (!this.parent.soundManager) {
        return this.waitTime(0);
      }
      var music = this.parent.soundManager.getBackgroundMusic2();
      if (!music) {
        return this.waitTime(0);
      }
      return this.waitEvent(music, 'complete');
    }
  };

  var WaitAny$1 = function WaitAny(config) {
    if (!config) {
      return this.waitTime(0);
    }
    var hasAnyWaitEvent = false;
    for (var name in config) {
      switch (name) {
        case 'time':
          hasAnyWaitEvent = true;
          this.waitTime(config.time);
          break;
        case 'click':
          hasAnyWaitEvent = true;
          this.waitClick(config.key);
          break;
        case 'key':
          hasAnyWaitEvent = true;
          this.waitKeyDown(config.key);
          break;
        case 'bgm':
          hasAnyWaitEvent = true;
          this.waitBackgroundMusicComplete();
          break;
        case 'bgm2':
          hasAnyWaitEvent = true;
          this.waitBackgroundMusic2Complete();
          break;
        case 'se':
          hasAnyWaitEvent = true;
          this.waitSoundEffectComplete();
          break;
        case 'se2':
          hasAnyWaitEvent = true;
          this.waitSoundEffect2Complete();
          break;
        case 'camera':
          hasAnyWaitEvent = true;
          this.waitCameraEffectComplete("camera.".concat(config.camera.toLowerCase()));
          break;
        default:
          var names = name.split('.');
          if (names.length === 2) {
            // GONAME.destroy, GONAME.PROPNAME, GONAME.DATAKEY, GONAME.EVTNAME

            var gameObjectName = names[0];
            var propName = names[1];
            var gameObjectManager = this.parent.getGameObjectManager(undefined, gameObjectName);
            if (!gameObjectManager) {
              continue;
            }

            // GONAME.destroy
            if (propName === 'destroy') {
              return this.waitGameObjectDestroy(undefined, gameObjectName);
            }

            // GONAME.PROPNAME (tween.complete)
            var value = gameObjectManager.getProperty(gameObjectName, propName);
            if (typeof value === 'number') {
              hasAnyWaitEvent = true;
              this.waitGameObjectTweenComplete(undefined, gameObjectName, propName);
              continue;
            }

            // GONAME.DATAKEY (boolean)
            var dataKey = propName;
            var matchFalseFlag = dataKey.startsWith('!');
            if (matchFalseFlag) {
              dataKey = dataKey.substring(1);
            }
            if (gameObjectManager.hasData(gameObjectName, propName)) {
              hasAnyWaitEvent = true;
              this.waitGameObjectDataFlag(undefined, gameObjectName, dataKey, !matchFalseFlag);
              continue;
            }

            // GONAME.EVTNAME
            this.waitEvent(gameObject, propName);
            continue;
          } else if (names.length === 1) ;
          break;
      }
    }
    if (!hasAnyWaitEvent) {
      this.waitTime(0);
    }
    return this.parent;
  };

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  //  Source object
  //  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
  //  The default value to use if the key doesn't exist

  /**
   * Retrieves a value from an object.
   *
   * @function Phaser.Utils.Objects.GetValue
   * @since 3.0.0
   *
   * @param {object} source - The object to retrieve the value from.
   * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.
   * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.
   *
   * @return {*} The value of the requested key.
   */
  var GetValue$38 = function GetValue(source, key, defaultValue) {
    if (!source || typeof source === 'number') {
      return defaultValue;
    } else if (source.hasOwnProperty(key)) {
      return source[key];
    } else if (key.indexOf('.') !== -1) {
      var keys = key.split('.');
      var parent = source;
      var value = defaultValue;

      //  Use for loop here so we can break early
      for (var i = 0; i < keys.length; i++) {
        if (parent.hasOwnProperty(keys[i])) {
          //  Yes it has a key property, let's carry on down
          value = parent[keys[i]];
          parent = parent[keys[i]];
        } else {
          //  Can't go any further, so reset to default
          value = defaultValue;
          break;
        }
      }
      return value;
    } else {
      return defaultValue;
    }
  };

  var WaitEventManager = /*#__PURE__*/function (_WaitEvent) {
    _inherits(WaitEventManager, _WaitEvent);
    function WaitEventManager(parent, config) {
      var _this;
      _classCallCheck(this, WaitEventManager);
      _this = _callSuper(this, WaitEventManager, [parent]);
      _this.waitCompleteEventName = GetValue$38(config, 'completeEventName', _this.waitCompleteEventName);
      _this.setClickTarget(GetValue$38(config, 'clickTarget', _this.scene));
      _this.setCameraTarget(GetValue$38(config, 'camera', _this.scene.cameras.main));
      return _this;
    }
    _createClass(WaitEventManager, [{
      key: "clickTarget",
      get: function get() {
        return this.parent.clickTarget;
      },
      set: function set(value) {
        this.parent.clickTarget = value;
      }
    }, {
      key: "cameraTarget",
      get: function get() {
        return this.parent.cameraTarget;
      },
      set: function set(value) {
        this.parent.cameraTarget = value;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.setClickTarget();
        this.setCameraTarget();
        _get(_getPrototypeOf(WaitEventManager.prototype), "destroy", this).call(this);
      }
    }, {
      key: "scene",
      get: function get() {
        return this.parent.managersScene;
      }
    }]);
    return WaitEventManager;
  }(WaitEvent$1);
  var Methods$k = {
    waitAny: WaitAny$1
  };
  Object.assign(WaitEventManager.prototype, WaitTimeMethods, WaitInputMethods, WaitGameObjectMethods, WaitCameraMethods, WaitMusicMethods, Methods$k);

  var GetValue$37 = Phaser.Utils.Objects.GetValue;
  var InitManagers = function InitManagers(scene, config) {
    this.clickTarget = undefined;
    this.cameraTarget = undefined;
    this.managersScene = scene;
    this.gameObjectManagers = {};
    var layerNames = GetValue$37(config, 'layers', false);
    if (layerNames !== false) {
      var layerManager = new LayerManager(scene, {
        layers: layerNames,
        rootLayer: GetValue$37(config, 'rootLayer', undefined),
        depth: GetValue$37(config, 'layerDepth', undefined)
      });
      this.gameObjectManagers.layer = layerManager;
      this.layerManager = layerManager;
    }
    var soundManagerConfig = GetValue$37(config, 'sounds');
    if (soundManagerConfig !== false) {
      this.soundManager = new SoundManager(scene, soundManagerConfig);
    }
    this.timeline = new Timeline(this);
    this.waitEventManager = new WaitEventManager(this, config);
    return this;
  };

  var SetTimeScale = function SetTimeScale(value) {
    this.timeline.timeScale = value;
    for (var name in this.gameObjectManagers) {
      this.gameObjectManagers[name].setTimeScale(value);
    }
    return this;
  };

  var GetTimeScale = function GetTimeScale() {
    return this.timeline.timeScale;
  };

  var DestroyManagers = function DestroyManagers(fromScene) {
    this.waitEventManager.destroy();
    this.waitEventManager = undefined;

    // Destroy layerManager at last
    delete this.gameObjectManagers.layer;
    for (var name in this.gameObjectManagers) {
      this.gameObjectManagers[name].destroy(fromScene);
      delete this.gameObjectManagers[name];
    }
    if (this.layerManager) {
      this.layerManager.destroy(fromScene);
      this.layerManager = undefined;
    }
    if (this.soundManager) {
      this.soundManager.destroy();
      this.soundManager = undefined;
    }
    if (this.timeline) {
      this.timeline.destroy();
      this.timeline = undefined;
    }
    this.clickTarget = undefined;
    this.cameraTarget = undefined;
    this.managersScene = undefined;
  };

  var GameObjectManagerMethods$1 = {
    addGameObjectManager: function addGameObjectManager(config, GameObjectManagerClass) {
      if (config === undefined) {
        config = {};
      }
      if (GameObjectManagerClass === undefined) {
        GameObjectManagerClass = GOManager;
      }
      if (!config.createGameObjectScope) {
        config.createGameObjectScope = this;
      }
      var gameobjectManager = new GameObjectManagerClass(this.managersScene, config);
      this.gameObjectManagers[config.name] = gameobjectManager;
      return this;
    },
    getGameObjectManager: function getGameObjectManager(managerName, gameObjectName) {
      if (managerName) {
        var manager = this.gameObjectManagers[managerName];
        return manager;
      } else {
        for (var managerName in this.gameObjectManagers) {
          var manager = this.gameObjectManagers[managerName];
          if (manager.has(gameObjectName)) {
            return manager;
          }
        }
      }
    },
    getGameObjectManagerNames: function getGameObjectManagerNames() {
      var names = [];
      for (var name in this.gameObjectManagers) {
        names.push(name);
      }
      return names;
    },
    getGameObjectManagerName: function getGameObjectManagerName(gameObjectName) {
      for (var managerName in this.gameObjectManagers) {
        if (this.gameObjectManagers[managerName].has(gameObjectName)) {
          return managerName;
        }
      }
    },
    hasGameObjectMananger: function hasGameObjectMananger(managerName) {
      return managerName in this.gameObjectManagers;
    }
  };

  var GameObjectMethods$1 = {
    createGameObject: function createGameObject(goType, name) {
      var _this$getGameObjectMa;
      for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        params[_key - 2] = arguments[_key];
      }
      (_this$getGameObjectMa = this.getGameObjectManager(goType, name)).add.apply(_this$getGameObjectMa, [name].concat(params));
      return this;
    },
    destroyGameObject: function destroyGameObject(goType, name) {
      var gameObjectManager = this.getGameObjectManager(goType, name);
      if (name === undefined) {
        gameObjectManager.removeAll();
      } else {
        gameObjectManager.remove(name);
      }
      return this;
    },
    hasGameObject: function hasGameObject(goType, name) {
      return !!this.getGameObjectManager(goType, name);
    },
    callGameObjectMethod: function callGameObjectMethod(goType, name, methodName) {
      var _this$getGameObjectMa2;
      for (var _len2 = arguments.length, params = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        params[_key2 - 3] = arguments[_key2];
      }
      (_this$getGameObjectMa2 = this.getGameObjectManager(goType, name)).call.apply(_this$getGameObjectMa2, [name, methodName].concat(params));
      return this;
    },
    setGameObjectProperty: function setGameObjectProperty(goType, name, prop, value) {
      this.getGameObjectManager(goType, name).setProperty(name, prop, value);
      return this;
    },
    easeGameObjectProperty: function easeGameObjectProperty(goType, name, prop, value, duration, ease, repeat, isYoyo) {
      this.getGameObjectManager(goType, name).easeProperty(name, prop, value, duration, ease, repeat, isYoyo);
      return this;
    },
    getGameObjectTweenTask: function getGameObjectTweenTask(goType, name, property) {
      return this.getGameObjectManager(goType, name).getTweenTask(name, property);
    },
    getGameObject: function getGameObject(goType, name, out) {
      var gameobjectManager = this.getGameObjectManager(goType, name);
      if (typeof name === 'string') {
        return gameobjectManager.getGO(name);
      } else {
        var names = name;
        if (names === undefined) {
          names = gameobjectManager.bobs;
        }
        if (out === undefined) {
          out = {};
        }
        for (name in names) {
          out[name] = gameobjectManager.getGO(name);
        }
        return out;
      }
    },
    addGameObject: function addGameObject(goType, name, gameObject) {
      var gameobjectManager = this.getGameObjectManager(goType, name);
      if (typeof name === 'string') {
        gameobjectManager.addGO(name, gameObject);
      } else {
        var names = name;
        for (name in names) {
          gameobjectManager.addGO(name, names[name]);
        }
      }
      return this;
    },
    drawGameObjectsBounds: function drawGameObjectsBounds(goTypes, graphics, config) {
      if (goTypes instanceof Phaser.GameObjects.Graphics) {
        config = graphics;
        graphics = goTypes;
        goTypes = undefined;
      }
      if (goTypes === undefined) {
        goTypes = this.getGameObjectManagerNames();
      }
      if (!Array.isArray(goTypes)) {
        goTypes = [goTypes];
      }
      for (var i = 0, cnt = goTypes.length; i < cnt; i++) {
        this.getGameObjectManager(goTypes[i]).drawGameObjectsBounds(graphics, config);
      }
      return this;
    }
  };

  var Extend = function Extend(BaseClass) {
    var Managers = /*#__PURE__*/function (_BaseClass) {
      _inherits(Managers, _BaseClass);
      function Managers() {
        _classCallCheck(this, Managers);
        return _callSuper(this, Managers, arguments);
      }
      return _createClass(Managers);
    }(BaseClass);
    var Methods = {
      initManagers: InitManagers,
      setTimeScale: SetTimeScale,
      getTimeScale: GetTimeScale,
      destroyManagers: DestroyManagers
    };
    Object.assign(Managers.prototype, Methods, GameObjectManagerMethods$1, GameObjectMethods$1);
    return Managers;
  };

  var EventEmitter = Phaser.Events.EventEmitter;
  var Managers = /*#__PURE__*/function (_Extend) {
    _inherits(Managers, _Extend);
    function Managers(scene, config) {
      var _this;
      _classCallCheck(this, Managers);
      if (config === undefined) {
        config = {};
      }
      config.completeEventName = 'complete';
      if (!config.hasOwnProperty('layers')) {
        config.layers = undefined;
      }
      _this = _callSuper(this, Managers);
      _this.scene = scene;
      _this.initManagers(scene, config);
      return _this;
    }
    _createClass(Managers, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }
        this.destroyManagers(fromScene);
        this.scene = undefined;
        _get(_getPrototypeOf(Managers.prototype), "destroy", this).call(this);
      }
    }]);
    return Managers;
  }(Extend(EventEmitter));

  var EventEmitterMethods = {
    setEventEmitter: function setEventEmitter(eventEmitter, EventEmitterClass) {
      if (EventEmitterClass === undefined) {
        EventEmitterClass = EventEmitter$2;
      }
      this._privateEE = eventEmitter === true || eventEmitter === undefined;
      this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
      return this;
    },
    destroyEventEmitter: function destroyEventEmitter() {
      if (this._eventEmitter && this._privateEE) {
        this._eventEmitter.shutdown();
      }
      return this;
    },
    getEventEmitter: function getEventEmitter() {
      return this._eventEmitter;
    },
    on: function on() {
      if (this._eventEmitter) {
        this._eventEmitter.on.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    once: function once() {
      if (this._eventEmitter) {
        this._eventEmitter.once.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    off: function off() {
      if (this._eventEmitter) {
        this._eventEmitter.off.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    emit: function emit(event) {
      if (this._eventEmitter && event) {
        this._eventEmitter.emit.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    addListener: function addListener() {
      if (this._eventEmitter) {
        this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    removeListener: function removeListener() {
      if (this._eventEmitter) {
        this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    removeAllListeners: function removeAllListeners() {
      if (this._eventEmitter) {
        this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
      }
      return this;
    },
    listenerCount: function listenerCount() {
      if (this._eventEmitter) {
        return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
      }
      return 0;
    },
    listeners: function listeners() {
      if (this._eventEmitter) {
        return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
      }
      return [];
    },
    eventNames: function eventNames() {
      if (this._eventEmitter) {
        return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
      }
      return [];
    }
  };

  // https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js

  var EscapeRegex = function EscapeRegex(s) {
    return s.replace(re0, '\\$&').replace(re1, '\\x2d');
  };
  var re0 = /[|\\{}()[\]^$+*?.]/g;
  var re1 = /-/g;

  var BracketParser$1 = /*#__PURE__*/function () {
    function BracketParser(config) {
      _classCallCheck(this, BracketParser);
      // Event emitter
      this.setEventEmitter(GetValue$38(config, 'eventEmitter', undefined));

      // Value convert
      this.setValueConverter(GetValue$38(config, 'valueConvert', true));
      // Loop
      this.setLoopEnable(GetValue$38(config, 'loop', false));

      // Brackets and generate regex
      this.setMultipleLinesTagEnable(GetValue$38(config, 'multipleLinesTag', false));
      var delimiters = GetValue$38(config, 'delimiters', '<>');
      this.setDelimiters(delimiters[0], delimiters[1]);

      // Translate tagName callback
      this.setTranslateTagNameCallback(GetValue$38(config, 'translateTagNameCallback'));
      this.isRunning = false;
      this.isPaused = false;
      this.skipEventFlag = false;
      this.justCompleted = false;
      this.lastTagStart = null;
      this.lastTagEnd = null;
      this.lastContent = null;
    }
    _createClass(BracketParser, [{
      key: "shutdown",
      value: function shutdown() {
        this.destroyEventEmitter();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.shutdown();
      }
    }, {
      key: "setMultipleLinesTagEnable",
      value: function setMultipleLinesTagEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.multipleLinesTagEnable = enable;
        return this;
      }

      // Override
    }, {
      key: "setDelimiters",
      value: function setDelimiters(delimiterLeft, delimiterRight) {
        if (delimiterRight === undefined) {
          delimiterRight = delimiterLeft[1];
          delimiterLeft = delimiterLeft[0];
        }
        this.delimiterLeft = delimiterLeft;
        this.delimiterRight = delimiterRight;
        delimiterLeft = EscapeRegex(this.delimiterLeft);
        delimiterRight = EscapeRegex(this.delimiterRight);
        var flag = this.multipleLinesTagEnable ? 'gs' : 'gi';
        this.reSplit = RegExp("".concat(delimiterLeft, "(.+?)").concat(delimiterRight), flag);
        return this;
      }
    }, {
      key: "setTranslateTagNameCallback",
      value: function setTranslateTagNameCallback(callback) {
        this.translateTagNameCallback = callback;
        return this;
      }
    }, {
      key: "setValueConverter",
      value: function setValueConverter(converter) {
        if (converter === true) {
          converter = TypeConvert;
        } else if (!converter) {
          converter = BypassValueConverter;
        }
        this.valueConverter = converter;
        return this;
      }
    }, {
      key: "setLoopEnable",
      value: function setLoopEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.loopEnable = enable;
        return this;
      }
    }, {
      key: "setSource",
      value: function setSource(source) {
        this.source = source;
        return this;
      }
    }, {
      key: "resetIndex",
      value: function resetIndex(index) {
        if (index === undefined) {
          index = 0;
        }
        this.progressIndex = index;
        this.reSplit.lastIndex = index;
        this.lastTagStart = null;
        this.lastTagEnd = null;
        this.lastContent = null;
        this.justCompleted = false;
        this.isRunning = false;
        return this;
      }
    }, {
      key: "start",
      value: function start(source) {
        this.setSource(source).restart();
        return this;
      }
    }, {
      key: "restart",
      value: function restart() {
        this.resetIndex().next();
      }
    }, {
      key: "next",
      value: function next() {
        if (this.isPaused) {
          this.onResume();
        }

        // Don't re-enter this method
        if (this.isRunning) {
          return this;
        }
        this.isRunning = true;
        if (this.justCompleted) {
          this.isRunning = false;
          return this;
        }
        if (this.reSplit.lastIndex === 0) {
          this.onStart();
        }
        var text = this.source,
          lastIndex = text.length;
        this.reSplit.lastIndex = this.progressIndex;
        while (true) {
          var regexResult = this.reSplit.exec(text);
          // No tag found, complete
          if (!regexResult) {
            if (this.progressIndex < lastIndex) {
              this.onContent(text.substring(this.progressIndex, lastIndex));
              // Might pause here
              if (this.isPaused) {
                this.progressIndex = lastIndex;
                break;
              }
            }
            this.onComplete();
            this.isRunning = false;
            return;
          }
          var matchEnd = this.reSplit.lastIndex;
          var matchStart = matchEnd - regexResult[0].length;

          // Process content between previous tag and current tag            
          if (this.progressIndex < matchStart) {
            this.onContent(text.substring(this.progressIndex, matchStart));
            // Might pause here
            if (this.isPaused) {
              this.progressIndex = matchStart;
              break;
            }
          }

          // Process current tag
          this.lastTagSource = regexResult[0];
          this.onTag(regexResult[1]);
          this.lastTagSource = undefined;
          this.progressIndex = matchEnd;
          // Might pause here
          if (this.isPaused) {
            break;
          }
        }
        this.isRunning = false;
        return this;
      }
    }, {
      key: "skipEvent",
      value: function skipEvent() {
        this.skipEventFlag = true;
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        if (!this.isPaused) {
          this.onPause();
        }
        return this;
      }
    }, {
      key: "pauseUntilEvent",
      value: function pauseUntilEvent(eventEmitter, eventName) {
        if (this.isPaused) {
          return this;
        }
        this.pause();
        eventEmitter.once(eventName, function () {
          this.next();
        }, this);
        return this;
      }
    }, {
      key: "onContent",
      value: function onContent(content) {
        this.skipEventFlag = false;
        this.emit('content', content);
        this.lastContent = content;
      }

      // Override
    }, {
      key: "onTag",
      value: function onTag(tagContent) {}
    }, {
      key: "onStart",
      value: function onStart() {
        this.isRunning = true;
        this.emit('start', this);
      }
    }, {
      key: "onComplete",
      value: function onComplete() {
        this.isRunning = false;
        this.justCompleted = true;
        this.emit('complete', this);
        if (this.loopEnable) {
          this.resetIndex();
        }
      }
    }, {
      key: "onPause",
      value: function onPause() {
        this.isPaused = true;
        this.emit('pause', this);
      }
    }, {
      key: "onResume",
      value: function onResume() {
        this.isPaused = false;
        this.emit('resume', this);
      }
    }]);
    return BracketParser;
  }();
  var BypassValueConverter = function BypassValueConverter(s) {
    return s;
  };
  Object.assign(BracketParser$1.prototype, EventEmitterMethods);

  var StringToValues = function StringToValues(text, valueConverter, delimiter) {
    if (text == null) {
      return [];
    }
    if (valueConverter === undefined) {
      valueConverter = TypeConvert;
    }
    if (delimiter === undefined) {
      delimiter = ',';
    }
    var values = text.split(delimiter);
    for (var i = 0, cnt = values.length; i < cnt; i++) {
      values[i] = valueConverter(values[i]);
    }
    return values;
  };

  var BracketParser = /*#__PURE__*/function (_BracketParserBase) {
    _inherits(BracketParser, _BracketParserBase);
    function BracketParser(config) {
      var _this;
      _classCallCheck(this, BracketParser);
      if (config === undefined) {
        config = {};
      }
      if (!config.hasOwnProperty('multipleLinesTag')) {
        config.multipleLinesTag = false;
      }
      _this = _callSuper(this, BracketParser, [config]);

      // Parameters for regex
      _this.setTagExpression(GetValue$38(config, 'regex.tag', undefined));
      _this.setValueExpression(GetValue$38(config, 'regex.value', undefined));
      // Brackets and generate regex
      var delimiters = GetValue$38(config, 'delimiters', '<>');
      _this.setDelimiters(delimiters[0], delimiters[1]);
      return _this;
    }
    _createClass(BracketParser, [{
      key: "setTagExpression",
      value: function setTagExpression(express) {
        if (!express) {
          express = DefaultTokenExpression;
        }
        this.tagExpression = express;
        return this;
      }
    }, {
      key: "setValueExpression",
      value: function setValueExpression(express) {
        if (!express) {
          express = DefaultTokenExpression;
        }
        this.valueExpression = express;
        return this;
      }
    }, {
      key: "setDelimiters",
      value: function setDelimiters(delimiterLeft, delimiterRight) {
        _get(_getPrototypeOf(BracketParser.prototype), "setDelimiters", this).call(this, delimiterLeft, delimiterRight);
        var tag = "(".concat(this.tagExpression, ")(=(").concat(this.valueExpression, "))?");
        this.reTag = RegExp(tag, 'i');
        if (this.tagExpression !== DefaultTokenExpression || this.valueExpression !== DefaultTokenExpression) {
          var startTagExpression = "".concat(this.tagExpression, "(=").concat(this.valueExpression, ")?");
          var endTagExpression = "/".concat(this.tagExpression);
          delimiterLeft = EscapeRegex(this.delimiterLeft);
          delimiterRight = EscapeRegex(this.delimiterRight);
          var flag = this.multipleLinesTagEnable ? 'gs' : 'gi';
          this.reSplit = RegExp("".concat(delimiterLeft, "((").concat(startTagExpression, ")|(").concat(endTagExpression, "))").concat(delimiterRight), flag);
        }
        return this;
      }
    }, {
      key: "onTag",
      value: function onTag(tagContent) {
        var regexResult = tagContent.match(this.reTag);
        var tagName = regexResult[1];
        var isEndTag = tagName.charAt(0) === '/';
        if (isEndTag) {
          tagName = tagName.substring(1, tagName.length);
        }
        if (this.translateTagNameCallback) {
          tagName = this.translateTagNameCallback(tagName);
        }
        this.skipEventFlag = false;
        if (!isEndTag) {
          var values = StringToValues(regexResult[3], this.valueConverter);
          this.emit.apply(this, ["+".concat(tagName)].concat(_toConsumableArray(values)));
          if (!this.skipEventFlag) {
            this.emit.apply(this, ['+', tagName].concat(_toConsumableArray(values)));
          }
          this.lastTagStart = tagName;
        } else {
          this.emit("-".concat(tagName));
          if (!this.skipEventFlag) {
            this.emit('-', tagName);
          }
          this.lastTagEnd = tagName;
        }
      }
    }]);
    return BracketParser;
  }(BracketParser$1);
  var DefaultTokenExpression = "[^=]+";

  var OnParseColorTag$1 = function OnParseColorTag(parser) {
    parser.on('+color', function (color) {
      parser.addStyle('color', color);
      parser.skipEvent();
    }).on('-color', function () {
      parser.removeStyle('color');
      parser.skipEvent();
    });
  };

  var OnParseBackgroundColorTag = function OnParseBackgroundColorTag(parser) {
    parser.on('+bgcolor', function (color) {
      parser.addStyle('background-color', color);
      parser.skipEvent();
    }).on('-bgcolor', function () {
      parser.removeStyle('background-color');
      parser.skipEvent();
    });
  };

  var ParseBoldTag = function ParseBoldTag(parser) {
    parser.on('+b', function () {
      parser.addStyle('font-weight', 'bold');
      parser.skipEvent();
    }).on('-b', function () {
      parser.removeStyle('font-weight');
      parser.skipEvent();
    });
  };

  var OnParseItalicTag$1 = function OnParseItalicTag(parser) {
    parser.on('+i', function () {
      parser.addStyle('font-style', 'italic');
      parser.skipEvent();
    }).on('-i', function () {
      parser.removeStyle('font-style');
      parser.skipEvent();
    });
  };

  var OnParseSizeTag = function OnParseSizeTag(parser) {
    parser.on('+size', function (size) {
      if (typeof size === 'number') {
        size = "".concat(size, "px");
      }
      parser.addStyle('font-size', size);
      parser.skipEvent();
    }).on('-size', function () {
      parser.removeStyle('font-size');
      parser.skipEvent();
    });
  };

  var OnParseUnderlineTag = function OnParseUnderlineTag(parser) {
    parser.on('+u', function () {
      parser.addStyle('text-decoration', 'underline');
      parser.skipEvent();
    }).on('-u', function () {
      parser.removeStyle('text-decoration');
      parser.skipEvent();
    });
  };

  var OnParseShadowTag = function OnParseShadowTag(parser) {
    parser.on('+shadow', function (color) {
      parser.addStyle('text-shadow', "1px 1px 3px ".concat(color));
      parser.skipEvent();
    }).on('-shadow', function () {
      parser.removeStyle('text-shadow');
      parser.skipEvent();
    });
  };

  var OnParseRoundBlockTag = function OnParseRoundBlockTag(parser) {
    parser.on('+round', function (radius, padding) {
      if (radius === undefined) {
        radius = 3;
      }
      if (padding === undefined) {
        padding = radius;
      }
      if (typeof radius === 'number') {
        radius = "".concat(radius, "px");
      }
      if (typeof padding === 'number') {
        padding = "".concat(padding, "px");
      }
      parser.addStyle('display', 'inline-block');
      parser.addStyle('border-radius', radius);
      parser.addStyle('padding', padding);
      parser.skipEvent();
    }).on('-round', function () {
      parser.removeStyle('display');
      parser.removeStyle('border-radius');
      parser.removeStyle('padding');
      parser.skipEvent();
    });
  };

  var OnParseFontFamilyTag = function OnParseFontFamilyTag(parser) {
    parser.on('+family', function (family) {
      parser.addStyle('font-family', family);
      parser.skipEvent();
    }).on('-family', function () {
      parser.removeStyle('font-family');
      parser.skipEvent();
    });
  };

  var ParseContent = function ParseContent(parser) {
    parser.on('content', function (content) {
      parser.addContent(content);
      parser.skipEvent();
    }).on('+', function () {
      parser.addContent(parser.lastTagSource);
      parser.skipEvent();
    }).on('-', function () {
      parser.addContent(parser.lastTagSource);
      parser.skipEvent();
    });
  };

  var ParseHandlers = [OnParseColorTag$1, OnParseBackgroundColorTag, ParseBoldTag, OnParseItalicTag$1, OnParseSizeTag, OnParseUnderlineTag, OnParseShadowTag, OnParseRoundBlockTag, OnParseFontFamilyTag, ParseContent];

  var Clear$1 = function Clear(obj) {
    if (_typeof(obj) !== 'object' || obj === null) {
      return obj;
    }
    if (Array.isArray(obj)) {
      obj.length = 0;
    } else {
      for (var key in obj) {
        delete obj[key];
      }
    }
    return obj;
  };

  /**
   * Shallow Object Clone. Will not out nested objects.
   * @param {object} obj JSON object
   * @param {object} ret JSON object to return, set null to return a new object
   * @returns {object} this object
   */
  var Clone$2 = function Clone(obj, out) {
    var objIsArray = Array.isArray(obj);
    if (out === undefined) {
      out = objIsArray ? [] : {};
    } else {
      Clear$1(out);
    }
    if (objIsArray) {
      out.length = obj.length;
      for (var i = 0, cnt = obj.length; i < cnt; i++) {
        out[i] = obj[i];
      }
    } else {
      for (var key in obj) {
        out[key] = obj[key];
      }
    }
    return out;
  };

  var Parser$2 = /*#__PURE__*/function (_BracketParser) {
    _inherits(Parser, _BracketParser);
    function Parser(config) {
      var _this;
      _classCallCheck(this, Parser);
      _this = _callSuper(this, Parser, [config]);
      _this.segments = [];
      _this.lastPropFlags = {};
      for (var i = 0, cnt = ParseHandlers.length; i < cnt; i++) {
        ParseHandlers[i](_assertThisInitialized(_this));
      }
      return _this;
    }
    _createClass(Parser, [{
      key: "clearBuffers",
      value: function clearBuffers() {
        this.segments.length = 0;
        this.lastPropFlags = {};
        return this;
      }
    }, {
      key: "addStyle",
      value: function addStyle(name, value) {
        this.lastPropFlags[name] = value;
        return this;
      }
    }, {
      key: "removeStyle",
      value: function removeStyle(name) {
        delete this.lastPropFlags[name];
        return this;
      }
    }, {
      key: "addContent",
      value: function addContent(content) {
        this.segments.push(Clone$2(this.lastPropFlags));
        this.segments.push(content);
        return this;
      }
    }, {
      key: "parse",
      value: function parse(s) {
        this.start(s);
        var result = [];
        for (var i = 0, cnt = this.segments.length; i < cnt; i++) {
          var text = this.segments[i];
          if (typeof text !== 'string') {
            continue;
          }
          var propFlags = this.segments[i - 1];
          if (_typeof(propFlags) === 'object') {
            result.push({
              value: text,
              css: PropToStyle(propFlags)
            });
          } else {
            result.push({
              value: text,
              css: null
            });
          }
        }
        this.clearBuffers();
        return result;
      }
    }]);
    return Parser;
  }(BracketParser);
  var PropToStyle = function PropToStyle(propFlags) {
    var styles = [];
    for (var propName in propFlags) {
      styles.push("".concat(propName, ":").concat(propFlags[propName]));
    }
    return styles.join(';');
  };

  var BBCodeLog = /*#__PURE__*/function () {
    function BBCodeLog() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$delimiters = _ref.delimiters,
        delimiters = _ref$delimiters === void 0 ? '[]' : _ref$delimiters,
        _ref$enable = _ref.enable,
        enable = _ref$enable === void 0 ? true : _ref$enable;
      _classCallCheck(this, BBCodeLog);
      this.parser = new Parser$2({
        delimiters: delimiters
      });
      this.enable = enable;
    }
    _createClass(BBCodeLog, [{
      key: "setEnable",
      value: function setEnable() {
        var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.enable = enable;
        return this;
      }
    }, {
      key: "log",
      value: function log(s) {
        var logType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'log';
        if (!this.enable) {
          return this;
        }
        if (typeof s == 'string') {
          var _console$logType;
          var inputs = [];
          var modifiers = [];
          this.parser.parse(s).forEach(function (item) {
            inputs.push("%c".concat(item.value));
            modifiers.push(item.css);
          });
          (_console$logType = console[logType]).call.apply(_console$logType, [console, inputs.join('')].concat(modifiers));
        } else {
          console[logType](s);
        }
        return this;
      }
    }]);
    return BBCodeLog;
  }();

  var AddCommand = function AddCommand(name, callback, scope) {
    if (scope === undefined) {
      scope = this;
    }
    if (scope) {
      callback = callback.bind(scope);
    }
    if (this[name]) {
      console.warn("CommandExecutor: method '".concat(name, " is existed."));
    }
    this[name] = callback;
    return this;
  };

  var EventSheetManagerMethods = {
    // TODO: More commands
    setData: function setData(config, eventSheetManager, eventsheet) {
      for (var name in config) {
        eventSheetManager.setData(name, config[name]);
      }
    },
    incData: function incData(config, eventSheetManager, eventsheet) {
      for (var name in config) {
        eventSheetManager.incData(name, config[name]);
      }
    },
    toggleData: function toggleData(config, eventSheetManager, eventsheet) {
      for (var name in config) {
        eventSheetManager.toggleData(name, config[name]);
      }
    }
  };

  var WaitMethods = {
    clearWaitEventFlag: function clearWaitEventFlag() {
      this.hasAnyWaitEvent = false;
      return this;
    },
    setWaitEventFlag: function setWaitEventFlag() {
      this.hasAnyWaitEvent = true;
      return this;
    },
    waitEvent: function waitEvent(eventEmitter, eventName) {
      this.sys.waitEventManager.waitEvent(eventEmitter, eventName);
      this.setWaitEventFlag();
      return this;
    },
    wait: function wait(config, eventSheetManager, eventsheet) {
      var click = config.click,
        key = config.key;
      if (click) {
        eventSheetManager.emit('pause.click');
      }
      if (key) {
        eventSheetManager.emit('pause.key', config.key);
      }
      if (click | key) {
        eventSheetManager.emit('pause.input');
        this.sys.once('complete', function () {
          eventSheetManager.emit('resume.input');
        });
      }
      this.sys.waitEventManager.waitAny(config);
      return this.sys;
    },
    click: function click(config, eventSheetManager, eventsheet) {
      return this.wait({
        click: true
      }, eventSheetManager);
    }
  };

  var GameObjectMethods = {
    addGameObjectManager: function addGameObjectManager(config) {
      // Register GameObjectManager
      var sys = this.sys;
      sys.addGameObjectManager(config);
      var name = config.name,
        defaultLayer = config.defaultLayer,
        _config$commands = config.commands,
        commands = _config$commands === void 0 ? {} : _config$commands;

      // Add custom commands
      sys.getGameObjectManager(name).commands = commands;

      // Add createGameObject command
      var createGameObjectCallback = function createGameObjectCallback(config, eventSheetManager) {
        var id = config.id,
          _config$layer = config.layer,
          layer = _config$layer === void 0 ? defaultLayer : _config$layer;
        delete config.id;
        delete config.layer;
        sys.createGameObject(name, id, config);
        // Execute next command

        if (layer) {
          var layerManager = sys.layerManager;
          if (layerManager) {
            var gameObject = sys.getGameObject(name, id);
            layerManager.addToLayer(layer, gameObject);
          }
        }
      };
      this.addCommand(name, createGameObjectCallback, null);
      return this;
    },
    addGameObjectCommand: function addGameObjectCommand(goType, commandName, callback) {
      this.sys.getGameObjectManager(goType).commands[commandName] = callback;
      return this;
    },
    _setGOProperty: function _setGOProperty(config, eventSheetManager, eventsheet) {
      var id = config.id;
      delete config.id;
      var goType = this.sys.getGameObjectManagerName(id);
      if (!goType) {
        return;
      }
      for (var prop in config) {
        var value = eventSheetManager.evalExpression(config[prop]);
        this.sys.setGameObjectProperty(goType, id, prop, value);
      }
      // Execute next command
    },
    _easeGOProperty: function _easeGOProperty(config, eventSheetManager, eventsheet) {
      var id = config.id,
        duration = config.duration,
        ease = config.ease,
        repeat = config.repeat,
        yoyo = config.yoyo,
        _config$wait = config.wait,
        wait = _config$wait === void 0 ? true : _config$wait;
      delete config.id;
      delete config.duration;
      delete config.ease;
      delete config.repeat;
      delete config.yoyo;
      delete config.wait;
      var goType = this.sys.getGameObjectManagerName(id);
      if (!goType) {
        return;
      }
      var waitProperty;
      for (var prop in config) {
        var value = eventSheetManager.evalExpression(config[prop]);
        this.sys.easeGameObjectProperty(goType, id, prop, value, duration, ease, repeat, yoyo);
        waitProperty = prop;
      }
      if (wait && waitProperty) {
        return this.sys.waitEventManager.waitGameObjectTweenComplete(goType, id, waitProperty);
      }

      // Execute next command
    },
    _destroyGO: function _destroyGO() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id,
        _ref$wait = _ref.wait,
        wait = _ref$wait === void 0 ? false : _ref$wait;
      var goType = this.sys.getGameObjectManagerName(id);
      if (!goType) {
        return;
      }
      this.sys.destroyGameObject(goType, id);
      if (wait) {
        return this.sys.waitEventManager.waitGameObjectDestroy(goType, id);
      }
    },
    _runGOMethod: function _runGOMethod(config, eventSheetManager, eventsheet) {
      var _this$sys;
      var goType = this.sys.getGameObjectManagerName(id);
      if (!goType) {
        return;
      }
      (_this$sys = this.sys).callGameObjectMethod.apply(_this$sys, [goType, config.id, config.methodName].concat(_toConsumableArray(config.parameters)));
      // Execute next command
    }
  };

  var BackgroundMusicMethods = {
    bgm: function bgm() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        volume = _ref.volume,
        mute = _ref.mute,
        unmute = _ref.unmute;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (volume !== undefined) {
        soundManager.setBackgroundMusicVolume(volume);
      }
      if (mute !== undefined) {
        soundManager.setBackgroundMusicMute(mute);
      } else if (unmute !== undefined) {
        soundManager.setBackgroundMusicMute(!unmute);
      }
    },
    'bgm.play': function bgmPlay() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        key = _ref2.key,
        volume = _ref2.volume,
        detune = _ref2.detune,
        rate = _ref2.rate,
        _ref2$fadeIn = _ref2.fadeIn,
        fadeIn = _ref2$fadeIn === void 0 ? 0 : _ref2$fadeIn,
        loop = _ref2.loop,
        _ref2$wait = _ref2.wait,
        wait = _ref2$wait === void 0 ? false : _ref2$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (!key) {
        return;
      }
      if (loop !== undefined) {
        soundManager.setBackgroundMusicLoopValue(loop);
      }
      soundManager.playBackgroundMusic(key);
      if (volume !== undefined) {
        soundManager.setBackgroundMusicVolume(volume);
      }
      if (detune !== undefined) {
        soundManager.setBackgroundMusicDetune(detune);
      }
      if (rate !== undefined) {
        soundManager.setBackgroundMusicRate(rate);
      }
      if (fadeIn > 0) {
        soundManager.fadeInBackgroundMusic(fadeIn);
      }
      if (wait) {
        return this.wait({
          bgm: true
        }, eventSheetManager);
      }
    },
    'bgm.cross': function bgmCross(_ref3, eventSheetManager, eventsheet) {
      var key = _ref3.key,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === void 0 ? 500 : _ref3$duration,
        _ref3$wait = _ref3.wait,
        wait = _ref3$wait === void 0 ? false : _ref3$wait;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (!key) {
        return;
      }
      soundManager.crossFadeBackgroundMusic(key, duration);
      if (wait) {
        return this.wait({
          bgm: true
        }, eventSheetManager);
      }
    },
    'bgm.stop': function bgmStop(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.stopBackgroundMusic();
    },
    'bgm.fadeOut': function bgmFadeOut(_ref4, eventSheetManager) {
      var _ref4$duration = _ref4.duration,
        duration = _ref4$duration === void 0 ? 500 : _ref4$duration,
        _ref4$stop = _ref4.stop,
        stop = _ref4$stop === void 0 ? true : _ref4$stop,
        _ref4$wait = _ref4.wait,
        wait = _ref4$wait === void 0 ? false : _ref4$wait;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.fadeOutBackgroundMusic2(duration, stop);
      if (wait) {
        return this.wait({
          bgm: true
        }, eventSheetManager);
      }
    },
    'bgm.fadeIn': function bgmFadeIn(_ref5, eventSheetManager, eventsheet) {
      var _ref5$duration = _ref5.duration,
        duration = _ref5$duration === void 0 ? 500 : _ref5$duration;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.fadeInBackgroundMusic(duration);
    },
    'bgm.pause': function bgmPause(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.pauseBackgroundMusic();
    },
    'bgm.resume': function bgmResume(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.resumeBackgroundMusic();
    },
    'bgm.mute': function bgmMute(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.setBackgroundMusicMute(true);
    },
    'bgm.unmute': function bgmUnmute(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.setBackgroundMusicMute(false);
    }
  };

  var BackgroundMusic2Methods = {
    bgm2: function bgm2() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        volume = _ref.volume,
        mute = _ref.mute,
        unmute = _ref.unmute;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (volume !== undefined) {
        soundManager.setBackgroundMusic2Volume(volume);
      }
      if (mute !== undefined) {
        soundManager.setBackgroundMusic2Mute(mute);
      } else if (unmute !== undefined) {
        soundManager.setBackgroundMusic2Mute(!unmute);
      }
    },
    'bgm2.play': function bgm2Play() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        key = _ref2.key,
        volume = _ref2.volume,
        detune = _ref2.detune,
        rate = _ref2.rate,
        _ref2$fadeIn = _ref2.fadeIn,
        fadeIn = _ref2$fadeIn === void 0 ? 0 : _ref2$fadeIn,
        loop = _ref2.loop,
        _ref2$wait = _ref2.wait,
        wait = _ref2$wait === void 0 ? false : _ref2$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (!key) {
        return;
      }
      if (loop !== undefined) {
        soundManager.setBackgroundMusic2LoopValue(loop);
      }
      soundManager.playBackgroundMusic2(key);
      if (volume !== undefined) {
        soundManager.setBackgroundMusic2Volume(volume);
      }
      if (detune !== undefined) {
        soundManager.setBackgroundMusic2Detune(detune);
      }
      if (rate !== undefined) {
        soundManager.setBackgroundMusic2Rate(rate);
      }
      if (fadeIn > 0) {
        soundManager.fadeInBackgroundMusic2(fadeIn);
      }
      if (wait) {
        return this.wait({
          bgm: true
        }, eventSheetManager);
      }
    },
    'bgm2.cross': function bgm2Cross(_ref3, eventSheetManager, eventsheet) {
      var key = _ref3.key,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === void 0 ? 500 : _ref3$duration,
        _ref3$wait = _ref3.wait,
        wait = _ref3$wait === void 0 ? false : _ref3$wait;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (!key) {
        return;
      }
      soundManager.crossFadeBackgroundMusic2(key, duration);
      if (wait) {
        return this.wait({
          bgm: true
        }, eventSheetManager);
      }
    },
    'bgm2.stop': function bgm2Stop(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.stopBackgroundMusic2();
    },
    'bgm2.fadeOut': function bgm2FadeOut(_ref4, eventSheetManager) {
      var _ref4$duration = _ref4.duration,
        duration = _ref4$duration === void 0 ? 500 : _ref4$duration,
        _ref4$stop = _ref4.stop,
        stop = _ref4$stop === void 0 ? true : _ref4$stop,
        _ref4$wait = _ref4.wait,
        wait = _ref4$wait === void 0 ? false : _ref4$wait;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.fadeOutBackgroundMusic2(duration, stop);
      if (wait) {
        return this.wait({
          bgm: true
        }, eventSheetManager);
      }
    },
    'bgm2.fadeIn': function bgm2FadeIn(_ref5, eventSheetManager, eventsheet) {
      var _ref5$duration = _ref5.duration,
        duration = _ref5$duration === void 0 ? 500 : _ref5$duration;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.fadeInBackgroundMusic2(duration);
    },
    'bgm2.pause': function bgm2Pause(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.pauseBackgroundMusic2();
    },
    'bgm2.resume': function bgm2Resume(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.resumeBackgroundMusic2();
    },
    'bgm2.mute': function bgm2Mute(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.setBackgroundMusic2Mute(true);
    },
    'bgm2.unmute': function bgm2Unmute(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.setBackgroundMusic2Mute(false);
    }
  };

  var SoundEffectsMethods = {
    se: function se() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        volume = _ref.volume,
        mute = _ref.mute,
        unmute = _ref.unmute;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (volume !== undefined) {
        soundManager.setSoundEffectVolume(volume);
      }
      if (mute !== undefined) {
        soundManager.setSoundEffectMute(mute);
      } else if (unmute !== undefined) {
        soundManager.setSoundEffectMute(!unmute);
      }
    },
    'se.play': function sePlay() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        key = _ref2.key,
        volume = _ref2.volume,
        detune = _ref2.detune,
        rate = _ref2.rate,
        _ref2$fadeIn = _ref2.fadeIn,
        fadeIn = _ref2$fadeIn === void 0 ? 0 : _ref2$fadeIn,
        _ref2$wait = _ref2.wait,
        wait = _ref2$wait === void 0 ? false : _ref2$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (!key) {
        return;
      }
      soundManager.playSoundEffect(key);
      if (volume !== undefined) {
        soundManager.setSoundEffectVolume(volume, true);
      }
      if (detune !== undefined) {
        soundManager.setSoundEffectDetune(detune, true);
      }
      if (rate !== undefined) {
        soundManager.setSoundEffectRate(rate, true);
      }
      if (fadeIn > 0) {
        soundManager.fadeInSoundEffect(fadeIn);
      }
      if (wait) {
        return this.wait({
          se: true
        }, eventSheetManager);
      }
    },
    'se.stop': function seStop(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.stopAllSoundEffects();
    },
    'se.fadeOut': function seFadeOut(_ref3, eventSheetManager, eventsheet) {
      var _ref3$duration = _ref3.duration,
        duration = _ref3$duration === void 0 ? 500 : _ref3$duration,
        _ref3$stop = _ref3.stop,
        stop = _ref3$stop === void 0 ? true : _ref3$stop,
        _ref3$wait = _ref3.wait,
        wait = _ref3$wait === void 0 ? false : _ref3$wait;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.fadeOutSoundEffect(duration, stop);
      if (wait) {
        return this.wait({
          bgm: true
        }, eventSheetManager);
      }
    },
    'se.mute': function seMute(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.setSoundEffectMute(true);
    },
    'se.unmute': function seUnmute(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.setSoundEffectMute(false);
    }
  };

  var SoundEffects2Methods = {
    se2: function se2() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        volume = _ref.volume,
        mute = _ref.mute,
        unmute = _ref.unmute;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (volume !== undefined) {
        soundManager.setSoundEffect2Volume(volume);
      }
      if (mute !== undefined) {
        soundManager.setSoundEffect2Mute(mute);
      } else if (unmute !== undefined) {
        soundManager.setSoundEffect2Mute(!unmute);
      }
    },
    'se2.play': function se2Play() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        key = _ref2.key,
        volume = _ref2.volume,
        detune = _ref2.detune,
        rate = _ref2.rate,
        _ref2$fadeIn = _ref2.fadeIn,
        fadeIn = _ref2$fadeIn === void 0 ? 0 : _ref2$fadeIn,
        _ref2$wait = _ref2.wait,
        wait = _ref2$wait === void 0 ? false : _ref2$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      if (!key) {
        return;
      }
      soundManager.playSoundEffect2(key);
      if (volume !== undefined) {
        soundManager.setSoundEffect2Volume(volume, true);
      }
      if (detune !== undefined) {
        soundManager.setSoundEffect2Detune(detune, true);
      }
      if (rate !== undefined) {
        soundManager.setSoundEffect2Rate(rate, true);
      }
      if (fadeIn > 0) {
        soundManager.fadeInSoundEffect2(fadeIn);
      }
      if (wait) {
        return this.wait({
          se: true
        }, eventSheetManager);
      }
    },
    'se2.stop': function se2Stop(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.stopAllSoundEffects2();
    },
    'se2.fadeOut': function se2FadeOut(_ref3, eventSheetManager, eventsheet) {
      var _ref3$duration = _ref3.duration,
        duration = _ref3$duration === void 0 ? 500 : _ref3$duration,
        _ref3$stop = _ref3.stop,
        stop = _ref3$stop === void 0 ? true : _ref3$stop,
        _ref3$wait = _ref3.wait,
        wait = _ref3$wait === void 0 ? false : _ref3$wait;
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.fadeOutSoundEffect2(duration, stop);
      if (wait) {
        return this.wait({
          bgm: true
        }, eventSheetManager);
      }
    },
    'se2.mute': function se2Mute(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.setSoundEffect2Mute(true);
    },
    'se2.unmute': function se2Unmute(config, eventSheetManager, eventsheet) {
      var soundManager = this.sys.soundManager;
      if (!soundManager) {
        return;
      }
      soundManager.setSoundEffect2Mute(false);
    }
  };

  var CameraMethods = {
    camera: function camera() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        x = _ref.x,
        y = _ref.y,
        rotate = _ref.rotate,
        zoom = _ref.zoom;
      var camera = this.sys.cameraTarget;
      if (!camera) {
        return;
      }
      if (x !== undefined || y !== undefined) {
        camera.setScroll(x, y);
      }
      if (rotate !== undefined) {
        camera.setRotation(rotate);
      }
      if (zoom !== undefined) {
        camera.setZoom(zoom);
      }
    },
    'camera.fadeIn': function cameraFadeIn() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === void 0 ? 1000 : _ref2$duration,
        red = _ref2.red,
        green = _ref2.green,
        blue = _ref2.blue,
        _ref2$wait = _ref2.wait,
        wait = _ref2$wait === void 0 ? false : _ref2$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var camera = this.sys.cameraTarget;
      if (!camera) {
        return;
      }
      camera.fadeIn(duration, red, green, blue);
      if (wait) {
        return this.wait({
          camera: 'fadeIn'
        }, eventSheetManager);
      }
    },
    'camera.fadeOut': function cameraFadeOut() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === void 0 ? 1000 : _ref3$duration,
        red = _ref3.red,
        green = _ref3.green,
        blue = _ref3.blue,
        _ref3$wait = _ref3.wait,
        wait = _ref3$wait === void 0 ? false : _ref3$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var camera = this.sys.cameraTarget;
      if (!camera) {
        return;
      }
      camera.fadeOut(duration, red, green, blue);
      if (wait) {
        return this.wait({
          camera: 'fadeOut'
        }, eventSheetManager);
      }
    },
    'camera.flash': function cameraFlash() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === void 0 ? 1000 : _ref4$duration,
        red = _ref4.red,
        green = _ref4.green,
        blue = _ref4.blue,
        _ref4$wait = _ref4.wait,
        wait = _ref4$wait === void 0 ? false : _ref4$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var camera = this.sys.cameraTarget;
      if (!camera) {
        return;
      }
      camera.flash(duration, red, green, blue);
      if (wait) {
        return this.wait({
          camera: 'flash'
        }, eventSheetManager);
      }
    },
    'camera.shake': function cameraShake() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref5$duration = _ref5.duration,
        duration = _ref5$duration === void 0 ? 1000 : _ref5$duration,
        intensity = _ref5.intensity,
        _ref5$wait = _ref5.wait,
        wait = _ref5$wait === void 0 ? false : _ref5$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var camera = this.sys.cameraTarget;
      if (!camera) {
        return;
      }
      camera.shake(duration, intensity);
      if (wait) {
        return this.wait({
          camera: 'shake'
        }, eventSheetManager);
      }
    },
    'camera.zoomTo': function cameraZoomTo() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$duration = _ref6.duration,
        duration = _ref6$duration === void 0 ? 1000 : _ref6$duration,
        zoom = _ref6.zoom,
        _ref6$wait = _ref6.wait,
        wait = _ref6$wait === void 0 ? false : _ref6$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var camera = this.sys.cameraTarget;
      if (!camera) {
        return;
      }
      camera.zoomTo(zoom, duration);
      if (wait) {
        return this.wait({
          camera: 'zoom'
        }, eventSheetManager);
      }
    },
    'camera.rotateTo': function cameraRotateTo() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref7$duration = _ref7.duration,
        duration = _ref7$duration === void 0 ? 1000 : _ref7$duration,
        rotate = _ref7.rotate,
        ease = _ref7.ease,
        _ref7$wait = _ref7.wait,
        wait = _ref7$wait === void 0 ? false : _ref7$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var camera = this.sys.cameraTarget;
      if (!camera) {
        return;
      }
      camera.rotateTo(rotate, false, duration, ease);
      if (wait) {
        return this.wait({
          camera: 'rotate'
        }, eventSheetManager);
      }
    },
    'camera.scrollTo': function cameraScrollTo() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref8$duration = _ref8.duration,
        duration = _ref8$duration === void 0 ? 1000 : _ref8$duration,
        x = _ref8.x,
        y = _ref8.y,
        ease = _ref8.ease,
        _ref8$wait = _ref8.wait,
        wait = _ref8$wait === void 0 ? false : _ref8$wait;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var camera = this.sys.cameraTarget;
      if (!camera) {
        return;
      }
      var xSave = camera.scrollX;
      var ySave = camera.scrollY;
      camera.setScroll(x, y);
      x += camera.centerX;
      y += camera.centerY;
      camera.setScroll(xSave, ySave);

      // x,y in pan() is the centerX, centerY
      camera.pan(x, y, duration, ease);
      if (wait) {
        return this.wait({
          camera: 'scroll'
        }, eventSheetManager);
      }
    }
  };

  var CanLog = function CanLog(eventsheet) {
    return !eventsheet.hasOwnProperty('logEnable') || eventsheet.logEnable;
  };
  var LogMethods = {
    log: function log() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$text = _ref.text,
        text = _ref$text === void 0 ? '' : _ref$text,
        _ref$logType = _ref.logType,
        logType = _ref$logType === void 0 ? 'log' : _ref$logType,
        _ref$showTitle = _ref.showTitle,
        showTitle = _ref$showTitle === void 0 ? true : _ref$showTitle,
        _ref$title = _ref.title,
        title = _ref$title === void 0 ? undefined : _ref$title,
        _ref$titleColor = _ref.titleColor,
        titleColor = _ref$titleColor === void 0 ? 'green' : _ref$titleColor;
      var eventsheet = arguments.length > 2 ? arguments[2] : undefined;
      if (!CanLog(eventsheet)) {
        return;
      }
      if (showTitle) {
        if (title === undefined) {
          title = eventsheet.title;
        }
        text = "[round][bgcolor=".concat(titleColor, "]").concat(title, "[/bgcolor][/round] ").concat(text);
      }
      this.sys.logger.log(text, logType);
    },
    'log.disable': function logDisable() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        title = _ref2.title;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var eventsheet = arguments.length > 2 ? arguments[2] : undefined;
      if (title) {
        eventsheet = eventSheetManager.getTree(title, eventsheet.groupName);
      }
      if (!eventsheet.hasOwnProperty('logEnable')) {
        eventsheet.wrapProperty('logEnable');
      }
      eventsheet.logEnable = false;
    },
    'log.enable': function logEnable() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        title = _ref3.title;
      var eventSheetManager = arguments.length > 1 ? arguments[1] : undefined;
      var eventsheet = arguments.length > 2 ? arguments[2] : undefined;
      if (title) {
        eventsheet = eventSheetManager.getTree(title, eventsheet.groupName);
      }
      if (!eventsheet.hasOwnProperty('logEnable')) {
        return;
      }
      eventsheet.logEnable = true;
    },
    'log.memory': function logMemory(config, eventSheetManager, eventsheet) {
      if (!CanLog(eventsheet)) {
        return;
      }
      this.log(config, eventSheetManager, eventsheet);
      var memory = eventSheetManager.memory;
      var table;
      var keys = config.keys;
      if (keys) {
        table = {};
        keys.split(',').forEach(function (key) {
          table[key] = memory[key];
        });
      } else {
        table = memory;
      }
      this.sys.logger.log(table, 'table');
    }
  };

  var DefaultHandler = function DefaultHandler(name, config, eventSheetManager, eventsheet) {
    var tokens = name.split('.');
    var gameObjectID = tokens[0];
    config.id = gameObjectID;
    switch (tokens.length) {
      case 1:
        if (!this.sys.hasGameObject(undefined, gameObjectID)) {
          // TODO
          console.warn("CommandExecutor: '".concat(gameObjectID, "' does not exist"));
          return;
        }
        return this._setGOProperty(config, eventSheetManager, eventsheet);
      case 2:
        if (!this.sys.hasGameObject(undefined, gameObjectID)) {
          // TODO
          console.warn("CommandExecutor: '".concat(gameObjectID, "' does not exist"));
          return;
        }
        var commandName = tokens[1];
        switch (tokens[1]) {
          case 'to':
            return this._easeGOProperty(config, eventSheetManager, eventsheet);
          case 'yoyo':
            config.yoyo = true;
            return this._easeGOProperty(config, eventSheetManager, eventsheet);
          case 'destroy':
            return this._destroyGO(config, eventSheetManager, eventsheet);
          default:
            var gameObjectManager = this.sys.getGameObjectManager(undefined, gameObjectID);
            if (gameObjectManager) {
              var command = gameObjectManager.commands[commandName];
              if (command) {
                var gameObject = gameObjectManager.getGO(gameObjectID);
                this.clearWaitEventFlag();
                command(gameObject, config, this, eventSheetManager, eventsheet);
                return this.hasAnyWaitEvent ? this.sys : undefined;
              }
            }
            var parameters;
            for (var key in config) {
              parameters = config[key];
              break;
            }
            config.methodName = commandName;
            config.parameters = parameters ? StringToValues(parameters) : [];
            return this._runGOMethod(config, eventSheetManager, eventsheet);
        }
    }
  };

  var Methods$j = {
    addCommand: AddCommand,
    defaultHandler: DefaultHandler
  };
  Object.assign(Methods$j, EventSheetManagerMethods, WaitMethods, GameObjectMethods, BackgroundMusicMethods, BackgroundMusic2Methods, SoundEffectsMethods, SoundEffects2Methods, CameraMethods, LogMethods);

  var CommandExecutor = /*#__PURE__*/function () {
    function CommandExecutor(scene) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, CommandExecutor);
      this.sys = new Managers(scene, config);
      var _config$log = config.log,
        log = _config$log === void 0 ? {} : _config$log;
      this.sys.logger = new BBCodeLog(log);
    }
    _createClass(CommandExecutor, [{
      key: "destroy",
      value: function destroy(fromScene) {
        this.sys.destroy(fromScene);
      }
    }]);
    return CommandExecutor;
  }();
  Object.assign(CommandExecutor.prototype, Methods$j);

  // Layer name
  var BGLayer = 'bgLayer';
  var GOLayer = 'gameObjectLayer';
  var UILayer = 'uiLayer';
  var BGBottomLayer = "".concat(BGLayer, "Bottom");
  var BGTopLayer = "".concat(BGLayer, "Top");
  var GOBottomLayer = "".concat(GOLayer, "Bottom");
  var GOTopLayer = "".concat(GOLayer, "Top");
  var UIBottomLayer = "".concat(UILayer, "Bottom");
  var UITopLayer = "".concat(UILayer, "Top");
  var LayerNames = [BGBottomLayer, BGLayer, BGTopLayer, GOBottomLayer, GOLayer, GOTopLayer, UIBottomLayer, UILayer, UITopLayer];

  // Game object type name
  var BG = 'BG'; // layer: BGLayer
  var TEXT = 'TEXT'; // layer: UILayer
  var SPRITE = 'SPRITE'; // layer: GOLayer
  var CHOICE = 'CHOICE'; // layer: UILayer

  var SetGetFrameNameCallback = function SetGetFrameNameCallback(callback) {
    if (callback === undefined) {
      callback = DefaultGetFrameNameCallback;
    }
    this.getFrameNameCallback = callback;
    return this;
  };
  var DefaultGetFrameNameCallback = function DefaultGetFrameNameCallback(colIndex, rowIndex, baseFrameName) {
    if (baseFrameName === '__BASE') {
      return "".concat(colIndex, ",").concat(rowIndex);
    } else {
      return "".concat(baseFrameName, ":").concat(colIndex, ",").concat(rowIndex);
    }
  };

  var SetBaseTexture = function SetBaseTexture(key, baseFrameName, columns, rows) {
    if (Array.isArray(baseFrameName)) {
      rows = columns;
      columns = baseFrameName;
      baseFrameName = undefined;
    }
    if (baseFrameName == null) {
      baseFrameName = '__BASE';
    }
    if (typeof columns === 'number' && arguments.length >= 6) {
      columns = [arguments[2], undefined, arguments[3]];
      rows = [arguments[4], undefined, arguments[5]];
    } else if (columns === undefined && rows === undefined && this.columns.data !== undefined && this.rows.data !== undefined) {
      columns = this.columns.data;
      rows = this.rows.data;
    } else {
      columns = DeepClone(columns);
      rows = DeepClone(rows);
    }
    this.textureKey = key;
    this.baseFrameName = baseFrameName;
    this.columns.data = columns;
    this.columns.count = columns ? columns.length : 0;
    this.columns.stretch = 0;
    this.columns.minWidth = 0;
    this.columns.scale = 1;
    this.rows.data = rows;
    this.rows.count = rows ? rows.length : 0;
    this.rows.stretch = 0;
    this.rows.minHeight = 0;
    this.rows.scale = 1;
    var texture = this.scene.sys.textures.get(key);
    if (!texture) {
      this.clear();
      return this;
    }
    if (!columns || !rows) {
      this.clear();
      return this;
    }

    // Get remainder width/height for unknown width/height
    var baseFrame = texture.get(baseFrameName);
    var remainderTextureWidth = baseFrame.width;
    var unknownColumnWidthCount = 0;
    for (var i = 0, cnt = columns.length; i < cnt; i++) {
      if (columns[i] === undefined) {
        unknownColumnWidthCount++;
      } else if (typeof columns[i] === 'number') {
        remainderTextureWidth -= columns[i];
      } else {
        remainderTextureWidth -= columns[i].width;
      }
    }
    var unknownColumnWidth = unknownColumnWidthCount > 0 ? remainderTextureWidth / unknownColumnWidthCount : 0;
    var remainderTextureHeight = baseFrame.height;
    var unknownRowHeightCount = 0;
    for (var i = 0, cnt = rows.length; i < cnt; i++) {
      if (rows[i] === undefined) {
        unknownRowHeightCount++;
      } else if (typeof rows[i] === 'number') {
        remainderTextureHeight -= rows[i];
      } else {
        remainderTextureHeight -= rows[i].width;
      }
    }
    var unknownRowHeight = unknownRowHeightCount ? remainderTextureHeight / unknownRowHeightCount : 0;
    var row, col, rowHeight, colWidth, frameName;
    var offsetX = 0,
      offsetY = 0;
    for (var j = 0, jcnt = rows.length; j < jcnt; j++) {
      // Unknown height
      if (rows[j] === undefined) {
        rows[j] = unknownRowHeight;
      }
      if (typeof rows[j] === 'number') {
        rows[j] = {
          height: rows[j],
          stretch: j % 2
        };
      }
      row = rows[j];
      rowHeight = row.height;
      this.rows.stretch += row.stretch | 0;
      this.rows.minHeight += row.stretch > 0 ? 0 : rowHeight;
      offsetX = 0;
      for (var i = 0, icnt = columns.length; i < icnt; i++) {
        // Unknown width
        if (columns[i] === undefined) {
          columns[i] = unknownColumnWidth;
        }
        if (typeof columns[i] === 'number') {
          columns[i] = {
            width: columns[i],
            stretch: i % 2
          };
        }
        col = columns[i];
        colWidth = col.width;
        if (j === 0) {
          this.columns.stretch += col.stretch | 0;
          this.columns.minWidth += col.stretch > 0 ? 0 : colWidth;
        }
        if (colWidth >= 1 && rowHeight >= 1) {
          frameName = this.getFrameNameCallback(i, j, baseFrameName);
          var frameNameType = _typeof(frameName);
          if (frameNameType === 'string' || frameNameType === 'number') {
            texture.add(frameName, 0, offsetX + baseFrame.cutX, offsetY + baseFrame.cutY, colWidth, rowHeight);
            // Do nothing if frameName is existed
          }
        }
        offsetX += colWidth;
      }
      offsetY += rowHeight;
    }
    this.updateTexture();
    return this;
  };

  var UpdateTexture = function UpdateTexture() {
    this.clear();
    if (this.textureKey === undefined) {
      return this;
    }
    var texture = this.scene.sys.textures.get(this.textureKey);
    if (!texture) {
      return this;
    }
    var minWidth = this.columns.minWidth * this.maxFixedPartScaleX; // Fixed-part width
    var minHeight = this.rows.minHeight * this.maxFixedPartScaleY; // Fixed-part height
    var stretchWidth = this.width - minWidth;
    var stretchHeight = this.height - minHeight;
    var fixedPartScaleX = stretchWidth >= 0 ? this.maxFixedPartScaleX : this.width / minWidth;
    var fixedPartScaleY = stretchHeight >= 0 ? this.maxFixedPartScaleY : this.height / minHeight;
    if (this.preserveRatio) {
      var minScale = Math.min(fixedPartScaleX, fixedPartScaleY);
      if (fixedPartScaleX > minScale) {
        var compensationWidth = (fixedPartScaleX - minScale) * minWidth;
        if (stretchWidth >= 0) {
          stretchWidth += compensationWidth;
        } else {
          stretchWidth = compensationWidth;
        }
        fixedPartScaleX = minScale;
      }
      if (fixedPartScaleY > minScale) {
        var compensationHeight = (fixedPartScaleY - minScale) * minHeight;
        if (stretchHeight >= 0) {
          stretchHeight += compensationHeight;
        } else {
          stretchHeight = compensationHeight;
        }
        fixedPartScaleY = minScale;
      }
    }
    this.columns.scale = fixedPartScaleX;
    this.rows.scale = fixedPartScaleY;
    var proportionWidth;
    if (stretchWidth > 0) {
      proportionWidth = this.columns.stretch > 0 ? stretchWidth / this.columns.stretch : 0;
    } else {
      proportionWidth = 0;
    }
    var proportionHeight;
    if (stretchHeight > 0) {
      proportionHeight = this.rows.stretch > 0 ? stretchHeight / this.rows.stretch : 0;
    } else {
      proportionHeight = 0;
    }
    var frameName, col, row, colWidth, rowHeight;
    var offsetX = 0,
      offsetY = 0;
    var imageType;
    this._beginDraw();
    for (var j = 0, jcnt = this.rows.count; j < jcnt; j++) {
      row = this.rows.data[j];
      rowHeight = row.stretch === 0 ? row.height * fixedPartScaleY : proportionHeight * row.stretch;
      offsetX = 0;
      for (var i = 0, icnt = this.columns.count; i < icnt; i++) {
        col = this.columns.data[i];
        colWidth = col.stretch === 0 ? col.width * fixedPartScaleX : proportionWidth * col.stretch;
        frameName = this.getFrameNameCallback(i, j, this.baseFrameName);
        if (texture.has(frameName) && colWidth > 0 && rowHeight > 0) {
          if (row.stretch === 0 && col.stretch === 0) {
            // Fixed parts
            imageType = 0; // Draw image
          } else {
            // Stretchable parts
            if (this.getStretchMode(i, j) === 0) {
              // Scaled image
              imageType = 0; // Draw scaled image
            } else {
              // Repeat tile-sprite
              imageType = 1; // Draw tile-sprite
            }
          }
          if (imageType === 0) {
            this._drawImage(this.textureKey, frameName, offsetX, offsetY, colWidth, rowHeight);
          } else {
            this._drawTileSprite(this.textureKey, frameName, offsetX, offsetY, colWidth, rowHeight);
          }
        }
        offsetX += colWidth;
      }
      offsetY += rowHeight;
    }
    this._endDraw();
  };

  var IsPlainObject$P = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$36 = Phaser.Utils.Objects.GetValue;
  var SetStretchMode = function SetStretchMode(mode) {
    if (IsPlainObject$P(mode)) {
      this.stretchMode.edge = parseMode(GetValue$36(mode, 'edge', 0));
      this.stretchMode.internal = parseMode(GetValue$36(mode, 'internal', 0));
    } else {
      mode = parseMode(mode);
      this.stretchMode.edge = mode;
      this.stretchMode.internal = mode;
    }
    return this;
  };
  var parseMode = function parseMode(mode) {
    if (typeof mode === 'string') {
      mode = EXTENDMODE[mode];
    }
    return mode;
  };
  var EXTENDMODE = {
    scale: 0,
    repeat: 1
  };

  var IsEdge = function IsEdge(colIndex, rowIndex) {
    return colIndex === 0 || colIndex === this.columns.count - 1 || rowIndex === 0 || rowIndex === this.rows.count - 1;
  };

  var GetStretchMode = function GetStretchMode(colIndex, rowIndex) {
    return IsEdge.call(this, colIndex, rowIndex) ? this.stretchMode.edge : this.stretchMode.internal;
  };

  var SetPreserveRatio = function SetPreserveRatio(enable) {
    if (enable == undefined) {
      enable = true;
    }
    this.preserveRatio = enable;
    return this;
  };

  var SetMaxFixedPartScale = function SetMaxFixedPartScale(scaleX, scaleY) {
    if (scaleY === undefined) {
      scaleY = scaleX;
    }
    this.maxFixedPartScaleX = scaleX;
    this.maxFixedPartScaleY = scaleY;
    return this;
  };

  var NOOP = function NOOP() {
    //  NOOP
  };

  var Methods$i = {
    _beginDraw: NOOP,
    _drawImage: NOOP,
    _drawTileSprite: NOOP,
    _endDraw: NOOP,
    setGetFrameNameCallback: SetGetFrameNameCallback,
    setBaseTexture: SetBaseTexture,
    updateTexture: UpdateTexture,
    setStretchMode: SetStretchMode,
    getStretchMode: GetStretchMode,
    setPreserveRatio: SetPreserveRatio,
    setMaxFixedPartScale: SetMaxFixedPartScale
  };

  var IsPlainObject$O = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$35 = Phaser.Utils.Objects.GetValue;
  var NinePatchBase = function NinePatchBase(GOClass, type) {
    var NinePatch = /*#__PURE__*/function (_GOClass) {
      _inherits(NinePatch, _GOClass);
      function NinePatch(scene, x, y, width, height, key, baseFrame, columns, rows, config) {
        var _this;
        _classCallCheck(this, NinePatch);
        if (IsPlainObject$O(x)) {
          config = x;
          x = GetValue$35(config, 'x', 0);
          y = GetValue$35(config, 'y', 0);
          width = GetValue$35(config, 'width', 1);
          height = GetValue$35(config, 'height', 1);
          key = GetValue$35(config, 'key', undefined);
          baseFrame = GetValue$35(config, 'baseFrame', undefined);
          columns = GetValue$35(config, 'columns', undefined);
          rows = GetValue$35(config, 'rows', undefined);
        } else if (IsPlainObject$O(width)) {
          config = width;
          width = GetValue$35(config, 'width', 1);
          height = GetValue$35(config, 'height', 1);
          key = GetValue$35(config, 'key', undefined);
          baseFrame = GetValue$35(config, 'baseFrame', undefined);
          columns = GetValue$35(config, 'columns', undefined);
          rows = GetValue$35(config, 'rows', undefined);
        } else if (IsPlainObject$O(key)) {
          config = key;
          key = GetValue$35(config, 'key', undefined);
          baseFrame = GetValue$35(config, 'baseFrame', undefined);
          columns = GetValue$35(config, 'columns', undefined);
          rows = GetValue$35(config, 'rows', undefined);
        } else if (IsPlainObject$O(baseFrame)) {
          config = baseFrame;
          baseFrame = GetValue$35(config, 'baseFrame', undefined);
          columns = GetValue$35(config, 'columns', undefined);
          rows = GetValue$35(config, 'rows', undefined);
        } else if (Array.isArray(baseFrame)) {
          config = rows;
          rows = columns;
          columns = baseFrame;
          baseFrame = GetValue$35(config, 'baseFrame', undefined);
        } else if (IsPlainObject$O(columns)) {
          config = columns;
          columns = GetValue$35(config, 'columns', undefined);
          rows = GetValue$35(config, 'rows', undefined);
        }
        if (baseFrame === undefined) {
          baseFrame = GetValue$35(config, 'frame', undefined);
        }
        if (columns === undefined) {
          var leftWidth = GetValue$35(config, 'leftWidth', undefined);
          var rightWidth = GetValue$35(config, 'rightWidth', undefined);
          if (leftWidth !== undefined && rightWidth !== undefined) {
            columns = [leftWidth, undefined, rightWidth];
          }
        }
        if (rows === undefined) {
          var topHeight = GetValue$35(config, 'topHeight', undefined);
          var bottomHeight = GetValue$35(config, 'bottomHeight', undefined);
          if (topHeight !== undefined && bottomHeight !== undefined) {
            rows = [topHeight, undefined, bottomHeight];
          }
        }
        _this = _callSuper(this, NinePatch, [scene]);
        _this.type = type;
        _this.setPosition(x, y).setSize(width, height).setOrigin(0.5, 0.5);
        _this.columns = {};
        _this.rows = {};
        _this.stretchMode = {};
        _this._tileSprite = undefined; // Reserved for drawing image
        _this._image = undefined; // Reserved for drawing image

        _this.setGetFrameNameCallback(GetValue$35(config, 'getFrameNameCallback', undefined));
        _this.setStretchMode(GetValue$35(config, 'stretchMode', 0));
        _this.setPreserveRatio(GetValue$35(config, 'preserveRatio', true));
        var maxFixedPartScale = GetValue$35(config, 'maxFixedPartScale', 1);
        var maxFixedPartScaleX = GetValue$35(config, 'maxFixedPartScaleX', maxFixedPartScale);
        var maxFixedPartScaleY = GetValue$35(config, 'maxFixedPartScaleY', undefined);
        _this.setMaxFixedPartScale(maxFixedPartScaleX, maxFixedPartScaleY);
        _this.setBaseTexture(key, baseFrame, columns, rows);
        return _this;
      }
      _createClass(NinePatch, [{
        key: "minWidth",
        get: function get() {
          return this.columns.minWidth;
        }
      }, {
        key: "minHeight",
        get: function get() {
          return this.rows.minHeight;
        }
      }, {
        key: "fixedPartScaleX",
        get: function get() {
          return this.columns.scale;
        }
      }, {
        key: "fixedPartScaleY",
        get: function get() {
          return this.rows.scale;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          if (this.width === width && this.height === height) {
            return this;
          }
          if (_get(_getPrototypeOf(NinePatch.prototype), "resize", this)) {
            _get(_getPrototypeOf(NinePatch.prototype), "resize", this).call(this, width, height);
          } else {
            // Use setSize method for alternative 
            _get(_getPrototypeOf(NinePatch.prototype), "setSize", this).call(this, width, height);
          }
          this.updateTexture();
          return this;
        }
      }, {
        key: "leftWidth",
        get: function get() {
          return this.columns.data[0];
        }
      }, {
        key: "rightWidth",
        get: function get() {
          return this.columns.data[this.columns.count - 1];
        }
      }, {
        key: "topHeight",
        get: function get() {
          return this.rows.data[0];
        }
      }, {
        key: "bottomHeight",
        get: function get() {
          return this.rows.data[this.rows.count - 1];
        }
      }]);
      return NinePatch;
    }(GOClass);
    Object.assign(NinePatch.prototype, Methods$i);
    return NinePatch;
  };

  var GameObjectClasses = Phaser.GameObjects;
  var GameObjects = undefined;
  var GetStampGameObject = function GetStampGameObject(gameObject, className) {
    if (!GameObjects) {
      GameObjects = {};
      GetGame(gameObject).events.once('destroy', function () {
        for (var name in GameObjects) {
          GameObjects[name].destroy();
        }
        GameObjects = undefined;
      });
    }
    if (!GameObjects.hasOwnProperty(className)) {
      var scene = GetGame(gameObject).scene.systemScene;
      var gameObject = new GameObjectClasses[className](scene);
      gameObject.setOrigin(0);
      GameObjects[className] = gameObject;
    }
    return GameObjects[className];
  };

  var DrawImage$2 = function DrawImage(key, frame, x, y, width, height) {
    var gameObject = GetStampGameObject(this, 'Image').setTexture(key, frame).setDisplaySize(width, height);
    this.draw(gameObject, x, y);
  };

  var DrawTileSprite$1 = function DrawTileSprite(key, frame, x, y, width, height) {
    var gameObject = GetStampGameObject(this, 'TileSprite').setTexture(key, frame).setSize(width, height);
    this.draw(gameObject, x, y);
  };

  var RenderTexture$2 = Phaser.GameObjects.RenderTexture;
  var NinePatch$1 = /*#__PURE__*/function (_NinePatchBase) {
    _inherits(NinePatch, _NinePatchBase);
    function NinePatch() {
      _classCallCheck(this, NinePatch);
      return _callSuper(this, NinePatch, arguments);
    }
    return _createClass(NinePatch);
  }(NinePatchBase(RenderTexture$2, 'rexNinePatch'));
  var Methods$h = {
    _drawImage: DrawImage$2,
    _drawTileSprite: DrawTileSprite$1
  };
  Object.assign(NinePatch$1.prototype, Methods$h);

  var GetCalcMatrix$2 = Phaser.GameObjects.GetCalcMatrix;
  var WebGLRenderer$3 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
    var bobs = src.getRenderList();
    if (bobs.length === 0) {
      return;
    }
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var texture = src.frame.glTexture;
    var textureUnit = pipeline.setGameObject(src);
    var roundPixels = camera.roundPixels;
    var result = GetCalcMatrix$2(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    for (var i = 0, cnt = bobs.length; i < cnt; i++) {
      bobs[i].webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels);
    }
    renderer.pipelines.postBatch(src);
  };

  var SetTransform$2 = Phaser.Renderer.Canvas.SetTransform;
  var CanvasRenderer$3 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
    var ctx = renderer.currentContext;
    var bobs = src.getRenderList();
    if (bobs.length === 0 || !SetTransform$2(renderer, ctx, src, camera, parentMatrix)) {
      return;
    }
    camera.addToRenderList(src);
    var roundPixels = camera.roundPixels;
    var dx = -src._displayOriginX,
      dy = -src._displayOriginY;
    ctx.translate(dx, dy);
    for (var i = 0, cnt = bobs.length; i < cnt; i++) {
      bobs[i].canvasRender(ctx, dx, dy, roundPixels);
    }

    //  Restore the context saved in SetTransform
    ctx.restore();
  };

  var Render$4 = {
    renderWebGL: WebGLRenderer$3,
    renderCanvas: CanvasRenderer$3
  };

  var SetTexture = function SetTexture(key, frame) {
    this.texture = this.scene.sys.textures.get(key);
    this.frame = this.texture.get(frame);
    return this;
  };

  var Resize$1 = function Resize(width, height) {
    if (this.width === width && this.height === height) {
      return this;
    }
    this.width = width;
    this.height = height;
    this.updateDisplayOrigin();
    var input = this.input;
    if (input && !input.customHitArea) {
      input.hitArea.width = width;
      input.hitArea.height = height;
    }
    return this;
  };

  var AddChild$4 = function AddChild(bob) {
    this.lastAppendedChildren.length = 0;
    if (Array.isArray(bob)) {
      var _this$lastAppendedChi;
      this.children.add(bob);
      (_this$lastAppendedChi = this.lastAppendedChildren).push.apply(_this$lastAppendedChi, _toConsumableArray(bob));
    } else {
      this.children.add(bob);
      this.lastAppendedChildren.push(bob);
    }
    return this;
  };

  var RemoveItem$a = Phaser.Utils.Array.Remove;
  var RemoveChild$3 = function RemoveChild(bob) {
    if (this.poolManager) {
      // Free this bob (bob.onFree())
      this.poolManager.free(bob);
    }

    // Remove this bob from blitter
    RemoveItem$a(this.children.list, bob);
    this.lastAppendedChildren.length = 0;
    this.dirty = true;
    return this;
  };

  var RemoveChildren$1 = function RemoveChildren() {
    if (this.poolManager) {
      // Free all bobs (bob.onFree())
      this.poolManager.freeMultiple(this.children.list);
    }

    // Remove all bobs from blitter
    this.children.list.length = 0;
    this.lastAppendedChildren.length = 0;
    this.dirty = true;
    return this;
  };

  var GetLastAppendedChildren$1 = function GetLastAppendedChildren() {
    return this.lastAppendedChildren;
  };

  var GetChildren$1 = function GetChildren() {
    return this.children.list;
  };

  var TintMethods = {
    setTint: function setTint(tint) {
      // 0: Solid tint + texture alpha
      this.tint = tint;
      this.tintFill = false;
      return this;
    },
    setTintFill: function setTintFill(tint) {
      // 1: Solid tint, no texture
      this.tint = tint;
      this.tintFill = true;
      return this;
    },
    clearTint: function clearTint() {
      this.setTint(0xffffff);
      return this;
    }
  };

  var methods$C = {
    setTexture: SetTexture,
    resize: Resize$1,
    setSize: Resize$1,
    addChild: AddChild$4,
    removeChild: RemoveChild$3,
    removeChildren: RemoveChildren$1,
    clear: RemoveChildren$1,
    getLastAppendedChildren: GetLastAppendedChildren$1,
    getChildren: GetChildren$1
  };
  Object.assign(methods$C, TintMethods);

  var GetValue$34 = Phaser.Utils.Objects.GetValue;
  var Pools$1 = {};
  var PoolManager$1 = /*#__PURE__*/function () {
    function PoolManager(config) {
      _classCallCheck(this, PoolManager);
      this.pools = GetValue$34(config, 'pools', Pools$1);
    }
    _createClass(PoolManager, [{
      key: "destroy",
      value: function destroy() {
        this.pools = undefined;
      }
    }, {
      key: "free",
      value: function free(bob) {
        if (!this.pools) {
          return this;
        }
        var bobType = bob.type;
        if (!this.pools.hasOwnProperty(bobType)) {
          this.pools[bobType] = new Stack();
        }
        this.pools[bobType].push(bob);
        bob.onFree();
        return this;
      }
    }, {
      key: "freeMultiple",
      value: function freeMultiple(bobs) {
        if (!this.pools) {
          return this;
        }
        for (var i = 0, cnt = bobs.length; i < cnt; i++) {
          this.free(bobs[i]);
        }
        return this;
      }
    }, {
      key: "allocate",
      value: function allocate(bobType) {
        if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
          return null;
        }
        return this.pools[bobType].pop();
      }
    }]);
    return PoolManager;
  }();

  var MinVersion = 60;
  var IsChecked = false;
  var CheckP3Version = function CheckP3Version(minVersion) {
    if (IsChecked) {
      return;
    }
    if (minVersion === undefined) {
      minVersion = MinVersion;
    }
    var currentVersion = parseInt(Phaser.VERSION.match(/\.(\d+)\./)[1]);
    if (currentVersion < minVersion) {
      console.error("Minimum supported version : 3.".concat(minVersion));
    }
    IsChecked = true;
  };

  CheckP3Version();
  var GameObject$4 = Phaser.GameObjects.GameObject;
  var IsPlainObject$N = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$33 = Phaser.Utils.Objects.GetValue;
  var List = Phaser.Structs.List;
  var StableSort = Phaser.Utils.Array.StableSort;
  var Blitter = /*#__PURE__*/function (_GameObject) {
    _inherits(Blitter, _GameObject);
    function Blitter(scene, x, y, texture, frame, config) {
      var _this;
      _classCallCheck(this, Blitter);
      if (IsPlainObject$N(x)) {
        config = x;
        x = GetValue$33(config, 'x', 0);
        y = GetValue$33(config, 'y', 0);
        texture = GetValue$33(config, 'texture');
        frame = GetValue$33(config, 'frame');
      }
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      _this = _callSuper(this, Blitter, [scene, 'rexBlitter']);
      _this.children = new List();
      _this.renderList = [];
      _this.displayListDirty = false;
      _this.lastAppendedChildren = [];
      var reuseBob = GetValue$33(config, 'reuseBob', true);
      _this.poolManager = reuseBob ? new PoolManager$1(config) : undefined;
      _this.setTexture(texture, frame);
      _this.setPosition(x, y);
      _this.setOrigin(0, 0);
      _this.clearTint();
      _this.initPipeline();
      _this.initPostPipeline();
      return _this;
    }
    _createClass(Blitter, [{
      key: "preDestroy",
      value: function preDestroy() {
        this.removeChildren();
        this.children.destroy();
        this.renderList.length = 0;
        if (this.poolManager) {
          this.poolManager.destroy();
        }
      }
    }, {
      key: "getRenderList",
      value: function getRenderList() {
        if (this.displayListDirty) {
          this.renderList.length = 0;
          var needDepthSort = false;
          var children = this.children.list;
          for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (ChildCanRender(child)) {
              this.renderList.push(child);
              if (!needDepthSort) {
                needDepthSort = child.depth !== 0;
              }
            }
          }
          if (needDepthSort) {
            StableSort(this.renderList, SortByDepth);
          }
          this.displayListDirty = false;
        }
        return this.renderList;
      }
    }]);
    return Blitter;
  }(GameObject$4);
  var ChildCanRender = function ChildCanRender(child) {
    return child.active && child.visible && child.alpha > 0;
  };
  var SortByDepth = function SortByDepth(childA, childB) {
    return childA._depth - childB._depth;
  };
  var Components$4 = Phaser.GameObjects.Components;
  Phaser.Class.mixin(Blitter, [Components$4.Alpha, Components$4.BlendMode, Components$4.ComputedSize, Components$4.Depth, Components$4.GetBounds, Components$4.Mask, Components$4.Origin, Components$4.Pipeline, Components$4.PostPipeline, Components$4.ScrollFactor, Components$4.Transform, Components$4.Visible, Render$4, methods$C]);

  var ImageTypeName$1 = 'image';

  var DataMethods = {
    enableData: function enableData() {
      if (this.data === undefined) {
        this.data = {};
      }
      return this;
    },
    setData: function setData(key, value) {
      this.enableData();
      if (arguments.length === 1) {
        var data = key;
        for (key in data) {
          this.data[key] = data[key];
        }
      } else {
        this.data[key] = value;
      }
      return this;
    },
    getData: function getData(key, defaultValue) {
      this.enableData();
      return key === undefined ? this.data : GetValue$38(this.data, key, defaultValue);
    },
    incData: function incData(key, inc, defaultValue) {
      if (defaultValue === undefined) {
        defaultValue = 0;
      }
      this.enableData();
      this.setData(key, this.getData(key, defaultValue) + inc);
      return this;
    },
    mulData: function mulData(key, mul, defaultValue) {
      if (defaultValue === undefined) {
        defaultValue = 0;
      }
      this.enableData();
      this.setData(key, this.getData(key, defaultValue) * mul);
      return this;
    },
    clearData: function clearData() {
      if (this.data) {
        Clear$1(this.data);
      }
      return this;
    }
  };

  var Base$3 = /*#__PURE__*/function () {
    function Base(parent, type) {
      _classCallCheck(this, Base);
      this.type = type;
      this.data = undefined;
      this.setParent(parent).reset().setActive();
    }
    _createClass(Base, [{
      key: "destroy",
      value: function destroy() {
        if (this.parent) {
          this.parent.removeChild(this);
          // Remove this bob from blitter, and free it (bob.onFree())
          // Will set this.parent to undefined
        }
      }
    }, {
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent;
        return this;
      }

      // get scene() {
      //     if (this.parent) {
      //         return this.parent.scene;
      //     } else {
      //         return null;
      //     }
      // }
    }, {
      key: "setDisplayListDirty",
      value: function setDisplayListDirty(displayListDirty) {
        if (displayListDirty && this.parent) {
          this.parent.displayListDirty = true;
        }
        return this;
      }
    }, {
      key: "active",
      get: function get() {
        return this._active;
      },
      set: function set(value) {
        this.setDisplayListDirty(this._active != value);
        this._active = value;
      }
    }, {
      key: "setActive",
      value: function setActive(active) {
        if (active === undefined) {
          active = true;
        }
        this.active = active;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        return this;
      }

      // Override
    }, {
      key: "reset",
      value: function reset() {
        this.clearData();
      }

      // Override
    }, {
      key: "onFree",
      value: function onFree() {
        this.reset().setActive(false).setParent();
      }
    }]);
    return Base;
  }();
  Object.assign(Base$3.prototype, DataMethods);

  var DegToRad$f = Phaser.Math.DegToRad;
  var RadToDeg$8 = Phaser.Math.RadToDeg;
  var GetValue$32 = Phaser.Utils.Objects.GetValue;
  var RenderBase$1 = /*#__PURE__*/function (_Base) {
    _inherits(RenderBase, _Base);
    function RenderBase() {
      _classCallCheck(this, RenderBase);
      return _callSuper(this, RenderBase, arguments);
    }
    _createClass(RenderBase, [{
      key: "visible",
      get: function get() {
        return this._visible;
      },
      set: function set(value) {
        this.setDisplayListDirty(this._visible != value);
        this._visible = value;
      }
    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        if (visible === undefined) {
          visible = true;
        }
        this.visible = visible;
        return this;
      }
    }, {
      key: "alpha",
      get: function get() {
        return this._alpha;
      },
      set: function set(value) {
        this.setDisplayListDirty(!!this._alpha !== !!value);
        this._alpha = value;
      }
    }, {
      key: "setAlpha",
      value: function setAlpha(alpha) {
        this.alpha = alpha;
        return this;
      }
    }, {
      key: "setX",
      value: function setX(x) {
        this.x = x;
        return this;
      }
    }, {
      key: "setY",
      value: function setY(y) {
        this.y = y;
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "setRotation",
      value: function setRotation(rotation) {
        this.rotation = rotation;
        return this;
      }
    }, {
      key: "angle",
      get: function get() {
        return RadToDeg$8(this.rotation);
      },
      set: function set(value) {
        this.rotation = DegToRad$f(value);
      }
    }, {
      key: "setAngle",
      value: function setAngle(angle) {
        this.angle = angle;
        return this;
      }
    }, {
      key: "setScaleX",
      value: function setScaleX(scaleX) {
        this.scaleX = scaleX;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this._width = value;
      }
    }, {
      key: "setWidth",
      value: function setWidth(width, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }
        this.width = width;
        if (keepAspectRatio) {
          this.scaleY = this.scaleX;
        }
        return this;
      }
    }, {
      key: "setScaleY",
      value: function setScaleY(scaleY) {
        this.scaleY = scaleY;
        return this;
      }
    }, {
      key: "setScale",
      value: function setScale(scaleX, scaleY) {
        if (scaleY === undefined) {
          scaleY = scaleX;
        }
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        return this;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this._height = value;
      }
    }, {
      key: "setHeight",
      value: function setHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }
        this.height = height;
        if (keepAspectRatio) {
          this.scaleX = this.scaleY;
        }
        return this;
      }
    }, {
      key: "displayWidth",
      get: function get() {
        return this._width * this.scaleX;
      },
      set: function set(value) {
        this.scaleX = value / this._width;
      }
    }, {
      key: "setDisplayWidth",
      value: function setDisplayWidth(width, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }
        this.displayWidth = width;
        if (keepAspectRatio) {
          this.scaleY = this.scaleX;
        }
        return this;
      }
    }, {
      key: "displayHeight",
      get: function get() {
        return this._height * this.scaleY;
      },
      set: function set(value) {
        this.scaleY = value / this._height;
      }
    }, {
      key: "setDisplayHeight",
      value: function setDisplayHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }
        this.displayHeight = height;
        if (keepAspectRatio) {
          this.scaleX = this.scaleY;
        }
        return this;
      }
    }, {
      key: "setOriginX",
      value: function setOriginX(originX) {
        this.originX = originX;
        this._displayOriginX = this.width * originX;
        return this;
      }
    }, {
      key: "setOriginY",
      value: function setOriginY(originY) {
        this.originY = originY;
        this._displayOriginY = this.height * originY;
        return this;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(originX, originY) {
        if (originY === undefined) {
          originY = originX;
        }
        this.setOriginX(originX).setOriginY(originY);
        return this;
      }
    }, {
      key: "depth",
      get: function get() {
        return this._depth;
      },
      set: function set(value) {
        this.setDisplayListDirty(this._depth != value);
        this._depth = value;
      }
    }, {
      key: "setDepth",
      value: function setDepth(depth) {
        if (depth === undefined) {
          depth = 0;
        }
        this.depth = depth;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (!o) {
          return this;
        }
        if (o.hasOwnProperty('x')) {
          this.setX(o.x);
        }
        if (o.hasOwnProperty('y')) {
          this.setY(o.y);
        }
        if (o.hasOwnProperty('rotation')) {
          this.setRotation(o.rotation);
        } else if (o.hasOwnProperty('angle')) {
          this.setAngle(o.angle);
        }
        if (o.hasOwnProperty('alpha')) {
          this.setAlpha(o.alpha);
        }

        // ScaleX, ScaleY
        var width = GetValue$32(o, 'width', undefined);
        var height = GetValue$32(o, 'height', undefined);
        var scale = GetValue$32(o, 'scale', undefined);
        var scaleX = GetValue$32(o, 'scaleX', scale);
        var scaleY = GetValue$32(o, 'scaleY', scale);
        if (width !== undefined) {
          if (height === undefined && scaleY === undefined) {
            this.setWidth(width, true);
          } else {
            this.setWidth(width);
          }
        } else if (scaleX !== undefined) {
          this.setScaleX(scaleX);
        } else if (o.hasOwnProperty('displayWidth')) {
          this.setDisplayWidth(o.displayWidth);
        }
        if (height !== undefined) {
          if (width === undefined && scaleX === undefined) {
            this.setHeight(height, true);
          } else {
            this.setHeight(height);
          }
        } else if (scaleY !== undefined) {
          this.setScaleY(scaleY);
        } else if (o.hasOwnProperty('displayHeight')) {
          this.setDisplayHeight(o.displayHeight);
        }
        var origin = GetValue$32(o, 'origin', undefined);
        if (origin !== undefined) {
          this.setOrigin(origin);
        } else {
          if (o.hasOwnProperty('originX')) {
            this.setOriginX(o.originX);
          }
          if (o.hasOwnProperty('originY')) {
            this.setOriginY(o.originY);
          }
        }
        if (o.hasOwnProperty('depth')) {
          this.setDepth(o.depth);
        }
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(RenderBase.prototype), "reset", this).call(this);
        this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setOrigin(0).setDepth(0);
        return this;
      }

      // Override
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {}
      // Override
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy, roundPixels) {}
    }]);
    return RenderBase;
  }(Base$3);

  var TransformMatrix$2 = Phaser.GameObjects.Components.TransformMatrix;
  var GetTint$2 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
  var FrameMatrix = new TransformMatrix$2();
  var WebglRender = function WebglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {
    var width = this._width,
      height = this._height;
    var displayOriginX = width * this.originX,
      displayOriginY = height * this.originY;
    var x = this.x - dx,
      y = this.y - dy;
    var flipX = 1;
    var flipY = 1;
    if (this.flipX) {
      x += width - displayOriginX * 2;
      flipX = -1;
    }
    if (this.flipY) {
      y += height - displayOriginY * 2;
      flipY = -1;
    }
    FrameMatrix.applyITRS(x, y, this.rotation, this.scaleX * flipX, this.scaleY * flipY);
    calcMatrix.multiply(FrameMatrix, FrameMatrix);
    var tx = -displayOriginX;
    var ty = -displayOriginY;
    var tw = tx + width;
    var th = ty + height;
    var quad = FrameMatrix.setQuad(tx, ty, tw, th, roundPixels);
    var u0 = this.frame.u0;
    var v0 = this.frame.v0;
    var u1 = this.frame.u1;
    var v1 = this.frame.v1;
    var tint = GetTint$2(this.tint, this.alpha * alpha);
    pipeline.batchQuad(this.parent, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], u0, v0, u1, v1, tint, tint, tint, tint, this.tintFill, texture, textureUnit);
  };

  var CanvasRender = function CanvasRender(ctx, dx, dy, roundPixels) {
    ctx.save();
    var width = this._width,
      height = this._height;
    var displayOriginX = width * this.originX,
      displayOriginY = height * this.originY;
    var x = this.x - displayOriginX,
      y = this.y - displayOriginY;
    var flipX = 1;
    var flipY = 1;
    if (this.flipX) {
      x += width;
      flipX = -1;
    }
    if (this.flipY) {
      y += height;
      flipY = -1;
    }
    if (roundPixels) {
      x = Math.round(x);
      y = Math.round(y);
    }
    ctx.translate(x, y);
    ctx.rotate(this.rotation);
    ctx.scale(this.scaleX * flipX, this.scaleY * flipY);
    var frame = this.frame;
    ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, width, height, 0, 0, width, height);
    ctx.restore();
  };

  var IsPlainObject$M = Phaser.Utils.Objects.IsPlainObject;
  var ImageData$1 = /*#__PURE__*/function (_RenderBase) {
    _inherits(ImageData, _RenderBase);
    function ImageData(parent, frame) {
      var _this;
      _classCallCheck(this, ImageData);
      _this = _callSuper(this, ImageData, [parent, ImageTypeName$1]);
      _this.setFrame(frame);
      return _this;
    }
    _createClass(ImageData, [{
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {}
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {}
    }, {
      key: "setFrame",
      value: function setFrame(frame) {
        if (arguments.length > 0 && !IsPlainObject$M(frame)) {
          frame = this.parent.texture.get(frame);
        }
        this.frame = frame;
        this._width = frame ? frame.width : 0;
        this._height = frame ? frame.height : 0;
        return this;
      }
    }, {
      key: "setFlipX",
      value: function setFlipX(flipX) {
        if (flipX === undefined) {
          flipX = true;
        }
        this.flipX = flipX;
        return this;
      }
    }, {
      key: "setFlipY",
      value: function setFlipY(flipY) {
        if (flipY === undefined) {
          flipY = true;
        }
        this.flipY = flipY;
        return this;
      }
    }, {
      key: "resetFlip",
      value: function resetFlip() {
        this.flipX = false;
        this.flipY = false;
        return this;
      }
    }, {
      key: "tint",
      get: function get() {
        if (this._tint === undefined) {
          return this.parent.tint;
        } else {
          return this._tint;
        }
      },
      set: function set(value) {
        this._tint = value;
      }
    }, {
      key: "setTint",
      value: function setTint(value) {
        this.tint = value;
        this.tintFill = false;
        return this;
      }
    }, {
      key: "setTintFill",
      value: function setTintFill(value) {
        this.tint = value;
        this.tintFill = true;
        return this;
      }
    }, {
      key: "clearTint",
      value: function clearTint() {
        this.setTint(0xffffff);
        return this;
      }
    }, {
      key: "resetTint",
      value: function resetTint() {
        this.tint = undefined;
        this.tintFill = undefined;
        return this;
      }
    }, {
      key: "tintFill",
      get: function get() {
        if (this._tintFill === undefined) {
          return this.parent.tintFill;
        } else {
          return this._tintFill;
        }
      },
      set: function set(value) {
        this._tintFill = value;
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(ImageData.prototype), "reset", this).call(this);
        this.resetFlip().resetTint().setFrame();
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (!o) {
          return this;
        }

        // Size of Image is equal to frame size,
        // Move width, height properties to displayWidth,displayHeight
        if (o.hasOwnProperty('width')) {
          o.displayWidth = o.width;
          delete o.width;
        }
        if (o.hasOwnProperty('height')) {
          o.displayHeight = o.height;
          delete o.height;
        }
        if (o.hasOwnProperty('frame')) {
          this.setFrame(o.frame);
        }
        _get(_getPrototypeOf(ImageData.prototype), "modifyPorperties", this).call(this, o);
        if (o.hasOwnProperty('flipX')) {
          this.setFlipX(o.flipX);
        }
        if (o.hasOwnProperty('flipY')) {
          this.setFlipY(o.flipY);
        }
        if (o.hasOwnProperty('tint')) {
          this.setTint(o.tint);
        }
        if (o.hasOwnProperty('tintFill')) {
          this.setTintFill(o.tintFill);
        }
        return this;
      }
    }]);
    return ImageData;
  }(RenderBase$1);
  var methods$B = {
    webglRender: WebglRender,
    canvasRender: CanvasRender
  };
  Object.assign(ImageData$1.prototype, methods$B);

  var AddImage$2 = function AddImage(blitter, config) {
    if (typeof config === 'string') {
      config = {
        frame: config
      };
    }
    var bob = blitter.poolManager ? blitter.poolManager.allocate(ImageTypeName$1) : null;
    if (bob === null) {
      bob = new ImageData$1(blitter);
    } else {
      bob.setParent(blitter).setActive();
    }
    bob.modifyPorperties(config);
    blitter.addChild(bob);
    return bob;
  };

  var DrawImage$1 = function DrawImage(key, frame, x, y, width, height) {
    AddImage$2(this, {
      frame: frame,
      x: x,
      y: y,
      width: width,
      height: height
    });
  };

  var DrawTileSprite = function DrawTileSprite(key, frame, x, y, width, height) {
    var frameObj = this.texture.get(frame);
    var frameWidth = frameObj.width,
      frameHeight = frameObj.height;
    var colCount = Math.floor(width / frameWidth),
      rowCount = Math.floor(height / frameHeight);
    // Align images at center
    x += (width - colCount * frameWidth) / 2;
    y += (height - rowCount * frameHeight) / 2;
    for (var colIndex = 0; colIndex < colCount; colIndex++) {
      for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
        AddImage$2(this, {
          frame: frame,
          x: x + colIndex * frameWidth,
          y: y + rowIndex * frameHeight
        });
      }
    }
  };

  var Methods$g = {
    _drawImage: DrawImage$1,
    _drawTileSprite: DrawTileSprite
  };

  var NinePatch = /*#__PURE__*/function (_NinePatchBase) {
    _inherits(NinePatch, _NinePatchBase);
    function NinePatch() {
      _classCallCheck(this, NinePatch);
      return _callSuper(this, NinePatch, arguments);
    }
    _createClass(NinePatch, [{
      key: "setBaseTexture",
      value: function setBaseTexture(key, baseFrameName, columns, rows) {
        this.setTexture(key, baseFrameName);
        _get(_getPrototypeOf(NinePatch.prototype), "setBaseTexture", this).call(this, key, baseFrameName, columns, rows);
        return this;
      }
    }]);
    return NinePatch;
  }(NinePatchBase(Blitter, 'rexNinePatch2'));
  Object.assign(NinePatch.prototype, Methods$g);

  var GetValue$31 = Phaser.Utils.Objects.GetValue;
  var RoundRectangle$2 = /*#__PURE__*/function () {
    function RoundRectangle(x, y, width, height, radiusConfig) {
      _classCallCheck(this, RoundRectangle);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = x;
      }
      if (width === undefined) {
        width = 0;
      }
      if (height === undefined) {
        height = 0;
      }
      if (radiusConfig === undefined) {
        radiusConfig = 0;
      }
      this.cornerRadius = {};
      this._width = 0;
      this._height = 0;
      this.setTo(x, y, width, height, radiusConfig);
    }
    _createClass(RoundRectangle, [{
      key: "setTo",
      value: function setTo(x, y, width, height, radiusConfig) {
        this.setPosition(x, y);
        this.setRadius(radiusConfig);
        this.setSize(width, height);
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "setRadius",
      value: function setRadius(value) {
        if (value === undefined) {
          value = 0;
        }
        this.radius = value;
        return this;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.width = width;
        this.height = height;
        return this;
      }
    }, {
      key: "minWidth",
      get: function get() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
      }
    }, {
      key: "minHeight",
      get: function get() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        if (value == null) {
          value = 0;
        }
        this._width = Math.max(value, this.minWidth);
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        if (value == null) {
          value = 0;
        }
        this._height = Math.max(value, this.minHeight);
      }
    }, {
      key: "radius",
      get: function get() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.x, radius.tl.y, radius.tr.x, radius.tr.y, radius.bl.x, radius.bl.y, radius.br.x, radius.br.y);
      },
      set: function set(value) {
        var defaultRadiusX, defaultRadiusY;
        if (typeof value === 'number') {
          defaultRadiusX = value;
          defaultRadiusY = value;
        } else {
          defaultRadiusX = GetValue$31(value, 'x', 0);
          defaultRadiusY = GetValue$31(value, 'y', 0);
        }
        var radius = this.cornerRadius;
        radius.tl = GetRadius(GetValue$31(value, 'tl', undefined), defaultRadiusX, defaultRadiusY);
        radius.tr = GetRadius(GetValue$31(value, 'tr', undefined), defaultRadiusX, defaultRadiusY);
        radius.bl = GetRadius(GetValue$31(value, 'bl', undefined), defaultRadiusX, defaultRadiusY);
        radius.br = GetRadius(GetValue$31(value, 'br', undefined), defaultRadiusX, defaultRadiusY);
      }
    }, {
      key: "radiusTL",
      get: function get() {
        var radius = this.cornerRadius.tl;
        return Math.max(radius.x, radius.y);
      },
      set: function set(value) {
        SetRadius(this.cornerRadius.tl, value);
      }
    }, {
      key: "radiusTR",
      get: function get() {
        var radius = this.cornerRadius.tr;
        return Math.max(radius.x, radius.y);
      },
      set: function set(value) {
        SetRadius(this.cornerRadius.tr, value);
      }
    }, {
      key: "radiusBL",
      get: function get() {
        var radius = this.cornerRadius.bl;
        return Math.max(radius.x, radius.y);
      },
      set: function set(value) {
        SetRadius(this.cornerRadius.bl, value);
      }
    }, {
      key: "radiusBR",
      get: function get() {
        var radius = this.cornerRadius.br;
        return Math.max(radius.x, radius.y);
      },
      set: function set(value) {
        SetRadius(this.cornerRadius.br, value);
      }
    }]);
    return RoundRectangle;
  }();
  var GetRadius = function GetRadius(radius, defaultRadiusX, defaultRadiusY) {
    if (radius === undefined) {
      radius = {
        x: defaultRadiusX,
        y: defaultRadiusY
      };
    } else if (typeof radius === 'number') {
      radius = {
        x: radius,
        y: radius
      };
    }
    SetConvex(radius);
    return radius;
  };
  var SetRadius = function SetRadius(radius, value) {
    if (typeof value === 'number') {
      radius.x = value;
      radius.y = value;
    } else {
      radius.x = GetValue$31(value, 'x', 0);
      radius.y = GetValue$31(value, 'y', 0);
    }
    SetConvex(radius);
  };
  var SetConvex = function SetConvex(radius) {
    radius.convex = radius.x >= 0 || radius.y >= 0;
    radius.x = Math.abs(radius.x);
    radius.y = Math.abs(radius.y);
  };

  var LineTo = function LineTo(x, y, pathData) {
    var cnt = pathData.length;
    if (cnt >= 2) {
      var lastX = pathData[cnt - 2];
      var lastY = pathData[cnt - 1];
      if (x === lastX && y === lastY) {
        return pathData;
      }
    }
    pathData.push(x, y);
    return pathData;
  };

  var DegToRad$e = Phaser.Math.DegToRad;
  var ArcTo$1 = function ArcTo(centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, pathData) {
    // startAngle, endAngle: 0 ~ 360
    if (antiClockWise && endAngle > startAngle) {
      endAngle -= 360;
    } else if (!antiClockWise && endAngle < startAngle) {
      endAngle += 360;
    }
    var deltaAngle = endAngle - startAngle;
    var step = DegToRad$e(deltaAngle) / iteration;
    startAngle = DegToRad$e(startAngle);
    for (var i = 0; i <= iteration; i++) {
      var angle = startAngle + step * i;
      var x = centerX + radiusX * Math.cos(angle);
      var y = centerY + radiusY * Math.sin(angle);
      LineTo(x, y, pathData);
    }
    return pathData;
  };

  /*
  src: {
      fillColor, 
      fillAlpha, 
      pathData, 
      pathIndexes  // Earcut(pathData)
  }
  */

  var Utils$3 = Phaser.Renderer.WebGL.Utils;
  var FillPathWebGL = function FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy) {
    var fillTintColor = Utils$3.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
    var path = src.pathData;
    var pathIndexes = src.pathIndexes;
    for (var i = 0; i < pathIndexes.length; i += 3) {
      var p0 = pathIndexes[i] * 2;
      var p1 = pathIndexes[i + 1] * 2;
      var p2 = pathIndexes[i + 2] * 2;
      var x0 = path[p0 + 0] - dx;
      var y0 = path[p0 + 1] - dy;
      var x1 = path[p1 + 0] - dx;
      var y1 = path[p1 + 1] - dy;
      var x2 = path[p2 + 0] - dx;
      var y2 = path[p2 + 1] - dy;
      var tx0 = calcMatrix.getX(x0, y0);
      var ty0 = calcMatrix.getY(x0, y0);
      var tx1 = calcMatrix.getX(x1, y1);
      var ty1 = calcMatrix.getY(x1, y1);
      var tx2 = calcMatrix.getX(x2, y2);
      var ty2 = calcMatrix.getY(x2, y2);
      pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
    }
  };

  /*
  src: {
      strokeColor,
      strokeAlpha,
      pathData,
      lineWidth,
      closePath
  }
  */
  var Utils$2 = Phaser.Renderer.WebGL.Utils;
  var StrokePathWebGL = function StrokePathWebGL(pipeline, src, alpha, dx, dy) {
    var strokeTint = pipeline.strokeTint;
    var strokeTintColor = Utils$2.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
    strokeTint.TL = strokeTintColor;
    strokeTint.TR = strokeTintColor;
    strokeTint.BL = strokeTintColor;
    strokeTint.BR = strokeTintColor;
    var path = src.pathData;
    var pathLength = path.length - 1;
    var lineWidth = src.lineWidth;
    var halfLineWidth = lineWidth / 2;
    var px1 = path[0] - dx;
    var py1 = path[1] - dy;
    if (!src.closePath) {
      pathLength -= 2;
    }
    for (var i = 2; i < pathLength; i += 2) {
      var px2 = path[i] - dx;
      var py2 = path[i + 1] - dy;
      pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, src.closePath ? i === pathLength - 1 : false);
      px1 = px2;
      py1 = py2;
    }
  };

  var GetCalcMatrix$1 = Phaser.GameObjects.GetCalcMatrix;
  var PolygonWebGLRenderer = function PolygonWebGLRenderer(renderer, src, camera, parentMatrix) {
    if (src.dirty) {
      src.updateData();
      src.dirty = false;
    }
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix$1(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isFilled) {
      FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }
    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
    renderer.pipelines.postBatch(src);
  };

  var FillStyleCanvas = function FillStyleCanvas(ctx, src, altColor, altAlpha) {
    var fillColor = altColor ? altColor : src.fillColor;
    var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
    var red = (fillColor & 0xFF0000) >>> 16;
    var green = (fillColor & 0xFF00) >>> 8;
    var blue = fillColor & 0xFF;
    ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
  };

  var LineStyleCanvas = function LineStyleCanvas(ctx, src, altColor, altAlpha) {
    var strokeColor = altColor ? altColor : src.strokeColor;
    var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
    var red = (strokeColor & 0xFF0000) >>> 16;
    var green = (strokeColor & 0xFF00) >>> 8;
    var blue = strokeColor & 0xFF;
    ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';
    ctx.lineWidth = src.lineWidth;
  };

  var SetTransform$1 = Phaser.Renderer.Canvas.SetTransform;
  var PolygonCanvasRenderer = function PolygonCanvasRenderer(renderer, src, camera, parentMatrix) {
    if (src.dirty) {
      src.updateData();
      src.dirty = false;
    }
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform$1(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var path = src.pathData;
      var pathLength = path.length - 1;
      var px1 = path[0] - dx;
      var py1 = path[1] - dy;
      ctx.beginPath();
      ctx.moveTo(px1, py1);
      if (!src.closePath) {
        pathLength -= 2;
      }
      for (var i = 2; i < pathLength; i += 2) {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;
        ctx.lineTo(px2, py2);
      }
      ctx.closePath();
      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fill();
      }
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.stroke();
      }

      //  Restore the context saved in SetTransform
      ctx.restore();
    }
  };

  var Render$3 = {
    renderWebGL: PolygonWebGLRenderer,
    renderCanvas: PolygonCanvasRenderer
  };

  var Shape$1 = Phaser.GameObjects.Shape;
  var IsPlainObject$L = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$30 = Phaser.Utils.Objects.GetValue;
  var Earcut$1 = Phaser.Geom.Polygon.Earcut;
  var RoundRectangle$1 = /*#__PURE__*/function (_Shape) {
    _inherits(RoundRectangle, _Shape);
    function RoundRectangle(scene, x, y, width, height, radiusConfig, fillColor, fillAlpha) {
      var _this;
      _classCallCheck(this, RoundRectangle);
      var strokeColor, strokeAlpha, strokeWidth, shapeType;
      if (IsPlainObject$L(x)) {
        var config = x;
        x = config.x;
        y = config.y;
        width = config.width;
        height = config.height;
        radiusConfig = config.radius;
        fillColor = config.color;
        fillAlpha = config.alpha;
        strokeColor = config.strokeColor;
        strokeAlpha = config.strokeAlpha;
        strokeWidth = config.strokeWidth;
        shapeType = config.shape;
      }
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 1;
      }
      if (height === undefined) {
        height = width;
      }
      if (radiusConfig === undefined) {
        radiusConfig = 0;
      }
      if (shapeType === undefined) {
        shapeType = 0;
      }
      var geom = new RoundRectangle$2(); // Configurate it later
      _this = _callSuper(this, RoundRectangle, [scene, 'rexRoundRectangleShape', geom]);
      _this.setShapeType(shapeType);
      if (_this.shapeType === 0) {
        var radius = GetValue$30(radiusConfig, 'radius', radiusConfig);
        geom.setTo(0, 0, width, height, radius);
      } else {
        var radius = {
          x: width / 2,
          y: height / 2
        };
        geom.setTo(0, 0, width, height, radius);
      }
      var iteration = GetValue$30(radiusConfig, 'iteration', undefined);
      _this.setIteration(iteration);
      _this.setPosition(x, y);
      _this.setFillStyle(fillColor, fillAlpha);
      if (strokeColor !== undefined && strokeWidth === undefined) {
        strokeWidth = 2;
      }
      _this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);
      _this.updateDisplayOrigin();
      _this.dirty = true;
      return _this;
    }
    _createClass(RoundRectangle, [{
      key: "fillColor",
      get: function get() {
        return this._fillColor;
      },
      set: function set(value) {
        this._fillColor = value;
        this.isFilled = value != null && this._fillAlpha > 0;
      }
    }, {
      key: "fillAlpha",
      get: function get() {
        return this._fillAlpha;
      },
      set: function set(value) {
        this._fillAlpha = value;
        this.isFilled = value > 0 && this._fillColor != null;
      }

      // Fully override setFillStyle method
    }, {
      key: "setFillStyle",
      value: function setFillStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.fillColor = color;
        this.fillAlpha = alpha;
        return this;
      }
    }, {
      key: "strokeColor",
      get: function get() {
        return this._strokeColor;
      },
      set: function set(value) {
        this._strokeColor = value;
        this.isStroked = value != null && this._strokeAlpha > 0 && this._lineWidth > 0;
      }
    }, {
      key: "strokeAlpha",
      get: function get() {
        return this._strokeAlpha;
      },
      set: function set(value) {
        this._strokeAlpha = value;
        this.isStroked = value > 0 && this._strokeColor != null && this._lineWidth > 0;
      }
    }, {
      key: "lineWidth",
      get: function get() {
        return this._lineWidth;
      },
      set: function set(value) {
        this._lineWidth = value;
        this.isStroked = value > 0 && this._strokeColor != null;
      }

      // Fully override setStrokeStyle method
    }, {
      key: "setStrokeStyle",
      value: function setStrokeStyle(lineWidth, color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.lineWidth = lineWidth;
        this.strokeColor = color;
        this.strokeAlpha = alpha;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        var geom = this.geom;
        var pathData = this.pathData;
        pathData.length = 0;
        var width = geom.width,
          height = geom.height,
          cornerRadius = geom.cornerRadius,
          radius,
          iteration = this.iteration + 1;

        // Top-left
        radius = cornerRadius.tl;
        if (IsArcCorner$1(radius)) {
          if (radius.convex) {
            var centerX = radius.x;
            var centerY = radius.y;
            ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 270, false, iteration, pathData);
          } else {
            var centerX = 0;
            var centerY = 0;
            ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 0, true, iteration, pathData);
          }
        } else {
          LineTo(0, 0, pathData);
        }

        // Top-right
        radius = cornerRadius.tr;
        if (IsArcCorner$1(radius)) {
          if (radius.convex) {
            var centerX = width - radius.x;
            var centerY = radius.y;
            ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 360, false, iteration, pathData);
          } else {
            var centerX = width;
            var centerY = 0;
            ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 90, true, iteration, pathData);
          }
        } else {
          LineTo(width, 0, pathData);
        }

        // Bottom-right
        radius = cornerRadius.br;
        if (IsArcCorner$1(radius)) {
          if (radius.convex) {
            var centerX = width - radius.x;
            var centerY = height - radius.y;
            ArcTo$1(centerX, centerY, radius.x, radius.y, 0, 90, false, iteration, pathData);
          } else {
            var centerX = width;
            var centerY = height;
            ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 180, true, iteration, pathData);
          }
        } else {
          LineTo(width, height, pathData);
        }

        // Bottom-left
        radius = cornerRadius.bl;
        if (IsArcCorner$1(radius)) {
          if (radius.convex) {
            var centerX = radius.x;
            var centerY = height - radius.y;
            ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 180, false, iteration, pathData);
          } else {
            var centerX = 0;
            var centerY = height;
            ArcTo$1(centerX, centerY, radius.x, radius.y, 360, 270, true, iteration, pathData);
          }
        } else {
          LineTo(0, height, pathData);
        }
        pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
        this.pathIndexes = Earcut$1(pathData);
        return this;
      }
    }, {
      key: "setShapeType",
      value: function setShapeType(shapeType) {
        if (typeof shapeType === 'string') {
          shapeType = ShapeTypeMap[shapeType];
        }
        this.shapeType = shapeType;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this.geom.width;
      },
      set: function set(value) {
        this.resize(value, this.height);
      }
    }, {
      key: "height",
      get: function get() {
        return this.geom.height;
      },
      set: function set(value) {
        this.resize(this.width, value);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        // Override Shape's setSize method
        if (height === undefined) {
          height = width;
        }
        if (this.geom.width === width && this.geom.height === height) {
          return this;
        }
        this.geom.setSize(width, height);
        if (this.shapeType === 1) {
          this.setRadius({
            x: width / 2,
            y: height / 2
          });
        }
        this.updateDisplayOrigin();
        this.dirty = true;
        var input = this.input;
        if (input && !input.customHitArea) {
          input.hitArea.width = width;
          input.hitArea.height = height;
        }
        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this.setSize(width, height);
        return this;
      }
    }, {
      key: "radius",
      get: function get() {
        return this.geom.radius;
      },
      set: function set(value) {
        this.geom.setRadius(value);
        this.updateDisplayOrigin();
        this.dirty = true;
      }
    }, {
      key: "radiusTL",
      get: function get() {
        return this.geom.radiusTL;
      },
      set: function set(value) {
        this.geom.radiusTL = value;
        this.dirty = true;
      }
    }, {
      key: "radiusTR",
      get: function get() {
        return this.geom.radiusTR;
      },
      set: function set(value) {
        this.geom.radiusTR = value;
        this.dirty = true;
      }
    }, {
      key: "radiusBL",
      get: function get() {
        return this.geom.radiusBL;
      },
      set: function set(value) {
        this.geom.radiusBL = value;
        this.dirty = true;
      }
    }, {
      key: "radiusBR",
      get: function get() {
        return this.geom.radiusBR;
      },
      set: function set(value) {
        this.geom.radiusBR = value;
        this.dirty = true;
      }
    }, {
      key: "setRadius",
      value: function setRadius(value) {
        if (value === undefined) {
          value = 0;
        }
        this.radius = value;
        return this;
      }
    }, {
      key: "setRadiusTL",
      value: function setRadiusTL(value) {
        if (value === undefined) {
          value = 0;
        }
        this.radiusTL = value;
        return this;
      }
    }, {
      key: "setRadiusTR",
      value: function setRadiusTR(value) {
        if (value === undefined) {
          value = 0;
        }
        this.radiusTR = value;
        return this;
      }
    }, {
      key: "setRadiusBL",
      value: function setRadiusBL(value) {
        if (value === undefined) {
          value = 0;
        }
        this.radiusBL = value;
        return this;
      }
    }, {
      key: "setRadiusBR",
      value: function setRadiusBR(value) {
        if (value === undefined) {
          value = 0;
        }
        this.radiusBR = value;
        return this;
      }
    }, {
      key: "cornerRadius",
      get: function get() {
        return this.geom.cornerRadius;
      },
      set: function set(value) {
        this.radius = value;
      }
    }, {
      key: "setCornerRadius",
      value: function setCornerRadius(value) {
        return this.setRadius(value);
      }
    }, {
      key: "iteration",
      get: function get() {
        return this._iteration;
      },
      set: function set(value) {
        // Set iteration first time
        if (this._iteration === undefined) {
          this._iteration = value;
          return;
        }

        // Change iteration value
        if (this._iteration === value) {
          return;
        }
        this._iteration = value;
        this.dirty = true;
      }
    }, {
      key: "setIteration",
      value: function setIteration(iteration) {
        if (iteration === undefined) {
          iteration = 6;
        }
        this.iteration = iteration;
        return this;
      }
    }]);
    return RoundRectangle;
  }(Shape$1);
  var IsArcCorner$1 = function IsArcCorner(radius) {
    return radius.x > 0 && radius.y > 0;
  };
  var ShapeTypeMap = {
    rectangle: 0,
    circle: 1
  };
  Object.assign(RoundRectangle$1.prototype, Render$3);

  // copy from Phaser.GameObjects.Text

  var Utils$1 = Phaser.Renderer.WebGL.Utils;
  var WebGLRenderer$2 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
    if (src.dirty) {
      src.updateTexture();
      src.dirty = false;
    }
    if (src.width === 0 || src.height === 0) {
      return;
    }
    camera.addToRenderList(src);
    var frame = src.frame;
    var width = frame.width;
    var height = frame.height;
    var getTint = Utils$1.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
    renderer.pipelines.preBatch(src);
    pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.resolution, height / src.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
    renderer.pipelines.postBatch(src);
  };

  // copy from Phaser.GameObjects.Text

  var CanvasRenderer$2 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
    if (src.dirty) {
      src.updateTexture();
      src.dirty = false;
    }
    if (src.width === 0 || src.height === 0) {
      return;
    }
    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };

  var Render$2 = {
    renderWebGL: WebGLRenderer$2,
    renderCanvas: CanvasRenderer$2
  };

  var Color$4 = Phaser.Display.Color;
  var CanvasMethods = {
    clear: function clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.dirty = true;
      return this;
    },
    fill: function fill(color) {
      this.context.fillStyle = color;
      this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.dirty = true;
      return this;
    },
    drawFrame: function drawFrame(key, frame, dx, dy, dWidth, dHeight, sxOffset, syOffset, sWidth, sHeight) {
      var textureFrame = this.scene.sys.textures.getFrame(key, frame);
      if (!textureFrame) {
        return this;
      }
      var frameWidth = textureFrame.cutWidth,
        frameHeight = textureFrame.cutHeight;
      if (dx === undefined) {
        dx = 0;
      }
      if (dy === undefined) {
        dy = 0;
      }
      if (dWidth === undefined) {
        dWidth = frameWidth;
      }
      if (dHeight === undefined) {
        dHeight = frameHeight;
      }
      if (sxOffset === undefined) {
        sxOffset = 0;
      }
      if (syOffset === undefined) {
        syOffset = 0;
      }
      if (sWidth === undefined) {
        sWidth = frameWidth;
      }
      if (sHeight === undefined) {
        sHeight = frameHeight;
      }
      var sx = textureFrame.cutX + sxOffset;
      var sy = textureFrame.cutY + syOffset;
      this.context.drawImage(textureFrame.source.image,
      // image
      sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
      this.dirty = true;
      return this;
    },
    getDataURL: function getDataURL(type, encoderOptions) {
      return this.canvas.toDataURL(type, encoderOptions);
    },
    getPixel: function getPixel(x, y, out) {
      if (out === undefined) {
        out = new Color$4();
      }
      var rgb = this.context.getImageData(x, y, 1, 1);
      out.setTo(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
      return out;
    },
    setPixel: function setPixel(x, y, r, g, b, a) {
      if (typeof r !== 'number') {
        var color = r;
        r = color.red;
        g = color.green;
        b = color.blue;
        a = color.alpha;
      }
      if (a === undefined) {
        a = r !== 0 || g !== 0 || b !== 0 ? 255 : 0;
      }
      var imgData = this.context.createImageData(1, 1);
      imgData.data[0] = r;
      imgData.data[1] = g;
      imgData.data[2] = b;
      imgData.data[3] = a;
      this.context.putImageData(imgData, x, y);
      this.dirty = true;
      return this;
    }
  };

  var CopyCanvasToTexture = function CopyCanvasToTexture(scene, srcCanvas, key, x, y, width, height) {
    var textures = scene.sys.textures;
    var renderer = scene.renderer;
    if (x === undefined) {
      x = 0;
    }
    if (y === undefined) {
      y = 0;
    }
    if (width === undefined) {
      width = srcCanvas.width;
    }
    if (height === undefined) {
      height = srcCanvas.height;
    }
    var texture;
    if (textures.exists(key)) {
      texture = textures.get(key);
    } else {
      texture = textures.createCanvas(key, width, height);
    }
    var destCanvas = texture.getSourceImage();
    if (destCanvas.width !== width) {
      destCanvas.width = width;
    }
    if (destCanvas.height !== height) {
      destCanvas.height = height;
    }
    var destCtx = destCanvas.getContext('2d', {
      willReadFrequently: true
    });
    destCtx.clearRect(0, 0, width, height);
    destCtx.drawImage(srcCanvas, x, y, width, height);
    if (renderer.gl && texture) {
      renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);
    }
  };

  var TextureMethods = {
    updateTexture: function updateTexture(callback, scope) {
      if (callback) {
        if (scope) {
          callback.call(scope, this.canvas, this.context);
        } else {
          callback(this.canvas, this.context);
        }
      }
      if (this.canvas.width !== this.frame.width || this.canvas.height !== this.frame.height) {
        this.frame.setSize(this.canvas.width, this.canvas.height);
      }
      if (this.renderer && this.renderer.gl) {
        this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);
        if (typeof WEBGL_DEBUG === "undefined" ? "undefined" : _typeof(WEBGL_DEBUG)) {
          this.frame.glTexture.spectorMetadata = {
            textureKey: 'Canvas Game Object'
          };
        }
      }
      this.dirty = false;
      var input = this.input;
      if (input && !input.customHitArea) {
        input.hitArea.width = this.width;
        input.hitArea.height = this.height;
      }
      return this;
    },
    generateTexture: function generateTexture(key, x, y, width, height) {
      var srcCanvas = this.canvas;
      if (width === undefined) {
        width = srcCanvas.width;
      } else {
        width *= this.resolution;
      }
      if (height === undefined) {
        height = srcCanvas.height;
      } else {
        height *= this.resolution;
      }
      CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
      return this;
    },
    loadTexture: function loadTexture(key, frame) {
      var textureFrame = this.scene.sys.textures.getFrame(key, frame);
      if (!textureFrame) {
        return this;
      }
      if (this.width !== textureFrame.cutWidth || this.height !== textureFrame.cutHeight) {
        this.setSize(textureFrame.cutWidth, textureFrame.cutHeight);
      } else {
        this.clear();
      }
      this.drawFrame(key, frame);
      this.dirty = true;
      return this;
    }
  };

  CheckP3Version();
  var CanvasPool$4 = Phaser.Display.Canvas.CanvasPool;
  var GameObject$3 = Phaser.GameObjects.GameObject;
  var UUID$5 = Phaser.Utils.String.UUID;
  var Canvas$1 = /*#__PURE__*/function (_GameObject) {
    _inherits(Canvas, _GameObject);
    function Canvas(scene, x, y, width, height) {
      var _this;
      _classCallCheck(this, Canvas);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 1;
      }
      if (height === undefined) {
        height = 1;
      }
      _this = _callSuper(this, Canvas, [scene, 'rexCanvas']);
      _this.renderer = scene.sys.game.renderer;
      _this.resolution = 1;
      _this._width = width;
      _this._height = height;
      width = Math.max(Math.ceil(width * _this.resolution), 1);
      height = Math.max(Math.ceil(height * _this.resolution), 1);
      _this.canvas = CanvasPool$4.create(_assertThisInitialized(_this), width, height);
      _this.context = _this.canvas.getContext('2d', {
        willReadFrequently: true
      });
      _this.dirty = false;
      _this.setPosition(x, y);
      _this.setOrigin(0.5, 0.5);
      _this.initPipeline();
      _this.initPostPipeline(true);
      _this._crop = _this.resetCropObject();

      //  Create a Texture for this Text object
      _this._textureKey = UUID$5();
      _this.texture = scene.sys.textures.addCanvas(_this._textureKey, _this.canvas);

      //  Get the frame
      _this.frame = _this.texture.get();

      //  Set the resolution
      _this.frame.source.resolution = _this.resolution;
      if (_this.renderer && _this.renderer.gl) {
        //  Clear the default 1x1 glTexture, as we override it later
        _this.renderer.deleteTexture(_this.frame.source.glTexture);
        _this.frame.source.glTexture = null;
      }
      _this.dirty = true;
      return _this;
    }
    _createClass(Canvas, [{
      key: "preDestroy",
      value: function preDestroy() {
        CanvasPool$4.remove(this.canvas);
        this.canvas = null;
        this.context = null;
        var texture = this.texture;
        if (texture) {
          texture.destroy();
        }
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this.setSize(value, this._height);
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this.setSize(this._width, value);
      }
    }, {
      key: "setCanvasSize",
      value: function setCanvasSize(width, height) {
        if (this._width === width && this._height === height) {
          return this;
        }
        this._width = width;
        this._height = height;
        this.updateDisplayOrigin();
        width = Math.max(Math.ceil(width * this.resolution), 1);
        height = Math.max(Math.ceil(height * this.resolution), 1);
        this.canvas.width = width;
        this.canvas.height = height;
        this.frame.setSize(width, height);
        this.dirty = true;
        return this;
      }

      // setSize might be override
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.setCanvasSize(width, height);
        return this;
      }
    }, {
      key: "displayWidth",
      get: function get() {
        return this.scaleX * this._width;
      },
      set: function set(value) {
        this.scaleX = value / this._width;
      }
    }, {
      key: "displayHeight",
      get: function get() {
        return this.scaleY * this._height;
      },
      set: function set(value) {
        this.scaleY = value / this._height;
      }
    }, {
      key: "setDisplaySize",
      value: function setDisplaySize(width, height) {
        this.displayWidth = width;
        this.displayHeight = height;
        return this;
      }
    }, {
      key: "getCanvas",
      value: function getCanvas(readOnly) {
        if (!readOnly) {
          this.dirty = true;
        }
        return this.canvas;
      }
    }, {
      key: "getContext",
      value: function getContext(readOnly) {
        if (!readOnly) {
          this.dirty = true;
        }
        return this.context;
      }
    }, {
      key: "needRedraw",
      value: function needRedraw() {
        this.dirty = true;
        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this.setSize(width, height);
        return this;
      }
    }]);
    return Canvas;
  }(GameObject$3);
  var Components$3 = Phaser.GameObjects.Components;
  Phaser.Class.mixin(Canvas$1, [Components$3.Alpha, Components$3.BlendMode, Components$3.Crop, Components$3.Depth, Components$3.Flip, Components$3.GetBounds, Components$3.Mask, Components$3.Origin, Components$3.Pipeline, Components$3.PostPipeline, Components$3.ScrollFactor, Components$3.Tint, Components$3.Transform, Components$3.Visible, Render$2, CanvasMethods, TextureMethods]);

  var Pad$1 = Phaser.Utils.String.Pad;
  var GetStyle = function GetStyle(style, canvas, context) {
    if (style == null) {
      return style;
    }
    switch (_typeof(style)) {
      case 'string':
        return style;
      case 'number':
        return "#".concat(Pad$1(Math.floor(style).toString(16), 6, '0', 1));
      case 'function':
        return style(canvas, context);
      case 'object':
        if (style.hasOwnProperty('r')) {
          if (style.hasOwnProperty('a')) {
            // rgba
            return "rgba(".concat(style.r, ",").concat(style.g, ",").concat(style.b, ",").concat(style.a, ")");
          } else {
            // rgb
            return "rgb(".concat(style.r, ",").concat(style.g, ",").concat(style.b, ")");
          }
        } else if (style.hasOwnProperty('h')) {
          if (style.hasOwnProperty('a')) {
            // hsla
            return "hsla(".concat(style.h, ",").concat(style.s, ",").concat(style.l, ",").concat(style.a, ")");
          } else {
            // hsl
            return "hsl(".concat(style.h, ",").concat(style.s, ",").concat(style.l, ")");
          }
        } else {
          return style; // Not a valid input
        }
      default:
        return style;
    }
  };

  var DegToRad$d = Phaser.Math.DegToRad;
  var AddRoundRectanglePath = function AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration) {
    var geom = new RoundRectangle$2(x, y, width, height, radiusConfig),
      minWidth = geom.minWidth,
      minHeight = geom.minHeight,
      scaleRX = width >= minWidth ? 1 : width / minWidth,
      scaleRY = height >= minHeight ? 1 : height / minHeight;
    var cornerRadius = geom.cornerRadius;
    var radius, radiusX, radiusY, centerX, centerY;
    var startX, startY;
    context.save();
    context.beginPath();
    context.translate(x, y);

    // Top-left
    radius = cornerRadius.tl;
    if (IsArcCorner(radius)) {
      radiusX = radius.x * scaleRX;
      radiusY = radius.y * scaleRY;
      if (IsConvexArc(radius)) {
        centerX = radiusX;
        centerY = radiusY;
        ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 270, false, iteration);
      } else {
        centerX = 0;
        centerY = 0;
        ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 0, true, iteration);
      }
      startX = 0;
      startY = radiusY;
    } else {
      context.lineTo(0, 0);
      startX = 0;
      startY = 0;
    }

    // Top-right
    radius = cornerRadius.tr;
    if (IsArcCorner(radius)) {
      radiusX = radius.x * scaleRX;
      radiusY = radius.y * scaleRY;
      if (IsConvexArc(radius)) {
        centerX = width - radiusX;
        centerY = radiusY;
        ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 360, false, iteration);
      } else {
        centerX = width;
        centerY = 0;
        ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 90, true, iteration);
      }
    } else {
      context.lineTo(width, 0);
    }

    // Bottom-right
    radius = cornerRadius.br;
    if (IsArcCorner(radius)) {
      radiusX = radius.x * scaleRX;
      radiusY = radius.y * scaleRY;
      if (IsConvexArc(radius)) {
        centerX = width - radiusX;
        centerY = height - radiusY;
        ArcTo(context, centerX, centerY, radiusX, radiusY, 0, 90, false, iteration);
      } else {
        centerX = width;
        centerY = height;
        ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 180, true, iteration);
      }
    } else {
      context.lineTo(width, height);
    }

    // Bottom-left
    radius = cornerRadius.bl;
    if (IsArcCorner(radius)) {
      radiusX = radius.x * scaleRX;
      radiusY = radius.y * scaleRY;
      if (IsConvexArc(radius)) {
        centerX = radiusX;
        centerY = height - radiusY;
        ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 180, false, iteration);
      } else {
        centerX = 0;
        centerY = height;
        ArcTo(context, centerX, centerY, radiusX, radiusY, 360, 270, true, iteration);
      }
    } else {
      context.lineTo(0, height);
    }
    context.lineTo(startX, startY);
    context.closePath();
    context.restore();
  };
  var IsConvexArc = function IsConvexArc(radius) {
    return !radius.hasOwnProperty('convex') ||
    // radius does not have convex property
    radius.convex;
  };
  var IsArcCorner = function IsArcCorner(radius) {
    return radius.x > 0 && radius.y > 0;
  };
  var ArcTo = function ArcTo(context, centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration) {
    // startAngle, endAngle: 0 ~ 360
    if (antiClockWise && endAngle > startAngle) {
      endAngle -= 360;
    } else if (!antiClockWise && endAngle < startAngle) {
      endAngle += 360;
    }
    startAngle = DegToRad$d(startAngle);
    endAngle = DegToRad$d(endAngle);
    if (iteration == null) {
      // undefined, or null
      context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle, antiClockWise);
    } else {
      iteration += 1;
      var x, y, angle;
      var step = (endAngle - startAngle) / iteration;
      for (var i = 0; i <= iteration; i++) {
        angle = startAngle + step * i;
        x = centerX + radiusX * Math.cos(angle);
        y = centerY + radiusY * Math.sin(angle);
        context.lineTo(x, y);
      }
    }
  };

  var DrawRoundRectangle = function DrawRoundRectangle(canvas, context, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient, iteration) {
    AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration);
    if (fillStyle != null) {
      if (fillColor2 != null) {
        var grd;
        if (isHorizontalGradient) {
          grd = context.createLinearGradient(0, 0, width, 0);
        } else {
          grd = context.createLinearGradient(0, 0, 0, height);
        }
        grd.addColorStop(0, fillStyle);
        grd.addColorStop(1, fillColor2);
        fillStyle = grd;
      }
      context.fillStyle = fillStyle;
      context.fill();
    }
    if (strokeStyle != null && lineWidth > 0) {
      context.strokeStyle = strokeStyle;
      context.lineWidth = lineWidth;
      context.stroke();
    }
  };

  var DrawRoundRectangleBackground = function DrawRoundRectangleBackground(canvasObject, color, strokeColor, strokeLineWidth, radius, color2, isHorizontalGradient, iteration) {
    if (color == null && strokeColor == null) {
      return;
    }
    var width = canvasObject.canvas.width,
      height = canvasObject.canvas.height;
    if (strokeColor == null) {
      strokeLineWidth = 0;
    }
    var x = strokeLineWidth / 2;
    width = Math.max(1, width - strokeLineWidth); // Min width is 1
    height = Math.max(1, height - strokeLineWidth); // Min height is 1
    DrawRoundRectangle(canvasObject.canvas, canvasObject.context, x, x, width, height, radius, color, strokeColor, strokeLineWidth, color2, isHorizontalGradient, iteration);
  };

  Phaser.Utils.Objects.GetValue;

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  var Utils = Phaser.Renderer.WebGL.Utils;

  /**
   * Renders this Game Object with the WebGL Renderer to the given Camera.
   * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
   * This method should not be called directly. It is a utility function of the Render module.
   *
   * @method Phaser.GameObjects.Text#renderWebGL
   * @since 3.0.0
   * @private
   *
   * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.
   * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.
   * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
   */
  var WebGLRenderer$1 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
    if (src.width === 0 || src.height === 0) {
      return;
    }
    camera.addToRenderList(src);
    var frame = src.frame;
    var width = frame.width;
    var height = frame.height;
    var getTint = Utils.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
    renderer.pipelines.preBatch(src);
    pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
    renderer.pipelines.postBatch(src);
  };

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  /**
   * Renders this Game Object with the Canvas Renderer to the given Camera.
   * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
   * This method should not be called directly. It is a utility function of the Render module.
   *
   * @method Phaser.GameObjects.Text#renderCanvas
   * @since 3.0.0
   * @private
   *
   * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.
   * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.
   * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
   */
  var CanvasRenderer$1 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
    if (src.width === 0 || src.height === 0) {
      return;
    }
    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };

  var Render$1 = {
    renderWebGL: WebGLRenderer$1,
    renderCanvas: CanvasRenderer$1
  };

  var CanvasPool$3 = Phaser.Display.Canvas.CanvasPool;
  var MeasureTextMargins = function MeasureTextMargins(textStyle, testString, out) {
    if (out === undefined) {
      out = {};
    }
    var canvas = CanvasPool$3.create(this);
    var context = canvas.getContext('2d', {
      willReadFrequently: true
    });
    textStyle.syncFont(canvas, context);
    var metrics = context.measureText(testString);
    var width = Math.ceil(metrics.width * textStyle.baselineX);
    var baseline = width;
    var height = 2 * baseline;
    baseline = baseline * textStyle.baselineY | 0;
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);
    context.font = textStyle._font;
    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(textStyle.testString, 0, baseline);
    out.left = 0;
    if (width === 0 || height === 0 || !context.getImageData(0, 0, width, height)) {
      CanvasPool$3.remove(canvas);
      return out;
    }
    var imagedata = context.getImageData(0, 0, width, height).data;
    var stop = false;
    for (var x = 0; x < width; x++) {
      for (var y = 0; y < height; y++) {
        var idx = (y * width + x) * 4;
        if (imagedata[idx] !== 255) {
          out.left = x;
          stop = true;
          break;
        }
      }
      if (stop) {
        break;
      }
    }
    CanvasPool$3.remove(canvas);
    return out;
  };

  CheckP3Version();
  var GameObject$2 = Phaser.GameObjects.GameObject;
  var TextBase = /*#__PURE__*/function (_GameObject) {
    _inherits(TextBase, _GameObject);
    function TextBase() {
      _classCallCheck(this, TextBase);
      return _callSuper(this, TextBase, arguments);
    }
    _createClass(TextBase, [{
      key: "setStyle",
      value: function setStyle(style) {
        return this.style.setStyle(style);
      }
    }, {
      key: "setFont",
      value: function setFont(font) {
        return this.style.setFont(font);
      }
    }, {
      key: "setFontFamily",
      value: function setFontFamily(family) {
        return this.style.setFontFamily(family);
      }
    }, {
      key: "setFontSize",
      value: function setFontSize(size) {
        return this.style.setFontSize(size);
      }
    }, {
      key: "setFontStyle",
      value: function setFontStyle(style) {
        return this.style.setFontStyle(style);
      }
    }, {
      key: "setTestString",
      value: function setTestString(string) {
        return this.style.setTestString(string);
      }
    }, {
      key: "setFixedSize",
      value: function setFixedSize(width, height) {
        return this.style.setFixedSize(width, height);
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color, color2, isHorizontalGradient) {
        return this.style.setBackgroundColor(color, color2, isHorizontalGradient);
      }
    }, {
      key: "setBackgroundStrokeColor",
      value: function setBackgroundStrokeColor(color, lineWidth) {
        return this.style.setBackgroundStrokeColor(color, lineWidth);
      }
    }, {
      key: "setBackgroundCornerRadius",
      value: function setBackgroundCornerRadius(radius, iteration) {
        return this.style.setBackgroundCornerRadius(radius, iteration);
      }
    }, {
      key: "setFill",
      value: function setFill(color) {
        return this.style.setFill(color);
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        return this.style.setColor(color);
      }
    }, {
      key: "setStroke",
      value: function setStroke(color, thickness) {
        return this.style.setStroke(color, thickness);
      }
    }, {
      key: "setShadow",
      value: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
      }
    }, {
      key: "setShadowOffset",
      value: function setShadowOffset(x, y) {
        return this.style.setShadowOffset(x, y);
      }
    }, {
      key: "setShadowColor",
      value: function setShadowColor(color) {
        return this.style.setShadowColor(color);
      }
    }, {
      key: "setShadowBlur",
      value: function setShadowBlur(blur) {
        return this.style.setShadowBlur(blur);
      }
    }, {
      key: "setShadowStroke",
      value: function setShadowStroke(enabled) {
        return this.style.setShadowStroke(enabled);
      }
    }, {
      key: "setShadowFill",
      value: function setShadowFill(enabled) {
        return this.style.setShadowFill(enabled);
      }
    }, {
      key: "setWrapMode",
      value: function setWrapMode(mode) {
        return this.style.setWrapMode(mode);
      }
    }, {
      key: "setWrapWidth",
      value: function setWrapWidth(width) {
        return this.style.setWrapWidth(width);
      }

      // Align with built-in text game object
    }, {
      key: "setWordWrapWidth",
      value: function setWordWrapWidth(width) {
        return this.style.setWrapWidth(width);
      }
    }, {
      key: "setAlign",
      value: function setAlign(align) {
        return this.style.setHAlign(align);
      }
    }, {
      key: "setHAlign",
      value: function setHAlign(align) {
        return this.style.setHAlign(align);
      }
    }, {
      key: "setVAlign",
      value: function setVAlign(align) {
        return this.style.setVAlign(align);
      }
    }, {
      key: "setLineSpacing",
      value: function setLineSpacing(value) {
        this.lineSpacing = value;
        this.updateText(false);
        return this;
      }
    }, {
      key: "setXOffset",
      value: function setXOffset(value) {
        return this.style.setXOffset(value);
      }
    }, {
      key: "setMaxLines",
      value: function setMaxLines(max) {
        return this.style.setMaxLines(max);
      }
    }, {
      key: "setResolution",
      value: function setResolution(value) {
        return this.style.setResolution(value);
      }
    }, {
      key: "getTextMetrics",
      value: function getTextMetrics() {
        return this.style.getTextMetrics();
      }
    }, {
      key: "setTextMetrics",
      value: function setTextMetrics(metrics, font) {
        return this.style.setTextMetrics(metrics, font);
      }
    }, {
      key: "measureTextMargins",
      value: function measureTextMargins(testString, out) {
        return MeasureTextMargins(this.style, testString, out);
      }
    }]);
    return TextBase;
  }(GameObject$2);
  var Components$2 = Phaser.GameObjects.Components;
  Phaser.Class.mixin(TextBase, [Components$2.Alpha, Components$2.BlendMode, Components$2.ComputedSize, Components$2.Crop, Components$2.Depth, Components$2.Flip, Components$2.GetBounds, Components$2.Mask, Components$2.Origin, Components$2.Pipeline, Components$2.PostPipeline, Components$2.ScrollFactor, Components$2.Tint, Components$2.Transform, Components$2.Visible, Render$1]);

  //  Key: [ Object Key, Default Value, postCallback ]

  var PropertyMap = {
    // background
    backgroundColor: ['backgroundColor', null, GetStyle],
    backgroundColor2: ['backgroundColor2', null, GetStyle],
    backgroundHorizontalGradient: ['backgroundHorizontalGradient', true, null],
    backgroundStrokeColor: ['backgroundStrokeColor', null, GetStyle],
    backgroundStrokeLineWidth: ['backgroundStrokeLineWidth', 2, null],
    backgroundCornerRadius: ['backgroundCornerRadius', 0, null],
    backgroundCornerIteration: ['backgroundCornerIteration', null, null],
    // font
    fontFamily: ['fontFamily', 'Courier', null],
    fontSize: ['fontSize', '16px', null],
    fontStyle: ['fontStyle', '', null],
    color: ['color', '#fff', GetStyle],
    stroke: ['stroke', '#fff', GetStyle],
    strokeThickness: ['strokeThickness', 0, null],
    shadowOffsetX: ['shadow.offsetX', 0, null],
    shadowOffsetY: ['shadow.offsetY', 0, null],
    shadowColor: ['shadow.color', '#000', GetStyle],
    shadowBlur: ['shadow.blur', 0, null],
    shadowStroke: ['shadow.stroke', false, null],
    shadowFill: ['shadow.fill', false, null],
    // underline
    underlineColor: ['underline.color', '#000', GetStyle],
    underlineThickness: ['underline.thickness', 0, null],
    underlineOffset: ['underline.offset', 0, null],
    // strikethrough
    strikethroughColor: ['strikethrough.color', '#000', GetStyle],
    strikethroughThickness: ['strikethrough.thickness', 0, null],
    strikethroughOffset: ['strikethrough.offset', 0, null],
    // align
    halign: ['halign', 'left', null],
    valign: ['valign', 'top', null],
    // size
    maxLines: ['maxLines', 0, null],
    fixedWidth: ['fixedWidth', 0, null],
    fixedHeight: ['fixedHeight', 0, null],
    resolution: ['resolution', 0, null],
    lineSpacing: ['lineSpacing', 0, null],
    xOffset: ['xOffset', 0, null],
    rtl: ['rtl', false, null],
    testString: ['testString', '|Mqgy', null],
    baselineX: ['baselineX', 1.2, null],
    baselineY: ['baselineY', 1.4, null],
    // wrap
    wrapMode: ['wrap.mode', 0, null],
    wrapWidth: ['wrap.width', 0, null],
    wrapCallback: ['wrap.callback', null],
    wrapCallbackScope: ['wrap.callbackScope', null]
  };

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  var CanvasPool$2 = Phaser.Display.Canvas.CanvasPool;

  /**
   * Calculates the ascent, descent and fontSize of a given font style.
   *
   * @function Phaser.GameObjects.MeasureText
   * @since 3.0.0
   *
   * @param {Phaser.GameObjects.Text.TextStyle} textStyle - The TextStyle object to measure.
   *
   * @return {object} An object containing the ascent, descent and fontSize of the TextStyle.
   */
  var MeasureText = function MeasureText(textStyle) {
    // @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
    var canvas = CanvasPool$2.create(this);

    // @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
    var context = canvas.getContext('2d', {
      willReadFrequently: true
    });
    textStyle.syncFont(canvas, context);
    var metrics = context.measureText(textStyle.testString);
    if ('actualBoundingBoxAscent' in metrics) {
      var ascent = metrics.actualBoundingBoxAscent;
      var descent = metrics.actualBoundingBoxDescent;
      var output = {
        ascent: ascent,
        descent: descent,
        fontSize: ascent + descent
      };
      CanvasPool$2.remove(canvas);
      return output;
    }
    var width = Math.ceil(metrics.width * textStyle.baselineX);
    var baseline = width;
    var height = 2 * baseline;
    baseline = baseline * textStyle.baselineY | 0;
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);
    context.font = textStyle._font;
    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(textStyle.testString, 0, baseline);
    var output = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    if (!context.getImageData(0, 0, width, height)) {
      output.ascent = baseline;
      output.descent = baseline + 6;
      output.fontSize = output.ascent + output.descent;
      CanvasPool$2.remove(canvas);
      return output;
    }
    var imagedata = context.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i;
    var j;
    var idx = 0;
    var stop = false;

    // ascent. scan from top to bottom until we find a non red pixel
    for (i = 0; i < baseline; i++) {
      for (j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    output.ascent = baseline - i;
    idx = pixels - line;
    stop = false;

    // descent. scan from bottom to top until we find a non red pixel
    for (i = height; i > baseline; i--) {
      for (j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    output.descent = i - baseline;
    output.fontSize = output.ascent + output.descent;
    CanvasPool$2.remove(canvas);
    return output;
  };

  var CONST = {
    // new line mode
    NO_NEWLINE: 0,
    RAW_NEWLINE: 1,
    WRAPPED_NEWLINE: 2,
    // wrap mode
    NO_WRAP: 0,
    WORD_WRAP: 1,
    CHAR_WRAP: 2,
    MIX_WRAP: 3,
    // split lines
    SPLITREGEXP: /(?:\r\n|\r|\n)/
  };

  var GetAdvancedValue$3 = Phaser.Utils.Objects.GetAdvancedValue;
  var GetValue$2$ = Phaser.Utils.Objects.GetValue;
  var TextStyle$1 = /*#__PURE__*/function () {
    function TextStyle(text, style, propertyMap) {
      _classCallCheck(this, TextStyle);
      this.parent = text;
      // parent.updateText()
      // parent.width, parent.height

      if (propertyMap === undefined) {
        propertyMap = PropertyMap;
      }
      this.propertyMap = propertyMap;
      this.backgroundColor;
      this.backgroundColor2;
      this.backgroundHorizontalGradient;
      this.backgroundStrokeColor;
      this.backgroundStrokeLineWidth;
      this.backgroundCornerRadius;
      this.backgroundCornerIteration;
      this.fontFamily;
      this.fontSize;
      this.fontStyle;
      this.color;
      this.stroke;
      this.strokeThickness;
      this.shadowOffsetX;
      this.shadowOffsetY;
      this.shadowColor;
      this.shadowBlur;
      this.shadowStroke;
      this.shadowFill;
      this.underlineColor;
      this.underlineThickness;
      this.underlineOffset;
      this.strikethroughColor;
      this.strikethroughThickness;
      this.strikethroughOffset;
      this.halign;
      this.valign;
      this.maxLines;
      this.fixedWidth;
      this.fixedHeight;
      this.resolution;
      this.xOffset;
      this.rtl;
      this.testString;
      this.baselineX;
      this.baselineY;
      this.wrapMode;
      this.wrapWidth;
      this.wrapCallback;
      this.wrapCallbackScope;
      this._font;

      //  Set to defaults + user style
      this.setStyle(style, false, true);
    }
    _createClass(TextStyle, [{
      key: "isWrapFitMode",
      get: function get() {
        return this.fixedWidth > 0 && this.wrapMode !== CONST.NO_WRAP && this.wrapWidth === 0;
      }
    }, {
      key: "setStyle",
      value: function setStyle(style, updateText, setDefaults) {
        if (updateText === undefined) {
          updateText = true;
        }
        if (setDefaults === undefined) {
          setDefaults = false;
        }

        // Compatible with Text game object
        if (style && style.hasOwnProperty('wordWrap')) {
          var wordWrap = style.wordWrap;
          if (wordWrap.hasOwnProperty('width')) {
            style.wrap = {
              mode: 'word',
              width: wordWrap.width
            };
          }
        }
        if (style && style.hasOwnProperty('wrap')) {
          var wrap = style.wrap;
          if (wrap.hasOwnProperty('mode')) {
            var mode = wrap.mode;
            if (typeof mode === 'string') {
              wrap.mode = WRAPMODE[mode];
            }
          } else {
            if (wrap.hasOwnProperty('width')) {
              wrap.mode = 1;
            }
          }
        }

        // default halign of RTL is 'right'
        if (style && style.rtl && setDefaults && !style.hasOwnProperty('halign')) {
          style.halign = 'right';
        }

        //  Avoid type mutation
        if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {
          style.fontSize = style.fontSize.toString() + 'px';
        }
        var propertyMap = this.propertyMap;
        for (var key in propertyMap) {
          var prop = propertyMap[key]; // [ Object Key, Default Value, preCallback ]
          var objKey = prop[0];
          var defaultValue = setDefaults ? prop[1] : this[key];
          var postCallback = prop[2];
          if (key === 'wrapCallback' || key === 'wrapCallbackScope') {
            // Callback & scope should be set without processing the values
            this[key] = GetValue$2$(style, objKey, defaultValue);
          } else {
            var value = GetAdvancedValue$3(style, objKey, defaultValue);
            if (postCallback) {
              value = postCallback(value);
            }
            this[key] = value;
          }
        }

        //  Allow for 'font' override
        var font = GetValue$2$(style, 'font', null);
        if (font === null) {
          this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;
        } else {
          this._font = font;
        }

        //  Allow for 'fill' to be used in place of 'color'
        var fill = GetValue$2$(style, 'fill', null);
        if (fill !== null) {
          this.color = GetStyle(fill);
        }
        var metrics = GetValue$2$(style, 'metrics', false);

        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
        //  Doing this is reset if you then change the font of this TextStyle after creation
        if (metrics) {
          this.metrics = {
            ascent: GetValue$2$(metrics, 'ascent', 0),
            descent: GetValue$2$(metrics, 'descent', 0),
            fontSize: GetValue$2$(metrics, 'fontSize', 0)
          };
        } else if (updateText || !this.metrics) {
          this.metrics = MeasureText(this);
        }
        if (updateText) {
          return this.parent.updateText();
        } else {
          return this.parent;
        }
      }
    }, {
      key: "syncFont",
      value: function syncFont(canvas, context) {
        context.font = this._font;
      }
    }, {
      key: "syncStyle",
      value: function syncStyle(canvas, context) {
        context.textBaseline = 'alphabetic';
        context.fillStyle = this.color;
        context.strokeStyle = this.stroke;
        context.lineWidth = this.strokeThickness;
        context.lineCap = 'round';
        context.lineJoin = 'round';
      }
    }, {
      key: "syncShadow",
      value: function syncShadow(context, enabled) {
        if (enabled) {
          context.shadowOffsetX = this.shadowOffsetX;
          context.shadowOffsetY = this.shadowOffsetY;
          context.shadowColor = this.shadowColor;
          context.shadowBlur = this.shadowBlur;
        } else {
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
          context.shadowColor = 0;
          context.shadowBlur = 0;
        }
      }
    }, {
      key: "update",
      value: function update(recalculateMetrics) {
        if (recalculateMetrics) {
          this._font = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim();
          this.metrics = MeasureText(this);
        }
        return this.parent.updateText(recalculateMetrics);
      }
    }, {
      key: "buildFont",
      value: function buildFont() {
        var newFont = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim();
        if (newFont !== this._font) {
          this._font = newFont;
          //this.metrics = MeasureText(this);
        }
        return this;
      }
    }, {
      key: "setFont",
      value: function setFont(font) {
        if (typeof font === 'string') {
          this.fontFamily = font;
          this.fontSize = '';
          this.fontStyle = '';
        } else {
          this.fontFamily = GetValue$2$(font, 'fontFamily', 'Courier');
          this.fontSize = GetValue$2$(font, 'fontSize', '16px');
          this.fontStyle = GetValue$2$(font, 'fontStyle', '');
        }
        return this.update(true);
      }
    }, {
      key: "setFontFamily",
      value: function setFontFamily(family) {
        this.fontFamily = family;
        return this.update(true);
      }
    }, {
      key: "setFontStyle",
      value: function setFontStyle(style) {
        this.fontStyle = style;
        return this.update(true);
      }
    }, {
      key: "setFontSize",
      value: function setFontSize(size) {
        if (typeof size === 'number') {
          size = size.toString() + 'px';
        }
        this.fontSize = size;
        return this.update(true);
      }
    }, {
      key: "setTestString",
      value: function setTestString(string) {
        this.testString = string;
        return this.update(true);
      }
    }, {
      key: "setFixedSize",
      value: function setFixedSize(width, height) {
        this.fixedWidth = width;
        this.fixedHeight = height;
        if (width) {
          this.parent.width = width;
        }
        if (height) {
          this.parent.height = height;
        }
        return this.update(this.isWrapFitMode);
      }
    }, {
      key: "setResolution",
      value: function setResolution(value) {
        this.resolution = value;
        return this.update(false);
      }
    }, {
      key: "setXOffset",
      value: function setXOffset(value) {
        this.xOffset = value;
        return this.update(false);
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
          isHorizontalGradient = true;
        }
        this.backgroundColor = GetStyle(color, this.parent.canvas, this.parent.context);
        this.backgroundColor2 = GetStyle(color2, this.parent.canvas, this.parent.context);
        this.backgroundHorizontalGradient = isHorizontalGradient;
        return this.update(false);
      }
    }, {
      key: "setBackgroundStrokeColor",
      value: function setBackgroundStrokeColor(color, lineWidth) {
        this.backgroundStrokeColor = GetStyle(color, this.parent.canvas, this.parent.context);
        this.backgroundStrokeLineWidth = lineWidth;
        return this.update(false);
      }
    }, {
      key: "setBackgroundCornerRadius",
      value: function setBackgroundCornerRadius(radius, iteration) {
        this.backgroundCornerRadius = radius;
        this.backgroundCornerIteration = iteration;
        return this.update(false);
      }
    }, {
      key: "setFill",
      value: function setFill(color) {
        this.color = GetStyle(color, this.parent.canvas, this.parent.context);
        return this.update(false);
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color = GetStyle(color, this.parent.canvas, this.parent.context);
        return this.update(false);
      }
    }, {
      key: "setStroke",
      value: function setStroke(color, thickness) {
        if (color === undefined) {
          //  Reset the stroke to zero (disabling it)
          this.strokeThickness = 0;
        } else {
          if (thickness === undefined) {
            thickness = this.strokeThickness;
          }
          this.stroke = GetStyle(color, this.parent.canvas, this.parent.context);
          this.strokeThickness = thickness;
        }
        return this.update(true);
      }
    }, {
      key: "setShadow",
      value: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (color === undefined) {
          color = '#000';
        }
        if (blur === undefined) {
          blur = 0;
        }
        if (shadowStroke === undefined) {
          shadowStroke = false;
        }
        if (shadowFill === undefined) {
          shadowFill = true;
        }
        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        this.shadowColor = GetStyle(color, this.parent.canvas, this.parent.context);
        this.shadowBlur = blur;
        this.shadowStroke = shadowStroke;
        this.shadowFill = shadowFill;
        return this.update(false);
      }
    }, {
      key: "setShadowOffset",
      value: function setShadowOffset(x, y) {
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = x;
        }
        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        return this.update(false);
      }
    }, {
      key: "setShadowColor",
      value: function setShadowColor(color) {
        if (color === undefined) {
          color = '#000';
        }
        this.shadowColor = GetStyle(color, this.parent.canvas, this.parent.context);
        return this.update(false);
      }
    }, {
      key: "setShadowBlur",
      value: function setShadowBlur(blur) {
        if (blur === undefined) {
          blur = 0;
        }
        this.shadowBlur = blur;
        return this.update(false);
      }
    }, {
      key: "setShadowStroke",
      value: function setShadowStroke(enabled) {
        this.shadowStroke = enabled;
        return this.update(false);
      }
    }, {
      key: "setShadowFill",
      value: function setShadowFill(enabled) {
        this.shadowFill = enabled;
        return this.update(false);
      }
    }, {
      key: "setUnderline",
      value: function setUnderline(color, thickness, offset) {
        if (color === undefined) {
          color = '#000';
        }
        if (thickness === undefined) {
          thickness = 0;
        }
        if (offset === undefined) {
          offset = 0;
        }
        this.underlineColor = GetStyle(color, this.parent.canvas, this.parent.context);
        this.underlineThickness = thickness;
        this.underlineOffset = offset;
        return this.update(false);
      }
    }, {
      key: "setUnderlineColor",
      value: function setUnderlineColor(color) {
        if (color === undefined) {
          color = '#000';
        }
        this.underlineColor = GetStyle(color, this.parent.canvas, this.parent.context);
        return this.update(false);
      }
    }, {
      key: "setUnderlineThickness",
      value: function setUnderlineThickness(thickness) {
        if (thickness === undefined) {
          thickness = 0;
        }
        this.underlineThickness = thickness;
        return this.update(false);
      }
    }, {
      key: "setUnderlineOffset",
      value: function setUnderlineOffset(offset) {
        if (offset === undefined) {
          offset = 0;
        }
        this.underlineOffset = offset;
        return this.update(false);
      }
    }, {
      key: "setStrikethrough",
      value: function setStrikethrough(color, thickness, offset) {
        if (color === undefined) {
          color = '#000';
        }
        if (thickness === undefined) {
          thickness = 0;
        }
        if (offset === undefined) {
          offset = 0;
        }
        this.strikethroughColor = GetStyle(color, this.parent.canvas, this.parent.context);
        this.strikethroughThickness = thickness;
        this.strikethroughOffset = offset;
        return this.update(false);
      }
    }, {
      key: "setStrikethroughColor",
      value: function setStrikethroughColor(color) {
        if (color === undefined) {
          color = '#000';
        }
        this.strikethroughColor = GetStyle(color, this.parent.canvas, this.parent.context);
        return this.update(false);
      }
    }, {
      key: "setStrikethroughThickness",
      value: function setStrikethroughThickness(thickness) {
        if (thickness === undefined) {
          thickness = 0;
        }
        this.strikethroughThickness = thickness;
        return this.update(false);
      }
    }, {
      key: "setStrikethroughOffset",
      value: function setStrikethroughOffset(offset) {
        if (offset === undefined) {
          offset = 0;
        }
        this.strikethroughOffset = offset;
        return this.update(false);
      }
    }, {
      key: "setWrapMode",
      value: function setWrapMode(mode) {
        if (typeof mode === 'string') {
          mode = WRAPMODE[mode.toLowerCase()] || 0;
        }
        this.wrapMode = mode;
        return this.update(true);
      }
    }, {
      key: "setWrapWidth",
      value: function setWrapWidth(width) {
        this.wrapWidth = width;
        return this.update(false);
      }
    }, {
      key: "setAlign",
      value: function setAlign(halign, valign) {
        if (halign === undefined) {
          halign = 'left';
        }
        if (valign === undefined) {
          valign = 'top';
        }
        this.halign = halign;
        this.valign = valign;
        return this.update(false);
      }
    }, {
      key: "setHAlign",
      value: function setHAlign(halign) {
        if (halign === undefined) {
          halign = 'left';
        }
        this.halign = halign;
        return this.update(false);
      }
    }, {
      key: "setVAlign",
      value: function setVAlign(valign) {
        if (valign === undefined) {
          valign = 'top';
        }
        this.valign = valign;
        return this.update(false);
      }
    }, {
      key: "setMaxLines",
      value: function setMaxLines(max) {
        if (max === undefined) {
          max = 0;
        }
        this.maxLines = max;
        return this.update(false);
      }
    }, {
      key: "getTextMetrics",
      value: function getTextMetrics() {
        var metrics = this.metrics;
        return {
          ascent: metrics.ascent,
          descent: metrics.descent,
          fontSize: metrics.fontSize
        };
      }
    }, {
      key: "setTextMetrics",
      value: function setTextMetrics(metrics, font) {
        this.metrics.ascent = metrics.ascent;
        this.metrics.descent = metrics.descent;
        this.metrics.fontSize = metrics.fontSize;
        if (font) {
          if (typeof font === 'string') {
            this.fontFamily = font;
            this.fontSize = '';
            this.fontStyle = '';
          } else {
            this.fontFamily = GetValue$2$(font, 'fontFamily', this.fontFamily);
            this.fontSize = GetValue$2$(font, 'fontSize', this.fontSize);
            this.fontStyle = GetValue$2$(font, 'fontStyle', this.fontStyle);
          }
        }
        return this.parent.updateText(true);
      }
    }, {
      key: "lineHeight",
      get: function get() {
        return this.metrics.fontSize + this.strokeThickness + this.parent.lineSpacing;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var output = {};
        var propertyMap = this.propertyMap;
        for (var key in propertyMap) {
          output[key] = this[key];
        }
        output.metrics = this.getTextMetrics();
        return output;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.parent = undefined;
      }
    }]);
    return TextStyle;
  }();
  var WRAPMODE = {
    none: CONST.NO_WRAP,
    word: CONST.WORD_WRAP,
    "char": CONST.CHAR_WRAP,
    character: CONST.CHAR_WRAP,
    mix: CONST.MIX_WRAP
  };

  var DrawMethods = {
    draw: function draw(startX, startY, textWidth, textHeight) {
      var penManager = this.penManager;
      this.hitAreaManager.clear();
      var context = this.context;
      context.save();
      var defaultStyle = this.defaultStyle;
      this.clear();
      DrawRoundRectangleBackground(this, defaultStyle.backgroundColor, defaultStyle.backgroundStrokeColor, defaultStyle.backgroundStrokeLineWidth, defaultStyle.backgroundCornerRadius, defaultStyle.backgroundColor2, defaultStyle.backgroundHorizontalGradient, defaultStyle.backgroundCornerIteration);

      // draw lines
      startX += this.startXOffset;
      startY += this.startYOffset;
      var defaultHalign = defaultStyle.halign,
        valign = defaultStyle.valign;
      var lineWidth,
        lineHeight = defaultStyle.lineHeight;
      var lines = penManager.lines;
      var totalLinesNum = lines.length,
        maxLines = defaultStyle.maxLines;
      var drawLinesNum, drawLineStartIdx, drawLineEndIdx;
      if (maxLines > 0 && totalLinesNum > maxLines) {
        drawLinesNum = maxLines;
        if (valign === 'center') {
          // center
          drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
        } else if (valign === 'bottom') {
          // bottom
          drawLineStartIdx = totalLinesNum - drawLinesNum;
        } else {
          drawLineStartIdx = 0;
        }
      } else {
        drawLinesNum = totalLinesNum;
        drawLineStartIdx = 0;
      }
      drawLineEndIdx = drawLineStartIdx + drawLinesNum;
      var offsetX, offsetY;
      var rtl = this.rtl,
        rtlOffset = rtl ? this.parent.width : undefined;
      if (valign === 'center') {
        // center
        offsetY = Math.max((textHeight - drawLinesNum * lineHeight) / 2, 0);
      } else if (valign === 'bottom') {
        // bottom
        offsetY = Math.max(textHeight - drawLinesNum * lineHeight - 2, 0);
      } else {
        offsetY = 0;
      }
      offsetY += startY;
      for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
        lineWidth = penManager.getLineWidth(lineIdx);
        if (lineWidth === 0) {
          continue;
        }
        var pens = lines[lineIdx],
          penCount = pens.length;
        var halign = defaultHalign;
        // Seek if there has algin tag
        for (var penIdx = 0; penIdx < penCount; penIdx++) {
          var penAlign = pens[penIdx].prop.align;
          if (penAlign !== undefined) {
            halign = penAlign;
            break;
          }
        }
        if (halign === 'center') {
          // center
          offsetX = (textWidth - lineWidth) / 2;
        } else if (halign === 'right') {
          // right
          offsetX = !rtl ? textWidth - lineWidth : 0;
        } else {
          offsetX = !rtl ? 0 : textWidth - lineWidth;
        }
        offsetX += startX;
        for (var penIdx = 0; penIdx < penCount; penIdx++) {
          this.drawPen(pens[penIdx], offsetX, offsetY, rtlOffset);
        }
      }
      context.restore();
    },
    drawPen: function drawPen(pen, offsetX, offsetY, rtlOffset) {
      offsetX += pen.x;
      offsetY += pen.y + (pen.prop.y || 0);
      if (rtlOffset !== undefined) {
        offsetX = rtlOffset - offsetX;
      }
      var canvas = this.canvas;
      var context = this.context;
      context.save();
      var curStyle = this.parser.propToContextStyle(this.defaultStyle, pen.prop);
      curStyle.buildFont();
      curStyle.syncFont(canvas, context);
      curStyle.syncStyle(canvas, context);

      // Underline
      if (curStyle.underlineThickness > 0 && pen.width > 0) {
        var lineOffsetY = offsetY + curStyle.underlineOffset - curStyle.underlineThickness / 2;
        this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.underlineThickness, curStyle.underlineColor, curStyle);
      }

      // Text
      if (pen.isTextPen) {
        this.drawText(offsetX, offsetY, pen.text, curStyle);
      }

      // Image
      if (pen.isImagePen) {
        this.drawImage(offsetX, offsetY, pen.prop.img, pen.prop.color, curStyle);
      }

      // Strikethrough
      if (curStyle.strikethroughThickness > 0 && pen.width > 0) {
        var lineOffsetY = offsetY + curStyle.strikethroughOffset - curStyle.strikethroughThickness / 2;
        this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.strikethroughThickness, curStyle.strikethroughColor, curStyle);
      }
      context.restore();
      if (pen.hasAreaMarker && pen.width > 0) {
        var data;
        var areaKey = pen.prop.area;
        if (areaKey) {
          data = {
            key: areaKey
          };
        } else {
          var url = pen.prop.url;
          data = {
            key: "url:".concat(url),
            url: url
          };
        }
        this.hitAreaManager.add(offsetX,
        // x
        offsetY - this.startYOffset,
        // y
        pen.width,
        // width
        this.defaultStyle.lineHeight,
        // height
        data);
      }
    },
    clear: function clear() {
      var canvas = this.canvas;
      this.context.clearRect(0, 0, canvas.width, canvas.height);
    },
    drawLine: function drawLine(x, y, width, height, color, style) {
      if (this.autoRound) {
        x = Math.round(x);
        y = Math.round(y);
      }
      var context = this.context;
      style.syncShadow(context, style.shadowStroke);
      var savedLineCap = context.lineCap;
      context.lineCap = 'butt';
      context.strokeStyle = color;
      context.lineWidth = height;
      context.beginPath();
      context.moveTo(x, y);
      context.lineTo(x + width, y);
      context.stroke();
      context.lineCap = savedLineCap;
    },
    drawText: function drawText(x, y, text, style) {
      if (this.autoRound) {
        x = Math.round(x);
        y = Math.round(y);
      }
      var context = this.context;
      if (style.stroke && style.stroke !== 'none' && style.strokeThickness > 0) {
        style.syncShadow(context, style.shadowStroke);
        context.strokeText(text, x, y);
      }
      if (style.color && style.color !== 'none') {
        style.syncShadow(context, style.shadowFill);
        context.fillText(text, x, y);
      }
    },
    drawImage: function drawImage(x, y, imgKey, color, style) {
      y -= this.startYOffset;
      this.parent.imageManager.draw(imgKey, this.context, x, y, color, this.autoRound);
    }
  };

  var GetValue$2_ = Phaser.Utils.Objects.GetValue;
  var NO_NEWLINE$3 = CONST.NO_NEWLINE;
  var RAW_NEWLINE$1 = CONST.RAW_NEWLINE;
  var Pen = /*#__PURE__*/function () {
    function Pen(config) {
      _classCallCheck(this, Pen);
      this.prop = {};
      this.resetFromJSON(config);
    }
    _createClass(Pen, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        // (txt, x, y, width, prop, newLineMode, startIndex)
        this.text = GetValue$2_(o, 'text', '');
        this.x = GetValue$2_(o, 'x', 0);
        this.y = GetValue$2_(o, 'y', 0);
        this.width = GetValue$2_(o, 'width', 0);
        var prop = GetValue$2_(o, 'prop', null);
        if (prop === null) {
          prop = {};
        }
        this.prop = prop;
        this.newLineMode = GetValue$2_(o, 'newLineMode', 0);
        this.startIndex = GetValue$2_(o, 'startIndex', 0);
      }
    }, {
      key: "plainText",
      get: function get() {
        var txt = this.text;
        if (this.newLineMode === RAW_NEWLINE$1) {
          txt += "\n";
        }
        return txt;
      }
    }, {
      key: "wrapText",
      get: function get() {
        var txt = this.text;
        if (this.newLineMode !== NO_NEWLINE$3) {
          txt += "\n";
        }
        return txt;
      }
    }, {
      key: "rawTextLength",
      get: function get() {
        var len = this.text.length;
        if (this.newLineMode === RAW_NEWLINE$1) {
          len += 1;
        }
        return len;
      }
    }, {
      key: "endIndex",
      get: function get() {
        return this.startIndex + this.rawTextLength;
      }
    }, {
      key: "lastX",
      get: function get() {
        return this.x + this.width;
      }
    }, {
      key: "isTextPen",
      get: function get() {
        return this.text !== '';
      }
    }, {
      key: "isImagePen",
      get: function get() {
        return !!this.prop.img;
      }
    }, {
      key: "hasAreaMarker",
      get: function get() {
        return !!this.prop.area || !!this.prop.url;
      }
    }]);
    return Pen;
  }();

  var GetFastValue$2 = Phaser.Utils.Objects.GetFastValue;
  var NO_NEWLINE$2 = CONST.NO_NEWLINE;
  var WRAPPED_NEWLINE$1 = CONST.WRAPPED_NEWLINE;
  var PenManager = /*#__PURE__*/function () {
    function PenManager(config) {
      _classCallCheck(this, PenManager);
      this.pens = []; // all pens
      this.lines = []; // pens in lines [ [],[],[],.. ]
      this.maxLinesWidth = undefined;
      this.pensPool = config.pensPool; // Required
      this.linesPool = config.linesPool; // Required
      this.tagToText = GetFastValue$2(config, 'tagToText', NOOP);
      this.tagToTextScope = GetFastValue$2(config, 'tagToTextScope', undefined);
    }
    _createClass(PenManager, [{
      key: "destroy",
      value: function destroy() {
        this.clear();
        this.tagToText = undefined;
        this.tagToTextScope = undefined;
      }
    }, {
      key: "clear",
      value: function clear() {
        for (var i = 0, len = this.lines.length; i < len; i++) {
          this.lines[i].length = 0;
        }
        this.pensPool.pushMultiple(this.pens);
        this.linesPool.pushMultiple(this.lines);
        this.maxLinesWidth = undefined;
      }
    }, {
      key: "addTextPen",
      value: function addTextPen(text, x, y, width, prop, newLineMode) {
        var pen = this.pensPool.pop();
        if (pen == null) {
          pen = new Pen();
        }
        PEN_CONFIG.text = text;
        PEN_CONFIG.x = x;
        PEN_CONFIG.y = y;
        PEN_CONFIG.width = width;
        PEN_CONFIG.prop = prop;
        PEN_CONFIG.newLineMode = newLineMode;
        pen.resetFromJSON(PEN_CONFIG);
        this.addPen(pen);
        return this;
      }
    }, {
      key: "addImagePen",
      value: function addImagePen(x, y, width, prop) {
        this.addTextPen('', x, y, width, prop, NO_NEWLINE$2);
        return this;
      }
    }, {
      key: "addNewLinePen",
      value: function addNewLinePen() {
        var previousPen = this.lastPen;
        var x = previousPen ? previousPen.lastX : 0;
        var y = previousPen ? previousPen.y : 0;
        var prop = previousPen ? Clone$2(previousPen.prop) : null;
        this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE$1);
        return this;
      }
    }, {
      key: "addPen",
      value: function addPen(pen) {
        var previousPen = this.lastPen;
        if (previousPen == null) {
          pen.startIndex = 0;
        } else {
          pen.startIndex = previousPen.endIndex;
        }
        this.pens.push(pen);

        // maintan lines
        var line = this.lastLine;
        if (line == null) {
          line = this.linesPool.pop() || [];
          this.lines.push(line);
        }
        line.push(pen);

        // new line, add an empty line
        if (pen.newLineMode !== NO_NEWLINE$2) {
          line = this.linesPool.pop() || [];
          this.lines.push(line);
        }
        this.maxLinesWidth = undefined;
      }
    }, {
      key: "clone",
      value: function clone(targetPenManager) {
        if (targetPenManager == null) targetPenManager = new PenManager();
        targetPenManager.clear();
        for (var li = 0, llen = this.lines.length; li < llen; li++) {
          var pens = this.lines[li];
          for (var pi = 0, plen = pens.length; pi < plen; pi++) {
            var pen = pens[pi];
            targetPenManager.addPen(pen.text, pen.x, pen.y, pen.width, Clone$2(pen.prop), pen.newLineMode);
          }
        }
        return targetPenManager;
      }
    }, {
      key: "lastPen",
      get: function get() {
        return this.pens[this.pens.length - 1];
      }
    }, {
      key: "lastLine",
      get: function get() {
        return this.lines[this.lines.length - 1];
      }
    }, {
      key: "getLineStartIndex",
      value: function getLineStartIndex(i) {
        if (i >= this.lines.length) {
          return this.getLineEndIndex(i);
        } else {
          var line = this.lines[i];
          return line && line[0] ? line[0].startIndex : 0;
        }
      }
    }, {
      key: "getLineEndIndex",
      value: function getLineEndIndex(i) {
        if (i >= this.lines.length) {
          i = this.lines.length - 1;
        }
        var li,
          hasLastPen = false,
          line;
        for (li = i; li >= 0; li--) {
          line = this.lines[li];
          hasLastPen = line != null && line.length > 0;
          if (hasLastPen) {
            break;
          }
        }
        if (!hasLastPen) {
          return 0;
        }
        var lastPen = line[line.length - 1];
        return lastPen.endIndex;
      }
    }, {
      key: "getLineWidth",
      value: function getLineWidth(i) {
        var line = this.lines[i];
        if (!line) {
          return 0;
        }
        var lastPen = line[line.length - 1];
        if (lastPen == null) {
          return 0;
        }
        var lineWidth = lastPen.lastX; // start from 0
        return lineWidth;
      }
    }, {
      key: "getMaxLineWidth",
      value: function getMaxLineWidth() {
        if (this.maxLinesWidth !== undefined) {
          return this.maxLinesWidth;
        }
        var w,
          maxW = 0;
        for (var i = 0, len = this.lines.length; i < len; i++) {
          w = this.getLineWidth(i);
          if (w > maxW) {
            maxW = w;
          }
        }
        this.maxLinesWidth = maxW;
        return maxW;
      }
    }, {
      key: "getLineWidths",
      value: function getLineWidths() {
        var result = [];
        for (var i = 0, len = this.lines.length; i < len; i++) {
          result.push(this.getLineWidth(i));
        }
        return result;
      }
    }, {
      key: "linesCount",
      get: function get() {
        return this.lines.length;
      }
    }, {
      key: "plainText",
      get: function get() {
        var txt = "",
          pens = this.pens;
        for (var i = 0, len = pens.length; i < len; i++) {
          txt += pens[i].plainText;
        }
        return txt;
      }
    }, {
      key: "rawTextLength",
      get: function get() {
        var l = 0,
          pens = this.pens;
        for (var i = 0, len = this.pens.length; i < len; i++) {
          l += pens[i].rawTextLength;
        }
        return l;
      }
    }, {
      key: "getSliceTagText",
      value: function getSliceTagText(start, end, wrap) {
        var lastPen = this.lastPen;
        if (lastPen == null) {
          return '';
        }
        var lastPenEnd = lastPen.endIndex;
        if (start === undefined || start === 0) {
          // Image pen before first character
          start = -1;
        }
        if (end === undefined || end === lastPenEnd) {
          // Image pen after last character
          end = lastPenEnd + 1;
        }
        if (wrap === undefined) {
          wrap = false;
        }
        var txt = "",
          pen,
          penTxt,
          penStartIdx,
          penEndIdx,
          isInRange;
        var currentProp, previousProp;
        for (var i = 0, len = this.pens.length; i < len; i++) {
          pen = this.pens[i];
          penEndIdx = pen.endIndex;
          if (penEndIdx <= start) {
            continue;
          }
          pen = this.pens[i];
          penTxt = !wrap ? pen.plainText : pen.wrapText;
          currentProp = pen.prop;
          penStartIdx = pen.startIndex;
          isInRange = penStartIdx >= start && penEndIdx <= end;
          if (!isInRange) {
            penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
          }
          if (this.tagToTextScope) {
            txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
          } else {
            txt += this.tagToText(penTxt, currentProp, previousProp);
          }
          previousProp = currentProp;
          if (penEndIdx >= end) {
            break;
          }
        }
        return txt;
      }
    }, {
      key: "length",
      get: function get() {
        return this.lines.length;
      },
      set: function set(value) {
        // Only for set length to 0 (clear)
        this.clear();
      }
    }]);
    return PenManager;
  }();
  var PEN_CONFIG = {};

  var Rectangle$4 = Phaser.Geom.Rectangle;
  var RectanglePool = new Stack();
  var HitAreaManager = /*#__PURE__*/function () {
    function HitAreaManager() {
      _classCallCheck(this, HitAreaManager);
      this.hitAreas = [];
    }
    _createClass(HitAreaManager, [{
      key: "destroy",
      value: function destroy() {
        this.clear();
      }
    }, {
      key: "clear",
      value: function clear() {
        // Reuse hitArea(rectangle) later
        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
          Clear$1(this.hitAreas[i].data);
        }
        RectanglePool.pushMultiple(this.hitAreas);
        return this;
      }
    }, {
      key: "add",
      value: function add(x, y, width, height, data) {
        var rectangle = RectanglePool.pop();
        if (rectangle === null) {
          rectangle = new Rectangle$4(x, y, width, height);
        } else {
          rectangle.setTo(x, y, width, height);
        }
        rectangle.data = data;
        this.hitAreas.push(rectangle);
        return this;
      }
    }, {
      key: "getFirst",
      value: function getFirst(x, y) {
        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
          var hitArea = this.hitAreas[i];
          if (hitArea.contains(x, y)) {
            return hitArea;
          }
        }
        return null;
      }
    }, {
      key: "getByKey",
      value: function getByKey(key) {
        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
          var hitArea = this.hitAreas[i];
          if (hitArea.data.key === key) {
            return hitArea;
          }
        }
        return null;
      }
    }, {
      key: "drawBounds",
      value: function drawBounds(graphics, color, parent) {
        if (color === undefined) {
          color = 0xffffff;
        }
        if (parent) {
          graphics.save().scaleCanvas(parent.scaleX, parent.scaleY).rotateCanvas(parent.rotation).translateCanvas(parent.x, parent.y);
        }
        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
          var hitArea = this.hitAreas[i];
          graphics.lineStyle(1, color).strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
        }
        if (parent) {
          graphics.restore();
        }
        return this;
      }
    }]);
    return HitAreaManager;
  }();

  var SetInteractive$1 = function SetInteractive() {
    this.parent.on('pointerdown', OnAreaDown, this).on('pointerup', OnAreaUp, this).on('pointermove', OnAreaOverOut, this).on('pointerover', OnAreaOverOut, this).on('pointerout', function (pointer, event) {
      OnAreaOverOut.call(this, pointer, null, null, event);
    }, this);
  };
  var OnAreaDown = function OnAreaDown(pointer, localX, localY, event) {
    var area = this.hitAreaManager.getFirst(localX, localY);
    if (area === null) {
      return;
    }
    var key = area.data.key;
    FireEvent$2.call(this, 'areadown', key, pointer, localX, localY, event);
    area.data.isDown = true;
  };
  var OnAreaUp = function OnAreaUp(pointer, localX, localY, event) {
    var area = this.hitAreaManager.getFirst(localX, localY);
    if (area === null) {
      return;
    }
    var areaData = area.data;
    var key = areaData.key;
    FireEvent$2.call(this, 'areaup', key, pointer, localX, localY, event);
    if (areaData.isDown) {
      FireEvent$2.call(this, 'areaclick', key, pointer, localX, localY, event);
      var url = areaData.url;
      if (url) {
        window.open(url, '_blank');
      }
    }
    areaData.isDown = false;
  };
  var OnAreaOverOut = function OnAreaOverOut(pointer, localX, localY, event) {
    if (localX === null) {
      // Case of pointerout
      if (this.lastHitAreaKey !== null) {
        FireEvent$2.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);
        this.hitAreaManager.getByKey(this.lastHitAreaKey).isDown = false;
        this.lastHitAreaKey = null;
      }
      return;
    }
    var area = this.hitAreaManager.getFirst(localX, localY);
    var key = area ? area.data.key : null;
    if (this.lastHitAreaKey === key) {
      return;
    }
    if (this.lastHitAreaKey !== null) {
      FireEvent$2.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);
      var prevHitArea = this.hitAreaManager.getByKey(this.lastHitAreaKey);
      if (this.urlTagCursorStyle && !!prevHitArea.data.url) {
        this.scene.input.manager.canvas.style.cursor = '';
      }
      prevHitArea.isDown = false;
    }
    if (key !== null) {
      FireEvent$2.call(this, 'areaover', key, pointer, localX, localY, event);
      if (this.urlTagCursorStyle && !!area.data.url) {
        this.scene.input.manager.canvas.style.cursor = this.urlTagCursorStyle;
      }
    }
    this.lastHitAreaKey = key;
  };
  var FireEvent$2 = function FireEvent(eventName, key, pointer, localX, localY, event) {
    this.parent.emit("".concat(eventName, "-").concat(key), pointer, localX, localY, event);
    this.parent.emit(eventName, key, pointer, localX, localY, event);
  };

  var IsASCIIString = function IsASCIIString(s) {
    return /^[\x00-\x7F]+$/.test(s);
  };

  var NO_NEWLINE$1 = CONST.NO_NEWLINE;
  var RAW_NEWLINE = CONST.RAW_NEWLINE;
  var WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;
  var NO_WRAP$1 = CONST.NO_WRAP;
  var WORD_WRAP = CONST.WORD_WRAP;
  var CHAR_WRAP = CONST.CHAR_WRAP;
  var splitRegExp = CONST.SPLITREGEXP;
  var WrapText = function WrapText(text, getTextWidth, wrapMode, wrapWidth, offset, wrapTextLinesPool) {
    if (wrapWidth <= 0) {
      wrapMode = NO_WRAP$1;
    }
    var retLines = [];
    if (!text || !text.length) {
      return retLines;
    }
    var isNoWrap = wrapMode === NO_WRAP$1;
    var lines = text.split(splitRegExp),
      line,
      remainWidth,
      newLineMode;
    for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
      line = lines[i];
      newLineMode = i === linesLen - 1 ? NO_NEWLINE$1 : RAW_NEWLINE;
      if (isNoWrap) {
        var textWidth = getTextWidth(line);
        retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
        continue;
      }
      remainWidth = i === 0 ? wrapWidth - offset : wrapWidth;

      // short string testing
      if (line.length <= 100) {
        var textWidth = getTextWidth(line);
        if (textWidth <= remainWidth) {
          retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
          continue;
        }
      }
      var tokenArray = ParseLine(line, wrapMode);
      var token, tokenWidth;
      var lineText = '',
        lineWidth = 0;
      var currLineWidth;
      for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
        token = tokenArray[j];
        tokenWidth = getTextWidth(token);

        // Text width of single token is larger than a line width
        if (tokenWidth > wrapWidth && IsWord(token)) {
          if (lineText !== '') {
            // Has pending lineText, flush it out
            retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE));
          } else if (j === 0 && offset > 0) {
            // No pending lineText, but has previous text. Append a newline
            retLines.push(wrapTextLinesPool.getLine('', 0, WRAPPED_NEWLINE));
          }

          // Word break
          retLines.push.apply(retLines, _toConsumableArray(WrapText(token, getTextWidth, CHAR_WRAP, wrapWidth, 0, wrapTextLinesPool)));
          // Continue at last-wordBreak-line
          var lastwordBreakLine = retLines.pop();
          lineText = lastwordBreakLine.text;
          lineWidth = lastwordBreakLine.width;
          // Free this line
          wrapTextLinesPool.freeLine(lastwordBreakLine);

          // Special case : Start at a space character, discard it
          if (lineText === ' ') {
            lineText = '';
            lineWidth = 0;
          }
          continue;
        }
        currLineWidth = lineWidth + tokenWidth;
        if (currLineWidth > remainWidth) {
          // New line
          retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE));
          lineText = token;
          lineWidth = tokenWidth;
          remainWidth = wrapWidth;
        } else {
          // Append token, continue
          lineText += token;
          lineWidth = currLineWidth;
        }
        if (j === tokenLen - 1) {
          // Flush remain text
          retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, newLineMode));
        }
      } // for token in tokenArray
    } // for each line in lines

    return retLines;
  };
  var ParseLine = function ParseLine(s, mode) {
    var tokens = [];
    switch (mode) {
      case WORD_WRAP:
        s = s.split(' ');
        for (var i = 0, icnt = s.length; i < icnt; i++) {
          var token = s[i];
          if (i < icnt - 1) {
            tokens.push(token + ' ');
          } else {
            // The last token
            if (token !== '') {
              tokens.push(token);
            }
          }
        }
        break;
      case CHAR_WRAP:
        tokens.push.apply(tokens, _toConsumableArray(s.split('')));
        break;
      default:
        // MIX_WRAP
        s = s.split(' ');
        for (var i = 0, icnt = s.length; i < icnt; i++) {
          var token = s[i];
          if (i < icnt - 1) {
            if (IsASCIIString(token)) {
              tokens.push(token + ' ');
            } else {
              tokens.push.apply(tokens, _toConsumableArray(token.split('')));
              // Add space as last token
              tokens.push(' ');
            }
          } else {
            // The last token
            if (token !== '') {
              if (IsASCIIString(token)) {
                tokens.push(token);
              } else {
                tokens.push.apply(tokens, _toConsumableArray(token.split('')));
              }
            }
          }
        }
        break;
    }
    return tokens;
  };
  var IsWord = function IsWord(s) {
    switch (s.length) {
      case 1:
        return false;
      case 2:
        return s.charAt(1) !== ' ';
      default:
        return true;
    }
  };

  var GetValue$2Z = Phaser.Utils.Objects.GetValue;
  var NO_WRAP = CONST.NO_WRAP;
  var NO_NEWLINE = CONST.NO_NEWLINE;
  var CanvasText = /*#__PURE__*/function () {
    function CanvasText(config) {
      _classCallCheck(this, CanvasText);
      this.parent = config.parent;
      this.scene = this.parent.scene;
      this.context = GetValue$2Z(config, 'context', null);
      this.canvas = this.context.canvas;
      this.parser = GetValue$2Z(config, 'parser', null);
      this.defaultStyle = GetValue$2Z(config, 'style', null);
      this.autoRound = true;
      this.pensPool = config.pensPool; // Required
      this.linesPool = config.linesPool; // Required
      this.wrapTextLinesPool = config.wrapTextLinesPool; // Required

      this.penManager = this.newPenManager();
      this._tmpPenManager = null;
      this.hitAreaManager = new HitAreaManager();
      this.lastHitAreaKey = null;
      this.urlTagCursorStyle = null;
      var context = this.context;
      this.getTextWidth = function (text) {
        return context.measureText(text).width;
      };
    }
    _createClass(CanvasText, [{
      key: "destroy",
      value: function destroy() {
        this.parent = undefined;
        this.scene = undefined;
        this.context = undefined;
        this.canvas = undefined;
        this.parser = undefined;
        this.defaultStyle = undefined;
        if (this.penManager) {
          this.penManager.destroy();
          this.penManager = undefined;
        }
        if (this._tmpPenManager) {
          this._tmpPenManager.destroy();
          this._tmpPenManager = undefined;
        }
        if (this.hitAreaManager) {
          this.hitAreaManager.destroy();
          this.hitAreaManager = undefined;
        }
        this.pensPool = undefined;
        this.linesPool = undefined;
        this.wrapTextLinesPool = undefined;
      }
    }, {
      key: "updatePenManager",
      value: function updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
        if (penManager === undefined) {
          penManager = this.penManager;
        }
        penManager.clear();
        if (text === "") {
          return penManager;
        }
        var textStyle = this.parent.style;
        if (textStyle.isWrapFitMode) {
          var padding = this.parent.padding;
          wrapWidth = textStyle.fixedWidth - padding.left - padding.right;
        }
        var canvas = this.canvas;
        var context = this.context;
        var MeasureText = function MeasureText(text) {
          return context.measureText(text).width;
        };
        var cursorX = 0,
          cursorY = 0;
        var customTextWrapCallback = textStyle.wrapCallback,
          customTextWrapCallbackScope = textStyle.wrapCallbackScope;
        var reuseLines = true;
        var plainText, curProp, curStyle;
        var match = this.parser.splitText(text),
          result,
          wrapLines,
          wrapTextLinesPool = this.wrapTextLinesPool;
        for (var i = 0, len = match.length; i < len; i++) {
          result = this.parser.tagTextToProp(match[i], curProp);
          plainText = result.plainText;
          curProp = result.prop;
          if (curProp.img) {
            // Image tag                
            var imgWidth = this.imageManager.getOuterWidth(curProp.img);
            if (wrapWidth > 0 && wrapMode !== NO_WRAP) {
              // Wrap mode
              if (wrapWidth < cursorX + imgWidth) {
                penManager.addNewLinePen();
                cursorY += lineHeight;
                cursorX = 0;
              }
            }
            penManager.addImagePen(cursorX, cursorY, imgWidth, Clone$2(curProp));
            cursorX += imgWidth;
          } else if (plainText !== '') {
            // wrap text to lines
            // Save the current context.
            context.save();
            curStyle = this.parser.propToContextStyle(this.defaultStyle, curProp);
            curStyle.buildFont();
            curStyle.syncFont(canvas, context);
            curStyle.syncStyle(canvas, context);
            if (!customTextWrapCallback) {
              wrapLines = WrapText(plainText, MeasureText, wrapMode, wrapWidth, cursorX, wrapTextLinesPool);
            } else {
              // customTextWrapCallback
              wrapLines = customTextWrapCallback.call(customTextWrapCallbackScope, plainText, MeasureText, wrapWidth, cursorX);
              if (typeof wrapLines === 'string') {
                wrapLines = wrapLines.split('\n');
              }
              var n;
              for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                n = wrapLines[j];
                if (typeof n === 'string') {
                  wrapLines[j] = wrapTextLinesPool.getLine(n, MeasureText(n), j < jLen - 1 ? 2 : 0);
                } else {
                  reuseLines = false;
                }
              }
            } // customTextWrapCallback

            // add pens
            var n;
            for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
              n = wrapLines[j];
              penManager.addTextPen(n.text, cursorX, cursorY, n.width, Clone$2(curProp), n.newLineMode);
              if (n.newLineMode !== NO_NEWLINE) {
                cursorX = 0;
                cursorY += lineHeight;
              } else {
                cursorX += n.width;
              }
            }
            if (reuseLines) {
              wrapTextLinesPool.freeLines(wrapLines);
            }
            wrapLines = null;
            context.restore();
          }
        }

        // Add strokeThinkness to last pen of each line
        for (var i = 0, len = this.lines.length; i < len; i++) {
          var line = this.lines[i];
          var lastPen = line[line.length - 1];
          if (lastPen) {
            lastPen.width += this.parser.getStrokeThinkness(this.defaultStyle, lastPen.prop);
          }
        }
        return penManager;
      }
    }, {
      key: "startXOffset",
      get: function get() {
        var defaultStyle = this.defaultStyle;
        return defaultStyle.strokeThickness / 2 + defaultStyle.xOffset;
      }
    }, {
      key: "startYOffset",
      get: function get() {
        var defaultStyle = this.defaultStyle;
        return defaultStyle.strokeThickness / 2 + defaultStyle.metrics.ascent;
      }
    }, {
      key: "lines",
      get: function get() {
        return this.penManager.lines;
      }
    }, {
      key: "desplayLinesCount",
      get: function get() {
        var linesCount = this.penManager.linesCount,
          maxLines = this.defaultStyle.maxLines;
        if (maxLines > 0 && linesCount > maxLines) {
          linesCount = maxLines;
        }
        return linesCount;
      }
    }, {
      key: "linesWidth",
      get: function get() {
        return Math.ceil(this.penManager.getMaxLineWidth());
      }
    }, {
      key: "linesHeight",
      get: function get() {
        var linesCount = this.desplayLinesCount;
        var linesHeight = this.defaultStyle.lineHeight * linesCount;
        if (linesCount > 0) {
          linesHeight -= this.defaultStyle.lineSpacing;
        }
        return linesHeight;
      }
    }, {
      key: "imageManager",
      get: function get() {
        return this.parent.imageManager;
      }
    }, {
      key: "rtl",
      get: function get() {
        return this.parent.style.rtl;
      }
    }, {
      key: "newPenManager",
      value: function newPenManager() {
        return new PenManager({
          pensPool: this.pensPool,
          linesPool: this.linesPool,
          tagToText: this.parser.propToTagText,
          tagToTextScope: this.parser
        });
      }
    }, {
      key: "tmpPenManager",
      get: function get() {
        if (this._tmpPenManager === null) {
          this._tmpPenManager = this.newPenManager();
        }
        return this._tmpPenManager;
      }
    }, {
      key: "getPlainText",
      value: function getPlainText(text, start, end) {
        var plainText;
        if (text == null) {
          plainText = this.penManager.plainText;
        } else {
          var match = this.parser.splitText(text, 1); // PLAINTEXTONLY_MODE
          plainText = "";
          for (var i = 0, len = match.length; i < len; i++) {
            plainText += match[i];
          }
        }
        if (start != null || end != null) {
          if (start == null) {
            start = 0;
          }
          if (end == null) {
            end = plainText.length;
          }
          plainText = plainText.substring(start, end);
        }
        return plainText;
      }
    }, {
      key: "getPenManager",
      value: function getPenManager(text, retPenManager) {
        if (text === undefined) {
          return this.copyPenManager(retPenManager, this.penManager);
        }
        if (retPenManager === undefined) {
          retPenManager = this.newPenManager();
        }
        var defaultStyle = this.defaultStyle;
        this.updatePenManager(text, defaultStyle.wrapMode, defaultStyle.wrapWidth, defaultStyle.lineHeight, retPenManager);
        return retPenManager;
      }
    }, {
      key: "getText",
      value: function getText(text, start, end, wrap) {
        if (text == null) {
          return this.penManager.getSliceTagText(start, end, wrap);
        }
        var penManager = this.tmpPenManager;
        var defaultStyle = this.defaultStyle;
        this.updatePenManager(text, defaultStyle.wrapMode, defaultStyle.wrapWidth, defaultStyle.lineHeight, penManager);
        return penManager.getSliceTagText(start, end, wrap);
      }
    }, {
      key: "copyPenManager",
      value: function copyPenManager(ret, src) {
        if (src === undefined) {
          src = this.penManager;
        }
        return src.copy(ret);
      }
    }, {
      key: "getTextWidth",
      value: function getTextWidth(penManager) {
        if (penManager === undefined) {
          penManager = this.penManager;
        }
        return penManager.getMaxLineWidth();
      }
    }, {
      key: "getLastPen",
      value: function getLastPen(penManager) {
        if (penManager === undefined) {
          penManager = this.penManager;
        }
        return penManager.lastPen;
      }
    }]);
    return CanvasText;
  }();
  var methods$A = {
    setInteractive: SetInteractive$1
  };
  Object.assign(CanvasText.prototype, DrawMethods, methods$A);

  var WrapTextLinesPool = /*#__PURE__*/function (_Pool) {
    _inherits(WrapTextLinesPool, _Pool);
    function WrapTextLinesPool() {
      _classCallCheck(this, WrapTextLinesPool);
      return _callSuper(this, WrapTextLinesPool, arguments);
    }
    _createClass(WrapTextLinesPool, [{
      key: "freeLine",
      value: function freeLine(line) {
        if (!line) {
          return;
        }
        this.push(line);
        return this;
      }
    }, {
      key: "freeLines",
      value: function freeLines(lines) {
        if (!lines) {
          return;
        }
        this.pushMultiple(lines);
        return this;
      }
    }, {
      key: "getLine",
      value: function getLine(text, width, newLineMode) {
        var l = this.pop();
        if (l === null) {
          l = {};
        }
        l.text = text;
        l.width = width;
        l.newLineMode = newLineMode;
        return l;
      }
    }]);
    return WrapTextLinesPool;
  }(Stack);

  var IsPlainObject$K = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$2Y = Phaser.Utils.Objects.GetValue;
  var AddImage$1 = function AddImage(key, config) {
    if (IsPlainObject$K(key)) {
      config = key;
      key = config.key;
    } else if (config === undefined) {
      config = {
        key: key
      };
    }
    if (!config.hasOwnProperty('key')) {
      config.key = key;
    }
    var textureKey = config.key,
      frameKey = config.frame;
    var width = config.width,
      height = config.height;
    if (width === undefined || height === undefined) {
      var frame = this.textureManager.getFrame(textureKey, frameKey);
      var frameWidth = frame ? frame.cutWidth : 0;
      var frameHeight = frame ? frame.cutHeight : 0;
      if (width === undefined && height === undefined) {
        width = frameWidth;
        height = frameHeight;
      } else if (width === undefined) {
        width = frameWidth * (height / frameHeight);
      } else if (height === undefined) {
        height = frameHeight * (width / frameWidth);
      }
    }
    this.images[key] = {
      key: textureKey,
      frame: frameKey,
      width: width,
      height: height,
      y: GetValue$2Y(config, 'y', 0),
      left: GetValue$2Y(config, 'left', 0),
      right: GetValue$2Y(config, 'right', 0),
      originX: GetValue$2Y(config, 'originX', 0),
      originY: GetValue$2Y(config, 'originY', 0),
      tintFill: GetValue$2Y(config, 'tintFill', false)
    };
  };

  var CanvasPool$1 = Phaser.Display.Canvas.CanvasPool;
  var DrawFrameToCanvas = function DrawFrameToCanvas(frame, canvas, x, y, width, height, color, autoRound) {
    if (x === undefined) {
      x = 0;
    }
    if (y === undefined) {
      y = 0;
    }
    if (width === undefined) {
      width = frame.cutWidth;
    }
    if (height === undefined) {
      height = frame.cutHeight;
    }
    if (autoRound === undefined) {
      autoRound = false;
    }
    if (autoRound) {
      x = Math.round(x);
      y = Math.round(y);
    }
    var context = canvas.getContext('2d', {
      willReadFrequently: true
    });
    if (color) {
      // Draw image at tempCanvas

      // Get tempCanvas
      var tempCanvas = CanvasPool$1.create(null, width, height, Phaser.CANVAS, true);
      var tempContext = tempCanvas.getContext('2d', {
        willReadFrequently: true
      });
      tempContext.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, width, height);

      // Tint-fill
      tempContext.globalCompositeOperation = 'source-in';
      tempContext.fillStyle = color;
      tempContext.fillRect(0, 0, width, height);

      // Draw tempCanvas at context
      context.drawImage(tempCanvas, 0, 0, width, height, x, y, width, height);

      // Release tempCanvas
      CanvasPool$1.remove(tempCanvas);
    } else {
      context.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, x, y, width, height);
    }
  };

  var DrawImage = function DrawImage(key, context, x, y, color, autoRound) {
    var imgData = this.get(key);
    var frame = this.textureManager.getFrame(imgData.key, imgData.frame);
    var width = imgData.width,
      height = imgData.height;
    x += imgData.left - imgData.originX * width;
    y += imgData.y - imgData.originY * height;
    if (!imgData.tintFill) {
      color = undefined;
    }
    DrawFrameToCanvas(frame, context.canvas, x, y, width, height, color, autoRound);
  };

  var ImageManager = /*#__PURE__*/function () {
    function ImageManager(scene) {
      _classCallCheck(this, ImageManager);
      this.textureManager = scene.sys.textures;
      this.images = {};
    }
    _createClass(ImageManager, [{
      key: "destroy",
      value: function destroy() {
        this.textureManager = undefined;
        this.images = undefined;
      }
    }, {
      key: "add",
      value: function add(key, config) {
        if (typeof key === 'string') {
          AddImage$1.call(this, key, config);
        } else if (Array.isArray(key)) {
          var data = key;
          for (var i = 0, cnt = data.length; i < cnt; i++) {
            AddImage$1.call(this, data[i]);
          }
        } else {
          var data = key;
          for (var key in data) {
            AddImage$1.call(this, key, data[key]);
          }
        }
        return this;
      }
    }, {
      key: "has",
      value: function has(key) {
        return this.images.hasOwnProperty(key);
      }
    }, {
      key: "remove",
      value: function remove(key) {
        if (this.has(key)) {
          delete this.images[key];
        }
        return this;
      }
    }, {
      key: "get",
      value: function get(key) {
        if (!this.has(key)) {
          if (this.textureManager.exists(key)) {
            this.add(key);
          }
        }
        return this.images[key];
      }
    }, {
      key: "getOuterWidth",
      value: function getOuterWidth(key) {
        var data = this.get(key);
        return data ? data.width + data.left + data.right : 0;
      }
    }, {
      key: "getFrame",
      value: function getFrame(key) {
        var data = this.get(key);
        return data ? this.textureManager.getFrame(data.key, data.frame) : undefined;
      }
    }, {
      key: "hasTexture",
      value: function hasTexture(key) {
        return !!this.getFrame(key);
      }
    }]);
    return ImageManager;
  }();
  var methods$z = {
    draw: DrawImage
  };
  Object.assign(ImageManager.prototype, methods$z);

  var AppendText$1 = function AppendText(value, addCR) {
    if (!value && value !== 0) {
      value = '';
    }
    if (addCR === undefined) {
      addCR = true;
    }
    if (Array.isArray(value)) {
      value = value.join('\n');
    }
    var newText;
    if (addCR) {
      newText = "".concat(this.text, "\n").concat(value);
    } else {
      newText = "".concat(this.text).concat(value);
    }
    if (newText != this.text) {
      this.setText(newText);
    }
    return this;
  };

  var IsPlainObject$J = Phaser.Utils.Objects.IsPlainObject;
  var AddToDOM = Phaser.DOM.AddToDOM;
  var CanvasPool = Phaser.Display.Canvas.CanvasPool;
  var GameObject$1 = Phaser.GameObjects.GameObject;
  var GetValue$2X = Phaser.Utils.Objects.GetValue;
  var RemoveFromDOM$1 = Phaser.DOM.RemoveFromDOM;
  var SPLITREGEXP = CONST.SPLITREGEXP;
  var UUID$4 = Phaser.Utils.String.UUID;

  // Reuse objects can increase performance
  var SharedPensPools = null;
  var SharedLinesPool = null;
  var SharedWrapTextLinesPool = null;
  var Text = /*#__PURE__*/function (_TextBase) {
    _inherits(Text, _TextBase);
    function Text(scene, x, y, text, style, type, parser) {
      var _this;
      _classCallCheck(this, Text);
      if (IsPlainObject$J(x)) {
        var config = x;
        x = GetValue$2X(config, 'x', 0);
        y = GetValue$2X(config, 'y', 0);
        text = GetValue$2X(config, 'text', '');
        style = GetValue$2X(config, 'style');
      }
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      _this = _callSuper(this, Text, [scene, type]);
      _this.renderer = scene.sys.game.renderer;
      _this.setPosition(x, y);
      _this.setOrigin(0, 0);
      _this.initPipeline();
      _this.initPostPipeline(true);
      _this.canvas = CanvasPool.create(_assertThisInitialized(_this));
      _this.context = _this.canvas.getContext('2d', {
        willReadFrequently: true
      });
      _this._imageManager = undefined;
      if (style) {
        // Override align
        if (style.hasOwnProperty('align')) {
          var halign = style.align;
          delete style.align;
          style.halign = halign;
        }
        // Has Stroke color but stroke thinkness, set stroke thinkness to 1
        if (style.hasOwnProperty('stroke') && !style.hasOwnProperty('strokeThickness')) {
          style.strokeThickness = 1;
        }
      }
      _this.style = new TextStyle$1(_assertThisInitialized(_this), style);
      var imageData = GetValue$2X(style, 'images', undefined);
      if (imageData) {
        _this.addImage(imageData);
      }
      _this.autoRound = true;
      _this._text = undefined;
      _this.padding = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      _this.width = 1;
      _this.height = 1;
      _this.lineSpacing = 0;
      _this.dirty = false;

      //  If resolution wasn't set, force it to 1
      if (_this.style.resolution === 0) {
        _this.style.resolution = 1;
      }
      _this._crop = _this.resetCropObject();

      //  Create a Texture for this Text object
      _this._textureKey = UUID$4();
      _this.texture = scene.sys.textures.addCanvas(_this._textureKey, _this.canvas);

      //  Get the frame
      _this.frame = _this.texture.get();

      //  Set the resolution
      _this.frame.source.resolution = _this.style.resolution;
      if (_this.renderer && _this.renderer.gl) {
        //  Clear the default 1x1 glTexture, as we override it later
        _this.renderer.deleteTexture(_this.frame.source.glTexture);
        _this.frame.source.glTexture = null;
      }
      var sharedPoolMode = GetValue$2X(style, 'sharedPool', true);
      var pensPool, linesPool, wrapTextLinesPool;
      if (sharedPoolMode) {
        // Use pools first time
        if (!SharedPensPools) {
          SharedPensPools = {};
          SharedLinesPool = new Stack();
          SharedWrapTextLinesPool = new WrapTextLinesPool();

          // Remove cached data
          _this.scene.game.events.once('destroy', function () {
            SharedPensPools = null;
            SharedLinesPool = null;
            SharedWrapTextLinesPool = null;
          });
        }
        if (!SharedPensPools.hasOwnProperty(type)) {
          SharedPensPools[type] = new Stack();
        }
        pensPool = SharedPensPools[type];
        linesPool = SharedLinesPool;
        wrapTextLinesPool = SharedWrapTextLinesPool;
      } else {
        pensPool = new Stack();
        linesPool = new Stack();
        wrapTextLinesPool = new WrapTextLinesPool();
      }
      _this.canvasText = new CanvasText({
        parent: _assertThisInitialized(_this),
        context: _this.context,
        parser: parser,
        style: _this.style,
        pensPool: pensPool,
        linesPool: linesPool,
        wrapTextLinesPool: wrapTextLinesPool
      });
      _this.parser = parser;
      _this.initRTL();
      if (style && style.padding) {
        _this.setPadding(style.padding);
      }
      if (style && style.lineSpacing) {
        _this.setLineSpacing(style.lineSpacing);
      }
      _this.setText(text);
      _this.setUrlTagCursorStyle(GetValue$2X(style, 'urlTagCursorStyle', 'pointer'));
      if (GetValue$2X(style, 'interactive', false)) {
        _this.setInteractive();
      }
      return _this;
    }
    _createClass(Text, [{
      key: "preDestroy",
      value: function preDestroy() {
        RemoveFromDOM$1(this.canvas);
        // Do nothing if canvas did not add to parent node before

        this.canvasText.destroy();
        this.canvasText = undefined;
        if (this._imageManager) {
          this._imageManager.destroy();
          this._imageManager = undefined;
        }
        CanvasPool.remove(this.canvas);
        var texture = this.texture;
        if (texture) {
          texture.destroy();
        }
      }
    }, {
      key: "text",
      get: function get() {
        return this._text;
      },
      set: function set(value) {
        this.setText(value);
      }
    }, {
      key: "initRTL",
      value: function initRTL() {
        if (!this.style.rtl) {
          return;
        }

        //  Here is where the crazy starts.
        //
        //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas
        //  that is not part of the DOM. It just completely ignores the direction property.

        this.canvas.dir = 'rtl';

        //  Experimental atm, but one day ...
        this.context.direction = 'rtl';

        //  Add it to the DOM, but hidden within the parent canvas.
        this.canvas.style.display = 'none';
        AddToDOM(this.canvas, this.scene.sys.canvas);

        //  And finally we set the x origin
        this.originX = 1;
      }
    }, {
      key: "setRTL",
      value: function setRTL(rtl) {
        if (rtl === undefined) {
          rtl = true;
        }
        var style = this.style;
        if (style.rtl === rtl) {
          return this;
        }
        style.rtl = rtl;
        if (rtl) {
          this.canvas.dir = 'rtl';
          this.context.direction = 'rtl';
          this.canvas.style.display = 'none';
          AddToDOM(this.canvas, this.scene.sys.canvas);
        } else {
          this.canvas.dir = 'ltr';
          this.context.direction = 'ltr';
        }
        if (style.halign === 'left') {
          style.halign = 'right';
        } else if (style.halign === 'right') {
          style.halign = 'left';
        }
        if (this._imageManager) {
          var images = this._imageManager.images;
          for (var key in images) {
            images[key].originX = 1 - images[key].originX;
          }
        }
        return this;
      }
    }, {
      key: "setText",
      value: function setText(value) {
        if (value == null) {
          value = '';
        } else if (Array.isArray(value)) {
          value = value.join('\n');
        } else {
          value = value.toString();
        }
        if (value === this._text) {
          return this;
        }
        this._text = value;
        this.updateText();
        return this;
      }
    }, {
      key: "setPadding",
      value: function setPadding(left, top, right, bottom) {
        if (_typeof(left) === 'object') {
          var config = left;

          //  If they specify x and/or y this applies to all
          var x = GetValue$2X(config, 'x', null);
          if (x !== null) {
            left = x;
            right = x;
          } else {
            left = GetValue$2X(config, 'left', 0);
            right = GetValue$2X(config, 'right', left);
          }
          var y = GetValue$2X(config, 'y', null);
          if (y !== null) {
            top = y;
            bottom = y;
          } else {
            top = GetValue$2X(config, 'top', 0);
            bottom = GetValue$2X(config, 'bottom', top);
          }
        } else {
          if (left === undefined) {
            left = 0;
          }
          if (top === undefined) {
            top = left;
          }
          if (right === undefined) {
            right = left;
          }
          if (bottom === undefined) {
            bottom = top;
          }
        }
        this.padding.left = left;
        this.padding.top = top;
        this.padding.right = right;
        this.padding.bottom = bottom;
        return this.updateText(false);
      }
    }, {
      key: "updateText",
      value: function updateText(runWrap) {
        if (runWrap === undefined) {
          runWrap = true;
        }
        var canvasText = this.canvasText;

        // wrap text to pens
        var style = this.style;
        if (runWrap) {
          canvasText.updatePenManager(this._text, style.wrapMode, style.wrapWidth, style.lineHeight);
        }

        // resize
        var padding = this.padding;
        var textWidth, textHeight;
        var linesWidth = Math.ceil(canvasText.linesWidth);
        if (style.fixedWidth === 0) {
          this.width = linesWidth + padding.left + padding.right;
          textWidth = linesWidth;
        } else {
          this.width = style.fixedWidth;
          textWidth = this.width - padding.left - padding.right;
          if (textWidth < linesWidth) {
            textWidth = linesWidth;
          }
        }
        if (style.fixedHeight === 0) {
          this.height = canvasText.linesHeight + padding.top + padding.bottom;
          textHeight = canvasText.linesHeight;
        } else {
          this.height = style.fixedHeight;
          textHeight = this.height - padding.top - padding.bottom;
          if (textHeight < canvasText.linesHeight) {
            textHeight = canvasText.linesHeight;
          }
        }
        var w = this.width;
        var h = this.height;
        this.updateDisplayOrigin();
        var resolution = style.resolution;
        w *= resolution;
        h *= resolution;
        w = Math.max(Math.ceil(w), 1);
        h = Math.max(Math.ceil(h), 1);
        var canvas = this.canvas;
        var context = this.context;
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
          this.frame.setSize(w, h);
        } else {
          context.clearRect(0, 0, w, h);
        }
        context.save();
        context.scale(resolution, resolution);

        // draw
        var startX = !this.style.rtl ? padding.left : padding.right;
        var startY = padding.top;
        canvasText.draw(startX, startY, textWidth, textHeight);
        context.restore();
        if (this.renderer && this.renderer.gl) {
          this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
          if (typeof WEBGL_DEBUG === "undefined" ? "undefined" : _typeof(WEBGL_DEBUG)) {
            this.frame.glTexture.spectorMetadata = {
              textureKey: 'BBCodeText Game Object'
            };
          }
        }
        this.dirty = true;
        var input = this.input;
        if (input && !input.customHitArea) {
          input.hitArea.width = this.width;
          input.hitArea.height = this.height;
        }
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var out = Components.ToJSON(this);

        //  Extra Text data is added here

        var data = {
          autoRound: this.autoRound,
          text: this._text,
          style: this.style.toJSON(),
          resolution: this.resolution,
          padding: {
            left: this.padding.left,
            right: this.padding.right,
            top: this.padding.top,
            bottom: this.padding.bottom
          }
        };
        out.data = data;
        return out;
      }
    }, {
      key: "setInteractive",
      value: function setInteractive(hitArea, hitAreaCallback, dropZone) {
        var isInteractived = !!this.input;
        GameObject$1.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);
        if (!isInteractived) {
          this.canvasText.setInteractive();
        }
        return this;
      }
    }, {
      key: "setUrlTagCursorStyle",
      value: function setUrlTagCursorStyle(cursor) {
        this.urlTagCursorStyle = cursor;
        return this;
      }
    }, {
      key: "urlTagCursorStyle",
      get: function get() {
        return this.canvasText.urlTagCursorStyle;
      },
      set: function set(value) {
        this.canvasText.urlTagCursorStyle = value;
      }
    }, {
      key: "getWrappedText",
      value: function getWrappedText(text, start, end) {
        if (typeof text === 'number') {
          end = start;
          start = text;
          text = undefined;
        }
        text = this.canvasText.getText(text, start, end, true);
        return text.split(SPLITREGEXP);
      }
    }, {
      key: "getPlainText",
      value: function getPlainText(text, start, end) {
        if (typeof text === 'number') {
          end = start;
          start = text;
          text = undefined;
        }
        return this.canvasText.getPlainText(text, start, end);
      }
    }, {
      key: "getText",
      value: function getText(text, start, end, wrap) {
        if (typeof text === 'number') {
          wrap = end;
          end = start;
          start = text;
          text = undefined;
        }
        if (wrap === undefined) {
          wrap = false;
        }
        return this.canvasText.getText(text, start, end, wrap);
      }
    }, {
      key: "getSubString",
      value: function getSubString(text, start, end) {
        if (typeof text === 'number') {
          end = start;
          start = text;
          text = undefined;
        }
        return this.getText(text, start, end);
      }
    }, {
      key: "copyPenManager",
      value: function copyPenManager(penManager) {
        return this.canvasText.copyPenManager(penManager);
      }
    }, {
      key: "getPenManager",
      value: function getPenManager(text, penManager) {
        return this.canvasText.getPenManager(text, penManager);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        return this.setFixedSize(width, height);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        return this.setFixedSize(width, height);
      }
    }, {
      key: "imageManager",
      get: function get() {
        if (!this._imageManager) {
          this._imageManager = new ImageManager(this.scene);
        }
        return this._imageManager;
      }
    }, {
      key: "addImage",
      value: function addImage(key, config) {
        this.imageManager.add(key, config);
        return this;
      }
    }, {
      key: "drawAreaBounds",
      value: function drawAreaBounds(graphics, color) {
        this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
        return this;
      }
    }, {
      key: "generateTexture",
      value: function generateTexture(key, x, y, width, height) {
        var srcCanvas = this.canvas;
        if (width === undefined) {
          width = srcCanvas.width;
        } else {
          width *= this.resolution;
        }
        if (height === undefined) {
          height = srcCanvas.height;
        } else {
          height *= this.resolution;
        }
        CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
        return this;
      }
    }]);
    return Text;
  }(TextBase);
  var methods$y = {
    appendText: AppendText$1
  };
  Object.assign(Text.prototype, methods$y);

  var SplitText = function SplitText(text, mode) {
    var TagRegex = this.tagRegex;
    var result = [];
    var charIdx = 0;
    var rawMode = false,
      escMode = false;
    while (true) {
      var regexResult = TagRegex.RE_SPLITTEXT.exec(text);
      if (!regexResult) {
        break;
      }
      var match = regexResult[0];
      if (escMode) {
        if (TagRegex.RE_ESC_CLOSE.test(match)) {
          escMode = false;
        } else {
          continue; // Skip other tags
        }
      } else if (rawMode) {
        if (TagRegex.RE_RAW_CLOSE.test(match)) {
          rawMode = false;
        } else {
          continue; // Skip other tags
        }
      } else {
        if (TagRegex.RE_ESC_OPEN.test(match)) {
          escMode = true;
        } else if (TagRegex.RE_RAW_OPEN.test(match)) {
          rawMode = true;
        }
      }
      var matchEnd = TagRegex.RE_SPLITTEXT.lastIndex;
      var matchStart = matchEnd - match.length;
      if (charIdx < matchStart) {
        var content = text.substring(charIdx, matchStart);
        result.push(content);
      }
      if (mode === undefined) {
        result.push(match);
      }
      charIdx = matchEnd;
    }
    var totalLen = text.length;
    if (charIdx < totalLen) {
      // Push remainder string
      result.push(text.substring(charIdx, totalLen));
    }
    return result; // [text,...]
  };

  var PROP_REMOVE = false;
  var PROP_ADD = true;
  var GETPROP_RESULT = {
    plainText: null,
    prevProp: null
  };
  var TagTextToProp = function TagTextToProp(text, prevProp) {
    var TagRegex = this.tagRegex;

    // text : result of splitText()
    if (prevProp == null) {
      prevProp = {};
    }
    var plainText = '';

    // close image tag
    if (prevProp.img) {
      UpdateProp(prevProp, PROP_REMOVE, 'img');
    }
    if (prevProp.esc) {
      if (TagRegex.RE_ESC_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'esc');
      } else {
        plainText = text;
      }
    } else if (prevProp.raw) {
      if (TagRegex.RE_RAW_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'raw');
      } else {
        plainText = text;
      }
    } else {
      if (TagRegex.RE_ESC_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'esc', true);
      } else if (TagRegex.RE_ESC_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'esc');
      } else if (TagRegex.RE_RAW_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'raw', true);
      } else if (TagRegex.RE_RAW_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'raw');
      } else if (TagRegex.RE_BLOD_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'b', true);
      } else if (TagRegex.RE_BLOD_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'b');
      } else if (TagRegex.RE_ITALICS_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'i', true);
      } else if (TagRegex.RE_ITALICS_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'i');
      } else if (TagRegex.RE_WEIGHT_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_WEIGHT_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'weight', innerMatch[1]);
      } else if (TagRegex.RE_WEIGHT_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'weight');
      } else if (TagRegex.RE_SIZE_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_SIZE_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'size', "".concat(innerMatch[1], "px"));
      } else if (TagRegex.RE_SIZE_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'size');
      } else if (TagRegex.RE_COLOR_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_COLOR_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'color', innerMatch[1]);
      } else if (TagRegex.RE_COLOR_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'color');
      } else if (TagRegex.RE_UNDERLINE_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'u', true);
      } else if (TagRegex.RE_UNDERLINE_OPENC.test(text)) {
        var innerMatch = text.match(TagRegex.RE_UNDERLINE_OPENC);
        UpdateProp(prevProp, PROP_ADD, 'u', innerMatch[1]);
      } else if (TagRegex.RE_UNDERLINE_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'u');
      } else if (TagRegex.RE_STRIKETHROUGH_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 's', true);
      } else if (TagRegex.RE_STRIKETHROUGH_OPENC.test(text)) {
        var innerMatch = text.match(TagRegex.RE_STRIKETHROUGH_OPENC);
        UpdateProp(prevProp, PROP_ADD, 's', innerMatch[1]);
      } else if (TagRegex.RE_STRIKETHROUGH_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 's');
      } else if (TagRegex.RE_SHADOW_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'shadow', true);
      } else if (TagRegex.RE_SHADOW_OPENC.test(text)) {
        var innerMatch = text.match(TagRegex.RE_SHADOW_OPENC);
        UpdateProp(prevProp, PROP_ADD, 'shadow', innerMatch[1]);
      } else if (TagRegex.RE_SHADOW_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'shadow');
      } else if (TagRegex.RE_STROKE_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'stroke', true);
      } else if (TagRegex.RE_STROKE_OPENC.test(text)) {
        var innerMatch = text.match(TagRegex.RE_STROKE_OPENC);
        UpdateProp(prevProp, PROP_ADD, 'stroke', innerMatch[1]);
      } else if (TagRegex.RE_STROKE_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'stroke');
      } else if (TagRegex.RE_OFFSETY_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_OFFSETY_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'y', parseFloat(innerMatch[1]));
      } else if (TagRegex.RE_OFFSETY_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'y');
      } else if (TagRegex.RE_IMAGE_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_IMAGE_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'img', innerMatch[1]);
      } else if (TagRegex.RE_IMAGE_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'img');
      } else if (TagRegex.RE_AREA_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_AREA_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'area', innerMatch[1]);
      } else if (TagRegex.RE_AREA_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'area');
      } else if (TagRegex.RE_URL_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_URL_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'url', innerMatch[1]);
      } else if (TagRegex.RE_URL_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'url');
      } else if (TagRegex.RE_ALIGN_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_ALIGN_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'align', innerMatch[1]);
      } else if (TagRegex.RE_ALIGN_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'align');
      } else if (TagRegex.RE_ID_OPEN.test(text)) {
        var innerMatch = text.match(TagRegex.RE_ID_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'id', innerMatch[1]);
      } else if (TagRegex.RE_ID_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'id');
      } else {
        plainText = text;
      }
    }
    var result = GETPROP_RESULT;
    result.plainText = plainText;
    result.prop = prevProp;
    return result;
  };
  var UpdateProp = function UpdateProp(prop, op, key, value) {
    if (op === PROP_ADD) {
      // PROP_ADD     
      prop[key] = value;
    } else {
      // PROP_REMOVE        
      if (prop.hasOwnProperty(key)) {
        delete prop[key];
      }
    }
    return prop;
  };

  var PropToContextStyle = function PropToContextStyle(defaultStyle, prop) {
    var result = STYLE_RESULT;
    if (!prop.hasOwnProperty('img')) {
      result.image = null;
      if (prop.hasOwnProperty('family')) {
        result.fontFamily = prop.family;
      } else {
        result.fontFamily = defaultStyle.fontFamily;
      }
      if (prop.hasOwnProperty('size')) {
        var size = prop.size;
        if (typeof size === 'number') {
          size = "".concat(size, "px");
        }
        result.fontSize = size;
      } else {
        result.fontSize = defaultStyle.fontSize;
      }
      result.fontStyle = GetFontStyle(prop);
      if (prop.hasOwnProperty('color')) {
        result.color = prop.color;
      } else {
        result.color = defaultStyle.color;
      }
      if (prop.hasOwnProperty('stroke')) {
        if (prop.stroke === true) {
          result.stroke = defaultStyle.stroke;
          result.strokeThickness = defaultStyle.strokeThickness;
        } else {
          result.stroke = prop.stroke;
          result.strokeThickness = defaultStyle.strokeThickness;
        }
      } else {
        result.stroke = defaultStyle.stroke;
        result.strokeThickness = 0;
      }
    } else {
      result.image = prop.img;
    }
    if (prop.hasOwnProperty('shadow')) {
      if (prop.shadow === true) {
        result.shadowColor = defaultStyle.shadowColor;
        result.shadowOffsetX = defaultStyle.shadowOffsetX;
        result.shadowOffsetY = defaultStyle.shadowOffsetY;
        result.shadowBlur = defaultStyle.shadowBlur;
        result.shadowStroke = true;
        result.shadowFill = true;
      } else {
        result.shadowColor = prop.shadow;
        result.shadowOffsetX = defaultStyle.shadowOffsetX;
        result.shadowOffsetY = defaultStyle.shadowOffsetY;
        result.shadowBlur = defaultStyle.shadowBlur;
        result.shadowStroke = true;
        result.shadowFill = true;
      }
    } else {
      result.shadowColor = '#000';
      result.shadowOffsetX = 0;
      result.shadowOffsetY = 0;
      result.shadowBlur = 0;
      result.shadowStroke = false;
      result.shadowFill = false;
    }
    if (prop.hasOwnProperty('u')) {
      if (prop.u === true) {
        result.underlineColor = defaultStyle.underlineColor;
        result.underlineThickness = defaultStyle.underlineThickness;
        result.underlineOffset = defaultStyle.underlineOffset;
      } else {
        result.underlineColor = prop.u;
        result.underlineThickness = defaultStyle.underlineThickness;
        result.underlineOffset = defaultStyle.underlineOffset;
      }
    } else {
      result.underlineColor = '#000';
      result.underlineThickness = 0;
      result.underlineOffset = 0;
    }
    if (prop.hasOwnProperty('s')) {
      if (prop.s === true) {
        result.strikethroughColor = defaultStyle.strikethroughColor;
        result.strikethroughThickness = defaultStyle.strikethroughThickness;
        result.strikethroughOffset = defaultStyle.strikethroughOffset;
      } else {
        result.strikethroughColor = prop.s;
        result.strikethroughThickness = defaultStyle.strikethroughThickness;
        result.strikethroughOffset = defaultStyle.strikethroughOffset;
      }
    } else {
      result.strikethroughColor = '#000';
      result.strikethroughThickness = 0;
      result.strikethroughOffset = 0;
    }
    return result;
  };
  var GetFontStyle = function GetFontStyle(prop) {
    var isBold = prop.b;
    var weight = prop.weight;
    var isItalic = prop.i;
    if (isBold || weight || isItalic) {
      if (isItalic) {
        if (isBold) {
          return 'bold italic';
        } else if (weight) {
          return "".concat(weight, " italic");
        } else {
          return 'italic';
        }
      } else {
        // !isItalic
        if (isBold) {
          return 'bold';
        } else {
          return weight.toString();
        }
      }
    } else {
      return '';
    }
  };
  var STYLE_RESULT = new TextStyle$1();

  var PropToTagText = function PropToTagText(text, prop, prevProp) {
    if (prevProp == null) {
      prevProp = EMPTYPROP;
    }
    var delimiterLeft = this.delimiters[0];
    var delimiterRight = this.delimiters[1];
    var headers = [];
    for (var k in prevProp) {
      if (!prop.hasOwnProperty(k)) {
        headers.push("".concat(delimiterLeft, "/").concat(k).concat(delimiterRight));
      }
    }
    for (var k in prop) {
      var value = prop[k];
      if (k === 'img') ; else {
        if (prevProp[k] === value) {
          continue;
        }
      }
      switch (k) {
        case 'size':
          headers.push("".concat(delimiterLeft, "size=").concat(value.replace('px', '')).concat(delimiterRight));
          break;
        case 'color':
        case 'weight':
        case 'stroke':
        case 'y':
        case 'img':
        case 'area':
        case 'url':
        case 'align':
        case 'id':
          headers.push("".concat(delimiterLeft).concat(k, "=").concat(value).concat(delimiterRight));
          break;
        case 'u':
        case 's':
          if (value === true) {
            headers.push("".concat(delimiterLeft).concat(k).concat(delimiterRight));
          } else {
            headers.push("".concat(delimiterLeft).concat(k, "=").concat(value).concat(delimiterRight));
          }
          break;
        default:
          headers.push("".concat(delimiterLeft).concat(k).concat(delimiterRight));
          break;
      }
    }
    headers.push(text);
    return headers.join('');
  };
  var EMPTYPROP = {};

  var DelimiterLeftSave;
  var DelimiterRightSave;
  var TagRegexSave = {};
  var GetOpenTagRegString = function GetOpenTagRegString(delimiterLeft, delimiterRight, tagName, param) {
    if (param === undefined) {
      return "".concat(delimiterLeft).concat(tagName).concat(delimiterRight);
    } else {
      return "".concat(delimiterLeft).concat(tagName, "=(").concat(param, ")").concat(delimiterRight);
    }
  };
  var GetCloseTagRegString = function GetCloseTagRegString(delimiterLeft, delimiterRight, tagName) {
    return "".concat(delimiterLeft, "/").concat(tagName).concat(delimiterRight);
  };
  var GenerateStringRegEx = function GenerateStringRegEx(delimiterRight) {
    return "[^".concat(delimiterRight, "]+");
  };
  var NUMBER_PARAM = '[-.0-9]+';
  var colorParameterList = ['[a-zA-Z]+',
  // 'white'
  '#[0-9abcdef]+',
  // '#FFFFFF'
  'rgba?\\(\s*[.0-9]+\s*(,\s*[.0-9]+\s*){2,3}\\)' // rgb(255,255,255), or rgba(255,255,255,1)
  ];
  var COLOR_PARAM = colorParameterList.join('|'); // '[a-z]+|#[0-9abcdef]+'

  var SetDelimiters = function SetDelimiters(delimiterLeft, delimiterRight) {
    if (delimiterRight === undefined) {
      var delimeters = delimiterLeft;
      delimiterLeft = delimeters[0];
      delimiterRight = delimeters[1];
    }
    if (DelimiterLeftSave === delimiterLeft && DelimiterRightSave === delimiterRight) {
      return false;
    }
    DelimiterLeftSave = delimiterLeft;
    DelimiterRightSave = delimiterRight;
    delimiterLeft = EscapeRegex(delimiterLeft);
    delimiterRight = EscapeRegex(delimiterRight);
    var STR_PARAM = GenerateStringRegEx(delimiterRight);
    var ESC = 'esc';
    var ESC_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ESC);
    var ESC_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ESC);
    var RAW = 'raw';
    var RAW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, RAW);
    var RAW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, RAW);
    var BLOD = 'b';
    var BLOD_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BLOD);
    var BLOD_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BLOD);
    var ITALICS = 'i';
    var ITALICS_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ITALICS);
    var ITALICS_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ITALICS);
    var WEIGHT = 'weight';
    var WEIGHT_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, WEIGHT, NUMBER_PARAM);
    var WEIGHT_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, WEIGHT);
    var SIZE = 'size';
    var SIZE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SIZE, NUMBER_PARAM);
    var SIZE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SIZE);
    var COLOR = 'color';
    var COLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, COLOR, COLOR_PARAM);
    var COLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, COLOR);
    var UNDERLINE = 'u';
    var UNDERLINE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
    var UNDERLINE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE, COLOR_PARAM);
    var UNDERLINE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
    var STRIKETHROUGH = 's';
    var STRIKETHROUGH_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
    var STRIKETHROUGH_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH, COLOR_PARAM);
    var STRIKETHROUGH_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
    var SHADOW = 'shadow';
    var SHADOW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW);
    var SHADOW_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW, COLOR_PARAM);
    var SHADOW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SHADOW);
    var STROKE = 'stroke';
    var STROKE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE);
    var STROKE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE, COLOR_PARAM);
    var STROKE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STROKE);
    var OFFSETY = 'y';
    var OFFSETY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, OFFSETY, NUMBER_PARAM);
    var OFFSETY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, OFFSETY);
    var IMAGE = 'img';
    var IMAGE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, IMAGE, STR_PARAM);
    var IMAGE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, IMAGE);
    var AREA = 'area';
    var AREA_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, AREA, STR_PARAM);
    var AREA_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, AREA);
    var URL = 'url';
    var URL_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, URL, STR_PARAM);
    var URL_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, URL);
    var ALIGN = 'align';
    var ALIGN_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ALIGN, STR_PARAM);
    var ALIGN_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ALIGN);
    var ID = 'id';
    var ID_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ID, STR_PARAM);
    var ID_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ID);
    TagRegexSave.RE_ESC_OPEN = new RegExp(ESC_OPEN, 'i');
    TagRegexSave.RE_ESC_CLOSE = new RegExp(ESC_CLOSE, 'i');
    TagRegexSave.RE_RAW_OPEN = new RegExp(RAW_OPEN, 'i');
    TagRegexSave.RE_RAW_CLOSE = new RegExp(RAW_CLOSE, 'i');
    TagRegexSave.RE_BLOD_OPEN = new RegExp(BLOD_OPEN, 'i');
    TagRegexSave.RE_BLOD_CLOSE = new RegExp(BLOD_CLOSE, 'i');
    TagRegexSave.RE_ITALICS_OPEN = new RegExp(ITALICS_OPEN, 'i');
    TagRegexSave.RE_ITALICS_CLOSE = new RegExp(ITALICS_CLOSE, 'i');
    TagRegexSave.RE_WEIGHT_OPEN = new RegExp(WEIGHT_OPEN, 'i');
    TagRegexSave.RE_WEIGHT_CLOSE = new RegExp(WEIGHT_CLOSE, 'i');
    TagRegexSave.RE_SIZE_OPEN = new RegExp(SIZE_OPEN, 'i');
    TagRegexSave.RE_SIZE_CLOSE = new RegExp(SIZE_CLOSE, 'i');
    TagRegexSave.RE_COLOR_OPEN = new RegExp(COLOR_OPEN, 'i');
    TagRegexSave.RE_COLOR_CLOSE = new RegExp(COLOR_CLOSE, 'i');
    TagRegexSave.RE_UNDERLINE_OPEN = new RegExp(UNDERLINE_OPEN, 'i');
    TagRegexSave.RE_UNDERLINE_OPENC = new RegExp(UNDERLINE_OPENC, 'i');
    TagRegexSave.RE_UNDERLINE_CLOSE = new RegExp(UNDERLINE_CLOSE, 'i');
    TagRegexSave.RE_STRIKETHROUGH_OPEN = new RegExp(STRIKETHROUGH_OPEN, 'i');
    TagRegexSave.RE_STRIKETHROUGH_OPENC = new RegExp(STRIKETHROUGH_OPENC, 'i');
    TagRegexSave.RE_STRIKETHROUGH_CLOSE = new RegExp(STRIKETHROUGH_CLOSE, 'i');
    TagRegexSave.RE_SHADOW_OPEN = new RegExp(SHADOW_OPEN, 'i');
    TagRegexSave.RE_SHADOW_OPENC = new RegExp(SHADOW_OPENC, 'i');
    TagRegexSave.RE_SHADOW_CLOSE = new RegExp(SHADOW_CLOSE, 'i');
    TagRegexSave.RE_STROKE_OPEN = new RegExp(STROKE_OPEN, 'i');
    TagRegexSave.RE_STROKE_OPENC = new RegExp(STROKE_OPENC, 'i');
    TagRegexSave.RE_STROKE_CLOSE = new RegExp(STROKE_CLOSE, 'i');
    TagRegexSave.RE_OFFSETY_OPEN = new RegExp(OFFSETY_OPEN, 'i');
    TagRegexSave.RE_OFFSETY_CLOSE = new RegExp(OFFSETY_CLOSE, 'i');
    TagRegexSave.RE_IMAGE_OPEN = new RegExp(IMAGE_OPEN, 'i');
    TagRegexSave.RE_IMAGE_CLOSE = new RegExp(IMAGE_CLOSE, 'i');
    TagRegexSave.RE_AREA_OPEN = new RegExp(AREA_OPEN, 'i');
    TagRegexSave.RE_AREA_CLOSE = new RegExp(AREA_CLOSE, 'i');
    TagRegexSave.RE_URL_OPEN = new RegExp(URL_OPEN, 'i');
    TagRegexSave.RE_URL_CLOSE = new RegExp(URL_CLOSE, 'i');
    TagRegexSave.RE_ALIGN_OPEN = new RegExp(ALIGN_OPEN, 'i');
    TagRegexSave.RE_ALIGN_CLOSE = new RegExp(ALIGN_CLOSE, 'i');
    TagRegexSave.RE_ID_OPEN = new RegExp(ID_OPEN, 'i');
    TagRegexSave.RE_ID_CLOSE = new RegExp(ID_CLOSE, 'i');
    TagRegexSave.RE_SPLITTEXT = new RegExp([RAW_OPEN, RAW_CLOSE, ESC_OPEN, ESC_CLOSE, BLOD_OPEN, BLOD_CLOSE, ITALICS_OPEN, ITALICS_CLOSE, WEIGHT_OPEN, WEIGHT_CLOSE, SIZE_OPEN, SIZE_CLOSE, COLOR_OPEN, COLOR_CLOSE, UNDERLINE_OPEN, UNDERLINE_OPENC, UNDERLINE_CLOSE, STRIKETHROUGH_OPEN, STRIKETHROUGH_OPENC, STRIKETHROUGH_CLOSE, SHADOW_OPEN, SHADOW_OPENC, SHADOW_CLOSE, STROKE_OPEN, STROKE_OPENC, STROKE_CLOSE, OFFSETY_OPEN, OFFSETY_CLOSE, IMAGE_OPEN, IMAGE_CLOSE, AREA_OPEN, AREA_CLOSE, URL_OPEN, URL_CLOSE, ALIGN_OPEN, ALIGN_CLOSE, ID_OPEN, ID_CLOSE].join('|'), 'ig');
    return true;
  };
  var GetTagRegex = function GetTagRegex(delimiterLeft, delimiterRight) {
    if (delimiterLeft !== undefined) {
      SetDelimiters(delimiterLeft, delimiterRight);
    }
    return Object.assign({}, TagRegexSave);
  };

  var GetValue$2W = Phaser.Utils.Objects.GetValue;
  var Parser$1 = /*#__PURE__*/function () {
    function Parser(style) {
      _classCallCheck(this, Parser);
      var delimiters = GetValue$2W(style, 'delimiters', '[]');
      this.tagRegex = GetTagRegex(delimiters);
      this.delimiters = delimiters;
    }
    _createClass(Parser, [{
      key: "getStrokeThinkness",
      value: function getStrokeThinkness(defaultStyle, prop) {
        var strokeThickness;
        if (prop.hasOwnProperty('stroke')) {
          strokeThickness = defaultStyle.strokeThickness;
        } else {
          strokeThickness = 0;
        }
        return strokeThickness;
      }
    }, {
      key: "setDelimiters",
      value: function setDelimiters(delimiterLeft, delimiterRight) {
        if (SetDelimiters(delimiterLeft, delimiterRight)) {
          this.tagRegex = GetTagRegex();
        }
        return this;
      }
    }]);
    return Parser;
  }();
  var methods$x = {
    splitText: SplitText,
    tagTextToProp: TagTextToProp,
    propToContextStyle: PropToContextStyle,
    propToTagText: PropToTagText
  };
  Object.assign(Parser$1.prototype, methods$x);

  var BBCodeText = /*#__PURE__*/function (_Text) {
    _inherits(BBCodeText, _Text);
    function BBCodeText(scene, x, y, text, style) {
      _classCallCheck(this, BBCodeText);
      var parser = new Parser$1(style);
      return _callSuper(this, BBCodeText, [scene, x, y, text, style, 'rexBBCodeText', parser]);
    }
    _createClass(BBCodeText, [{
      key: "setDelimiters",
      value: function setDelimiters(delimiterLeft, delimiterRight) {
        this.parse.setDelimiters(delimiterLeft, delimiterRight);
        return this;
      }
    }]);
    return BBCodeText;
  }(Text);

  new TextStyle$1();

  Phaser.Utils.Objects.GetValue;

  var GetValue$2V = Phaser.Utils.Objects.GetValue;
  var GetPadding$1 = function GetPadding(padding, key) {
    if (key === undefined) {
      return padding;
    }
    return padding[key];
  };
  var SetPadding$1 = function SetPadding(padding, key, value) {
    if (padding === undefined) {
      padding = {};
    }
    if (key === undefined) {
      key = 0;
    }
    var keyType = _typeof(key);
    if (keyType === 'string') {
      padding[key] = value;
    } else if (keyType === 'number') {
      padding.left = key;
      padding.right = key;
      padding.top = key;
      padding.bottom = key;
    } else {
      padding.left = GetValue$2V(key, 'left', 0);
      padding.right = GetValue$2V(key, 'right', 0);
      padding.top = GetValue$2V(key, 'top', 0);
      padding.bottom = GetValue$2V(key, 'bottom', 0);
    }
    return padding;
  };

  var Base$2 = /*#__PURE__*/function () {
    function Base(parent, type) {
      _classCallCheck(this, Base);
      this.setParent(parent);
      this.type = type;
      this.renderable = false;
      this.reset().setActive();
    }
    _createClass(Base, [{
      key: "destroy",
      value: function destroy() {
        this.parent.removeChild(this);
      }
    }, {
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent;
        return this;
      }
    }, {
      key: "scene",
      get: function get() {
        return this.parent.scene;
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.parent ? this.parent.canvas : null;
      }
    }, {
      key: "context",
      get: function get() {
        return this.parent ? this.parent.context : null;
      }
    }, {
      key: "setDirty",
      value: function setDirty(dirty) {
        if (dirty && this.parent) {
          this.parent.dirty = true;
        }
        return this;
      }
    }, {
      key: "active",
      get: function get() {
        return this._active;
      },
      set: function set(value) {
        this.setDirty(this._active != value);
        this._active = value;
      }
    }, {
      key: "setActive",
      value: function setActive(active) {
        if (active === undefined) {
          active = true;
        }
        this.active = active;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        return this;
      }

      // Override
    }, {
      key: "onFree",
      value: function onFree() {
        this.reset().setParent();
      }

      // Override
    }, {
      key: "reset",
      value: function reset() {
        return this;
      }

      // Override
    }, {
      key: "render",
      value: function render() {}

      // Override
    }, {
      key: "contains",
      value: function contains(x, y) {
        return false;
      }
    }]);
    return Base;
  }();
  Object.assign(Base$2.prototype, DataMethods);

  var RenderMethods = {
    // Override
    renderContent: function renderContent() {},
    // Override
    render: function render() {
      if (!this.willRender) {
        return this;
      }
      var context = this.context;
      context.save();
      context.globalAlpha = this.alpha;
      if (this.toLocalPosition) {
        var x = this.drawX,
          y = this.drawY;
        if (this.autoRound) {
          x = Math.round(x);
          y = Math.round(y);
        }
        context.translate(x, y);
        context.scale(this.scaleX, this.scaleY);
        context.rotate(this.rotation);
      }
      if (this.drawBelowCallback) {
        this.drawBelowCallback(this);
      }
      this.renderContent();
      if (this.drawAboveCallback) {
        this.drawAboveCallback(this);
      }
      context.restore();
      return this;
    }
  };

  var RotateAround$7 = Phaser.Math.RotateAround;
  var CanvasPositionToBobPosition = function CanvasPositionToBobPosition(canvasX, canvasY, bob, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      if (globPoint$1 === undefined) {
        globPoint$1 = {};
      }
      out = globPoint$1;
    }
    out.x = (canvasX - bob.drawX) / bob.scaleX;
    out.y = (canvasY - bob.drawY) / bob.scaleY;
    if (bob.rotation !== 0) {
      RotateAround$7(out, 0, 0, -bob.rotation);
    }
    return out;
  };
  var globPoint$1;

  var Rectangle$3 = Phaser.Geom.Rectangle;
  var Contains$1 = function Contains(canvasX, canvasY) {
    if (this.width === 0 || this.height === 0) {
      return false;
    }
    var bobPosition = CanvasPositionToBobPosition(canvasX, canvasY, this, true);
    return GetBobBounds(this).contains(bobPosition.x, bobPosition.y);
  };
  var GetBobBounds = function GetBobBounds(bob) {
    if (bobBounds === undefined) {
      bobBounds = new Rectangle$3();
    }
    var x = bob.drawTLX,
      y = bob.drawTLY;
    bobBounds.setTo(x, y, bob.drawTRX - x, bob.drawBLY - y);
    return bobBounds;
  };
  var bobBounds;

  var RotateAround$6 = Phaser.Math.RotateAround;
  var BobPositionToCanvasPosition = function BobPositionToCanvasPosition(bob, bobX, bobY, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      if (globPoint === undefined) {
        globPoint = {};
      }
      out = globPoint;
    }
    out.x = bobX;
    out.y = bobY;
    if (bob.rotation !== 0) {
      RotateAround$6(out, 0, 0, bob.rotation);
    }
    out.x = out.x * bob.scaleX + bob.drawX;
    out.y = out.y * bob.scaleY + bob.drawY;
    return out;
  };
  var globPoint;

  var TransformMatrix$1 = Phaser.GameObjects.Components.TransformMatrix;
  var GameObjectLocalXYToWorldXY = function GameObjectLocalXYToWorldXY(gameObject, localX, localY, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = globOut$2;
    }
    var px = localX - gameObject.width * gameObject.originX;
    var py = localY - gameObject.height * gameObject.originY;
    if (tempMatrix$2 === undefined) {
      tempMatrix$2 = new TransformMatrix$1();
      parentMatrix$1 = new TransformMatrix$1();
    }
    if (gameObject.parentContainer) {
      gameObject.getWorldTransformMatrix(tempMatrix$2, parentMatrix$1);
    } else {
      tempMatrix$2.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY);
    }
    tempMatrix$2.transformPoint(px, py, out);
    return out;
  };
  var tempMatrix$2, parentMatrix$1;
  var globOut$2 = {};

  var BobPositionToWorldPosition = function BobPositionToWorldPosition(dynamicText, bob, bobX, bobY, out) {
    var localXY = BobPositionToCanvasPosition(bob, bobX, bobY, true);
    var worldXY = GameObjectLocalXYToWorldXY(dynamicText, localXY.x, localXY.y, out);
    return worldXY;
  };

  var GetBobWorldPosition = function GetBobWorldPosition(dynamicText, bob, offsetX, offsetY, out) {
    if (typeof offsetX !== 'number') {
      out = offsetX;
      offsetX = 0;
      offsetY = 0;
    }
    var bobX = bob.drawCenterX + offsetX;
    var bobY = bob.drawCenterY + offsetY;
    return BobPositionToWorldPosition(dynamicText, bob, bobX, bobY, out);
  };

  var GetWorldPosition = function GetWorldPosition(offsetX, offsetY, out) {
    return GetBobWorldPosition(this.parent, this, offsetX, offsetY, out);
  };

  var Methods$f = {
    contains: Contains$1,
    getWorldPosition: GetWorldPosition
  };
  Object.assign(Methods$f, RenderMethods);

  var DegToRad$c = Phaser.Math.DegToRad;
  var RadToDeg$7 = Phaser.Math.RadToDeg;
  var GetValue$2U = Phaser.Utils.Objects.GetValue;
  var RenderBase = /*#__PURE__*/function (_Base) {
    _inherits(RenderBase, _Base);
    function RenderBase(parent, type) {
      var _this;
      _classCallCheck(this, RenderBase);
      _this = _callSuper(this, RenderBase, [parent, type]);
      _this.renderable = true;
      _this.scrollFactorX = 1;
      _this.scrollFactorY = 1;
      _this.toLocalPosition = true;
      _this.originX = 0;
      _this.offsetX = 0; // Override
      _this.offsetY = 0; // Override
      return _this;
    }
    _createClass(RenderBase, [{
      key: "visible",
      get: function get() {
        return this._visible;
      },
      set: function set(value) {
        this.setDirty(this._visible != value);
        this._visible = value;
      }
    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        if (visible === undefined) {
          visible = true;
        }
        this.visible = visible;
        return this;
      }
    }, {
      key: "alpha",
      get: function get() {
        return this._alpha;
      },
      set: function set(value) {
        this.setDirty(this._alpha != value);
        this._alpha = value;
      }
    }, {
      key: "setAlpha",
      value: function setAlpha(alpha) {
        this.alpha = alpha;
        return this;
      }
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this.setDirty(this._x != value);
        this._x = value;
      }
    }, {
      key: "setX",
      value: function setX(x) {
        this.x = x;
        return this;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this.setDirty(this._y != value);
        this._y = value;
      }
    }, {
      key: "setY",
      value: function setY(y) {
        this.y = y;
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "setInitialPosition",
      value: function setInitialPosition(x, y) {
        this.x0 = x;
        this.y0 = y;
        return this;
      }
    }, {
      key: "setScrollFactorX",
      value: function setScrollFactorX(x) {
        this.scrollFactorX = x;
        return this;
      }
    }, {
      key: "setScrollFactorY",
      value: function setScrollFactorY(y) {
        this.scrollFactorY = y;
        return this;
      }
    }, {
      key: "setScrollFactor",
      value: function setScrollFactor(x, y) {
        if (y === undefined) {
          y = x;
        }
        this.scrollFactorX = x;
        this.scrollFactorY = y;
        return this;
      }
    }, {
      key: "rotation",
      get: function get() {
        return this._rotation;
      },
      set: function set(value) {
        this.setDirty(this._rotation != value);
        this._rotation = value;
      }
    }, {
      key: "setRotation",
      value: function setRotation(rotation) {
        this.rotation = rotation;
        return this;
      }
    }, {
      key: "angle",
      get: function get() {
        return RadToDeg$7(this._rotation);
      },
      set: function set(value) {
        this.rotation = DegToRad$c(value);
      }
    }, {
      key: "setAngle",
      value: function setAngle(angle) {
        this.angle = angle;
        return this;
      }
    }, {
      key: "scaleX",
      get: function get() {
        return this._scaleX;
      },
      set: function set(value) {
        this.setDirty(this._scaleX !== value);
        this._scaleX = value;
      }
    }, {
      key: "setScaleX",
      value: function setScaleX(scaleX) {
        this.scaleX = scaleX;
        return this;
      }

      // Override
    }, {
      key: "width",
      get: function get() {
        return 0;
      }

      // Override
      ,
      set: function set(value) {}
    }, {
      key: "setWidth",
      value: function setWidth(width, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }
        this.width = width;
        if (keepAspectRatio) {
          this.scaleY = this.scaleX;
        }
        return this;
      }
    }, {
      key: "leftSpace",
      get: function get() {
        return this._leftSpace;
      },
      set: function set(value) {
        this.setDirty(this._leftSpace !== value);
        this._leftSpace = value;
      }
    }, {
      key: "setLeftSpace",
      value: function setLeftSpace(value) {
        this.leftSpace = value;
        return this;
      }
    }, {
      key: "rightSpace",
      get: function get() {
        return this._rightSpace;
      },
      set: function set(value) {
        this.setDirty(this._rightSpace !== value);
        this._rightSpace = value;
      }
    }, {
      key: "setRightSpace",
      value: function setRightSpace(value) {
        this.rightSpace = value;
        return this;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.width + this.leftSpace + this.rightSpace;
      }
    }, {
      key: "scaleY",
      get: function get() {
        return this._scaleY;
      },
      set: function set(value) {
        this.setDirty(this._scaleY !== value);
        this._scaleY = value;
      }
    }, {
      key: "setScaleY",
      value: function setScaleY(scaleY) {
        this.scaleY = scaleY;
        return this;
      }

      // Override
    }, {
      key: "height",
      get: function get() {
        return 0;
      }

      // Override
      ,
      set: function set(value) {}
    }, {
      key: "setHeight",
      value: function setHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }
        this.height = height;
        if (keepAspectRatio) {
          this.scaleX = this.scaleY;
        }
        return this;
      }
    }, {
      key: "setScale",
      value: function setScale(scaleX, scaleY) {
        if (scaleY === undefined) {
          scaleY = scaleX;
        }
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        return this;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(x) {
        this.originX = x;
        return this;
      }
    }, {
      key: "setAlign",
      value: function setAlign(align) {
        this.align = align;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (!o) {
          return this;
        }
        if (o.hasOwnProperty('x')) {
          this.setX(o.x);
        }
        if (o.hasOwnProperty('y')) {
          this.setY(o.y);
        }
        if (o.hasOwnProperty('rotation')) {
          this.setRotation(o.rotation);
        } else if (o.hasOwnProperty('angle')) {
          this.setAngle(o.angle);
        }
        if (o.hasOwnProperty('alpha')) {
          this.setAlpha(o.alpha);
        }

        // ScaleX, ScaleY
        var width = GetValue$2U(o, 'width', undefined);
        var height = GetValue$2U(o, 'height', undefined);
        var scaleX = GetValue$2U(o, 'scaleX', undefined);
        var scaleY = GetValue$2U(o, 'scaleY', undefined);
        if (width !== undefined) {
          if (height === undefined && scaleY === undefined) {
            this.setWidth(width, true);
          } else {
            this.setWidth(width);
          }
        } else if (scaleX !== undefined) {
          this.setScaleX(scaleX);
        }
        if (height !== undefined) {
          if (width === undefined && scaleX === undefined) {
            this.setHeight(height, true);
          } else {
            this.setHeight(height);
          }
        } else if (scaleY !== undefined) {
          this.setScaleY(scaleY);
        }
        if (o.hasOwnProperty('leftSpace')) {
          this.setLeftSpace(o.leftSpace);
        }
        if (o.hasOwnProperty('rightSpace')) {
          this.setRightSpace(o.rightSpace);
        }
        if (o.hasOwnProperty('align')) {
          this.setAlign(o.align);
        }
        return this;
      }
    }, {
      key: "setDrawBelowCallback",
      value: function setDrawBelowCallback(callback) {
        this.drawBelowCallback = callback;
        return this;
      }
    }, {
      key: "setDrawAboveCallback",
      value: function setDrawAboveCallback(callback) {
        this.drawAboveCallback = callback;
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setLeftSpace(0).setRightSpace(0).setOrigin(0).setAlign().setDrawBelowCallback().setDrawAboveCallback();
        return this;
      }

      // Override
    }, {
      key: "willRender",
      get: function get() {
        return this.visible && this.alpha > 0;
      }
    }, {
      key: "drawX",
      get: function get() {
        var x = this.x + this.leftSpace + this.offsetX - this.originX * this.width;
        return this.parent._textOX * this.scrollFactorX + x;
      }
    }, {
      key: "drawY",
      get: function get() {
        var y = this.y + this.offsetY;
        return this.parent._textOY * this.scrollFactorY + y;
      }

      // Override
    }, {
      key: "drawTLX",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawTLY",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawBLX",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawBLY",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawTRX",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawTRY",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawBRX",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawBRY",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawCenterX",
      get: function get() {
        return (this.drawTRX + this.drawTLX) / 2;
      }
    }, {
      key: "drawCenterY",
      get: function get() {
        return (this.drawBLY + this.drawTLY) / 2;
      }
    }]);
    return RenderBase;
  }(Base$2);
  Object.assign(RenderBase.prototype, Methods$f);

  var GetProperty = function GetProperty(name, config, defaultConfig) {
    if (config.hasOwnProperty(name)) {
      return config[name];
    } else {
      return defaultConfig[name];
    }
  };

  var GetValue$2T = Phaser.Utils.Objects.GetValue;
  var Background = /*#__PURE__*/function (_RenderBase) {
    _inherits(Background, _RenderBase);
    function Background(parent, config) {
      var _this;
      _classCallCheck(this, Background);
      _this = _callSuper(this, Background, [parent, 'background']);
      _this.setScrollFactor(0);
      _this.setColor(GetValue$2T(config, 'color', null), GetValue$2T(config, 'color2', null), GetValue$2T(config, 'horizontalGradient', true));
      _this.setStroke(GetValue$2T(config, 'stroke', null), GetValue$2T(config, 'strokeThickness', 2));
      _this.setCornerRadius(GetValue$2T(config, 'cornerRadius', 0), GetValue$2T(config, 'cornerIteration', null));
      return _this;
    }
    _createClass(Background, [{
      key: "color",
      get: function get() {
        return this._color;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color != value);
        this._color = value;
      }
    }, {
      key: "color2",
      get: function get() {
        return this._color2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color2 != value);
        this._color2 = value;
      }
    }, {
      key: "horizontalGradient",
      get: function get() {
        return this._horizontalGradient;
      },
      set: function set(value) {
        this.setDirty(this._horizontalGradient != value);
        this._horizontalGradient = value;
      }
    }, {
      key: "setColor",
      value: function setColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
          isHorizontalGradient = true;
        }
        this.color = color;
        this.color2 = color2;
        this.horizontalGradient = isHorizontalGradient;
        return this;
      }
    }, {
      key: "stroke",
      get: function get() {
        return this._stroke;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._stroke != value);
        this._stroke = value;
      }
    }, {
      key: "strokeThickness",
      get: function get() {
        return this._strokeThickness;
      },
      set: function set(value) {
        this.setDirty(this._strokeThickness != value);
        this._strokeThickness = value;
      }
    }, {
      key: "setStroke",
      value: function setStroke(color, lineWidth) {
        if (color != null) {
          if (lineWidth === undefined) {
            lineWidth = 2;
          }
        }
        this.stroke = color;
        this.strokeThickness = lineWidth;
        return this;
      }
    }, {
      key: "cornerRadius",
      get: function get() {
        return this._cornerRadius;
      },
      set: function set(value) {
        this.setDirty(this._cornerRadius != value);
        this._cornerRadius = value;
      }
    }, {
      key: "cornerIteration",
      get: function get() {
        return this._cornerIteration;
      },
      set: function set(value) {
        this.setDirty(this._cornerIteration != value);
        this._cornerIteration = value;
      }
    }, {
      key: "modifyStyle",
      value: function modifyStyle(o) {
        if (o.hasOwnProperty('color')) {
          this.setColor(o.color, GetProperty('color2', o, this), GetProperty('horizontalGradient', o, this));
        }
        if (o.hasOwnProperty('stroke')) {
          this.setStroke(o.stroke, GetProperty('strokeThickness', o, this));
        }
        if (o.hasOwnProperty('cornerRadius')) {
          this.setCornerRadius(o.cornerRadius, GetProperty('cornerIteration', o, this));
        }
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        _get(_getPrototypeOf(Background.prototype), "modifyPorperties", this).call(this, o);
        this.modifyStyle(o);
        return this;
      }
    }, {
      key: "setCornerRadius",
      value: function setCornerRadius(radius, iteration) {
        this.cornerRadius = radius;
        this.cornerIteration = iteration;
        return this;
      }
    }, {
      key: "renderContent",
      value: function renderContent() {
        DrawRoundRectangleBackground(this.parent, this.color, this.stroke, this.strokeThickness, this.cornerRadius, this.color2, this.horizontalGradient, this.cornerIteration);
      }
    }]);
    return Background;
  }(RenderBase);

  var GetValue$2S = Phaser.Utils.Objects.GetValue;
  var InnerBounds = /*#__PURE__*/function (_RenderBase) {
    _inherits(InnerBounds, _RenderBase);
    function InnerBounds(parent, config) {
      var _this;
      _classCallCheck(this, InnerBounds);
      _this = _callSuper(this, InnerBounds, [parent, 'innerbounds']);
      _this.setScrollFactor(0);
      _this.setColor(GetValue$2S(config, 'color', null), GetValue$2S(config, 'color2', null), GetValue$2S(config, 'horizontalGradient', true));
      _this.setStroke(GetValue$2S(config, 'stroke', null), GetValue$2S(config, 'strokeThickness', 2));
      return _this;
    }
    _createClass(InnerBounds, [{
      key: "color",
      get: function get() {
        return this._color;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color != value);
        this._color = value;
      }
    }, {
      key: "color2",
      get: function get() {
        return this._color2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color2 != value);
        this._color2 = value;
      }
    }, {
      key: "horizontalGradient",
      get: function get() {
        return this._horizontalGradient;
      },
      set: function set(value) {
        this.setDirty(this._horizontalGradient != value);
        this._horizontalGradient = value;
      }
    }, {
      key: "setColor",
      value: function setColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
          isHorizontalGradient = true;
        }
        this.color = color;
        this.color2 = color2;
        this.horizontalGradient = isHorizontalGradient;
        return this;
      }
    }, {
      key: "stroke",
      get: function get() {
        return this._stroke;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._stroke != value);
        this._stroke = value;
      }
    }, {
      key: "strokeThickness",
      get: function get() {
        return this._strokeThickness;
      },
      set: function set(value) {
        this.setDirty(this._strokeThickness != value);
        this._strokeThickness = value;
      }
    }, {
      key: "setStroke",
      value: function setStroke(color, lineWidth) {
        if (color != null) {
          if (lineWidth === undefined) {
            lineWidth = 2;
          }
        }
        this.stroke = color;
        this.strokeThickness = lineWidth;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        _get(_getPrototypeOf(InnerBounds.prototype), "modifyPorperties", this).call(this, o);
        if (o.hasOwnProperty('color')) {
          this.setColor(o.color, GetValue$2S(o, 'color2', null), GetValue$2S(o, 'horizontalGradient', true));
        }
        if (o.hasOwnProperty('stroke')) {
          this.setStroke(o.stroke, GetValue$2S(o, 'strokeThickness', 2));
        }
      }
    }, {
      key: "renderContent",
      value: function renderContent() {
        var padding = this.parent.padding;
        var x = padding.left,
          y = padding.top,
          width = this.parent.width - padding.left - padding.right,
          height = this.parent.height - padding.top - padding.bottom;
        var context = this.context;
        if (this.color != null) {
          var fillStyle;
          if (this.color2 != null) {
            var grd;
            if (this.horizontalGradient) {
              grd = context.createLinearGradient(0, 0, width, 0);
            } else {
              grd = context.createLinearGradient(0, 0, 0, height);
            }
            grd.addColorStop(0, this.color);
            grd.addColorStop(1, this.color2);
            fillStyle = grd;
          } else {
            fillStyle = this.color;
          }
          context.fillStyle = fillStyle;
          context.fillRect(x, y, width, height);
        }
        if (this.stroke != null && this.strokeThickness > 0) {
          context.strokeStyle = this.stroke;
          context.lineWidth = this.strokeThickness;
          context.strokeRect(x, y, width, height);
        }
      }
    }]);
    return InnerBounds;
  }(RenderBase);

  var GetValue$2R = Phaser.Utils.Objects.GetValue;
  var TextStyle = /*#__PURE__*/function () {
    function TextStyle(parent, config) {
      _classCallCheck(this, TextStyle);
      this.parent = parent;
      this.set(config);
    }
    _createClass(TextStyle, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          bold: this.bold,
          italic: this.italic,
          fontSize: this.fontSize,
          fontFamily: this.fontFamily,
          color: this.color,
          stroke: this.stroke,
          strokeThickness: this.strokeThickness,
          shaodwColor: this.shadowColor,
          shadowBlur: this.shadowBlur,
          shadowOffsetX: this.shadowOffsetX,
          shadowOffsetY: this.shadowOffsetY,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          leftSpace: this.leftSpace,
          rightSpace: this.rightSpace,
          backgroundHeight: this.backgroundHeight,
          backgroundBottomY: this.backgroundBottomY,
          align: this.align
        };
      }
    }, {
      key: "set",
      value: function set(o) {
        this.setBold(GetValue$2R(o, 'bold', false));
        this.setItalic(GetValue$2R(o, 'italic', false));
        this.setFontSize(GetValue$2R(o, 'fontSize', '16px'));
        this.setFontFamily(GetValue$2R(o, 'fontFamily', 'Courier'));
        this.setColor(GetValue$2R(o, 'color', '#fff'));
        this.setStrokeStyle(GetValue$2R(o, 'stroke', null), GetValue$2R(o, 'strokeThickness', 0));
        this.setShadow(GetValue$2R(o, 'shadowColor', null), GetValue$2R(o, 'shadowOffsetX', 0), GetValue$2R(o, 'shadowOffsetY', 0), GetValue$2R(o, 'shadowBlur', 0));
        this.setOffset(GetValue$2R(o, 'offsetX', 0), GetValue$2R(o, 'offsetY', 0));
        this.setSpace(GetValue$2R(o, 'leftSpace', 0), GetValue$2R(o, 'rightSpace', 0));
        this.setAlign(GetValue$2R(o, 'align', undefined));
        this.setBackgroundColor(GetValue$2R(o, 'backgroundColor', null));
        this.setBackgroundHeight(GetValue$2R(o, 'backgroundHeight', undefined));
        this.setBackgroundBottomY(GetValue$2R(o, 'backgroundBottomY', undefined));
        return this;
      }
    }, {
      key: "modify",
      value: function modify(o) {
        if (o.hasOwnProperty('bold')) {
          this.setBold(o.bold);
        }
        if (o.hasOwnProperty('italic')) {
          this.setItalic(o.italic);
        }
        if (o.hasOwnProperty('fontSize')) {
          this.setFontSize(o.fontSize);
        }
        if (o.hasOwnProperty('fontFamily')) {
          this.setFontFamily(o.fontFamily);
        }
        if (o.hasOwnProperty('color')) {
          this.setColor(o.color);
        }
        if (o.hasOwnProperty('stroke') || o.hasOwnProperty('strokeThickness')) {
          this.setStrokeStyle(GetProperty('stroke', o, this), GetProperty('strokeThickness', o, this));
        }
        if (o.hasOwnProperty('shadowColor')) {
          this.setShadowColor(o.shadowColor);
        }
        if (o.hasOwnProperty('shadowOffsetX') || o.hasOwnProperty('shadowOffsetY')) {
          this.setShadowOffset(GetProperty('shadowOffsetX', o, this), GetProperty('shadowOffsetY', o, this));
        }
        if (o.hasOwnProperty('shadowBlur')) {
          this.setShadowBlur(o.shaodwBlur);
        }
        if (o.hasOwnProperty('offsetX')) {
          this.setOffsetX(o.offsetX);
        }
        if (o.hasOwnProperty('offsetY')) {
          this.setOffsetY(o.offsetY);
        }
        if (o.hasOwnProperty('leftSpace')) {
          this.setLeftSpace(o.leftSpace);
        }
        if (o.hasOwnProperty('rightSpace')) {
          this.setRightSpace(o.rightSpace);
        }
        if (o.hasOwnProperty('align')) {
          this.setAlign(o.align);
        }
        if (o.hasOwnProperty('backgroundColor')) {
          this.setBackgroundColor(o.backgroundColor);
        }
        if (o.hasOwnProperty('backgroundHeight')) {
          this.setBackgroundHeight(o.backgroundHeight);
        }
        if (o.hasOwnProperty('backgroundBottomY')) {
          this.setBackgroundBottomY(o.backgroundBottomY);
        }
        return this;
      }
    }, {
      key: "setUpdateTextFlag",
      value: function setUpdateTextFlag() {
        if (this.parent) {
          this.parent.updateTextFlag = true;
        }
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new TextStyle(null, this.toJSON());
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(sourceTextStyle) {
        this.set(sourceTextStyle.toJSON());
        return this;
      }
    }, {
      key: "copyTo",
      value: function copyTo(targetTextStyle) {
        targetTextStyle.set(this.toJSON());
        return this;
      }
    }, {
      key: "setBold",
      value: function setBold(value) {
        if (value === undefined) {
          value = true;
        }
        this.bold = value;
        this.setUpdateTextFlag();
        return this;
      }
    }, {
      key: "setItalic",
      value: function setItalic(value) {
        if (value === undefined) {
          value = true;
        }
        this.italic = value;
        this.setUpdateTextFlag();
        return this;
      }
    }, {
      key: "fontStyle",
      get: function get() {
        if (this.bold && this.italic) {
          return 'bold italic';
        } else if (this.bold) {
          return 'bold';
        } else if (this.italic) {
          return 'italic';
        } else {
          return '';
        }
      }
    }, {
      key: "setFontSize",
      value: function setFontSize(fontSize) {
        if (typeof fontSize === 'number') {
          fontSize = "".concat(fontSize, "px");
        }
        this.fontSize = fontSize;
        this.setUpdateTextFlag();
        return this;
      }
    }, {
      key: "setFontFamily",
      value: function setFontFamily(fontFamily) {
        this.fontFamily = fontFamily;
        this.setUpdateTextFlag();
        return this;
      }
    }, {
      key: "font",
      get: function get() {
        return "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily);
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color = GetStyle(color);
        return this;
      }
    }, {
      key: "hasFill",
      get: function get() {
        return this.color != null;
      }
    }, {
      key: "setStrokeStyle",
      value: function setStrokeStyle(stroke, strokeThickness) {
        this.stroke = GetStyle(stroke);
        if (strokeThickness !== undefined) {
          this.strokeThickness = strokeThickness;
        }
        return this;
      }
    }, {
      key: "setStrokeThickness",
      value: function setStrokeThickness(strokeThickness) {
        this.strokeThickness = strokeThickness;
        return this;
      }
    }, {
      key: "hasStroke",
      get: function get() {
        return this.stroke != null && this.strokeThickness > 0;
      }
    }, {
      key: "setShadowColor",
      value: function setShadowColor(color) {
        this.shadowColor = GetStyle(color);
        return this;
      }
    }, {
      key: "setShadowOffset",
      value: function setShadowOffset(offsetX, offsetY) {
        if (offsetX === undefined) {
          offsetX = 0;
        }
        if (offsetY === undefined) {
          offsetY = 0;
        }
        this.shadowOffsetX = offsetX;
        this.shadowOffsetY = offsetY;
        return this;
      }
    }, {
      key: "setShadowBlur",
      value: function setShadowBlur(blur) {
        if (blur === undefined) {
          blur = 0;
        }
        this.shaodwBlur = blur;
        return this;
      }
    }, {
      key: "setShadow",
      value: function setShadow(color, offsetX, offsetY, blur) {
        this.setShadowColor(color).setShadowOffset(offsetX, offsetY).setShadowBlur(blur);
        return this;
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color) {
        this.backgroundColor = GetStyle(color);
        return this;
      }
    }, {
      key: "hasBackgroundColor",
      get: function get() {
        return this.backgroundColor != null;
      }
    }, {
      key: "setBackgroundHeight",
      value: function setBackgroundHeight(height) {
        this.backgroundHeight = height;
        return this;
      }
    }, {
      key: "setBackgroundBottomY",
      value: function setBackgroundBottomY(y) {
        this.backgroundBottomY = y;
        return this;
      }
    }, {
      key: "setOffsetX",
      value: function setOffsetX(offsetX) {
        if (offsetX === undefined) {
          offsetX = 0;
        }
        this.offsetX = offsetX;
        return this;
      }
    }, {
      key: "setOffsetY",
      value: function setOffsetY(offsetY) {
        if (offsetY === undefined) {
          offsetY = 0;
        }
        this.offsetY = offsetY;
        return this;
      }
    }, {
      key: "setOffset",
      value: function setOffset(offsetX, offsetY) {
        this.setOffsetX(offsetX).setOffsetY(offsetY);
        return this;
      }
    }, {
      key: "setLeftSpace",
      value: function setLeftSpace(space) {
        if (space === undefined) {
          space = 0;
        }
        this.leftSpace = space;
        return this;
      }
    }, {
      key: "setRightSpace",
      value: function setRightSpace(space) {
        if (space === undefined) {
          space = 0;
        }
        this.rightSpace = space;
        return this;
      }
    }, {
      key: "setSpace",
      value: function setSpace(leftSpace, rightSpace) {
        this.setLeftSpace(leftSpace).setRightSpace(rightSpace);
        return this;
      }
    }, {
      key: "setAlign",
      value: function setAlign(align) {
        this.align = align;
        return this;
      }
    }, {
      key: "syncFont",
      value: function syncFont(context) {
        context.font = this.font;
        return this;
      }
    }, {
      key: "syncStyle",
      value: function syncStyle(context) {
        context.textBaseline = 'alphabetic';
        var hasFill = this.hasFill;
        var hasStroke = this.hasStroke;
        context.fillStyle = hasFill ? this.color : '#000';
        context.strokeStyle = hasStroke ? this.stroke : '#000';
        context.lineWidth = hasStroke ? this.strokeThickness : 0;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        return this;
      }
    }, {
      key: "syncShadow",
      value: function syncShadow(context) {
        if (context.shadowColor != null) {
          context.shadowColor = this.shadowColor;
          context.shadowOffsetX = this.shadowOffsetX;
          context.shadowOffsetY = this.shadowOffsetY;
          context.shadowBlur = this.shadowBlur;
        } else {
          context.shadowColor = 0;
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
          context.shadowBlur = 0;
        }
      }
    }, {
      key: "getTextMetrics",
      value: function getTextMetrics(context, text) {
        this.syncFont(context).syncStyle(context);
        return context.measureText(text);
      }
    }]);
    return TextStyle;
  }();

  var SetFixedSize = function SetFixedSize(width, height) {
    if (width === undefined) {
      width = 0;
    }
    if (height === undefined) {
      height = 0;
    }
    if (this.fixedWidth === width && this.fixedHeight === height) {
      return this;
    }
    this.fixedWidth = width;
    this.fixedHeight = height;
    this.dirty = true; // -> this.updateTexture();

    this.setCanvasSize(width > 0 ? width : this.width, height > 0 ? height : this.height);
    return this;
  };

  var SetPadding = function SetPadding(key, value) {
    var padding = this.padding;
    var paddingLeft = padding.left,
      paddingRight = padding.right,
      paddingTop = padding.top,
      paddingBottom = padding.bottom;
    SetPadding$1(padding, key, value);
    this.dirty = this.dirty || paddingLeft != padding.left || paddingRight != padding.right || paddingTop != padding.top || paddingBottom != padding.bottom;
    return this;
  };

  var GetPadding = function GetPadding(key) {
    return GetPadding$1(this.padding, key);
  };

  var ModifyTextStyle = function ModifyTextStyle(style) {
    this.textStyle.modify(style);
    return this;
  };

  var ModifyDefaultTextStyle = function ModifyDefaultTextStyle(style) {
    this.defaultTextStyle.modify(style);
    return this;
  };

  var ResetTextStyle = function ResetTextStyle() {
    this.textStyle.copyFrom(this.defaultTextStyle);
    return this;
  };

  var SetTestString = function SetTestString(testString) {
    this.testString = testString;
    return this;
  };

  var RemoveItem$9 = Phaser.Utils.Array.Remove;
  var RemoveChild$2 = function RemoveChild(child) {
    this.poolManager.free(child);
    RemoveItem$9(this.children, child);
    this.lastAppendedChildren.length = 0;
    this.lastOverChild = null;
    this.dirty = true;
    return this;
  };

  var RemoveChildren = function RemoveChildren() {
    this.poolManager.freeMultiple(this.children);
    this.children.length = 0;
    this.lastAppendedChildren.length = 0;
    this.lastOverChild = null;
    this.dirty = true;
    return this;
  };

  var RemoveItem$8 = Phaser.Utils.Array.Remove;
  var PopChild = function PopChild(child) {
    RemoveItem$8(this.children, child);
    this.lastAppendedChildren.length = 0;
    this.lastOverChild = null;
    this.dirty = true;
    return this;
  };

  var ClearContent = function ClearContent() {
    this.setText();
    return this;
  };

  // const RemoveItem = Phaser.Utils.Array.Remove;

  var AddChild$3 = function AddChild(child, index) {
    var areChildren = Array.isArray(child);

    // Remove existed child(s)
    // RemoveItem(this.children, child);

    if (index === undefined || index === this.children.length) {
      if (areChildren) {
        var _this$children;
        (_this$children = this.children).push.apply(_this$children, _toConsumableArray(child));
      } else {
        this.children.push(child);
      }
    } else {
      if (areChildren) {
        var _this$children2;
        (_this$children2 = this.children).splice.apply(_this$children2, [index, 0].concat(_toConsumableArray(child)));
      } else {
        this.children.splice(index, 0, child);
      }
    }
    this.lastAppendedChildren.length = 0;
    if (areChildren) {
      var _this$lastAppendedChi;
      (_this$lastAppendedChi = this.lastAppendedChildren).push.apply(_this$lastAppendedChi, _toConsumableArray(child));
    } else {
      this.lastAppendedChildren.push(child);
    }
    return this;
  };

  var CharTypeName = 'text';
  var ImageTypeName = 'image';
  var DrawerTypeName = 'drawer';
  var SpaceTypeName = 'space';
  var CmdTypeName = 'command';
  var IsNewLineChar = function IsNewLineChar(bob) {
    return bob.type === CharTypeName && bob.text === '\n';
  };
  var IsPageBreakChar = function IsPageBreakChar(bob) {
    return bob.type === CharTypeName && bob.text === '\f';
  };
  var IsSpaceChar = function IsSpaceChar(bob) {
    return bob.type === CharTypeName && bob.text === ' ';
  };
  var IsChar = function IsChar(bob) {
    return bob.type === CharTypeName;
  };
  var IsCommand = function IsCommand(bob) {
    return bob.type === CmdTypeName;
  };

  var CharData = /*#__PURE__*/function (_RenderBase) {
    _inherits(CharData, _RenderBase);
    function CharData(parent, text, style) {
      var _this;
      _classCallCheck(this, CharData);
      _this = _callSuper(this, CharData, [parent, CharTypeName]);
      _this.updateTextFlag = false;
      _this.style = new TextStyle(_assertThisInitialized(_this), style);
      _this.setText(text);
      return _this;
    }
    _createClass(CharData, [{
      key: "autoRound",
      get: function get() {
        return this.parent.autoRound;
      }
    }, {
      key: "offsetX",
      get: function get() {
        return this.style.offsetX;
      },
      set: function set(value) {
        if (this.style) {
          this.style.offsetX = value;
        }
      }
    }, {
      key: "offsetY",
      get: function get() {
        return this.style.offsetY;
      },
      set: function set(value) {
        if (this.style) {
          this.style.offsetY = value;
        }
      }
    }, {
      key: "leftSpace",
      get: function get() {
        return this.style.leftSpace * this.scaleX;
      },
      set: function set(value) {
        if (this.style) {
          this.style.leftSpace = value;
        }
        _set(_getPrototypeOf(CharData.prototype), "leftSpace", value, this, true);
      }
    }, {
      key: "rightSpace",
      get: function get() {
        return this.style.rightSpace * this.scaleX;
      },
      set: function set(value) {
        if (this.style) {
          this.style.rightSpace = value;
        }
        _set(_getPrototypeOf(CharData.prototype), "rightSpace", value, this, true);
      }
    }, {
      key: "align",
      get: function get() {
        return this.style.align;
      },
      set: function set(value) {
        if (this.style) {
          this.style.align = value;
        }
      }
    }, {
      key: "modifyStyle",
      value: function modifyStyle(style) {
        this.setDirty(true);
        this.style.modify(style);
        if (this.updateTextFlag) {
          this.updateTextSize();
        }
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (!o) {
          return this;
        }
        this.modifyStyle(o);
        _get(_getPrototypeOf(CharData.prototype), "modifyPorperties", this).call(this, o);
        return this;
      }
    }, {
      key: "setText",
      value: function setText(text) {
        this.setDirty(this.text != text);
        this.text = text;
        this.updateTextSize();
        return this;
      }
    }, {
      key: "updateTextSize",
      value: function updateTextSize() {
        var text = this.text;
        // Is new-line, page-break, or empty character
        if (text === '\n' || text === '\f' || text === '') {
          this.clearTextSize();
        } else {
          var metrics = this.style.getTextMetrics(this.context, this.text);
          this.textWidth = metrics.width;
          var ascent, descent;
          if ('actualBoundingBoxAscent' in metrics) {
            ascent = metrics.actualBoundingBoxAscent;
            descent = metrics.actualBoundingBoxDescent;
          } else {
            ascent = 0;
            descent = 0;
          }
          this.textHeight = ascent + descent;
          this.ascent = ascent;
          this.descent = descent;
        }
        this.updateTextFlag = false;
        return this;
      }
    }, {
      key: "clearTextSize",
      value: function clearTextSize() {
        this.textWidth = 0;
        this.textHeight = 0;
        this.ascent = 0;
        this.descent = 0;
        return this;
      }
    }, {
      key: "copyTextSize",
      value: function copyTextSize(child) {
        this.textWidth = child.textWidth;
        this.textHeight = child.textHeight;
        this.ascent = child.ascent;
        this.descent = child.descent;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this.textWidth * this.scaleX;
      },
      set: function set(value) {
        if (this.textWidth > 0) {
          this.scaleX = value / this.textWidth;
        } else {
          this.scaleX = 1;
        }
      }
    }, {
      key: "height",
      get: function get() {
        return this.textHeight * this.scaleY;
      },
      set: function set(value) {
        if (this.textHeight > 0) {
          this.scaleY = value / this.textHeight;
        } else {
          this.scaleY = 1;
        }
      }
    }, {
      key: "willRender",
      get: function get() {
        if (this.textWidth === 0) {
          return false;
        }
        return _get(_getPrototypeOf(CharData.prototype), "willRender", this);
      }
    }, {
      key: "renderContent",
      value: function renderContent() {
        var context = this.context;
        var textStyle = this.style;
        if (textStyle.hasBackgroundColor) {
          context.fillStyle = textStyle.backgroundColor;
          var x = this.drawTLX;
          var width = this.drawTRX - x;
          var bottomY = textStyle.backgroundBottomY;
          if (bottomY == null) {
            bottomY = this.drawBLY;
          }
          var height = textStyle.backgroundHeight;
          if (height == null) {
            height = bottomY - this.drawTLY;
          }
          var y = bottomY - height;
          context.fillRect(x, y, width, height);
        }
        var hasFill = textStyle.hasFill,
          hasStroke = textStyle.hasStroke;
        if (!hasFill && !hasStroke) {
          return;
        }
        textStyle.syncFont(context).syncStyle(context);
        // textBaseline = 'alphabetic'

        if (hasStroke) {
          textStyle.syncShadow(context);
          context.strokeText(this.text, 0, 0);
        }
        if (hasFill) {
          textStyle.syncShadow(context);
          context.fillText(this.text, 0, 0);
        }
      }
    }, {
      key: "drawTLX",
      get: function get() {
        return -this.leftSpace;
      }
    }, {
      key: "drawTLY",
      get: function get() {
        return -this.ascent;
      }
    }, {
      key: "drawBLX",
      get: function get() {
        return -this.leftSpace;
      }
    }, {
      key: "drawBLY",
      get: function get() {
        return this.descent;
      }
    }, {
      key: "drawTRX",
      get: function get() {
        return this.textWidth + this.rightSpace;
      }
    }, {
      key: "drawTRY",
      get: function get() {
        return -this.ascent;
      }
    }, {
      key: "drawBRX",
      get: function get() {
        return this.textWidth + this.rightSpace;
      }
    }, {
      key: "drawBRY",
      get: function get() {
        return this.descent;
      }
    }]);
    return CharData;
  }(RenderBase);

  var CreateCharChild = function CreateCharChild(text, style) {
    if (style) {
      this.textStyle.modify(style);
    }
    var child = this.poolManager.allocate(CharTypeName);
    if (child === null) {
      child = new CharData(this,
      // parent
      text,
      // text
      this.textStyle) // style
      ;
    } else {
      child.setParent(this).setActive().modifyStyle(this.textStyle).setText(text);
    }
    return child;
  };

  var CreateCharChildren = function CreateCharChildren(text, style) {
    if (style) {
      this.textStyle.modify(style);
    }
    var children = [];
    for (var i = 0, cnt = text.length; i < cnt; i++) {
      var _char = text.charAt(i);
      var child = this.poolManager.allocate(CharTypeName);
      if (child === null) {
        child = new CharData(this,
        // parent
        _char,
        // text
        this.textStyle) // style
        ;
      } else {
        child.setParent(this).setActive().modifyStyle(this.textStyle).setText(_char);
      }
      // child.modifyPorperties(properties);  // Warning: Will modify text-style twice

      children.push(child);
    }
    return children;
  };

  var AppendText = function AppendText(text, style) {
    var children = this.createCharChildren(text, style);
    this.addChild(children);
    return this;
  };

  var SetText$2 = function SetText(text, style) {
    if (text === undefined) {
      text = '';
    }
    this.removeChildren();
    AppendText.call(this, text, style); // this.appendText might be override

    this.dirty = true;
    return this;
  };

  var InsertText = function InsertText(index, text, style) {
    var children = this.createCharChildren(text, style);
    index = this.getCharChildIndex(index, true);
    this.addChild(children, index);
    return this;
  };

  var RemoveText = function RemoveText(index, length) {
    if (length === undefined) {
      length = 1;
    }
    for (var i = 0; i < length; i++) {
      var childIndex = this.getCharChildIndex(index, true);
      if (childIndex === undefined) {
        break;
      }
      this.removeChild(this.children[childIndex]);
    }
    return this;
  };

  var GetText = function GetText(activeOnly) {
    var text = '';
    this.forEachCharChild(function (child) {
      text += child.text;
    }, undefined, activeOnly);
    return text;
  };

  Phaser.Display.Canvas.CanvasPool;
  var ImageData = /*#__PURE__*/function (_RenderBase) {
    _inherits(ImageData, _RenderBase);
    function ImageData(parent, key, frame) {
      var _this;
      _classCallCheck(this, ImageData);
      _this = _callSuper(this, ImageData, [parent, ImageTypeName]);
      _this.setTexture(key, frame);
      _this.color = undefined;
      return _this;
    }
    _createClass(ImageData, [{
      key: "frameWidth",
      get: function get() {
        return this.frameObj ? this.frameObj.cutWidth : 0;
      }
    }, {
      key: "frameHeight",
      get: function get() {
        return this.frameObj ? this.frameObj.cutHeight : 0;
      }
    }, {
      key: "offsetY",
      get: function get() {
        return -this.height;
      },
      set: function set(value) {}
    }, {
      key: "key",
      get: function get() {
        return this._key;
      },
      set: function set(value) {
        this.setDirty(this._key != value);
        this._key = value;
      }
    }, {
      key: "frame",
      get: function get() {
        return this._frame;
      },
      set: function set(value) {
        this.setDirty(this._frame != value);
        this._frame = value;
      }
    }, {
      key: "setTexture",
      value: function setTexture(key, frame) {
        this.key = key;
        this.frame = frame;
        this.frameObj = this.scene.sys.textures.getFrame(key, frame);
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this.frameWidth * this.scaleX;
      },
      set: function set(value) {
        this.setDirty(this.width !== value);
        this.scaleX = value / this.frameWidth;
      }
    }, {
      key: "height",
      get: function get() {
        return this.frameHeight * this.scaleY;
      },
      set: function set(value) {
        this.setDirty(this.height !== value);
        this.scaleY = value / this.frameHeight;
      }
    }, {
      key: "setHeight",
      value: function setHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }
        this.height = height;
        if (keepAspectRatio) {
          this.scaleX = this.scaleY;
        }
        return this;
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color = color;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (o.hasOwnProperty('color')) {
          this.setColor(o.color);
        }
        _get(_getPrototypeOf(ImageData.prototype), "modifyPorperties", this).call(this, o);
        return this;
      }
    }, {
      key: "renderContent",
      value: function renderContent() {
        DrawFrameToCanvas(this.frameObj, this.canvas, 0, 0, this.frameWidth, this.frameHeight, this.color, false);
      }
    }, {
      key: "drawTLX",
      get: function get() {
        return -this.leftSpace;
      }
    }, {
      key: "drawTLY",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawBLX",
      get: function get() {
        return -this.leftSpace;
      }
    }, {
      key: "drawBLY",
      get: function get() {
        return this.frameHeight;
      }
    }, {
      key: "drawTRX",
      get: function get() {
        return this.frameWidth + this.rightSpace;
      }
    }, {
      key: "drawTRY",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawBRX",
      get: function get() {
        return this.frameWidth + this.rightSpace;
      }
    }, {
      key: "drawBRY",
      get: function get() {
        return this.frameHeight;
      }
    }]);
    return ImageData;
  }(RenderBase);

  var CreateImageChild = function CreateImageChild(key, frame, properties) {
    var child = this.poolManager.allocate(ImageTypeName);
    if (child === null) {
      child = new ImageData(this,
      // parent
      key, frame);
    } else {
      child.setParent(this).setActive().setTexture(key, frame);
    }
    child.modifyPorperties(properties);
    return child;
  };

  var AppendImage = function AppendImage(key, frame, properties) {
    var child = this.createImageChild(key, frame, properties);
    this.addChild(child);
    return this;
  };

  var Drawer = /*#__PURE__*/function (_RenderBase) {
    _inherits(Drawer, _RenderBase);
    function Drawer(parent, renderCallback, width, height) {
      var _this;
      _classCallCheck(this, Drawer);
      _this = _callSuper(this, Drawer, [parent, DrawerTypeName]);
      _this.setRenderCallback(renderCallback);
      _this.setDrawerSize(width, height);
      return _this;
    }
    _createClass(Drawer, [{
      key: "setRenderCallback",
      value: function setRenderCallback(callback) {
        if (callback) {
          this.renderContent = callback.bind(this);
        } else {
          delete this.renderContent;
        }
        return this;
      }
    }, {
      key: "setDrawerSize",
      value: function setDrawerSize(width, height) {
        // Whole canvas
        if (width === true) {
          this.toLocalPosition = false;
          width = undefined;
          height = undefined;
        } else {
          this.toLocalPosition = true;
        }
        if (width === undefined) {
          width = 0;
        }
        if (height === undefined) {
          height = width;
        }
        this.drawerWidth = width;
        this.drawerHeight = height;
        return this;
      }
    }, {
      key: "onFree",
      value: function onFree() {
        _get(_getPrototypeOf(Drawer.prototype), "onFree", this).call(this);
        this.setRenderCallback();
      }
    }, {
      key: "width",
      get: function get() {
        return this.drawerWidth * this.scaleX;
      },
      set: function set(value) {
        this.setDirty(this.width !== value);
        this.scaleX = this.drawerWidth > 0 ? value / this.drawerWidth : 1;
      }
    }, {
      key: "height",
      get: function get() {
        return this.drawerHeight * this.scaleY;
      },
      set: function set(value) {
        this.setDirty(this.height !== value);
        this.scaleY = this.drawerHeight > 0 ? value / this.drawerHeight : 1;
      }
    }, {
      key: "offsetY",
      get: function get() {
        return -this.height;
      },
      set: function set(value) {}
    }, {
      key: "drawTLX",
      get: function get() {
        return -this.leftSpace;
      }
    }, {
      key: "drawTLY",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawBLX",
      get: function get() {
        return -this.leftSpace;
      }
    }, {
      key: "drawBLY",
      get: function get() {
        return this.drawerHeight;
      }
    }, {
      key: "drawTRX",
      get: function get() {
        return this.drawerWidth + this.rightSpace;
      }
    }, {
      key: "drawTRY",
      get: function get() {
        return 0;
      }
    }, {
      key: "drawBRX",
      get: function get() {
        return this.drawerWidth + this.rightSpace;
      }
    }, {
      key: "drawBRY",
      get: function get() {
        return this.drawerHeight;
      }
    }]);
    return Drawer;
  }(RenderBase);

  var CreateDrawerChild = function CreateDrawerChild(renderCallback, width, height) {
    var child = this.poolManager.allocate(DrawerTypeName);
    if (child === null) {
      child = new Drawer(this,
      // parent
      renderCallback, width, height);
    } else {
      child.setParent(this).setActive().setRenderCallback(renderCallback).setDrawerSize(width, height);
    }
    return child;
  };

  var AppendDrawer = function AppendDrawer(renderCallback, width, height) {
    var child = this.createDrawerChild(renderCallback, width, height);
    this.addChild(child);
    return this;
  };

  var Space$1 = /*#__PURE__*/function (_RenderBase) {
    _inherits(Space, _RenderBase);
    function Space(parent, width) {
      var _this;
      _classCallCheck(this, Space);
      _this = _callSuper(this, Space, [parent, SpaceTypeName]);
      _this.setSpaceWidth(width);
      return _this;
    }
    _createClass(Space, [{
      key: "width",
      get: function get() {
        return this.spaceWidth * this.scaleX;
      },
      set: function set(value) {
        if (this.spaceWidth > 0) {
          this.scaleX = value / this.spaceWidth;
        } else {
          this.scaleX = 1;
        }
      }
    }, {
      key: "setSpaceWidth",
      value: function setSpaceWidth(width) {
        this.spaceWidth = width;
        return this;
      }
    }]);
    return Space;
  }(RenderBase);

  var CreateSpaceChild = function CreateSpaceChild(width) {
    var child = this.poolManager.allocate(SpaceTypeName);
    if (child === null) {
      child = new Space$1(this,
      // parent
      width);
    } else {
      child.setParent(this).setActive().setSpaceWidth(width);
    }
    return child;
  };

  var AppendSpace = function AppendSpace(width) {
    var child = this.createSpaceChild(width);
    this.addChild(child);
    return this;
  };

  var Command = /*#__PURE__*/function (_Base) {
    _inherits(Command, _Base);
    function Command(parent, name, callback, param, scope) {
      var _this;
      _classCallCheck(this, Command);
      _this = _callSuper(this, Command, [parent, CmdTypeName]);
      _this.setName(name).setParameter(param).setCallback(callback, scope);
      return _this;
    }
    _createClass(Command, [{
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "setParameter",
      value: function setParameter(param) {
        this.param = param;
        return this;
      }
    }, {
      key: "setCallback",
      value: function setCallback(callback, scope) {
        this.callback = callback;
        this.scope = scope;
        return this;
      }
    }, {
      key: "exec",
      value: function exec() {
        var result;
        if (this.scope) {
          result = this.callback.call(this.scope, this.param, this.name);
        } else {
          result = this.callback(this.param, this.name);
        }
        return result;
      }
    }, {
      key: "onFree",
      value: function onFree() {
        _get(_getPrototypeOf(Command.prototype), "onFree", this).call(this);
        this.setName().setCallback().setParameter();
      }
    }]);
    return Command;
  }(Base$2);

  var CreateCommandChild = function CreateCommandChild(name, callback, param, scope) {
    var child = this.poolManager.allocate(CmdTypeName);
    if (child === null) {
      child = new Command(this,
      // parent
      name, callback, param, scope);
    } else {
      child.setParent(this).setActive().setName(name).setCallback(callback, scope).setParameter(param);
    }
    return child;
  };

  var AppendCommand$3 = function AppendCommand(name, callback, param, scope) {
    var child = this.createCommandChild(name, callback, param, scope);
    this.addChild(child);
    return this;
  };

  var SetWrapConfig = function SetWrapConfig(config) {
    if (config === undefined) {
      config = {};
    } else if (_typeof(config) === 'object') {
      config = DeepClone(config);
    }
    this.wrapConfig = config;
    return this;
  };

  var CreateWrapResultData = function CreateWrapResultData(config) {
    var data = {
      callback: undefined,
      start: 0,
      // Next start index
      isLastPage: false,
      // Is last page
      maxLines: undefined,
      padding: undefined,
      letterSpacing: undefined,
      hAlign: undefined,
      vAlign: undefined,
      children: [],
      // Wrap result
      lines: [],
      // Wrap result in lines

      // WordWrap
      maxLineWidth: 0,
      linesHeight: 0,
      lineHeight: undefined,
      // VerticalWrap
      maxLineHeight: 0,
      linesWidth: 0,
      lineWidth: undefined
    };
    return Object.assign(data, config);
  };

  var GetWord = function GetWord(children, startIndex, charMode, result) {
    if (result === undefined) {
      result = {
        word: [],
        width: 0
      };
    }
    result.word.length = 0;
    var endIndex = children.length;
    var currentIndex = startIndex;
    var word = result.word,
      wordWidth = 0;
    while (currentIndex < endIndex) {
      var child = children[currentIndex];
      // Can't render (command child), put into output directly
      if (!child.renderable) {
        word.push(child);
        currentIndex++;
        continue;
      }
      var text = child.type === CharTypeName ? child.text : null;
      if (text !== null && text !== ' ' && text !== '\n' && text !== '\f') {
        word.push(child);
        wordWidth += child.outerWidth;
        currentIndex++;
        // Continue
      } else {
        // Get image child, a space, a new-line, or page-break
        if (currentIndex === startIndex) {
          // Single child
          word.push(child);
          wordWidth += child.outerWidth;
        }
        break;
      }
      if (charMode) {
        // Word only contains 1 character
        break;
      }
    }
    result.width = wordWidth;
    return result;
  };

  var GetChildrenAlign = function GetChildrenAlign(children) {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (child.align !== undefined) {
        return child.align;
      }
    }
    return undefined;
  };

  var OffsetChildren = function OffsetChildren(children, offsetX, offsetY) {
    if (offsetX === 0 && offsetY === 0) {
      return;
    }
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (!child.renderable) {
        continue;
      }
      child.x += offsetX;
      child.y += offsetY;
    }
  };

  var AlignLines$1 = function AlignLines(result, width, height) {
    var hAlign = result.hAlign,
      vAlign = result.vAlign;
    var offsetX, offsetY;
    var linesHeight = result.linesHeight;
    switch (vAlign) {
      case 1: // center
      case 'center':
        offsetY = (height - linesHeight) / 2;
        break;
      case 2: // bottom
      case 'bottom':
        offsetY = height - linesHeight;
        break;
      default:
        offsetY = 0;
        break;
    }
    var lines = result.lines;
    for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
      var line = lines[li];
      var lineWidth = line.width,
        children = line.children;
      var lineHAlign = GetChildrenAlign(children);
      if (lineHAlign === undefined) {
        lineHAlign = hAlign;
      }
      switch (lineHAlign) {
        case 1: // center
        case 'center':
          offsetX = (width - lineWidth) / 2;
          break;
        case 2: // right
        case 'right':
          offsetX = width - lineWidth;
          break;
        default:
          offsetX = 0;
          break;
      }
      OffsetChildren(children, offsetX, offsetY);
    }
  };

  var GetDefaultTextHeight = function GetDefaultTextHeight() {
    var metrics = this.defaultTextStyle.getTextMetrics(this.context, this.testString);
    var ascent, descent;
    if ('actualBoundingBoxAscent' in metrics) {
      ascent = metrics.actualBoundingBoxAscent;
      descent = metrics.actualBoundingBoxDescent;
    } else {
      ascent = 0;
      descent = 0;
    }
    Result.ascent = ascent;
    Result.descent = descent;
    Result.height = ascent + descent;
    return Result;
  };
  var Result = {};

  var GetValue$2Q = Phaser.Utils.Objects.GetValue;
  var RunWordWrap$1 = function RunWordWrap(config) {
    // Parse parameters
    var startIndex = GetValue$2Q(config, 'start', 0);
    SetPadding$1(this.wrapPadding, GetValue$2Q(config, 'padding', 0));
    var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
    var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;

    // Get lineHeight, maxLines
    var lineHeight = GetValue$2Q(config, 'lineHeight');
    var ascent = GetValue$2Q(config, 'ascent', lineHeight);
    var maxLines;
    if (lineHeight === undefined) {
      // Calculate lineHeight
      var useDefaultTextHeight = GetValue$2Q(config, 'useDefaultTextHeight', false);
      maxLines = GetValue$2Q(config, 'maxLines', 0);
      if (this.fixedHeight > 0 && !useDefaultTextHeight) {
        var innerHeight = this.fixedHeight - paddingVertical;
        if (maxLines > 0) {
          // Calculate lineHeight via maxLines, in fixedHeight mode
          lineHeight = innerHeight / maxLines;
        } else {
          var textHeightResult = GetDefaultTextHeight.call(this);
          lineHeight = textHeightResult.height;
          ascent = textHeightResult.ascent;
          // Calculate maxLines via (ascent, lineHeight), in fixedHeight mode
          maxLines = Math.floor((innerHeight - ascent) / lineHeight);
        }
      } else {
        var textHeightResult = GetDefaultTextHeight.call(this);
        lineHeight = textHeightResult.height;
        ascent = textHeightResult.ascent;
      }
    } else {
      // Calculate maxLines
      if (this.fixedHeight > 0) {
        // Calculate maxLines via lineHeight, in fixedHeight mode
        maxLines = GetValue$2Q(config, 'maxLines');
        if (maxLines === undefined) {
          var innerHeight = this.fixedHeight - paddingVertical;
          maxLines = Math.floor(innerHeight / lineHeight);
        }
      } else {
        maxLines = GetValue$2Q(config, 'maxLines', 0); // Default is show all lines
      }
    }

    // If ascent is undefined, assign to lineHeight
    if (ascent === undefined) {
      ascent = lineHeight;
    }
    var showAllLines = maxLines === 0;

    // Get wrapWidth
    var wrapWidth = GetValue$2Q(config, 'wrapWidth', undefined);
    if (wrapWidth === undefined) {
      if (this.fixedWidth > 0) {
        wrapWidth = this.fixedWidth - paddingHorizontal;
      } else {
        wrapWidth = Infinity; // No word-wrap
      }
    }
    var letterSpacing = GetValue$2Q(config, 'letterSpacing', 0);
    var hAlign = GetValue$2Q(config, 'hAlign', 0);
    var vAlign = GetValue$2Q(config, 'vAlign', 0);
    var charWrap = GetValue$2Q(config, 'charWrap', false);
    var result = CreateWrapResultData({
      // Override properties
      callback: 'runWordWrap',
      start: startIndex,
      // Next start index
      padding: this.wrapPadding,
      letterSpacing: letterSpacing,
      maxLines: maxLines,
      hAlign: hAlign,
      vAlign: vAlign,
      // Specific properties
      ascent: ascent,
      lineHeight: lineHeight,
      wrapWidth: wrapWidth,
      charWrap: charWrap
    });

    // Set all children to inactive
    var children = this.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setActive(false);
    }

    // Layout children
    wrapWidth += letterSpacing;
    var startX = this.padding.left + this.wrapPadding.left,
      startY = this.padding.top + this.wrapPadding.top + ascent,
      // Start(baseline) from ascent, not 0
      x = startX,
      y = startY;
    var remainderWidth = wrapWidth,
      childIndex = startIndex,
      lastChildIndex = children.length;
    var resultChildren = result.children;
    var resultLines = result.lines,
      lastLine = [],
      lastLineWidth = 0,
      maxLineWidth = 0;
    var wordResult;
    var isPageBreakChar = false;
    while (childIndex < lastChildIndex) {
      wordResult = GetWord(children, childIndex, charWrap, wordResult);
      var word = wordResult.word;
      var charCnt = word.length;
      var wordWidth = wordResult.width + charCnt * letterSpacing;
      childIndex += charCnt;
      // Next line
      var isNewLineChar = IsNewLineChar(word[0]);
      isPageBreakChar = IsPageBreakChar(word[0]);
      var isControlChar = isNewLineChar || isPageBreakChar;
      if (remainderWidth < wordWidth || isControlChar) {
        // Add to result
        if (isControlChar) {
          var _char = word[0];
          _char.setActive().setPosition(x, y);
          resultChildren.push(_char);
          lastLine.push(_char);
        }

        // Move cursor
        x = startX;
        y += lineHeight;
        remainderWidth = wrapWidth;
        resultLines.push({
          children: lastLine,
          width: lastLineWidth
        });
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        lastLineWidth = 0;
        lastLine = [];
        var isPageEnd = isPageBreakChar || !showAllLines && resultLines.length === maxLines; // Exceed maxLines
        if (isPageEnd) {
          break;
        } else if (isControlChar) {
          // Already add to result
          continue;
        }
      }
      remainderWidth -= wordWidth;
      lastLineWidth += wordWidth;
      for (var i = 0, cnt = word.length; i < cnt; i++) {
        var child = word[i];
        child.setActive();
        resultChildren.push(child);
        lastLine.push(child);
        if (child.renderable) {
          child.setPosition(x, y);
          x += child.outerWidth + letterSpacing;
        }
      }
    }
    if (lastLine.length > 0) {
      resultLines.push({
        children: lastLine,
        width: lastLineWidth
      });
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
    }
    result.start += resultChildren.length;
    result.isLastPage = !isPageBreakChar && result.start === lastChildIndex;
    result.maxLineWidth = maxLineWidth;
    result.linesHeight = resultLines.length * lineHeight;

    // Calculate size of game object
    var width = this.fixedWidth > 0 ? this.fixedWidth : result.maxLineWidth + paddingHorizontal;
    var height = this.fixedHeight > 0 ? this.fixedHeight : result.linesHeight + paddingVertical;

    // Size might be changed after wrapping
    var innerWidth = width - paddingHorizontal;
    var innerHeight = height - paddingVertical;
    AlignLines$1(result, innerWidth, innerHeight);

    // Resize
    this.setCanvasSize(width, height);

    // Set initial position
    for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
      var child = resultChildren[i];
      if (!child.renderable) {
        continue;
      }
      child.x0 = child.x;
      child.y0 = child.y;
    }
    return result;
  };

  var Merge$3 = Phaser.Utils.Objects.Merge;
  var RunWordWrap = function RunWordWrap(config) {
    if (config === undefined) {
      config = {};
    }
    return RunWordWrap$1.call(this, Merge$3(config, this.wrapConfig));
  };

  var AlignLines = function AlignLines(result, width, height) {
    var hAlign = result.hAlign,
      vAlign = result.vAlign;
    var offsetX, offsetY;
    var rtl = result.rtl;
    var lines = result.lines,
      lineWidth = result.lineWidth,
      linesWidth = result.linesWidth;
    switch (hAlign) {
      case 1: // center
      case 'center':
        offsetX = (width - linesWidth) / 2;
        break;
      case 2: // right
      case 'right':
        offsetX = width - linesWidth;
        break;
      default:
        // left
        offsetX = 0;
        break;
    }
    if (rtl) {
      offsetX += lineWidth;
    }
    for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
      var line = lines[rtl ? lcnt - li - 1 : li];
      var children = line.children;
      var lineHeight = line.height;
      var lineVAlign = GetChildrenAlign(children);
      if (lineVAlign === undefined) {
        lineVAlign = vAlign;
      }
      switch (lineVAlign) {
        case 1: // center
        case 'center':
          offsetY = (height - lineHeight) / 2;
          break;
        case 2: // bottom
        case 'bottom':
          offsetY = height - lineHeight;
          break;
        default:
          // top
          offsetY = 0;
          break;
      }
      OffsetChildren(children, offsetX, offsetY);
      offsetX += lineWidth;
    }
  };

  var GetValue$2P = Phaser.Utils.Objects.GetValue;
  var RunVerticalWrap$1 = function RunVerticalWrap(config) {
    // Parse parameters
    var startIndex = GetValue$2P(config, 'start', 0);
    SetPadding$1(this.wrapPadding, GetValue$2P(config, 'padding', 0));
    var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
    var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
    var lineWidth = GetValue$2P(config, 'lineWidth', undefined);
    var maxLines;
    if (lineWidth === undefined) {
      // Calculate lineWidth via maxLines, in fixedWidth mode
      maxLines = GetValue$2P(config, 'maxLines', 0);
      if (this.fixedWidth > 0) {
        var innerWidth = this.fixedWidth - paddingHorizontal;
        lineWidth = innerWidth / maxLines;
      } else {
        lineWidth = 0;
      }
    } else {
      if (this.fixedWidth > 0) {
        // Calculate maxLines via lineWidth, in fixedWidth mode
        maxLines = GetValue$2P(config, 'maxLines', undefined);
        if (maxLines === undefined) {
          var innerWidth = this.fixedWidth - paddingHorizontal;
          maxLines = Math.floor(innerWidth / lineWidth) + 1;
        }
      } else {
        maxLines = GetValue$2P(config, 'maxLines', 0); // Default is show all lines
      }
    }
    var showAllLines = maxLines === 0;

    // Get fixedCharacterHeight
    var fixedCharacterHeight = GetValue$2P(config, 'fixedCharacterHeight', undefined);
    if (fixedCharacterHeight === undefined) {
      var charPerLine = GetValue$2P(config, 'charPerLine', undefined);
      if (charPerLine !== undefined) {
        var innerHeight = this.fixedHeight - paddingVertical;
        fixedCharacterHeight = Math.floor(innerHeight / charPerLine);
      }
    }

    // Get wrapHeight
    var wrapHeight = GetValue$2P(config, 'wrapHeight', undefined);
    if (wrapHeight === undefined) {
      if (this.fixedHeight > 0) {
        wrapHeight = this.fixedHeight - paddingVertical;
      } else {
        wrapHeight = Infinity; // No word-wrap
      }
    }
    var letterSpacing = GetValue$2P(config, 'letterSpacing', 0);
    var rtl = GetValue$2P(config, 'rtl', true);
    var hAlign = GetValue$2P(config, 'hAlign', rtl ? 2 : 0);
    var vAlign = GetValue$2P(config, 'vAlign', 0);
    var result = CreateWrapResultData({
      // Override properties
      callback: 'runVerticalWrap',
      start: startIndex,
      // Next start index
      padding: this.wrapPadding,
      letterSpacing: letterSpacing,
      maxLines: maxLines,
      hAlign: hAlign,
      vAlign: vAlign,
      // Specific properties
      lineWidth: lineWidth,
      fixedCharacterHeight: fixedCharacterHeight,
      wrapHeight: wrapHeight,
      rtl: rtl
    });

    // Set all children to active
    var children = this.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setActive(false);
    }

    // Layout children
    wrapHeight += letterSpacing;
    var startX = this.padding.left + this.wrapPadding.left,
      // Reset x of each character in AlignLines method
      startY = this.padding.top + this.wrapPadding.top,
      x = startX,
      y = startY;
    var remainderHeight = wrapHeight,
      childIndex = startIndex,
      lastChildIndex = children.length;
    var resultChildren = result.children;
    var resultLines = result.lines,
      lastLine = [],
      lastLineHeight = 0,
      maxLineHeight = 0;
    while (childIndex < lastChildIndex) {
      // Append non-typeable child directly
      var child = children[childIndex];
      childIndex++;
      if (!child.renderable) {
        child.setActive();
        resultChildren.push(child);
        lastLine.push(child);
        continue;
      }
      var childHeight = (fixedCharacterHeight !== undefined ? fixedCharacterHeight : child.height) + letterSpacing;
      // Next line
      var isNewLineChar = IsNewLineChar(child);
      var isPageBreakChar = IsPageBreakChar(child);
      var isControlChar = isNewLineChar || isPageBreakChar;
      if (remainderHeight < childHeight || isControlChar) {
        // Add to result
        if (isNewLineChar) {
          child.setActive().setPosition(x, y).setOrigin(0.5);
          resultChildren.push(child);
          lastLine.push(child);
        }

        // Move cursor
        x = startX;
        y = startY;
        remainderHeight = wrapHeight;
        resultLines.push({
          children: lastLine,
          height: lastLineHeight
        });
        maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
        lastLineHeight = 0;
        lastLine = [];
        var isPageEnd = isPageBreakChar || !showAllLines && resultLines.length === maxLines; // Exceed maxLines
        if (isPageEnd) {
          break;
        } else if (isControlChar) {
          // Already add to result                
          continue;
        }
      }
      remainderHeight -= childHeight;
      lastLineHeight += childHeight;
      child.setActive().setPosition(x, y).setOrigin(0.5);
      resultChildren.push(child);
      lastLine.push(child);
      y += childHeight;
    }
    if (lastLine.length > 0) {
      resultLines.push({
        children: lastLine,
        height: lastLineHeight
      });
      maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
    }
    result.start += resultChildren.length;
    result.isLastPage = result.start === lastChildIndex;
    result.maxLineHeight = maxLineHeight;
    result.linesWidth = resultLines.length * lineWidth;

    // Calculate size of game object
    var width = this.fixedWidth > 0 ? this.fixedWidth : result.linesWidth + paddingHorizontal;
    var height = this.fixedHeight > 0 ? this.fixedHeight : result.maxLineHeight + paddingVertical;

    // Size might be changed after wrapping
    var innerWidth = width - paddingHorizontal;
    var innerHeight = height - paddingVertical;
    AlignLines(result, innerWidth, innerHeight);

    // Resize
    this.setCanvasSize(width, height);

    // Set initial position
    for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
      var child = resultChildren[i];
      if (!child.renderable) {
        continue;
      }
      child.x0 = child.x;
      child.y0 = child.y;
    }
    return result;
  };

  var Merge$2 = Phaser.Utils.Objects.Merge;
  var RunVerticalWrap = function RunVerticalWrap(config) {
    if (config === undefined) {
      config = {};
    }
    return RunVerticalWrap$1.call(this, Merge$2(config, this.wrapConfig));
  };

  var GetValue$2O = Phaser.Utils.Objects.GetValue;
  var RunWrap = function RunWrap(config) {
    var wrapCallback = GetValue$2O(this.wrapConfig, 'callback');
    if (!wrapCallback) {
      wrapCallback = GetValue$2O(config, 'callback', this.runWordWrap);
    }
    if (typeof wrapCallback === 'string') {
      wrapCallback = this[wrapCallback];
    }
    return wrapCallback.call(this, config);
  };

  var SetAlignMethods = {
    setVAlign: function setVAlign(align) {
      this.wrapConfig.vAlign = align;
      return this;
    },
    setHAlign: function setHAlign(align) {
      this.wrapConfig.hAlign = align;
      return this;
    }
  };

  var SetTextOXYMethods$1 = {
    setTextOX: function setTextOX(ox) {
      if (ox === this._textOX) {
        return this;
      }
      this._textOX = ox;
      return this;
    },
    setTextOY: function setTextOY(oy) {
      if (oy === this._textOY) {
        return this;
      }
      this._textOY = oy;
      return this;
    },
    setTextOXY: function setTextOXY(ox, oy) {
      if (ox === this._textOX && oy === this._textOY) {
        return;
      }
      this._textOX = ox;
      this._textOY = oy;
      return this;
    },
    addTextOX: function addTextOX(incX) {
      this.setTextOX(this._textOX + incX);
      return this;
    },
    addTextOY: function addTextOY(incY) {
      this.setTextOY(this._textOY + incY);
      return this;
    },
    addTextOXY: function addTextOXY(incX, incY) {
      this.setTextOXY(this._textOX + incX, this._textOY + incY);
      return this;
    }
  };

  var RenderContent = function RenderContent() {
    this.clear();
    this.setCanvasSize(this.width, this.height);
    if (this.background.active) {
      this.background.render();
    }
    var child;
    for (var i = 0, cnt = this.children.length; i < cnt; i++) {
      child = this.children[i];
      if (child.active) {
        child.render();
      }
    }
    if (this.innerBounds.active) {
      this.innerBounds.render();
    }
  };

  var ForEachChild = function ForEachChild(callback, scope, activeOnly) {
    if (activeOnly === undefined) {
      activeOnly = true;
    }
    var children = this.children;
    var childIndex = 0;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (activeOnly && !child.active) {
        continue;
      }
      var isBreak;
      if (scope) {
        isBreak = callback.call(this, child, childIndex, children);
      } else {
        isBreak = callback(child, childIndex, children);
      }
      childIndex++;
      if (isBreak) {
        break;
      }
    }
    return this;
  };

  var ForEachRenderableChild = function ForEachRenderableChild(callback, scope, activeOnly) {
    if (activeOnly === undefined) {
      activeOnly = true;
    }
    var children = this.children;
    var childIndex = 0;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (activeOnly && !child.active) {
        continue;
      }
      if (child.renderable && !child.removed) {
        var isBreak;
        if (scope) {
          isBreak = callback.call(this, child, childIndex, children);
        } else {
          isBreak = callback(child, childIndex, children);
        }
        childIndex++;
        if (isBreak) {
          break;
        }
      }
    }
    return this;
  };

  var ForEachCharChild = function ForEachCharChild(callback, scope, activeOnly) {
    if (activeOnly === undefined) {
      activeOnly = true;
    }
    var children = this.children;
    var charIndex = 0;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (activeOnly && !child.active) {
        continue;
      }
      if (IsChar(child) && !child.removed) {
        var isBreak;
        if (scope) {
          isBreak = callback.call(this, child, charIndex, children);
        } else {
          isBreak = callback(child, charIndex, children);
        }
        charIndex++;
        if (isBreak) {
          break;
        }
      }
    }
    return this;
  };

  var GetChildren = function GetChildren() {
    return this.children;
  };

  var GetAll = Phaser.Utils.Array.GetAll;
  var GetActiveChildren = function GetActiveChildren() {
    return GetAll(this.children, 'active', true);
  };

  var GetCharChildren = function GetCharChildren(activeOnly, out) {
    if (out === undefined) {
      out = [];
    }
    this.forEachCharChild(function (child) {
      out.push(child);
    }, undefined, activeOnly);
    return out;
  };

  var GetLastAppendedChildren = function GetLastAppendedChildren() {
    return this.lastAppendedChildren;
  };

  var GetBobCenterPosition = function GetBobCenterPosition(bob, offsetX, offsetY, out) {
    if (typeof offsetX !== 'number') {
      out = offsetX;
      offsetX = 0;
      offsetY = 0;
    }
    var bobX = bob.drawCenterX + offsetX;
    var bobY = bob.drawCenterY + offsetY;
    return BobPositionToCanvasPosition(bob, bobX, bobY, out);
  };

  var GetDistance$1 = Phaser.Math.Distance.BetweenPointsSquared;
  var GetNearestChild = function GetNearestChild(canvasX, canvasY) {
    var pointA = {
      x: canvasX,
      y: canvasY
    };
    var minDistance = Infinity;
    var nearestChild = null;
    this.forEachRenderableChild(function (child) {
      var distance = GetDistance$1(pointA, GetBobCenterPosition(child, true));
      if (minDistance > distance) {
        minDistance = distance;
        nearestChild = child;
      }
    });
    return nearestChild;
  };

  var GetCharWorldPosition = function GetCharWorldPosition(child, offsetX, offsetY, out) {
    if (typeof child === 'number') {
      child = this.getCharChild(child, true);
    }
    return GetBobWorldPosition(this, child, offsetX, offsetY, out);
  };

  var SetToMinSize = function SetToMinSize() {
    var children = this.children;
    var maxX = 0,
      maxY = 0;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (!child.renderable || !child.active || !child.visible) {
        continue;
      }
      var x0 = child.x0 !== undefined ? child.x0 : child.x;
      var y0 = child.y0 !== undefined ? child.y0 : child.y;
      maxX = Math.max(maxX, x0);
      maxY = Math.max(maxY, y0);
    }
    var width = maxX + this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
    var height = maxY + this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;

    // Ignore fixedWidth, and fixedHeight
    if (this.width !== width || this.height !== height) {
      this.dirty = true;
      this.setCanvasSize(width, height);
    }
    return this;
  };

  var GetCharChildIndex = function GetCharChildIndex(charIndex, activeOnly) {
    if (activeOnly === undefined) {
      activeOnly = true;
    }
    var children = this.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (activeOnly && !child.active) {
        continue;
      }
      if (IsChar(child) && !child.removed) {
        if (charIndex === 0) {
          return i;
        } else {
          charIndex--;
        }
      }
    }
    return undefined;
  };

  var GetCharChild = function GetCharChild(charIndex, activeOnly) {
    if (activeOnly === undefined) {
      activeOnly = true;
    }
    var children = this.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (activeOnly && !child.active) {
        continue;
      }
      if (IsChar(child) && !child.removed) {
        if (charIndex === 0) {
          return child;
        } else {
          charIndex--;
        }
      }
    }
    return undefined;
  };

  var GetCharIndex = function GetCharIndex(childIndex, activeOnly) {
    if (typeof childIndex !== 'number') {
      childIndex = this.children.indexOf(childIndex);
      if (childIndex < 0) {
        return null;
      }
    }
    if (activeOnly === undefined) {
      activeOnly = true;
    }
    var children = this.children;
    if (childIndex >= children.length) {
      childIndex = children.length;
    }
    var charIndex = 0;
    for (var i = 0; i < childIndex; i++) {
      var child = children[i];
      if (activeOnly && !child.active) {
        continue;
      }
      if (IsChar(child) && !child.removed) {
        charIndex++;
      }
    }
    return charIndex;
  };

  var SetChildrenInteractiveEnable = function SetChildrenInteractiveEnable(enable) {
    if (enable === undefined) {
      enable = true;
    }
    if (this.childrenInteractiveEnable !== enable) {
      this.lastOverChild = null;
    }
    this.childrenInteractiveEnable = enable;
    return this;
  };

  var GetFirstChildContains = function GetFirstChildContains(children, x, y) {
    var children = children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (!child.active || !child.renderable) {
        continue;
      }
      if (child.contains(x, y)) {
        return child;
      }
    }
    return null;
  };

  var SetChildrenInteractive$1 = function SetChildrenInteractive() {
    this.on('pointerdown', OnPointerDown$1, this).on('pointerdown', OnPointerUp$1, this).on('pointermove', OnPointOverOut, this).on('pointerover', OnPointOverOut, this).on('pointerout', function (pointer, event) {
      OnPointOverOut.call(this, pointer, null, null, event);
    }, this);
    return this;
  };
  var OnPointerDown$1 = function OnPointerDown(pointer, localX, localY, event) {
    if (!this.childrenInteractiveEnable) {
      return;
    }
    var child = GetFirstChildContains(this.children, localX, localY);
    if (!child) {
      return;
    }
    this.emit('child.pointerdown', child, pointer, localX, localY, event);
  };
  var OnPointerUp$1 = function OnPointerUp(pointer, localX, localY, event) {
    if (!this.childrenInteractiveEnable) {
      return;
    }
    var child = GetFirstChildContains(this.children, localX, localY);
    if (!child) {
      return;
    }
    this.emit('child.pointerup', child, pointer, localX, localY, event);
  };
  var OnPointOverOut = function OnPointOverOut(pointer, localX, localY, event) {
    if (!this.childrenInteractiveEnable) {
      return;
    }
    if (localX === null) {
      // Case of pointerout
      if (this.lastOverChild !== null) {
        this.emit('child.pointerout', this.lastOverChild, pointer, localX, localY, event);
        this.lastOverChild = null;
      }
      return;
    }
    var child = GetFirstChildContains(this.children, localX, localY);
    if (child === this.lastOverChild) {
      return;
    }
    if (this.lastOverChild !== null) {
      this.emit('child.pointerout', this.lastOverChild, pointer, localX, localY, event);
    }
    if (child !== null) {
      this.emit('child.pointerover', child, pointer, localX, localY, event);
    }
    this.lastOverChild = child;
  };

  var GameObject = Phaser.GameObjects.GameObject;
  var SetInteractive = function SetInteractive(hitArea, hitAreaCallback, dropZone) {
    var isInteractived = !!this.input;
    GameObject.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);
    if (!isInteractived) {
      SetChildrenInteractive$1.call(this);
    }
    return this;
  };

  var BringToTop = Phaser.Utils.Array.BringToTop;
  var SendToBack = Phaser.Utils.Array.SendToBack;
  var MoveUp = Phaser.Utils.Array.MoveUp;
  var MoveDown = Phaser.Utils.Array.MoveDown;
  var MoveAbove = Phaser.Utils.Array.MoveAbove;
  var MoveBelow = Phaser.Utils.Array.MoveBelow;
  var MoveChildMethods = {
    moveChildToFist: function moveChildToFist(child) {
      SendToBack(this.children, child);
      return this;
    },
    moveChildToLast: function moveChildToLast(child) {
      BringToTop(this.children, child);
      return this;
    },
    movechildUp: function movechildUp(child) {
      MoveUp(this.children, child);
      return this;
    },
    movechildDown: function movechildDown(child) {
      MoveDown(this.children, child);
      return this;
    },
    movechildAbove: function movechildAbove(child, baseChild) {
      MoveAbove(this.children, child, baseChild);
      return this;
    },
    movechildBelow: function movechildBelow(child, baseChild) {
      MoveBelow(this.children, child, baseChild);
      return this;
    }
  };

  var BackgroundMethods = {
    setBackgroundColor: function setBackgroundColor(color, color2, isHorizontalGradient) {
      this.background.setColor(color, color2, isHorizontalGradient);
      return this;
    },
    setBackgroundStroke: function setBackgroundStroke(color, lineWidth) {
      this.background.setStroke(color, lineWidth);
      return this;
    },
    setBackgroundCornerRadius: function setBackgroundCornerRadius(radius, iteration) {
      this.background.setCornerRadius(radius, iteration);
      return this;
    }
  };

  var InnerBoundsMethods = {
    setInnerBoundsColor: function setInnerBoundsColor(color, color2, isHorizontalGradient) {
      this.innerBounds.setColor(color, color2, isHorizontalGradient);
      return this;
    },
    setInnerBoundsStroke: function setInnerBoundsStroke(color, lineWidth) {
      this.innerBounds.setStroke(color, lineWidth);
      return this;
    }
  };

  var Methods$e = {
    setFixedSize: SetFixedSize,
    setPadding: SetPadding,
    getPadding: GetPadding,
    modifyTextStyle: ModifyTextStyle,
    modifyDefaultTextStyle: ModifyDefaultTextStyle,
    resetTextStyle: ResetTextStyle,
    setTestString: SetTestString,
    removeChild: RemoveChild$2,
    removeChildren: RemoveChildren,
    popChild: PopChild,
    clearContent: ClearContent,
    addChild: AddChild$3,
    createCharChild: CreateCharChild,
    createCharChildren: CreateCharChildren,
    setText: SetText$2,
    appendText: AppendText,
    insertText: InsertText,
    removeText: RemoveText,
    getText: GetText,
    createImageChild: CreateImageChild,
    appendImage: AppendImage,
    createDrawerChild: CreateDrawerChild,
    appendDrawer: AppendDrawer,
    createSpaceChild: CreateSpaceChild,
    appendSpace: AppendSpace,
    createCommandChild: CreateCommandChild,
    appendCommand: AppendCommand$3,
    setWrapConfig: SetWrapConfig,
    runWordWrap: RunWordWrap,
    runVerticalWrap: RunVerticalWrap,
    runWrap: RunWrap,
    renderContent: RenderContent,
    forEachChild: ForEachChild,
    forEachRenderableChild: ForEachRenderableChild,
    forEachCharChild: ForEachCharChild,
    getChildren: GetChildren,
    getActiveChildren: GetActiveChildren,
    getCharChildren: GetCharChildren,
    getLastAppendedChildren: GetLastAppendedChildren,
    getNearestChild: GetNearestChild,
    getCharWorldPosition: GetCharWorldPosition,
    setToMinSize: SetToMinSize,
    getCharChildIndex: GetCharChildIndex,
    getCharChild: GetCharChild,
    getCharIndex: GetCharIndex,
    setChildrenInteractiveEnable: SetChildrenInteractiveEnable,
    setInteractive: SetInteractive
  };
  Object.assign(Methods$e, MoveChildMethods, BackgroundMethods, InnerBoundsMethods, SetAlignMethods, SetTextOXYMethods$1);

  var GetFastValue$1 = Phaser.Utils.Objects.GetFastValue;
  var Pools = {};
  var PoolManager = /*#__PURE__*/function () {
    function PoolManager(config) {
      _classCallCheck(this, PoolManager);
      this.pools = GetFastValue$1(config, 'pools', Pools);
    }
    _createClass(PoolManager, [{
      key: "free",
      value: function free(bob) {
        if (!this.pools) {
          return this;
        }
        var bobType = bob.type;
        if (!this.pools.hasOwnProperty(bobType)) {
          this.pools[bobType] = new Stack();
        }
        this.pools[bobType].push(bob);
        bob.onFree();
        return this;
      }
    }, {
      key: "freeMultiple",
      value: function freeMultiple(arr) {
        if (!this.pools) {
          return this;
        }
        for (var i = 0, cnt = arr.length; i < cnt; i++) {
          this.free(arr[i]);
        }
        return this;
      }
    }, {
      key: "allocate",
      value: function allocate(bobType) {
        if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
          return null;
        }
        return this.pools[bobType].pop();
      }
    }]);
    return PoolManager;
  }();

  var IsPlainObject$I = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$2N = Phaser.Utils.Objects.GetValue;
  var DynamicText = /*#__PURE__*/function (_Canvas) {
    _inherits(DynamicText, _Canvas);
    function DynamicText(scene, x, y, fixedWidth, fixedHeight, config) {
      var _this;
      _classCallCheck(this, DynamicText);
      if (IsPlainObject$I(x)) {
        config = x;
        x = GetValue$2N(config, 'x', 0);
        y = GetValue$2N(config, 'y', 0);
        fixedWidth = GetValue$2N(config, 'width', 0);
        fixedHeight = GetValue$2N(config, 'height', 0);
      } else if (IsPlainObject$I(fixedWidth)) {
        config = fixedWidth;
        fixedWidth = GetValue$2N(config, 'width', 0);
        fixedHeight = GetValue$2N(config, 'height', 0);
      }
      var width = fixedWidth === 0 ? 1 : fixedWidth;
      var height = fixedHeight === 0 ? 1 : fixedHeight;
      _this = _callSuper(this, DynamicText, [scene, x, y, width, height]);
      _this.type = 'rexDynamicText';
      _this.autoRound = true;
      _this.padding = SetPadding$1();
      _this.wrapPadding = SetPadding$1();
      var textStyleConfig = GetValue$2N(config, 'style', undefined);
      _this.defaultTextStyle = new TextStyle(null, textStyleConfig);
      _this.textStyle = _this.defaultTextStyle.clone();
      _this.setTestString(GetValue$2N(config, 'testString', '|Mqgy'));
      _this._textOX = 0;
      _this._textOY = 0;
      _this.background = new Background(_assertThisInitialized(_this), GetValue$2N(config, 'background', undefined));
      _this.innerBounds = new InnerBounds(_assertThisInitialized(_this), GetValue$2N(config, 'innerBounds', undefined));
      _this.children = [];
      _this.lastAppendedChildren = [];
      _this.lastOverChild = null;
      _this.poolManager = new PoolManager(config);
      _this.setFixedSize(fixedWidth, fixedHeight);
      _this.setPadding(GetValue$2N(config, 'padding', 0));
      _this.setWrapConfig(GetValue$2N(config, 'wrap', undefined));
      _this.setChildrenInteractiveEnable(GetValue$2N(config, 'childrenInteractive', false));
      var text = GetValue$2N(config, 'text', undefined);
      if (text) {
        _this.setText(text);
      }
      return _this;
    }
    _createClass(DynamicText, [{
      key: "updateTexture",
      value: function updateTexture() {
        this.renderContent();
        _get(_getPrototypeOf(DynamicText.prototype), "updateTexture", this).call(this);
        return this;
      }
    }, {
      key: "text",
      get: function get() {
        return this.getText(true);
      },
      set: function set(value) {
        this.setText(value);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.setFixedSize(width, height);
        return this;
      }
    }, {
      key: "textOX",
      get: function get() {
        return this._textOX;
      },
      set: function set(value) {
        this.setTextOX(value);
      }
    }, {
      key: "textOY",
      get: function get() {
        return this._textOY;
      },
      set: function set(value) {
        this.setTextOY(value);
      }
    }]);
    return DynamicText;
  }(Canvas$1);
  Object.assign(DynamicText.prototype, Methods$e);

  var OnParseColorTag = function OnParseColorTag(textPlayer, parser, config) {
    var tagName = 'color';
    var defaultColor;
    parser.on('start', function () {
      defaultColor = textPlayer.textStyle.color;
    }).on("+".concat(tagName), function (color) {
      textPlayer.textStyle.setColor(color);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setColor(defaultColor);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setColor(defaultColor);
    });
  };

  var OnParseStrokeColorTag = function OnParseStrokeColorTag(textPlayer, parser, config) {
    var tagName = 'stroke';
    var defaultStroke;
    parser.on('start', function () {
      defaultStroke = textPlayer.textStyle.stroke;
      textPlayer.textStyle.setStrokeStyle(null);
    }).on("+".concat(tagName), function (color) {
      if (color === undefined) {
        color = defaultStroke;
      }
      textPlayer.textStyle.setStrokeStyle(color);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setStrokeStyle(null);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setStrokeStyle(defaultStroke);
    });
  };

  var OnParseBoldTag = function OnParseBoldTag(textPlayer, parser, config) {
    var tagName = 'b';
    parser.on('start', function () {
      textPlayer.textStyle.setBold(false);
    }).on("+".concat(tagName), function () {
      textPlayer.textStyle.setBold(true);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setBold(false);
      parser.skipEvent();
    });
  };

  var OnParseItalicTag = function OnParseItalicTag(textPlayer, parser, config) {
    var tagName = 'i';
    parser.on('start', function () {
      textPlayer.textStyle.setItalic(false);
    }).on("+".concat(tagName), function () {
      textPlayer.textStyle.setItalic(true);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setItalic(false);
      parser.skipEvent();
    });
  };

  var OnParseFontSizeTag = function OnParseFontSizeTag(textPlayer, parser, config) {
    var tagName = 'size';
    var defaultFontSize;
    parser.on('start', function () {
      defaultFontSize = textPlayer.textStyle.fontSize;
    }).on("+".concat(tagName), function (fontSize) {
      textPlayer.textStyle.setFontSize(fontSize);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setFontSize(defaultFontSize);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setFontSize(defaultFontSize);
    });
  };

  var OnParseOffsetYTag = function OnParseOffsetYTag(textPlayer, parser, config) {
    var tagName = 'y';
    var defaultOffsetY;
    parser.on('start', function () {
      defaultOffsetY = textPlayer.textStyle.offsetY;
      textPlayer.textStyle.setOffsetY(0);
    }).on("+".concat(tagName), function (y) {
      if (y === undefined) {
        y = defaultOffsetY;
      }
      textPlayer.textStyle.setOffsetY(y);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setOffsetY(0);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setOffsetY(0);
    });
  };

  var OnParseOffsetXTag = function OnParseOffsetXTag(textPlayer, parser, config) {
    var tagName = 'x';
    var defaultOffsetX;
    parser.on('start', function () {
      defaultOffsetX = textPlayer.textStyle.offsetY;
      textPlayer.textStyle.setOffsetX(0);
    }).on("+".concat(tagName), function (y) {
      if (y === undefined) {
        y = defaultOffsetX;
      }
      textPlayer.textStyle.setOffsetX(y);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setOffsetX(0);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setOffsetX(0);
    });
  };

  var OnParseLeftSpaceTag = function OnParseLeftSpaceTag(textPlayer, parser, config) {
    var tagName = 'left';
    var defaultLeftSpace;
    parser.on('start', function () {
      defaultLeftSpace = textPlayer.textStyle.leftSpace;
      textPlayer.textStyle.setLeftSpace(0);
    }).on("+".concat(tagName), function (space) {
      if (space === undefined) {
        space = defaultLeftSpace;
      }
      textPlayer.textStyle.setLeftSpace(space);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setLeftSpace(0);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setLeftSpace(0);
    });
  };

  var OnParseRightSpaceTag = function OnParseRightSpaceTag(textPlayer, parser, config) {
    var tagName = 'right';
    var defaultRightSpace;
    parser.on('start', function () {
      defaultRightSpace = textPlayer.textStyle.rightSpace;
      textPlayer.textStyle.setRightSpace(0);
    }).on("+".concat(tagName), function (space) {
      if (space === undefined) {
        space = defaultRightSpace;
      }
      textPlayer.textStyle.setRightSpace(space);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setRightSpace(0);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setRightSpace(0);
    });
  };

  var OnParseShadowColorTag = function OnParseShadowColorTag(textPlayer, parser, config) {
    var tagName = 'shadow';
    var defaultShadowColor;
    parser.on('start', function () {
      defaultShadowColor = textPlayer.textStyle.shadowColor;
      textPlayer.textStyle.setShadowColor(null);
    }).on("+".concat(tagName), function (color) {
      if (color === undefined) {
        color = defaultShadowColor;
      }
      textPlayer.textStyle.setShadowColor(color);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setShadowColor(null);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setShadowColor(defaultShadowColor);
    });
  };

  var OnParseAlignTag = function OnParseAlignTag(textPlayer, parser, config) {
    var tagName = 'align';
    parser.on("+".concat(tagName), function (align) {
      textPlayer.textStyle.setAlign(align);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setAlign();
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setAlign();
    });
  };

  var OnParseImageTag$1 = function OnParseImageTag(textPlayer, parser, config) {
    var tagName = 'img';
    parser.on("+".concat(tagName), function (name) {
      var imgData = textPlayer.imageManager.get(name);
      AppendImage.call(textPlayer, imgData.key, imgData.frame, {
        width: imgData.width,
        hieght: imgData.height,
        leftSpace: imgData.left,
        rightSpace: imgData.right,
        color: imgData.tintFill ? textPlayer.textStyle.color : undefined
      });
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var OnParseImageTag = function OnParseImageTag(textPlayer, parser, config) {
    var tagName = 'space';
    parser.on("+".concat(tagName), function (width) {
      AppendSpace.call(textPlayer, width);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var OnParseTypingSpeedTag = function OnParseTypingSpeedTag(textPlayer, parser, config) {
    var tagName = 'speed';
    parser.on("+".concat(tagName), function (speed) {
      AppendCommand$2(textPlayer, speed);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      AppendCommand$2(textPlayer, undefined);
      parser.skipEvent();
    });
  };
  var SetTypingSpeed = function SetTypingSpeed(speed) {
    this.typeWriter.setTypingSpeed(speed); // this: textPlayer
  };
  var AppendCommand$2 = function AppendCommand(textPlayer, speed) {
    AppendCommand$3.call(textPlayer, 'speed',
    // name
    SetTypingSpeed,
    // callback
    speed,
    // params
    textPlayer // scope
    );
  };

  var OnParsePlaySoundEffectTag = function OnParsePlaySoundEffectTag(textPlayer, parser, config) {
    var tagName = 'se';
    parser.on("+".concat(tagName), function (name, fadeInTime) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PlaySoundEffect,
      // callback
      [name, fadeInTime],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'se2';
    parser.on("+".concat(tagName), function (name, fadeInTime) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PlaySoundEffect2,
      // callback
      [name, fadeInTime],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var PlaySoundEffect = function PlaySoundEffect(params) {
    if (this.skipSoundEffect) {
      return;
    }
    var name = params[0];
    var fadeInTime = params[1];
    this.soundManager.playSoundEffect(name); // this: textPlayer
    if (fadeInTime) {
      this.soundManager.fadeInSoundEffect(fadeInTime);
    }
  };
  var PlaySoundEffect2 = function PlaySoundEffect2(params) {
    if (this.skipSoundEffect) {
      return;
    }
    var name = params[0];
    var fadeInTime = params[1];
    this.soundManager.playSoundEffect2(name); // this: textPlayer
    if (fadeInTime) {
      this.soundManager.fadeInSoundEffect2(fadeInTime);
    }
  };

  var OnParseFadeInSoundEffectTag = function OnParseFadeInSoundEffectTag(textPlayer, parser, config) {
    var tagName = 'se.fadein';
    parser.on("+".concat(tagName), function (time) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      FadeInSoundEffect,
      // callback
      time,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'se2.fadein';
    parser.on("+".concat(tagName), function (time) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      FadeInSoundEffect2,
      // callback
      time,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var FadeInSoundEffect = function FadeInSoundEffect(time) {
    // this: textPlayer
    this.soundManager.fadeInSoundEffect(time);
  };
  var FadeInSoundEffect2 = function FadeInSoundEffect2(time) {
    // this: textPlayer
    this.soundManager.fadeInSoundEffect2(time);
  };

  var OnParseFadeOutSoundEffectTag = function OnParseFadeOutSoundEffectTag(textPlayer, parser, config) {
    var tagName = 'se.fadeout';
    parser.on("+".concat(tagName), function (time, isStopped) {
      isStopped = isStopped === 'stop';
      AppendCommand$3.call(textPlayer, tagName,
      // name
      FadeOutSoundEffect,
      // callback
      [time, isStopped],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'se2.fadeout';
    parser.on("+".concat(tagName), function (time, isStopped) {
      isStopped = isStopped === 'stop';
      AppendCommand$3.call(textPlayer, tagName,
      // name
      FadeOutSoundEffect2,
      // callback
      [time, isStopped],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var FadeOutSoundEffect = function FadeOutSoundEffect(params) {
    var _this$soundManager;
    // this: textPlayer
    (_this$soundManager = this.soundManager).fadeOutSoundEffect.apply(_this$soundManager, _toConsumableArray(params));
  };
  var FadeOutSoundEffect2 = function FadeOutSoundEffect2(params) {
    var _this$soundManager2;
    // this: textPlayer
    (_this$soundManager2 = this.soundManager).fadeOutSoundEffect2.apply(_this$soundManager2, _toConsumableArray(params));
  };

  var OnParseSetSoundEffectVolumeTag = function OnParseSetSoundEffectVolumeTag(textPlayer, parser, config) {
    var tagName = 'se.volume';
    parser.on("+".concat(tagName), function (volume) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetSoundEffectVolume,
      // callback
      volume,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'se2.volume';
    parser.on("+".concat(tagName), function (volume) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetSoundEffectVolume2,
      // callback
      volume,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var SetSoundEffectVolume = function SetSoundEffectVolume(volume) {
    // this: textPlayer
    this.soundManager.setSoundEffectVolume(volume, true);
  };
  var SetSoundEffectVolume2 = function SetSoundEffectVolume2(volume) {
    // this: textPlayer
    this.soundManager.setSoundEffectVolume2(volume, true);
  };

  var OnParseSetSoundEffectMuteTag = function OnParseSetSoundEffectMuteTag(textPlayer, parser, config) {
    var tagName = 'se.mute';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetSoundEffectMute,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'se2.mute';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetSoundEffect2Mute,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'se.unmute';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetSoundEffectUnMute,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'se2.unmute';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetSoundEffect2UnMute,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var SetSoundEffectMute = function SetSoundEffectMute() {
    // this: textPlayer
    this.soundManager.setSoundEffectMute(true);
  };
  var SetSoundEffect2Mute = function SetSoundEffect2Mute() {
    // this: textPlayer
    this.soundManager.setSoundEffect2Mute(true);
  };
  var SetSoundEffectUnMute = function SetSoundEffectUnMute() {
    // this: textPlayer
    this.soundManager.setSoundEffectMute(false);
  };
  var SetSoundEffect2UnMute = function SetSoundEffect2UnMute() {
    // this: textPlayer
    this.soundManager.setSoundEffect2Mute(false);
  };

  var OnParsePlayBackgroundMusicTag = function OnParsePlayBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = 'bgm';
    parser.on("+".concat(tagName), function (name, fadeInTime) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PlayBackgroundMusic,
      // callback
      [name, fadeInTime],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, 'bgm.stop',
      // name
      StopBackgroundMusic,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
    var tagName = 'bgm2';
    parser.on("+".concat(tagName), function (name, fadeInTime) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PlayBackgroundMusic2,
      // callback
      [name, fadeInTime],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, 'bgm2.stop',
      // name
      StopBackgroundMusic2,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var PlayBackgroundMusic = function PlayBackgroundMusic(params) {
    var name = params[0];
    var fadeInTime = params[1];

    // this: textPlayer
    this.soundManager.playBackgroundMusic(name);
    if (fadeInTime) {
      this.soundManager.fadeInBackgroundMusic(fadeInTime);
    }
  };
  var StopBackgroundMusic = function StopBackgroundMusic() {
    // this: textPlayer
    this.soundManager.stopBackgroundMusic();
  };
  var PlayBackgroundMusic2 = function PlayBackgroundMusic2(params) {
    var name = params[0];
    var fadeInTime = params[1];

    // this: textPlayer
    this.soundManager.playBackgroundMusic2(name);
    if (fadeInTime) {
      this.soundManager.fadeInBackgroundMusic2(fadeInTime);
    }
  };
  var StopBackgroundMusic2 = function StopBackgroundMusic2() {
    // this: textPlayer
    this.soundManager.stopBackgroundMusic2();
  };

  var OnParseFadeInBackgroundMusicTag = function OnParseFadeInBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = 'bgm.fadein';
    parser.on("+".concat(tagName), function (time) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      FadeInBackgroundMusic,
      // callback
      time,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'bgm2.fadein';
    parser.on("+".concat(tagName), function (time) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      FadeInBackgroundMusic2,
      // callback
      time,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var FadeInBackgroundMusic = function FadeInBackgroundMusic(time) {
    // this: textPlayer
    this.soundManager.fadeInBackgroundMusic(time);
  };
  var FadeInBackgroundMusic2 = function FadeInBackgroundMusic2(time) {
    // this: textPlayer
    this.soundManager.fadeInBackgroundMusic2(time);
  };

  var OnParseFadeOutBackgroundMusicTag = function OnParseFadeOutBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = 'bgm.fadeout';
    parser.on("+".concat(tagName), function (time, isStopped) {
      isStopped = isStopped === 'stop';
      AppendCommand$3.call(textPlayer, tagName,
      // name
      FadeOutBackgroundMusic,
      // callback
      [time, isStopped],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'bgm2.fadeout';
    parser.on("+".concat(tagName), function (time, isStopped) {
      isStopped = isStopped === 'stop';
      AppendCommand$3.call(textPlayer, tagName,
      // name
      FadeOutBackgroundMusic2,
      // callback
      [time, isStopped],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var FadeOutBackgroundMusic = function FadeOutBackgroundMusic(params) {
    var _this$soundManager;
    // this: textPlayer
    (_this$soundManager = this.soundManager).fadeOutBackgroundMusic.apply(_this$soundManager, _toConsumableArray(params));
  };
  var FadeOutBackgroundMusic2 = function FadeOutBackgroundMusic2(params) {
    var _this$soundManager2;
    // this: textPlayer
    (_this$soundManager2 = this.soundManager).fadeOutBackgroundMusic2.apply(_this$soundManager2, _toConsumableArray(params));
  };

  var OnParseCrossFadeBackgroundMusicTag = function OnParseCrossFadeBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = 'bgm.cross';
    parser.on("+".concat(tagName), function (name, fadeTime) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      CrossFadeBackgroundMusic,
      // callback
      [name, fadeTime],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'bgm2.cross';
    parser.on("+".concat(tagName), function (name, fadeTime) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      CrossFadeBackgroundMusic2,
      // callback
      [name, fadeTime],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var CrossFadeBackgroundMusic = function CrossFadeBackgroundMusic(params) {
    var _this$soundManager;
    // this: textPlayer
    (_this$soundManager = this.soundManager).crossFadeBackgroundMusic.apply(_this$soundManager, _toConsumableArray(params));
  };
  var CrossFadeBackgroundMusic2 = function CrossFadeBackgroundMusic2(params) {
    var _this$soundManager2;
    // this: textPlayer
    (_this$soundManager2 = this.soundManager).crossFadeBackgroundMusic2.apply(_this$soundManager2, _toConsumableArray(params));
  };

  var OnParsePauseBackgroundMusicTag = function OnParsePauseBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = 'bgm.pause';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PauseBackgroundMusic,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, 'bgm.resume',
      // name
      ResumeBackgroundMusic,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
    var tagName = 'bgm2.pause';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PauseBackgroundMusic2,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, 'bgm2.resume',
      // name
      ResumeBackgroundMusic2,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var PauseBackgroundMusic = function PauseBackgroundMusic() {
    // this: textPlayer
    this.soundManager.pauseBackgroundMusic();
  };
  var ResumeBackgroundMusic = function ResumeBackgroundMusic() {
    // this: textPlayer
    this.soundManager.resumeBackgroundMusic();
  };
  var PauseBackgroundMusic2 = function PauseBackgroundMusic2() {
    // this: textPlayer
    this.soundManager.pauseBackgroundMusic2();
  };
  var ResumeBackgroundMusic2 = function ResumeBackgroundMusic2() {
    // this: textPlayer
    this.soundManager.resumeBackgroundMusic2();
  };

  var OnParseSetBackgroundMusicVolumeTag = function OnParseSetBackgroundMusicVolumeTag(textPlayer, parser, config) {
    var tagName = 'bgm.volume';
    parser.on("+".concat(tagName), function (volume) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetBackgroundMusicVolume,
      // callback
      volume,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'bgm2.volume';
    parser.on("+".concat(tagName), function (volume) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetBackgroundMusicVolume2,
      // callback
      volume,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var SetBackgroundMusicVolume = function SetBackgroundMusicVolume(volume) {
    // this: textPlayer
    this.soundManager.setBackgroundMusicVolume(volume);
  };
  var SetBackgroundMusicVolume2 = function SetBackgroundMusicVolume2(volume) {
    // this: textPlayer
    this.soundManager.setBackgroundMusicVolume2(volume);
  };

  var OnParseSetBackgroundMusicMuteTag = function OnParseSetBackgroundMusicMuteTag(textPlayer, parser, config) {
    var tagName = 'bgm.mute';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetBackgroundMusicMute,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'bgm2.mute';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetBackgroundMusic2Mute,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'bgm.unmute';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetBackgroundMusicUnMute,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
    var tagName = 'bgm2.unmute';
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      SetBackgroundMusic2UnMute,
      // callback
      undefined,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };
  var SetBackgroundMusicMute = function SetBackgroundMusicMute() {
    // this: textPlayer
    this.soundManager.setBackgroundMusicMute(true);
  };
  var SetBackgroundMusic2Mute = function SetBackgroundMusic2Mute() {
    // this: textPlayer
    this.soundManager.setBackgroundMusic2Mute(true);
  };
  var SetBackgroundMusicUnMute = function SetBackgroundMusicUnMute() {
    // this: textPlayer
    this.soundManager.setBackgroundMusicMute(false);
  };
  var SetBackgroundMusic2UnMute = function SetBackgroundMusic2UnMute() {
    // this: textPlayer
    this.soundManager.setBackgroundMusic2Mute(false);
  };

  var OnParseFadeInCameraTag = function OnParseFadeInCameraTag(textPlayer, parser, config) {
    var tagName = 'camera.fadein';
    parser.on("+".concat(tagName), function (duration, red, green, blue) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PlayFadeInEffect,
      // callback
      [duration, red, green, blue],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var PlayFadeInEffect = function PlayFadeInEffect(params) {
    var _this$cameraTarget;
    // this: textPlayer
    (_this$cameraTarget = this.cameraTarget).fadeIn.apply(_this$cameraTarget, _toConsumableArray(params));
  };

  var OnParseFadeOutCameraTag = function OnParseFadeOutCameraTag(textPlayer, parser, config) {
    var tagName = 'camera.fadeout';
    parser.on("+".concat(tagName), function (duration, red, green, blue) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PlayFadeOutEffect,
      // callback
      [duration, red, green, blue],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var PlayFadeOutEffect = function PlayFadeOutEffect(params) {
    var _this$cameraTarget;
    // this: textPlayer
    (_this$cameraTarget = this.cameraTarget).fadeOut.apply(_this$cameraTarget, _toConsumableArray(params));
  };

  var OnParseShakeCameraTag = function OnParseShakeCameraTag(textPlayer, parser, config) {
    var tagName = 'camera.shake';
    parser.on("+".concat(tagName), function (duration, intensity) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PlayShakeEffect,
      // callback
      [duration, intensity],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var PlayShakeEffect = function PlayShakeEffect(params) {
    var _this$cameraTarget;
    // this: textPlayer
    (_this$cameraTarget = this.cameraTarget).shake.apply(_this$cameraTarget, _toConsumableArray(params));
  };

  var OnParseFlashCameraTag = function OnParseFlashCameraTag(textPlayer, parser, config) {
    var tagName = 'camera.flash';
    parser.on("+".concat(tagName), function (duration, red, green, blue) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      PlayFlashEffect,
      // callback
      [duration, red, green, blue],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var PlayFlashEffect = function PlayFlashEffect(params) {
    var _this$cameraTarget;
    // this: textPlayer
    (_this$cameraTarget = this.cameraTarget).flash.apply(_this$cameraTarget, _toConsumableArray(params));
  };

  var OnParseZoomCameraTag = function OnParseZoomCameraTag(textPlayer, parser, config) {
    var tagName = 'camera.zoom';
    parser.on("+".concat(tagName), function (value) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      Zoom,
      // callback
      value,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("+".concat(tagName, ".to"), function (value, duration, ease) {
      AppendCommand$3.call(textPlayer, 'camera.zoom.to',
      // name
      ZoomTo,
      // callback
      [value, duration, ease],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var Zoom = function Zoom(value) {
    // this: textPlayer
    this.cameraTarget.setZoom(value);
  };
  var ZoomTo = function ZoomTo(params) {
    var _this$cameraTarget;
    // this: textPlayer
    (_this$cameraTarget = this.cameraTarget).zoomTo.apply(_this$cameraTarget, _toConsumableArray(params));
  };

  var DegToRad$b = Phaser.Math.DegToRad;
  var OnParseRotateCameraTag = function OnParseRotateCameraTag(textPlayer, parser, config) {
    var tagName = 'camera.rotate';
    parser.on("+".concat(tagName), function (value) {
      value = DegToRad$b(value);
      AppendCommand$3.call(textPlayer, tagName,
      // name
      Rotate$1,
      // callback
      value,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("+".concat(tagName, ".to"), function (value, duration, ease) {
      value = DegToRad$b(value);
      AppendCommand$3.call(textPlayer, 'camera.rotate.to',
      // name
      RotateTo,
      // callback
      [value, duration, ease],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var Rotate$1 = function Rotate(value) {
    // this: textPlayer
    this.cameraTarget.setRotation(value);
  };
  var RotateTo = function RotateTo(params) {
    var value = params[0];
    var duration = params[1];
    var ease = params[2];

    // this: textPlayer
    this.cameraTarget.rotateTo(value, false, duration, ease);
  };

  var OnParseScrollCameraTag = function OnParseScrollCameraTag(textPlayer, parser, config) {
    var tagName = 'camera.scroll';
    parser.on("+".concat(tagName), function (x, y) {
      AppendCommand$3.call(textPlayer, tagName,
      // name
      Scroll,
      // callback
      [x, y],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("+".concat(tagName, ".to"), function (x, y, duration, ease) {
      AppendCommand$3.call(textPlayer, 'camera.scroll.to',
      // name
      ScrollTo,
      // callback
      [x, y, duration, ease],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var Scroll = function Scroll(params) {
    var _this$cameraTarget;
    // this: textPlayer
    (_this$cameraTarget = this.cameraTarget).setScroll.apply(_this$cameraTarget, _toConsumableArray(params));
  };
  var ScrollTo = function ScrollTo(params) {
    var x = params[0];
    var y = params[1];
    var duration = params[2];
    var ease = params[3];

    // this: textPlayer
    var camera = this.cameraTarget;
    var xSave = camera.scrollX;
    var ySave = camera.scrollY;
    camera.setScroll(x, y);
    x += camera.centerX;
    y += camera.centerY;
    camera.setScroll(xSave, ySave);

    // x,y in pan() is the centerX, centerY
    camera.pan(x, y, duration, ease);
  };

  var OnParseWaitTag = function OnParseWaitTag(textPlayer, parser, config) {
    var tagWait = 'wait';
    var tagClick = 'click';
    parser.on("+".concat(tagWait), function (name) {
      AppendCommand$1(textPlayer, name);
      parser.skipEvent();
    }).on("-".concat(tagWait), function () {
      parser.skipEvent();
    }).on("+".concat(tagClick), function () {
      // Equal to [wait=click]
      AppendCommand$1(textPlayer, 'click');
      parser.skipEvent();
    }).on("-".concat(tagClick), function () {
      // Equal to [/wait]
      parser.skipEvent();
    });
  };
  var Wait$2 = function Wait(name) {
    this.typeWriter.wait(name); // this: textPlayer
  };
  var AppendCommand$1 = function AppendCommand(textPlayer, name) {
    AppendCommand$3.call(textPlayer, 'wait',
    // name
    Wait$2,
    // callback
    name,
    // params
    textPlayer // scope
    );
  };

  var OnParseNewLineTag = function OnParseNewLineTag(textPlayer, parser, config) {
    var tagName = 'r';
    parser.on("+".concat(tagName), function () {
      AppendText.call(textPlayer, '\n');
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var OnParsePageBreakTag = function OnParsePageBreakTag(textPlayer, parser, config) {
    var tagNames = ['pagebreak', 'pb'];
    for (var i = 0, cnt = tagNames.length; i < cnt; i++) {
      var tagName = tagNames[i];
      parser.on("+".concat(tagName), function () {
        AppendText.call(textPlayer, '\f');
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    }
  };

  var OnParseContentOff = function OnParseContentOff(textPlayer, parser, config) {
    var tagName = 'content.off';
    parser.on("+".concat(tagName), function () {
      parser.setContentOutputEnable(false);
      parser.skipEvent();
    });
  };

  var OnParseContentOn = function OnParseContentOn(textPlayer, parser, config) {
    var tagName = 'content.on';
    parser.on("+".concat(tagName), function () {
      parser.setContentOutputEnable();
      parser.skipEvent();
    });
  };

  var OnParseContent = function OnParseContent(textPlayer, parser, config) {
    parser.on('content', function (content) {
      if (parser.contentOutputEnable) {
        AppendText.call(textPlayer, content);
      } else {
        var startTag = "+".concat(parser.lastTagStart);
        textPlayer.emit("parser.".concat(startTag, "#content"), parser, content);
      }
    });
  };

  var OnParseCustomTag = function OnParseCustomTag(textPlayer, parser, config) {
    parser.on('start', function () {
      textPlayer.emit('parser.start', parser);
    }).on('+', function (tagName) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }
      var startTag = "+".concat(tagName);
      for (var _len = arguments.length, value = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        value[_key - 1] = arguments[_key];
      }
      var param = value;
      textPlayer.emit.apply(textPlayer, ["parser.".concat(startTag), parser].concat(value, [param]));
      AppendCommand(textPlayer, startTag, param);
    }).on('-', function (tagName) {
      if (parser.skipEventFlag) {
        return;
      }
      var endTag = "-".concat(tagName);
      var param = [];
      textPlayer.emit("parser.".concat(endTag), parser, param);
      AppendCommand(textPlayer, endTag, param);
    }).on('complete', function () {
      textPlayer.emit('parser.complete', parser);
    });
  };
  var FireEvent$1 = function FireEvent(param, tagName) {
    var eventName = "tag.".concat(tagName);
    // this: textPlayer
    if (param == null) {
      this.emit(eventName);
    } else {
      this.emit.apply(this, [eventName].concat(_toConsumableArray(param)));
    }
  };
  var AppendCommand = function AppendCommand(textPlayer, name, param) {
    AppendCommand$3.call(textPlayer, name,
    // name
    FireEvent$1,
    // callback
    param,
    // params
    textPlayer // scope
    );
  };

  var ParseCallbacks$2 = [OnParseColorTag, OnParseStrokeColorTag, OnParseBoldTag, OnParseItalicTag, OnParseFontSizeTag, OnParseShadowColorTag, OnParseAlignTag, OnParseOffsetYTag, OnParseOffsetXTag, OnParseLeftSpaceTag, OnParseRightSpaceTag, OnParseImageTag$1, OnParseImageTag, OnParseTypingSpeedTag, OnParsePlaySoundEffectTag, OnParseFadeInSoundEffectTag, OnParseFadeOutSoundEffectTag, OnParseSetSoundEffectVolumeTag, OnParseSetSoundEffectMuteTag, OnParsePlayBackgroundMusicTag, OnParseFadeInBackgroundMusicTag, OnParseFadeOutBackgroundMusicTag, OnParseCrossFadeBackgroundMusicTag, OnParsePauseBackgroundMusicTag, OnParseSetBackgroundMusicVolumeTag, OnParseSetBackgroundMusicMuteTag, OnParseFadeInCameraTag, OnParseFadeOutCameraTag, OnParseShakeCameraTag, OnParseFlashCameraTag, OnParseZoomCameraTag, OnParseRotateCameraTag, OnParseScrollCameraTag, OnParseWaitTag, OnParseNewLineTag, OnParsePageBreakTag, OnParseContentOff, OnParseContentOn, OnParseContent, OnParseCustomTag];
  var AddParseCallbacks = function AddParseCallbacks(textPlayer, parser, config) {
    for (var i = 0, cnt = ParseCallbacks$2.length; i < cnt; i++) {
      ParseCallbacks$2[i](textPlayer, parser, config);
    }
  };

  /*
  Skip line
  - An empty line, only has space
  - A comment line, start with commentLineStart ('//')
  */

  var PreProcess = function PreProcess(parser, source) {
    var comentLineStart = parser.commentLineStart;
    var lines = source.split('\n');
    for (var i = 0, cnt = lines.length; i < cnt; i++) {
      var line = lines[i];
      if (line === '') ; else if (line.trim().length === 0) {
        // An empty line, only has space
        lines[i] = '';
      } else if (comentLineStart && line.startsWith(comentLineStart)) {
        // A comment line, start with commentLineStart ('//')
        lines[i] = '';
      }
    }
    // Use [r] to put \n
    return lines.join('');
  };

  var GetValue$2M = Phaser.Utils.Objects.GetValue;
  var Parser = /*#__PURE__*/function (_BracketParser) {
    _inherits(Parser, _BracketParser);
    function Parser(textPlayer, config) {
      var _this;
      _classCallCheck(this, Parser);
      if (config === undefined) {
        config = {};
      }
      if (!config.hasOwnProperty('delimiters')) {
        config.delimiters = '[]';
      }
      _this = _callSuper(this, Parser, [config]);
      AddParseCallbacks(textPlayer, _assertThisInitialized(_this), config);
      _this.setCommentLineStartSymbol(GetValue$2M(config, 'comment', '//'));
      _this.setContentOutputEnable();
      return _this;
    }
    _createClass(Parser, [{
      key: "setCommentLineStartSymbol",
      value: function setCommentLineStartSymbol(symbol) {
        this.commentLineStart = symbol;
        return this;
      }
    }, {
      key: "setContentOutputEnable",
      value: function setContentOutputEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.contentOutputEnable = enable;
        return this;
      }
    }, {
      key: "start",
      value: function start(source) {
        _get(_getPrototypeOf(Parser.prototype), "start", this).call(this, PreProcess(this, source));
        return this;
      }
    }]);
    return Parser;
  }(BracketParser);

  var TypingSpeedMethods$1 = {
    setDefaultTypingSpeed: function setDefaultTypingSpeed(speed) {
      this.defaultSpeed = speed;
      return this;
    },
    setTypingSpeed: function setTypingSpeed(speed) {
      if (speed === undefined) {
        speed = this.defaultSpeed;
      }
      this.speed = speed;
      return this;
    }
  };

  // Internal events

  var PageFadeOutCompleteEvent = 'page.fadeout';
  var StopPlayEvent = '_remove.play';
  var ClearEvents$1 = [PageFadeOutCompleteEvent, StopPlayEvent];

  var FadeOutPage = function FadeOutPage() {
    if (!this.fadeOutPageCallback || !this.children) {
      this.emit(PageFadeOutCompleteEvent);
      return this;
    }
    var renderableChildren = this.children.filter(function (child) {
      return child.renderable;
    });
    var waitObject = this.fadeOutPageCallback(renderableChildren, this.fadeOutPageDuration);
    if (!waitObject) {
      this.emit(PageFadeOutCompleteEvent);
    } else if (waitObject.once) {
      waitObject.once('complete', function () {
        this.emit(PageFadeOutCompleteEvent);
      }, this);
    } else if (waitObject.then) {
      var self = this;
      waitObject.then(function () {
        self.emit(PageFadeOutCompleteEvent);
      });
    } else {
      this.emit(PageFadeOutCompleteEvent);
    }
    return this;
  };

  var WaitEvent = function WaitEvent(eventEmitter, eventName) {
    return new Promise(function (resolve, reject) {
      eventEmitter.once(eventName, function () {
        resolve();
      });
    });
  };
  var WaitComplete = function WaitComplete(eventEmitter) {
    return WaitEvent(eventEmitter, 'complete');
  };

  var Start = function Start(children) {
    this.children = children;
    this.index = 0;
    this.isPageTyping = true;
    if (this.onTypeStart) {
      this.onTypeStart(children);
    }
    this.typing();
    return WaitComplete(this); // Promise
  };

  var TypingDelayTimerType = 'delay';
  var TypingAnimationTimerType = 'anim';

  var Typing = function Typing(offsetTime) {
    if (offsetTime === undefined) {
      offsetTime = 0;
    }
    var delay = 0;
    this.inTypingProcessLoop = true;
    while (this.inTypingProcessLoop) {
      var child = this.getNextChild();
      if (!child) {
        if (this.timeline.isRunning) {
          // Wait until last animationConfig is end
          this.timeline.once('complete', function () {
            this.isPageTyping = false;
            this.emit('complete');
          }, this);
        } else {
          this.isPageTyping = false;
          this.emit('complete');
        }
        break; // Leave this typing loop
      }
      if (child.renderable) {
        // Typing this char
        var animationConfig = this.animationConfig;
        if (animationConfig.duration > 0) {
          var animationTimer = this.timeline.addTimer({
            name: TypingAnimationTimerType,
            target: child,
            duration: animationConfig.duration,
            yoyo: animationConfig.yoyo,
            onStart: animationConfig.onStart,
            onProgress: animationConfig.onProgress,
            onComplete: animationConfig.onComplete
          });
          if (this.skipTypingAnimation) {
            animationTimer.seek(1);
          }
        } else {
          // No animationConfig, only invoke onStart callback
          if (animationConfig.onStart) {
            animationConfig.onStart(child, 0);
          }
        }

        // Set to min size
        if (this.minSizeEnable) {
          this.textPlayer.setToMinSize();
        }
        this.textPlayer.emit('typing', child);
        var nextChild = this.nextChild;
        if (nextChild) {
          if (this.skipSpaceEnable && IsSpaceChar(nextChild)) ; else {
            delay += this.speed + offsetTime;
            offsetTime = 0;
            if (delay > 0) {
              // Process next character later
              this.typingTimer = this.timeline.addTimer({
                name: TypingDelayTimerType,
                target: this,
                duration: delay,
                onComplete: function onComplete(target, t, timer) {
                  target.typingTimer = undefined;
                  Typing.call(target, timer.remainder);
                }
              });
              break; // Leave this typing loop     
            }
          }
        }
        // Process next child
      } else if (IsCommand(child)) {
        child.exec();
        // Process next child
      }
    }

    // Set to min size
    if (this.minSizeEnable) {
      this.textPlayer.setToMinSize();
    }
    this.inTypingProcessLoop = false;
  };

  var Pause = function Pause() {
    // Pause typing timer and animation progresses
    this.timeline.pause();
    return this;
  };

  var Resume = function Resume() {
    // Resume typing timer and animation progresses
    this.timeline.resume();
    return this;
  };

  var PauseTyping = function PauseTyping() {
    // Already in typingPaused state
    if (this.isTypingPaused) {
      return this;
    }
    if (this.typingTimer) {
      // Pause when typing timer is counting
      this.typingTimer.pause();
      this.isTypingPaused = true;
    } else if (this.inTypingProcessLoop) {
      // Pause in loop of typing(), by tag
      this.inTypingProcessLoop = false;
      this.isTypingPaused = true;
    }
    return this;
  };

  var ResumeTyping = function ResumeTyping(offsetTime) {
    // Already not in typingPaused state
    if (!this.isTypingPaused) {
      return this;
    }
    if (offsetTime === undefined) {
      offsetTime = 0;
    }
    if (this.typingTimer) {
      // Pause when typing timer is paused
      this.isTypingPaused = false;
      this.typingTimer.resume();
      this.typingTimer.remainder += offsetTime;
    } else if (this.isTypingPaused) {
      // Resume paused by tag
      this.isTypingPaused = false;
      this.typing(offsetTime);
    }
    return this;
  };

  var IsWaitCameraEffect = function IsWaitCameraEffect(name) {
    switch (name) {
      case 'camera.fadein':
      case 'camera.fadeout':
      case 'camera.flash':
      case 'camera.shake':
      case 'camera.zoom':
      case 'camera.rotate':
      case 'camera.scroll':
        return true;
      default:
        return false;
    }
  };

  var IsWaitGameObject = function IsWaitGameObject(textPlayer, name) {
    var names = name.split('.');
    return textPlayer.gameObjectManagers.hasOwnProperty(names[0]);
  };
  var WaitGameObject = function WaitGameObject(textPlayer, tag, callback, scope) {
    var waitEventManager = textPlayer.waitEventManager;
    var tags = tag.split('.');
    var goType = tags[0];
    var gameObjectManager = textPlayer.getGameObjectManager(goType);
    var waitEventName = "wait.".concat(goType);
    switch (tags.length) {
      case 1:
        // 'goType' : wait all sprites has beeen destroyed
        waitEventManager.waitGameObjectManagerEmpty(goType);
        textPlayer.emit(waitEventName);
        return;
      case 2:
        // 'goType.name' : wait goType.name has been destroyed
        var name = tags[1];
        waitEventManager.waitGameObjectDestroy(goType, name);
        textPlayer.emit(waitEventName, name);
        return;
      case 3:
        // 'goType.name.prop' : wait ease goType.name.prop has been completed
        var name = tags[1],
          prop = tags[2];
        var value = gameObjectManager.getProperty(name, prop);
        // Can start tween task for a number property
        if (typeof value === 'number') {
          waitEventManager.waitGameObjectTweenComplete(goType, name, prop);
          textPlayer.emit(waitEventName, name, prop);
          return;
        }
        var dataKey = prop;
        var matchFalseFlag = dataKey.startsWith('!');
        if (matchFalseFlag) {
          dataKey = dataKey.substring(1);
        }
        // Wait until flag is true/false
        if (gameObjectManager.hasData(name, dataKey)) {
          waitEventManager.waitGameObjectDataFlag(goType, name, dataKey, !matchFalseFlag);
          textPlayer.emit(waitEventName, name, dataKey);
          return;
        } else {
          waitEventManager.waitTime(0);
          return;
        }
    }
  };

  var KeyCodes = Phaser.Input.Keyboard.KeyCodes;
  var WaitAny = function WaitAny(textPlayer, names, callback, scope) {
    var waitEventManager = textPlayer.waitEventManager;
    waitEventManager.clearWaitCompleteCallbacks().addWaitCompleteCallback(callback, scope);
    if (typeof names === 'string' && names.length > 1 && names.indexOf('|') !== -1) {
      names = names.split('|');
    } else {
      names = [names];
    }
    for (var i = 0, cnt = names.length; i < cnt; i++) {
      var name = names[i];
      if (name == null || name === 'wait') {
        // Wait event
        var waitCompleteTriggerCallback = textPlayer.waitEventManager.getWaitCompleteTriggerCallback();
        textPlayer.emit('wait', waitCompleteTriggerCallback);
      } else if (typeof name === 'number' || !isNaN(name)) {
        // A number, or a number string
        var time = parseFloat(name);
        waitEventManager.waitTime(time);
        textPlayer.emit('wait.time', time);
      } else if (name === 'click') {
        // 'click'
        waitEventManager.waitClick();
        textPlayer.emit('wait.click');
      } else if (name === 'se') {
        waitEventManager.waitSoundEffectComplete();
        var music = textPlayer.soundManager.getLastSoundEffect();
        textPlayer.emit('wait.music', music);
      } else if (name === 'se2') {
        waitEventManager.waitSoundEffect2Complete();
        var music = textPlayer.soundManager.getLastSoundEffect2();
        textPlayer.emit('wait.music', music);
      } else if (name === 'bgm') {
        waitEventManager.waitBackgroundMusicComplete();
        var music = textPlayer.soundManager.getBackgroundMusic();
        textPlayer.emit('wait.music', music);
      } else if (name === 'bgm2') {
        waitEventManager.waitBackgroundMusic2Complete();
        var music = textPlayer.soundManager.getBackgroundMusic2();
        textPlayer.emit('wait.music', music);
      } else if (KeyCodes.hasOwnProperty(name.toUpperCase())) {
        waitEventManager.waitKeyDown(name);
        textPlayer.emit('wait.keydown', name);
      } else if (IsWaitCameraEffect(name)) {
        waitEventManager.waitCameraEffectComplete(name);
        textPlayer.emit('wait.camera', name);
      } else if (IsWaitGameObject(textPlayer, name)) {
        WaitGameObject(textPlayer, name);
      } else {
        var waitCompleteTriggerCallback = textPlayer.waitEventManager.getWaitCompleteTriggerCallback();
        textPlayer.emit("wait.".concat(name), waitCompleteTriggerCallback);
      }
    }
  };

  var Wait$1 = function Wait(name) {
    // Already in typingPaused state, or ignore any wait
    if (this.ignoreWait) {
      return this;
    }
    this.pauseTyping();
    WaitAny(this.textPlayer, name, this.resumeTyping, this);
    return this;
  };

  var SetIgnoreWait$1 = function SetIgnoreWait(value) {
    if (value === undefined) {
      value = true;
    }
    this.ignoreWait = value;
    return this;
  };

  var SetSkipSpaceEnable = function SetSkipSpaceEnable(enable) {
    if (enable === undefined) {
      enable = true;
    }
    this.skipSpaceEnable = enable;
    return this;
  };

  var SetSkipTypingAnimation = function SetSkipTypingAnimation(value) {
    if (value === undefined) {
      value = true;
    }
    this.skipTypingAnimation = value;
    if (value) {
      // Skip current playing typing-animation
      var timers = this.timeline.getTimers(TypingAnimationTimerType);
      for (var i = 0, cnt = timers.length; i < cnt; i++) {
        timers[i].seek(1);
      }
    }
    return this;
  };

  var SetSkipSoundEffect = function SetSkipSoundEffect(value) {
    if (value === undefined) {
      value = true;
    }
    this.skipSoundEffect = value;
    if (value) {
      var soundManager = this.textPlayer._soundManager;
      if (soundManager) {
        soundManager.fadeOutAllSoundEffects(100, true);
      }
    }
    return this;
  };

  var SkipCurrentTypingDelay = function SkipCurrentTypingDelay() {
    if (this.typingTimer) {
      this.typingTimer.seek(1);
    }
    return this;
  };

  var Methods$d = {
    fadeOutPage: FadeOutPage,
    start: Start,
    typing: Typing,
    pause: Pause,
    resume: Resume,
    pauseTyping: PauseTyping,
    resumeTyping: ResumeTyping,
    wait: Wait$1,
    setIgnoreWait: SetIgnoreWait$1,
    setSkipSpaceEnable: SetSkipSpaceEnable,
    setSkipTypingAnimation: SetSkipTypingAnimation,
    setSkipSoundEffect: SetSkipSoundEffect,
    skipCurrentTypingDelay: SkipCurrentTypingDelay
  };
  Object.assign(Methods$d, TypingSpeedMethods$1);

  var GetValue$2L = Phaser.Utils.Objects.GetValue;
  var TypeWriter = /*#__PURE__*/function () {
    function TypeWriter(textPlayer, config) {
      _classCallCheck(this, TypeWriter);
      this.setEventEmitter();
      this.textPlayer = textPlayer;
      this.isPageTyping = false;
      this.typingTimer = undefined; // Typing delay
      this.pauseTypingTimer = undefined; // Wait time
      this.inTypingProcessLoop = false; // Used in this.typing()
      this.isTypingPaused = false; // Used in this.wait(), this.pauseTyping(), this.resumeTyping()
      this.setIgnoreWait(false);
      this.setSkipTypingAnimation(false);
      this.setTypingStartCallback(GetValue$2L(config, 'onTypingStart', SetChildrenInvisible));
      this.setDefaultTypingSpeed(GetValue$2L(config, 'speed', 250));
      this.setTypingSpeed();
      this.setSkipSpaceEnable(GetValue$2L(config, 'skipSpace', false));
      this.setAnimationConfig(GetValue$2L(config, 'animation', undefined));
      this.setMinSizeEnable(GetValue$2L(config, 'minSizeEnable', false));
      this.setFadeOutPageCallback(GetValue$2L(config, 'fadeOutPage'));
    }
    _createClass(TypeWriter, [{
      key: "destroy",
      value: function destroy() {
        this.destroyEventEmitter();
        this.textPlayer = undefined;
        this.typingTimer = undefined;
        this.pauseTypingTimer = undefined;
        this.onTypeStart = undefined;
        this.animationConfig = undefined;
      }
    }, {
      key: "timeline",
      get: function get() {
        return this.textPlayer.timeline;
      }
    }, {
      key: "setTypingStartCallback",
      value: function setTypingStartCallback(callback) {
        this.onTypeStart = callback;
        return this;
      }
    }, {
      key: "setAnimationConfig",
      value: function setAnimationConfig(config) {
        if (!config) {
          config = {};
        }
        if (!config.hasOwnProperty('duration')) {
          config.duration = 0;
        }
        if (!config.hasOwnProperty('onStart')) {
          // Apply default onStart callback
          config.onStart = SetChildVisible;
        }
        this.animationConfig = config;
        return this;
      }
    }, {
      key: "setFadeOutPageCallback",
      value: function setFadeOutPageCallback(callback) {
        this.fadeOutPageCallback = callback;
        return this;
      }
    }, {
      key: "setMinSizeEnable",
      value: function setMinSizeEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.minSizeEnable = enable;
        return this;
      }
    }, {
      key: "getNextChild",
      value: function getNextChild() {
        var child = this.nextChild;
        this.index = Math.min(this.index + 1, this.children.length); // Point to next child
        this._nextChild = undefined;
        return child;
      }
    }, {
      key: "nextChild",
      get: function get() {
        if (!this._nextChild) {
          this._nextChild = this.children[this.index];
        }
        return this._nextChild;
      }
    }]);
    return TypeWriter;
  }();
  var SetChildVisible = function SetChildVisible(child) {
    if (child.setVisible) {
      child.setVisible();
    }
  };
  var SetChildrenInvisible = function SetChildrenInvisible(children) {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (child.setVisible) {
        child.setVisible(false);
      }
    }
  };
  Object.assign(TypeWriter.prototype, EventEmitterMethods$1, Methods$d);

  var SpriteBob = /*#__PURE__*/function (_BobBase) {
    _inherits(SpriteBob, _BobBase);
    function SpriteBob() {
      _classCallCheck(this, SpriteBob);
      return _callSuper(this, SpriteBob, arguments);
    }
    _createClass(SpriteBob, [{
      key: "playAnimation",
      value: function playAnimation(key) {
        this.gameObject.anims.timeScale = this.timeScale;
        this.gameObject.play(key);
        return this;
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation() {
        this.gameObject.stop();
        return this;
      }
    }, {
      key: "chainAnimation",
      value: function chainAnimation(keys) {
        this.gameObject.chain(keys);
        return this;
      }
    }, {
      key: "pauseAnimation",
      value: function pauseAnimation() {
        this.gameObject.anims.pause();
        return this;
      }
    }, {
      key: "setTimeScale",
      value: function setTimeScale(timeScale) {
        _get(_getPrototypeOf(SpriteBob.prototype), "setTimeScale", this).call(this, timeScale);
        if (this.gameObject.anims) {
          this.gameObject.anims.timeScale = timeScale;
        }
        return this;
      }
    }]);
    return SpriteBob;
  }(BobBase);

  var AnimationMethods = {
    playAnimation: function playAnimation(name, key) {
      if (!this.has(name)) {
        this.add(name);
      }
      this.get(name).playAnimation(key);
      return this;
    },
    stopAnimation: function stopAnimation(name) {
      if (!this.has(name)) {
        return this;
      }
      this.get(name).stopAnimation();
      return this;
    },
    chainAnimation: function chainAnimation(name, keys) {
      if (!this.has(name)) {
        return this;
      }
      this.get(name).chainAnimation(keys);
      return this;
    },
    pauseAnimation: function pauseAnimation(name) {
      if (!this.has(name)) {
        return this;
      }
      this.get(name).pauseAnimation();
      return this;
    }
  };

  var Methods$c = {};
  Object.assign(Methods$c, AnimationMethods);

  var SpriteManager = /*#__PURE__*/function (_GOManager) {
    _inherits(SpriteManager, _GOManager);
    function SpriteManager(scene, config) {
      _classCallCheck(this, SpriteManager);
      if (config === undefined) {
        config = {};
      }
      config.BobClass = SpriteBob;
      return _callSuper(this, SpriteManager, [scene, config]);
    }
    _createClass(SpriteManager, [{
      key: "setCreateGameObjectCallback",
      value: function setCreateGameObjectCallback(callback, scope) {
        if (!callback || callback === 'sprite') {
          callback = CreateSprite;
        } else if (callback === 'image') {
          callback = CreateImage$1;
        }
        _get(_getPrototypeOf(SpriteManager.prototype), "setCreateGameObjectCallback", this).call(this, callback, scope);
        return this;
      }
    }]);
    return SpriteManager;
  }(GOManager);
  var CreateSprite = function CreateSprite(scene, textureKey, frameName) {
    if (typeof frameName !== 'string' && typeof frameName !== 'number') {
      frameName = undefined;
    }
    return scene.add.sprite(0, 0, textureKey, frameName);
  };
  var CreateImage$1 = function CreateImage(scene, textureKey, frameName) {
    if (typeof frameName !== 'string' && typeof frameName !== 'number') {
      frameName = undefined;
    }
    return scene.add.image(0, 0, textureKey, frameName);
  };
  Object.assign(SpriteManager.prototype, Methods$c);

  var IsPlayAnimationTag = function IsPlayAnimationTag(tags, goType) {
    // goType.name.play
    return tags.length === 3 && tags[0] === goType && tags[2] === 'play';
  };
  var IsStopAnimationTag = function IsStopAnimationTag(tags, goType) {
    // goType.name.stop
    return tags.length === 3 && tags[0] === goType && tags[2] === 'stop';
  };
  var OnParsePlayAnimationTag = function OnParsePlayAnimationTag(textPlayer, parser, config) {
    var goType = config.name;
    parser.on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [goType.name.play=key], or [goType.name.play=key0,key1,...]
      var tags = tag.split('.');
      var name;
      if (IsPlayAnimationTag(tags, goType)) {
        name = tags[1];
      } else {
        return;
      }
      for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        keys[_key - 1] = arguments[_key];
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".play"),
      // name
      PlayAnimation,
      // callback
      [goType, name, keys],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [goType.name.stop]
      var tags = tag.split('.');
      var name;
      if (IsStopAnimationTag(tags, goType)) {
        name = tags[1];
      } else {
        return;
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".stop"),
      // name
      StopAnimation,
      // callback
      [goType, name],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on('-', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [/goType.name.play]
      var tags = tag.split('.');
      var name;
      if (IsPlayAnimationTag(tags, goType)) {
        name = tags[1];
      } else {
        return;
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".stop"),
      // name
      StopAnimation,
      // callback
      [goType, name],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var PlayAnimation = function PlayAnimation(params) {
    var goType, name, keys;
    var _params = _slicedToArray(params, 3);
    goType = _params[0];
    name = _params[1];
    keys = _params[2];
    var key = keys.shift();

    // this: textPlayer
    var gameObjectManager = this.getGameObjectManager(goType);
    gameObjectManager.playAnimation(name, key);
    if (keys.length > 0) {
      gameObjectManager.chainAnimation(name, keys);
    }
  };
  var StopAnimation = function StopAnimation(params) {
    var goType, args;
    // this: textPlayer
    var _params2 = _toArray(params);
    goType = _params2[0];
    args = _params2.slice(1);
    var gameObjectManager = this.getGameObjectManager(goType);
    gameObjectManager.stopAnimation.apply(gameObjectManager, _toConsumableArray(args));
  };

  var IsPauseAnimationTag = function IsPauseAnimationTag(tags, goType) {
    // goType.name.pause 
    return tags.length === 3 && tags[0] === goType && tags[2] === 'pause';
  };
  var OnParsePauseAnimationTag = function OnParsePauseAnimationTag(textPlayer, parser, config) {
    var goType = config.name;
    parser.on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [goType.name.pause=key]
      var tags = tag.split('.');
      var name;
      if (IsPauseAnimationTag(tags, goType)) {
        name = tags[1];
      } else {
        return;
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".pause"),
      // name
      PauseAnimation,
      // callback
      [goType, name],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var PauseAnimation = function PauseAnimation(params) {
    var goType, args;
    // this: textPlayer
    var _params = _toArray(params);
    goType = _params[0];
    args = _params.slice(1);
    var gameObjectManager = this.getGameObjectManager(goType);
    gameObjectManager.pauseAnimation.apply(gameObjectManager, _toConsumableArray(args));
  };

  var IsChainAnimationTag = function IsChainAnimationTag(tags, goType) {
    // goType.name.chain 
    return tags.length === 3 && tags[0] === goType && tags[2] === 'chain';
  };
  var OnParseChainAnimationTag = function OnParseChainAnimationTag(textPlayer, parser, config) {
    var goType = config.name;
    parser.on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [goType.name.chain=key]
      var tags = tag.split('.');
      var name;
      if (IsChainAnimationTag(tags, goType)) {
        name = tags[1];
      } else {
        return;
      }
      var keys = Array.prototype.slice.call(arguments, 1);
      AppendCommand$3.call(textPlayer, "".concat(goType, ".chain"),
      // name
      ChainAnimation,
      // callback
      [goType, name, keys],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var ChainAnimation = function ChainAnimation(params) {
    var goType, args;
    // this: textPlayer
    var _params = _toArray(params);
    goType = _params[0];
    args = _params.slice(1);
    var gameObjectManager = this.getGameObjectManager(goType);
    gameObjectManager.chainAnimation.apply(gameObjectManager, _toConsumableArray(args));
  };

  var ParseCallbacks$1 = [OnParsePlayAnimationTag, OnParsePauseAnimationTag, OnParseChainAnimationTag];
  var AddSpriteManager = function AddSpriteManager(config) {
    if (config === undefined) {
      config = {};
    }
    config.name = 'sprite';
    config.parseCallbacks = ParseCallbacks$1;
    this.addGameObjectManager(config, SpriteManager);
  };

  var IsAddGameObjectTag = function IsAddGameObjectTag(tags, goType) {
    // goType.name
    return tags.length === 2 && tags[0] === goType;
  };
  var OnParseAddGameObjectTag = function OnParseAddGameObjectTag(textPlayer, parser, config) {
    var goType = config.name;
    parser.on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [goType.name=key,frame], or [goType.name]
      var tags = tag.split('.');
      var name;
      if (IsAddGameObjectTag(tags, goType)) {
        name = tags[1];
      } else {
        return;
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".add"),
      // name
      AddGameObject, // callback
      [goType, name].concat(args),
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on('-', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [/goType.name]
      var tags = tag.split('.');
      var name;
      if (IsAddGameObjectTag(tags, goType)) {
        name = tags[1];
      } else {
        return;
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".remove"),
      // name
      RemoveGameObject,
      // callback
      [goType, name],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var AddGameObject = function AddGameObject(params) {
    var goType, args;
    // this: textPlayer
    var _params = _toArray(params);
    goType = _params[0];
    args = _params.slice(1);
    var gameObjectManager = this.getGameObjectManager(goType);
    gameObjectManager.add.apply(gameObjectManager, _toConsumableArray(args));
  };
  var RemoveGameObject = function RemoveGameObject(params) {
    var goType, args;
    // this: textPlayer
    var _params2 = _toArray(params);
    goType = _params2[0];
    args = _params2.slice(1);
    var gameObjectManager = this.getGameObjectManager(goType);
    gameObjectManager.remove.apply(gameObjectManager, _toConsumableArray(args));
  };

  var OnParseRemoveAllGameObjectsTag = function OnParseRemoveAllGameObjectsTag(textPlayer, parser, config) {
    var goType = config.name;
    parser.on('-', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [/goType]
      if (tag === goType) ; else {
        return;
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".removeall"),
      // name
      RemoveAllSprites,
      // callback
      goType,
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var RemoveAllSprites = function RemoveAllSprites(goType) {
    // this: textPlayer
    var gameObjectManager = this.getGameObjectManager(goType);
    gameObjectManager.removeAll();
  };

  var IsPropTag = function IsPropTag(tags, goType) {
    // goType.name.prop
    return tags.length === 3 && tags[0] === goType;
  };
  var OnParseCallGameObjectMethodTag = function OnParseCallGameObjectMethodTag(textPlayer, parser, config) {
    var goType = config.name;
    parser.on("+", function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [goType.name.methodName=value0,value1,value2...]
      // [goType.name.prop=value]
      var tags = tag.split('.');
      var name, prop;
      if (IsPropTag(tags, goType)) {
        name = tags[1];
        prop = tags[2];
      } else {
        return;
      }
      for (var _len = arguments.length, parameters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        parameters[_key - 1] = arguments[_key];
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".call"),
      // name
      CallMethod, // callback
      [goType, name, prop].concat(parameters),
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var CallMethod = function CallMethod(params) {
    var goType, name, prop, args;
    // this: textPlayer
    var _params = _toArray(params);
    goType = _params[0];
    name = _params[1];
    prop = _params[2];
    args = _params.slice(3);
    var eventName = "".concat(goType, ".").concat(prop);
    this.emit.apply(this, [eventName, name].concat(_toConsumableArray(args)));
    if (this.listenerCount(eventName) > 0) {
      return;
    }
    var gameObjectManager = this.getGameObjectManager(goType);
    if (gameObjectManager.hasMethod(name, prop)) {
      // Is method
      gameObjectManager.call.apply(gameObjectManager, [name, prop].concat(_toConsumableArray(args)));
    } else {
      // Is property
      gameObjectManager.setProperty(name, prop, args[0]);
    }
  };

  var EaseMode = {
    to: true,
    yoyo: true,
    from: true,
    toLeft: true,
    toRight: true,
    toUp: true,
    toDown: true,
    yoyoLeft: true,
    yoyoRight: true,
    yoyoUp: true,
    yoyoDown: true,
    fromLeft: true,
    fromRight: true,
    fromUp: true,
    fromDown: true
  };
  var IsEasePropertyTag = function IsEasePropertyTag(tags, goType) {
    // goType.name.prop.to
    return tags.length === 4 && tags[0] === goType && EaseMode[tags[3]];
  };
  var OnParseEaseGameObjectPropertyTag = function OnParseEaseGameObjectPropertyTag(textPlayer, parser, config) {
    var goType = config.name;
    textPlayer.getGameObjectManager(goType);
    parser.on("+", function (tag, value, duration, ease, repeat) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      // [goType.name.prop.to=value,duration]
      // [goType.name.prop.to=value,duration,ease,repeat]
      // [goType.name.prop.to=value,duration,repeat]
      var tags = tag.split('.');
      var name, property, easeMode;
      if (IsEasePropertyTag(tags, goType)) {
        name = tags[1];
        property = tags[2];
        easeMode = tags[3];
      } else {
        return;
      }
      if (typeof ease === 'number') {
        repeat = ease;
        ease = undefined;
      }
      AppendCommand$3.call(textPlayer, "".concat(goType, ".ease"),
      // name
      EaseProperty,
      // callback
      [goType, name, property, value, duration, ease, repeat, easeMode],
      // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };
  var EaseProperty = function EaseProperty(params) {
    var goType, name, property, value, duration, ease, repeat, easeMode;
    // this: textPlayer
    var _params = _slicedToArray(params, 8);
    goType = _params[0];
    name = _params[1];
    property = _params[2];
    value = _params[3];
    duration = _params[4];
    ease = _params[5];
    repeat = _params[6];
    easeMode = _params[7];
    var gameObjectManager = this.getGameObjectManager(goType);
    var currentValue = gameObjectManager.getProperty(name, property);
    // Only can tween number property
    if (typeof currentValue !== 'number') {
      return;
    }
    if (easeMode.endsWith('Left') || easeMode.endsWith('Up')) {
      if (easeMode.startsWith('to') || easeMode.startsWith('yoyo')) {
        value = currentValue - value;
      } else if (easeMode.startsWith('from')) {
        gameObjectManager.setProperty(name, property, currentValue - value);
        value = currentValue;
      }
    } else if (easeMode.endsWith('Right') || easeMode.endsWith('Down')) {
      if (easeMode.startsWith('to') || easeMode.startsWith('yoyo')) {
        value = currentValue + value;
      } else if (easeMode.startsWith('from')) {
        gameObjectManager.setProperty(name, property, currentValue + value);
        value = currentValue;
      }
    } else if (easeMode === 'from') {
      gameObjectManager.setProperty(name, property, value);
      value = currentValue;
    }
    var isYoyo = easeMode.startsWith('yoyo');
    gameObjectManager.easeProperty(name, property, value, duration, ease, repeat, isYoyo);
  };

  var ParseCallbacks = [OnParseAddGameObjectTag, OnParseRemoveAllGameObjectsTag, OnParseCallGameObjectMethodTag, OnParseEaseGameObjectPropertyTag];
  var AddGameObjectManager = GameObjectManagerMethods$1.addGameObjectManager;
  var GameObjectManagerMethods = {
    addGameObjectManager: function addGameObjectManager(config, GameObjectManagerClass) {
      config = config ? Clone$2(config) : {};
      var name = config.name;
      if (!name) {
        console.warn("[TextPlayer] Parameter 'name' is required in addGameObjectManager(config) method");
      }
      var defaultLayer = config.defaultLayer;
      var createGameObject = config.createGameObject;
      var layerManager = this.layerManager;
      config.createGameObject = function (scene) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var gameObject = createGameObject.call.apply(createGameObject, [this, scene].concat(args));
        // this: config.createGameObjectScope

        if (defaultLayer && layerManager) {
          layerManager.addToLayer(defaultLayer, gameObject);
        }
        return gameObject;
      };
      AddGameObjectManager.call(this, config, GameObjectManagerClass);

      // Register parse callbacks
      var customParseCallbacks = config.parseCallbacks;
      if (!customParseCallbacks) {
        customParseCallbacks = ParseCallbacks;
      } else {
        customParseCallbacks = [].concat(_toConsumableArray(customParseCallbacks), ParseCallbacks);
      }
      for (var i = 0, cnt = customParseCallbacks.length; i < cnt; i++) {
        customParseCallbacks[i](this, this.parser, config);
      }
      return this;
    }
  };

  var SetClickTarget = function SetClickTarget(target) {
    this.waitEventManager.setClickTarget(target);
    return this;
  };

  var SetCameraTarget = function SetCameraTarget(camera) {
    this.waitEventManager.setCameraTarget(camera);
    return this;
  };

  var SetNextPageInput = function SetNextPageInput(input) {
    var textPlayer = this;
    if (!input) {
      this.nextPageInput = null;
    } else if (typeof input === 'function') {
      this.nextPageInput = function (callback, scope) {
        var waitEventManager = textPlayer.waitEventManager;
        waitEventManager.clearWaitCompleteCallbacks().addWaitCompleteCallback(callback, scope);
        var waitCompleteTriggerCallback = waitEventManager.getWaitCompleteTriggerCallback();
        input.call(textPlayer, waitCompleteTriggerCallback);
      };
    } else {
      this.nextPageInput = function (callback, scope) {
        WaitAny(textPlayer, input, callback, scope);
      };
    }
  };

  var AddImage = function AddImage(key, config) {
    this.imageManager.add(key, config);
    return this;
  };

  var PlayMethods = {
    play: function play(content) {
      if (this.isPlaying) {
        return this;
      }
      this.removeChildren();
      this.parser.start(content); // Parse bbcode-content

      this.isPlaying = true;
      this.once('complete', function () {
        this.isPlaying = false;
      }, this);
      this.lastWrapResult = undefined;
      this.typingNextPage();
      return this;
    },
    playPromise: function playPromise(content) {
      var promise = WaitComplete(this);
      this.play(content);
      return promise;
    }
  };

  var TypingNextPage = function TypingNextPage() {
    if (!this.isPlaying || this.isPageTyping) {
      return this;
    }
    this.typeWriter.once(PageFadeOutCompleteEvent, _TypingNextPage, this).fadeOutPage();
    return this;
  };
  var _TypingNextPage = function _TypingNextPage() {
    var result = this.runWrap(this.lastWrapResult);
    this.lastWrapResult = result;
    this.emit('page.start');
    var OnTypingPageComplete = function OnTypingPageComplete() {
      this.emit(StopPlayEvent); // Clear registed StopPlayEvent
      if (result.isLastPage) {
        this.emit('complete');
      } else {
        this.emit('page.complete');
        if (this.ignoreNextPageInput) {
          TypingNextPage.call(this);
        } else if (this.nextPageInput) {
          this.nextPageInput(TypingNextPage, this);
        } else ;
      }
    };

    // Remove event when typing pages has been canceled
    this.once(StopPlayEvent, function () {
      this.typeWriter.off('complete', OnTypingPageComplete, this);
    }, this);
    this.typeWriter.once('complete', OnTypingPageComplete, this).start(result.children);
  };

  var PauseMethods = {
    pause: function pause() {
      // Pause typing, typing timer and animation progresses
      this.timeline.pause();
      return this;
    },
    pauseTyping: function pauseTyping() {
      // Pause typing
      this.typeWriter.pauseTyping();
      return this;
    }
  };

  var ResumeMethods = {
    resume: function resume() {
      // Resume typing timer, animation progresses and typing
      this.timeline.resume();
      return this;
    },
    resumeTyping: function resumeTyping(offsetTime) {
      // Resume typing
      this.typeWriter.resumeTyping(offsetTime);
      return this;
    }
  };

  var Wait = function Wait(name) {
    this.typeWriter.wait(name);
    return this;
  };

  var TypingSpeedMethods = {
    setDefaultTypingSpeed: function setDefaultTypingSpeed(speed) {
      this.defaultTypingSpeed = speed;
      return this;
    },
    setTypingSpeed: function setTypingSpeed(speed) {
      this.typingSpeed = speed;
      return this;
    }
  };

  var SetIgnoreWait = function SetIgnoreWait(value) {
    this.typeWriter.setIgnoreWait(value);
    return this;
  };

  var SetIgnoreNextPageInput = function SetIgnoreNextPageInput(enable) {
    if (enable === undefined) {
      enable = true;
    }
    this.ignoreNextPageInput = enable;
    return this;
  };

  var ShowPage = function ShowPage() {
    // Only can work after playing, and before processing last child
    if (!this.isPlaying || !this.isPageTyping) {
      return this;
    }

    // Save parameters
    var typingSpeedSave = this.typeWriter.speed;
    var ignoreWaitSave = this.typeWriter.ignoreWait;
    var skipTypingAnimationSave = this.typeWriter.skipTypingAnimation;
    var skipSoundEffectSave = this.typeWriter.skipSoundEffect;
    this.typeWriter.once('complete', function () {
      // Recover parameters
      this.typeWriter.setTypingSpeed(typingSpeedSave).setIgnoreWait(ignoreWaitSave).setSkipTypingAnimation(skipTypingAnimationSave).setSkipSoundEffect(skipSoundEffectSave);
    }, this).setTypingSpeed(0).skipCurrentTypingDelay().setIgnoreWait(true).setSkipTypingAnimation(true).setSkipSoundEffect(true);
    return this;
  };

  var SpriteMethods = {
    getSprite: function getSprite(name) {
      return this.getGameObject('sprite', name);
    },
    addSprite: function addSprite(name, gameObject) {
      this.addGameObject('sprite', name, gameObject);
      return this;
    }
  };

  var ContentMethods = {
    setContentOutputEnable: function setContentOutputEnable(enable) {
      this.parser.setContentOutputEnable(enable);
      return this;
    },
    setContentCallback: function setContentCallback(callback, scope) {
      this.contentCallback = callback;
      this.contentCallbackScope = scope;
      return this;
    }
  };

  var Methods$b = {
    setClickTarget: SetClickTarget,
    setCameraTarget: SetCameraTarget,
    setNextPageInput: SetNextPageInput,
    addImage: AddImage,
    typingNextPage: TypingNextPage,
    wait: Wait,
    setIgnoreWait: SetIgnoreWait,
    setIgnoreNextPageInput: SetIgnoreNextPageInput,
    showPage: ShowPage
  };
  Object.assign(Methods$b, GameObjectManagerMethods, PlayMethods, PauseMethods, ResumeMethods, TypingSpeedMethods, SpriteMethods, ContentMethods);

  var ClearEvents = function ClearEvents(textPlayer) {
    for (var i = 0, cnt = ClearEvents$1.length; i < cnt; i++) {
      textPlayer.emit(ClearEvents$1[i]);
    }
  };

  var IsPlainObject$H = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$2K = Phaser.Utils.Objects.GetValue;
  var TextPlayer = /*#__PURE__*/function (_Extend) {
    _inherits(TextPlayer, _Extend);
    function TextPlayer(scene, x, y, fixedWidth, fixedHeight, config) {
      var _this;
      _classCallCheck(this, TextPlayer);
      if (IsPlainObject$H(x)) {
        config = x;
      } else if (IsPlainObject$H(fixedWidth)) {
        config = fixedWidth;
      }
      if (config === undefined) {
        config = {};
      }

      // Don't set text in DynamicText's constructor
      var content = config.text;
      delete config.text;
      _this = _callSuper(this, TextPlayer, [scene, x, y, fixedWidth, fixedHeight, config]);
      _this.type = 'rexTextPlayer';
      _this.initManagers(scene, config);
      _this.parser = new Parser(_assertThisInitialized(_this), GetValue$2K(config, 'parser', undefined));
      _this.typeWriter = new TypeWriter(_assertThisInitialized(_this), GetValue$2K(config, 'typing', undefined));
      _this._imageManager = undefined;
      var imageData = GetValue$2K(config, 'images', undefined);
      if (imageData) {
        _this.addImage(imageData);
      }
      var spriteManagerConfig = GetValue$2K(config, 'sprites');
      if (spriteManagerConfig !== false && spriteManagerConfig !== null) {
        AddSpriteManager.call(_assertThisInitialized(_this), spriteManagerConfig);
      }
      _this.setIgnoreNextPageInput(GetValue$2K(config, 'ignoreNextPageInput', false));
      _this.setNextPageInput(GetValue$2K(config, 'nextPageInput', null));
      _this.isPlaying = false;
      if (content) {
        _this.play(content);
      }
      return _this;
    }
    _createClass(TextPlayer, [{
      key: "imageManager",
      get: function get() {
        if (this._imageManager === undefined) {
          this._imageManager = new ImageManager(this.scene);
        }
        return this._imageManager;
      }
    }, {
      key: "spriteManager",
      get: function get() {
        return this.getGameObjectManager('sprite');
      }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        ClearEvents(this);
        this.parser.destroy();
        this.parser = undefined;
        this.typeWriter.destroy(fromScene);
        this.typeWriter = undefined;
        if (this._imageManager) {
          this._imageManager.destroy(fromScene);
        }
        this._imageManager = undefined;
        this.destroyManagers(fromScene);
        _get(_getPrototypeOf(TextPlayer.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "isPageTyping",
      get: function get() {
        return this.typeWriter.isPageTyping;
      }
    }, {
      key: "defaultTypingSpeed",
      get: function get() {
        return this.typeWriter.defaultTypingSpeed;
      },
      set: function set(speed) {
        this.typeWriter.setDefaultTypingSpeed(speed);
      }
    }, {
      key: "typingSpeed",
      get: function get() {
        return this.typeWriter.speed;
      },
      set: function set(speed) {
        this.typeWriter.setTypingSpeed(speed);
      }
    }, {
      key: "timeScale",
      get: function get() {
        return this.getTimeScale();
      },
      set: function set(value) {
        this.setTimeScale(value);
      }
    }]);
    return TextPlayer;
  }(Extend(DynamicText));
  Object.assign(TextPlayer.prototype, Methods$b);

  var ElementProperties$1 = {
    maxLength: ['maxLength', undefined],
    minLength: ['minLength', undefined],
    readOnly: ['readOnly', false]
  };
  var StyleProperties$1 = {
    direction: ['direction', undefined]
  };

  var CopyProperty = function CopyProperty(from, to, key) {
    if (typeof key === 'string') {
      if (from.hasOwnProperty(key)) {
        to[key] = from[key];
      }
    } else {
      var keys = key;
      if (Array.isArray(keys)) {
        for (var i = 0, cnt = keys.length; i < cnt; i++) {
          CopyProperty(from, to, keys[i]);
        }
      } else {
        for (var key in keys) {
          CopyProperty(from, to, key);
        }
      }
    }
  };

  var CopyElementConfig = function CopyElementConfig(from) {
    if (from === undefined) {
      from = {};
    }
    var to = {};
    CopyProperty(from, to, 'inputType');
    CopyProperty(from, to, 'type');
    CopyProperty(from, to, 'style');
    CopyProperty(from, to, StyleProperties$1);
    CopyProperty(from, to, ElementProperties$1);
    return to;
  };

  var IsPointerInHitArea = function IsPointerInHitArea(gameObject, pointer, preTest, postTest) {
    if (pointer) {
      if (preTest && !preTest(gameObject, pointer)) {
        return false;
      }
      if (!HitTest(gameObject, pointer)) {
        return false;
      }
      if (postTest && !postTest(gameObject, pointer)) {
        return false;
      }
      return true;
    } else {
      var inputManager = gameObject.scene.input.manager;
      var pointersTotal = inputManager.pointersTotal;
      var pointers = inputManager.pointers,
        pointer;
      for (var i = 0; i < pointersTotal; i++) {
        pointer = pointers[i];
        if (preTest && !preTest(gameObject, pointer)) {
          continue;
        }
        if (!HitTest(gameObject, pointer)) {
          continue;
        }
        if (postTest && !postTest(gameObject, pointer)) {
          continue;
        }
        return true;
      }
      return false;
    }
  };
  var HitTest = function HitTest(gameObject, pointer) {
    var scene = gameObject.scene;
    var cameras = scene.input.cameras.getCamerasBelowPointer(pointer);
    var inputManager = scene.input.manager;
    var gameObjects = [gameObject];
    for (var i = 0, len = cameras.length; i < len; i++) {
      inputManager.hitTest(pointer, gameObjects, cameras[i], HitTestResult);
      if (HitTestResult.length > 0) {
        HitTestResult.length = 0;
        return true;
      }
    }
    HitTestResult.length = 0;
    return false;
  };
  var HitTestResult = [];

  var LastOpenedEditor$1 = undefined;
  var SetLastOpenedEditor$1 = function SetLastOpenedEditor(editor) {
    if (editor === LastOpenedEditor$1) {
      return;
    }
    if (LastOpenedEditor$1 !== undefined) {
      LastOpenedEditor$1.close();
    }
    LastOpenedEditor$1 = editor;
  };
  var CloseLastOpenEditor$1 = function CloseLastOpenEditor(editor) {
    if (editor !== LastOpenedEditor$1) {
      return;
    }

    // Don't call `LastOpenedEditor.close()`
    LastOpenedEditor$1 = undefined;
  };

  var GetValue$2J = Phaser.Utils.Objects.GetValue;
  var SetProperties = function SetProperties(properties, config, out) {
    if (out === undefined) {
      out = {};
    }
    var property, value;
    for (var key in properties) {
      property = properties[key]; // [propName, defaultValue]
      value = GetValue$2J(config, key, property[1]);
      if (value !== undefined) {
        out[property[0]] = value;
      }
    }
    return out;
  };

  var StopPropagationTouchEvents = function StopPropagationTouchEvents(element) {
    // Don't propagate touch/mouse events to parent(game canvas)
    element.addEventListener('touchstart', callback, false);
    element.addEventListener('touchmove', callback, false);
    element.addEventListener('touchend', callback, false);
    element.addEventListener('mousedown', callback, false);
    element.addEventListener('mouseup', callback, false);
    element.addEventListener('mousemove', callback, false);
  };
  var callback = function callback(e) {
    e.stopPropagation();
  };

  var EnterClose = function EnterClose() {
    this.close();
    this.emit('keydown-ENTER', this.parent, this);
    return this;
  };

  var OnOpen = function OnOpen() {
    this.isOpened = true;
    this.initText();
    if (this.enterCloseEnable) {
      this.scene.input.keyboard.once('keydown-ENTER', EnterClose, this);
    }

    // There is no cursor-position-change event, 
    // so updating cursor position every tick
    this.scene.sys.events.on('postupdate', this.updateText, this);
    this.scene.input.on('pointerdown', this.onClickOutside, this);
    if (this.onOpenCallback) {
      this.onOpenCallback(this.parent, this);
    }
    this.emit('open', this);
  };

  var RemoveElement = function RemoveElement(element) {
    if (!element) {
      return;
    }
    var parentElement = element.parentElement;
    if (parentElement) {
      parentElement.removeChild(element);
    }
  };

  var OnClose = function OnClose() {
    this.isOpened = false;
    this.updateText();
    this.scene.sys.events.off('postupdate', this.updateText, this);
    this.scene.input.off('pointerdown', this.onClickOutside, this);
    if (this.onCloseCallback) {
      this.onCloseCallback(this.parent, this);
    }

    // Remove input text element when closing editor
    RemoveElement(this.node);
    this.node = undefined;
    this.emit('close', this);
  };

  var GetValue$2I = Phaser.Utils.Objects.GetValue;
  var CreateElement = function CreateElement(parent, config) {
    var element;
    var textType = GetValue$2I(config, 'inputType', undefined);
    if (textType === undefined) {
      textType = GetValue$2I(config, 'type', 'text');
    }
    if (textType === 'textarea') {
      element = document.createElement('textarea');
      element.style.resize = 'none';
    } else {
      element = document.createElement('input');
      element.type = textType;
    }
    var style = GetValue$2I(config, 'style', undefined);
    // Apply other style properties
    var elementStyle = element.style;
    SetProperties(StyleProperties$1, style, elementStyle);
    // Set style
    elementStyle.position = 'absolute';
    elementStyle.opacity = 0;
    elementStyle.pointerEvents = 'none';
    elementStyle.zIndex = 0;
    // hide native blue text cursor on iOS
    elementStyle.transform = 'scale(0)';
    SetProperties(ElementProperties$1, config, element);

    // Don't propagate touch/mouse events to parent(game canvas)
    StopPropagationTouchEvents(element);

    // Attach element to fullscreenTarget in full screen mode
    var scaleManager = parent.scene.sys.scale;
    var parentElement = scaleManager.isFullscreen ? scaleManager.fullscreenTarget : document.body;
    parentElement.appendChild(element);

    // open() -> 'focus' -> OnOpen
    element.addEventListener('focus', function (e) {
      OnOpen.call(parent);
    });

    // close() -> 'blur' -> OnClose
    element.addEventListener('blur', function (e) {
      OnClose.call(parent);
    });
    return element;
  };

  var Open$2 = function Open() {
    // Already opened
    if (this.isOpened) {
      return this;
    }
    // Read only
    if (this.readOnly) {
      return this;
    }
    SetLastOpenedEditor$1(this);
    if (!this.node) {
      // Create input text element when opening editor
      this.node = CreateElement(this, this.nodeConfig);
      // Register 'focus', 'blur' events
    }
    this.setFocus();

    // 'focus' event -> OnOpen

    return this;
  };

  var Close$1 = function Close() {
    // Already closed
    if (!this.isOpened) {
      return this;
    }
    CloseLastOpenEditor$1(this);
    this.setBlur();

    // 'blur' event -> OnOpen

    return this;
  };

  var Methods$a = {
    open: Open$2,
    close: Close$1
  };

  var GetValue$2H = Phaser.Utils.Objects.GetValue;
  var HiddenTextEditBase = /*#__PURE__*/function (_ComponentBase) {
    _inherits(HiddenTextEditBase, _ComponentBase);
    function HiddenTextEditBase(gameObject, config) {
      var _this;
      _classCallCheck(this, HiddenTextEditBase);
      _this = _callSuper(this, HiddenTextEditBase, [gameObject]);
      // this.parent = gameObject;

      var textType = GetValue$2H(config, 'inputType', undefined);
      if (textType === undefined) {
        textType = GetValue$2H(config, 'type', 'text');
      }
      _this.setEnterCloseEnable(GetValue$2H(config, 'enterClose', textType !== 'textarea'));
      var onOpen = GetValue$2H(config, 'onOpen', undefined);
      if (!onOpen) {
        onOpen = GetValue$2H(config, 'onFocus', undefined);
      }
      _this.onOpenCallback = onOpen;
      var onClose = GetValue$2H(config, 'onClose', undefined);
      if (!onClose) {
        onClose = GetValue$2H(config, 'onBlur', undefined);
      }
      _this.onCloseCallback = onClose;
      _this.onUpdateCallback = GetValue$2H(config, 'onUpdate', undefined);
      _this.isOpened = false;
      gameObject.on('pointerdown', function () {
        this.open();
      }, _assertThisInitialized(_this)).setInteractive();
      _this.nodeConfig = CopyElementConfig(config);
      // Create/remove input text element when opening/closing editor
      _this.node = undefined;
      return _this;
    }
    _createClass(HiddenTextEditBase, [{
      key: "destroy",
      value: function destroy() {
        // this.parent.off('pointerdown', this.open, this);

        this.close();
        _get(_getPrototypeOf(HiddenTextEditBase.prototype), "destroy", this).call(this);
      }
    }, {
      key: "onClickOutside",
      value: function onClickOutside(pointer) {
        if (!IsPointerInHitArea(this.parent, pointer)) {
          this.close();
        }
      }
    }, {
      key: "setEnterCloseEnable",
      value: function setEnterCloseEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.enterCloseEnable = enable;
        return this;
      }

      // Override
    }, {
      key: "initText",
      value: function initText() {}

      // Override, invoking under 'postupdate' event of scene
    }, {
      key: "updateText",
      value: function updateText() {}

      // Copy from InputText class
    }, {
      key: "text",
      get: function get() {
        if (!this.node) {
          return '';
        }
        return this.node.value;
      },
      set: function set(value) {
        if (!this.node) {
          return;
        }
        this.node.value = value;
      }
    }, {
      key: "setText",
      value: function setText(value) {
        // Override
        this.text = value;
        return this;
      }
    }, {
      key: "maxLength",
      get: function get() {
        return this.nodeConfig.maxLength;
      },
      set: function set(value) {
        this.nodeConfig.maxLength = value;
        if (this.node) {
          this.node.maxLength = value;
        }
      }
    }, {
      key: "setMaxLength",
      value: function setMaxLength(value) {
        this.maxLength = value;
        return this;
      }
    }, {
      key: "minLength",
      get: function get() {
        return this.nodeConfig.minLength;
      },
      set: function set(value) {
        this.nodeConfig.minLength = value;
        if (this.node) {
          this.node.minLength = value;
        }
      }
    }, {
      key: "setMinLength",
      value: function setMinLength(value) {
        this.minLength = value;
        return this;
      }
    }, {
      key: "placeholder",
      get: function get() {
        return this.node.placeholder;
      },
      set: function set(value) {
        if (!this.node) {
          return;
        }
        this.node.placeholder = value;
      }
    }, {
      key: "setPlaceholder",
      value: function setPlaceholder(value) {
        this.placeholder = value;
        return this;
      }
    }, {
      key: "selectText",
      value: function selectText(selectionStart, selectionEnd) {
        if (!this.node) {
          return this;
        }
        if (selectionStart === undefined) {
          this.node.select();
        } else {
          this.node.setSelectionRange(selectionStart, selectionEnd);
        }
        return this;
      }
    }, {
      key: "selectAll",
      value: function selectAll() {
        this.selectText();
        return this;
      }
    }, {
      key: "selectionStart",
      get: function get() {
        if (!this.node) {
          return 0;
        }
        return this.node.selectionStart;
      }
    }, {
      key: "selectionEnd",
      get: function get() {
        if (!this.node) {
          return 0;
        }
        return this.node.selectionEnd;
      }
    }, {
      key: "selectedText",
      get: function get() {
        if (!this.node) {
          return '';
        }
        var node = this.node;
        return node.value.substring(node.selectionStart, node.selectionEnd);
      }
    }, {
      key: "cursorPosition",
      get: function get() {
        if (!this.node) {
          return 0;
        }
        return this.node.selectionStart;
      },
      set: function set(value) {
        if (!this.node) {
          return;
        }
        this.node.setSelectionRange(value, value);
      }
    }, {
      key: "setCursorPosition",
      value: function setCursorPosition(value) {
        if (value === undefined) {
          value = this.text.length;
        } else if (value < 0) {
          value = this.text.length + value;
        }
        this.cursorPosition = value;
        return this;
      }
    }, {
      key: "tooltip",
      get: function get() {
        if (!this.node) {
          return '';
        }
        return this.node.title;
      },
      set: function set(value) {
        if (!this.node) {
          return this;
        }
        this.node.title = value;
      }
    }, {
      key: "setTooltip",
      value: function setTooltip(value) {
        this.tooltip = value;
        return this;
      }
    }, {
      key: "setTextChangedCallback",
      value: function setTextChangedCallback(callback) {
        this.onTextChanged = callback;
        return this;
      }
    }, {
      key: "readOnly",
      get: function get() {
        return this.nodeConfig.readOnly;
      },
      set: function set(value) {
        this.nodeConfig.readOnly = value;
        if (this.node) {
          this.node.readOnly = value;
        }
      }
    }, {
      key: "setReadOnly",
      value: function setReadOnly(value) {
        if (value === undefined) {
          value = true;
        }
        this.readOnly = value;
        return this;
      }
    }, {
      key: "spellCheck",
      get: function get() {
        if (!this.node) {
          return '';
        }
        return this.node.spellcheck;
      },
      set: function set(value) {
        if (!this.node) {
          return;
        }
        this.node.spellcheck = value;
      }
    }, {
      key: "setSpellCheck",
      value: function setSpellCheck(value) {
        this.spellCheck = value;
        return this;
      }
    }, {
      key: "fontColor",
      get: function get() {
        if (!this.node) {
          return undefined;
        }
        return this.node.style.color;
      },
      set: function set(value) {
        if (!this.node) {
          return;
        }
        this.node.style.color = value;
      }
    }, {
      key: "setFontColor",
      value: function setFontColor(value) {
        this.fontColor = value;
        return this;
      }
    }, {
      key: "setStyle",
      value: function setStyle(key, value) {
        if (!this.node) {
          return this;
        }
        this.node.style[key] = value;
        return this;
      }
    }, {
      key: "getStyle",
      value: function getStyle(key) {
        if (!this.node) {
          return undefined;
        }
        return this.node.style[key];
      }
    }, {
      key: "scrollToBottom",
      value: function scrollToBottom() {
        if (!this.node) {
          return this;
        }
        this.node.scrollTop = this.node.scrollHeight;
        return this;
      }
    }, {
      key: "setEnabled",
      value: function setEnabled(enabled) {
        if (!this.node) {
          return this;
        }
        if (enabled === undefined) {
          enabled = true;
        }
        this.node.disabled = !enabled;
        return this;
      }
    }, {
      key: "setBlur",
      value: function setBlur() {
        if (!this.node) {
          return this;
        }
        this.node.blur();
        return this;
      }
    }, {
      key: "setFocus",
      value: function setFocus() {
        if (!this.node) {
          return this;
        }
        this.node.focus();
        return this;
      }
    }, {
      key: "isFocused",
      get: function get() {
        return this.isOpened;
      }
    }]);
    return HiddenTextEditBase;
  }(ComponentBase);
  Object.assign(HiddenTextEditBase.prototype, Methods$a);

  var NumberInputUpdateCallback = function NumberInputUpdateCallback(text, textObject, hiddenInputText) {
    text = text.replace(' ', '');
    var previousText = hiddenInputText.previousText;
    if (text === previousText) {
      return text;
    }
    if (isNaN(text)) {
      // Enter a NaN character, back to previous text
      hiddenInputText.emit('nan', text, hiddenInputText);
      text = previousText;
      var cursorPosition = hiddenInputText.cursorPosition - 1;
      hiddenInputText.setText(text);
      hiddenInputText.setCursorPosition(cursorPosition);
    } else {
      // New number text, update previous texr
      hiddenInputText.previousText = text;
    }
    return text;
  };

  var SelectRange = function SelectRange(hiddenTextEdit) {
    var textObject = hiddenTextEdit.parent;
    // var text = textObject.text;
    var selectionStart = hiddenTextEdit.isOpened ? hiddenTextEdit.selectionStart : null;
    var selectionEnd = hiddenTextEdit.isOpened ? hiddenTextEdit.selectionEnd : null;
    var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
    var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;
    if (prevSelectionStart === selectionStart && prevSelectionEnd === selectionEnd) {
      return;
    }
    var min, max;
    if (prevSelectionStart === null) {
      min = selectionStart;
      max = selectionEnd;
    } else if (selectionStart === null) {
      min = prevSelectionStart;
      max = prevSelectionEnd;
    } else {
      min = Math.min(prevSelectionStart, selectionStart);
      max = Math.max(prevSelectionEnd, selectionEnd);
    }
    for (var i = min; i < max; i++) {
      var inPrevSelectionRange;
      if (prevSelectionStart === null) {
        inPrevSelectionRange = false;
      } else {
        inPrevSelectionRange = i >= prevSelectionStart && i < prevSelectionEnd;
      }
      var inSelectionRange;
      if (selectionStart === null) {
        inSelectionRange = false;
      } else {
        inSelectionRange = i >= selectionStart && i < selectionEnd;
      }
      if (inPrevSelectionRange === inSelectionRange) {
        continue;
      }
      var child = textObject.getCharChild(i);
      if (child) {
        var eventName = inPrevSelectionRange ? 'cursorout' : 'cursorin';
        textObject.emit(eventName, child, i, textObject);
      }
    }
    hiddenTextEdit.prevSelectionStart = selectionStart;
    hiddenTextEdit.prevSelectionEnd = selectionEnd;
  };

  var ScrollToBob = function ScrollToBob(bob) {
    var textObject = bob.parent;
    var textObjectLeftX = 0,
      textObjectRightX = textObject.width,
      textObjectTopY = 0,
      textObjectBottomY = textObject.height;
    var childX = bob.drawX,
      childY = bob.drawY;
    var childLeftX = childX + bob.drawTLX,
      childRightX = childX + bob.drawTRX,
      childTopY = childY + bob.drawTLY,
      childBottomY = childY + bob.drawBLY;
    var dx;
    if (childLeftX < textObjectLeftX) {
      dx = textObjectLeftX - childLeftX;
    } else if (childRightX > textObjectRightX) {
      dx = textObjectRightX - childRightX;
    } else {
      dx = 0;
    }
    var dy;
    if (childTopY < textObjectTopY) {
      dy = textObjectTopY - childTopY;
    } else if (childBottomY > textObjectBottomY) {
      dy = textObjectBottomY - childBottomY;
    } else {
      dy = 0;
    }
    textObject._textOX += dx;
    textObject._textOY += dy;
  };

  var MoveCursor = function MoveCursor(hiddenTextEdit) {
    var textObject = hiddenTextEdit.parent;
    var text = textObject.text;
    var cursorPosition = hiddenTextEdit.cursorPosition;
    if (hiddenTextEdit.prevCursorPosition === cursorPosition) {
      return;
    }
    if (hiddenTextEdit.prevCursorPosition !== null) {
      if (hiddenTextEdit.prevCursorPosition > text.length) {
        hiddenTextEdit.prevCursorPosition = null;
      }
    }
    if (hiddenTextEdit.prevCursorPosition !== null) {
      var child = textObject.getCharChild(hiddenTextEdit.prevCursorPosition);
      if (child) {
        // Rollback size of new line child
        if (child.text === '\n') {
          child.clearTextSize();
        }
        textObject.emit('cursorout', child, hiddenTextEdit.prevCursorPosition, textObject);
      }
    }
    if (cursorPosition != null) {
      var child = textObject.getCharChild(cursorPosition);
      if (child) {
        // Display new line child
        if (child.text === '\n') {
          child.copyTextSize(textObject.lastInsertCursor);
        }
        ScrollToBob(child);
        textObject.emit('cursorin', child, cursorPosition, textObject);
      }
    }
    textObject.emit('movecursor', cursorPosition, hiddenTextEdit.prevCursorPosition, textObject);
    hiddenTextEdit.prevCursorPosition = cursorPosition;
  };

  var ClearSelectRange = function ClearSelectRange(hiddenTextEdit) {
    var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
    if (prevSelectionStart === null) {
      return;
    }
    var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;
    var textObject = hiddenTextEdit.parent;
    for (var i = prevSelectionStart; i < prevSelectionEnd; i++) {
      var child = textObject.getCharChild(i);
      if (child) {
        textObject.emit('cursorout', child, i, textObject);
      }
    }
    hiddenTextEdit.prevSelectionStart = null;
    hiddenTextEdit.prevSelectionEnd = null;
  };

  var ClearCursor = function ClearCursor(hiddenTextEdit) {
    var prevCursorPosition = hiddenTextEdit.prevCursorPosition;
    if (prevCursorPosition === null) {
      return;
    }
    var textObject = hiddenTextEdit.parent;
    var child = textObject.getCharChild(prevCursorPosition);
    if (child) {
      textObject.emit('cursorout', child, prevCursorPosition, textObject);
    }
    hiddenTextEdit.prevCursorPosition = null;
  };

  var GetValue$2G = Phaser.Utils.Objects.GetValue;
  var HiddenTextEdit = /*#__PURE__*/function (_HiddenTextEditBase) {
    _inherits(HiddenTextEdit, _HiddenTextEditBase);
    function HiddenTextEdit(gameObject, config) {
      var _this;
      _classCallCheck(this, HiddenTextEdit);
      _this = _callSuper(this, HiddenTextEdit, [gameObject, config]);
      // this.parent = gameObject;

      _this.setSelectAllWhenFocusEnable(GetValue$2G(config, 'selectAll', false));
      _this.cursorMoveStartIndex = null;
      _this.prevCursorPosition = null;
      _this.prevSelectionStart = null;
      _this.prevSelectionEnd = null;
      _this.firstClickAfterOpen = false;
      gameObject
      // Open editor by 'pointerdown' event
      // Then set cursor position to nearest char
      .on('pointerdown', function (pointer, localX, localY, event) {
        var child = gameObject.getNearestChild(localX, localY);
        var charIndex = gameObject.getCharIndex(child);
        if (!this.selectAllWhenFocus || !this.firstClickAfterOpen) {
          this.setCursorPosition(charIndex);
        }
        this.cursorMoveStartIndex = charIndex;
        this.firstClickAfterOpen = false;
      }, _assertThisInitialized(_this)).on('pointermove', function (pointer, localX, localY, event) {
        if (!pointer.isDown) {
          return;
        }
        var child = gameObject.getNearestChild(localX, localY);
        var charIndex = gameObject.getCharIndex(child);
        if (this.cursorMoveStartIndex < charIndex) {
          this.selectText(this.cursorMoveStartIndex, charIndex + 1);
        } else {
          this.selectText(charIndex, this.cursorMoveStartIndex + 1);
        }
      }, _assertThisInitialized(_this));
      _this.on('open', function () {
        if (this.selectAllWhenFocus) {
          this.selectAll();
        }
        this.firstClickAfterOpen = true;
        gameObject.emit('open');
      }, _assertThisInitialized(_this)).on('close', function () {
        // Route 'close' event
        gameObject.emit('close');
      }).on('keydown-ENTER', function () {
        // Route 'keydown-ENTER' event
        gameObject.emit('keydown-ENTER');
      });
      return _this;
    }
    _createClass(HiddenTextEdit, [{
      key: "initText",
      value: function initText() {
        var textObject = this.parent;
        this.prevCursorPosition = null;
        this.setText(textObject.text);
        return this;
      }
    }, {
      key: "updateText",
      value: function updateText() {
        var textObject = this.parent;
        var text = this.text;
        if (this.onUpdateCallback) {
          var newText = this.onUpdateCallback(text, textObject, this);
          if (newText != null) {
            text = newText;
          }
        }
        if (textObject.text !== text) {
          textObject.setText(text);
        }
        if (this.isOpened) {
          if (this.selectionStart !== this.selectionEnd) {
            ClearCursor(this);
            SelectRange(this);
          } else {
            ClearSelectRange(this);
            MoveCursor(this);
          }
        } else {
          ClearSelectRange(this);
          ClearCursor(this);
        }
        return this;
      }
    }, {
      key: "setNumberInput",
      value: function setNumberInput() {
        this.onUpdateCallback = NumberInputUpdateCallback;
        return this;
      }
    }, {
      key: "setSelectAllWhenFocusEnable",
      value: function setSelectAllWhenFocusEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.selectAllWhenFocus = enable;
        return this;
      }
    }]);
    return HiddenTextEdit;
  }(HiddenTextEditBase);

  var GetValue$2F = Phaser.Utils.Objects.GetValue;
  var PropertiesList = ['inputType', 'onOpen', 'onFocus', 'onClose', 'onBlur', 'onUpdate', 'enterClose', 'readOnly', 'maxLength', 'minLength', 'selectAll'];
  var CreateHiddenTextEdit = function CreateHiddenTextEdit(parent, parentConfig) {
    var config = GetValue$2F(parentConfig, 'edit');
    if (config === undefined) {
      config = {};
    }
    CopyProperty(parentConfig, config, PropertiesList);
    return new HiddenTextEdit(parent, config);
  };

  var HasValue = function HasValue(source, key) {
    if (!source || typeof source === 'number') {
      return false;
    } else if (source.hasOwnProperty(key)) {
      return true;
    } else if (key.indexOf('.') !== -1) {
      var keys = key.split('.');
      var parent = source;

      //  Use for loop here so we can break early
      for (var i = 0; i < keys.length; i++) {
        if (parent.hasOwnProperty(keys[i])) {
          parent = parent[keys[i]];
        } else {
          //  Can't go any further
          return false;
        }
      }
      return true;
    } else {
      return false;
    }
  };

  var IsInValidKey = function IsInValidKey(keys) {
    return keys == null || keys === '' || keys.length === 0;
  };
  var GetEntry = function GetEntry(target, keys, defaultEntry) {
    var entry = target;
    if (IsInValidKey(keys)) ; else {
      if (typeof keys === 'string') {
        keys = keys.split('.');
      }
      var key;
      for (var i = 0, cnt = keys.length; i < cnt; i++) {
        key = keys[i];
        if (entry[key] == null || _typeof(entry[key]) !== 'object') {
          var newEntry;
          if (i === cnt - 1) {
            if (defaultEntry === undefined) {
              newEntry = {};
            } else {
              newEntry = defaultEntry;
            }
          } else {
            newEntry = {};
          }
          entry[key] = newEntry;
        }
        entry = entry[key];
      }
    }
    return entry;
  };
  var SetValue = function SetValue(target, keys, value, delimiter) {
    if (delimiter === undefined) {
      delimiter = '.';
    }

    // no object
    if (_typeof(target) !== 'object') {
      return;
    }

    // invalid key
    else if (IsInValidKey(keys)) {
      // don't erase target
      if (value == null) {
        return;
      }
      // set target to another object
      else if (_typeof(value) === 'object') {
        target = value;
      }
    } else {
      if (typeof keys === 'string') {
        keys = keys.split(delimiter);
      }
      var lastKey = keys.pop();
      var entry = GetEntry(target, keys);
      entry[lastKey] = value;
    }
    return target;
  };

  var InjectDefaultConfig = function InjectDefaultConfig(config) {
    var isSingleLineMode = !config.textArea;
    if (!HasValue(config, 'wrap.vAlign')) {
      var defaultValue = isSingleLineMode ? 'center' : 'top';
      SetValue(config, 'wrap.vAlign', defaultValue);
    }
    if (!HasValue(config, 'wrap.charWrap')) {
      SetValue(config, 'wrap.charWrap', true);
    }
    if (!HasValue(config, 'wrap.maxLines')) {
      var defaultValue = isSingleLineMode ? 1 : undefined;
      SetValue(config, 'wrap.maxLines', defaultValue);
    }
    if (isSingleLineMode) {
      SetValue(config, 'wrap.wrapWidth', Infinity);
    }
    if (!HasValue(config, 'wrap.useDefaultTextHeight')) {
      SetValue(config, 'wrap.useDefaultTextHeight', true);
    }
    if (!config.edit) {
      config.edit = {};
    }
    if (!HasValue(config.edit, 'inputType')) {
      var defaultValue = isSingleLineMode ? 'text' : 'textarea';
      SetValue(config.edit, 'inputType', defaultValue);
    }
    return config;
  };

  var ExtractByPrefix = function ExtractByPrefix(obj, prefix, delimiter, out) {
    if (delimiter === undefined) {
      delimiter = '.';
    }
    if (out === undefined) {
      out = {};
    }
    if (!obj) {
      return out;
    }
    if (prefix in obj) {
      return Object.assign(out, obj[prefix]);
    }
    prefix += delimiter;
    for (var key in obj) {
      if (!key.startsWith(prefix)) {
        continue;
      }
      out[key.replace(prefix, '')] = obj[key];
    }
    return out;
  };

  var GetPartialData = function GetPartialData(obj, keys, out) {
    if (out === undefined) {
      out = {};
    }
    if (Array.isArray(keys)) {
      var key;
      for (var i = 0, cnt = keys.length; i < cnt; i++) {
        key = keys[i];
        out[key] = obj[key];
      }
    } else {
      for (var key in keys) {
        out[key] = obj[key];
      }
    }
    return out;
  };

  var IsKeyValueEqual = function IsKeyValueEqual(objA, objB) {
    for (var key in objA) {
      if (!(key in objB)) {
        return false;
      }
      if (objA[key] !== objB[key]) {
        return false;
      }
    }
    for (var key in objB) {
      if (!(key in objA)) {
        return false;
      }
    }
    return true;
  };

  var RegisterCursorStyle = function RegisterCursorStyle(cursorStyle) {
    if (IsEmpty(cursorStyle)) {
      return;
    }
    this.setCursorStyle(cursorStyle).on('cursorin', function (child) {
      var cursorStyle = this.cursorStyle;
      var styleSave = GetPartialData(child.style, cursorStyle);
      if (IsKeyValueEqual(cursorStyle, styleSave)) {
        return;
      }
      child.styleSave = styleSave;
      child.modifyStyle(cursorStyle);
    }, this).on('cursorout', function (child) {
      if (!child.styleSave) {
        return;
      }
      child.modifyStyle(child.styleSave);
      child.styleSave = undefined;
    }, this);
  };

  var RegisterFocusStyle = function RegisterFocusStyle(focusStyle) {
    if (IsEmpty(focusStyle)) {
      return;
    }
    this.setFocusStyle(focusStyle).on('open', function () {
      var child = this.background;
      var focusStyle = this.focusStyle;
      var styleSave = GetPartialData(child, focusStyle);
      if (IsKeyValueEqual(focusStyle, styleSave)) {
        return;
      }
      child.styleSave = styleSave;
      child.modifyStyle(focusStyle);
    }, this).on('close', function () {
      var child = this.background;
      if (!child.styleSave) {
        return;
      }
      child.modifyStyle(child.styleSave);
      child.styleSave = undefined;
    }, this);
  };

  var CreateInsertCursorChild = function CreateInsertCursorChild(textObject) {
    var child = textObject.createCharChild('|'); // Use '|' to update render size
    child.text = ''; // Render empty string ''

    return child;
  };

  function Diff() {}
  Diff.prototype = {
    diff: function diff(oldString, newString) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = options.callback;
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      this.options = options;
      var self = this;
      function done(value) {
        if (callback) {
          setTimeout(function () {
            callback(undefined, value);
          }, 0);
          return true;
        } else {
          return value;
        }
      }

      // Allow subclasses to massage the input prior to running
      oldString = this.castInput(oldString);
      newString = this.castInput(newString);
      oldString = this.removeEmpty(this.tokenize(oldString));
      newString = this.removeEmpty(this.tokenize(newString));
      var newLen = newString.length,
        oldLen = oldString.length;
      var editLength = 1;
      var maxEditLength = newLen + oldLen;
      if (options.maxEditLength) {
        maxEditLength = Math.min(maxEditLength, options.maxEditLength);
      }
      var bestPath = [{
        newPos: -1,
        components: []
      }];

      // Seed editLength = 0, i.e. the content starts with the same values
      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        // Identity per the equality and tokenizer
        return done([{
          value: this.join(newString),
          count: newString.length
        }]);
      }

      // Main worker method. checks all permutations of a given edit length for acceptance.
      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = void 0;
          var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
          if (addPath) {
            // No one else is going to attempt to use this value, clear it
            bestPath[diagonalPath - 1] = undefined;
          }
          var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
          if (!canAdd && !canRemove) {
            // If this path is a terminal then prune
            bestPath[diagonalPath] = undefined;
            continue;
          }

          // Select the diagonal that we want to branch from. We select the prior
          // path whose position in the new string is the farthest from the origin
          // and does not pass the bounds of the diff graph
          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath);
            self.pushComponent(basePath.components, undefined, true);
          } else {
            basePath = addPath; // No need to clone, we've pulled it from the list
            basePath.newPos++;
            self.pushComponent(basePath.components, true, undefined);
          }
          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

          // If we have hit the end of both strings, then we are done
          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
          } else {
            // Otherwise track this path as a potential candidate and continue.
            bestPath[diagonalPath] = basePath;
          }
        }
        editLength++;
      }

      // Performs the length of edit iteration. Is a bit fugly as this has to support the
      // sync and async mode which is never fun. Loops over execEditLength until a value
      // is produced, or until the edit length exceeds options.maxEditLength (if given),
      // in which case it will return undefined.
      if (callback) {
        (function exec() {
          setTimeout(function () {
            if (editLength > maxEditLength) {
              return callback();
            }
            if (!execEditLength()) {
              exec();
            }
          }, 0);
        })();
      } else {
        while (editLength <= maxEditLength) {
          var ret = execEditLength();
          if (ret) {
            return ret;
          }
        }
      }
    },
    pushComponent: function pushComponent(components, added, removed) {
      var last = components[components.length - 1];
      if (last && last.added === added && last.removed === removed) {
        // We need to clone here as the component clone operation is just
        // as shallow array clone
        components[components.length - 1] = {
          count: last.count + 1,
          added: added,
          removed: removed
        };
      } else {
        components.push({
          count: 1,
          added: added,
          removed: removed
        });
      }
    },
    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
      var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;
      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
        newPos++;
        oldPos++;
        commonCount++;
      }
      if (commonCount) {
        basePath.components.push({
          count: commonCount
        });
      }
      basePath.newPos = newPos;
      return oldPos;
    },
    equals: function equals(left, right) {
      if (this.options.comparator) {
        return this.options.comparator(left, right);
      } else {
        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }
    },
    removeEmpty: function removeEmpty(array) {
      var ret = [];
      for (var i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i]);
        }
      }
      return ret;
    },
    castInput: function castInput(value) {
      return value;
    },
    tokenize: function tokenize(value) {
      return value.split('');
    },
    join: function join(chars) {
      return chars.join('');
    }
  };
  function buildValues(diff, components, newString, oldString, useLongestToken) {
    var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      var component = components[componentPos];
      if (!component.removed) {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count);
          value = value.map(function (value, i) {
            var oldValue = oldString[oldPos + i];
            return oldValue.length > value.length ? oldValue : value;
          });
          component.value = diff.join(value);
        } else {
          component.value = diff.join(newString.slice(newPos, newPos + component.count));
        }
        newPos += component.count;

        // Common case
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
        oldPos += component.count;

        // Reverse add and remove so removes are output first to match common convention
        // The diffing algorithm is tied to add then remove output and this is the simplest
        // route to get the desired output with minimal overhead.
        if (componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos];
          components[componentPos] = tmp;
        }
      }
    }

    // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.
    var lastComponent = components[componentLen - 1];
    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
      components[componentLen - 2].value += lastComponent.value;
      components.pop();
    }
    return components;
  }
  function clonePath(path) {
    return {
      newPos: path.newPos,
      components: path.components.slice(0)
    };
  }

  var characterDiff = new Diff();
  function diffChars(oldStr, newStr, options) {
    return characterDiff.diff(oldStr, newStr, options);
  }

  // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
  //
  // Ranges and exceptions:
  // Latin-1 Supplement, 008000FF
  //  - U+00D7   Multiplication sign
  //  - U+00F7   Division sign
  // Latin Extended-A, 0100017F
  // Latin Extended-B, 0180024F
  // IPA Extensions, 025002AF
  // Spacing Modifier Letters, 02B002FF
  //  - U+02C7   &#711;  Caron
  //  - U+02D8   &#728;  Breve
  //  - U+02D9   &#729;  Dot Above
  //  - U+02DA   &#730;  Ring Above
  //  - U+02DB   &#731;  Ogonek
  //  - U+02DC   &#732;  Small Tilde
  //  - U+02DD   &#733;  Double Acute Accent
  // Latin Extended Additional, 1E001EFF
  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
  var reWhitespace = /\S/;
  var wordDiff = new Diff();
  wordDiff.equals = function (left, right) {
    if (this.options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
  };
  wordDiff.tokenize = function (value) {
    // All whitespace symbols except newline group into one token, each newline - in separate token
    var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);

    // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
    for (var i = 0; i < tokens.length - 1; i++) {
      // If we have an empty string in the next field and we have only word chars before and after, merge
      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
        tokens[i] += tokens[i + 2];
        tokens.splice(i + 1, 2);
        i--;
      }
    }
    return tokens;
  };

  var lineDiff = new Diff();
  lineDiff.tokenize = function (value) {
    var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/);

    // Ignore the final empty token that occurs if the string ends with a new line
    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop();
    }

    // Merge the content and line separators into single tokens
    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i];
      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line;
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim();
        }
        retLines.push(line);
      }
    }
    return retLines;
  };

  var sentenceDiff = new Diff();
  sentenceDiff.tokenize = function (value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
  };

  var cssDiff = new Diff();
  cssDiff.tokenize = function (value) {
    return value.split(/([{}:;,]|\s+)/);
  };

  var objectPrototypeToString = Object.prototype.toString;
  var jsonDiff = new Diff();
  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
  jsonDiff.useLongestToken = true;
  jsonDiff.tokenize = lineDiff.tokenize;
  jsonDiff.castInput = function (value) {
    var _this$options = this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
        return typeof v === 'undefined' ? undefinedReplacement : v;
      } : _this$options$stringi;
    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
  };
  jsonDiff.equals = function (left, right) {
    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
  };

  // This function handles the presence of circular references by bailing out when encountering an
  // object that is already on the "stack" of items being processed. Accepts an optional replacer
  function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [];
    replacementStack = replacementStack || [];
    if (replacer) {
      obj = replacer(key, obj);
    }
    var i;
    for (i = 0; i < stack.length; i += 1) {
      if (stack[i] === obj) {
        return replacementStack[i];
      }
    }
    var canonicalizedObj;
    if ('[object Array]' === objectPrototypeToString.call(obj)) {
      stack.push(obj);
      canonicalizedObj = new Array(obj.length);
      replacementStack.push(canonicalizedObj);
      for (i = 0; i < obj.length; i += 1) {
        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
      }
      stack.pop();
      replacementStack.pop();
      return canonicalizedObj;
    }
    if (obj && obj.toJSON) {
      obj = obj.toJSON();
    }
    if (_typeof(obj) === 'object' && obj !== null) {
      stack.push(obj);
      canonicalizedObj = {};
      replacementStack.push(canonicalizedObj);
      var sortedKeys = [],
        _key;
      for (_key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(_key)) {
          sortedKeys.push(_key);
        }
      }
      sortedKeys.sort();
      for (i = 0; i < sortedKeys.length; i += 1) {
        _key = sortedKeys[i];
        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
      }
      stack.pop();
      replacementStack.pop();
    } else {
      canonicalizedObj = obj;
    }
    return canonicalizedObj;
  }

  var arrayDiff = new Diff();
  arrayDiff.tokenize = function (value) {
    return value.slice();
  };
  arrayDiff.join = arrayDiff.removeEmpty = function (value) {
    return value;
  };

  var RemoveItem$7 = Phaser.Utils.Array.Remove;
  var SetText$1 = function SetText(textObject, newText) {
    var text = textObject.text;
    if (newText === text) {
      return;
    }
    if (text == null) {
      text = '';
    }

    // textObject.setText(newText);

    // Remove lastInsertCursor directly 
    RemoveItem$7(textObject.children, textObject.lastInsertCursor);
    if (newText === '') {
      textObject.removeChildren();
    } else {
      var results = diffChars(text, newText);
      var charIndex = 0;
      for (var i = 0, cnt = results.length; i < cnt; i++) {
        var result = results[i];
        if (result.removed) {
          // Remove character at charIndex
          textObject.removeText(charIndex, result.count);
        } else if (result.added) {
          textObject.insertText(charIndex, result.value);
          charIndex += result.count;
        } else {
          charIndex += result.count;
        }
      }
    }

    // Push back lastInsertCursor directly
    textObject.children.push(textObject.lastInsertCursor);
    textObject.runWrap();
    textObject.emit('textchange', newText, textObject);
  };

  var SetTextOXYMethods = {
    setTextOYByPercentage: function setTextOYByPercentage(percentage) {
      this.setTextOY(-this.textVisibleHeight * percentage);
      return this;
    },
    getTextOYPercentage: function getTextOYPercentage() {
      var textVisibleHeight = this.textVisibleHeight;
      if (textVisibleHeight === 0) {
        return 0;
      }
      return this._textOY / -textVisibleHeight;
    },
    setTextOXByPercentage: function setTextOXByPercentage(percentage) {
      this.setTextOX(-this.textVisibleWidth * percentage);
      return this;
    },
    getTextOXPercentage: function getTextOXPercentage() {
      var textVisibleWidth = this.textVisibleWidth;
      if (textVisibleWidth === 0) {
        return 0;
      }
      return this._textOX / -textVisibleWidth;
    }
  };

  var IsPlainObject$G = Phaser.Utils.Objects.IsPlainObject;
  var CanvasInput = /*#__PURE__*/function (_DynamicText) {
    _inherits(CanvasInput, _DynamicText);
    function CanvasInput(scene, x, y, fixedWidth, fixedHeight, config) {
      var _this;
      _classCallCheck(this, CanvasInput);
      if (IsPlainObject$G(x)) {
        config = x;
      } else if (IsPlainObject$G(fixedWidth)) {
        config = fixedWidth;
      }
      if (config === undefined) {
        config = {};
      }
      InjectDefaultConfig(config);

      // Set text later
      var text = config.text;
      if (text) {
        delete config.text;
      }
      var focusStyle = ExtractByPrefix(config.background, 'focus');
      var cursorStyle = ExtractByPrefix(config.style, 'cursor');
      _this = _callSuper(this, CanvasInput, [scene, x, y, fixedWidth, fixedHeight, config]);
      _this.type = 'rexCanvasInput';

      // readonly
      _this.contentWidth = undefined;
      _this.contentHeight = undefined;
      _this.lineHeight = undefined;
      _this.linesCount = undefined;
      _this._text;
      _this.textEdit = CreateHiddenTextEdit(_assertThisInitialized(_this), config);
      if (config.focusStyle) {
        Object.assign(focusStyle, config.focusStyle);
      }
      RegisterFocusStyle.call(_assertThisInitialized(_this), focusStyle);
      if (config.cursorStyle) {
        Object.assign(cursorStyle, config.cursorStyle);
      }
      RegisterCursorStyle.call(_assertThisInitialized(_this), cursorStyle);
      var addCharCallback = config.onAddChar;
      if (addCharCallback) {
        _this.on('addchar', addCharCallback);
      }
      var cursorOutCallback = config.onCursorOut;
      if (cursorOutCallback) {
        _this.on('cursorout', cursorOutCallback);
      }
      var cursorInCallback = config.onCursorIn;
      if (cursorInCallback) {
        _this.on('cursorin', cursorInCallback);
      }
      var moveCursorCallback = config.onMoveCursor;
      if (moveCursorCallback) {
        _this.on('movecursor', moveCursorCallback);
      }
      _this.setParseTextCallback(config.parseTextCallback);
      _this.lastInsertCursor = CreateInsertCursorChild(_assertThisInitialized(_this));
      if (!text) {
        text = '';
      }
      _this.setText(text);
      return _this;
    }
    _createClass(CanvasInput, [{
      key: "addChild",
      value: function addChild(child, index) {
        _get(_getPrototypeOf(CanvasInput.prototype), "addChild", this).call(this, child, index);
        if (Array.isArray(child)) {
          var children = child;
          for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (IsChar(child)) {
              this.emit('addchar', child, index + i, this);
            }
          }
        } else {
          if (IsChar(child)) {
            this.emit('addchar', child, index, this);
          }
        }
        return this;
      }
    }, {
      key: "text",
      get: function get() {
        return this._text;
      },
      set: function set(value) {
        if (value == null) {
          value = '';
        } else {
          value = value.toString();
        }
        if (this._text === value) {
          return;
        }
        SetText$1(this, value);
        this._text = value;
      }
    }, {
      key: "setText",
      value: function setText(text) {
        this.text = text;
        return this;
      }
    }, {
      key: "appendText",
      value: function appendText(text) {
        this.setText(this.text + text);
        return this;
      }
    }, {
      key: "runWrap",
      value: function runWrap(config) {
        var result = _get(_getPrototypeOf(CanvasInput.prototype), "runWrap", this).call(this, config);
        // Save content size
        this.contentWidth = result.maxLineWidth;
        this.contentHeight = result.linesHeight;
        this.lineHeight = result.lineHeight;
        this.linesCount = result.lines.length;
        return result;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        if (this.width === width && this.height === height) {
          return this;
        }
        _get(_getPrototypeOf(CanvasInput.prototype), "setSize", this).call(this, width, height);

        // Run wrap again since fixedWidth and fixedHeight are changed
        this.runWrap();
        return this;
      }
    }, {
      key: "displayText",
      get: function get() {
        return this.text;
      },
      set: function set(value) {
        this.text = value;
      }
    }, {
      key: "setDisplayText",
      value: function setDisplayText(value) {
        this.displayText = value;
        return this;
      }
    }, {
      key: "inputText",
      get: function get() {
        return this.textEdit.text;
      },
      set: function set(value) {
        this.textEdit.text = value;
      }
    }, {
      key: "setInputText",
      value: function setInputText(value) {
        this.inputText = value;
        return this;
      }
    }, {
      key: "setParseTextCallback",
      value: function setParseTextCallback(callback) {
        if (!callback) {
          callback = DefaultParseTextCallback;
        }
        this.parseTextCallback = callback;
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this.parseTextCallback(this.text);
      },
      set: function set(value) {
        this.setText(value);
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this.value;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }, {
      key: "readOnly",
      get: function get() {
        return this.textEdit.readOnly;
      },
      set: function set(value) {
        this.textEdit.readOnly = value;
      }
    }, {
      key: "setReadOnly",
      value: function setReadOnly(value) {
        this.textEdit.setReadOnly(value);
        return this;
      }
    }, {
      key: "open",
      value: function open(onCloseCallback) {
        if (onCloseCallback) {
          this.textEdit.once('close', onCloseCallback);
        }
        this.textEdit.open();
        return this;
      }
    }, {
      key: "close",
      value: function close() {
        this.textEdit.close();
        return this;
      }
    }, {
      key: "isOpened",
      get: function get() {
        return this.textEdit.isOpened;
      }
    }, {
      key: "setFocusStyle",
      value: function setFocusStyle(style) {
        this.focusStyle = style;
        return this;
      }
    }, {
      key: "setCursorStyle",
      value: function setCursorStyle(style) {
        this.cursorStyle = style;
        return this;
      }
    }, {
      key: "setNumberInput",
      value: function setNumberInput() {
        this.textEdit.setNumberInput().setSelectAllWhenFocusEnable();
        this.parseTextCallback = Number;
        return this;
      }
    }, {
      key: "maxLength",
      get: function get() {
        return this.textEdit.maxLength;
      },
      set: function set(value) {
        this.textEdit.maxLength = value;
      }
    }, {
      key: "setMaxLength",
      value: function setMaxLength(value) {
        this.maxLength = value;
        return this;
      }
    }, {
      key: "minLength",
      get: function get() {
        return this.textEdit.minLength;
      },
      set: function set(value) {
        this.textEdit.minLength = value;
      }
    }, {
      key: "setMinLength",
      value: function setMinLength(value) {
        this.minLength = value;
        return this;
      }
    }, {
      key: "topTextOY",
      get: function get() {
        return 0;
      }
    }, {
      key: "bottomTextOY",
      get: function get() {
        return -this.tableVisibleHeight;
      }
    }, {
      key: "leftTextOX",
      get: function get() {
        return 0;
      }
    }, {
      key: "rightTextOX",
      get: function get() {
        return -this.textVisibleWidth;
      }
    }, {
      key: "textVisibleHeight",
      get: function get() {
        var h = this.contentHeight - this.height;
        if (h < 0) {
          h = 0;
        }
        return h;
      }
    }, {
      key: "textVisibleWidth",
      get: function get() {
        var w = this.contentWidth - this.width;
        if (w < 0) {
          w = 0;
        }
        return w;
      }
    }, {
      key: "t",
      get: function get() {
        return this.getTextOYPercentage();
      },
      set: function set(value) {
        this.setTextOYByPercentage(value).updateTexture();
      }
    }, {
      key: "s",
      get: function get() {
        return this.getTextOXPercentage();
      },
      set: function set(value) {
        this.setTextOXByPercentage(value).updateTexture();
      }
    }]);
    return CanvasInput;
  }(DynamicText);
  var DefaultParseTextCallback = function DefaultParseTextCallback(text) {
    return text;
  };
  Object.assign(CanvasInput.prototype, SetTextOXYMethods);

  var GetTickDelta = function GetTickDelta(game) {
    return GetGame(game).loop.delta;
  };

  Phaser.Utils.Objects.GetValue;
  Phaser.Math.Wrap;

  var GetCalcMatrix = Phaser.GameObjects.GetCalcMatrix;
  var WebGLRenderer = function WebGLRenderer(renderer, src, camera, parentMatrix) {
    src.updateData();
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    var shapes = src.geom,
      shape;
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      shape = shapes[i];
      if (shape.visible) {
        shape.webglRender(pipeline, calcMatrix, alpha, dx, dy);
      }
    }
    renderer.pipelines.postBatch(src);
  };

  var SetTransform = Phaser.Renderer.Canvas.SetTransform;
  var CanvasRenderer = function CanvasRenderer(renderer, src, camera, parentMatrix) {
    src.updateData();
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var shapes = src.geom,
        shape;
      for (var i = 0, cnt = shapes.length; i < cnt; i++) {
        shape = shapes[i];
        if (shape.visible) {
          shape.canvasRender(ctx, dx, dy);
        }
      }

      //  Restore the context saved in SetTransform
      ctx.restore();
    }
  };

  var Render = {
    renderWebGL: WebGLRenderer,
    renderCanvas: CanvasRenderer
  };

  var Shape = Phaser.GameObjects.Shape;
  var RemoveItem$6 = Phaser.Utils.Array.Remove;
  var BaseShapes = /*#__PURE__*/function (_Shape) {
    _inherits(BaseShapes, _Shape);
    function BaseShapes(scene, x, y, width, height) {
      var _this;
      _classCallCheck(this, BaseShapes);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 2;
      }
      if (height === undefined) {
        height = width;
      }
      _this = _callSuper(this, BaseShapes, [scene, 'rexShapes', []]);
      _this._width = -1;
      _this._height = -1;
      _this.dirty = true;
      _this.isSizeChanged = true;
      _this.shapes = {};
      _this.setPosition(x, y);
      _this.setSize(width, height);
      _this.updateDisplayOrigin();
      return _this;
    }
    _createClass(BaseShapes, [{
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this.setSize(value, this._height);
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this.setSize(this._width, value);
      }
    }, {
      key: "setDirty",
      value: function setDirty(value) {
        if (value === undefined) {
          value = true;
        }
        this.dirty = value;
        return this;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.isSizeChanged = this.isSizeChanged || this._width !== width || this._height !== height;
        this.dirty = this.dirty || this.isSizeChanged;
        this._width = width;
        this._height = height;
        this.updateDisplayOrigin();
        var input = this.input;
        if (input && !input.customHitArea) {
          input.hitArea.width = width;
          input.hitArea.height = height;
        }
        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this.setSize(width, height);
        return this;
      }
    }, {
      key: "fillColor",
      get: function get() {
        return this._fillColor;
      },
      set: function set(value) {
        this.setFillStyle(value, this._fillAlpha);
      }
    }, {
      key: "fillAlpha",
      get: function get() {
        return this._fillAlpha;
      },
      set: function set(value) {
        this.setFillStyle(this._fillColor, value);
      }
    }, {
      key: "setFillStyle",
      value: function setFillStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.fillColor !== color || this.fillAlpha !== alpha;
        this._fillColor = color;
        this._fillAlpha = alpha;
        return this;
      }
    }, {
      key: "lineWidth",
      get: function get() {
        return this._lineWidth;
      },
      set: function set(value) {
        this.setStrokeStyle(value, this._strokeColor, this._strokeAlpha);
      }
    }, {
      key: "strokeColor",
      get: function get() {
        return this._strokeColor;
      },
      set: function set(value) {
        this.setStrokeStyle(this._lineWidth, value, this._strokeAlpha);
      }
    }, {
      key: "strokeAlpha",
      get: function get() {
        return this._strokeAlpha;
      },
      set: function set(value) {
        this.setStrokeStyle(this._lineWidth, this._strokeColor, value);
      }
    }, {
      key: "setStrokeStyle",
      value: function setStrokeStyle(lineWidth, color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.lineWidth !== lineWidth || this.strokeColor !== color || this.strokeAlpha !== alpha;
        this._lineWidth = lineWidth;
        this._strokeColor = color;
        this._strokeAlpha = alpha;
        return this;
      }
    }, {
      key: "updateShapes",
      value: function updateShapes() {}
    }, {
      key: "updateData",
      value: function updateData() {
        if (!this.dirty) {
          return this;
        }
        this.updateShapes();
        var shapes = this.geom;
        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
          var shape = shapes[i];
          if (shape.dirty) {
            shape.updateData();
          }
        }
        this.isSizeChanged = false;
        this.dirty = false;
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.geom.length = 0;
        Clear$1(this.shapes);
        return this;
      }
    }, {
      key: "getShape",
      value: function getShape(name) {
        return this.shapes[name];
      }
    }, {
      key: "getShapes",
      value: function getShapes() {
        return this.geom;
      }
    }, {
      key: "addShape",
      value: function addShape(shape) {
        this.geom.push(shape);
        var name = shape.name;
        if (name) {
          this.shapes[name] = shape;
        }
        this.dirty = true;
        return this;
      }
    }, {
      key: "deleteShape",
      value: function deleteShape(name) {
        var shape = this.getShape(name);
        if (shape) {
          delete this.shapes[name];
          RemoveItem$6(this.geom, shape);
        }
        return this;
      }
    }]);
    return BaseShapes;
  }(Shape);
  Object.assign(BaseShapes.prototype, Render);

  var StyleMethods$2 = {
    setBoxFillStyle: function setBoxFillStyle(color, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.dirty = this.dirty || this.boxFillColor !== color || this.boxFillAlpha !== alpha;
      this.boxFillColor = color;
      this.boxFillAlpha = alpha;
      return this;
    },
    setUncheckedBoxFillStyle: function setUncheckedBoxFillStyle(color, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.dirty = this.dirty || this.uncheckedBoxFillColor !== color || this.uncheckedBoxFillAlpha !== alpha;
      this.uncheckedBoxFillColor = color;
      this.uncheckedBoxFillAlpha = alpha;
      return this;
    },
    setBoxStrokeStyle: function setBoxStrokeStyle(lineWidth, color, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.dirty = this.dirty || this.boxLineWidth !== lineWidth || this.boxStrokeColor !== color || this.boxStrokeAlpha !== alpha;
      this.boxLineWidth = lineWidth;
      this.boxStrokeColor = color;
      this.boxStrokeAlpha = alpha;
      return this;
    },
    setUncheckedBoxStrokeStyle: function setUncheckedBoxStrokeStyle(lineWidth, color, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.dirty = this.dirty || this.uncheckedBoxLineWidth !== lineWidth || this.uncheckedBoxStrokeColor !== color || this.uncheckedBoxStrokeAlpha !== alpha;
      this.uncheckedBoxLineWidth = lineWidth;
      this.uncheckedBoxStrokeColor = color;
      this.uncheckedBoxStrokeAlpha = alpha;
      return this;
    },
    setCheckerStyle: function setCheckerStyle(color, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.dirty = this.dirty || this.checkerColor !== color || this.checkAlpha !== alpha;
      this.checkerColor = color;
      this.checkAlpha = alpha;
      return this;
    },
    setBoxShape: function setBoxShape(isCircleShape) {
      if (isCircleShape === undefined) {
        isCircleShape = false;
      }
      if (this.isCircleShape === isCircleShape) {
        return this;
      }
      this.isCircleShape = isCircleShape;
      this.isSizeChanged = true;
      this.dirty = true;
      return this;
    }
  };

  var SizeMethods$1 = {
    setBoxSize: function setBoxSize(size) {
      this.dirty = this.dirty || this.boxSize !== size;
      this.boxSize = size;
      return this;
    },
    setCheckerSize: function setCheckerSize(size) {
      this.dirty = this.dirty || this.checkerSize !== size;
      this.checkerSize = size;
      return this;
    }
  };

  var FillStyle = function FillStyle(color, alpha) {
    if (color == null) {
      this.isFilled = false;
    } else {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.isFilled = true;
      this.fillColor = color;
      this.fillAlpha = alpha;
    }
    return this;
  };
  var LineStyle = function LineStyle(lineWidth, color, alpha) {
    if (lineWidth == null || color == null) {
      this.isStroked = false;
    } else {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.isStroked = true;
      this.lineWidth = lineWidth;
      this.strokeColor = color;
      this.strokeAlpha = alpha;
    }
    return this;
  };
  var StyleMethods$1 = {
    fillStyle: FillStyle,
    lineStyle: LineStyle
  };

  var BaseGeom = /*#__PURE__*/function () {
    function BaseGeom() {
      _classCallCheck(this, BaseGeom);
      this.name = undefined;
      this.dirty = true;
      this.visible = true;
      this.data = undefined;
      this.isFilled = false;
      this.fillColor = undefined;
      this.fillAlpha = 1;
      this.isStroked = false;
      this.lineWidth = 1;
      this.strokeColor = undefined;
      this.strokeAlpha = 1;
    }
    _createClass(BaseGeom, [{
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        if (visible === undefined) {
          visible = true;
        }
        this.visible = visible;
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.setVisible().fillStyle().lineStyle();
        return this;
      }
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {}
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {}
    }, {
      key: "updateData",
      value: function updateData() {
        this.dirty = false;
      }
    }]);
    return BaseGeom;
  }();
  Object.assign(BaseGeom.prototype, StyleMethods$1, DataMethods);

  var Earcut = Phaser.Geom.Polygon.Earcut;
  var PathBase = /*#__PURE__*/function (_BaseGeom) {
    _inherits(PathBase, _BaseGeom);
    function PathBase() {
      var _this;
      _classCallCheck(this, PathBase);
      _this = _callSuper(this, PathBase);
      _this.pathData = [];
      _this.pathIndexes = [];
      _this.closePath = false;
      return _this;
    }
    _createClass(PathBase, [{
      key: "updateData",
      value: function updateData() {
        this.pathIndexes = Earcut(this.pathData);
        _get(_getPrototypeOf(PathBase.prototype), "updateData", this).call(this);
        return this;
      }
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
          FillPathWebGL(pipeline, calcMatrix, this, alpha, dx, dy);
        }
        if (this.isStroked) {
          StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
      }
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {
        var path = this.pathData;
        var pathLength = path.length - 1;
        var px1 = path[0] - dx;
        var py1 = path[1] - dy;
        ctx.beginPath();
        ctx.moveTo(px1, py1);
        if (!this.closePath) {
          pathLength -= 2;
        }
        for (var i = 2; i < pathLength; i += 2) {
          var px2 = path[i] - dx;
          var py2 = path[i + 1] - dy;
          ctx.lineTo(px2, py2);
        }
        if (this.closePath) {
          ctx.closePath();
        }
        if (this.isFilled) {
          FillStyleCanvas(ctx, this);
          ctx.fill();
        }
        if (this.isStroked) {
          LineStyleCanvas(ctx, this);
          ctx.stroke();
        }
      }
    }]);
    return PathBase;
  }(BaseGeom);

  var DegToRad$a = Phaser.Math.DegToRad;
  var Arc = /*#__PURE__*/function (_PathBase) {
    _inherits(Arc, _PathBase);
    function Arc(x, y, radiusX, radiusY, startAngle, endAngle, anticlockwise, pie) {
      var _this;
      _classCallCheck(this, Arc);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (radiusX === undefined) {
        radiusX = 0;
      }
      if (radiusY === undefined) {
        radiusY = 0;
      }
      if (startAngle === undefined) {
        startAngle = 0;
      }
      if (endAngle === undefined) {
        endAngle = 360;
      }
      if (anticlockwise === undefined) {
        anticlockwise = false;
      }
      if (pie === undefined) {
        pie = false;
      }
      _this = _callSuper(this, Arc);
      _this.setCenterPosition(x, y);
      _this.setRadius(radiusX, radiusY);
      _this.setAngle(startAngle, endAngle, anticlockwise);
      _this.setPie(pie);
      _this.setIterations(32);
      return _this;
    }
    _createClass(Arc, [{
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x !== value;
        this._x = value;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y !== value;
        this._y = value;
      }
    }, {
      key: "setCenterPosition",
      value: function setCenterPosition(x, y) {
        if (y === undefined) {
          y = x;
        }
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "radiusX",
      get: function get() {
        return this._radiusX;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radiusX !== value;
        this._radiusX = value;
      }
    }, {
      key: "radiusY",
      get: function get() {
        return this._radiusY;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radiusY !== value;
        this._radiusY = value;
      }
    }, {
      key: "setRadius",
      value: function setRadius(radiusX, radiusY) {
        if (radiusY === undefined) {
          radiusY = radiusX;
        }
        this.radiusX = radiusX;
        this.radiusY = radiusY;
        return this;
      }
    }, {
      key: "startAngle",
      get: function get() {
        return this._startAngle;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._startAngle !== value;
        this._startAngle = value;
      }
    }, {
      key: "endAngle",
      get: function get() {
        return this._endAngle;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._endAngle !== value;
        this._endAngle = value;
      }
    }, {
      key: "anticlockwise",
      get: function get() {
        return this._anticlockwise;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._anticlockwise !== value;
        this._anticlockwise = value;
      }
    }, {
      key: "setAngle",
      value: function setAngle(startAngle, endAngle, anticlockwise) {
        // startAngle, endAngle in degrees
        if (anticlockwise === undefined) {
          anticlockwise = false;
        }
        this.startAngle = startAngle;
        this.endAngle = endAngle;
        this.anticlockwise = anticlockwise;
        return this;
      }
    }, {
      key: "pie",
      get: function get() {
        return this._pie;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._pie !== value;
        this._pie = value;
      }
    }, {
      key: "setPie",
      value: function setPie(pie) {
        if (pie === undefined) {
          pie = true;
        }
        this.pie = pie;
        return this;
      }
    }, {
      key: "iterations",
      get: function get() {
        return this._iterations;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._iterations !== value;
        this._iterations = value;
      }
    }, {
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        if (this.pie) {
          this.pathData.push(this.x, this.y);
        }
        ArcTo$1(this.x, this.y, this.radiusX, this.radiusY, this.startAngle, this.endAngle, this.anticlockwise, this.iterations, this.pathData);
        if (this.pie) {
          this.pathData.push(this.x, this.y);
        }
        // Close
        this.pathData.push(this.pathData[0], this.pathData[1]);
        _get(_getPrototypeOf(Arc.prototype), "updateData", this).call(this);
        return this;
      }
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {
        ctx.beginPath();
        var x = this.x - dx,
          y = this.y - dy,
          startAngle = DegToRad$a(this.startAngle),
          endAngle = DegToRad$a(this.endAngle);
        if (this.pie) {
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(startAngle) * this.radiusX, y + Math.sin(startAngle) * this.radiusY);
        }
        ctx.ellipse(x, y, this.radiusX, this.radiusY, 0, startAngle, endAngle, this.anticlockwise);
        if (this.pie) {
          ctx.lineTo(x, y);
        }
        if (this.isFilled) {
          FillStyleCanvas(ctx, this);
          ctx.fill();
        }
        if (this.isStroked) {
          LineStyleCanvas(ctx, this);
          ctx.stroke();
        }
      }
    }]);
    return Arc;
  }(PathBase);

  var Circle = /*#__PURE__*/function (_Arc) {
    _inherits(Circle, _Arc);
    function Circle(x, y, radius) {
      _classCallCheck(this, Circle);
      return _callSuper(this, Circle, [x, y, radius, radius, 0, 360]);
    }
    return _createClass(Circle);
  }(Arc);

  var Curve = /*#__PURE__*/function (_PathBase) {
    _inherits(Curve, _PathBase);
    function Curve(curve) {
      var _this;
      _classCallCheck(this, Curve);
      _this = _callSuper(this, Curve);
      _this.setCurve(curve);
      _this.setIterations(32);
      return _this;
    }
    _createClass(Curve, [{
      key: "curve",
      get: function get() {
        return this._curve;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._curve !== value;
        this._curve = value;
      }
    }, {
      key: "setCurve",
      value: function setCurve(curve) {
        this.curve = curve;
        return this;
      }
    }, {
      key: "iterations",
      get: function get() {
        return this._iterations;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._iterations !== value;
        this._iterations = value;
      }
    }, {
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        var points = this.curve.getPoints(this.iterations);
        for (var i = 0, cnt = points.length; i < cnt; i++) {
          this.pathData.push(points[i].x, points[i].y);
        }
        this.pathData.push(points[0].x, points[0].y);
        _get(_getPrototypeOf(Curve.prototype), "updateData", this).call(this);
        return this;
      }
    }]);
    return Curve;
  }(PathBase);

  var Ellipse = /*#__PURE__*/function (_Arc) {
    _inherits(Ellipse, _Arc);
    function Ellipse(x, y, radiusX, radiusY) {
      _classCallCheck(this, Ellipse);
      return _callSuper(this, Ellipse, [x, y, radiusX, radiusY, 0, 360]);
    }
    return _createClass(Ellipse);
  }(Arc);

  var Line = /*#__PURE__*/function (_PathBase) {
    _inherits(Line, _PathBase);
    function Line(x0, y0, x1, y1) {
      var _this;
      _classCallCheck(this, Line);
      if (x0 === undefined) {
        x0 = 0;
      }
      if (y0 === undefined) {
        y0 = 0;
      }
      if (x1 === undefined) {
        x1 = 0;
      }
      if (y1 === undefined) {
        y1 = 0;
      }
      _this = _callSuper(this, Line);
      _this.setP0(x0, y0);
      _this.setP1(x1, y1);
      return _this;
    }
    _createClass(Line, [{
      key: "x0",
      get: function get() {
        return this._x0;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x0 !== value;
        this._x0 = value;
      }
    }, {
      key: "y0",
      get: function get() {
        return this._y0;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y0 !== value;
        this._y0 = value;
      }
    }, {
      key: "setP0",
      value: function setP0(x, y) {
        this.x0 = x;
        this.y0 = y;
        return this;
      }
    }, {
      key: "x1",
      get: function get() {
        return this._x1;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x1 !== value;
        this._x1 = value;
      }
    }, {
      key: "y1",
      get: function get() {
        return this._y1;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y1 !== value;
        this._y1 = value;
      }
    }, {
      key: "setP1",
      value: function setP1(x, y) {
        this.x1 = x;
        this.y1 = y;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        this.pathData.push(this.x0, this.y0);
        this.pathData.push(this.x1, this.y1);
        this.pathData.push(this.x0, this.y0);
        _get(_getPrototypeOf(Line.prototype), "updateData", this).call(this);
        return this;
      }
    }]);
    return Line;
  }(PathBase);

  var StartAt = function StartAt(x, y, pathData) {
    pathData.length = 0;
    if (x != null) {
      pathData.push(x, y);
    }
    return pathData;
  };

  //import QuadraticBezierInterpolation from '../../utils/math/interpolation/QuadraticBezierInterpolation.js';

  var QuadraticBezierInterpolation = Phaser.Math.Interpolation.QuadraticBezier;
  var QuadraticBezierTo = function QuadraticBezierTo(cx, cy, x, y, iterations, pathData) {
    var pathDataCnt = pathData.length;
    var p0x = pathData[pathDataCnt - 2];
    var p0y = pathData[pathDataCnt - 1];
    for (var i = 1, last = iterations - 1; i <= last; i++) {
      var t = i / last;
      pathData.push(QuadraticBezierInterpolation(t, p0x, cx, x), QuadraticBezierInterpolation(t, p0y, cy, y));
    }
    return pathData;
  };

  // import CubicBezierInterpolation from '../../utils/math/interpolation/CubicBezierInterpolation.js';

  var CubicBezierInterpolation = Phaser.Math.Interpolation.CubicBezier;
  var CubicBezierCurveTo = function CubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y, iterations, pathData) {
    var pathDataCnt = pathData.length;
    var p0x = pathData[pathDataCnt - 2];
    var p0y = pathData[pathDataCnt - 1];
    for (var i = 1, last = iterations - 1; i <= last; i++) {
      var t = i / last;
      pathData.push(CubicBezierInterpolation(t, p0x, cx0, cx1, x), CubicBezierInterpolation(t, p0y, cy0, cy1, y));
    }
    return pathData;
  };

  var DuplicateLast = function DuplicateLast(pathData) {
    var len = pathData.length;
    if (len < 2) {
      return pathData;
    }
    var lastX = pathData[len - 2];
    var lastY = pathData[len - 1];
    pathData.push(lastX);
    pathData.push(lastY);
    return pathData;
  };

  var AddPathMethods = {
    clear: function clear() {
      this.start();
      return this;
    },
    start: function start() {
      this.startAt();
      return this;
    },
    startAt: function startAt(x, y) {
      this.restorePathData();
      this.accumulationLengths = undefined;
      StartAt(x, y, this.pathData);
      this.firstPointX = x;
      this.firstPointY = y;
      this.lastPointX = x;
      this.lastPointY = y;
      return this;
    },
    lineTo: function lineTo(x, y, relative) {
      if (relative === undefined) {
        relative = false;
      }
      if (relative) {
        x += this.lastPointX;
        y += this.lastPointY;
      }
      LineTo(x, y, this.pathData);
      this.lastPointX = x;
      this.lastPointY = y;
      return this;
    },
    verticalLineTo: function verticalLineTo(x, relative) {
      this.lineTo(x, this.lastPointY, relative);
      return this;
    },
    horizontalLineTo: function horizontalLineTo(y, relative) {
      this.lineTo(this.lastPointX, y, relative);
      return this;
    },
    ellipticalArc: function ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
      if (anticlockwise === undefined) {
        anticlockwise = false;
      }
      ArcTo$1(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise, this.iterations, this.pathData);
      this.lastPointX = this.pathData[this.pathData.length - 2];
      this.lastPointY = this.pathData[this.pathData.length - 1];
      return this;
    },
    arc: function arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
      this.ellipticalArc(centerX, centerY, radius, radius, startAngle, endAngle, anticlockwise);
      return this;
    },
    quadraticBezierTo: function quadraticBezierTo(cx, cy, x, y) {
      QuadraticBezierTo(cx, cy, x, y, this.iterations, this.pathData);
      this.lastPointX = x;
      this.lastPointY = y;
      this.lastCX = cx;
      this.lastCY = cy;
      return this;
    },
    smoothQuadraticBezierTo: function smoothQuadraticBezierTo(x, y) {
      var cx = this.lastPointX * 2 - this.lastCX;
      var cy = this.lastPointY * 2 - this.lastCY;
      this.quadraticBezierTo(cx, cy, x, y);
      return this;
    },
    cubicBezierCurveTo: function cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y) {
      CubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y, this.iterations, this.pathData);
      this.lastPointX = x;
      this.lastPointY = y;
      this.lastCX = cx1;
      this.lastCY = cy1;
      return this;
    },
    smoothCubicBezierCurveTo: function smoothCubicBezierCurveTo(cx1, cy1, x, y) {
      var cx0 = this.lastPointX * 2 - this.lastCX;
      var cy0 = this.lastPointY * 2 - this.lastCY;
      this.cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y);
      return this;
    },
    close: function close() {
      // Line to first point        
      var startX = this.pathData[0],
        startY = this.pathData[1];
      if (startX !== this.lastPointX || startY !== this.lastPointY) {
        this.lineTo(startX, startY);
      }
      this.closePath = true;
      return this;
    },
    end: function end() {
      DuplicateLast(this.pathData);
      return this;
    }
  };

  //import PointRotateAround from '../../utils/math/RotateAround.js';

  var PointRotateAround$1 = Phaser.Math.RotateAround;
  var RotateAround$5 = function RotateAround(centerX, centerY, angle, pathData) {
    var point = {
      x: 0,
      y: 0
    };
    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
      point.x = pathData[i];
      point.y = pathData[i + 1];
      PointRotateAround$1(point, centerX, centerY, angle);
      pathData[i] = point.x;
      pathData[i + 1] = point.y;
    }
    return pathData;
  };

  var Scale$2 = function Scale(centerX, centerY, scaleX, scaleY, pathData) {
    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
      var x = pathData[i] - centerX;
      var y = pathData[i + 1] - centerY;
      x *= scaleX;
      y *= scaleY;
      pathData[i] = x + centerX;
      pathData[i + 1] = y + centerY;
    }
    return pathData;
  };

  var Offset = function Offset(x, y, pathData) {
    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
      pathData[i] += x;
      pathData[i + 1] += y;
    }
    return pathData;
  };

  var DegToRad$9 = Phaser.Math.DegToRad;
  var PointRotateAround = Phaser.Math.RotateAround;
  var TransformPointsMethods = {
    rotateAround: function rotateAround(centerX, centerY, angle) {
      if (this.pathData.length === 0) {
        return this;
      }
      angle = DegToRad$9(angle);
      RotateAround$5(centerX, centerY, angle, this.pathData);
      var pathDataCnt = this.pathData.length;
      this.lastPointX = this.pathData[pathDataCnt - 2];
      this.lastPointY = this.pathData[pathDataCnt - 1];
      if (this.lastCX !== undefined) {
        var point = {
          x: this.lastCX,
          y: this.lastCY
        };
        PointRotateAround(point, centerX, centerY, angle);
        this.lastCX = point.x;
        this.lastCY = point.y;
      }
      return this;
    },
    scale: function scale(centerX, centerY, scaleX, scaleY) {
      if (this.pathData.length === 0) {
        return this;
      }
      Scale$2(centerX, centerY, scaleX, scaleY, this.pathData);
      this.lastPointX = this.pathData[pathDataCnt - 2];
      this.lastPointY = this.pathData[pathDataCnt - 1];
      if (this.lastCX !== undefined) {
        var x = this.lastCX - centerX;
        var y = this.lastCY - centerY;
        x *= scaleX;
        y *= scaleY;
        this.lastCX = x + centerX;
        this.lastCY = y + centerY;
      }
      return this;
    },
    offset: function offset(x, y) {
      Offset(x, y, this.pathData);
      return this;
    }
  };

  var Copy = function Copy(dest, src, startIdx, endIdx) {
    if (startIdx === undefined) {
      startIdx = 0;
    }
    if (endIdx === undefined) {
      endIdx = src.length;
    }
    dest.length = endIdx - startIdx;
    for (var i = 0, len = dest.length; i < len; i++) {
      dest[i] = src[i + startIdx];
    }
    return dest;
  };

  var SavePathDataMethods = {
    savePathData: function savePathData() {
      if (this.pathDataSaved) {
        return this;
      }
      this.pathDataSave = _toConsumableArray(this.pathData);
      this.pathData.length = 0;
      this.pathDataSaved = true;
      return this;
    },
    restorePathData: function restorePathData() {
      if (!this.pathDataSaved) {
        return this;
      }
      Copy(this.pathData, this.pathDataSave);
      this.pathDataSave = undefined;
      this.pathDataSaved = false;
      return this;
    }
  };

  var DistanceBetween$6 = Phaser.Math.Distance.Between;
  var Wrap$1 = Phaser.Math.Wrap;
  var Linear$a = Phaser.Math.Linear;
  var AppendFromPathSegment = function AppendFromPathSegment(srcPathData, accumulationLengths, startT, endT, destPathData) {
    if (endT === undefined) {
      endT = startT;
      startT = 0;
    }
    startT = WrapT(startT);
    endT = WrapT(endT);
    if (startT === endT) {
      return;
    }
    var totalPathLength = accumulationLengths[accumulationLengths.length - 1];
    var startL = totalPathLength * startT;
    var endL = totalPathLength * endT;
    if (startT < endT) {
      AddPathSegment(srcPathData, accumulationLengths, startL, endL, destPathData);
    } else {
      AddPathSegment(srcPathData, accumulationLengths, startL, totalPathLength, destPathData);
      AddPathSegment(srcPathData, accumulationLengths, 0, endL, destPathData);
    }
    DuplicateLast(destPathData);
  };
  var AddPathSegment = function AddPathSegment(srcPathData, accumulationLengths, startL, endL, destPathData) {
    var skipState = startL > 0;
    for (var i = 0, cnt = accumulationLengths.length; i < cnt; i++) {
      var pIdx = i * 2;
      var d = accumulationLengths[i];
      if (skipState) {
        if (d < startL) {
          continue;
        } else if (d == startL) {
          skipState = false;
        } else {
          // d > startL
          var deltaD = d - accumulationLengths[i - 1];
          var t = 1 - (d - startL) / deltaD;
          destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
          destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
          skipState = false;
        }
      }
      if (d <= endL) {
        destPathData.push(srcPathData[pIdx]);
        destPathData.push(srcPathData[pIdx + 1]);
        if (d === endL) {
          break;
        }
      } else {
        // d > endL
        var deltaD = d - accumulationLengths[i - 1];
        var t = 1 - (d - endL) / deltaD;
        destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
        destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
        break;
      }
    }
  };
  var GetInterpolation = function GetInterpolation(pathData, i0, i1, t) {
    var p0 = pathData[i0],
      p1 = pathData[i1];
    return Linear$a(p0, p1, t);
  };
  var WrapT = function WrapT(t) {
    if (t === 0) {
      return 0;
    } else if (t % 1 === 0) {
      return 1;
    }
    return Wrap$1(t, 0, 1);
  };
  var PathSegmentMethods = {
    updateAccumulationLengths: function updateAccumulationLengths() {
      if (this.accumulationLengths == null) {
        this.accumulationLengths = [];
      } else if (this.accumulationLengths.length === this.pathData.length / 2) {
        return this;
      }
      var accumulationLengths = this.accumulationLengths;
      var pathData = this.pathData;
      var prevX, prevY, x, y;
      var d,
        accumulationLength = 0;
      for (var i = 0, cnt = pathData.length; i < cnt; i += 2) {
        x = pathData[i];
        y = pathData[i + 1];
        d = prevX === undefined ? 0 : DistanceBetween$6(prevX, prevY, x, y);
        accumulationLength += d;
        accumulationLengths.push(accumulationLength);
        prevX = x;
        prevY = y;
      }
      this.totalPathLength = accumulationLength;
      return this;
    },
    setDisplayPathSegment: function setDisplayPathSegment(startT, endT) {
      if (!this.pathDataSaved) {
        this.updateAccumulationLengths();
        this.savePathData();
      }
      this.pathData.length = 0;
      AppendFromPathSegment(this.pathDataSave, this.accumulationLengths, startT, endT, this.pathData);
      return this;
    },
    appendFromPathSegment: function appendFromPathSegment(src, startT, endT) {
      if (startT === undefined) {
        var _this$pathData;
        (_this$pathData = this.pathData).push.apply(_this$pathData, _toConsumableArray(src.pathData));
      } else {
        src.updateAccumulationLengths();
        AppendFromPathSegment(src.pathData, src.accumulationLengths, startT, endT, this.pathData);
      }
      this.firstPointX = this.pathData[0];
      this.firstPointY = this.pathData[1];
      this.lastPointX = this.pathData[this.pathData.length - 2];
      this.lastPointY = this.pathData[this.pathData.length - 1];
      return this;
    }
  };

  var GraphicsMethods = {
    draw: function draw(graphics, isFill, isStroke) {
      var points = this.toPoints();
      if (isFill) {
        graphics.fillPoints(points, this.closePath, this.closePath);
      }
      if (isStroke) {
        graphics.strokePoints(points, this.closePath, this.closePath);
      }
      return this;
    }
  };

  var ToPoints = function ToPoints(pathData, points) {
    if (points === undefined) {
      points = [];
    }
    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
      points.push({
        x: pathData[i],
        y: pathData[i + 1]
      });
    }
    return points;
  };

  //import Polygon from '../../utils/geom/polygon/Polygon.js';

  var Polygon = Phaser.Geom.Polygon;
  var ToPolygon = function ToPolygon(pathData, polygon) {
    if (polygon === undefined) {
      polygon = new Polygon();
    }
    polygon.setTo(pathData);
    return polygon;
  };

  var PathDataBuilder = /*#__PURE__*/function () {
    function PathDataBuilder(pathData) {
      _classCallCheck(this, PathDataBuilder);
      if (pathData === undefined) {
        pathData = [];
      }
      this.pathData = pathData;
      this.closePath = false;
      this.setIterations(32);
      this.firstPointX = undefined;
      this.firstPointY = undefined;
      this.lastPointX = undefined;
      this.lastPointY = undefined;
      this.accumulationLengths = undefined;
    }
    _createClass(PathDataBuilder, [{
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "toPoints",
      value: function toPoints() {
        return ToPoints(this.pathData);
      }
    }, {
      key: "toPolygon",
      value: function toPolygon(polygon) {
        return ToPolygon(this.pathData, polygon);
      }
    }]);
    return PathDataBuilder;
  }();
  Object.assign(PathDataBuilder.prototype, AddPathMethods, TransformPointsMethods, SavePathDataMethods, PathSegmentMethods, GraphicsMethods);

  var Lines = /*#__PURE__*/function (_PathBase) {
    _inherits(Lines, _PathBase);
    function Lines() {
      var _this;
      _classCallCheck(this, Lines);
      _this = _callSuper(this, Lines);
      _this.builder = new PathDataBuilder(_this.pathData);
      return _this;
    }
    _createClass(Lines, [{
      key: "iterations",
      get: function get() {
        return this.builder.iterations;
      },
      set: function set(value) {
        this.dirty = this.dirty || this.builder.iterations !== value;
        this.builder.setIterations(value);
      }
    }, {
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "lastPointX",
      get: function get() {
        return this.builder.lastPointX;
      }
    }, {
      key: "lastPointY",
      get: function get() {
        return this.builder.lastPointY;
      }
    }, {
      key: "start",
      value: function start() {
        this.builder.start();
        this.dirty = true;
        return this;
      }
    }, {
      key: "startAt",
      value: function startAt(x, y) {
        this.builder.startAt(x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y, relative) {
        this.builder.lineTo(x, y, relative);
        this.dirty = true;
        return this;
      }
    }, {
      key: "verticalLineTo",
      value: function verticalLineTo(x, relative) {
        this.builder.verticalLineTo(x, relative);
        this.dirty = true;
        return this;
      }
    }, {
      key: "horizontalLineTo",
      value: function horizontalLineTo(y, relative) {
        this.builder.horizontalLineTo(y, relative);
        this.dirty = true;
        return this;
      }
    }, {
      key: "ellipticalArc",
      value: function ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
        this.builder.ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise);
        this.dirty = true;
        return this;
      }
    }, {
      key: "arc",
      value: function arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
        this.builder.arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise);
        this.dirty = true;
        return this;
      }
    }, {
      key: "quadraticBezierTo",
      value: function quadraticBezierTo(cx, cy, x, y) {
        this.builder.quadraticBezierTo(cx, cy, x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "smoothQuadraticBezierTo",
      value: function smoothQuadraticBezierTo(x, y) {
        this.builder.smoothQuadraticBezierTo(x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "cubicBezierCurveTo",
      value: function cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y) {
        this.builder.cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "smoothCubicBezierCurveTo",
      value: function smoothCubicBezierCurveTo(cx1, cy1, x, y) {
        this.builder.smoothCubicBezierCurveTo(cx1, cy1, x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "close",
      value: function close() {
        this.builder.close();
        this.closePath = this.builder.closePath;
        this.dirty = true;
        return this;
      }
    }, {
      key: "end",
      value: function end() {
        this.builder.end();
        this.dirty = true;
        return this;
      }
    }, {
      key: "rotateAround",
      value: function rotateAround(centerX, centerY, angle) {
        this.builder.rotateAround(centerX, centerY, angle);
        this.dirty = true;
        return this;
      }
    }, {
      key: "scale",
      value: function scale(centerX, centerY, scaleX, scaleY) {
        this.builder.scale(centerX, centerY, scaleX, scaleY);
        this.dirty = true;
        return this;
      }
    }, {
      key: "offset",
      value: function offset(x, y) {
        this.builder.offset(x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "toPolygon",
      value: function toPolygon(polygon) {
        return this.builder.toPolygon(polygon);
      }
    }, {
      key: "appendPathFrom",
      value: function appendPathFrom(src, startT, endT) {
        this.builder.appendFromPathSegment(src.builder, startT, endT);
        return this;
      }
    }, {
      key: "copyPathFrom",
      value: function copyPathFrom(src, startT, endT) {
        this.builder.clear().appendFromPathSegment(src.builder, startT, endT);
        return this;
      }
    }, {
      key: "setDisplayPathSegment",
      value: function setDisplayPathSegment(startT, endT) {
        this.builder.setDisplayPathSegment(startT, endT);
        return this;
      }
    }]);
    return Lines;
  }(PathBase);

  var GetTint$1 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
  var Rectangle$2 = /*#__PURE__*/function (_BaseGeom) {
    _inherits(Rectangle, _BaseGeom);
    function Rectangle(x, y, width, height) {
      var _this;
      _classCallCheck(this, Rectangle);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 0;
      }
      if (height === undefined) {
        height = width;
      }
      _this = _callSuper(this, Rectangle);
      _this.pathData = [];
      _this.closePath = true;
      _this.setTopLeftPosition(x, y);
      _this.setSize(width, height);
      return _this;
    }
    _createClass(Rectangle, [{
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x !== value;
        this._x = value;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y !== value;
        this._y = value;
      }
    }, {
      key: "setTopLeftPosition",
      value: function setTopLeftPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._width !== value;
        this._width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._height !== value;
        this._height = value;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.width = width;
        this.height = height;
        return this;
      }
    }, {
      key: "centerX",
      get: function get() {
        return this.x + this.width / 2;
      },
      set: function set(value) {
        this.x = value - this.width / 2;
      }
    }, {
      key: "centerY",
      get: function get() {
        return this.y + this.height / 2;
      },
      set: function set(value) {
        this.y = value - this.height / 2;
      }
    }, {
      key: "setCenterPosition",
      value: function setCenterPosition(x, y) {
        this.centerX = x;
        this.centerY = y;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        var x0 = this.x,
          x1 = x0 + this.width,
          y0 = this.y,
          y1 = y0 + this.height;
        this.pathData.push(x0, y0);
        this.pathData.push(x1, y0);
        this.pathData.push(x1, y1);
        this.pathData.push(x0, y1);
        this.pathData.push(x0, y0);
        _get(_getPrototypeOf(Rectangle.prototype), "updateData", this).call(this);
        return this;
      }
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
          var fillTint = pipeline.fillTint;
          var fillTintColor = GetTint$1(this.fillColor, this.fillAlpha * alpha);
          fillTint.TL = fillTintColor;
          fillTint.TR = fillTintColor;
          fillTint.BL = fillTintColor;
          fillTint.BR = fillTintColor;
          pipeline.batchFillRect(-dx + this.x, -dy + this.y, this.width, this.height);
        }
        if (this.isStroked) {
          StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
      }
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {
        if (this.isFilled) {
          FillStyleCanvas(ctx, this);
          ctx.fillRect(-dx, -dy, this.width, this.height);
        }
        if (this.isStroked) {
          LineStyleCanvas(ctx, this);
          ctx.beginPath();
          ctx.rect(-dx, -dy, this.width, this.height);
          ctx.stroke();
        }
      }
    }]);
    return Rectangle;
  }(BaseGeom);

  var GetValue$2E = Phaser.Utils.Objects.GetValue;
  var RoundRectangle = /*#__PURE__*/function (_PathBase) {
    _inherits(RoundRectangle, _PathBase);
    function RoundRectangle(x, y, width, height, radius, iterations) {
      var _this;
      _classCallCheck(this, RoundRectangle);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 0;
      }
      if (height === undefined) {
        height = width;
      }
      if (radius === undefined) {
        radius = 0;
      }
      if (iterations === undefined) {
        iterations = 6;
      }
      _this = _callSuper(this, RoundRectangle);
      _this.setTopLeftPosition(x, y);
      _this.setSize(width, height);
      _this.setRadius(radius);
      _this.setIterations(iterations);
      _this.closePath = true;
      return _this;
    }
    _createClass(RoundRectangle, [{
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x !== value;
        this._x = value;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y !== value;
        this._y = value;
      }
    }, {
      key: "setTopLeftPosition",
      value: function setTopLeftPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._width !== value;
        this._width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._height !== value;
        this._height = value;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.width = width;
        this.height = height;
        return this;
      }
    }, {
      key: "centerX",
      get: function get() {
        return this.x + this.width / 2;
      },
      set: function set(value) {
        this.x = value - this.width / 2;
      }
    }, {
      key: "centerY",
      get: function get() {
        return this.y + this.height / 2;
      },
      set: function set(value) {
        this.y = value - this.height / 2;
      }
    }, {
      key: "setCenterPosition",
      value: function setCenterPosition(x, y) {
        this.centerX = x;
        this.centerY = y;
        return this;
      }
    }, {
      key: "radiusTL",
      get: function get() {
        return this._radiusTL;
      },
      set: function set(value) {
        var isConvex = value > 0;
        this.dirty = this.dirty || this._radiusTL !== value || this._convexTL !== isConvex;
        this._convexTL = isConvex;
        this._radiusTL = Math.abs(value);
      }
    }, {
      key: "radiusTR",
      get: function get() {
        return this._radiusTR;
      },
      set: function set(value) {
        var isConvex = value > 0;
        this.dirty = this.dirty || this._radiusTR !== value || this._convexTR !== isConvex;
        this._convexTR = isConvex;
        this._radiusTR = Math.abs(value);
      }
    }, {
      key: "radiusBL",
      get: function get() {
        return this._radiusBL;
      },
      set: function set(value) {
        var isConvex = value > 0;
        this.dirty = this.dirty || this._radiusBL !== value || this._convexBL !== isConvex;
        this._convexBL = isConvex;
        this._radiusBL = Math.abs(value);
      }
    }, {
      key: "radiusBR",
      get: function get() {
        return this._radiusBR;
      },
      set: function set(value) {
        var isConvex = value > 0;
        this.dirty = this.dirty || this._radiusBR !== value || this._convexBR !== isConvex;
        this._convexBR = isConvex;
        this._radiusBR = Math.abs(value);
      }
    }, {
      key: "radius",
      get: function get() {
        return Math.max(this.radiusTL, this.radiusTR, this.radiusBL, this.radiusBR);
      },
      set: function set(value) {
        if (typeof value === 'number') {
          this.radiusTL = value;
          this.radiusTR = value;
          this.radiusBL = value;
          this.radiusBR = value;
        } else {
          this.radiusTL = GetValue$2E(value, 'tl', 0);
          this.radiusTR = GetValue$2E(value, 'tr', 0);
          this.radiusBL = GetValue$2E(value, 'bl', 0);
          this.radiusBR = GetValue$2E(value, 'br', 0);
        }
      }
    }, {
      key: "setRadius",
      value: function setRadius(radius) {
        if (radius === undefined) {
          radius = 0;
        }
        this.radius = radius;
        return this;
      }
    }, {
      key: "iterations",
      get: function get() {
        return this._iterations;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._iterations !== value;
        this._iterations = value;
      }
    }, {
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        var pathData = this.pathData;
        pathData.length = 0;
        var width = this.width,
          height = this.height,
          radius,
          iterations = this.iterations + 1;

        // top-left
        radius = this.radiusTL;
        if (radius > 0) {
          if (this._convexTL) {
            var centerX = radius;
            var centerY = radius;
            ArcTo$1(centerX, centerY, radius, radius, 180, 270, false, iterations, pathData);
          } else {
            var centerX = 0;
            var centerY = 0;
            ArcTo$1(centerX, centerY, radius, radius, 90, 0, true, iterations, pathData);
          }
        } else {
          LineTo(0, 0, pathData);
        }

        // top-right
        radius = this.radiusTR;
        if (radius > 0) {
          if (this._convexTR) {
            var centerX = width - radius;
            var centerY = radius;
            ArcTo$1(centerX, centerY, radius, radius, 270, 360, false, iterations, pathData);
          } else {
            var centerX = width;
            var centerY = 0;
            ArcTo$1(centerX, centerY, radius, radius, 180, 90, true, iterations, pathData);
          }
        } else {
          LineTo(width, 0, pathData);
        }

        // bottom-right
        radius = this.radiusBR;
        if (radius > 0) {
          if (this._convexBR) {
            var centerX = width - radius;
            var centerY = height - radius;
            ArcTo$1(centerX, centerY, radius, radius, 0, 90, false, iterations, pathData);
          } else {
            var centerX = width;
            var centerY = height;
            ArcTo$1(centerX, centerY, radius, radius, 270, 180, true, iterations, pathData);
          }
        } else {
          LineTo(width, height, pathData);
        }

        // bottom-left
        radius = this.radiusBL;
        if (radius > 0) {
          if (this._convexBL) {
            var centerX = radius;
            var centerY = height - radius;
            ArcTo$1(centerX, centerY, radius, radius, 90, 180, false, iterations, pathData);
          } else {
            var centerX = 0;
            var centerY = height;
            ArcTo$1(centerX, centerY, radius, radius, 360, 270, true, iterations, pathData);
          }
        } else {
          LineTo(0, height, pathData);
        }
        pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
        Offset(this.x, this.y, pathData);
        _get(_getPrototypeOf(RoundRectangle.prototype), "updateData", this).call(this);
        return this;
      }
    }]);
    return RoundRectangle;
  }(PathBase);

  var GetTint = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
  var Triangle$1 = /*#__PURE__*/function (_BaseGeom) {
    _inherits(Triangle, _BaseGeom);
    function Triangle(x0, y0, x1, y1, x2, y2) {
      var _this;
      _classCallCheck(this, Triangle);
      if (x0 === undefined) {
        x0 = 0;
      }
      if (y0 === undefined) {
        y0 = 0;
      }
      if (x1 === undefined) {
        x1 = 0;
      }
      if (y1 === undefined) {
        y1 = 0;
      }
      if (x2 === undefined) {
        x2 = 0;
      }
      if (y2 === undefined) {
        y2 = 0;
      }
      _this = _callSuper(this, Triangle);
      _this.pathData = [];
      _this.closePath = true;
      _this.setP0(x0, y0);
      _this.setP1(x1, y1);
      _this.setP2(x2, y2);
      return _this;
    }
    _createClass(Triangle, [{
      key: "x0",
      get: function get() {
        return this._x0;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x0 !== value;
        this._x0 = value;
      }
    }, {
      key: "y0",
      get: function get() {
        return this._y0;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y0 !== value;
        this._y0 = value;
      }
    }, {
      key: "setP0",
      value: function setP0(x, y) {
        this.x0 = x;
        this.y0 = y;
        return this;
      }
    }, {
      key: "x1",
      get: function get() {
        return this._x1;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x1 !== value;
        this._x1 = value;
      }
    }, {
      key: "y1",
      get: function get() {
        return this._y1;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y1 !== value;
        this._y1 = value;
      }
    }, {
      key: "setP1",
      value: function setP1(x, y) {
        this.x1 = x;
        this.y1 = y;
        return this;
      }
    }, {
      key: "x2",
      get: function get() {
        return this._x2;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x2 !== value;
        this._x2 = value;
      }
    }, {
      key: "y2",
      get: function get() {
        return this._y2;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y2 !== value;
        this._y2 = value;
      }
    }, {
      key: "setP2",
      value: function setP2(x, y) {
        this.dirty = this.dirty || this.x2 !== x || this.y2 !== y;
        this.x2 = x;
        this.y2 = y;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        this.pathData.push(this.x0, this.y0);
        this.pathData.push(this.x1, this.y1);
        this.pathData.push(this.x2, this.y2);
        this.pathData.push(this.x0, this.y0);
        _get(_getPrototypeOf(Triangle.prototype), "updateData", this).call(this);
        return this;
      }
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
          var fillTintColor = GetTint(this.fillColor, this.fillAlpha * alpha);
          var x0 = this.x0 - dx;
          var y0 = this.y0 - dy;
          var x1 = this.x1 - dx;
          var y1 = this.y1 - dy;
          var x2 = this.x2 - dx;
          var y2 = this.y2 - dy;
          var tx0 = calcMatrix.getX(x0, y0);
          var ty0 = calcMatrix.getY(x0, y0);
          var tx1 = calcMatrix.getX(x1, y1);
          var ty1 = calcMatrix.getY(x1, y1);
          var tx2 = calcMatrix.getX(x2, y2);
          var ty2 = calcMatrix.getY(x2, y2);
          pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
        }
        if (this.isStroked) {
          StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
      }
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {
        var x1 = this.x1 - dx;
        var y1 = this.y1 - dy;
        var x2 = this.x2 - dx;
        var y2 = this.y2 - dy;
        var x3 = this.x3 - dx;
        var y3 = this.y3 - dy;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();
        if (this.isFilled) {
          FillStyleCanvas(ctx, this);
          ctx.fill();
        }
        if (this.isStroked) {
          LineStyleCanvas(ctx, this);
          ctx.stroke();
        }
      }
    }]);
    return Triangle;
  }(BaseGeom);

  var ShapesUpdateMethods$4 = {
    buildShapes: function buildShapes() {
      this.addShape(new RoundRectangle().setName('box')).addShape(new Lines().setName('checker'));
    },
    updateShapes: function updateShapes() {
      var centerX = this.width / 2,
        centerY = this.height / 2,
        radius = Math.min(centerX, centerY);
      var width = radius * 2;
      var x = centerX - radius,
        y = centerY - radius;
      var boxLineWidth = this.boxLineWidth;
      var checkLineWidth = Math.max(width / 10, 2);
      var boxShape = this.getShape('box');
      var checkerShape = this.getShape('checker');

      // Setup shapes
      if (this.isSizeChanged) {
        // Box
        var posOffset = width * (1 - this.boxSize) / 2;
        var halfBoxLineWidth = boxLineWidth / 2;
        var boxInnerWidth = width * this.boxSize - boxLineWidth;
        boxShape.setTopLeftPosition(x + halfBoxLineWidth + posOffset, y + halfBoxLineWidth + posOffset).setSize(boxInnerWidth, boxInnerWidth);
        if (this.isCircleShape) {
          boxShape.setRadius(boxInnerWidth / 2);
        } else {
          boxShape.setRadius(0);
        }

        // Checker
        var posOffset = width * (1 - this.checkerSize) / 2;
        var unit = width * this.checkerSize / 4;
        var u1 = unit * 1,
          u2 = unit * 2,
          u3 = unit * 3;
        checkerShape.startAt(u1, u2).lineTo(u2, u3).lineTo(u3, u1).offset(x + posOffset, y + posOffset).end();
      }

      // Set styles
      if (this.checked) {
        boxShape.fillStyle(this.boxFillColor, this.boxFillAlpha).lineStyle(boxLineWidth, this.boxStrokeColor, this.boxStrokeAlpha);
        checkerShape.lineStyle(checkLineWidth, this.checkerColor);
      } else {
        boxShape.fillStyle(this.uncheckedBoxFillColor, this.uncheckedBoxFillAlpha).lineStyle(boxLineWidth, this.uncheckedBoxStrokeColor, this.uncheckedBoxStrokeAlpha);
        checkerShape.lineStyle();
      }

      // Play checker animation
      if (this.checked) {
        checkerShape.setDisplayPathSegment(this.checkerAnimProgress);
      }
    }
  };

  var GetValue$2D = Phaser.Utils.Objects.GetValue;
  var Linear$9 = Phaser.Math.Linear;
  var EaseValueTask = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(EaseValueTask, _EaseValueTaskBase);
    function EaseValueTask(gameObject, config) {
      var _this;
      _classCallCheck(this, EaseValueTask);
      _this = _callSuper(this, EaseValueTask, [gameObject, config]);
      // this.parent = gameObject;
      // this.timer

      _this.resetFromJSON();
      _this.boot();
      return _this;
    }
    _createClass(EaseValueTask, [{
      key: "start",
      value: function start(config) {
        if (this.timer.isRunning) {
          return this;
        }
        var target = this.target;
        this.propertyKey = GetValue$2D(config, 'key', 'value');
        var currentValue = target[this.propertyKey];
        this.fromValue = GetValue$2D(config, 'from', currentValue);
        this.toValue = GetValue$2D(config, 'to', currentValue);
        this.setEase(GetValue$2D(config, 'ease', this.ease));
        this.setDuration(GetValue$2D(config, 'duration', this.duration));
        this.setRepeat(GetValue$2D(config, 'repeat', 0));
        this.setDelay(GetValue$2D(config, 'delay', 0));
        this.setRepeatDelay(GetValue$2D(config, 'repeatDelay', 0));
        this.timer.setDuration(this.duration).setRepeat(this.repeat).setDelay(this.delay).setRepeatDelay(this.repeatDelay);
        target[this.propertyKey] = this.fromValue;
        _get(_getPrototypeOf(EaseValueTask.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(target, timer) {
        var t = timer.t;
        t = this.easeFn(t);
        target[this.propertyKey] = Linear$9(this.fromValue, this.toValue, t);
      }
    }]);
    return EaseValueTask;
  }(EaseValueTaskBase);

  var CheckerAnimationMethods = {
    setCheckerAnimationDuration: function setCheckerAnimationDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }
      this.checkerAnimDuration = duration;
      return this;
    },
    playCheckerAnimation: function playCheckerAnimation() {
      if (this.checkerAnimProgressTask === undefined) {
        this.checkerAnimProgressTask = new EaseValueTask(this, {
          eventEmitter: null
        });
      }
      this.checkerAnimProgressTask.restart({
        key: 'checkerAnimProgress',
        from: 0,
        to: 1,
        duration: this.checkerAnimDuration
      });
      return this;
    },
    stopCheckerAnimation: function stopCheckerAnimation() {
      if (this.checkerAnimProgressTask === undefined) {
        return this;
      }
      this.checkerAnimProgressTask.stop();
      return this;
    }
  };

  var methods$w = {};
  Object.assign(methods$w, StyleMethods$2, SizeMethods$1, ShapesUpdateMethods$4, CheckerAnimationMethods);

  var GetValue$2C = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$F = Phaser.Utils.Objects.IsPlainObject;
  var DefaultBoxFillColor = 0x005cb2;
  var DefaultCheckerColor = 0xffffff;
  var CheckboxShape = /*#__PURE__*/function (_BaseShapes) {
    _inherits(CheckboxShape, _BaseShapes);
    function CheckboxShape(scene, x, y, width, height, color, config) {
      var _this;
      _classCallCheck(this, CheckboxShape);
      if (IsPlainObject$F(x)) {
        config = x;
        x = GetValue$2C(config, 'x', 0);
        y = GetValue$2C(config, 'y', 0);
        width = GetValue$2C(config, 'width', 2);
        height = GetValue$2C(config, 'height', 2);
        color = GetValue$2C(config, 'color', DefaultBoxFillColor);
      } else if (IsPlainObject$F(color)) {
        config = color;
        color = GetValue$2C(config, 'color', DefaultBoxFillColor);
      }
      _this = _callSuper(this, CheckboxShape, [scene, x, y, width, height]);
      _this.type = 'rexCheckbox';
      if (color === undefined) {
        color = DefaultBoxFillColor;
      }
      _this.setBoxShape(GetValue$2C(config, 'circleBox', false));
      _this.setBoxFillStyle(color, GetValue$2C(config, 'boxFillAlpha', 1));
      _this.setUncheckedBoxFillStyle(GetValue$2C(config, 'uncheckedColor', null), GetValue$2C(config, 'uncheckedBoxFillAlpha', 1));
      _this.setBoxStrokeStyle(GetValue$2C(config, 'boxLineWidth', 4), GetValue$2C(config, 'boxStrokeColor', color), GetValue$2C(config, 'boxStrokeAlpha', 1));
      _this.setUncheckedBoxStrokeStyle(_this.boxLineWidth, GetValue$2C(config, 'uncheckedBoxStrokeColor', _this.boxStrokeColor), GetValue$2C(config, 'uncheckedBoxStrokeAlpha', _this.boxStrokeAlpha));
      _this.setCheckerStyle(GetValue$2C(config, 'checkerColor', DefaultCheckerColor), GetValue$2C(config, 'checkerAlpha', 1));
      _this.setBoxSize(GetValue$2C(config, 'boxSize', 1));
      _this.setCheckerSize(GetValue$2C(config, 'checkerSize', 1));
      _this.setCheckerAnimationDuration(GetValue$2C(config, 'animationDuration', 150));
      _this.buildShapes();
      var value = GetValue$2C(config, 'checked');
      if (value === undefined) {
        value = GetValue$2C(config, 'value', false);
      }
      _this.setValue(value);
      return _this;
    }
    _createClass(CheckboxShape, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        value = !!value;
        if (this._value === value) {
          return;
        }
        this.dirty = true;
        this._value = value;
        if (value) {
          this.playCheckerAnimation();
        } else {
          this.stopCheckerAnimation();
        }
        this.emit('valuechange', value);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }, {
      key: "toggleValue",
      value: function toggleValue() {
        this.setValue(!this.value);
        return this;
      }
    }, {
      key: "checked",
      get: function get() {
        return this.value;
      },
      set: function set(value) {
        this.value = value;
      }
    }, {
      key: "setChecked",
      value: function setChecked(checked) {
        if (checked === undefined) {
          checked = true;
        }
        this.setValue(checked);
        return this;
      }
    }, {
      key: "toggleChecked",
      value: function toggleChecked() {
        this.toggleValue();
        return this;
      }
    }, {
      key: "checkerAnimProgress",
      get: function get() {
        return this._checkerAnimProgress;
      },
      set: function set(value) {
        if (this._checkerAnimProgress === value) {
          return;
        }
        this._checkerAnimProgress = value;
        this.dirty = true;
      }
    }]);
    return CheckboxShape;
  }(BaseShapes);
  Object.assign(CheckboxShape.prototype, methods$w);

  var GetValue$2B = Phaser.Utils.Objects.GetValue;
  var Button = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Button, _ComponentBase);
    function Button(gameObject, config) {
      var _this;
      _classCallCheck(this, Button);
      _this = _callSuper(this, Button, [gameObject, config]);
      // this.parent = gameObject;

      _this._enable = undefined;
      gameObject.setInteractive(GetValue$2B(config, "inputConfig", undefined));
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(Button, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.pointer = undefined;
        this.lastClickTime = undefined;
        this.isDown = false;
        this.isOver = false;
        this.setEnable(GetValue$2B(o, "enable", true));
        this.setMode(GetValue$2B(o, "mode", 1));
        this.setClickInterval(GetValue$2B(o, "clickInterval", 100));
        this.setDragThreshold(GetValue$2B(o, 'threshold', undefined));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        var gameObject = this.parent;
        gameObject.on('pointerdown', this.onPress, this);
        gameObject.on('pointerup', this.onRelease, this);
        gameObject.on('pointerout', this.onPointOut, this);
        gameObject.on('pointermove', this.onMove, this);
        gameObject.on('pointerover', this.onOver, this);
        gameObject.on('pointerout', this.onOut, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        // GameObject events will be removed when this gameObject destroyed 
        // this.parent.on('pointerdown', this.onPress, this);
        // this.parent.on('pointerup', this.onRelease, this);
        // this.parent.on('pointerout', this.onPointOut, this);
        // this.parent.on('pointermove', this.onMove, this);
        this.pointer = null;
        _get(_getPrototypeOf(Button.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }
        if (!e) {
          this.cancel();
        }
        this._enable = e;
        var eventName = e ? 'enable' : 'disable';
        this.emit(eventName, this, this.parent);
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = CLICKMODE$1[m];
        }
        this.mode = m;
        return this;
      }
    }, {
      key: "setClickInterval",
      value: function setClickInterval(interval) {
        this.clickInterval = interval; // ms
        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }

      // internal
    }, {
      key: "onPress",
      value: function onPress(pointer, localX, localY, event) {
        if (this.pointer !== undefined) {
          return;
        }
        this.pointer = pointer;
        this.isDown = true;
        this.emit('down', this, this.parent, pointer, event);
        if (this.mode === 0) {
          this.click(pointer.downTime, pointer, event);
        }
      }
    }, {
      key: "onRelease",
      value: function onRelease(pointer, localX, localY, event) {
        if (this.pointer !== pointer) {
          return;
        }
        this.isDown = false;
        this.emit('up', this, this.parent, pointer, event);
        if (this.mode === 1) {
          this.click(pointer.upTime, pointer, event);
        }
        this.pointer = undefined;
      }
    }, {
      key: "onPointOut",
      value: function onPointOut(pointer, event) {
        if (this.pointer !== pointer) {
          return;
        }
        this.cancel();
      }
    }, {
      key: "onMove",
      value: function onMove(pointer, localX, localY, event) {
        if (this.pointer !== pointer) {
          return;
        }
        if (this.dragThreshold === undefined) {
          return;
        }
        if (this.mode === 1) {
          if (pointer.getDistance() >= this.dragThreshold) {
            this.cancel();
          }
        }
      }
    }, {
      key: "onOver",
      value: function onOver(pointer, localX, localY, event) {
        if (!this.enable) {
          return this;
        }
        this.isOver = true;
        this.emit('over', this, this.parent, pointer, event);
        return this;
      }
    }, {
      key: "onOut",
      value: function onOut(pointer, event) {
        if (!this.enable) {
          return this;
        }
        this.isOver = false;
        this.emit('out', this, this.parent, pointer, event);
        return this;
      }
    }, {
      key: "click",
      value: function click(nowTime, pointer, event) {
        if (!this.enable) {
          return this;
        }
        if (nowTime === undefined) {
          // fires 'click' event manually
          this.emit('click', this, this.parent, pointer, event);
          return this;
        }
        this.pointer = undefined;
        var lastClickTime = this.lastClickTime;
        if (lastClickTime !== undefined && nowTime - lastClickTime <= this.clickInterval) {
          return this;
        }
        this.lastClickTime = nowTime;
        this.emit('click', this, this.parent, pointer, event);
        return this;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.pointer = undefined;
        return this;
      }
    }]);
    return Button;
  }(ComponentBase);
  var CLICKMODE$1 = {
    press: 0,
    pointerdown: 0,
    release: 1,
    pointerup: 1
  };

  Phaser.Utils.Objects.GetValue;

  var StyleMethods = {
    setTrackFillStyle: function setTrackFillStyle(color, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.dirty = this.dirty || this.trackFillColor !== color || this.trackFillAlpha !== alpha;
      this.trackFillColor = color;
      this.trackFillAlpha = alpha;
      return this;
    },
    setFalseValueTrackFillStyle: function setFalseValueTrackFillStyle(color, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.dirty = this.dirty || this.falseValueTrackColor !== color || this.uncheckedTrackFillAlpha !== alpha;
      this.falseValueTrackColor = color;
      this.falseValueTrackFillAlpha = alpha;
      return this;
    },
    setThumbStyle: function setThumbStyle(color, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      this.dirty = this.dirty || this.thumbColor !== color || this.checkAlpha !== alpha;
      this.thumbColor = color;
      this.thumbAlpha = alpha;
      return this;
    }
  };

  var SizeMethods = {
    setTrackSize: function setTrackSize(width, height) {
      this.dirty = this.dirty || this.trackWidth !== width || this.trackHeight !== height;
      this.trackWidth = width;
      this.trackHeight = height;
      return this;
    },
    setTrackRadius: function setTrackRadius(radius) {
      this.dirty = this.dirty || this.trackRadius !== radius;
      this.trackRadius = radius;
      return this;
    },
    setThumbSize: function setThumbSize(width, height) {
      if (height === undefined) {
        height = width;
      }
      this.dirty = this.dirty || this.thumbWidth !== width || this.thumbHeight !== height;
      this.thumbWidth = width;
      this.thumbHeight = height;
      return this;
    },
    setThumbRadius: function setThumbRadius(radius) {
      this.dirty = this.dirty || this.thumbRadius !== radius;
      this.thumbRadius = radius;
      return this;
    }
  };

  var PositionMethods = {
    setThumbPosition: function setThumbPosition(left, right) {
      if (right === undefined) {
        right = 1 - left;
      }
      this.thumbLeftX = left;
      this.thumbRightX = right;
      return this;
    },
    setRTL: function setRTL(rtl) {
      if (rtl === undefined) {
        rtl = true;
      }
      this.rtl = rtl;
      return this;
    }
  };

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  /**
   * Calculates a linear (interpolation) value over t.
   *
   * @function Phaser.Math.Linear
   * @since 3.0.0
   *
   * @param {number} p0 - The first point.
   * @param {number} p1 - The second point.
   * @param {number} t - The percentage between p0 and p1 to return, represented as a number between 0 and 1.
   *
   * @return {number} The step t% of the way between p0 and p1.
   */
  var Linear$8 = function Linear(p0, p1, t) {
    return (p1 - p0) * t + p0;
  };

  var MixColor = function MixColor(color0, color1, t) {
    var r = Linear$8(GetR(color0), GetR(color1), t);
    var g = Linear$8(GetG(color0), GetG(color1), t);
    var b = Linear$8(GetB(color0), GetB(color1), t);
    return (r & 0xff) << 16 | (g & 0xff) << 8 | b & 0xff;
  };

  var Linear$7 = Phaser.Math.Linear;
  var ShapesUpdateMethods$3 = {
    buildShapes: function buildShapes() {
      this.addShape(new RoundRectangle().setName('track')).addShape(new RoundRectangle().setName('thumb'));
    },
    updateShapes: function updateShapes() {
      var width = this.width,
        height = this.height;
      var toggleAnimProgress = this.value ? this.toggleAnimProgress : 1 - this.toggleAnimProgress;

      // Track
      var trackShape = this.getShape('track');
      if (this.isSizeChanged) {
        var trackWidth = width * this.trackWidth,
          trackHeight = height * this.trackHeight,
          trackX = (width - trackWidth) / 2,
          trackY = (height - trackHeight) / 2,
          trackRadius = height * this.trackRadius;
        trackShape.setTopLeftPosition(trackX, trackY).setSize(trackWidth, trackHeight).setRadius(trackRadius);
      }
      var trackFillColor = MixColor(this.falseValueTrackColor, this.trackFillColor, toggleAnimProgress);
      var trackFillAlpha = Linear$7(this.falseValueTrackFillAlpha, this.trackFillAlpha, toggleAnimProgress);
      trackShape.fillStyle(trackFillColor, trackFillAlpha);

      // Thumb
      var thumbShape = this.getShape('thumb');
      if (this.isSizeChanged) {
        var thumbWidth = width * this.thumbWidth,
          thumbHeight = height * this.thumbHeight,
          thumbRadius = height * this.thumbRadius;
        thumbShape.setSize(thumbWidth, thumbHeight).setRadius(thumbRadius);
      }
      var thumbX = Linear$7(this.thumbLeftX, this.thumbRightX, toggleAnimProgress) * width;
      if (this.rtl) {
        thumbX = width - thumbX;
      }
      var thumbY = height / 2;
      thumbShape.setCenterPosition(thumbX, thumbY);
      thumbShape.fillStyle(this.thumbColor, this.thumbAlpha);
    }
  };

  var ToggleAnimationMethods = {
    setToggleAnimationDuration: function setToggleAnimationDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }
      this.toggleAnimDuration = duration;
      return this;
    },
    playToggleAnimation: function playToggleAnimation() {
      if (this.toggleAnimProgressTask === undefined) {
        this.toggleAnimProgressTask = new EaseValueTask(this, {
          eventEmitter: null
        });
      }
      this.toggleAnimProgressTask.restart({
        key: 'toggleAnimProgress',
        from: 0,
        to: 1,
        duration: this.toggleAnimDuration
      });
      return this;
    },
    stopToggleAnimation: function stopToggleAnimation() {
      if (this.toggleAnimProgressTask === undefined) {
        return this;
      }
      this.toggleAnimProgressTask.stop();
      return this;
    }
  };

  var methods$v = {};
  Object.assign(methods$v, StyleMethods, SizeMethods, PositionMethods, ShapesUpdateMethods$3, ToggleAnimationMethods);

  var GrayScale = function GrayScale(color) {
    var shade = 0.3 * GetR(color) + 0.59 * GetG(color) + 0.11 * GetB(color);
    return (shade & 0xff) << 16 | (shade & 0xff) << 8 | shade & 0xff;
  };

  var GetValue$2A = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$E = Phaser.Utils.Objects.IsPlainObject;
  var DefaultTrackFillColor = 0x005cb2;
  var DefaultThumbFillColor = 0xffffff;
  var ToggleSwitchShape = /*#__PURE__*/function (_BaseShapes) {
    _inherits(ToggleSwitchShape, _BaseShapes);
    function ToggleSwitchShape(scene, x, y, width, height, color, config) {
      var _this;
      _classCallCheck(this, ToggleSwitchShape);
      if (IsPlainObject$E(x)) {
        config = x;
        x = GetValue$2A(config, 'x', 0);
        y = GetValue$2A(config, 'y', 0);
        width = GetValue$2A(config, 'width', 2);
        height = GetValue$2A(config, 'height', 2);
        color = GetValue$2A(config, 'color', DefaultTrackFillColor);
      } else if (IsPlainObject$E(color)) {
        config = color;
        color = GetValue$2A(config, 'color', DefaultTrackFillColor);
      }
      _this = _callSuper(this, ToggleSwitchShape, [scene, x, y, width, height]);
      _this.type = 'rexToggleSwitch';
      if (color === undefined) {
        color = DefaultTrackFillColor;
      }
      _this.setTrackFillStyle(color, GetValue$2A(config, 'trackFillAlpha', 1));
      _this.setFalseValueTrackFillStyle(GetValue$2A(config, 'falseValueTrackColor', GrayScale(color)), GetValue$2A(config, 'falseValueTrackFillAlpha', 1));
      _this.setThumbStyle(GetValue$2A(config, 'thumbColor', DefaultThumbFillColor), GetValue$2A(config, 'thumbAlpha', 1));
      _this.setTrackSize(GetValue$2A(config, 'trackWidth', 0.9), GetValue$2A(config, 'trackHeight', 0.5));
      _this.setTrackRadius(GetValue$2A(config, 'trackRadius', _this.trackHeight * 0.5));
      var thumbHeight = GetValue$2A(config, 'thumbHeight', undefined);
      var thumbWidth = GetValue$2A(config, 'thumbWidth', thumbHeight);
      if (thumbWidth === undefined) {
        thumbWidth = _this.trackHeight * 0.9;
      }
      _this.setThumbSize(thumbWidth, thumbHeight);
      _this.setThumbRadius(GetValue$2A(config, 'thumbRadius', _this.thumbHeight * 0.5));
      _this.setThumbPosition(GetValue$2A(config, 'thumbLeft', 0.3), GetValue$2A(config, 'thumbRight', undefined));
      _this.setRTL(GetValue$2A(config, 'rtl', false));
      _this.setToggleAnimationDuration(GetValue$2A(config, 'animationDuration', 150));
      _this.buildShapes();
      _this.setValue(GetValue$2A(config, 'value', false), 0);
      return _this;
    }
    _createClass(ToggleSwitchShape, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        value = !!value;
        if (this._value === value) {
          return;
        }
        this.dirty = true;
        this._value = value;
        this.playToggleAnimation();
        this.emit('valuechange', value);
      }
    }, {
      key: "setValue",
      value: function setValue(value, duration) {
        if (duration === undefined) {
          duration = this.toggleAnimDuration;
        }
        var durationSave = this.toggleAnimDuration;
        this.toggleAnimDuration = duration;
        this.value = value;
        this.toggleAnimDuration = durationSave;
        return this;
      }
    }, {
      key: "toggleValue",
      value: function toggleValue(duration) {
        this.setValue(!this.value, duration);
        return this;
      }
    }, {
      key: "toggleAnimProgress",
      get: function get() {
        return this._toggleAnimProgress;
      },
      set: function set(value) {
        if (this._toggleAnimProgress === value) {
          return;
        }
        this._toggleAnimProgress = value;
        this.dirty = true;
      }
    }]);
    return ToggleSwitchShape;
  }(BaseShapes);
  Object.assign(ToggleSwitchShape.prototype, methods$v);

  Phaser.Utils.Objects.GetValue;

  var LoadImageMethods = {
    loadFromURL: function loadFromURL(url, callback) {
      var self = this;
      var img = new Image();
      img.onload = function () {
        if (self.width !== img.width || self.height !== img.height) {
          self.resize(img.width, img.height);
        } else {
          self.clear();
        }
        self.context.drawImage(img, 0, 0);
        self.updateTexture();
        if (callback) {
          callback();
        }
        img.onload = null;
        img.src = '';
        img.remove();
      };
      img.src = url;
      return this;
    },
    loadFromURLPromise: function loadFromURLPromise(url) {
      var self = this;
      return new Promise(function (resolve, reject) {
        self.loadFromURL(url, resolve);
      });
    },
    loadFromFile: function loadFromFile(file, callback) {
      var url = URL.createObjectURL(file);
      this.loadFromURL(url, function () {
        URL.revokeObjectURL(url);
        if (callback) {
          callback();
        }
      });
      return this;
    },
    loadFromFilePromise: function loadFromFilePromise(file) {
      var self = this;
      return new Promise(function (resolve, reject) {
        self.loadFromFile(file, resolve);
      });
    }
  };

  var Canvas = /*#__PURE__*/function (_CanvasBase) {
    _inherits(Canvas, _CanvasBase);
    function Canvas() {
      _classCallCheck(this, Canvas);
      return _callSuper(this, Canvas, arguments);
    }
    return _createClass(Canvas);
  }(Canvas$1);
  Object.assign(Canvas.prototype, LoadImageMethods);

  Phaser.Utils.Objects.GetValue;

  Phaser.Utils.Objects.GetValue;

  var Linear$6 = Phaser.Math.Linear;
  var Percent$5 = Phaser.Math.Percent;
  var ProgressValueMethods = {
    setValue: function setValue(value, min, max) {
      if (value === undefined || value === null) {
        return this;
      }
      if (min !== undefined) {
        value = Percent$5(value, min, max);
      }
      this.value = value;
      return this;
    },
    addValue: function addValue(inc, min, max) {
      if (min !== undefined) {
        inc = Percent$5(inc, min, max);
      }
      this.value += inc;
      return this;
    },
    getValue: function getValue(min, max) {
      var value = this.value;
      if (min !== undefined) {
        value = Linear$6(min, max, value);
      }
      return value;
    }
  };

  var Percent$4 = Phaser.Math.Percent;
  var SetEaseValuePropName = function SetEaseValuePropName(name) {
    this.easeValuePropName = name;
    return this;
  };
  var SetEaseValueDuration = function SetEaseValueDuration(duration) {
    this.easeValueDuration = duration;
    return this;
  };
  var SetEaseValueFunction = function SetEaseValueFunction(ease) {
    this.easeFunction = ease;
    return this;
  };
  var StopEaseValue = function StopEaseValue() {
    if (this.easeValueTask) {
      this.easeValueTask.stop();
    }
    return this;
  };
  var EaseValueTo = function EaseValueTo(value, min, max) {
    if (value === undefined || value === null) {
      return this;
    }
    if (min !== undefined) {
      value = Percent$4(value, min, max);
    }
    if (this.easeValueTask === undefined) {
      this.easeValueTask = new EaseValueTask(this, {
        eventEmitter: null
      });
    }
    this.easeValueTask.restart({
      key: this.easeValuePropName,
      to: value,
      duration: this.easeValueDuration,
      ease: this.easeFunction
    });
    return this;
  };
  var EaseValueRepeat = function EaseValueRepeat(from, to, repeat, repeatDelay) {
    if (repeat === undefined) {
      repeat = -1;
    }
    if (repeatDelay === undefined) {
      repeatDelay = 0;
    }
    if (this.easeValueTask === undefined) {
      this.easeValueTask = new EaseValueTask(this, {
        eventEmitter: null
      });
    }
    this.easeValueTask.restart({
      key: this.easeValuePropName,
      from: from,
      to: to,
      duration: this.easeValueDuration,
      ease: this.easeFunction,
      repeat: repeat,
      repeatDelay: repeatDelay
    });
    return this;
  };
  var EaseValueMethods = {
    setEaseValuePropName: SetEaseValuePropName,
    setEaseValueDuration: SetEaseValueDuration,
    setEaseValueFunction: SetEaseValueFunction,
    stopEaseValue: StopEaseValue,
    easeValueTo: EaseValueTo,
    easeValueRepeat: EaseValueRepeat
  };

  var GetValue$2z = Phaser.Utils.Objects.GetValue;
  var Clamp$d = Phaser.Math.Clamp;
  function ProgressBase (BaseClass) {
    var ProgressBase = /*#__PURE__*/function (_BaseClass) {
      _inherits(ProgressBase, _BaseClass);
      function ProgressBase() {
        _classCallCheck(this, ProgressBase);
        return _callSuper(this, ProgressBase, arguments);
      }
      _createClass(ProgressBase, [{
        key: "bootProgressBase",
        value: function bootProgressBase(config) {
          this.eventEmitter = GetValue$2z(config, 'eventEmitter', this);
          var callback = GetValue$2z(config, 'valuechangeCallback', null);
          if (callback !== null) {
            var scope = GetValue$2z(config, 'valuechangeCallbackScope', undefined);
            this.eventEmitter.on('valuechange', callback, scope);
          }
          this.setEaseValuePropName('value').setEaseValueDuration(GetValue$2z(config, 'easeValue.duration', 0)).setEaseValueFunction(GetValue$2z(config, 'easeValue.ease', 'Linear'));
          return this;
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          value = Clamp$d(value, 0, 1);
          var oldValue = this._value;
          var valueChanged = oldValue != value;
          this.dirty = this.dirty || valueChanged;
          this._value = value;
          if (valueChanged) {
            this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
          }
        }
      }]);
      return ProgressBase;
    }(BaseClass);
    Object.assign(ProgressBase.prototype, ProgressValueMethods, EaseValueMethods);
    return ProgressBase;
  }

  var RadToDeg$6 = Phaser.Math.RadToDeg;
  var DegToRad$8 = Phaser.Math.DegToRad;
  var FillArc = function FillArc(shape, x, y, outerRadius, innerRadius, startAngle, endAngle, anticlockwise) {
    var isCircle = Math.abs(endAngle - startAngle) === 360;
    var radStartAngle = DegToRad$8(startAngle),
      radEndAngle = DegToRad$8(endAngle);
    var cosStartAngle = Math.cos(radStartAngle),
      sinStartAngle = Math.sin(radStartAngle),
      cosEndAngle = Math.cos(radEndAngle),
      sinEndAngle = Math.sin(radEndAngle);
    shape.startAt(x + cosStartAngle * outerRadius, y + sinStartAngle * outerRadius);
    shape.arc(x, y, outerRadius, startAngle, endAngle, anticlockwise);
    if (isCircle && innerRadius === 0) ; else {
      shape.lineTo(x + cosEndAngle * innerRadius, y + sinEndAngle * innerRadius);
      if (innerRadius > 0) {
        shape.arc(x, y, innerRadius, endAngle, startAngle, !anticlockwise);
      }
    }
    shape.close();
    return shape;
  };
  var ShapesUpdateMethods$2 = {
    buildShapes: function buildShapes() {
      this.addShape(new Lines().setName('track')).addShape(new Lines().setName('bar')).addShape(new Circle().setName('center'));
    },
    updateShapes: function updateShapes() {
      var x = this.radius;
      var barWidth = this.thickness * this.radius;
      var barOuterRadius = this.radius;
      var barInnerRadius = barOuterRadius - barWidth;

      // Track shape
      var trackShape = this.getShape('track');
      if (this.trackColor != null && this.thickness > 0) {
        trackShape.fillStyle(this.trackColor);
        FillArc(trackShape, x, x, barOuterRadius, barInnerRadius, 0, 360, false);
      } else {
        trackShape.reset();
      }

      // Bar shape
      var barShape = this.getShape('bar');
      if (this.barColor != null && this.thickness > 0) {
        var anticlockwise, startAngle, endAngle;
        if (this.value === 1) {
          anticlockwise = false;
          startAngle = 0;
          endAngle = 360;
        } else {
          anticlockwise = this.anticlockwise;
          startAngle = RadToDeg$6(this.startAngle);
          var deltaAngle = 360 * (anticlockwise ? 1 - this.value : this.value);
          endAngle = deltaAngle + startAngle;
        }
        barShape.fillStyle(this.barColor);
        FillArc(barShape, x, x, barOuterRadius, barInnerRadius, startAngle, endAngle, false);
      } else {
        barShape.reset();
      }

      // Center shape
      var centerShape = this.getShape('center');
      if (this.centerColor && barInnerRadius > 0) {
        centerShape.setCenterPosition(x, x).setRadius(barInnerRadius).fillStyle(this.centerColor);
      } else {
        centerShape.reset();
      }
    }
  };

  var GetValue$2y = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$D = Phaser.Utils.Objects.IsPlainObject;
  var Clamp$c = Phaser.Math.Clamp;
  var DefaultStartAngle$1 = Phaser.Math.DegToRad(270);
  var CircularProgress$1 = /*#__PURE__*/function (_ProgressBase) {
    _inherits(CircularProgress, _ProgressBase);
    function CircularProgress(scene, x, y, radius, barColor, value, config) {
      var _this;
      _classCallCheck(this, CircularProgress);
      if (IsPlainObject$D(x)) {
        config = x;
        x = GetValue$2y(config, 'x', 0);
        y = GetValue$2y(config, 'y', 0);
        radius = GetValue$2y(config, 'radius', 1);
        barColor = GetValue$2y(config, 'barColor', undefined);
        value = GetValue$2y(config, 'value', 0);
      }
      if (radius === undefined) {
        radius = 1;
      }
      var width = radius * 2;
      _this = _callSuper(this, CircularProgress, [scene, x, y, width, width]);
      _this.type = 'rexCircularProgress';
      _this.bootProgressBase(config);
      _this.setRadius(radius);
      _this.setTrackColor(GetValue$2y(config, 'trackColor', undefined));
      _this.setBarColor(barColor);
      _this.setCenterColor(GetValue$2y(config, 'centerColor', undefined));
      _this.setThickness(GetValue$2y(config, 'thickness', 0.2));
      _this.setStartAngle(GetValue$2y(config, 'startAngle', DefaultStartAngle$1));
      _this.setAnticlockwise(GetValue$2y(config, 'anticlockwise', false));
      _this.buildShapes();
      _this.setValue(value);
      return _this;
    }
    _createClass(CircularProgress, [{
      key: "resize",
      value: function resize(width, height) {
        width = Math.floor(Math.min(width, height));
        if (width === this.width) {
          return this;
        }
        _get(_getPrototypeOf(CircularProgress.prototype), "resize", this).call(this, width, width);
        this.setRadius(width / 2);
        return this;
      }
    }, {
      key: "radius",
      get: function get() {
        return this._radius;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radius != value;
        this._radius = value;
        var width = value * 2;
        this.resize(width, width);
      }
    }, {
      key: "setRadius",
      value: function setRadius(radius) {
        this.radius = radius;
        return this;
      }
    }, {
      key: "trackColor",
      get: function get() {
        return this._trackColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._trackColor != value;
        this._trackColor = value;
      }
    }, {
      key: "setTrackColor",
      value: function setTrackColor(color) {
        this.trackColor = color;
        return this;
      }
    }, {
      key: "barColor",
      get: function get() {
        return this._barColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._barColor != value;
        this._barColor = value;
      }
    }, {
      key: "setBarColor",
      value: function setBarColor(color) {
        this.barColor = color;
        return this;
      }
    }, {
      key: "startAngle",
      get: function get() {
        return this._startAngle;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._startAngle != value;
        this._startAngle = value;
      }
    }, {
      key: "setStartAngle",
      value: function setStartAngle(angle) {
        this.startAngle = angle;
        return this;
      }
    }, {
      key: "anticlockwise",
      get: function get() {
        return this._anticlockwise;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._anticlockwise != value;
        this._anticlockwise = value;
      }
    }, {
      key: "setAnticlockwise",
      value: function setAnticlockwise(anticlockwise) {
        if (anticlockwise === undefined) {
          anticlockwise = true;
        }
        this.anticlockwise = anticlockwise;
        return this;
      }
    }, {
      key: "thickness",
      get: function get() {
        return this._thickness;
      },
      set: function set(value) {
        value = Clamp$c(value, 0, 1);
        this.dirty = this.dirty || this._thickness != value;
        this._thickness = value;
      }
    }, {
      key: "setThickness",
      value: function setThickness(thickness) {
        this.thickness = thickness;
        return this;
      }
    }, {
      key: "centerColor",
      get: function get() {
        return this._centerColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._centerColor != value;
        this._centerColor = value;
      }
    }, {
      key: "setCenterColor",
      value: function setCenterColor(color) {
        this.centerColor = color;
        return this;
      }
    }]);
    return CircularProgress;
  }(ProgressBase(BaseShapes));
  Object.assign(CircularProgress$1.prototype, ShapesUpdateMethods$2);

  var DrawCircle = function DrawCircle(canvas, context, x, y, rx, ry, fillStyle, strokeStyle, lineWidth, startAngle, endAngle, anticlockwise) {
    if (startAngle === undefined) {
      startAngle = 0;
    }
    if (endAngle === undefined) {
      endAngle = 2 * Math.PI;
    }
    if (anticlockwise === undefined) {
      anticlockwise = false;
    }
    context.beginPath();
    context.ellipse(x, y, rx, ry, 0, startAngle, endAngle, anticlockwise);
    if (fillStyle != null) {
      context.fillStyle = fillStyle;
      context.fill();
    }
    if (strokeStyle != null) {
      context.strokeStyle = strokeStyle;
      context.lineWidth = lineWidth;
      context.stroke();
    }
  };

  var DrawText = function DrawText(canvas, context, x, y, text, font, fillStyle, strokeStyle, lineWidth, textAlign, textBaseline) {
    if (lineWidth === undefined && strokeStyle != null) {
      lineWidth = 2;
    }
    if (textAlign === undefined) {
      textAlign = 'start';
    }
    if (textBaseline === undefined) {
      textBaseline = 'alphabetic';
    }
    context.font = font;
    context.textAlign = textAlign;
    context.textBaseline = textBaseline;
    context.fillStyle = fillStyle;
    context.strokeStyle = strokeStyle;
    context.lineWidth = lineWidth;
    context.lineCap = 'round';
    context.lineJoin = 'round';
    if (strokeStyle != null && strokeStyle !== 'none' && lineWidth > 0) {
      context.strokeText(text, x, y);
    }
    if (fillStyle != null && fillStyle !== 'none') {
      context.fillText(text, x, y);
    }
  };

  var PI2$1 = Phaser.Math.PI2;
  var DrawContent$1 = function DrawContent() {
    var x = this.radius;
    var lineWidth = this.thickness * this.radius;
    var barRadius = this.radius - lineWidth / 2;
    var centerRadius = this.radius - lineWidth;
    var canvas = this.canvas,
      context = this.context;
    var anticlockwise = this.anticlockwise,
      startAngle = this.startAngle,
      endAngle = this.endAngle,
      deltaAngle = this._deltaAngle;

    // Draw track
    if (this.trackColor && lineWidth > 0) {
      context.save();
      DrawCircle(canvas, context, x, x, barRadius, barRadius, undefined, this.trackColor, lineWidth, startAngle, endAngle, anticlockwise);
      context.restore();
    }

    // Draw bar
    if (this.barColor && barRadius > 0) {
      var barEndAngle;
      if (anticlockwise) {
        barEndAngle = (startAngle - deltaAngle * this.value + PI2$1) % PI2$1;
      } else {
        barEndAngle = (startAngle + deltaAngle * this.value) % PI2$1;
      }
      context.save();
      var style;
      if (this.barColor2) {
        var x0 = x + barRadius * Math.cos(startAngle),
          y0 = x + barRadius * Math.sin(startAngle),
          x1 = x + barRadius * Math.cos(barEndAngle),
          y1 = x + barRadius * Math.sin(barEndAngle);
        var grd = context.createLinearGradient(x0, y0, x1, y1);
        grd.addColorStop(0, this.barColor2);
        grd.addColorStop(1, this.barColor);
        style = grd;
      } else {
        style = this.barColor;
      }
      DrawCircle(canvas, context, x, x, barRadius, barRadius, undefined, style, lineWidth, startAngle, barEndAngle, anticlockwise);
      context.restore();
    }

    // Draw center
    if (this.centerColor && centerRadius > 0) {
      var fillStyle;
      if (this.centerColor2) {
        fillStyle = this.context.createRadialGradient(x, x, 0, x, x, centerRadius);
        fillStyle.addColorStop(0, this.centerColor);
        fillStyle.addColorStop(1, this.centerColor2);
      } else {
        fillStyle = this.centerColor;
      }
      context.save();
      DrawCircle(canvas, context, x, x, centerRadius, centerRadius, fillStyle);
      context.restore();
    }

    // Draw text
    if (this.textFormatCallback && (this.textColor || this.textStrokeColor)) {
      context.save();
      DrawText(canvas, context, x, x, this.getFormatText(), this.textFont, this.textColor, this.textStrokeColor, this.textStrokeThickness, 'center',
      // textAlign
      'middle' // textBaseline
      );
      context.restore();
    }
  };

  var GetValue$2x = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$C = Phaser.Utils.Objects.IsPlainObject;
  var NormalizeAngle$1 = Phaser.Math.Angle.Normalize;
  var Clamp$b = Phaser.Math.Clamp;
  var DefaultStartAngle = Phaser.Math.DegToRad(270);
  var PI2 = Phaser.Math.PI2;
  var CircularProgress = /*#__PURE__*/function (_ProgressBase) {
    _inherits(CircularProgress, _ProgressBase);
    function CircularProgress(scene, x, y, radius, barColor, value, config) {
      var _this;
      _classCallCheck(this, CircularProgress);
      if (IsPlainObject$C(x)) {
        config = x;
        x = GetValue$2x(config, 'x', 0);
        y = GetValue$2x(config, 'y', 0);
        radius = GetValue$2x(config, 'radius', 1);
        barColor = GetValue$2x(config, 'barColor', undefined);
        value = GetValue$2x(config, 'value', 0);
      }
      var width = radius * 2;
      _this = _callSuper(this, CircularProgress, [scene, x, y, width, width]);
      _this.type = 'rexCircularProgressCanvas';
      _this.bootProgressBase(config);
      _this.setRadius(radius);
      _this.setTrackColor(GetValue$2x(config, 'trackColor', undefined));
      _this.setBarColor(barColor);
      _this.setBarColor2(GetValue$2x(config, 'barColor2', undefined));
      _this.setCenterColor(GetValue$2x(config, 'centerColor', undefined));
      _this.setThickness(GetValue$2x(config, 'thickness', 0.2));
      _this.setStartAngle(GetValue$2x(config, 'startAngle', DefaultStartAngle));
      _this.setEndAngle(GetValue$2x(config, 'endAngle', _this.startAngle + PI2));
      _this.setAnticlockwise(GetValue$2x(config, 'anticlockwise', false));
      _this.setTextColor(GetValue$2x(config, 'textColor', undefined));
      _this.setTextStrokeColor(GetValue$2x(config, 'textStrokeColor', undefined), GetValue$2x(config, 'textStrokeThickness', undefined));
      var textFont = GetValue$2x(config, 'textFont', undefined);
      if (textFont) {
        _this.setTextFont(textFont);
      } else {
        _this.setTextFont(GetValue$2x(config, 'textSize', '16px'), GetValue$2x(config, 'textFamily', 'Courier'), GetValue$2x(config, 'textStyle', ''));
      }
      _this.setTextFormatCallback(GetValue$2x(config, 'textFormatCallback', undefined), GetValue$2x(config, 'textFormatCallbackScope', undefined));
      _this.setValue(value);
      return _this;
    }
    _createClass(CircularProgress, [{
      key: "resize",
      value: function resize(width, height) {
        width = Math.floor(Math.min(width, height));
        if (width === this.width) {
          return this;
        }
        _get(_getPrototypeOf(CircularProgress.prototype), "resize", this).call(this, width, width);
        this.setRadius(width / 2);
        return this;
      }
    }, {
      key: "radius",
      get: function get() {
        return this._radius;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radius != value;
        this._radius = value;
        var width = value * 2;
        this.resize(width, width);
      }
    }, {
      key: "setRadius",
      value: function setRadius(radius) {
        this.radius = radius;
        return this;
      }
    }, {
      key: "trackColor",
      get: function get() {
        return this._trackColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._trackColor != value;
        this._trackColor = value;
      }
    }, {
      key: "setTrackColor",
      value: function setTrackColor(color) {
        this.trackColor = color;
        return this;
      }
    }, {
      key: "barColor",
      get: function get() {
        return this._barColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._barColor != value;
        this._barColor = value;
      }
    }, {
      key: "setBarColor",
      value: function setBarColor(color) {
        this.barColor = color;
        return this;
      }
    }, {
      key: "barColor2",
      get: function get() {
        return this._barColor2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._barColor2 != value;
        this._barColor2 = value;
      }
    }, {
      key: "setBarColor2",
      value: function setBarColor2(color) {
        this.barColor2 = color;
        return this;
      }
    }, {
      key: "startAngle",
      get: function get() {
        return this._startAngle;
      },
      set: function set(value) {
        value = NormalizeAngle$1(value);
        this.dirty = this.dirty || this._startAngle != value;
        this._startAngle = value;
        this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
      }
    }, {
      key: "setStartAngle",
      value: function setStartAngle(angle) {
        this.startAngle = angle;
        return this;
      }
    }, {
      key: "endAngle",
      get: function get() {
        return this._endAngle;
      },
      set: function set(value) {
        value = NormalizeAngle$1(value);
        this.dirty = this.dirty || this._endAngle != value;
        this._endAngle = value;
        this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
      }
    }, {
      key: "setEndAngle",
      value: function setEndAngle(angle) {
        this.endAngle = angle;
        return this;
      }
    }, {
      key: "anticlockwise",
      get: function get() {
        return this._anticlockwise;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._anticlockwise != value;
        this._anticlockwise = value;
        this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
      }
    }, {
      key: "setAnticlockwise",
      value: function setAnticlockwise(anticlockwise) {
        if (anticlockwise === undefined) {
          anticlockwise = true;
        }
        this.anticlockwise = anticlockwise;
        return this;
      }
    }, {
      key: "thickness",
      get: function get() {
        return this._thickness;
      },
      set: function set(value) {
        value = Clamp$b(value, 0, 1);
        this.dirty = this.dirty || this._thickness != value;
        this._thickness = value;
      }
    }, {
      key: "setThickness",
      value: function setThickness(thickness) {
        this.thickness = thickness;
        return this;
      }
    }, {
      key: "centerColor",
      get: function get() {
        return this._centerColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._centerColor != value;
        this._centerColor = value;
      }
    }, {
      key: "centerColor2",
      get: function get() {
        return this._centerColor2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._centerColor2 != value;
        this._centerColor2 = value;
      }
    }, {
      key: "setCenterColor",
      value: function setCenterColor(color, color2) {
        this.centerColor = color;
        this.centerColor2 = color2;
        return this;
      }
    }, {
      key: "textColor",
      get: function get() {
        return this._textColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._textColor != value;
        this._textColor = value;
      }
    }, {
      key: "setTextColor",
      value: function setTextColor(color) {
        this.textColor = color;
        return this;
      }
    }, {
      key: "textStrokeColor",
      get: function get() {
        return this._textStrokeColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._textStrokeColor != value;
        this._textStrokeColor = value;
      }
    }, {
      key: "textStrokeThickness",
      get: function get() {
        return this._textStrokeThickness;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._textStrokeThickness != value;
        this._textStrokeThickness = value;
      }
    }, {
      key: "setTextStrokeColor",
      value: function setTextStrokeColor(color, thickness) {
        if (thickness === undefined) {
          thickness = 2;
        }
        this.textStrokeColor = color;
        this.textStrokeThickness = thickness;
        return this;
      }
    }, {
      key: "textFont",
      get: function get() {
        return this._textFont;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._textFont != value;
        this._textFont = value;
      }
    }, {
      key: "setTextFont",
      value: function setTextFont(fontSize, fontFamily, fontStyle) {
        var font;
        if (fontFamily === undefined) {
          font = fontSize;
        } else {
          font = fontStyle + ' ' + fontSize + ' ' + fontFamily;
        }
        this.textFont = font;
        return this;
      }
    }, {
      key: "setTextFormatCallback",
      value: function setTextFormatCallback(callback, scope) {
        this.textFormatCallback = callback;
        this.textFormatCallbackScope = scope;
        return this;
      }
    }, {
      key: "updateTexture",
      value: function updateTexture() {
        this.clear();
        DrawContent$1.call(this);
        _get(_getPrototypeOf(CircularProgress.prototype), "updateTexture", this).call(this);
        return this;
      }
    }, {
      key: "getFormatText",
      value: function getFormatText(value) {
        if (value === undefined) {
          value = this.value;
        }
        var text;
        if (this.textFormatCallbackScope) {
          text = this.textFormatCallback(value);
        } else {
          text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
        }
        return text;
      }
    }]);
    return CircularProgress;
  }(ProgressBase(Canvas$1));
  var GetDeltaAngle = function GetDeltaAngle(startAngle, endAngle, anticlockwise) {
    if (anticlockwise) {
      if (startAngle <= endAngle) {
        return PI2 + startAngle - endAngle;
      } else {
        return startAngle - endAngle;
      }
    } else {
      if (startAngle >= endAngle) {
        return PI2 + endAngle - startAngle;
      } else {
        return endAngle - startAngle;
      }
    }
  };

  var UpdateShapes = function UpdateShapes() {
    var skewX = this.skewX;
    var width = this.width - Math.abs(skewX);
    var height = this.height;
    var trackFill = this.getShape('trackFill');
    trackFill.fillStyle(this.trackColor);
    if (trackFill.isFilled) {
      BuildRectangle(trackFill,
      // lines
      0, 0,
      // x0, y0
      width, height,
      // x1, y1
      skewX // skewX
      ).close();
    }
    var bar = this.getShape('bar');
    bar.fillStyle(this.barColor);
    if (bar.isFilled) {
      var barX0, barX1;
      if (!this.rtl) {
        barX0 = 0;
        barX1 = width * this.value;
      } else {
        barX0 = width * (1 - this.value);
        barX1 = width;
      }
      BuildRectangle(bar,
      // lines
      barX0, 0,
      // x0, y0
      barX1, height,
      // x1, y1
      skewX // skew
      ).close();
    }
    var trackStroke = this.getShape('trackStroke');
    trackStroke.lineStyle(this.trackStrokeThickness, this.trackStrokeColor);
    if (trackStroke.isStroked) {
      BuildRectangle(trackStroke,
      // lines            
      0, 0,
      // x0, y0
      width, height,
      // x1, y1
      skewX // skewX
      ).end();
    }
  };
  var BuildRectangle = function BuildRectangle(lines, x0, y0, x1, y1, skewX) {
    var startX = (x0 + x1) / 2; // Start x from middle
    if (skewX >= 0) {
      lines.startAt(startX + skewX, y0).lineTo(x1 + skewX, y0).lineTo(x1, y1).lineTo(x0, y1).lineTo(x0 + skewX, y0).lineTo(startX + skewX, y0);
    } else {
      lines.startAt(startX, y0).lineTo(x1, y0).lineTo(x1 - skewX, y1).lineTo(x0 - skewX, y1).lineTo(x0, y0).lineTo(startX, y0);
    }
    return lines;
  };

  var GetValue$2w = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$B = Phaser.Utils.Objects.IsPlainObject;
  var LineProgress$1 = /*#__PURE__*/function (_ProgressBase) {
    _inherits(LineProgress, _ProgressBase);
    function LineProgress(scene, x, y, width, height, barColor, value, config) {
      var _this;
      _classCallCheck(this, LineProgress);
      if (IsPlainObject$B(x)) {
        config = x;
        x = GetValue$2w(config, 'x', 0);
        y = GetValue$2w(config, 'y', 0);
        width = GetValue$2w(config, 'width', 2);
        height = GetValue$2w(config, 'height', 2);
        barColor = GetValue$2w(config, 'barColor', undefined);
        value = GetValue$2w(config, 'value', 0);
      } else if (IsPlainObject$B(width)) {
        config = width;
        width = GetValue$2w(config, 'width', 2);
        height = GetValue$2w(config, 'height', 2);
        barColor = GetValue$2w(config, 'barColor', undefined);
        value = GetValue$2w(config, 'value', 0);
      } else if (IsPlainObject$B(barColor)) {
        config = barColor;
        barColor = GetValue$2w(config, 'barColor', undefined);
        value = GetValue$2w(config, 'value', 0);
      }
      _this = _callSuper(this, LineProgress, [scene, x, y, width, height, config]);
      _this.type = 'rexLineProgress';
      _this.bootProgressBase(config);
      _this.addShape(new Lines().setName('trackFill')).addShape(new Lines().setName('bar')).addShape(new Lines().setName('trackStroke'));
      _this.setTrackColor(GetValue$2w(config, 'trackColor', undefined));
      _this.setBarColor(barColor);
      _this.setTrackStroke(GetValue$2w(config, 'trackStrokeThickness', 2), GetValue$2w(config, 'trackStrokeColor', undefined));
      _this.setSkewX(GetValue$2w(config, 'skewX', 0));
      _this.setRTL(GetValue$2w(config, 'rtl', false));
      _this.setValue(value);
      return _this;
    }
    _createClass(LineProgress, [{
      key: "trackColor",
      get: function get() {
        return this._trackColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._trackColor != value;
        this._trackColor = value;
      }
    }, {
      key: "setTrackColor",
      value: function setTrackColor(color) {
        this.trackColor = color;
        return this;
      }
    }, {
      key: "trackStrokeColor",
      get: function get() {
        return this._trackStrokeColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._trackStrokeColor != value;
        this._trackStrokeColor = value;
      }
    }, {
      key: "trackStrokeThickness",
      get: function get() {
        return this._trackStrokeThickness;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._trackStrokeThickness != value;
        this._trackStrokeThickness = value;
      }
    }, {
      key: "setTrackStroke",
      value: function setTrackStroke(lineWidth, color) {
        this.trackStrokeThickness = lineWidth;
        this.trackStrokeColor = color;
        return this;
      }
    }, {
      key: "barColor",
      get: function get() {
        return this._barColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._barColor != value;
        this._barColor = value;
      }
    }, {
      key: "setBarColor",
      value: function setBarColor(color) {
        this.barColor = color;
        return this;
      }
    }, {
      key: "skewX",
      get: function get() {
        return this._skewX;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._skewX != value;
        this._skewX = value;
      }
    }, {
      key: "setSkewX",
      value: function setSkewX(value) {
        this.skewX = value;
        return this;
      }
    }, {
      key: "rtl",
      get: function get() {
        return this._rtl;
      },
      set: function set(value) {
        value = !!value;
        this.dirty = this.dirty || this._rtl != value;
        this._rtl = value;
      }
    }, {
      key: "setRTL",
      value: function setRTL(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.rtl = enable;
        return this;
      }
    }]);
    return LineProgress;
  }(ProgressBase(BaseShapes));
  var Methods$9 = {
    updateShapes: UpdateShapes
  };
  Object.assign(LineProgress$1.prototype, Methods$9);

  var AddPolygonPath = function AddPolygonPath(context, points) {
    context.save();
    context.beginPath();
    var point = points[0];
    context.moveTo(point.x, point.y);
    for (var i = 1, cnt = points.length; i < cnt; i++) {
      point = points[i];
      context.lineTo(point.x, point.y);
    }
    context.closePath();
    context.restore();
  };

  var DrawPolygon = function DrawPolygon(canvas, context, points, fillStyle, strokeStyle, lineWidth, lineJoin) {
    if (lineJoin === undefined) {
      lineJoin = 'round';
    }
    AddPolygonPath(context, points);
    context.lineJoin = lineJoin;
    if (fillStyle != null) {
      context.fillStyle = fillStyle;
      context.fill();
    }
    if (strokeStyle != null) {
      context.strokeStyle = strokeStyle;
      context.lineWidth = lineWidth;
      context.stroke();
    }
  };

  var DrawContent = function DrawContent() {
    var skewX = this.skewX;
    var width = this.width - Math.abs(skewX);
    var height = this.height;
    var canvas = this.canvas,
      context = this.context;

    // Has track
    if (this.trackColor || this.trackStrokeColor) {
      BuildPolygon(0, 0,
      // x0, y0
      width, height,
      // x1, y1
      skewX,
      // skewX
      this.trackPoints);
    }

    // Has bar
    var barX0, barX1;
    if (this.barColor) {
      if (!this.rtl) {
        barX0 = 0;
        barX1 = width * this.value;
      } else {
        barX0 = width * (1 - this.value);
        barX1 = width;
      }
      BuildPolygon(barX0, 0,
      // x0, y0
      barX1, height,
      // x1, y1
      skewX,
      // skewX
      this.barPoints);
    }
    if (this.trackColor) {
      context.save();
      DrawPolygon(canvas, context, this.trackPoints, this.trackColor);
      context.restore();
    }
    if (this.barColor) {
      context.save();
      var style;
      if (this.barColor2) {
        var grd;
        if (this.isHorizontalGradient) {
          var helfHeight = height / 2;
          grd = context.createLinearGradient(barX0, helfHeight, barX1, helfHeight);
        } else {
          var helfWidth = width / 2;
          grd = context.createLinearGradient(helfWidth, 0, helfWidth, height);
        }
        grd.addColorStop(0, this.rtl ? this.barColor : this.barColor2);
        grd.addColorStop(1, this.rtl ? this.barColor2 : this.barColor);
        style = grd;
      } else {
        style = this.barColor;
      }
      DrawPolygon(canvas, context, this.barPoints, style);
      context.restore();
    }
    if (this.trackStrokeColor && this.trackStrokeThickness > 0) {
      context.save();
      DrawPolygon(canvas, context, this.trackPoints, undefined, this.trackStrokeColor, this.trackStrokeThickness);
      context.restore();
    }
  };
  var BuildPolygon = function BuildPolygon(x0, y0, x1, y1, skewX, out) {
    if (out === undefined) {
      out = [];
    }
    out.length = 4;
    for (var i = 0; i < 4; i++) {
      if (!out[i]) {
        out[i] = {};
      }
    }
    var p;
    if (skewX >= 0) {
      p = out[0];
      p.x = x0 + skewX;
      p.y = y0;
      p = out[1];
      p.x = x1 + skewX;
      p.y = y0;
      p = out[2];
      p.x = x1;
      p.y = y1;
      p = out[3];
      p.x = x0;
      p.y = y1;
    } else {
      p = out[0];
      p.x = x0;
      p.y = y0;
      p = out[1];
      p.x = x1;
      p.y = y0;
      p = out[2];
      p.x = x1 - skewX;
      p.y = y1;
      p = out[3];
      p.x = x0 - skewX;
      p.y = y1;
    }
    return out;
  };

  var GetValue$2v = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$A = Phaser.Utils.Objects.IsPlainObject;
  var LineProgress = /*#__PURE__*/function (_ProgressBase) {
    _inherits(LineProgress, _ProgressBase);
    function LineProgress(scene, x, y, width, height, barColor, value, config) {
      var _this;
      _classCallCheck(this, LineProgress);
      if (IsPlainObject$A(x)) {
        config = x;
        x = GetValue$2v(config, 'x', 0);
        y = GetValue$2v(config, 'y', 0);
        width = GetValue$2v(config, 'width', 2);
        height = GetValue$2v(config, 'height', 2);
        barColor = GetValue$2v(config, 'barColor', undefined);
        value = GetValue$2v(config, 'value', 0);
      } else if (IsPlainObject$A(width)) {
        config = width;
        width = GetValue$2v(config, 'width', 2);
        height = GetValue$2v(config, 'height', 2);
        barColor = GetValue$2v(config, 'barColor', undefined);
        value = GetValue$2v(config, 'value', 0);
      } else if (IsPlainObject$A(barColor)) {
        config = barColor;
        barColor = GetValue$2v(config, 'barColor', undefined);
        value = GetValue$2v(config, 'value', 0);
      }
      _this = _callSuper(this, LineProgress, [scene, x, y, width, height]);
      _this.type = 'rexLineProgressCanvas';
      _this.trackPoints = [];
      _this.barPoints = [];
      _this.bootProgressBase(config);
      _this.setTrackColor(GetValue$2v(config, 'trackColor', undefined));
      _this.setBarColor(barColor, GetValue$2v(config, 'barColor2', undefined), GetValue$2v(config, 'isHorizontalGradient', undefined));
      _this.setTrackStroke(GetValue$2v(config, 'trackStrokeThickness', 2), GetValue$2v(config, 'trackStrokeColor', undefined));
      _this.setSkewX(GetValue$2v(config, 'skewX', 0));
      _this.setRTL(GetValue$2v(config, 'rtl', false));
      _this.setValue(value);
      return _this;
    }
    _createClass(LineProgress, [{
      key: "trackColor",
      get: function get() {
        return this._trackColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._trackColor != value;
        this._trackColor = value;
      }
    }, {
      key: "setTrackColor",
      value: function setTrackColor(color) {
        this.trackColor = color;
        return this;
      }
    }, {
      key: "trackStrokeColor",
      get: function get() {
        return this._trackStrokeColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._trackStrokeColor != value;
        this._trackStrokeColor = value;
      }
    }, {
      key: "trackStrokeThickness",
      get: function get() {
        return this._trackStrokeThickness;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._trackStrokeThickness != value;
        this._trackStrokeThickness = value;
      }
    }, {
      key: "setTrackStroke",
      value: function setTrackStroke(lineWidth, color) {
        this.trackStrokeThickness = lineWidth;
        this.trackStrokeColor = color;
        return this;
      }
    }, {
      key: "barColor",
      get: function get() {
        return this._barColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._barColor != value;
        this._barColor = value;
      }
    }, {
      key: "barColor2",
      get: function get() {
        return this._barColor2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._barColor2 != value;
        this._barColor2 = value;
      }
    }, {
      key: "isHorizontalGradient",
      get: function get() {
        return this._isHorizontalGradient;
      },
      set: function set(value) {
        this.dirty |= this._isHorizontalGradient != value;
        this._isHorizontalGradient = value;
      }
    }, {
      key: "setBarColor",
      value: function setBarColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
          isHorizontalGradient = true;
        }
        this.barColor = color;
        this.barColor2 = color2;
        this.isHorizontalGradient = isHorizontalGradient;
        return this;
      }
    }, {
      key: "skewX",
      get: function get() {
        return this._skewX;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._skewX != value;
        this._skewX = value;
      }
    }, {
      key: "setSkewX",
      value: function setSkewX(value) {
        this.skewX = value;
        return this;
      }
    }, {
      key: "rtl",
      get: function get() {
        return this._rtl;
      },
      set: function set(value) {
        value = !!value;
        this.dirty = this.dirty || this._rtl != value;
        this._rtl = value;
      }
    }, {
      key: "setRTL",
      value: function setRTL(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.rtl = enable;
        return this;
      }
    }, {
      key: "updateTexture",
      value: function updateTexture() {
        this.clear();
        DrawContent.call(this);
        _get(_getPrototypeOf(LineProgress.prototype), "updateTexture", this).call(this);
        return this;
      }
    }]);
    return LineProgress;
  }(ProgressBase(Canvas$1));

  Phaser.Math.Wrap;
  var Linear$5 = Phaser.Math.Linear;
  var DrawFitTriangle = function DrawFitTriangle() {
    var triangle = this.getShape('triangle');
    var padding = this.padding;
    var right = this.width - padding.right;
    var left = 0 + padding.left;
    var bottom = this.height - padding.bottom;
    var top = 0 + padding.top;
    var centerX = (left + right) / 2;
    var centerY = (top + bottom) / 2;
    var points = {
      0: {
        // right
        a: {
          x: left,
          y: top
        },
        b: {
          x: right,
          y: centerY
        },
        c: {
          x: left,
          y: bottom
        }
      },
      1: {
        // down
        a: {
          x: left,
          y: top
        },
        b: {
          x: centerX,
          y: bottom
        },
        c: {
          x: right,
          y: top
        }
      },
      2: {
        // left
        a: {
          x: right,
          y: top
        },
        b: {
          x: left,
          y: centerY
        },
        c: {
          x: right,
          y: bottom
        }
      },
      3: {
        // up
        a: {
          x: left,
          y: bottom
        },
        b: {
          x: centerX,
          y: top
        },
        c: {
          x: right,
          y: bottom
        }
      }
    };
    var pax, pay, pbx, pby, pcx, pcy;
    if (this.previousDirection === undefined) {
      var currentTrianglePoints = points[this.direction];
      var pa = currentTrianglePoints.a,
        pb = currentTrianglePoints.b,
        pc = currentTrianglePoints.c;
      pax = pa.x;
      pay = pa.y;
      pbx = pb.x;
      pby = pb.y;
      pcx = pc.x;
      pcy = pc.y;
    } else {
      var p0 = points[this.previousDirection];
      var p1 = points[this.direction];
      var t = this.easeDirectionProgress;
      pax = Linear$5(p0.a.x, p1.a.x, t);
      pay = Linear$5(p0.a.y, p1.a.y, t);
      pbx = Linear$5(p0.b.x, p1.b.x, t);
      pby = Linear$5(p0.b.y, p1.b.y, t);
      pcx = Linear$5(p0.c.x, p1.c.x, t);
      pcy = Linear$5(p0.c.y, p1.c.y, t);
    }
    triangle.startAt(pax, pay).lineTo(pbx, pby).lineTo(pcx, pcy);
    if (!this.arrowOnly) {
      triangle.close();
    } else {
      triangle.end();
    }
  };

  var DegToRad$7 = Phaser.Math.DegToRad;
  var Rad120 = DegToRad$7(120);
  var DrawCircleVerticesTriangle = function DrawCircleVerticesTriangle(triangle) {
    var triangle = this.getShape('triangle');
    var centerX = this.width / 2,
      centerY = this.height / 2;
    var radius = Math.min(centerX, centerY) * this.radius,
      verticeRotation = this.verticeRotation;
    triangle.startAt(centerX + radius * Math.cos(verticeRotation + Rad120), centerY + radius * Math.sin(verticeRotation + Rad120)).lineTo(centerX + radius * Math.cos(verticeRotation), centerY + radius * Math.sin(verticeRotation)).lineTo(centerX + radius * Math.cos(verticeRotation - Rad120), centerY + radius * Math.sin(verticeRotation - Rad120));
    if (!this.arrowOnly) {
      triangle.close();
    } else {
      triangle.end();
    }
  };

  var ShapesUpdateMethods$1 = {
    buildShapes: function buildShapes() {
      this.addShape(new Lines().setName('triangle'));
    },
    updateShapes: function updateShapes() {
      // Set style
      var triangle = this.getShape('triangle');
      if (!this.arrowOnly) {
        triangle.fillStyle(this.fillColor, this.fillAlpha).lineStyle(this.lineWidth, this.strokeColor, this.strokeAlpha);
      } else {
        triangle.fillStyle().lineStyle(this.lineWidth, this.strokeColor, this.strokeAlpha);
      }

      // Set points
      if (this.shapeMode === 0) {
        DrawFitTriangle.call(this);
      } else {
        DrawCircleVerticesTriangle.call(this);
      }
    }
  };

  var EaseDirectionMethods = {
    setEaseDuration: function setEaseDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }
      this.easeDuration = duration;
      return this;
    },
    playEaseDirectionation: function playEaseDirectionation() {
      if (this.easeDirectionProgressTask === undefined) {
        this.easeDirectionProgressTask = new EaseValueTask(this, {
          eventEmitter: null
        });
      }
      this.easeDirectionProgressTask.restart({
        key: 'easeDirectionProgress',
        from: 0,
        to: 1,
        duration: this.easeDuration
      });
      return this;
    },
    stopEaseDirection: function stopEaseDirection() {
      if (this.easeDirectionProgressTask === undefined) {
        return this;
      }
      this.easeDirectionProgressTask.stop();
      return this;
    }
  };

  var GetValue$2u = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$z = Phaser.Utils.Objects.IsPlainObject;
  var DegToRad$6 = Phaser.Math.DegToRad;
  var RadToDeg$5 = Phaser.Math.RadToDeg;
  var Triangle = /*#__PURE__*/function (_BaseShapes) {
    _inherits(Triangle, _BaseShapes);
    function Triangle(scene, x, y, width, height, fillColor, fillAlpha) {
      var _this;
      _classCallCheck(this, Triangle);
      var strokeColor, strokeAlpha, strokeWidth, arrowOnly;
      var direction, easeDuration, padding;
      var radius;
      if (IsPlainObject$z(x)) {
        var config = x;
        x = config.x;
        y = config.y;
        width = config.width;
        height = config.height;
        fillColor = config.color;
        fillAlpha = config.alpha;
        strokeColor = config.strokeColor;
        strokeAlpha = config.strokeAlpha;
        strokeWidth = config.strokeWidth;
        arrowOnly = config.arrowOnly;
        direction = config.direction;
        easeDuration = config.easeDuration;
        padding = config.padding;
        radius = config.radius;
      }
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 1;
      }
      if (height === undefined) {
        height = width;
      }
      if (arrowOnly === undefined) {
        arrowOnly = false;
      }
      if (direction === undefined) {
        direction = 0;
      }
      if (easeDuration === undefined) {
        easeDuration = 0;
      }
      if (padding === undefined) {
        padding = 0;
      }
      if (radius === undefined) {
        radius = undefined;
      }
      _this = _callSuper(this, Triangle, [scene, x, y, width, height]);
      _this.type = 'rexTriangle';
      _this.setFillStyle(fillColor, fillAlpha);
      if (strokeColor !== undefined && strokeWidth === undefined) {
        strokeWidth = 2;
      }
      _this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);
      _this.setArrowOnly(arrowOnly);
      _this.setDirection(direction, easeDuration);
      _this.setPadding(padding);
      _this.setRadius(radius);
      _this.buildShapes();
      return _this;
    }
    _createClass(Triangle, [{
      key: "arrowOnly",
      get: function get() {
        return this._arrowOnly;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._arrowOnly != value;
        this._arrowOnly = value;
      }
    }, {
      key: "setArrowOnly",
      value: function setArrowOnly(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.arrowOnly = enable;
        return this;
      }
    }, {
      key: "direction",
      get: function get() {
        return this._direction;
      },
      set: function set(value) {
        value = ParseDirection(value);
        if (this._direction === value) {
          return;
        }
        if (this.easeDuration > 0 && this._direction !== undefined) {
          this.previousDirection = this._direction;
        } else {
          this.previousDirection = undefined;
        }
        this._direction = value;
        this.verticeAngle = value * 90;
        this.dirty = true;
        if (this.previousDirection !== undefined) {
          this.playEaseDirectionation();
        } else {
          this.stopEaseDirection();
        }
      }
    }, {
      key: "setDirection",
      value: function setDirection(direction, easeDuration) {
        if (easeDuration !== undefined) {
          this.setEaseDuration(easeDuration);
        }
        this.direction = direction;
        return this;
      }
    }, {
      key: "toggleDirection",
      value: function toggleDirection(easeDuration) {
        this.setDirection(this.direction + 2, easeDuration);
        return this;
      }
    }, {
      key: "easeDirectionProgress",
      get: function get() {
        return this._easeDirectionProgress;
      },
      set: function set(value) {
        if (this._easeDirectionProgress === value) {
          return;
        }
        this._easeDirectionProgress = value;
        this.dirty = true;
      }
    }, {
      key: "setPadding",
      value: function setPadding(left, top, right, bottom) {
        if (_typeof(left) === 'object') {
          var config = left;

          //  If they specify x and/or y this applies to all
          var x = GetValue$2u(config, 'x', null);
          if (x !== null) {
            left = x;
            right = x;
          } else {
            left = GetValue$2u(config, 'left', 0);
            right = GetValue$2u(config, 'right', left);
          }
          var y = GetValue$2u(config, 'y', null);
          if (y !== null) {
            top = y;
            bottom = y;
          } else {
            top = GetValue$2u(config, 'top', 0);
            bottom = GetValue$2u(config, 'bottom', top);
          }
        } else {
          if (left === undefined) {
            left = 0;
          }
          if (top === undefined) {
            top = left;
          }
          if (right === undefined) {
            right = left;
          }
          if (bottom === undefined) {
            bottom = top;
          }
        }
        if (this.padding === undefined) {
          this.padding = {};
        }
        this.dirty = this.dirty || this.padding.left != left || this.padding.top != top || this.padding.right != right || this.padding.bottom != bottom;
        this.padding.left = left;
        this.padding.top = top;
        this.padding.right = right;
        this.padding.bottom = bottom;

        // Switch to fit mode
        this.setRadius();
        return this;
      }
    }, {
      key: "radius",
      get: function get() {
        return this._radius;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radius != value;
        this._radius = value;
      }
    }, {
      key: "setRadius",
      value: function setRadius(radius) {
        this.radius = radius;

        // 0: fit mode
        // 1: circle mode
        this.shapeMode = radius == null ? 0 : 1;
        return this;
      }
    }, {
      key: "verticeRotation",
      get: function get() {
        return this._verticeRotation;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._verticeRotation != value;
        this._verticeRotation = value;
      }
    }, {
      key: "setVerticeRotation",
      value: function setVerticeRotation(rotation) {
        this.verticeRotation = rotation;
        return this;
      }
    }, {
      key: "verticeAngle",
      get: function get() {
        return RadToDeg$5(this.verticeRotation);
      },
      set: function set(value) {
        this.verticeRotation = DegToRad$6(value);
      }
    }, {
      key: "setVerticeAngle",
      value: function setVerticeAngle(angle) {
        this.verticeAngle = angle;
        return this;
      }
    }]);
    return Triangle;
  }(BaseShapes);
  var DirectionNameMap = {
    right: 0,
    down: 1,
    left: 2,
    up: 3
  };
  var ParseDirection = function ParseDirection(direction) {
    if (typeof direction === 'string') {
      direction = DirectionNameMap[direction];
    }
    direction = direction % 4;
    return direction;
  };
  Object.assign(Triangle.prototype, ShapesUpdateMethods$1, EaseDirectionMethods);

  CheckP3Version();
  var Zone$1 = Phaser.GameObjects.Zone;
  var AddItem = Phaser.Utils.Array.Add;
  var RemoveItem$5 = Phaser.Utils.Array.Remove;
  var Base$1 = /*#__PURE__*/function (_Zone) {
    _inherits(Base, _Zone);
    function Base(scene, x, y, width, height) {
      var _this;
      _classCallCheck(this, Base);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 1;
      }
      if (height === undefined) {
        height = 1;
      }
      _this = _callSuper(this, Base, [scene, x, y, width, height]);
      _this.children = [];
      return _this;
    }
    _createClass(Base, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        if (fromScene) {
          // Stop scene
          var child;
          for (var i = this.children.length - 1; i >= 0; i--) {
            child = this.children[i];
            if (!child.parentContainer &&
            // Not in container
            !child.displayList // Not in scene, neither in layer
            ) {
              // Destroy child which is not in scene, container, or layer manually
              child.destroy(fromScene);
            }
          }
        }

        // Destroy/remove children
        this.clear(!fromScene);
        _get(_getPrototypeOf(Base.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "contains",
      value: function contains(gameObject) {
        return this.children.indexOf(gameObject) !== -1;
      }
    }, {
      key: "add",
      value: function add(gameObjects) {
        var parent = this;
        AddItem(this.children, gameObjects, 0,
        // Callback of item added
        function (gameObject) {
          gameObject.once('destroy', parent.onChildDestroy, parent);
        }, this);
        return this;
      }
    }, {
      key: "remove",
      value: function remove(gameObjects, destroyChild) {
        var parent = this;
        RemoveItem$5(this.children, gameObjects,
        // Callback of item removed
        function (gameObject) {
          gameObject.off('destroy', parent.onChildDestroy, parent);
          if (destroyChild) {
            gameObject.destroy();
          }
        });
        return this;
      }
    }, {
      key: "onChildDestroy",
      value: function onChildDestroy(child, fromScene) {
        // Only remove reference
        this.remove(child, false);
      }
    }, {
      key: "clear",
      value: function clear(destroyChild) {
        var parent = this;
        var gameObject;
        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
          gameObject = this.children[i];
          gameObject.off('destroy', parent.onChildDestroy, parent);
          if (destroyChild) {
            gameObject.destroy();
          }
        }
        this.children.length = 0;
        return this;
      }
    }]);
    return Base;
  }(Zone$1);
  var Components$1 = Phaser.GameObjects.Components;
  Phaser.Class.mixin(Base$1, [Components$1.Alpha, Components$1.Flip]);

  var GetParent$1 = function GetParent(gameObject, name) {
    var parent;
    if (name === undefined) {
      if (gameObject.hasOwnProperty('rexContainer')) {
        parent = gameObject.rexContainer.parent;
      }
    } else {
      parent = GetParent(gameObject);
      while (parent) {
        if (parent.name === name) {
          break;
        }
        parent = GetParent(parent);
      }
    }
    return parent;
  };
  var GetTopmostParent$1 = function GetTopmostParent(gameObject) {
    var parent = GetParent$1(gameObject);
    while (parent) {
      gameObject = parent;
      parent = GetParent$1(parent);
    }
    return gameObject;
  };

  var DegToRad$5 = Phaser.Math.DegToRad;
  var RadToDeg$4 = Phaser.Math.RadToDeg;
  var GetLocalState = function GetLocalState(gameObject) {
    if (!gameObject.hasOwnProperty('rexContainer')) {
      var rexContainer = {
        parent: null,
        self: null,
        layer: null,
        x: 0,
        y: 0,
        syncPosition: true,
        rotation: 0,
        syncRotation: true,
        scaleX: 0,
        scaleY: 0,
        syncScale: true,
        alpha: 0,
        syncAlpha: true,
        syncScrollFactor: true,
        syncCameraFilter: true,
        syncDisplayList: true,
        visible: true,
        active: true
      };
      Object.defineProperty(rexContainer, 'angle', {
        get: function get() {
          return RadToDeg$4(this.rotation);
        },
        set: function set(value) {
          this.rotation = DegToRad$5(value);
        }
      });
      Object.defineProperty(rexContainer, 'displayWidth', {
        get: function get() {
          return gameObject.width * this.scaleX;
        },
        set: function set(width) {
          this.scaleX = width / gameObject.width;
        }
      });
      Object.defineProperty(rexContainer, 'displayHeight', {
        get: function get() {
          return gameObject.height * this.scaleY;
        },
        set: function set(height) {
          this.scaleY = height / gameObject.height;
        }
      });
      gameObject.rexContainer = rexContainer;
    }
    return gameObject.rexContainer;
  };

  var Parent = {
    setParent: function setParent(gameObject, parent) {
      if (parent === undefined) {
        parent = this;
      }
      var localState = GetLocalState(gameObject);
      if (parent) {
        // Add to parent
        localState.parent = parent;
        localState.self = gameObject;
      } else {
        // Remove from parent
        localState.parent = null;
        localState.self = null;
      }
      return this;
    },
    getParent: function getParent(gameObject, name) {
      if (typeof gameObject === 'string') {
        name = gameObject;
        gameObject = undefined;
      }
      if (gameObject === undefined) {
        gameObject = this;
      }
      return GetParent$1(gameObject, name);
    },
    getTopmostParent: function getTopmostParent(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      return GetTopmostParent$1(gameObject);
    }
  };

  var GetValue$2t = Phaser.Utils.Objects.GetValue;
  var BaseAdd = Base$1.prototype.add;
  var Add$8 = function Add(gameObject, config) {
    this.setParent(gameObject);
    var state = GetLocalState(gameObject);
    SetupSyncFlags(state, config);
    this.resetChildState(gameObject) // Reset local state of child
    .updateChildVisible(gameObject) // Apply parent's visible to child
    .updateChildActive(gameObject) // Apply parent's active to child
    .updateChildScrollFactor(gameObject) // Apply parent's scroll factor to child
    .updateChildMask(gameObject) // Apply parent's mask to child
    .updateCameraFilter(gameObject); // Apply parent's cameraFilter to child

    BaseAdd.call(this, gameObject);
    SyncDisplayList$1.call(this, gameObject, state);
    return this;
  };
  var AddLocal = function AddLocal(gameObject, config) {
    this.setParent(gameObject);

    // Set local state from child directly
    var state = GetLocalState(gameObject);
    SetupSyncFlags(state, config);
    // Position
    state.x = gameObject.x;
    state.y = gameObject.y;
    state.rotation = gameObject.rotation;
    state.scaleX = gameObject.scaleX;
    state.scaleY = gameObject.scaleY;
    // Alpha
    state.alpha = gameObject.alpha;
    // Visible
    state.visible = gameObject.visible;
    // Active
    state.active = gameObject.active;
    this.updateChildPosition(gameObject).updateChildAlpha(gameObject).updateChildVisible(gameObject) // Apply parent's visible to child
    .updateChildActive(gameObject) // Apply parent's active to child
    .updateChildScrollFactor(gameObject) // Apply parent's scroll factor to child
    .updateChildMask(gameObject); // Apply parent's mask to child

    BaseAdd.call(this, gameObject);
    SyncDisplayList$1.call(this, gameObject, state);
    return this;
  };
  var SetupSyncFlags = function SetupSyncFlags(state, config) {
    if (config === undefined) {
      config = true;
    }
    if (typeof config === 'boolean') {
      state.syncPosition = config;
      state.syncRotation = config;
      state.syncScale = config;
      state.syncAlpha = config;
      state.syncScrollFactor = config;
      state.syncCameraFilter = config;
      state.syncDisplayList = config;
    } else {
      state.syncPosition = GetValue$2t(config, 'syncPosition', true);
      state.syncRotation = GetValue$2t(config, 'syncRotation', true);
      state.syncScale = GetValue$2t(config, 'syncScale', true);
      state.syncAlpha = GetValue$2t(config, 'syncAlpha', true);
      state.syncScrollFactor = GetValue$2t(config, 'syncScrollFactor', true);
      state.syncCameraFilter = GetValue$2t(config, 'syncCameraFilter', true);
      state.syncDisplayList = GetValue$2t(config, 'syncDisplayList', true);
    }
  };
  var SyncDisplayList$1 = function SyncDisplayList(gameObject, state) {
    this.addToParentContainer(gameObject); // Sync parent's container to child

    if (state.syncDisplayList) {
      this.addToPatentLayer(gameObject); // Sync parent's layer to child
    }
    this.addToRenderLayer(gameObject); // Sync parent's render-layer
  };
  var AddChild$2 = {
    // Can override this method
    add: function add(gameObject) {
      if (Array.isArray(gameObject)) {
        this.addMultiple(gameObject);
      } else {
        Add$8.call(this, gameObject);
      }
      return this;
    },
    // Don't override this method
    pin: function pin(gameObject, config) {
      if (Array.isArray(gameObject)) {
        this.addMultiple(gameObject, config);
      } else {
        Add$8.call(this, gameObject, config);
      }
      return this;
    },
    addMultiple: function addMultiple(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Add$8.call(this, gameObjects[i]);
      }
      return this;
    },
    addLocal: function addLocal(gameObject) {
      if (Array.isArray(gameObject)) {
        this.addMultiple(gameObject);
      } else {
        AddLocal.call(this, gameObject);
      }
      return this;
    },
    // Don't override this method
    pinLocal: function pinLocal(gameObject, config) {
      if (Array.isArray(gameObject)) {
        this.addMultiple(gameObject, config);
      } else {
        AddLocal.call(this, gameObject, config);
      }
      return this;
    },
    addLocalMultiple: function addLocalMultiple(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        AddLocal.call(this, gameObjects[i]);
      }
      return this;
    }
  };

  var BaseRemove = Base$1.prototype.remove;
  var BaseClear = Base$1.prototype.clear;
  var RemoveChild$1 = {
    // Can override this method
    remove: function remove(gameObject, destroyChild) {
      if (GetParent$1(gameObject) !== this) {
        return this;
      }
      this.setParent(gameObject, null);
      if (!destroyChild) {
        this.removeFromRenderLayer(gameObject);
      }
      BaseRemove.call(this, gameObject, destroyChild);
      return this;
    },
    // Don't override this method
    unpin: function unpin(gameObject, destroyChild) {
      if (GetParent$1(gameObject) !== this) {
        return this;
      }
      this.setParent(gameObject, null);
      if (!destroyChild) {
        this.removeFromRenderLayer(gameObject);
      }
      BaseRemove.call(this, gameObject, destroyChild);
      return this;
    },
    clear: function clear(destroyChild) {
      var children = this.children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        this.setParent(child, null);
        if (!destroyChild) {
          this.removeFromRenderLayer(child);
        }
      }
      BaseClear.call(this, destroyChild);
      return this;
    }
  };

  var ChildState = {
    getLocalState: function getLocalState(gameObject) {
      return GetLocalState(gameObject);
    },
    resetChildState: function resetChildState(gameObject) {
      this.resetChildPositionState(gameObject).resetChildVisibleState(gameObject).resetChildAlphaState(gameObject).resetChildActiveState(gameObject);
      return this;
    },
    resetChildrenState: function resetChildrenState(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        this.resetChildState(gameObjects[i]);
      }
      return this;
    },
    syncProperties: function syncProperties() {
      this.syncPosition().syncVisible().syncAlpha().syncActive().syncScrollFactor().syncMask();
      return this;
    }
  };

  var RotateAround$4 = Phaser.Math.RotateAround;
  var Transform = {
    worldToLocal: function worldToLocal(point) {
      // Transform
      point.x -= this.x;
      point.y -= this.y;
      // Rotate
      RotateAround$4(point, 0, 0, -this.rotation);
      // Scale
      point.x /= this.scaleX;
      point.y /= this.scaleY;
      return point;
    },
    localToWorld: function localToWorld(point) {
      // Scale
      point.x *= this.scaleX;
      point.y *= this.scaleY;
      // Rotate
      RotateAround$4(point, 0, 0, this.rotation);
      // Transform
      point.x += this.x;
      point.y += this.y;
      return point;
    }
  };

  var GetScale = function GetScale(a, b) {
    if (a === b) {
      return 1;
    } else {
      return a / b;
    }
  };

  var Position = {
    updateChildPosition: function updateChildPosition(child) {
      if (child.isRexContainerLite) {
        child.syncChildrenEnable = false;
      }
      var state = GetLocalState(child);
      var parent = state.parent;
      if (state.syncPosition) {
        child.x = state.x;
        child.y = state.y;
        parent.localToWorld(child);
      }
      if (state.syncRotation) {
        child.rotation = state.rotation + parent.rotation;
      }
      if (state.syncScale) {
        child.scaleX = state.scaleX * parent.scaleX;
        child.scaleY = state.scaleY * parent.scaleY;
      }
      if (child.isRexContainerLite) {
        child.syncChildrenEnable = true;
        child.syncPosition();
      }
      return this;
    },
    syncPosition: function syncPosition() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildPosition, this);
      }
      return this;
    },
    resetChildPositionState: function resetChildPositionState(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      state.x = child.x;
      state.y = child.y;
      parent.worldToLocal(state);
      state.scaleX = GetScale(child.scaleX, parent.scaleX);
      state.scaleY = GetScale(child.scaleY, parent.scaleY);
      state.rotation = child.rotation - parent.rotation;
      return this;
    },
    setChildPosition: function setChildPosition(child, x, y) {
      child.x = x;
      child.y = y;
      this.resetChildPositionState(child);
      return this;
    },
    setChildLocalPosition: function setChildLocalPosition(child, x, y) {
      var state = GetLocalState(child);
      state.x = x;
      state.y = y;
      this.updateChildPosition(child);
      return this;
    },
    resetLocalPositionState: function resetLocalPositionState() {
      var parent = GetLocalState(this).parent;
      if (parent) {
        parent.resetChildPositionState(this);
      }
      return this;
    }
  };

  var DegToRad$4 = Phaser.Math.DegToRad;
  var Rotation = {
    updateChildRotation: function updateChildRotation(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      if (state.syncRotation) {
        child.rotation = parent.rotation + state.rotation;
      }
      return this;
    },
    syncRotation: function syncRotation() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildRotation, this);
      }
      return this;
    },
    resetChildRotationState: function resetChildRotationState(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      state.rotation = child.rotation - parent.rotation;
      return this;
    },
    setChildRotation: function setChildRotation(child, rotation) {
      child.rotation = rotation;
      this.resetChildRotationState(child);
      return this;
    },
    setChildAngle: function setChildAngle(child, angle) {
      child.angle = angle;
      this.resetChildRotationState(child);
      return this;
    },
    setChildLocalRotation: function setChildLocalRotation(child, rotation) {
      var state = GetLocalState(child);
      state.rotation = rotation;
      this.updateChildRotation(child);
      return this;
    },
    setChildLocalAngle: function setChildLocalAngle(child, angle) {
      var state = GetLocalState(child);
      state.rotation = DegToRad$4(angle);
      this.updateChildRotation(child);
      return this;
    },
    resetLocalRotationState: function resetLocalRotationState() {
      var parent = GetLocalState(this).parent;
      if (parent) {
        parent.resetChildRotationState(this);
      }
      return this;
    }
  };

  var Scale$1 = {
    updateChildScale: function updateChildScale(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      if (state.syncScale) {
        child.scaleX = parent.scaleX * state.scaleX;
        child.scaleY = parent.scaleY * state.scaleY;
      }
      return this;
    },
    syncScale: function syncScale() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildScale, this);
      }
      return this;
    },
    resetChildScaleState: function resetChildScaleState(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      state.scaleX = GetScale(child.scaleX, parent.scaleX);
      state.scaleY = GetScale(child.scaleY, parent.scaleY);
      return this;
    },
    setChildScale: function setChildScale(child, scaleX, scaleY) {
      if (scaleY === undefined) {
        scaleY = scaleX;
      }
      child.scaleX = scaleX;
      child.scaleY = scaleY;
      this.resetChildScaleState(child);
      return this;
    },
    setChildLocalScale: function setChildLocalScale(child, scaleX, scaleY) {
      if (scaleY === undefined) {
        scaleY = scaleX;
      }
      var state = GetLocalState(child);
      state.scaleX = scaleX;
      state.scaleY = scaleY;
      this.updateChildScale(child);
      return this;
    },
    setChildDisplaySize: function setChildDisplaySize(child, width, height) {
      child.setDisplaySize(width, height);
      this.resetChildScaleState(child);
      return this;
    },
    resetLocalScaleState: function resetLocalScaleState() {
      var parent = GetLocalState(this).parent;
      if (parent) {
        parent.resetChildScaleState(this);
      }
      return this;
    }
  };

  /*

  Visible in localState:

    - visible: original visible of child
    - maskVisible: invisible by parent mask, see MaskChildren.js
        - undefined (not in masking) : Equal to mask visible
        - true (mask visible) : Inside, or across parent's visible area
        - false (maske invisible) : Out of parent's visible area

  Visible result of child = (parent visible) && (child visible) && (mask visible)
  */

  var Visible$1 = {
    updateChildVisible: function updateChildVisible(child) {
      var localState = GetLocalState(child);
      var parent = localState.parent;
      var maskVisible = localState.hasOwnProperty('maskVisible') ? localState.maskVisible : true;
      var parentVisible = parent ? parent.visible : true;
      child.visible = parentVisible && localState.visible && maskVisible;
      return this;
    },
    syncVisible: function syncVisible() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildVisible, this);
      }
      return this;
    },
    resetChildVisibleState: function resetChildVisibleState(child) {
      var localState = GetLocalState(child);
      // Delete maskVisible property
      if (localState.hasOwnProperty('maskVisible')) {
        delete localState.maskVisible;
      }
      localState.visible = child.visible;
      return this;
    },
    setChildVisible: function setChildVisible(child, visible) {
      // Visible of child will be affect by parent's visible, and mask visible
      this.setChildLocalVisible(child, visible);
      return this;
    },
    // Internal method
    setChildLocalVisible: function setChildLocalVisible(child, visible) {
      if (visible === undefined) {
        visible = true;
      }
      var localState = GetLocalState(child);
      localState.visible = visible;
      this.updateChildVisible(child);
      return this;
    },
    // Internal method
    setChildMaskVisible: function setChildMaskVisible(child, visible) {
      if (visible === undefined) {
        visible = true;
      }
      var localState = GetLocalState(child);
      localState.maskVisible = visible;
      this.updateChildVisible(child);
      return this;
    },
    resetLocalVisibleState: function resetLocalVisibleState() {
      var parent = GetLocalState(this).parent;
      if (parent) {
        parent.resetChildVisibleState(this);
      }
      return this;
    }
  };

  var Alpha = {
    updateChildAlpha: function updateChildAlpha(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      if (state.syncAlpha) {
        child.alpha = parent.alpha * state.alpha;
      }
      return this;
    },
    syncAlpha: function syncAlpha() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildAlpha, this);
      }
      return this;
    },
    resetChildAlphaState: function resetChildAlphaState(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      state.alpha = GetScale(child.alpha, parent.alpha);
      return this;
    },
    setChildAlpha: function setChildAlpha(child, alpha) {
      child.alpha = alpha;
      this.resetChildAlphaState(child);
      return this;
    },
    setChildLocalAlpha: function setChildLocalAlpha(child, alpha) {
      var state = GetLocalState(child);
      state.alpha = alpha;
      this.updateChildAlpha(child);
      return this;
    },
    resetLocalAlphaState: function resetLocalAlphaState() {
      var parent = GetLocalState(this).parent;
      if (parent) {
        parent.resetChildAlphaState(this);
      }
      return this;
    }
  };

  var Active = {
    updateChildActive: function updateChildActive(child) {
      var localState = GetLocalState(child);
      var parent = localState.parent;
      child.active = parent.active && localState.active;
      return this;
    },
    syncActive: function syncActive() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildActive, this);
      }
      return this;
    },
    resetChildActiveState: function resetChildActiveState(child) {
      var localState = GetLocalState(child);
      localState.active = child.active;
      return this;
    },
    setChildActive: function setChildActive(child, active) {
      child.active = active;
      this.resetChildActiveState(child);
      return this;
    },
    setChildLocalActive: function setChildLocalActive(child, active) {
      if (active === undefined) {
        active = true;
      }
      var localState = GetLocalState(child);
      localState.active = active;
      this.updateChildActive(child);
      return this;
    },
    resetLocalActiveState: function resetLocalActiveState() {
      var parent = GetLocalState(this).parent;
      if (parent) {
        parent.resetChildActiveState(this);
      }
      return this;
    }
  };

  var ScrollFactor = {
    updateChildScrollFactor: function updateChildScrollFactor(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      if (state.syncScrollFactor) {
        child.scrollFactorX = parent.scrollFactorX;
        child.scrollFactorY = parent.scrollFactorY;
      }
      return this;
    },
    syncScrollFactor: function syncScrollFactor() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildScrollFactor, this);
      }
      return this;
    }
  };

  var CameraFilter = {
    updateCameraFilter: function updateCameraFilter(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      if (state.syncCameraFilter) {
        child.cameraFilter = parent.cameraFilter;
      }
      return this;
    },
    syncCameraFilter: function syncCameraFilter() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateCameraFilter, this);
      }
      return this;
    }
  };

  var Mask = {
    updateChildMask: function updateChildMask(child) {
      // Don't propagate null mask to clear children's mask
      if (this.mask == null) {
        return this;
      }
      var maskGameObject = this.mask.hasOwnProperty('geometryMask') ? this.mask.geometryMask : this.mask.bitmapMask;
      if (maskGameObject !== child) {
        child.mask = this.mask;
      }
      return this;
    },
    syncMask: function syncMask() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildMask, this);
      }
      return this;
    },
    setMask: function setMask(mask) {
      this.mask = mask;
      return this;
    },
    clearMask: function clearMask(destroyMask) {
      if (destroyMask === undefined) {
        destroyMask = false;
      }
      var self = this;

      // Clear current mask
      this._mask = null;
      this.setChildMaskVisible(this);
      // Also set maskVisible to `true`

      this.children.forEach(function (child) {
        // Clear child's mask
        if (child.clearMask) {
          child.clearMask(false);
        }
        if (!child.hasOwnProperty('isRexContainerLite')) {
          self.setChildMaskVisible(child);
          // Set child's maskVisible to `true`
        }
      });
      if (destroyMask && this.mask) {
        this.mask.destroy();
      }
      return this;
    }
  };

  var FilterDisplayGameObjects = function FilterDisplayGameObjects(gameObjects) {
    return gameObjects.filter(function (gameObject) {
      if (gameObject.displayList) {
        // Inside a scene or a layer
        return true;
      } else if (gameObject.parentContainer) {
        // Inside a container
        return true;
      }
    });
  };

  var Depth = {
    setDepth: function setDepth(value, containerOnly) {
      this.depth = value;
      if (!containerOnly && this.children) {
        var children = this.getAllChildren();
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          children[i].depth = value;
        }
      }
      return this;
    },
    swapDepth: function swapDepth(containerB) {
      var depthA = this.depth;
      var depthB = containerB.depth;
      this.setDepth(depthB);
      containerB.setDepth(depthA);
      return this;
    },
    incDepth: function incDepth(inc) {
      this.depth += inc;
      if (this.children) {
        var children = this.getAllChildren();
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          children[i].depth += inc;
        }
      }
      return this;
    },
    bringToTop: function bringToTop() {
      var displayList = this.displayList;
      if (!displayList) {
        return this;
      }
      var children = this.getAllChildren([this]);
      SortGameObjectsByDepth(children, false);
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (displayList.exists(child)) {
          displayList.bringToTop(child);
        }
      }
      return this;
    },
    bringMeToTop: function bringMeToTop() {
      return this.bringToTop();
    },
    sendToBack: function sendToBack() {
      var displayList = this.displayList;
      if (!displayList) {
        return this;
      }
      var children = this.getAllChildren([this]);
      SortGameObjectsByDepth(children, true);
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (displayList.exists(child)) {
          displayList.sendToBack(child);
        }
      }
      return this;
    },
    sendMeToBack: function sendMeToBack() {
      return this.sendToBack();
    },
    moveDepthBelow: function moveDepthBelow(gameObject) {
      var displayList = this.displayList;
      if (!displayList) {
        return this;
      }
      if (gameObject.displayList !== displayList) {
        // Do nothing if not at the same display list
        return this;
      }
      var children = this.getAllChildren([this]);
      SortGameObjectsByDepth(children, false);
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (displayList.exists(child)) {
          displayList.moveBelow(gameObject, child);
          break;
        }
      }
      return this;
    },
    moveMyDepthBelow: function moveMyDepthBelow(gameObject) {
      return this.moveDepthBelow(gameObject);
    },
    moveDepthAbove: function moveDepthAbove(gameObject) {
      var displayList = this.displayList;
      if (!displayList) {
        return this;
      }
      if (gameObject.displayList !== displayList) {
        // Do nothing if not at the same display list
        return this;
      }
      var children = this.getAllChildren([this]);
      SortGameObjectsByDepth(children, true);
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (displayList.exists(child)) {
          displayList.moveAbove(gameObject, child);
          break;
        }
      }
      return this;
    },
    moveMyDepthAbove: function moveMyDepthAbove(gameObject) {
      return this.moveDepthAbove(gameObject);
    },
    bringChildToTop: function bringChildToTop(child) {
      var gameObjects;
      if (child.isRexContainerLite) {
        gameObjects = child.getAllChildren([child]);
        gameObjects = FilterDisplayGameObjects(gameObjects);
        gameObjects = SortGameObjectsByDepth(gameObjects, false);
      } else {
        gameObjects = [child];
      }
      var children = this.getAllChildren([this]);
      children = FilterDisplayGameObjects(children);
      children = SortGameObjectsByDepth(children, false);
      var topChild = children[children.length - 1];
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        var gameObject = gameObjects[i];
        if (topChild === gameObject || topChild.displayList !== gameObject.displayList) {
          continue;
        }
        topChild.displayList.moveAbove(gameObject, topChild);
        topChild = gameObject;
      }
      return this;
    },
    sendChildToBack: function sendChildToBack(child) {
      var gameObjects;
      if (child.isRexContainerLite) {
        gameObjects = child.getAllChildren([child]);
        gameObjects = FilterDisplayGameObjects(gameObjects);
        gameObjects = SortGameObjectsByDepth(gameObjects, false);
      } else {
        gameObjects = [child];
      }
      var children = this.getAllChildren([this]);
      children = FilterDisplayGameObjects(children);
      children = SortGameObjectsByDepth(children, false);
      var bottomChild = children[0];
      for (var i = gameObjects.length - 1; i >= 0; i--) {
        var gameObject = gameObjects[i];
        if (bottomChild === gameObject || bottomChild.displayList !== gameObject.displayList) {
          continue;
        }
        bottomChild.displayList.moveBelow(gameObject, bottomChild);
        bottomChild = gameObject;
      }
      return this;
    }
  };

  var DepthFirstSearch = function DepthFirstSearch(root, callback) {
    var skip = callback(root);
    if (!skip && root.isRexContainerLite) {
      var children = root.children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        DepthFirstSearch(children[i], callback);
      }
    }
  };
  var BreadthFirstSearch = function BreadthFirstSearch(root, callback) {
    var queue = [root];
    while (queue.length > 0) {
      var current = queue.shift();
      var skip = callback(current);
      if (!skip && current.isRexContainerLite) {
        queue.push.apply(queue, _toConsumableArray(current.children));
      }
    }
  };

  var ArrayUtils = Phaser.Utils.Array;
  var Children = {
    getChildren: function getChildren(out) {
      if (!out) {
        out = this.children; // Return internal children array
      } else {
        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
          out.push(this.children[i]);
        }
        // Copy children
      }
      return out;
    },
    getAllChildren: function getAllChildren(out) {
      if (out === undefined) {
        out = [];
      }
      var root = this;
      BreadthFirstSearch(root, function (child) {
        // Don't add root
        if (child === root) {
          return;
        }
        out.push(child);
      });
      return out;
    },
    getAllVisibleChildren: function getAllVisibleChildren(out) {
      if (out === undefined) {
        out = [];
      }
      var root = this;
      BreadthFirstSearch(root, function (child) {
        // Don't add root
        if (child === root) {
          return;
        }
        // Don't add invisible child
        if (!child.visible) {
          return true;
        }
        out.push(child);
      });
      return out;
    },
    bfs: function bfs(callback, root) {
      if (root === undefined) {
        root = this;
      }
      BreadthFirstSearch(root, callback);
      return this;
    },
    dfs: function dfs(callback, root) {
      if (root === undefined) {
        root = this;
      }
      DepthFirstSearch(root, callback);
      return this;
    },
    contains: function contains(gameObject) {
      // Override Base.contains method
      var parent = GetParent$1(gameObject);
      if (!parent) {
        return false;
      } else if (parent === this) {
        return true;
      } else {
        return this.contains(parent);
      }
    },
    getByName: function getByName(name, recursive) {
      if (!recursive) {
        return ArrayUtils.GetFirst(this.children, 'name', name); // object, or null if not found
      } else {
        // recursive
        // Breadth-first search
        var queue = [this];
        var parent, child;
        while (queue.length) {
          parent = queue.shift();
          for (var i = 0, cnt = parent.children.length; i < cnt; i++) {
            child = parent.children[i];
            if (child.name === name) {
              return child;
            } else if (child.isRexContainerLite) {
              queue.push(child);
            }
          }
        }
        return null;
      }
    },
    getRandom: function getRandom(startIndex, length) {
      return ArrayUtils.GetRandom(this.children, startIndex, length);
    },
    getFirst: function getFirst(property, value, startIndex, endIndex) {
      return ArrayUtils.GetFirstElement(this.children, property, value, startIndex, endIndex);
    },
    getAll: function getAll(property, value, startIndex, endIndex) {
      return ArrayUtils.GetAll(this.children, property, value, startIndex, endIndex);
    },
    count: function count(property, value, startIndex, endIndex) {
      return ArrayUtils.CountAllMatching(this.children, property, value, startIndex, endIndex);
    },
    swap: function swap(child1, child2) {
      ArrayUtils.Swap(this.children, child1, child2);
      return this;
    },
    setAll: function setAll(property, value, startIndex, endIndex) {
      ArrayUtils.SetAll(this.children, property, value, startIndex, endIndex);
      return this;
    }
  };

  var GetLocalStates = function GetLocalStates(gameObjects) {
    var localStates = [];
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var gameObject = gameObjects[i];
      if (!gameObject.hasOwnProperty('rexContainer')) {
        continue;
      }
      localStates.push(gameObject.rexContainer);
    }
    return localStates;
  };
  var GetScene = function GetScene(gameObjects) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var scene = gameObjects[i].scene;
      if (scene) {
        return scene;
      }
    }
    return null;
  };
  var UpdateChild = function UpdateChild(tween, key, target) {
    if (!target.parent) {
      // target object was removed, so remove this tween too
      tween.remove();
      return;
    }
    var parent = target.parent;
    var child = target.self;
    switch (key) {
      case 'x':
      case 'y':
        parent.updateChildPosition(child);
        break;
      case 'angle':
      case 'rotation':
        parent.updateChildRotation(child);
        break;
      case 'scaleX':
      case 'scaleY':
      case 'displayWidth':
      case 'displayHeight':
        parent.updateChildScale(child);
        break;
      case 'alpha':
        parent.updateChildAlpha(child);
        break;
      default:
        parent.updateChildPosition(child);
        parent.updateChildRotation(child);
        parent.updateChildScale(child);
        parent.updateChildAlpha(child);
        break;
    }
  };
  var Tween = {
    tweenChild: function tweenChild(tweenConfig) {
      var targets = tweenConfig.targets;
      if (!Array.isArray(targets)) {
        targets = [targets];
      }
      var scene = this.scene || GetScene(targets);
      if (!scene) {
        return;
      }

      // Map child game objects to local states
      tweenConfig.targets = GetLocalStates(targets);
      var tween = scene.tweens.add(tweenConfig);

      // Update child game object in 'update' event
      tween.on('update', UpdateChild);
      return tween;
    },
    tweenSelf: function tweenSelf(tweenConfig) {
      tweenConfig.targets = [this];
      return this.tweenChild(tweenConfig);
    },
    createTweenChildConfig: function createTweenChildConfig(tweenConfig) {
      var targets = tweenConfig.targets;
      if (targets) {
        if (!Array.isArray(targets)) {
          targets = [targets];
        }
        // Map child game objects to local states
        tweenConfig.targets = GetLocalStates(targets);
      }
      var onUpdate = tweenConfig.onUpdate;
      tweenConfig.onUpdate = function (tween, target) {
        if (onUpdate) {
          onUpdate(tween, target);
        }
        UpdateChild(tween, undefined, target);
      };
      return tweenConfig;
    },
    tween: function tween(tweenConfig) {
      var scene = this.scene;
      if (!tweenConfig.targets) {
        tweenConfig.targets = this;
      }
      return scene.tweens.add(tweenConfig);
    }
  };

  var ContainerClass = Phaser.GameObjects.Container;
  var IsContainerGameObject = function IsContainerGameObject(gameObject) {
    return gameObject instanceof ContainerClass;
  };

  var LayerClass = Phaser.GameObjects.Layer;
  var IsLayerGameObject = function IsLayerGameObject(gameObject) {
    return gameObject instanceof LayerClass;
  };

  var GetValidChildren = function GetValidChildren(parent) {
    var children = parent.getAllChildren([parent]);
    children = children.filter(function (gameObject) {
      return !!gameObject.displayList ||
      // At scene's displayList or at a layer
      !!gameObject.parentContainer; // At a container
    });
    return children;
  };
  var AddToContainer = function AddToContainer(p3Container) {
    var gameObjects = GetValidChildren(this);
    // This containerLite parent should be considered.
    if (gameObjects.indexOf(this) === -1) {
      gameObjects.push(this);
    }
    SortGameObjectsByDepth(gameObjects);
    p3Container.add(gameObjects);
  };
  var RemoveFromContainer = function RemoveFromContainer(p3Container, descending, addToScene) {
    if (!this.scene) {
      // Destroyed
      return;
    }
    var gameObjects = GetValidChildren(this);
    SortGameObjectsByDepth(gameObjects, descending);
    p3Container.remove(gameObjects);
    if (addToScene) {
      gameObjects.forEach(function (gameObject) {
        gameObject.addToDisplayList();
      });
    }
  };
  var P3Container = {
    addToContainer: function addToContainer(p3Container) {
      if (!IsContainerGameObject(p3Container)) {
        return this;
      }
      this._setParentContainerFlag = true;
      AddToContainer.call(this, p3Container);
      this._setParentContainerFlag = false;
      return this;
    },
    addToLayer: function addToLayer(layer) {
      if (!IsLayerGameObject(layer)) {
        return this;
      }
      AddToContainer.call(this, layer);
      return this;
    },
    removeFromContainer: function removeFromContainer() {
      if (!this.parentContainer) {
        return this;
      }
      this._setParentContainerFlag = true;
      RemoveFromContainer.call(this, this.parentContainer, true, false);
      this._setParentContainerFlag = false;
      return this;
    },
    removeFromLayer: function removeFromLayer(addToScene) {
      if (addToScene === undefined) {
        addToScene = true;
      }
      if (!IsLayerGameObject(this.displayList)) {
        return this;
      }
      RemoveFromContainer.call(this, this.displayList, false, addToScene);
      return this;
    },
    getParentContainer: function getParentContainer() {
      if (this.parentContainer) {
        return this.parentContainer;
      }

      // One of parent container has a layer
      var parent = this.getParent();
      while (parent) {
        var p3Container = parent.parentContainer;
        if (p3Container) {
          return p3Container;
        }
        parent = parent.getParent();
      }
      return null;
    },
    addToParentContainer: function addToParentContainer(gameObject) {
      // Do nothing if gameObject is not in any displayList
      if (!gameObject.displayList) {
        return this;
      }
      var p3Container = this.getParentContainer();
      if (!p3Container) {
        return this;
      }
      if (gameObject.isRexContainerLite) {
        // Add containerLite and its children
        gameObject.addToContainer(p3Container);
      } else {
        // Add gameObject directly
        p3Container.add(gameObject);
      }
      return this;
    },
    addToPatentLayer: function addToPatentLayer(gameObject) {
      // Do nothing if gameObject is not in any displayList
      if (!gameObject.displayList) {
        return this;
      }

      // At the same display list
      var parentLayer = this.displayList;
      if (parentLayer === gameObject.displayList) {
        return this;
      }
      if (IsLayerGameObject(parentLayer)) {
        if (gameObject.isRexContainerLite) {
          // Add containerLite and its children
          gameObject.addToLayer(parentLayer);
        } else {
          // Add gameObject directly
          parentLayer.add(gameObject);
        }
      }
      return this;
    }
  };

  var RenderLayer = {
    hasLayer: function hasLayer() {
      return !!this.privateRenderLayer;
    },
    enableLayer: function enableLayer() {
      if (this.hasLayer()) {
        return this;
      }
      var layer = this.scene.add.layer();
      // layer.name = (this.name) ? `${this.name}.privateLayer` : 'privateLayer';

      this.moveDepthBelow(layer);
      this.addToLayer(layer);
      this.privateRenderLayer = layer;
      return this;
    },
    getLayer: function getLayer() {
      if (!this.hasLayer()) {
        this.enableLayer();
      }
      return this.privateRenderLayer;
    },
    getRenderLayer: function getRenderLayer() {
      // This containerLite has a layer
      if (this.hasLayer()) {
        return this.privateRenderLayer;
      }

      // One of parent container has a layer
      var parent = this.getParent();
      while (parent) {
        var layer = parent.privateRenderLayer;
        if (layer) {
          return layer;
        }
        parent = parent.getParent();
      }
      return null;
    },
    // Internal method for adding child
    addToRenderLayer: function addToRenderLayer(gameObject) {
      // Don't add to layer if gameObject is not in any displayList
      if (!gameObject.displayList) {
        return this;
      }

      // Move gameObject from scene to layer
      var layer = this.getRenderLayer();
      if (!layer) {
        return this;
      }
      if (layer === gameObject.displayList) {
        return this;
      }
      if (gameObject.isRexContainerLite) {
        // Add containerLite and its children
        gameObject.addToLayer(layer);
      } else {
        // Add gameObject directly
        layer.add(gameObject);
      }
      var state = GetLocalState(gameObject);
      state.layer = layer;
      return this;
    },
    // Internal method for removing child
    removeFromRenderLayer: function removeFromRenderLayer(gameObject) {
      // Move gameObject from layer to scene
      var state = GetLocalState(gameObject);
      var layer = state.layer;
      if (!layer) {
        return this;
      }
      if (gameObject.isRexContainerLite) {
        // Remove containerLite and its children
        gameObject.removeFromLayer(true);
      } else {
        // Remove gameObject directly
        layer.remove(gameObject);
      }
      state.layer = null;
      return this;
    }
  };

  var Rectangle$1 = Phaser.Geom.Rectangle;
  var Union = Phaser.Geom.Rectangle.Union;
  var GetBoundsOfGameObjects = function GetBoundsOfGameObjects(gameObjects, out) {
    if (out === undefined) {
      out = new Rectangle$1();
    } else if (out === true) {
      if (GlobRect$1 === undefined) {
        GlobRect$1 = new Rectangle$1();
      }
      out = GlobRect$1;
    }
    out.setTo(0, 0, 0, 0);
    var gameObject;
    var firstClone = true;
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      gameObject = gameObjects[i];
      if (!gameObject.getBounds) {
        continue;
      }
      var boundsRect = GetBounds(gameObject, true);
      if (firstClone) {
        out.setTo(boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
        firstClone = false;
      } else {
        Union(boundsRect, out, out);
      }
    }
    return out;
  };
  var GlobRect$1;

  var GameObjectClass = Phaser.GameObjects.GameObject;
  var IsGameObject = function IsGameObject(object) {
    return object instanceof GameObjectClass;
  };

  var GetValue$2s = Phaser.Utils.Objects.GetValue;
  var Snapshot = function Snapshot(config) {
    if (!config) {
      return;
    }
    var gameObjects = config.gameObjects;
    var renderTexture = config.renderTexture; // renderTexture, or dynamicTexture
    var saveTexture = config.saveTexture;
    var x = GetValue$2s(config, 'x', undefined);
    var y = GetValue$2s(config, 'y', undefined);
    var width = GetValue$2s(config, 'width', undefined);
    var height = GetValue$2s(config, 'height', undefined);
    var originX = GetValue$2s(config, 'originX', 0);
    var originY = GetValue$2s(config, 'originY', 0);
    var padding = GetValue$2s(config, 'padding', 0);
    var scrollX, scrollY;
    if (width === undefined || height === undefined || x === undefined || y === undefined) {
      // Union bounds of gameObjects
      var bounds = GetBoundsOfGameObjects(gameObjects, true);
      var isCenterOrigin = x !== undefined && y !== undefined;
      if (isCenterOrigin) {
        width = Math.max(x - bounds.left, bounds.right - x) * 2;
        height = Math.max(y - bounds.top, bounds.bottom - y) * 2;
        originX = 0.5;
        originY = 0.5;
      } else {
        x = bounds.x;
        y = bounds.y;
        width = bounds.width;
        height = bounds.height;
        originX = 0;
        originY = 0;
      }
      scrollX = bounds.x;
      scrollY = bounds.y;
    } else {
      scrollX = x + (0 - originX) * width;
      scrollY = y + (0 - originY) * height;
    }
    scrollX -= padding;
    scrollY -= padding;
    width += padding * 2;
    height += padding * 2;
    var scene = gameObjects[0].scene;
    var textureManager = scene.sys.textures;

    // Snapshot on dynamicTexture directly
    if (saveTexture && !renderTexture) {
      renderTexture = textureManager.addDynamicTexture(saveTexture, width, height);
    }

    // Return a renderTexture
    if (!renderTexture) {
      renderTexture = scene.add.renderTexture(0, 0, width, height);
    }
    if (renderTexture.setPosition) {
      renderTexture.setPosition(x, y);
    }
    if (renderTexture.width !== width || renderTexture.height !== height) {
      renderTexture.setSize(width, height);
    }
    if (renderTexture.setOrigin) {
      renderTexture.setOrigin(originX, originY);
    }
    renderTexture.camera.setScroll(scrollX, scrollY);

    // Draw gameObjects
    gameObjects = SortGameObjectsByDepth(Clone$2(gameObjects));
    renderTexture.draw(gameObjects);

    // Save render result to texture
    if (saveTexture) {
      if (IsGameObject(renderTexture)) {
        renderTexture.saveTexture(saveTexture);
      } else if (renderTexture.key !== saveTexture) {
        textureManager.renameTexture(renderTexture.key, key);
      }
    }
    return renderTexture;
  };

  var RenderTexture$1 = {
    snapshot: function snapshot(config) {
      // Save scale
      var scaleXSave = this.scaleX;
      var scaleYSave = this.scaleY;
      var scale1 = scaleXSave === 1 && scaleYSave === 1;
      if (!scale1) {
        this.setScale(1);
      }

      // Snapshot with scale = 1
      if (config === undefined) {
        config = {};
      }
      config.gameObjects = this.getAllVisibleChildren();
      config.x = this.x;
      config.y = this.y;
      config.originX = this.originX;
      config.originY = this.originY;
      var rt = Snapshot(config);
      var isValidRT = !!rt.scene;

      // Restore scale
      if (!scale1) {
        this.setScale(scaleXSave, scaleYSave);
        if (isValidRT) {
          rt.setScale(scaleXSave, scaleYSave);
        }
      }
      return isValidRT ? rt : this;
    }
  };

  var GetValue$2r = Phaser.Utils.Objects.GetValue;
  var DrawBounds$1 = function DrawBounds(graphics, config) {
    var drawContainer = GetValue$2r(config, 'drawContainer', true);
    var gameObjects = GetValue$2r(config, 'children');
    if (gameObjects === undefined) {
      gameObjects = this.getAllVisibleChildren([this]);
    }
    if (!drawContainer) {
      gameObjects = gameObjects.filter(function (gameObject) {
        return !gameObject.isRexContainerLite;
      });
    }
    DrawBounds$2(gameObjects, graphics, config);
    return this;
  };

  var RotateAround$3 = Phaser.Math.RotateAround;
  var ChangeOrigin$1 = function ChangeOrigin(gameObject, originX, originY) {
    if (originY === undefined) {
      originY = originX;
    }
    var deltaXY = {
      x: (originX - gameObject.originX) * gameObject.displayWidth,
      y: (originY - gameObject.originY) * gameObject.displayHeight
    };
    RotateAround$3(deltaXY, 0, 0, gameObject.rotation);
    gameObject.originX = originX;
    gameObject.originY = originY;
    gameObject.x = gameObject.x + deltaXY.x;
    gameObject.y = gameObject.y + deltaXY.y;
    return gameObject;
  };

  var ChangeOrigin = function ChangeOrigin(originX, originY) {
    this.syncChildrenEnable = false;
    ChangeOrigin$1(this, originX, originY);
    this.syncChildrenEnable = true;
    var children = this.getAllChildren();
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      this.resetChildPositionState(children[i]);
    }
    return this;
  };

  var methods$u = {
    changeOrigin: ChangeOrigin,
    drawBounds: DrawBounds$1
  };
  Object.assign(methods$u, Parent, AddChild$2, RemoveChild$1, ChildState, Transform, Position, Rotation, Scale$1, Visible$1, Alpha, Active, ScrollFactor, CameraFilter, Mask, Depth, Children, Tween, P3Container, RenderLayer, RenderTexture$1);

  var ContainerLite = /*#__PURE__*/function (_Base) {
    _inherits(ContainerLite, _Base);
    function ContainerLite(scene, x, y, width, height, children) {
      var _this;
      _classCallCheck(this, ContainerLite);
      if (Array.isArray(width)) {
        children = width;
        width = undefined;
        height = undefined;
      }
      _this = _callSuper(this, ContainerLite, [scene, x, y, width, height]);
      _this.type = 'rexContainerLite';
      _this.isRexContainerLite = true;
      _this.syncChildrenEnable = true;
      _this._active = true;
      _this._mask = null;
      _this._scrollFactorX = 1;
      _this._scrollFactorY = 1;
      _this._cameraFilter = 0;
      _this.privateRenderLayer = undefined;
      if (children) {
        _this.add(children);
      }
      return _this;
    }
    _createClass(ContainerLite, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.syncChildrenEnable = false; // Don't sync properties changing anymore
        _get(_getPrototypeOf(ContainerLite.prototype), "destroy", this).call(this, fromScene);
        if (this.privateRenderLayer) {
          this.privateRenderLayer.list.length = 0; // Remove all children without trigger callback
          this.privateRenderLayer.destroy();
        }
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this.setSize(width, height);
        return this;
      }
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        if (this._x === value) {
          return;
        }
        this._x = value;
        this.syncPosition();
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        if (this._y === value) {
          return;
        }
        this._y = value;
        this.syncPosition();
      }

      // Override
    }, {
      key: "rotation",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "rotation", this);
      },
      set: function set(value) {
        if (this.rotation === value) {
          return;
        }
        _set(_getPrototypeOf(ContainerLite.prototype), "rotation", value, this, true);
        this.syncPosition();
      }

      // Override
    }, {
      key: "scaleX",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "scaleX", this);
      },
      set: function set(value) {
        if (this.scaleX === value) {
          return;
        }
        _set(_getPrototypeOf(ContainerLite.prototype), "scaleX", value, this, true);
        this.syncPosition();
      }

      // Override
    }, {
      key: "scaleY",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "scaleY", this);
      },
      set: function set(value) {
        if (this.scaleY === value) {
          return;
        }
        _set(_getPrototypeOf(ContainerLite.prototype), "scaleY", value, this, true);
        this.syncPosition();
      }

      // Override
    }, {
      key: "scale",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "scale", this);
      },
      set: function set(value) {
        if (this.scale === value) {
          return;
        }
        _set(_getPrototypeOf(ContainerLite.prototype), "scale", value, this, true);
        this.syncPosition();
      }

      // Override
    }, {
      key: "visible",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "visible", this);
      },
      set: function set(value) {
        if (_get(_getPrototypeOf(ContainerLite.prototype), "visible", this) === value) {
          return;
        }
        _set(_getPrototypeOf(ContainerLite.prototype), "visible", value, this, true);
        this.syncVisible();
      }

      // Override
    }, {
      key: "alpha",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "alpha", this);
      },
      set: function set(value) {
        if (_get(_getPrototypeOf(ContainerLite.prototype), "alpha", this) === value) {
          return;
        }
        _set(_getPrototypeOf(ContainerLite.prototype), "alpha", value, this, true);
        this.syncAlpha();
      }

      // Override
    }, {
      key: "active",
      get: function get() {
        return this._active;
      },
      set: function set(value) {
        if (this._active === value) {
          return;
        }
        this._active = value;
        this.syncActive();
      }

      // Override
    }, {
      key: "mask",
      get: function get() {
        return this._mask;
      },
      set: function set(mask) {
        if (this._mask === mask) {
          return;
        }
        this._mask = mask;
        this.syncMask();
      }

      // Override
    }, {
      key: "scrollFactorX",
      get: function get() {
        return this._scrollFactorX;
      },
      set: function set(value) {
        if (this._scrollFactorX === value) {
          return;
        }
        this._scrollFactorX = value;
        this.syncScrollFactor();
      }
    }, {
      key: "scrollFactorY",
      get: function get() {
        return this._scrollFactorY;
      },
      set: function set(value) {
        if (this._scrollFactorY === value) {
          return;
        }
        this._scrollFactorY = value;
        this.syncScrollFactor();
      }
    }, {
      key: "cameraFilter",
      get: function get() {
        return this._cameraFilter;
      },
      set: function set(value) {
        if (this._cameraFilter === value) {
          return;
        }
        this._cameraFilter = value;
        this.syncCameraFilter();
      }

      // Compatiable with container plugin
    }, {
      key: "list",
      get: function get() {
        return this.children;
      }
    }, {
      key: "parentContainer",
      get:
      // For p3-container
      function get() {
        return this._parentContainer;
      },
      set: function set(value) {
        // Initialize
        if (!this._parentContainer && !value) {
          this._parentContainer = value;
          return;
        }

        // Set this._parentContainer only,
        // if under AddToContainer, or RemoveFromContainer methods
        if (this.setParentContainerFlag) {
          this._parentContainer = value;
          return;
        }
        // else if (!this.setParentContainerFlag)

        // Add itself and all children to container,
        // Or remove itseld and all children from container
        if (this._parentContainer && !value) {
          // Remove from container
          this.removeFromContainer();
          this._parentContainer = value;
        } else if (value) {
          // Add to container
          this._parentContainer = value;
          this.addToContainer(value);
        } else {
          this._parentContainer = value;
        }
      }
    }, {
      key: "setParentContainerFlag",
      get: function get() {
        if (this._setParentContainerFlag) {
          return true;
        }
        var parent = GetParent$1(this);
        return parent ? parent.setParentContainerFlag : false;
      }
    }], [{
      key: "GetParent",
      value: function GetParent(child) {
        return GetParent$1(child);
      }
    }]);
    return ContainerLite;
  }(Base$1);
  Object.assign(ContainerLite.prototype, methods$u);

  var GetSizerConfig$1 = function GetSizerConfig(gameObject) {
    if (!gameObject.hasOwnProperty('rexSizer')) {
      gameObject.rexSizer = {};
    }
    return gameObject.rexSizer;
  };

  function GetSizerConfig (gameObject) {
    if (gameObject === undefined) {
      gameObject = this;
    }
    return GetSizerConfig$1(gameObject);
  }

  var GetChildPrevState = function GetChildPrevState(child) {
    var childConfig = GetSizerConfig$1(child);
    if (!childConfig.hasOwnProperty('prevState')) {
      childConfig.prevState = {};
    }
    return childConfig.prevState;
  };

  var PushIntoBounds = function PushIntoBounds(bounds) {
    if (bounds === undefined) {
      bounds = GetViewport(this.scene);
    }
    this.left = Math.max(this.left, bounds.left);
    this.right = Math.min(this.right, bounds.right);
    this.top = Math.max(this.top, bounds.top);
    this.bottom = Math.min(this.bottom, bounds.bottom);
    return this;
  };

  var ALIGN$1 = Phaser.Display.Align;
  var AlignConst = {
    center: ALIGN$1.CENTER,
    left: ALIGN$1.LEFT_CENTER,
    right: ALIGN$1.RIGHT_CENTER,
    top: ALIGN$1.TOP_CENTER,
    bottom: ALIGN$1.BOTTOM_CENTER,
    'left-top': ALIGN$1.TOP_LEFT,
    'top-left': ALIGN$1.TOP_LEFT,
    'left-center': ALIGN$1.LEFT_CENTER,
    'center-left': ALIGN$1.LEFT_CENTER,
    'left-bottom': ALIGN$1.BOTTOM_LEFT,
    'bottom-left': ALIGN$1.BOTTOM_LEFT,
    'center-top': ALIGN$1.TOP_CENTER,
    'top-center': ALIGN$1.TOP_CENTER,
    'center-center': ALIGN$1.CENTER,
    'center-bottom': ALIGN$1.BOTTOM_CENTER,
    'bottom-center': ALIGN$1.BOTTOM_CENTER,
    'right-top': ALIGN$1.TOP_RIGHT,
    'top-right': ALIGN$1.TOP_RIGHT,
    'right-center': ALIGN$1.RIGHT_CENTER,
    'center-right': ALIGN$1.RIGHT_CENTER,
    'right-bottom': ALIGN$1.BOTTOM_RIGHT,
    'bottom-right': ALIGN$1.BOTTOM_RIGHT
  };

  var globZone = new Phaser.GameObjects.Zone({
    sys: {
      queueDepthSort: NOOP,
      events: {
        once: NOOP
      }
    }
  }, 0, 0, 1, 1);
  globZone.setOrigin(0);

  var ALIGN_CONST = {
    /**
    * A constant representing a top-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_LEFT
    * @since 3.0.0
    * @type {integer}
    */
    TOP_LEFT: 0,
    /**
    * A constant representing a top-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    TOP_CENTER: 1,
    /**
    * A constant representing a top-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_RIGHT
    * @since 3.0.0
    * @type {integer}
    */
    TOP_RIGHT: 2,
    /**
    * A constant representing a left-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_TOP
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_TOP: 3,
    /**
    * A constant representing a left-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_CENTER: 4,
    /**
    * A constant representing a left-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_BOTTOM: 5,
    /**
    * A constant representing a center alignment or position.
    * @constant
    * @name Phaser.Display.Align.CENTER
    * @since 3.0.0
    * @type {integer}
    */
    CENTER: 6,
    /**
    * A constant representing a right-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_TOP
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_TOP: 7,
    /**
    * A constant representing a right-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_CENTER: 8,
    /**
    * A constant representing a right-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_BOTTOM: 9,
    /**
    * A constant representing a bottom-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_LEFT
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_LEFT: 10,
    /**
    * A constant representing a bottom-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_CENTER: 11,
    /**
    * A constant representing a bottom-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_RIGHT
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_RIGHT: 12
  };

  var GetBottom = function GetBottom(gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y + height - height * gameObject.originY;
  };

  var GetCenterX = function GetCenterX(gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x - width * gameObject.originX + width * 0.5;
  };

  var SetBottom = function SetBottom(gameObject, value) {
    var height = GetDisplayHeight(gameObject);
    gameObject.y = value - height + height * gameObject.originY;
    return gameObject;
  };

  var SetCenterX = function SetCenterX(gameObject, x) {
    var width = GetDisplayWidth(gameObject);
    var offsetX = width * gameObject.originX;
    gameObject.x = x + offsetX - width * 0.5;
    return gameObject;
  };

  var BottomCenter = function BottomCenter(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };

  var GetLeft = function GetLeft(gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x - width * gameObject.originX;
  };

  var SetLeft = function SetLeft(gameObject, value) {
    var width = GetDisplayWidth(gameObject);
    gameObject.x = value + width * gameObject.originX;
    return gameObject;
  };

  var BottomLeft = function BottomLeft(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };

  var GetRight = function GetRight(gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x + width - width * gameObject.originX;
  };

  var SetRight = function SetRight(gameObject, value) {
    var width = GetDisplayWidth(gameObject);
    gameObject.x = value - width + width * gameObject.originX;
    return gameObject;
  };

  var BottomRight = function BottomRight(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };

  var SetCenterY = function SetCenterY(gameObject, y) {
    var height = GetDisplayHeight(gameObject);
    var offsetY = height * gameObject.originY;
    gameObject.y = y + offsetY - height * 0.5;
    return gameObject;
  };

  var CenterOn = function CenterOn(gameObject, x, y) {
    SetCenterX(gameObject, x);
    return SetCenterY(gameObject, y);
  };

  var GetCenterY = function GetCenterY(gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y - height * gameObject.originY + height * 0.5;
  };

  var Center = function Center(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };

  var LeftCenter = function LeftCenter(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };

  var RightCenter = function RightCenter(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };

  var GetTop = function GetTop(gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y - height * gameObject.originY;
  };

  var SetTop = function SetTop(gameObject, value) {
    var height = GetDisplayHeight(gameObject);
    gameObject.y = value + height * gameObject.originY;
    return gameObject;
  };

  var TopCenter = function TopCenter(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };

  var TopLeft = function TopLeft(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };

  var TopRight = function TopRight(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };

  var AlignInMap = [];
  AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = BottomCenter;
  AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = BottomLeft;
  AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = BottomRight;
  AlignInMap[ALIGN_CONST.CENTER] = Center;
  AlignInMap[ALIGN_CONST.LEFT_CENTER] = LeftCenter;
  AlignInMap[ALIGN_CONST.RIGHT_CENTER] = RightCenter;
  AlignInMap[ALIGN_CONST.TOP_CENTER] = TopCenter;
  AlignInMap[ALIGN_CONST.TOP_LEFT] = TopLeft;
  AlignInMap[ALIGN_CONST.TOP_RIGHT] = TopRight;
  var QuickSet = function QuickSet(child, alignIn, position, offsetX, offsetY) {
    return AlignInMap[position](child, alignIn, offsetX, offsetY);
  };

  var AlignIn = function AlignIn(child, x, y, width, height, align) {
    globZone.setPosition(x, y).setSize(width, height);
    QuickSet(child, globZone, align);
  };

  var GetValue$2q = Phaser.Utils.Objects.GetValue;
  var Group$1 = Phaser.GameObjects.Group;
  var DrawBounds = function DrawBounds(graphics, config) {
    var scene = graphics.scene;
    var color, lineWidth;
    var createTextCallback, createTextCallbackScope, textAlign;
    if (typeof config === 'number') {
      color = config;
    } else {
      color = GetValue$2q(config, 'color');
      lineWidth = GetValue$2q(config, 'lineWidth');
      var nameTextConfig = GetValue$2q(config, 'name', false);
      if (nameTextConfig) {
        createTextCallback = GetValue$2q(nameTextConfig, 'createTextCallback', DefaultCreateTextCallback);
        createTextCallbackScope = GetValue$2q(nameTextConfig, 'createTextCallbackScope', undefined);
        textAlign = GetValue$2q(nameTextConfig, 'align', 'left-top');
        if (typeof textAlign === 'string') {
          textAlign = AlignConst[textAlign];
        }
      }
    }
    if (color === undefined) {
      color = 0xffffff;
    }
    if (lineWidth === undefined) {
      lineWidth = 1;
    }
    if (createTextCallback && !graphics.children) {
      graphics.children = new Group$1(scene);
      graphics.once('destroy', function (graphics, fromScene) {
        graphics.children.destroy(!fromScene);
        graphics.children = undefined;
      });
      var graphicsClear = graphics.clear.bind(graphics);
      graphics.clear = function () {
        graphicsClear();
        graphics.children.clear(false, true);
      };
    }
    var children = this.getAllShownChildren([this]),
      child;
    var nameText;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child.getBounds || child.width !== undefined && child.height !== undefined) {
        GlobRect = GetBounds(child, GlobRect);
      } else {
        continue;
      }
      if (color != null) {
        graphics.lineStyle(lineWidth, color).strokeRectShape(GlobRect);
      }
      if (child.name && createTextCallback) {
        if (createTextCallbackScope) {
          nameText = createTextCallback.call(createTextCallbackScope, scene);
        } else {
          nameText = createTextCallback(scene);
        }
        if (nameText) {
          nameText.setText(child.name);
          graphics.children.add(nameText);
          AlignIn(nameText, GlobRect.x, GlobRect.y, GlobRect.width, GlobRect.height, textAlign);
        }
      }
    }
    return this;
  };
  var DefaultCreateTextCallback = function DefaultCreateTextCallback(scene, child, childBoundsRect) {
    return scene.add.text(0, 0, '');
  };
  var GlobRect = undefined;

  var GetValue$2p = Phaser.Utils.Objects.GetValue;
  var GetBoundsConfig = function GetBoundsConfig(config, out) {
    if (config === undefined) {
      config = 0;
    }
    if (out === undefined) {
      out = {};
    }
    if (typeof config === 'number') {
      out.left = config;
      out.right = config;
      out.top = config;
      out.bottom = config;
    } else {
      out.left = GetValue$2p(config, 'left', 0);
      out.right = GetValue$2p(config, 'right', 0);
      out.top = GetValue$2p(config, 'top', 0);
      out.bottom = GetValue$2p(config, 'bottom', 0);
    }
    return out;
  };

  var ContainerAdd = ContainerLite.prototype.add;
  var AddChild$1 = function AddChild(gameObject) {
    ContainerAdd.call(this, gameObject);
    if (this.sizerEventsEnable) {
      gameObject.emit('sizer.add', gameObject, this);
      this.emit('add', gameObject, this);
    }
    return this;
  };

  var AddChildMethods$8 = {
    addBackground: function addBackground(gameObject, paddingConfig, childKey) {
      if (this.backgroundChildren === undefined) {
        this.backgroundChildren = [];
      }
      if (typeof paddingConfig === 'string') {
        childKey = paddingConfig;
        paddingConfig = undefined;
      }
      if (paddingConfig === undefined) {
        paddingConfig = 0;
      }
      AddChild$1.call(this, gameObject);
      this.backgroundChildren.push(gameObject);
      var config = this.getSizerConfig(gameObject);
      config.padding = GetBoundsConfig(paddingConfig);
      if (childKey !== undefined) {
        this.addChildrenMap(childKey, gameObject);
      }
      return this;
    },
    isBackground: function isBackground(gameObject) {
      if (this.backgroundChildren === undefined) {
        return false;
      }
      return this.backgroundChildren.indexOf(gameObject) !== -1;
    }
  };

  var GetParent = function GetParent(gameObject, name) {
    var parent = null;
    if (name === undefined) {
      if (gameObject.hasOwnProperty('rexContainer')) {
        parent = gameObject.rexContainer.parent;
        if (parent) {
          if (!parent.isRexSizer) {
            // Try to get sizer parent
            parent = GetParent(parent);
          }
        } else {
          parent = null;
        }
      }
    } else {
      parent = GetParent(gameObject);
      while (parent) {
        if (parent.name === name) {
          break;
        }
        parent = GetParent(parent);
      }
    }
    return parent;
  };
  var GetTopmostParent = function GetTopmostParent(gameObject) {
    var parent = GetParent(gameObject);
    while (parent) {
      gameObject = parent;
      parent = GetParent(parent);
    }
    return gameObject;
  };
  var GetParentSizerMethods = {
    getParentSizer: function getParentSizer(gameObject, name) {
      if (typeof gameObject === 'string') {
        name = gameObject;
        gameObject = undefined;
      }
      if (gameObject === undefined) {
        gameObject = this;
      }
      return GetParent(gameObject, name);
    },
    getTopmostSizer: function getTopmostSizer(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      return GetTopmostParent(gameObject);
    },
    hasParentSizer: function hasParentSizer(parentGameObject, gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      var parent = GetParent(gameObject);
      while (parent) {
        if (parent === parentGameObject) {
          return true;
        }
        parent = GetParent(parent);
      }
      return false;
    },
    hasChild: function hasChild(child, gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      return this.hasParentSizer(gameObject, child);
    }
  };

  var RemoveItem$4 = Phaser.Utils.Array.Remove;
  var ContainerRemove = ContainerLite.prototype.remove;
  var GetParentSizer$1 = GetParentSizerMethods.getParentSizer;
  var RemoveChild = function RemoveChild(gameObject, destroyChild) {
    // Invoke parent's removeChildCallback method
    var parent = GetParentSizer$1(gameObject);
    while (parent) {
      if (parent.removeChildCallback) {
        parent.removeChildCallback(gameObject, destroyChild);
      }
      parent = GetParentSizer$1(parent);
    }
    if (this.isBackground(gameObject)) {
      RemoveItem$4(this.backgroundChildren, gameObject);
    }
    ContainerRemove.call(this, gameObject, destroyChild);
    if (!destroyChild && this.sizerEventsEnable) {
      gameObject.emit('sizer.remove', gameObject, this);
      this.emit('remove', gameObject, this);
    }
    return this;
  };

  var RemoveItem$3 = Phaser.Utils.Array.Remove;
  var GetParentSizer = GetParentSizerMethods.getParentSizer;
  var RemoveChildMethods$7 = {
    removeFromParentSizer: function removeFromParentSizer() {
      var parent = GetParentSizer(gameObject);
      if (parent) {
        parent.remove(this);
      }
      return this;
    },
    removeBackground: function removeBackground(gameObject, destroyChild) {
      if (this.backgroundChildren === undefined) {
        return this;
      }
      if (this.getParentSizer(gameObject) !== this) {
        return this;
      }
      RemoveItem$3(this.backgroundChildren, gameObject);
      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAllBackgrounds: function removeAllBackgrounds(destroyChild) {
      if (this.backgroundChildren === undefined) {
        return this;
      }
      for (var i = this.backgroundChildren.length - 1; i >= 0; i--) {
        this.remove(this.backgroundChildren[i], destroyChild);
      }
      return this;
    }
  };

  var AddChildrenMap = function AddChildrenMap(key, gameObject) {
    if (typeof key === 'string') {
      this.childrenMap[key] = gameObject;
    } else {
      var config = key;
      for (key in config) {
        this.childrenMap[key] = config[key];
      }
    }
    return this;
  };

  var RemoveChildrenMap = function RemoveChildrenMap(key) {
    if (_typeof(key) === 'object') {
      var gameObject = key;
      for (var key in this.childrenMap) {
        if (this.childrenMap[key] === gameObject) {
          delete this.childrenMap[key];
          return this;
        }
      }
    }
    delete this.childrenMap[key];
    return this;
  };

  var GetElement = function GetElement(mapNameList, recursive) {
    if (typeof mapNameList === 'string') {
      mapNameList = mapNameList.split('.');
    }
    if (mapNameList.length === 0) {
      return undefined;
    }
    if (recursive === undefined) {
      recursive = false;
    }
    var name = mapNameList.shift(),
      element = null;
    if (name.charAt(0) === '#') {
      // Get element by name
      name = name.substring(1);
      element = this.getByName(name, recursive);
    } else if (mapNameList.length === 0 && recursive) {
      // Get element by single key and recursive        
      var childrenMap = this.childrenMap;
      if (childrenMap) {
        var queue = [childrenMap];
        var child;
        while (queue.length) {
          childrenMap = queue.shift();
          for (var key in childrenMap) {
            child = childrenMap[key];
            if (key === name) {
              element = child;
              break; // Leave for-loop
            } else if (child && _typeof(child) === 'object' && child.childrenMap) {
              queue.push(child.childrenMap);
            }
          }
          if (element) {
            // leave while-loop
            break;
          }
        }
      }
    } else if (name.indexOf('[') === -1) {
      // Get element by key
      if (this.childrenMap) {
        element = this.childrenMap[name];
      }
    } else {
      // Get element by key[]
      var innerMatch = name.match(RE_OBJ);
      if (innerMatch != null) {
        if (this.childrenMap) {
          var elements = this.childrenMap[innerMatch[1]];
          if (elements) {
            element = elements[innerMatch[2]];
          }
        }
      }
    }
    if (mapNameList.length === 0) {
      return element;
    } else if (element && element.childrenMap) {
      return element.getElement(mapNameList);
    } else {
      return null;
    }
  };
  var RE_OBJ = /(\S+)\[(\d+)\]/i;

  var GetChildIndex = function GetChildIndex(child) {
    if (Array.isArray(this.sizerChildren)) {
      var index = this.sizerChildren.indexOf(child);
      if (index === -1) {
        index = null;
      }
      return index;
    } else {
      if (this.getParentSizer(child) !== this) {
        return null;
      }
      for (var key in this.sizerChildren) {
        if (this.sizerChildre[key] === child) {
          return key;
        }
      }
      return null;
    }
  };

  var PaddingMethods = {
    getInnerPadding: function getInnerPadding(key) {
      return GetPadding$1(this.space, key);
    },
    setInnerPadding: function setInnerPadding(key, value) {
      SetPadding$1(this.space, key, value);
      return this;
    },
    getOuterPadding: function getOuterPadding(key) {
      return GetPadding$1(this.getSizerConfig(this).padding, key);
    },
    setOuterPadding: function setOuterPadding(key, value) {
      SetPadding$1(this.getSizerConfig(this).padding, key, value);
      return this;
    },
    getChildOuterPadding: function getChildOuterPadding(child, key) {
      if (typeof child === 'string') {
        child = this.getElement(child);
      }
      return GetPadding$1(this.getSizerConfig(child).padding, key);
    },
    setChildOuterPadding: function setChildOuterPadding(child, key, value) {
      if (typeof child === 'string') {
        child = this.getElement(child);
      }
      SetPadding$1(this.getSizerConfig(child).padding, key, value);
      return this;
    }
  };

  var ResolveWidth$3 = function ResolveWidth(width) {
    var childrenWidth = this.childrenWidth;
    if (childrenWidth === undefined) {
      // Can't resolve child width
      return undefined;
    }
    var minWidth = this.minWidth !== undefined ? this.minWidth : 0;
    if (width === undefined) {
      width = Math.max(minWidth, childrenWidth);
      if (this.layoutWarnEnable) {
        if (minWidth > 0 && childrenWidth > minWidth) {
          console.warn("Layout width warn: ".concat(this.constructor.name, "'s minWidth (").concat(minWidth, ") < childrenWidth (").concat(childrenWidth, ")"));
        }
      }
    } else {
      if (this.layoutWarnEnable) {
        if (minWidth > width || childrenWidth > width) {
          console.warn("Layout width warn: ".concat(this.constructor.name, "'s minWidth (").concat(minWidth, ") or childrenWidth (").concat(childrenWidth, " > targetWidth ").concat(width, ")"));
        }
      }
    }
    return width;
  };

  var HasWidthWrap$2 = function HasWidthWrap() {
    var child;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
        continue;
      }
      if (!child.hasWidthWrap || child.hasWidthWrap()) {
        return true;
      }
    }
    return false;
  };

  var ResolveChildrenWidth$1 = function ResolveChildrenWidth(parentWidth) {
    // Resolve width of sizer children
    var child, expandedChildWidth, childWidth;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (child && child.isRexSizer && !child.ignoreLayout) {
        expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
        childWidth = child.resolveWidth(expandedChildWidth);
        if (childWidth === undefined) {
          childWidth = expandedChildWidth;
        }
        child.resolveChildrenWidth(childWidth);
      }
    }
  };

  // Default method
  var RunWidthWrap$3 = function RunWidthWrap(parentWidth) {
    var child, expandedChildWidth, childWidth;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
        continue;
      }
      expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
      if (child.isRexSizer) {
        childWidth = child.resolveWidth(expandedChildWidth);
        if (childWidth === undefined) {
          childWidth = expandedChildWidth;
        }
      } else {
        childWidth = expandedChildWidth;
      }
      child.runWidthWrap(childWidth);
    }
    return this;
  };

  var ResolveHeight$3 = function ResolveHeight(height) {
    var childrenHeight = this.childrenHeight;
    if (childrenHeight === undefined) {
      // Can't resolve child height
      return undefined;
    }
    var minHeight = this.minHeight !== undefined ? this.minHeight : 0;
    if (height === undefined) {
      height = Math.max(minHeight, childrenHeight);
      if (this.layoutWarnEnable) {
        if (minHeight > 0 && childrenHeight > minHeight) {
          console.warn("Layout height warn: ".concat(this.constructor.name, "'s minHeight (").concat(minHeight, ") < childrenHeight (").concat(childrenHeight, ")"));
        }
      }
    } else {
      if (this.layoutWarnEnable) {
        if (minHeight > height || childrenHeight > height) {
          console.warn("Layout height warn: ".concat(this.constructor.name, "'s minHeight (").concat(minHeight, ") or childrenHeight (").concat(childrenHeight, ") > targetHeight (").concat(height, ")"));
        }
      }
    }
    return height;
  };

  var HasHeightWrap$2 = function HasHeightWrap() {
    var child;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
        continue;
      }
      if (!child.hasHeightWrap || child.hasHeightWrap() // all kind of sizers has hasHeightWrap method
      ) {
        return true;
      }
    }
    return false;
  };

  var ResolveChildrenHeight$1 = function ResolveChildrenHeight(parentHeight) {
    // Resolve width of sizer children
    var child, expandedChildHeight, childHeight;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (child && child.isRexSizer && !child.ignoreLayout) {
        expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
        childHeight = child.resolveHeight(expandedChildHeight);
        if (childHeight === undefined) {
          childHeight = expandedChildHeight;
        }
        child.resolveChildrenHeight(childHeight);
      }
    }
  };

  // Default method
  var RunHeightWrap$3 = function RunHeightWrap(parentHeight) {
    var child, expandedChildHeight, childHeight;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
        continue;
      }
      expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
      if (child.isRexSizer) {
        childHeight = child.resolveHeight(expandedChildHeight);
        if (childHeight === undefined) {
          childHeight = expandedChildHeight;
        }
      } else {
        childHeight = expandedChildHeight;
      }
      child.runHeightWrap(childHeight);
    }
    return this;
  };

  var GetChildWidth = function GetChildWidth(child) {
    var childWidth;
    if (child.isRexSizer) {
      // Sizer game object
      var childrenWidth = child.childrenWidth;
      if (childrenWidth == undefined) {
        return undefined;
      }
      childWidth = Math.max(child.minWidth, childrenWidth);
    } else {
      // Normal game object
      if (child.minWidth !== undefined) {
        // Force minWidth
        childWidth = child.minWidth;
      } else {
        childWidth = GetDisplayWidth(child);
      }
    }
    return childWidth;
  };

  var GetChildHeight = function GetChildHeight(child) {
    var childHeight;
    if (child.isRexSizer) {
      // Sizer game object
      var childrenHeight = child.childrenHeight;
      if (childrenHeight === undefined) {
        return undefined;
      }
      childHeight = Math.max(child.minHeight, childrenHeight);
    } else {
      // Normal game object
      if (child.minHeight !== undefined) {
        // Force minHeight
        childHeight = child.minHeight;
      } else {
        childHeight = GetDisplayHeight(child);
      }
    }
    return childHeight;
  };

  // Override
  var GetExpandedChildWidth$3 = function GetExpandedChildWidth(child, parentWidth) {
    return parentWidth;
  };

  // Override
  var GetExpandedChildHeight$3 = function GetExpandedChildHeight(child, parentHeight) {
    return parentHeight;
  };

  // Override
  var GetChildrenWidth$5 = function GetChildrenWidth() {
    return 0;
  };

  // Override
  var GetChildrenHeight$5 = function GetChildrenHeight() {
    return 0;
  };

  var GetAllChildrenSizers = function GetAllChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }
    var startIdx = out.length;
    var children = this.getChildrenSizers(out);
    var endIdx = out.length;
    for (var i = startIdx; i < endIdx; i++) {
      children[i].getAllChildrenSizers(out);
    }
    return out;
  };

  // Default method
  var GetChildrenSizers$5 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }
    return out;
  };

  var GetShownChildrenMethods = {
    getShownChildren: function getShownChildren(out) {
      if (out === undefined) {
        out = [];
      }
      var children = this.children,
        child;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.rexSizer && child.rexSizer.hidden) {
          // Don't add hidden child
          continue;
        }
        out.push(child);
      }
      return out;
    },
    getAllShownChildren: function getAllShownChildren(out) {
      if (out === undefined) {
        out = [];
      }
      var queue = [this];
      while (queue.length > 0) {
        var current = queue.shift();
        if (current.rexSizer && current.rexSizer.hidden) {
          continue;
        }
        if (current !== this) {
          out.push(current);
        }
        if (current.isRexContainerLite) {
          queue.push.apply(queue, _toConsumableArray(current.children));
        }
      }
      return out;
    }
  };

  var PreLayout$4 = function PreLayout() {
    this._childrenWidth = undefined;
    this._childrenHeight = undefined;
    var children = this.getChildrenSizers(),
      child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child.ignoreLayout) {
        continue;
      }
      child.preLayout();
    }
  };

  var Layout = function Layout() {
    // Skip hidden or !dirty sizer
    if (this.ignoreLayout) {
      return this;
    }

    // Save scale
    var scaleXSave = this.scaleX;
    var scaleYSave = this.scaleY;
    var scale1 = scaleXSave === 1 && scaleYSave === 1;
    if (!scale1) {
      this.setScale(1);
    }

    // Run layout with scale = 1
    this.runLayout();

    // Restore scale
    if (!scale1) {
      this.setScale(scaleXSave, scaleYSave);
    }
    return this;
  };

  // Override
  var RunLayout = function RunLayout(parent, newWidth, newHeight) {
    // Skip hidden or !dirty sizer
    if (this.ignoreLayout) {
      return this;
    }
    var isTopmostParent = !parent;
    // Pre-processor, top parent only
    if (isTopmostParent) {
      this.preLayout();
    }
    var size, width, height;
    var runWidthWrap = isTopmostParent && this.hasWidthWrap();
    var runHeightWrap = isTopmostParent && this.hasHeightWrap();
    size = ResolveSize(this, newWidth, newHeight, runWidthWrap, runHeightWrap);
    if (!size) {
      console.error('Can\'t resolve size of ', this);
    }
    width = size.width;
    height = size.height;

    // Resize parent
    this.resize(width, height);
    if (this.sizerEventsEnable) {
      if (this.layoutedChildren === undefined) {
        this.layoutedChildren = [];
      }
    }

    // Layout children    
    this.layoutChildren();

    // Layout background children
    this.layoutBackgrounds();
    if (this.sizerEventsEnable) {
      this.emit('postlayout', this.layoutedChildren, this);
      this.layoutedChildren.length = 0;
    }

    // Custom postLayout callback
    this.postLayout();

    // Post-processor, top parent only
    if (isTopmostParent) {
      this._postLayout();
    }
    return this;
  };
  var ResolveSize = function ResolveSize(self, width, height, runWidthWrap, runHeightWrap) {
    var newWidth = ResolveWidth$2(self, width, runWidthWrap);
    var newHeight = ResolveHeight$2(self, height, runHeightWrap);
    if (newWidth === undefined) {
      newWidth = ResolveWidth$2(self, width, runWidthWrap);
    }
    if (newWidth !== undefined && newHeight !== undefined) {
      return {
        width: newWidth,
        height: newHeight
      };
    }
    return false;
  };
  var ResolveWidth$2 = function ResolveWidth(self, width, runWidthWrap) {
    // Calculate parent width
    var width = self.resolveWidth(width);

    // Calculate all children width, run width wrap
    if (width !== undefined) {
      if (runWidthWrap) {
        self.resolveChildrenWidth(width);
        self.runWidthWrap(width);
      }
    }
    return width;
  };
  var ResolveHeight$2 = function ResolveHeight(self, height, runHeightWrap) {
    // Calculate parent height
    var height = self.resolveHeight(height);

    // Calculate all children width, run width wrap
    if (height !== undefined) {
      if (runHeightWrap) {
        self.resolveChildrenHeight(height);
        self.runHeightWrap(height);
      }
    }
    return height;
  };

  // Override
  var LayoutChildren$6 = function LayoutChildren() {};

  var _PostLayout = function _PostLayout(parent, newWidth, newHeight) {
    if (this._anchor) {
      this._anchor.updatePosition();
    }
    return this;
  };

  // Override
  var PostLayout = function PostLayout(parent, newWidth, newHeight) {
    return this;
  };

  var HasResizeMethod = function HasResizeMethod(gameObject) {
    // 1st pass : Has `resize` method?
    if (gameObject.resize) {
      return true;
    }

    // 2nd pass : Has `setSize` method?
    if (!gameObject.setSize) {
      return false;
    }
    for (var i = 0, cnt = ExcludeClassList$1.length; i < cnt; i++) {
      var excludeClass = ExcludeClassList$1[i];
      if (excludeClass && gameObject instanceof excludeClass) {
        return false;
      }
    }
    return true;
  };
  var ExcludeClassList$1 = [Phaser.GameObjects.Image, Phaser.GameObjects.Sprite, Phaser.GameObjects.Mesh, Phaser.GameObjects.Shader, Phaser.GameObjects.Video];

  var CanSetDisplaySize = function CanSetDisplaySize(gameObject) {
    if (gameObject.displayWidth === undefined) {
      return false;
    }
    for (var i = 0, cnt = ExcludeClassList.length; i < cnt; i++) {
      var excludeClass = ExcludeClassList[i];
      if (excludeClass && gameObject instanceof excludeClass) {
        return false;
      }
    }
    return true;
  };
  var ExcludeClassList = [Phaser.GameObjects.BitmapText];

  var ResizeGameObject = function ResizeGameObject(gameObject, newWidth, newHeight) {
    if (!gameObject || newWidth === undefined && newHeight === undefined) {
      return;
    }
    if (HasResizeMethod(gameObject)) {
      // Has `resize`, or `setSize` method
      if (newWidth === undefined) {
        newWidth = gameObject.width;
      }
      if (newHeight === undefined) {
        newHeight = gameObject.height;
      }
      if (gameObject.resize) {
        gameObject.resize(newWidth, newHeight);
      } else {
        gameObject.setSize(newWidth, newHeight);
      }
    } else {
      // Set display width/height
      var canSetDisplaySize = CanSetDisplaySize(gameObject);
      if (newWidth !== undefined) {
        if (canSetDisplaySize) {
          gameObject.displayWidth = newWidth;
        } else {
          gameObject.scaleX = newWidth / gameObject.width;
        }
      }
      if (newHeight !== undefined) {
        if (canSetDisplaySize) {
          gameObject.displayHeight = newHeight;
        } else {
          gameObject.scaleY = newHeight / gameObject.height;
        }
      }
    }
  };

  var DefaultResizeCallback = function DefaultResizeCallback(width, height, gameObject, anchor) {
    ResizeGameObject(gameObject, width, height);
  };

  var GetValue$2o = Phaser.Utils.Objects.GetValue;
  var Anchor = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Anchor, _ComponentBase);
    function Anchor(gameObject, config) {
      var _this;
      _classCallCheck(this, Anchor);
      _this = _callSuper(this, Anchor, [gameObject, {
        eventEmitter: false
      }]);
      // No event emitter
      // this.parent = gameObject;

      _this.viewport = undefined;
      _this.resetFromJSON(config);
      return _this;
    }
    _createClass(Anchor, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        this.autoAnchor(false);
        this.viewport = undefined;
        this.onUpdateViewportCallback = undefined;
        this.onUpdateViewportCallbackScope = undefined;
        this.onResizeCallback = undefined;
        this.onResizeCallbackScope = undefined;
        _get(_getPrototypeOf(Anchor.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        if (o === undefined) {
          o = {};
        }

        // Position
        var alignX, configX;
        if (o.x !== undefined) {
          alignX = null;
          configX = o.x;
        } else if (o.left !== undefined) {
          alignX = 0;
          configX = o.left;
        } else if (o.right !== undefined) {
          alignX = 1;
          configX = o.right;
        } else if (o.centerX !== undefined) {
          alignX = 0.5;
          configX = o.centerX;
        }
        var alignY, configY;
        if (o.y !== undefined) {
          alignY = null;
          configY = o.y;
        } else if (o.top !== undefined) {
          alignY = 0;
          configY = o.top;
        } else if (o.bottom !== undefined) {
          alignY = 1;
          configY = o.bottom;
        } else if (o.centerY !== undefined) {
          alignY = 0.5;
          configY = o.centerY;
        }
        var percentageX, offsetX;
        if (configX !== undefined) {
          configX = configX.replace('left', '0%').replace('right', '100%').replace('center', '50%').split('%');
          percentageX = parseFloat(configX[0]) / 100;
          offsetX = configX[1] === '' ? 0 : parseFloat(configX[1]);
        }
        var percentageY, offsetY;
        if (configY !== undefined) {
          configY = configY.replace('top', '0%').replace('bottom', '100%').replace('center', '50%').split('%');
          percentageY = parseFloat(configY[0]) / 100;
          offsetY = configY[1] === '' ? 0 : parseFloat(configY[1]);
        }

        // Size
        var configWidth = o.width;
        var percentageWidth, paddingWidth;
        if (configWidth !== undefined) {
          configWidth = configWidth.split('%');
          percentageWidth = parseFloat(configWidth[0]) / 100;
          paddingWidth = configWidth[1] === '' ? 0 : parseFloat(configWidth[1]);
        }
        var configHeight = o.height;
        var percentageHeight, paddingHeight;
        if (configHeight !== undefined) {
          configHeight = configHeight.split('%');
          percentageHeight = parseFloat(configHeight[0]) / 100;
          paddingHeight = configHeight[1] === '' ? 0 : parseFloat(configHeight[1]);
        }

        // Position
        this.setAlign(alignX, alignY);
        this.setPercentage(percentageX, percentageY);
        this.setOffset(offsetX, offsetY);
        // Size
        this.setSizePercentage(percentageWidth, percentageHeight);
        this.setSizePadding(paddingWidth, paddingHeight);
        var onResizeCallback = GetValue$2o(o, 'onResizeCallback', DefaultResizeCallback);
        var onResizeCallbackScope = GetValue$2o(o, 'onResizeCallbackScope');
        this.setResizeCallback(onResizeCallback, onResizeCallbackScope);
        var onUpdateViewportCallback = GetValue$2o(o, 'onUpdateViewportCallback');
        var onUpdateViewportCallbackScope = GetValue$2o(o, 'onUpdateViewportCallbackScope');
        this.setUpdateViewportCallback(onUpdateViewportCallback, onUpdateViewportCallbackScope);
        this.autoAnchor(o.enable);
        return this;
      }
    }, {
      key: "autoAnchor",
      value: function autoAnchor(enable) {
        if (enable === undefined) {
          enable = true;
        }
        enable = !!enable;
        if (this.autoAnchorEnable === enable) {
          return this;
        }
        if (enable) {
          this.scene.sys.scale.on('resize', this.anchor, this);
          this.anchor();
        } else {
          this.scene.sys.scale.off('resize', this.anchor, this);
        }
        this.autoAnchorEnable = enable;
        return this;
      }

      // Position
    }, {
      key: "setAlign",
      value: function setAlign(x, y) {
        this.alignX = x;
        this.alignY = y;
        return this;
      }
    }, {
      key: "setPercentage",
      value: function setPercentage(x, y) {
        this.percentageX = x;
        this.percentageY = y;
        return this;
      }
    }, {
      key: "setOffset",
      value: function setOffset(x, y) {
        this.offsetX = x;
        this.offsetY = y;
        return this;
      }

      // Size
    }, {
      key: "setSizePercentage",
      value: function setSizePercentage(width, height) {
        this.percentageWidth = width;
        this.percentageHeight = height;
        return this;
      }
    }, {
      key: "setSizePadding",
      value: function setSizePadding(width, height) {
        this.paddingWidth = width;
        this.paddingHeight = height;
        return this;
      }
    }, {
      key: "setResizeCallback",
      value: function setResizeCallback(callback, scope) {
        this.onResizeCallback = callback;
        this.onResizeCallbackScope = scope;
        return this;
      }
    }, {
      key: "setUpdateViewportCallback",
      value: function setUpdateViewportCallback(callback, scope) {
        this.onUpdateViewportCallback = callback;
        this.onUpdateViewportCallbackScope = scope;
        return this;
      }
    }, {
      key: "anchor",
      value: function anchor() {
        this.updateViewport();
        this.updateSize();
        this.updatePosition();
        return this;
      }
    }, {
      key: "updateSize",
      value: function updateSize() {
        var callback = this.onResizeCallback,
          scope = this.onResizeCallbackScope;
        var newWidth = this.anchorWidth,
          newHeight = this.anchorHeight;
        if (newWidth === undefined && newHeight === undefined || !callback) {
          return;
        }
        var gameObject = this.parent;
        if (newWidth === undefined) {
          newWidth = gameObject.width;
        }
        if (newHeight === undefined) {
          newHeight = gameObject.height;
        }
        if (scope) {
          callback.call(scope, newWidth, newHeight, gameObject, this);
        } else {
          callback(newWidth, newHeight, gameObject, this);
        }
      }
    }, {
      key: "updatePosition",
      value: function updatePosition() {
        var gameObject = this.parent;
        if (this.alignX === null) {
          gameObject.x = this.anchorX;
        } else if (this.alignX !== undefined) {
          gameObject.x = this.anchorX + gameObject.displayWidth * (gameObject.originX - this.alignX);
        }
        if (this.alignY === null) {
          gameObject.y = this.anchorY;
        } else if (this.alignY !== undefined) {
          gameObject.y = this.anchorY + gameObject.displayHeight * (gameObject.originY - this.alignY);
        }
        return this;
      }
    }, {
      key: "anchorX",
      get: function get() {
        return this.viewport.x + this.viewport.width * this.percentageX + this.offsetX;
      }
    }, {
      key: "anchorY",
      get: function get() {
        return this.viewport.y + this.viewport.height * this.percentageY + this.offsetY;
      }
    }, {
      key: "anchorWidth",
      get: function get() {
        if (this.percentageWidth === undefined) {
          return undefined;
        }
        return this.viewport.width * this.percentageWidth + this.paddingWidth;
      }
    }, {
      key: "anchorHeight",
      get: function get() {
        if (this.percentageHeight === undefined) {
          return undefined;
        }
        return this.viewport.height * this.percentageHeight + this.paddingHeight;
      }
    }, {
      key: "updateViewport",
      value: function updateViewport() {
        var camera = this.parent.scene.cameras.main;
        this.viewport = GetViewport(this.scene, camera, this.viewport);
        var viewport = this.viewport;
        var callback = this.onUpdateViewportCallback,
          scope = this.onUpdateViewportCallbackScope;
        if (callback) {
          if (scope) {
            callback.call(scope, viewport, this.parent, this);
          } else {
            callback(viewport, this.parent, this);
          }
        }
      }
    }]);
    return Anchor;
  }(ComponentBase);

  var SetAnchor = function SetAnchor(config) {
    if (config === undefined) {
      config = {};
    }

    // Assign default onResizeCallback if not given    
    var hasMinWidth = config.hasOwnProperty('width');
    var hasMinHeight = config.hasOwnProperty('height');
    var hasOnResizeCallback = config.hasOwnProperty('onResizeCallback');
    if ((hasMinWidth || hasMinHeight) && !hasOnResizeCallback) {
      config.onResizeCallback = function (width, height, sizer) {
        if (hasMinWidth) {
          sizer.setMinWidth(width);
        }
        if (hasMinHeight) {
          sizer.setMinHeight(height);
        }
        sizer.layout();
      };
    }
    if (this._anchor === undefined) {
      this._anchor = new Anchor(this, config);
    } else {
      this._anchor.resetFromJSON(config);
    }
    return this;
  };

  var GetValue$2n = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$2 = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear$4 = Phaser.Math.Linear;
  var Scale = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(Scale, _EaseValueTaskBase);
    function Scale(gameObject, config) {
      var _this;
      _classCallCheck(this, Scale);
      _this = _callSuper(this, Scale, [gameObject, config]);
      // this.parent = gameObject;
      // this.timer

      _this.scaleStart = {};
      _this.scaleEnd = {};
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(Scale, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Scale.prototype), "resetFromJSON", this).call(this, o);
        this.setMode(GetValue$2n(o, 'mode', 0));
        this.setScaleRange(GetAdvancedValue$2(o, 'start', undefined), GetAdvancedValue$2(o, 'end', 0));
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = MODE$3[m];
        }
        this.mode = m;
        return this;
      }
    }, {
      key: "setScaleRange",
      value: function setScaleRange(start, end) {
        if (typeof start === 'number') {
          this.startX = start;
          this.startY = start;
        } else {
          this.startX = GetAdvancedValue$2(start, 'x', this.parent.scaleX);
          this.startY = GetAdvancedValue$2(start, 'y', this.parent.scaleY);
        }
        if (typeof end === 'number') {
          this.endX = end;
          this.endY = end;
        } else {
          this.endX = GetAdvancedValue$2(end, 'x', undefined);
          this.endY = GetAdvancedValue$2(end, 'y', undefined);
        }
        this.hasScaleX = this.startX !== undefined && this.endX !== undefined;
        this.hasScaleY = this.startY !== undefined && this.endY !== undefined;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }
        var gameObject = this.parent;
        if (this.hasScaleX) {
          gameObject.scaleX = this.startX;
        }
        if (this.hasScaleY) {
          gameObject.scaleY = this.startY;
        }
        var repeat = this.repeat;
        if (this.mode === 2) {
          // Yoyo
          if (repeat !== -1) {
            repeat = (repeat + 1) * 2 - 1;
          }
        }
        this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(repeat);
        _get(_getPrototypeOf(Scale.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(gameObject, timer) {
        var t = timer.t;
        if (timer.isOddIteration) {
          // Yoyo
          t = 1 - t;
        }
        t = this.easeFn(t);
        if (this.hasScaleX) {
          gameObject.scaleX = Linear$4(this.startX, this.endX, t);
        }
        if (this.hasScaleY) {
          gameObject.scaleY = Linear$4(this.startY, this.endY, t);
        }
      }
    }, {
      key: "complete",
      value: function complete() {
        _get(_getPrototypeOf(Scale.prototype), "complete", this).call(this);
        if (this.mode === 1) {
          this.parent.destroy();
          // Will also destroy this behavior
        }
        return this;
      }
    }]);
    return Scale;
  }(EaseValueTaskBase);
  var MODE$3 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
  };

  var PopUp$1 = function PopUp(gameObject, duration, orientation, ease, scale) {
    if (ease === undefined) {
      ease = 'Cubic';
    }

    // Ease scale from 0 to current scale
    var start, end;
    switch (orientation) {
      case 0:
      case 'x':
        start = {
          x: 0
        };
        end = {
          x: gameObject.scaleX
        };
        break;
      case 1:
      case 'y':
        start = {
          y: 0
        };
        end = {
          y: gameObject.scaleY
        };
        break;
      default:
        start = 0;
        end = gameObject.scale;
        break;
    }
    var config = {
      mode: 0,
      start: start,
      end: end,
      duration: duration,
      ease: ease
    };
    if (scale === undefined) {
      scale = new Scale(gameObject, config);
    } else {
      scale.resetFromJSON(config);
    }
    scale.restart();
    return scale;
  };

  var ScaleDownDestroy = function ScaleDownDestroy(gameObject, duration, orientation, ease, destroyMode, scale) {
    if (ease === undefined) {
      ease = 'Linear';
    }

    // Ease from current scale to 0
    if (destroyMode instanceof Scale) {
      scale = destroyMode;
      destroyMode = undefined;
    }
    if (destroyMode === undefined) {
      destroyMode = true;
    }
    var config = {};
    config.mode = destroyMode ? 1 : 0;
    switch (orientation) {
      case 0:
      case 'x':
        config.end = {
          x: 0
        };
        break;
      case 1:
      case 'y':
        config.end = {
          y: 0
        };
        break;
      default:
        config.end = 0;
        break;
    }
    config.duration = duration;
    config.ease = ease;
    if (scale === undefined) {
      scale = new Scale(gameObject, config);
    } else {
      scale.resetFromJSON(config);
    }
    scale.restart();
    return scale;
  };

  var Yoyo = function Yoyo(gameObject, duration, peakValue, repeat, orientation, ease, scale) {
    if (peakValue === undefined) {
      peakValue = 1.2;
    }
    if (repeat === undefined) {
      repeat = 0;
    }
    if (ease === undefined) {
      ease = 'Cubic';
    }

    // Ease scale from 0 to current scale
    var start, end;
    switch (orientation) {
      case 0:
      case 'x':
        start = {
          x: gameObject.scaleX
        };
        end = {
          x: peakValue
        };
        break;
      case 1:
      case 'y':
        start = {
          y: gameObject.scaleX
        };
        end = {
          y: peakValue
        };
        break;
      default:
        start = gameObject.scaleX;
        end = peakValue;
        break;
    }
    var config = {
      mode: 2,
      start: start,
      end: end,
      duration: duration / 2,
      ease: ease,
      repeat: repeat
    };
    if (scale === undefined) {
      scale = new Scale(gameObject, config);
    } else {
      scale.resetFromJSON(config);
    }
    scale.restart();
    return scale;
  };

  var IsPlainObject$y = Phaser.Utils.Objects.IsPlainObject;
  var OnInitScale = function OnInitScale(gameObject, scale) {
    // Route 'complete' of scale to gameObject
    scale.completeEventName = undefined;
    scale.on('complete', function () {
      if (scale.completeEventName) {
        gameObject.emit(scale.completeEventName, gameObject);
        scale.completeEventName = undefined;
      }
    });

    // Update local state
    scale.on('update', function () {
      var parent = GetParentSizerMethods.getParentSizer(gameObject);
      if (parent) {
        parent.resetChildPositionState(gameObject);
      }
    });
  };
  var ScaleMethods = {
    popUp: function popUp(duration, orientation, ease) {
      if (IsPlainObject$y(duration)) {
        var config = duration;
        duration = config.duration;
        orientation = config.orientation;
        ease = config.ease;
      }
      var isInit = this._scaleBehavior === undefined;
      this._scaleBehavior = PopUp$1(this, duration, orientation, ease, this._scaleBehavior);
      if (isInit) {
        OnInitScale(this, this._scaleBehavior);
      }
      this._scaleBehavior.completeEventName = 'popup.complete';
      return this;
    },
    popUpPromise: function popUpPromise(duration, orientation, ease) {
      this.popUp(duration, orientation, ease);
      return WaitComplete(this._scaleBehavior);
    },
    scaleDownDestroy: function scaleDownDestroy(duration, orientation, ease, destroyMode) {
      if (IsPlainObject$y(duration)) {
        var config = duration;
        duration = config.duration;
        orientation = config.orientation;
        ease = config.ease;
        destroyMode = config.destroy;
      }
      var isInit = this._scaleBehavior === undefined;
      this._scaleBehavior = ScaleDownDestroy(this, duration, orientation, ease, destroyMode, this._scaleBehavior);
      if (isInit) {
        OnInitScale(this, this._scaleBehavior);
      }
      this._scaleBehavior.completeEventName = 'scaledown.complete';
      return this;
    },
    scaleDownDestroyPromise: function scaleDownDestroyPromise(duration, orientation, ease, destroyMode) {
      this.scaleDownDestroy(duration, orientation, ease, destroyMode);
      return WaitComplete(this._scaleBehavior);
    },
    scaleDown: function scaleDown(duration, orientation, ease) {
      this.scaleDownDestroy(duration, orientation, ease, false);
      return this;
    },
    scaleDownPromise: function scaleDownPromise(duration, orientation, ease) {
      this.scaleDown(duration, orientation, ease);
      return WaitComplete(this._scaleBehavior);
    },
    scaleYoyo: function scaleYoyo(duration, peakValue, repeat, orientation, ease) {
      if (IsPlainObject$y(duration)) {
        var config = duration;
        duration = config.duration;
        peakValue = config.peakValue;
        repeat = config.repeat;
        orientation = config.orientation;
        ease = config.ease;
      }
      var isInit = this._scaleBehavior === undefined;
      this._scaleBehavior = Yoyo(this, duration, peakValue, repeat, orientation, ease, this._scaleBehavior);
      if (isInit) {
        OnInitScale(this, this._scaleBehavior);
      }
      this._scaleBehavior.completeEventName = 'scaleyoyo.complete';
      return this;
    },
    scaleYoyoPromise: function scaleYoyoPromise(duration, peakValue, repeat, orientation, ease) {
      this.scaleYoyo(duration, peakValue, repeat, orientation, ease);
      return WaitComplete(this._scaleBehavior);
    }
  };

  var GetValue$2m = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$1 = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear$3 = Phaser.Math.Linear;
  var Fade$2 = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(Fade, _EaseValueTaskBase);
    function Fade(gameObject, config) {
      var _this;
      _classCallCheck(this, Fade);
      _this = _callSuper(this, Fade, [gameObject, config]);
      // this.parent = gameObject;
      // this.timer

      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(Fade, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Fade.prototype), "resetFromJSON", this).call(this, o);
        this.setMode(GetValue$2m(o, 'mode', 0));
        this.setAlphaRange(GetAdvancedValue$1(o, 'start', this.parent.alpha), GetAdvancedValue$1(o, 'end', 0));
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = MODE$2[m];
        }
        this.mode = m;
        return this;
      }
    }, {
      key: "setAlphaRange",
      value: function setAlphaRange(start, end) {
        this.alphaStart = start;
        this.alphaEnd = end;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }
        var gameObject = this.parent;
        gameObject.setAlpha(this.alphaStart);
        this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);
        _get(_getPrototypeOf(Fade.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(gameObject, timer) {
        var t = timer.t;
        if (timer.isOddIteration) {
          // Yoyo
          t = 1 - t;
        }
        gameObject.alpha = Linear$3(this.alphaStart, this.alphaEnd, t);
      }
    }, {
      key: "complete",
      value: function complete() {
        _get(_getPrototypeOf(Fade.prototype), "complete", this).call(this);
        if (this.mode === 1) {
          this.parent.destroy();
          // Will also destroy this behavior
        }
        return this;
      }
    }]);
    return Fade;
  }(EaseValueTaskBase);
  var MODE$2 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
  };

  var IsPlainObject$x = Phaser.Utils.Objects.IsPlainObject;
  var FadeIn = function FadeIn(gameObject, duration, alpha, fade) {
    var startAlpha, endAlpha;
    if (IsPlainObject$x(alpha)) {
      startAlpha = alpha.start;
      endAlpha = alpha.end;
    } else {
      endAlpha = alpha;
    }
    if (startAlpha === undefined) {
      startAlpha = 0;
    }
    if (endAlpha === undefined) {
      endAlpha = 1;
    }
    var config = {
      mode: 0,
      start: startAlpha,
      end: endAlpha,
      duration: duration
    };
    if (fade === undefined) {
      fade = new Fade$2(gameObject, config);
    } else {
      fade.resetFromJSON(config);
    }
    fade.restart();
    return fade;
  };

  var FadeOutDestroy = function FadeOutDestroy(gameObject, duration, destroyMode, fade) {
    if (destroyMode instanceof Fade$2) {
      fade = destroyMode;
      destroyMode = undefined;
    }
    if (destroyMode === undefined) {
      destroyMode = true;
    }
    var config = {
      mode: destroyMode ? 1 : 0,
      end: 0,
      duration: duration
    };
    if (fade === undefined) {
      fade = new Fade$2(gameObject, config);
    } else {
      fade.resetFromJSON(config);
    }
    fade.restart();
    return fade;
  };

  var IsPlainObject$w = Phaser.Utils.Objects.IsPlainObject;
  var OnInitFade = function OnInitFade(gameObject, fade) {
    // Route 'complete' of fade to gameObject
    fade.completeEventName = undefined;
    fade.on('complete', function () {
      if (fade.completeEventName) {
        gameObject.emit(fade.completeEventName, gameObject);
        fade.completeEventName = undefined;
      }
    });

    // Update local state
    fade.on('update', function () {
      var parent = GetParentSizerMethods.getParentSizer(gameObject);
      if (parent) {
        parent.resetChildAlphaState(gameObject);
      }
    });
  };
  var FadeMethods = {
    fadeIn: function fadeIn(duration, alpha) {
      if (IsPlainObject$w(duration)) {
        var config = duration;
        duration = config.duration;
        alpha = config.alpha;
      }
      var isInit = this._fade === undefined;
      this._fade = FadeIn(this, duration, alpha, this._fade);
      if (isInit) {
        OnInitFade(this, this._fade);
      }
      this._fade.completeEventName = 'fadein.complete';
      return this;
    },
    fadeInPromise: function fadeInPromise(duration, alpha) {
      this.fadeIn(duration, alpha);
      return WaitComplete(this._fade);
    },
    fadeOutDestroy: function fadeOutDestroy(duration, destroyMode) {
      if (IsPlainObject$w(duration)) {
        var config = duration;
        duration = config.duration;
        destroyMode = config.destroy;
      }
      var isInit = this._fade === undefined;
      this._fade = FadeOutDestroy(this, duration, destroyMode, this._fade);
      if (isInit) {
        OnInitFade(this, this._fade);
      }
      this._fade.completeEventName = 'fadeout.complete';
      return this;
    },
    fadeOutDestroyPromise: function fadeOutDestroyPromise(duration, destroyMode) {
      this.fadeOutDestroy(duration, destroyMode);
      return WaitComplete(this._fade);
    },
    fadeOut: function fadeOut(duration) {
      this.fadeOutDestroy(duration, false);
      return this;
    },
    fadeOutPromise: function fadeOutPromise(duration) {
      this.fadeOut(duration);
      return WaitComplete(this._fade);
    }
  };

  var GetValue$2l = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear$2 = Phaser.Math.Linear;
  var EaseMove = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(EaseMove, _EaseValueTaskBase);
    function EaseMove(gameObject, config) {
      var _this;
      _classCallCheck(this, EaseMove);
      _this = _callSuper(this, EaseMove, [gameObject, config]);
      // this.parent = gameObject;
      // this.timer

      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(EaseMove, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(EaseMove.prototype), "resetFromJSON", this).call(this, o);
        this.setMode(GetValue$2l(o, 'mode', 0));
        if (o && (o.hasOwnProperty('x') || o.hasOwnProperty('y'))) {
          var endX = GetAdvancedValue(o, 'x', undefined);
          var endY = GetAdvancedValue(o, 'y', undefined);
          this.setTargetPosition(endX, endY);
        } else {
          this.setTargetPosition(o);
        }
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = MODE$1[m];
        }
        this.mode = m;
        return this;
      }
    }, {
      key: "setTargetPosition",
      value: function setTargetPosition(x, y) {
        if (typeof x === 'number' || typeof y === 'number') {
          // endX, endY
          // x,y : a number, or undefined
          this.startX = this.parent.x;
          this.startY = this.parent.y;
          this.endX = x;
          this.endY = y;
        } else {
          var config = x;
          this.startX = GetAdvancedValue(config, 'startX', undefined);
          this.startY = GetAdvancedValue(config, 'startY', undefined);
          this.endX = GetAdvancedValue(config, 'endX', undefined);
          this.endY = GetAdvancedValue(config, 'endY', undefined);
        }
        this.hasMoveX = this.startX !== undefined && this.endX !== undefined;
        this.hasMoveY = this.startY !== undefined && this.endY !== undefined;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }
        var gameObject = this.parent;
        if (this.hasMoveX) {
          gameObject.x = this.startX;
        }
        if (this.hasMoveY) {
          gameObject.y = this.startY;
        }
        this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);
        _get(_getPrototypeOf(EaseMove.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(gameObject, timer) {
        var t = timer.t;
        if (timer.isOddIteration) {
          // Yoyo
          t = 1 - t;
        }
        t = this.easeFn(t);
        if (this.hasMoveX) {
          gameObject.x = Linear$2(this.startX, this.endX, t);
        }
        if (this.hasMoveY) {
          gameObject.y = Linear$2(this.startY, this.endY, t);
        }
      }
    }, {
      key: "complete",
      value: function complete() {
        _get(_getPrototypeOf(EaseMove.prototype), "complete", this).call(this);
        if (this.mode === 1) {
          this.parent.destroy();
          // Will also destroy this behavior
        }
        return this;
      }
    }]);
    return EaseMove;
  }(EaseValueTaskBase);
  var MODE$1 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
  };

  var ParseValue = function ParseValue(propertyValue, startValue) {
    // propertyValue : number or string
    if (typeof propertyValue === 'number') {
      return propertyValue;
    } else {
      var op = propertyValue[0];
      var num = parseFloat(propertyValue.substr(2));
      switch (op) {
        case '+':
          return startValue + num;
        case '-':
          return startValue - num;
        case '*':
          return startValue * num;
        case '/':
          return startValue / num;
      }
    }
  };

  var EaseMoveTo = function EaseMoveTo(gameObject, duration, endX, endY, ease, destroyMode, easeMove) {
    if (destroyMode instanceof EaseMove) {
      easeMove = destroyMode;
      destroyMode = undefined;
    }
    if (destroyMode === undefined) {
      destroyMode = false;
    }
    var config = {};
    config.mode = destroyMode ? 1 : 0;
    if (endX !== undefined) {
      config.startX = gameObject.x;
      config.endX = ParseValue(endX, gameObject.x);
    }
    if (endY !== undefined) {
      config.startY = gameObject.y;
      config.endY = ParseValue(endY, gameObject.y);
    }
    config.duration = duration;
    config.ease = ease === undefined ? 'Linear' : ease;
    if (easeMove === undefined) {
      easeMove = new EaseMove(gameObject, config);
    } else {
      easeMove.resetFromJSON(config);
    }
    easeMove.restart();
    return easeMove;
  };

  var EaseMoveFrom = function EaseMoveFrom(gameObject, duration, startX, startY, ease, destroyMode, easeMove) {
    if (destroyMode instanceof EaseMove) {
      easeMove = destroyMode;
      destroyMode = undefined;
    }
    if (destroyMode === undefined) {
      destroyMode = false;
    }
    var config = {};
    config.mode = destroyMode ? 1 : 0;
    if (startX !== undefined) {
      config.startX = ParseValue(startX, gameObject.x);
      config.endX = gameObject.x;
    }
    if (startY !== undefined) {
      config.startY = ParseValue(startY, gameObject.y);
      config.endY = gameObject.y;
    }
    config.duration = duration;
    config.ease = ease === undefined ? 'Linear' : ease;
    if (easeMove === undefined) {
      easeMove = new EaseMove(gameObject, config);
    } else {
      easeMove.resetFromJSON(config);
    }
    easeMove.restart();
    return easeMove;
  };

  var IsPlainObject$v = Phaser.Utils.Objects.IsPlainObject;
  var DistanceBetween$5 = Phaser.Math.Distance.Between;
  var OnInitEaseMove = function OnInitEaseMove(gameObject, easeMove) {
    // Route 'complete' of easeMove to gameObject
    easeMove.completeEventName = undefined;
    easeMove.on('complete', function () {
      if (easeMove.completeEventName) {
        gameObject.emit(easeMove.completeEventName, gameObject);
        easeMove.completeEventName = undefined;
      }
    });

    // Update local state
    easeMove.on('update', function () {
      var parent = GetParentSizerMethods.getParentSizer(gameObject);
      if (parent) {
        parent.resetChildPositionState(gameObject);
      }
    });
  };
  var EaseMoveMethods = {
    moveFrom: function moveFrom(duration, x, y, ease, destroyMode) {
      if (IsPlainObject$v(duration)) {
        var config = duration;
        x = config.x;
        y = config.y;
        if (config.hasOwnProperty('speed')) {
          duration = DistanceBetween$5(x, y, this.x, this.y) * 1000 / config.speed;
        } else {
          duration = config.duration;
        }
        ease = config.ease;
      }
      var isInit = this._easeMove === undefined;
      this._easeMove = EaseMoveFrom(this, duration, x, y, ease, destroyMode, this._easeMove);
      if (isInit) {
        OnInitEaseMove(this, this._easeMove);
      }
      this._easeMove.completeEventName = 'movefrom.complete';
      return this;
    },
    moveFromPromise: function moveFromPromise(duration, x, y, ease, destroyMode) {
      this.moveFrom(duration, x, y, ease, destroyMode);
      return WaitComplete(this._easeMove);
    },
    moveFromDestroy: function moveFromDestroy(duration, x, y, ease) {
      this.moveFrom(duration, x, y, ease, true);
      return this;
    },
    moveFromDestroyPromise: function moveFromDestroyPromise(duration, x, y, ease) {
      this.moveFromDestroy(duration, x, y, ease);
      return WaitComplete(this._easeMove);
    },
    moveTo: function moveTo(duration, x, y, ease, destroyMode) {
      if (IsPlainObject$v(duration)) {
        var config = duration;
        x = config.x;
        y = config.y;
        if (config.hasOwnProperty('speed')) {
          duration = DistanceBetween$5(x, y, this.x, this.y) * 1000 / config.speed;
        } else {
          duration = config.duration;
        }
        ease = config.ease;
      }
      var isInit = this._easeMove === undefined;
      this._easeMove = EaseMoveTo(this, duration, x, y, ease, destroyMode, this._easeMove);
      if (isInit) {
        OnInitEaseMove(this, this._easeMove);
      }
      this._easeMove.completeEventName = 'moveto.complete';
      return this;
    },
    moveToPromise: function moveToPromise(duration, x, y, ease, destroyMode) {
      this.moveTo(duration, x, y, ease, destroyMode);
      return WaitComplete(this._easeMove);
    },
    moveToDestroy: function moveToDestroy(duration, x, y, ease) {
      this.moveTo(duration, x, y, ease, true);
      return this;
    },
    moveToDestroyPromise: function moveToDestroyPromise(duration, x, y, ease) {
      this.moveToDestroy(duration, x, y, ease, true);
      return WaitComplete(this._easeMove);
    },
    moveStop: function moveStop(toEnd) {
      if (!this._easeMove) {
        return this;
      }
      this._easeMove.stop(toEnd);
      return this;
    }
  };

  var GetValue$2k = Phaser.Utils.Objects.GetValue;
  var ShakePosition = /*#__PURE__*/function (_TickTask) {
    _inherits(ShakePosition, _TickTask);
    function ShakePosition(gameObject, config) {
      var _this;
      _classCallCheck(this, ShakePosition);
      _this = _callSuper(this, ShakePosition, [gameObject, config]);
      // this.parent = gameObject;

      _this.timer = new Timer$1();
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(ShakePosition, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.timer.resetFromJSON(GetValue$2k(o, 'timer'));
        this.setEnable(GetValue$2k(o, 'enable', true));
        this.setMode(GetValue$2k(o, 'mode', 1));
        this.isRunning = GetValue$2k(o, 'isRunning', false);
        this.setMagnitudeMode(GetValue$2k(o, 'magnitudeMode', 1));
        this.setAxisMode(GetValue$2k(o, "axis", 0));
        this.setDuration(GetValue$2k(o, 'duration', 500));
        this.setMagnitude(GetValue$2k(o, 'magnitude', 10));
        this.ox = GetValue$2k(o, 'ox', undefined);
        this.oy = GetValue$2k(o, 'oy', undefined);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          timer: this.timer.toJSON(),
          enable: this.enable,
          mode: this.mode,
          isRunning: this.isRunning,
          magnitudeMode: magnitudeMode,
          duration: this.duration,
          magnitude: this.magnitude,
          ox: this.ox,
          oy: this.oy
        };
      }

      // override
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        _get(_getPrototypeOf(ShakePosition.prototype), "shutdown", this).call(this, fromScene);
        this.timer.destroy();
        this.timer = undefined;
      }
    }, {
      key: "startTicking",
      value: function startTicking() {
        _get(_getPrototypeOf(ShakePosition.prototype), "startTicking", this).call(this);
        if (this.mode === 0) {
          // Effect mode
          this.scene.game.events.on('poststep', this.update, this);
          this.scene.game.events.on('prestep', this.backToOrigin, this);
        } else {
          // Behavior Mode
          this.scene.sys.events.on('preupdate', this.update, this);
        }
      }
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        _get(_getPrototypeOf(ShakePosition.prototype), "stopTicking", this).call(this);
        if (this.scene) {
          // Scene might be destoryed
          if (this.mode === 0) {
            // Effect mode
            this.scene.game.events.off('poststep', this.update, this);
            this.scene.game.events.off('prestep', this.backToOrigin, this);
          } else {
            // Behavior Mode
            this.scene.sys.events.off('preupdate', this.update, this);
          }
        }
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e == undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(mode) {
        if (typeof mode === 'string') {
          mode = MODE[mode];
        }
        this.mode = mode;
        return this;
      }
    }, {
      key: "setMagnitudeMode",
      value: function setMagnitudeMode(magnitudeMode) {
        if (typeof magnitudeMode === 'string') {
          magnitudeMode = MANITUDEMODE[magnitudeMode];
        }
        this.magnitudeMode = magnitudeMode;
        return this;
      }
    }, {
      key: "setAxisMode",
      value: function setAxisMode(m) {
        if (typeof m === 'string') {
          m = DIRECTIONNODE[m];
        }
        this.axisMode = m;
        return this;
      }
    }, {
      key: "setDuration",
      value: function setDuration(duration) {
        this.duration = duration;
        return this;
      }
    }, {
      key: "setMagnitude",
      value: function setMagnitude(magnitude) {
        this.magnitude = magnitude;
        return this;
      }
    }, {
      key: "start",
      value: function start(duration, magnitude) {
        if (typeof duration !== 'number') {
          var config = duration;
          magnitude = GetValue$2k(config, 'magnitude', undefined);
          duration = GetValue$2k(config, 'duration', undefined);
        }
        if (magnitude !== undefined) {
          this.setMagnitude(magnitude);
        }
        if (duration !== undefined) {
          this.setDuration(duration);
        }
        this.timer.setDuration(this.duration).start();
        _get(_getPrototypeOf(ShakePosition.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "shake",
      value: function shake(duration, magnitude) {
        this.start(duration, magnitude);
        return this;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (!this.isRunning || !this.enable) {
          return this;
        }
        var gameObject = this.parent;
        if (!gameObject.active) {
          return this;
        }
        this.timer.update(time, delta);
        if (this.timer.isDone) {
          this.backToOrigin();
          this.complete();
        } else {
          if (this.ox === undefined) {
            this.ox = gameObject.x;
            this.oy = gameObject.y;
          }
          var magnitude = this.magnitude;
          if (this.magnitudeMode === 1)
            // decay
            {
              magnitude *= 1 - this.timer.t;
            }
          var a = Math.random() * Math.PI * 2;
          var x = this.ox + Math.cos(a) * magnitude;
          var y = this.oy + Math.sin(a) * magnitude;
          switch (this.axisMode) {
            case 1:
              gameObject.x = x;
              break;
            case 2:
              gameObject.y = y;
              break;
            default:
              gameObject.x = x;
              gameObject.y = y;
              break;
          }
        }
        return this;
      }
    }, {
      key: "backToOrigin",
      value: function backToOrigin() {
        if (!this.isRunning || !this.enable) {
          return this;
        }
        if (this.ox === undefined) {
          return this;
        }
        var gameObject = this.parent;
        switch (this.axisMode) {
          case 1:
            gameObject.x = this.ox;
            break;
          case 2:
            gameObject.y = this.oy;
            break;
          default:
            gameObject.x = this.ox;
            gameObject.y = this.oy;
            break;
        }
        this.ox = undefined;
        this.oy = undefined;
        return this;
      }
    }]);
    return ShakePosition;
  }(TickTask);
  var MODE = {
    effect: 0,
    behavior: 1
  };
  var DIRECTIONNODE = {
    'both': 0,
    'h&v': 0,
    'x&y': 0,
    'horizontal': 1,
    'h': 1,
    'x': 1,
    'vertical': 2,
    'v': 2,
    'y': 2
  };
  var MANITUDEMODE = {
    constant: 0,
    decay: 1
  };

  var IsPlainObject$u = Phaser.Utils.Objects.IsPlainObject;
  var OnInitShake = function OnInitShake(gameObject, shake) {
    // Route 'complete' of shake to gameObject
    shake.on('complete', function () {
      gameObject.emit('shake.complete', gameObject);
    });

    // Shake effect won't change position
  };
  var ShakeMethods = {
    shake: function shake(duration, magnitude, magnitudeMode) {
      if (IsPlainObject$u(duration)) {
        var config = duration;
        duration = config.duration;
        magnitude = config.magnitude;
        magnitudeMode = config.magnitudeMode;
      }
      if (this._shake === undefined) {
        this._shake = new ShakePosition(this, {
          mode: 0,
          magnitudeMode: 1
        });
        OnInitShake(this, this._shake);
      }
      if (duration !== undefined) {
        this._shake.setDuration(duration);
      }
      if (magnitude !== undefined) {
        this._shake.setMagnitude(magnitude);
      }
      if (magnitudeMode !== undefined) {
        this._shake.setMagnitudeMode(magnitudeMode);
      }
      this._shake.shake();
      return this;
    },
    shakePromise: function shakePromise(duration, alpha) {
      this.shake(duration, alpha);
      return WaitComplete(this._shake);
    }
  };

  var IsPlainObject$t = Phaser.Utils.Objects.IsPlainObject;
  var EaseData = /*#__PURE__*/function (_ComponentBase) {
    _inherits(EaseData, _ComponentBase);
    function EaseData(parent, config) {
      var _this;
      _classCallCheck(this, EaseData);
      _this = _callSuper(this, EaseData, [parent, config]);
      _this.parent.setDataEnabled();
      _this.easeTasks = {};
      return _this;
    }
    _createClass(EaseData, [{
      key: "complete",
      value: function complete(key) {
        this.emit("complete-".concat(key), this.parent, this);
        this.emit('complete', key, this.parent, this);
      }
    }, {
      key: "getEaseTask",
      value: function getEaseTask(key) {
        var easeTask = this.easeTasks[key];
        if (easeTask === undefined) {
          easeTask = new EaseValueTask(this.parent);
          this.easeTasks[key] = easeTask;
          easeTask.setTarget(this.parent.data.values).on('complete', function () {
            this.complete(key);
          }, this);
        }
        return easeTask;
      }
    }, {
      key: "easeTo",
      value: function easeTo(key, value, duration, ease) {
        if (IsPlainObject$t(key)) {
          var config = key;
          key = config.key;
          value = config.value;
          duration = config.duration;
          ease = config.ease;
          var speed = config.speed;
          if (duration === undefined && speed !== undefined) {
            duration = Math.abs(value - this.parent.data.values[key]) / speed * 1000;
          }
        }
        if (duration === undefined) {
          duration = 1000;
        }
        if (ease === undefined) {
          ease = 'Linear';
        }
        var easeTask = this.getEaseTask(key);
        easeTask.restart({
          key: key,
          to: value,
          duration: duration,
          ease: ease
        });
        return this;
      }
    }, {
      key: "easeFrom",
      value: function easeFrom(key, value, duration, ease) {
        if (IsPlainObject$t(key)) {
          var config = key;
          key = config.key;
          value = config.value;
          duration = config.duration;
          ease = config.ease;
          var speed = config.speed;
          if (duration === undefined && speed !== undefined) {
            duration = Math.abs(value - this.parent.data.values[key]) / speed * 1000;
          }
        }
        if (duration === undefined) {
          duration = 1000;
        }
        if (ease === undefined) {
          ease = 'Linear';
        }
        var easeTask = this.getEaseTask(key);
        easeTask.restart({
          key: key,
          from: value,
          duration: duration,
          ease: ease
        });
        return this;
      }
    }, {
      key: "stopEase",
      value: function stopEase(key, toEnd) {
        if (toEnd === undefined) {
          toEnd = true;
        }
        var easeTask = this.easeTasks[key];
        if (easeTask) {
          easeTask.stop(toEnd);
        }
        return this;
      }
    }, {
      key: "stopAll",
      value: function stopAll(toEnd) {
        if (toEnd === undefined) {
          toEnd = true;
        }
        for (var key in this.easeTasks) {
          this.stopEase(key, toEnd);
        }
        return this;
      }
    }]);
    return EaseData;
  }(ComponentBase);

  var OnInitEaseData = function OnInitEaseData(gameObject, easeData) {
    // Route 'complete' of easeData to gameObject
    easeData.on('complete', function (key) {
      gameObject.emit("easedata.".concat(key, ".complete"), gameObject);
      gameObject.emit('easedata.complete', key, gameObject);
    });
  };
  var EaseDataMethods = {
    easeDataTo: function easeDataTo(key, value, duration, ease) {
      if (!this._easeData) {
        this._easeData = new EaseData(this);
        OnInitEaseData(this, this._easeData);
      }
      this._easeData.easeTo(key, value, duration, ease);
      return this;
    },
    easeDataToPromise: function easeDataToPromise(key, value, duration, ease) {
      this.easeDataTo(key, value, duration, ease);
      return WaitEvent(this._easeData, "complete-".concat(key));
    },
    stopEaseData: function stopEaseData(key, toEnd) {
      if (!this._easeData) {
        return this;
      }
      this._easeData.stopEase(key, toEnd);
      return this;
    },
    stopAllEaseData: function stopAllEaseData(toEnd) {
      if (!this._easeData) {
        return this;
      }
      this._easeData.stopAll(toEnd);
      return this;
    }
  };

  var Show = function Show(gameObject) {
    _hide(gameObject, false);
  };
  var Hide = function Hide(gameObject) {
    _hide(gameObject, true);
  };
  var IsShown = function IsShown(gameObject) {
    if (!gameObject) {
      return false;
    }
    var config = GetSizerConfig$1(gameObject);
    return !config.hidden;
  };
  var _hide = function _hide(gameObject, hidden) {
    if (!gameObject) {
      return;
    }
    var config = GetSizerConfig$1(gameObject);
    config.hidden = hidden;
    var parent = GetParent$1(gameObject);
    if (parent) {
      parent.setChildVisible(gameObject, !hidden);
    } else {
      gameObject.setVisible(!hidden);
    }
  };

  var HideMethods = {
    show: function show(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      Show(gameObject);
      return this;
    },
    hide: function hide(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      Hide(gameObject);
      return this;
    },
    isShow: function isShow(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      return IsShown(gameObject);
    }
  };

  var StateProperties$1 = ['next', 'exit', 'enter'];
  var FSM$1 = /*#__PURE__*/function () {
    /*
    var config = {
        start: 'A',   // default: undefined
        states: {
            A: {
                next: 'B',  // function() { return 'B'; }
                enter: function() {},
                exit: function() {},
            },
            // ...
        },        
        extend: {
            i: 0,
            name: 'abc'
            // ...
        },
        init: function() {},
        enable: true,
        eventEmitter: true,
    };
    */
    function FSM(config) {
      _classCallCheck(this, FSM);
      // Attach get-next-state function
      var states = GetValue$38(config, 'states', undefined);
      if (states) {
        this.addStates(states);
      }

      // Attach extend members
      var extend = GetValue$38(config, 'extend', undefined);
      if (extend) {
        for (var name in extend) {
          if (!this.hasOwnProperty(name) || this[name] === undefined) {
            this[name] = extend[name];
          }
        }
      }

      // Event emitter
      var eventEmitter = GetValue$38(config, 'eventEmitter', undefined);
      var EventEmitterClass = GetValue$38(config, 'EventEmitterClass', undefined);
      this.setEventEmitter(eventEmitter, EventEmitterClass);
      this._stateLock = false;
      this.resetFromJSON(config);
    }
    _createClass(FSM, [{
      key: "shutdown",
      value: function shutdown() {
        this.destroyEventEmitter();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.shutdown();
      }
    }, {
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setEnable(GetValue$38(o, 'enable', true));
        this.start(GetValue$38(o, 'start', undefined));
        var init = GetValue$38(o, 'init', undefined);
        if (init) {
          init.call(this);
        }
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          curState: this.state,
          prevState: this.prevState,
          enable: this.enable,
          start: this._start
        };
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "state",
      get: function get() {
        return this._state;
      },
      set: function set(newState) {
        if (!this.enable || this._stateLock) {
          return;
        }
        if (this._state === newState) {
          return;
        }
        this._prevState = this._state;
        this._state = newState;
        this._stateLock = true; // lock state

        this.emit('statechange', this);
        if (this._prevState != null) {
          var exitEventName = 'exit_' + this._prevState;
          var exitCallback = this[exitEventName];
          if (exitCallback) {
            exitCallback.call(this);
          }
          this.emit(exitEventName, this);
        }
        this._stateLock = false;
        if (this._state != null) {
          var enterEventName = 'enter_' + this._state;
          var enterCallback = this[enterEventName];
          if (enterCallback) {
            enterCallback.call(this);
          }
          this.emit(enterEventName, this);
        }
      }
    }, {
      key: "prevState",
      get: function get() {
        return this._prevState;
      }
    }, {
      key: "start",
      value: function start(state) {
        this._start = state;
        this._prevState = undefined;
        this._state = state; // Won't fire statechange events
        return this;
      }
    }, {
      key: "goto",
      value: function goto(nextState) {
        if (nextState != null) {
          this.state = nextState;
        }
        return this;
      }
    }, {
      key: "next",
      value: function next() {
        var nextState;
        var getNextState = this['next_' + this.state];
        if (getNextState) {
          if (typeof getNextState === 'string') {
            nextState = getNextState;
          } else {
            nextState = getNextState.call(this);
          }
        }
        this["goto"](nextState);
        return this;
      }
    }, {
      key: "stateProperties",
      get: function get() {
        return StateProperties$1;
      }
    }, {
      key: "addState",
      value: function addState(name, state) {
        if (typeof name !== 'string') {
          state = name;
          name = state.name;
        }
        var stateProperties = this.stateProperties;
        for (var i = 0, cnt = stateProperties.length; i < cnt; i++) {
          var propertyName = stateProperties[i];
          var propertyValue = state[propertyName];
          if (propertyValue) {
            this["".concat(propertyName, "_").concat(name)] = propertyValue;
          }
        }
        return this;
      }
    }, {
      key: "addStates",
      value: function addStates(states) {
        if (Array.isArray(states)) {
          for (var i = 0, cnt = states.length; i < cnt; i++) {
            this.addState(states[i]);
          }
        } else {
          for (var name in states) {
            this.addState(name, states[name]);
          }
        }
        return this;
      }
    }, {
      key: "runMethod",
      value: function runMethod(methodName, a1, a2, a3, a4, a5) {
        var fn = this[methodName + '_' + this.state];
        if (!fn) {
          return undefined;
        }

        // Copy from eventemitter3
        var len = arguments.length;
        switch (len) {
          case 1:
            return fn.call(this);
          case 2:
            return fn.call(this, a1);
          case 3:
            return fn.call(this, a1, a2);
          case 4:
            return fn.call(this, a1, a2, a3);
          case 5:
            return fn.call(this, a1, a2, a3, a4);
          case 6:
            return fn.call(this, a1, a2, a3, a4, a5);
        }
        var args = new Array(len - 1);
        for (var i = 1; i < len; i++) {
          args[i - 1] = arguments[i];
        }
        return fn.apply(this, args);
      }
    }]);
    return FSM;
  }();
  Object.assign(FSM$1.prototype, EventEmitterMethods);

  var HasListener = function HasListener(eventEmitter, eventName, fn, context, once) {
    if (once === undefined) {
      once = false;
    }
    var listeners = eventEmitter._events[eventName];
    if (!listeners) {
      return false;
    }
    for (var i = 0, cnt = listeners.length; i < cnt; i++) {
      var listener = listeners[i];
      if (listener.fn === fn && listener.context === context && listener.once === once) {
        return true;
      }
    }
    return false;
  };

  var StateProperties = ['next', 'exit', 'enter', 'update', 'preupdate', 'postupdate'];
  var FSM = /*#__PURE__*/function (_FSMBase) {
    _inherits(FSM, _FSMBase);
    function FSM() {
      _classCallCheck(this, FSM);
      return _callSuper(this, FSM, arguments);
    }
    _createClass(FSM, [{
      key: "shutdown",
      value:
      /*
      var config = {
          start: 'A',   // default: undefined
          states: {
              A: {
                  next: 'B',  // function() { return 'B'; }
                  enter: function() {},
                  exit: function() {},
                  update: function(time, delta) {},
                  preupdate: function(time, delta) {},
                  postupdate: function(time, delta) {},
              },
              // ...
          },        
          extend: {
              i: 0,
              name: 'abc'
              // ...
          },
          init: function() {},
          enable: true,
          scene: undefined,
          eventEmitter: true,
      };
      */
      function shutdown() {
        this.stopUpdate();
        this.stopPreUpdate();
        this.stopPostUpdate();
        this._scene = undefined;
        _get(_getPrototypeOf(FSM.prototype), "shutdown", this).call(this);
      }
    }, {
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(FSM.prototype), "resetFromJSON", this).call(this, o);
        this._scene = GetValue$38(o, 'scene', undefined);
        return this;
      }
    }, {
      key: "stateProperties",
      get: function get() {
        return StateProperties;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        this.runMethod('update', time, delta);
      }
    }, {
      key: "preupdate",
      value: function preupdate(time, delta) {
        this.runMethod('preupdate', time, delta);
      }
    }, {
      key: "postupdate",
      value: function postupdate(time, delta) {
        this.runMethod('postupdate', time, delta);
      }
    }, {
      key: "startUpdate",
      value: function startUpdate(scene) {
        if (!scene) {
          scene = this._scene;
        }
        var eventEmitter = scene.sys.events;
        if (HasListener(eventEmitter, 'update', this.update, this)) {
          return this;
        }
        this._scene = scene;
        eventEmitter.on('update', this.update, this);
        return this;
      }
    }, {
      key: "stopUpdate",
      value: function stopUpdate() {
        if (!this._scene) {
          return this;
        }
        this._scene.sys.events.off('update', this.update, this);
        return this;
      }
    }, {
      key: "startPreUpdate",
      value: function startPreUpdate(scene) {
        if (!scene) {
          scene = this._scene;
        }
        var eventEmitter = scene.sys.events;
        if (HasListener(eventEmitter, 'preupdate', this.preupdate, this)) {
          return this;
        }
        this._scene = scene;
        eventEmitter.on('preupdate', this.preupdate, this);
        return this;
      }
    }, {
      key: "stopPreUpdate",
      value: function stopPreUpdate() {
        if (!this._scene) {
          return this;
        }
        this._scene.sys.events.off('preupdate', this.preupdate, this);
        return this;
      }
    }, {
      key: "startPostUpdate",
      value: function startPostUpdate(scene) {
        if (!scene) {
          scene = this._scene;
        }
        var eventEmitter = scene.sys.events;
        if (HasListener(eventEmitter, 'postupdate', this.postupdate, this)) {
          return this;
        }
        this._scene = scene;
        eventEmitter.on('postupdate', this.postupdate, this);
        return this;
      }
    }, {
      key: "stopPostUpdate",
      value: function stopPostUpdate() {
        if (!this._scene) {
          return this;
        }
        this._scene.sys.events.off('postupdate', this.postupdate, this);
        return this;
      }
    }]);
    return FSM;
  }(FSM$1);

  /*
  graph TD

  IDLE --> |"requestOpen()"| TRANS_OPNE["TRAN_OPEN<br>runTransitionInCallback()"]
  TRANS_OPNE --> |transitInTime| OPEN
  OPEN --> |"requestClose()"| TRANS_CLOSE["TRANS_CLOSE<br>runTransitionOutCallback()"]
  TRANS_CLOSE --> |transitOutTime| CLOSE
  CLOSE --> |"requestOpen()"| TRANS_OPNE
  */
  var State$1 = /*#__PURE__*/function (_FSM) {
    _inherits(State, _FSM);
    function State(parent, config) {
      var _this;
      _classCallCheck(this, State);
      _this = _callSuper(this, State, [config]);
      _this.parent = parent;
      var initState = config.initState || 'IDLE';
      _this.start(initState);
      return _this;
    }
    _createClass(State, [{
      key: "init",
      value: function init() {
        this.start('IDLE');
      }

      // IDLE -> TRANS_OPNE
    }, {
      key: "next_IDLE",
      value: function next_IDLE() {
        return 'TRANS_OPNE';
      }
      // IDLE

      // TRANS_OPNE -> OPEN
    }, {
      key: "next_TRANS_OPNE",
      value: function next_TRANS_OPNE() {
        return 'OPEN';
      }
    }, {
      key: "enter_TRANS_OPNE",
      value: function enter_TRANS_OPNE() {
        var transitionBehavior = this.parent;
        if (transitionBehavior.transitInTime > 0) {
          var delay = transitionBehavior.runTransitionInCallback();
          transitionBehavior.delayCall(delay, this.next, this);
        } else {
          this.next();
        }
      }
    }, {
      key: "exit_TRANS_OPNE",
      value: function exit_TRANS_OPNE() {
        var transitionBehavior = this.parent;
        transitionBehavior.removeDelayCall();
      }
      // TRANS_OPNE

      // OPEN -> TRANS_CLOSE
    }, {
      key: "next_OPEN",
      value: function next_OPEN() {
        return 'TRANS_CLOSE';
      }
    }, {
      key: "enter_OPEN",
      value: function enter_OPEN() {
        var transitionBehavior = this.parent;
        transitionBehavior.onOpen();
      }
    }, {
      key: "exit_OPEN",
      value: function exit_OPEN() {
        var transitionBehavior = this.parent;
        transitionBehavior.removeDelayCall();
      }
      // OPEN

      // TRANS_CLOSE -> CLOSE
    }, {
      key: "next_TRANS_CLOSE",
      value: function next_TRANS_CLOSE() {
        return 'CLOSE';
      }
    }, {
      key: "enter_TRANS_CLOSE",
      value: function enter_TRANS_CLOSE() {
        var transitionBehavior = this.parent;
        if (transitionBehavior.transitOutTime > 0) {
          var delay = transitionBehavior.runTransitionOutCallback();
          transitionBehavior.delayCall(delay, this.next, this);
        } else {
          this.next();
        }
      }
    }, {
      key: "exit_TRANS_CLOSE",
      value: function exit_TRANS_CLOSE() {
        var transitionBehavior = this.parent;
        transitionBehavior.removeDelayCall();
      }
      // TRANS_CLOSE

      // CLOSE -> TRANS_OPNE
    }, {
      key: "next_CLOSE",
      value: function next_CLOSE() {
        return 'TRANS_OPNE';
      }
    }, {
      key: "enter_CLOSE",
      value: function enter_CLOSE() {
        var transitionBehavior = this.parent;
        transitionBehavior.onClose();
      }
    }, {
      key: "exit_CLOSE",
      value: function exit_CLOSE() {}
      // CLOSE
    }, {
      key: "canOpen",
      value: function canOpen() {
        return this.state === 'IDLE' || this.state === 'CLOSE';
      }
    }, {
      key: "canClose",
      value: function canClose() {
        return this.state === 'IDLE' || this.state === 'OPEN';
      }
    }]);
    return State;
  }(FSM);

  var PostStepDelayCall = function PostStepDelayCall(gameObject, delay, callback, scope, args) {
    // Invoke callback under game's 'poststep' event
    var scene = GetSceneObject(gameObject);
    var timer = scene.time.delayedCall(delay, function () {
      scene.game.events.once('poststep', function () {
        callback.call(scope, args);
      });
    });
    return timer;
  };

  var DelayCallMethods$1 = {
    delayCall: function delayCall(delay, callback, scope) {
      // Invoke callback under scene's 'postupdate' event
      this.delayCallTimer = PostStepDelayCall(this, delay, callback, scope);
      return this;
    },
    removeDelayCall: function removeDelayCall() {
      if (this.delayCallTimer) {
        this.delayCallTimer.remove(false);
        this.delayCallTimer = undefined;
      }
      return this;
    }
  };

  var ConfigurationMethods$2 = {
    setTransitInTime: function setTransitInTime(time) {
      this.transitInTime = time;
      return this;
    },
    setTransitOutTime: function setTransitOutTime(time) {
      this.transitOutTime = time;
      return this;
    },
    setTransitInCallback: function setTransitInCallback(callback) {
      if (!callback) {
        callback = NOOP;
      }
      this.transitInCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    },
    setTransitOutCallback: function setTransitOutCallback(callback) {
      if (!callback) {
        callback = NOOP;
      }
      this.transitOutCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    }
  };

  var OpenMethods$1 = {
    // Override
    runTransitionInCallback: function runTransitionInCallback() {
      this.transitInCallback(this.parent, this.transitInTime);
      return this.transitInTime;
    },
    // Override
    onOpen: function onOpen() {},
    requestOpen: function requestOpen(openEventData, duration) {
      if (!this._state.canOpen()) {
        return this;
      }
      this.openEventData = arguments.length > 0 ? openEventData : this.parent;
      var transitionTimeSave = this.transitInTime;
      if (duration !== undefined) {
        this.transitInTime = duration;
      }
      this._state["goto"]('TRANS_OPNE');
      this.transitInTime = transitionTimeSave;
      return this;
    }
  };

  var CloseMethods = {
    // Override
    runTransitionOutCallback: function runTransitionOutCallback() {
      this.transitOutCallback(this.parent, this.transitOutTime);
      return this.transitOutTime;
    },
    // Override
    onClose: function onClose() {
      // Destroy parent and this behavior
      if (this.oneShotMode) {
        this.parent.destroy();
        // Will invoke `this.destroy()`
      }
    },
    requestClose: function requestClose(closeEventData, duration) {
      if (!this._state.canClose) {
        return this;
      }
      this.closeEventData = arguments.length > 0 ? closeEventData : this.parent;
      var transitionTimeSave = this.transitOutTime;
      if (duration !== undefined) {
        this.transitOutTime = duration;
      }
      this._state["goto"]('TRANS_CLOSE');
      this.transitOutTime = transitionTimeSave;
      return this;
    }
  };

  var methods$t = {};
  Object.assign(methods$t, DelayCallMethods$1, ConfigurationMethods$2, OpenMethods$1, CloseMethods);

  var GetValue$2j = Phaser.Utils.Objects.GetValue;
  var OpenCloseTransition = /*#__PURE__*/function (_ComponentBase) {
    _inherits(OpenCloseTransition, _ComponentBase);
    function OpenCloseTransition(gameObject, config) {
      var _this;
      _classCallCheck(this, OpenCloseTransition);
      _this = _callSuper(this, OpenCloseTransition, [gameObject, config]);
      // this.parent = gameObject;
      // this.scene

      _this.setTransitInTime(GetValue$2j(config, 'duration.in', 200));
      _this.setTransitOutTime(GetValue$2j(config, 'duration.out', 200));
      _this.setTransitInCallback(GetValue$2j(config, 'transitIn'));
      _this.setTransitOutCallback(GetValue$2j(config, 'transitOut'));
      _this.oneShotMode = GetValue$2j(config, 'destroy', false);
      _this.delayCallTimer = undefined;
      _this._state = new State$1(_assertThisInitialized(_this), {
        eventEmitter: false,
        initState: GetValue$2j(config, 'initState', 'IDLE')
      });
      _this.openEventData = undefined;
      _this.closeEventData = undefined;
      return _this;
    }
    _createClass(OpenCloseTransition, [{
      key: "state",
      get: function get() {
        return this._state.state;
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        this.transitInCallback = undefined;
        this.transitOutCallback = undefined;
        this.openEventData = undefined;
        this.closeEventData = undefined;
        this.removeDelayCall();
        _get(_getPrototypeOf(OpenCloseTransition.prototype), "shutdown", this).call(this, fromScene);
      }
    }]);
    return OpenCloseTransition;
  }(ComponentBase);
  Object.assign(OpenCloseTransition.prototype, methods$t);

  var GetFirstRenderCamera = function GetFirstRenderCamera(scene, gameObject) {
    var cameras = scene.sys.cameras.cameras;
    var camera, cameraFilter, isCameraIgnore;
    for (var i = 0, cnt = cameras.length; i < cnt; i++) {
      camera = cameras[i];
      cameraFilter = gameObject.cameraFilter;
      isCameraIgnore = cameraFilter !== 0 && cameraFilter & camera.id;
      if (!isCameraIgnore) {
        return camera;
      }
    }
    return null;
  };

  var FullWindow = /*#__PURE__*/function (_ComponentBase) {
    _inherits(FullWindow, _ComponentBase);
    function FullWindow(gameObject, config) {
      var _this;
      _classCallCheck(this, FullWindow);
      _this = _callSuper(this, FullWindow, [gameObject]);
      // this.parent = gameObject;

      gameObject.setOrigin(0.5).setScrollFactor(0);
      _this.targetCamera = undefined;
      _this.boot();
      return _this;
    }
    _createClass(FullWindow, [{
      key: "boot",
      value: function boot() {
        this.scene.sys.events.on('prerender', this.resize, this);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (!this.scene) {
          return;
        }
        this.scene.sys.events.off('prerender', this.resize, this);
        _get(_getPrototypeOf(FullWindow.prototype), "destroy", this).call(this);
      }
    }, {
      key: "getTargetCamera",
      value: function getTargetCamera() {
        var gameObject = this.parent;
        if (this.targetCamera) {
          var isCameraIgnore = gameObject.cameraFilter !== 0 && gameObject.cameraFilter & this.targetCamera.id;
          if (isCameraIgnore) {
            this.targetCamera = undefined;
          }
        }
        if (!this.targetCamera) {
          this.targetCamera = GetFirstRenderCamera(this.scene, gameObject);
        }
        return this.targetCamera;
      }
    }, {
      key: "resize",
      value: function resize() {
        var camera = this.getTargetCamera();
        if (!camera) {
          return;
        }
        var scene = this.scene;
        var gameObject = this.parent;
        var gameSize = scene.sys.scale.gameSize;
        var gameWidth = gameSize.width,
          gameHeight = gameSize.height,
          scale = 1 / camera.zoom;

        // Origin is fixed to (0.5,0.5)
        var x = gameWidth / 2,
          y = gameHeight / 2;
        var width = gameWidth * scale,
          height = gameHeight * scale;
        if (gameObject.x !== x || gameObject.y !== y) {
          gameObject.setPosition(x, y);
        }
        if (gameObject.width !== width || gameObject.height !== height) {
          gameObject.setSize(width, height);
        }
      }
    }]);
    return FullWindow;
  }(ComponentBase);

  var Rectangle = Phaser.GameObjects.Rectangle;
  var FullWindowRectangle = /*#__PURE__*/function (_Rectangle) {
    _inherits(FullWindowRectangle, _Rectangle);
    function FullWindowRectangle(scene, color, alpha) {
      var _this;
      _classCallCheck(this, FullWindowRectangle);
      _this = _callSuper(this, FullWindowRectangle, [scene, 0, 0, 2, 2, color, 1]);
      _this.fullWindow = new FullWindow(_assertThisInitialized(_this));
      _this.setAlpha(alpha);
      return _this;
    }
    _createClass(FullWindowRectangle, [{
      key: "tint",
      get: function get() {
        return this.fillColor;
      },
      set: function set(value) {
        this.setFillStyle(value, this.fillAlpha);
      }
    }]);
    return FullWindowRectangle;
  }(Rectangle);

  var GetValue$2i = Phaser.Utils.Objects.GetValue;
  var TouchEventStop = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TouchEventStop, _ComponentBase);
    function TouchEventStop(gameObject, config) {
      var _this;
      _classCallCheck(this, TouchEventStop);
      _this = _callSuper(this, TouchEventStop, [gameObject, {
        eventEmitter: false
      }]);
      // No event emitter
      // this.parent = gameObject;

      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(TouchEventStop, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setHitAreaMode(GetValue$2i(o, 'hitAreaMode', 0));
        this.setEnable(GetValue$2i(o, 'enable', true));
        this.setStopMode(GetValue$2i(o, 'stopAllLevels', true));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        this.parent.on('pointerdown', function (pointer, localX, localY, event) {
          if (this.stopAllLevels) {
            event.stopPropagation();
          }
        }, this).on('pointerup', function (pointer, localX, localY, event) {
          if (this.stopAllLevels) {
            event.stopPropagation();
          }
        }, this).on('pointermove', function (pointer, localX, localY, event) {
          if (this.stopAllLevels) {
            event.stopPropagation();
          }
        }, this).on('pointerover', function (pointer, localX, localY, event) {
          if (this.stopAllLevels) {
            event.stopPropagation();
          }
        }, this).on('pointerout', function (pointer, event) {
          if (this.stopAllLevels) {
            event.stopPropagation();
          }
        }, this);
      }
    }, {
      key: "setHitAreaMode",
      value: function setHitAreaMode(mode) {
        if (typeof mode === 'string') {
          mode = HitAreaMode[mode];
        }
        var gameObject = this.parent;
        if (gameObject.input) {
          gameObject.removeInteractive();
        }
        if (mode === 0) {
          gameObject.setInteractive();
        } else {
          gameObject.setInteractive({
            hitArea: {},
            hitAreaCallback: function hitAreaCallback() {
              return true;
            }
          });
        }
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        if (e) {
          this.parent.setInteractive();
        } else {
          this.parent.disableInteractive();
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "setStopMode",
      value: function setStopMode(allLevels) {
        if (allLevels === undefined) {
          allLevels = true;
        }
        this.stopAllLevels = allLevels;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }]);
    return TouchEventStop;
  }(ComponentBase);
  var HitAreaMode = {
    "default": 0,
    fullWindow: 1
  };

  var GetValue$2h = Phaser.Utils.Objects.GetValue;
  var Cover = /*#__PURE__*/function (_FullWindowRectangle) {
    _inherits(Cover, _FullWindowRectangle);
    function Cover(scene, config) {
      var _this;
      _classCallCheck(this, Cover);
      var fillColor = GetValue$2h(config, 'color', 0x0);
      var fillAlpha = GetValue$2h(config, 'alpha', 0.8);
      _this = _callSuper(this, Cover, [scene, fillColor, fillAlpha]);
      _this.touchEventStop = new TouchEventStop(_assertThisInitialized(_this), {
        hitAreaMode: 1
      });
      return _this;
    }
    return _createClass(Cover);
  }(FullWindowRectangle);

  var CreateCover = function CreateCover(gameObject, config) {
    var scene = gameObject.scene;
    var cover = new Cover(scene, config);
    scene.add.existing(cover);

    // Put cover behind game object
    if (gameObject.isRexContainerLite) {
      gameObject.pin(cover, {
        syncPosition: false,
        syncRotation: false,
        syncScale: false,
        syncAlpha: false,
        syncScrollFactor: false
      });
      gameObject.moveDepthBelow(cover);
    } else {
      scene.children.moveBelow(cover, gameObject);
    }
    return cover;
  };

  var DefaultTransitCallbacks$1 = {
    popUp: function popUp(gameObject, duration) {
      if (gameObject._modalScaleSave !== undefined) {
        gameObject.scaleX = gameObject._modalScaleSave;
        gameObject.scaleY = gameObject._modalScaleSave;
      } else {
        gameObject._modalScaleSave = gameObject.scaleX;
      }
      PopUp$1(gameObject, duration);
    },
    scaleDown: function scaleDown(gameObject, duration) {
      // Don't destroy here
      ScaleDownDestroy(gameObject, duration, undefined, undefined, false);
    },
    fadeIn: function fadeIn(gameObject, duration) {
      if (gameObject._modalAlphaSave !== undefined) {
        gameObject.alpha = gameObject._modalAlphaSave;
      } else {
        gameObject._modalAlphaSave = gameObject.alpha;
      }
      FadeIn(gameObject, duration);
    },
    fadeOut: function fadeOut(gameObject, duration) {
      // Don't destroy here
      FadeOutDestroy(gameObject, duration, false);
    }
  };

  var DefaultCoverTransitInCallback = function DefaultCoverTransitInCallback(cover, duration) {
    if (cover._modalAlphaSave !== undefined) {
      cover.alpha = cover._modalAlphaSave;
    } else {
      cover._modalAlphaSave = cover.alpha;
    }
    FadeIn(cover, duration, cover.alpha);
  };
  var DefaultCoverTransitOutCallback = function DefaultCoverTransitOutCallback(cover, duration) {
    FadeOutDestroy(cover, duration, false);
  };

  var IsPointInBounds = function IsPointInBounds(gameObject, x, y, preTest, postTest) {
    // Can't get bounds
    if (!gameObject) {
      return false;
    }
    if (preTest && !preTest(gameObject, x, y)) {
      return false;
    }
    var boundsRect = GetBounds(gameObject, true);
    if (!boundsRect.contains(x, y)) {
      return false;
    }
    if (postTest && !postTest(gameObject, x, y)) {
      return false;
    }
    return true;
  };

  var GetValue$2g = Phaser.Utils.Objects.GetValue;
  var Modal$2 = /*#__PURE__*/function (_OpenCloseTransition) {
    _inherits(Modal, _OpenCloseTransition);
    function Modal(gameObject, config) {
      var _this;
      _classCallCheck(this, Modal);
      if (config === undefined) {
        config = {};
      }
      if (config.transitIn == null) {
        config.transitIn = TransitionMode$1.popUp;
      }
      if (config.transitOut == null) {
        config.transitOut = TransitionMode$1.scaleDown;
      }
      config.destroy = GetValue$2g(config, 'destroy', true);
      _this = _callSuper(this, Modal, [gameObject, config]);
      // this.parent = gameObject;
      // this.scene

      // Cover : key of modal, to block touch input        
      var coverConfig = GetValue$2g(config, 'cover');
      _this.cover = coverConfig !== false ? CreateCover(gameObject, coverConfig) : undefined;
      if (_this.cover) {
        _this.setCoverTransitInCallback(GetValue$2g(coverConfig, 'transitIn', DefaultCoverTransitInCallback));
        _this.setCoverTransitOutCallback(GetValue$2g(coverConfig, 'transitOut', DefaultCoverTransitOutCallback));
      }

      // Close conditions:
      var touchOutsideClose = GetValue$2g(config, 'touchOutsideClose', false);
      var timeOutDuration = GetValue$2g(config, 'duration.hold', -1);
      var timeOutClose = GetValue$2g(config, 'timeOutClose', timeOutDuration >= 0);
      var anyTouchClose = GetValue$2g(config, 'anyTouchClose', false);
      var manualClose = GetValue$2g(config, 'manualClose', false);
      if (manualClose) {
        touchOutsideClose = false;
        anyTouchClose = false;
        timeOutClose = false;
      }
      if (anyTouchClose) {
        touchOutsideClose = false;
      }
      if (timeOutClose) {
        _this.setDisplayTime(timeOutDuration);
      } else {
        _this.setDisplayTime(-1);
      }

      // Registet touch-close event after opened
      if (anyTouchClose) {
        _this.once('open', _this.anyTouchClose, _assertThisInitialized(_this));
      } else if (touchOutsideClose) {
        _this.once('open', _this.touchOutsideClose, _assertThisInitialized(_this));
      }
      if (GetValue$2g(config, 'openOnStart', true)) {
        // Run this.requestOpen() next tick
        // User can register events before this.requestOpen()
        _this.delayCall(0, _this.requestOpen, _assertThisInitialized(_this));
      }
      return _this;
    }
    _createClass(Modal, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        // Registered in touchOutsideClose(), or anyTouchClose()
        if (!this.cover) {
          this.scene.input.off('pointerup', this.touchCloseCallback, this);
        }
        if (this.cover && !fromScene) {
          this.cover.destroy();
          this.cover = undefined;
        }
        _get(_getPrototypeOf(Modal.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "touchOutsideClose",
      value: function touchOutsideClose() {
        if (this.cover) {
          this.cover.on('pointerup', this.touchCloseCallback, this);
        } else {
          this.scene.input.on('pointerup', this.touchCloseCallback, this);
        }
        this.clickOutsideTest = true;
        return this;
      }
    }, {
      key: "anyTouchClose",
      value: function anyTouchClose() {
        if (this.cover) {
          this.cover.once('pointerup', this.touchCloseCallback, this);
        } else {
          this.scene.input.once('pointerup', this.touchCloseCallback, this);
        }
        return this;
      }
    }, {
      key: "touchCloseCallback",
      value: function touchCloseCallback(pointer) {
        if (this.clickOutsideTest && IsPointInBounds(this.parent, pointer.worldX, pointer.worldY)) {
          return;
        }
        this.requestClose();
      }
    }, {
      key: "runTransitionInCallback",
      value: function runTransitionInCallback() {
        var duration = _get(_getPrototypeOf(Modal.prototype), "runTransitionInCallback", this).call(this);
        var cover = this.cover;
        if (cover && this.coverTransitInCallback) {
          this.coverTransitInCallback(cover, duration);
        }
        return duration;
      }
    }, {
      key: "runTransitionOutCallback",
      value: function runTransitionOutCallback() {
        var duration = _get(_getPrototypeOf(Modal.prototype), "runTransitionOutCallback", this).call(this);
        var cover = this.cover;
        if (cover && this.coverTransitOutCallback) {
          this.coverTransitOutCallback(cover, duration);
        }
        return duration;
      }
    }, {
      key: "onOpen",
      value: function onOpen() {
        var duration = this.displayTime;
        if (duration >= 0) {
          this.delayCall(duration, this.requestClose,
          // callback
          this // scope
          );
        }
        this.emit('open', this.parent, this);
        _get(_getPrototypeOf(Modal.prototype), "onOpen", this).call(this);
      }
    }, {
      key: "onClose",
      value: function onClose() {
        this.emit('close', this.closeEventData);
        _get(_getPrototypeOf(Modal.prototype), "onClose", this).call(this);
      }
    }, {
      key: "setDisplayTime",
      value: function setDisplayTime(time) {
        this.displayTime = time;
        return this;
      }
    }, {
      key: "setTransitInCallback",
      value: function setTransitInCallback(callback) {
        if (typeof callback === 'string') {
          callback = TransitionMode$1[callback];
        }
        switch (callback) {
          case TransitionMode$1.popUp:
            callback = DefaultTransitCallbacks$1.popUp;
            break;
          case TransitionMode$1.fadeIn:
            callback = DefaultTransitCallbacks$1.fadeIn;
            break;
        }
        _get(_getPrototypeOf(Modal.prototype), "setTransitInCallback", this).call(this, callback);
        // callback = function(gameObject, duration) {}
        return this;
      }
    }, {
      key: "setTransitOutCallback",
      value: function setTransitOutCallback(callback) {
        if (typeof callback === 'string') {
          callback = TransitionMode$1[callback];
        }
        switch (callback) {
          case TransitionMode$1.scaleDown:
            callback = DefaultTransitCallbacks$1.scaleDown;
            break;
          case TransitionMode$1.fadeOut:
            callback = DefaultTransitCallbacks$1.fadeOut;
            break;
        }
        _get(_getPrototypeOf(Modal.prototype), "setTransitOutCallback", this).call(this, callback);
        // callback = function(gameObject, duration) {}
        return this;
      }
    }, {
      key: "setCoverTransitInCallback",
      value: function setCoverTransitInCallback(callback) {
        this.coverTransitInCallback = callback;
        return this;
      }
    }, {
      key: "setCoverTransitOutCallback",
      value: function setCoverTransitOutCallback(callback) {
        this.coverTransitOutCallback = callback;
        return this;
      }
    }]);
    return Modal;
  }(OpenCloseTransition);
  var TransitionMode$1 = {
    popUp: 0,
    fadeIn: 1,
    scaleDown: 0,
    fadeOut: 1
  };

  var Modal$1 = function Modal(gameObject, config) {
    var modalBehavior = new Modal$2(gameObject, config);

    // Route modal's 'open', 'close' event
    modalBehavior.on('open', function () {
      gameObject.emit('modal.open', modalBehavior);
    });
    modalBehavior.on('close', function (closeEventData) {
      gameObject.emit('modal.close', closeEventData, modalBehavior);
    });

    // Reigster 'modal.requestClose' event for invoking modalBehavior.requestClose() method
    gameObject.on('modal.requestClose', modalBehavior.requestClose, modalBehavior);
    /*
    It is not necessary to turn off gameObject's 'modal.requestClose' event because that :
      - If `config.destroy` is `undefined` (or `true), gameObject and modalBehavior will be destroyed
    - If `config.destroy` is `false` (for reusing dialog), keeping gameObject and modalBehavior 
    */

    return modalBehavior;
  };
  var ModalClose = function ModalClose(gameObject, closeEventData) {
    gameObject.emit('modal.requestClose', closeEventData);
  };

  var IsFunction = function IsFunction(obj) {
    return obj && typeof obj === 'function';
  };

  var ModalMethods$1 = {
    // Override
    // onCreateModalBehavior(self, config) { },
    modal: function modal(config, onClose) {
      if (IsFunction(config)) {
        onClose = config;
        config = undefined;
      }
      if (this._modalBehavior === undefined) {
        if (this.onCreateModalBehavior) {
          this.onCreateModalBehavior(this, config);
        }
        this._modalBehavior = Modal$1(this, config);
      }
      if (onClose) {
        this._modalBehavior.once('close', onClose);
      }
      this._modalBehavior.requestOpen();
      return this;
    },
    modalPromise: function modalPromise(config) {
      var self = this;
      return new Promise(function (resolve, reject) {
        self.modal(config, resolve);
      });
    },
    modalClose: function modalClose(closeEventData) {
      ModalClose(this, closeEventData);
      return this;
    }
  };

  var GetPointerWorldXY = function GetPointerWorldXY(pointer, mainCamera, out) {
    var camera = pointer.camera;
    if (!camera) {
      return null;
    }
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = globalOut$1;
    }
    if (camera === mainCamera) {
      out.x = pointer.worldX;
      out.y = pointer.worldY;
    } else {
      camera.getWorldPoint(pointer.x, pointer.y, out);
    }
    return out;
  };
  var globalOut$1 = {};

  var IsPointerInBounds = function IsPointerInBounds(gameObject, pointer, preTest, postTest) {
    var mainCamera = gameObject.scene.sys.cameras.main,
      worldXY;
    if (pointer) {
      worldXY = GetPointerWorldXY(pointer, mainCamera, true);
      if (!worldXY) {
        return false;
      }
      return IsPointInBounds(gameObject, worldXY.x, worldXY.y, preTest, postTest);
    } else {
      var inputManager = gameObject.scene.input.manager;
      var pointersTotal = inputManager.pointersTotal;
      var pointers = inputManager.pointers;
      for (var i = 0; i < pointersTotal; i++) {
        pointer = pointers[i];
        worldXY = GetPointerWorldXY(pointer, mainCamera, true);
        if (!worldXY) {
          continue;
        }
        if (IsPointInBounds(gameObject, worldXY.x, worldXY.y, preTest, postTest)) {
          return true;
        }
      }
      return false;
    }
  };

  var IsInTouching = function IsInTouching(pointer, gameObject) {
    if (IsGameObject(pointer) || typeof pointer === 'string') {
      gameObject = pointer;
      pointer = undefined;
    }
    if (gameObject === undefined) {
      gameObject = this;
    } else if (typeof gameObject === 'string') {
      gameObject = this.getElement(gameObject);
    }
    return IsPointerInBounds(gameObject, pointer);
  };

  var IsArray = function IsArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  var ContainsPoint = function ContainsPoint(gameObject, x, y, preTest, postTest) {
    return IsPointInBounds(gameObject, x, y, GetPreTestCallback(preTest), GetPostTestCallback(postTest));
  };
  var IsNotHiddenSizer = function IsNotHiddenSizer(gameObject) {
    var isHiddenSizer = gameObject.rexSizer && gameObject.rexSizer.hidden;
    return !isHiddenSizer;
  };
  var GetPreTestCallback = function GetPreTestCallback(preTest) {
    if (!preTest) {
      return IsNotHiddenSizer;
    }
    return function (gameObject, x, y) {
      if (!IsNotHiddenSizer(gameObject)) {
        return false;
      }
      preTest(gameObject, x, y);
      return true;
    };
  };
  var GetPostTestCallback = function GetPostTestCallback(postTest) {
    return postTest;
  };

  var PointToChild$1 = function PointToChild(x, y, preTest, postTest, children) {
    if (!IsFunction(preTest)) {
      children = preTest;
      preTest = undefined;
      postTest = undefined;
    }
    if (children === undefined) {
      if (this.sizerChildren) {
        children = this.sizerChildren;
      } else {
        children = this.children;
      }
    }
    if (IsArray(children)) {
      var child;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (ContainsPoint(child, x, y, preTest, postTest)) {
          return child;
        }
      }
    } else {
      var child;
      for (var key in children) {
        child = children[key];
        if (ContainsPoint(child, x, y, preTest, postTest)) {
          return child;
        }
      }
    }
    return null;
  };

  var CopyState = function CopyState(gamObject, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = GlobState;
    }
    out.x = gamObject.x;
    out.y = gamObject.y;
    out.scaleX = gamObject.scaleX;
    out.scaleY = gamObject.scaleY;
    out.width = gamObject.width;
    out.height = gamObject.height;
    out.displayWidth = gamObject.displayWidth;
    out.displayHeight = gamObject.displayHeight;
    return out;
  };
  var GlobState = {};

  var PreLayoutChild = function PreLayoutChild(child) {
    if (this.sizerEventsEnable) {
      CopyState(child, this.getChildPrevState(child));
      this.layoutedChildren.push(child);
    }
  };

  var LayoutChild = function LayoutChild(child, x, y, width, height, align, offsetX, offsetY) {
    AlignIn(child, x, y, width, height, align);
    if (offsetX !== undefined) {
      child.x += offsetX;
    }
    if (offsetY !== undefined) {
      child.y += offsetY;
    }
    this.resetChildPositionState(child);
    if (this.sizerEventsEnable) {
      child.emit('sizer.postlayout', child, this);
    }
  };

  var ALIGN_CENTER$4 = Phaser.Display.Align.CENTER;
  var LayoutBackgrounds = function LayoutBackgrounds() {
    if (this.backgroundChildren === undefined) {
      return;
    }
    var backgrounds = this.backgroundChildren;
    var startX = this.left,
      startY = this.top;
    var parentWidth = this.width,
      parentHeight = this.height;
    var child, childConfig, padding, x, y, width, height;
    for (var i = 0, cnt = backgrounds.length; i < cnt; i++) {
      child = backgrounds[i];
      childConfig = child.rexSizer;
      if (childConfig.hidden) {
        continue;
      }
      padding = childConfig.padding;
      PreLayoutChild.call(this, child);
      x = startX + padding.left;
      y = startY + padding.top;
      width = parentWidth - padding.left - padding.right;
      height = parentHeight - padding.top - padding.bottom;
      ResizeGameObject(child, width, height);
      LayoutChild.call(this, child, x, y, width, height, ALIGN_CENTER$4);
    }
  };

  var IsPlainObject$s = Phaser.Utils.Objects.IsPlainObject;
  var SetDraggable = function SetDraggable(sensor, draggable, dragTarget) {
    if (IsPlainObject$s(sensor)) {
      var config = sensor;
      sensor = config.sensor;
      dragTarget = config.target;
      draggable = config.draggable;
    } else {
      if (typeof draggable !== 'boolean') {
        dragTarget = draggable;
        draggable = undefined;
      }
    }
    var sensorType = _typeof(sensor);
    if (sensorType === 'string') {
      var sensorName = sensor;
      sensor = this.getElement(sensorName);
      if (!sensor) {
        console.error("Can get element '".concat(sensorName, "'"));
        return this;
      }
    } else if (sensor === undefined || sensorType != 'object') {
      draggable = sensor;
      sensor = this;
    }
    if (draggable === undefined) {
      draggable = true;
    }
    if (sensor.input && sensor.input._rexUIDragSizer) {
      // Draggable is already registered
      sensor.input.draggable = draggable;
    } else if (draggable) {
      // Register draggable
      sensor.setInteractive();
      sensor.scene.input.setDraggable(sensor);
      sensor.on('drag', function (pointer, dragX, dragY) {
        var currentDragTarget = dragTarget === undefined ? this.getTopmostSizer() : dragTarget;
        currentDragTarget.x += dragX - sensor.x;
        currentDragTarget.y += dragY - sensor.y;
        currentDragTarget.emit('sizer.drag', pointer, dragX, dragY);
      }, this).on('dragstart', function (pointer, dragX, dragY) {
        var currentDragTarget = dragTarget === undefined ? this.getTopmostSizer() : dragTarget;
        currentDragTarget.emit('sizer.dragstart', pointer, dragX, dragY);
      }, this).on('dragend', function (pointer, dragX, dragY, dropped) {
        var currentDragTarget = dragTarget === undefined ? this.getTopmostSizer() : dragTarget;
        currentDragTarget.emit('sizer.dragend', pointer, dragX, dragY, dropped);
      }, this).on('drop', function (pointer, dropZone) {
        var currentDragTarget = dragTarget === undefined ? this.getTopmostSizer() : dragTarget;
        currentDragTarget.emit('sizer.drop', pointer, dropZone);
      });
      sensor.input._rexUIDragSizer = true;
    } else ;
    return this;
  };

  var ClickMethods = {
    onClick: function onClick(gameObject, callback, scope, config) {
      if (!gameObject) {
        return this;
      }
      if (typeof gameObject === 'function') {
        config = scope;
        scope = callback;
        callback = gameObject;
        gameObject = this;
      }
      if (gameObject._click === undefined) {
        gameObject._click = new Button(gameObject, config);
      }
      gameObject._click.on('click', callback, scope);
      return this;
    },
    offClick: function offClick(gameObject, callback, scope) {
      if (typeof gameObject === 'function') {
        scope = callback;
        callback = gameObject;
        gameObject = this;
      }
      if (gameObject._click === undefined) {
        return this;
      }
      gameObject._click.off('click', callback, scope);
      return this;
    },
    enableClick: function enableClick(gameObject, enabled) {
      if (typeof gameObject === 'boolean') {
        enabled = gameObject;
        gameObject = undefined;
      }
      if (gameObject === undefined) {
        gameObject = this;
      }
      if (gameObject._click === undefined) {
        return this;
      }
      gameObject._click.setEnable(enabled);
      return this;
    },
    disableClick: function disableClick(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      if (gameObject._click === undefined) {
        return this;
      }
      gameObject._click.setEnable(false);
      return this;
    }
  };

  var GetValue$2f = Phaser.Utils.Objects.GetValue;
  var ClickOutside = /*#__PURE__*/function (_ComponentBase) {
    _inherits(ClickOutside, _ComponentBase);
    function ClickOutside(gameObject, config) {
      var _this;
      _classCallCheck(this, ClickOutside);
      _this = _callSuper(this, ClickOutside, [gameObject, config]);
      // this.parent = gameObject;

      _this._enable = undefined;
      var inputConfig = GetValue$2f(config, "inputConfig", undefined);
      if (inputConfig) {
        gameObject.setInteractive(inputConfig);
      }
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(ClickOutside, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.pointer = undefined;
        this.lastClickTime = undefined;
        this.setEnable(GetValue$2f(o, "enable", true));
        this.setMode(GetValue$2f(o, "mode", 1));
        this.setClickInterval(GetValue$2f(o, "clickInterval", 100));
        this.setDragThreshold(GetValue$2f(o, 'threshold', undefined));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        var scene = this.parent.scene;
        scene.input.on('pointerdown', this.onPress, this);
        scene.input.on('pointerup', this.onRelease, this);
        scene.input.on('pointermove', this.onMove, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        var scene = this.parent.scene;
        scene.input.off('pointerdown', this.onPress, this);
        scene.input.off('pointerup', this.onRelease, this);
        scene.input.off('pointermove', this.onMove, this);
        this.pointer = null;
        _get(_getPrototypeOf(ClickOutside.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }
        if (!e) {
          this.cancel();
        }
        this._enable = e;
        var eventName = e ? 'enable' : 'disable';
        this.emit(eventName, this, this.parent);
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = CLICKMODE[m];
        }
        this.mode = m;
        return this;
      }
    }, {
      key: "setClickInterval",
      value: function setClickInterval(interval) {
        this.clickInterval = interval; // ms
        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }, {
      key: "isPointerInside",
      value: function isPointerInside(pointer) {
        var gameObject = this.parent;
        var isInsideCallback = gameObject.input ? IsPointerInHitArea : IsPointerInBounds;
        return isInsideCallback(gameObject, pointer);
      }

      // internal
    }, {
      key: "onPress",
      value: function onPress(pointer) {
        // Do nothing if game object is not visible
        if (!this.parent.willRender(pointer.camera)) {
          return;
        }
        if (this.pointer !== undefined) {
          return;
        }
        this.pointer = pointer;
        if (this.mode === 0) {
          if (!this.isPointerInside(pointer)) {
            this.click(pointer.downTime, pointer);
          }
        }
      }
    }, {
      key: "onRelease",
      value: function onRelease(pointer) {
        // Do nothing if game object is not visible
        if (!this.parent.willRender(pointer.camera)) {
          return;
        }
        if (this.pointer !== pointer) {
          return;
        }
        if (this.mode === 1) {
          if (!this.isPointerInside(pointer)) {
            this.click(pointer.upTime, pointer);
          }
        }
        this.pointer = undefined;
      }
    }, {
      key: "onMove",
      value: function onMove(pointer, localX, localY, event) {
        if (this.pointer !== pointer) {
          return;
        }
        if (this.dragThreshold === undefined) {
          return;
        }
        if (this.mode === 1) {
          if (pointer.getDistance() >= this.dragThreshold || this.isPointerInside(pointer)) {
            this.cancel();
          }
        }
      }
    }, {
      key: "click",
      value: function click(nowTime, pointer) {
        if (!this.enable) {
          return this;
        }
        if (nowTime === undefined) {
          // fires 'clickoutside' event manually
          this.emit('clickoutside', this, this.parent, pointer);
          return this;
        }
        this.pointer = undefined;
        var lastClickTime = this.lastClickTime;
        if (lastClickTime !== undefined && nowTime - lastClickTime <= this.clickInterval) {
          return this;
        }
        this.lastClickTime = nowTime;
        this.emit('clickoutside', this, this.parent, pointer);
        return this;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.pointer = undefined;
        return this;
      }
    }]);
    return ClickOutside;
  }(ComponentBase);
  var CLICKMODE = {
    press: 0,
    pointerdown: 0,
    release: 1,
    pointerup: 1
  };

  var ClickOutsideMethods = {
    onClickOutside: function onClickOutside(gameObject, callback, scope, config) {
      if (!gameObject) {
        return this;
      }
      if (typeof gameObject === 'function') {
        config = scope;
        scope = callback;
        callback = gameObject;
        gameObject = this;
      }
      if (gameObject._clickOutside === undefined) {
        gameObject._clickOutside = new ClickOutside(gameObject, config);
      }
      gameObject._clickOutside.on('clickoutside', callback, scope);
      return this;
    },
    offClickOutside: function offClickOutside(gameObject, callback, scope) {
      if (typeof gameObject === 'function') {
        scope = callback;
        callback = gameObject;
        gameObject = this;
      }
      if (gameObject._clickOutside === undefined) {
        return this;
      }
      gameObject._clickOutside.off('clickoutside', callback, scope);
      return this;
    },
    enableClickOutside: function enableClickOutside(gameObject, enabled) {
      if (typeof gameObject === 'boolean') {
        enabled = gameObject;
        gameObject = undefined;
      }
      if (gameObject === undefined) {
        gameObject = this;
      }
      if (gameObject._clickOutside === undefined) {
        return this;
      }
      gameObject._clickOutside.setEnable(enabled);
      return this;
    },
    disableClickOutside: function disableClickOutside(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      if (gameObject._clickOutside === undefined) {
        return this;
      }
      gameObject._clickOutside.setEnable(false);
      return this;
    }
  };

  var Cooldown = /*#__PURE__*/function (_FSM) {
    _inherits(Cooldown, _FSM);
    function Cooldown() {
      var _this;
      _classCallCheck(this, Cooldown);
      _this = _callSuper(this, Cooldown, [{
        eventEmitter: false
      }]);
      _this["goto"]('IDLE');
      return _this;
    }
    _createClass(Cooldown, [{
      key: "setCooldownTime",
      value: function setCooldownTime(time) {
        this.cooldownTime = time;
        this.cooldownMode = time !== undefined;
        return this;
      }
    }, {
      key: "request",
      value: function request() {
        return this.runMethod('request');
      }

      // IDLE state
    }, {
      key: "update_IDLE",
      value: function update_IDLE() {
        this.compensationTime = 0;
      }
    }, {
      key: "request_IDLE",
      value: function request_IDLE() {
        this.next();
        return true;
      }
    }, {
      key: "next_IDLE",
      value: function next_IDLE() {
        if (this.cooldownMode) {
          return 'COOLDOWN';
        }
      }

      // COOLDOWN state
    }, {
      key: "enter_COOLDOWN",
      value: function enter_COOLDOWN() {
        this.remainderTime = this.cooldownTime + this.compensationTime;
      }
    }, {
      key: "update_COOLDOWN",
      value: function update_COOLDOWN(time, delta) {
        this.remainderTime -= delta;
        if (this.remainderTime < 0) {
          this.compensationTime = this.cooldownTime > delta ? -this.remainderTime : 0;
          this["goto"]('IDLE');
        }
      }
    }, {
      key: "request_COOLDOWN",
      value: function request_COOLDOWN() {
        return false;
      }
    }]);
    return Cooldown;
  }(FSM);

  var GetValue$2e = Phaser.Utils.Objects.GetValue;
  var InTouching = /*#__PURE__*/function (_ComponentBase) {
    _inherits(InTouching, _ComponentBase);
    function InTouching(gameObject, config) {
      var _this;
      _classCallCheck(this, InTouching);
      _this = _callSuper(this, InTouching, [gameObject, config]);
      // this.parent = gameObject;

      _this._enable = undefined;
      _this.cooldown = new Cooldown();
      _this.parent.setInteractive(GetValue$2e(config, 'inputConfig', undefined));
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(InTouching, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.pointer = undefined;
        this.prevIsInTouch = false;
        this.isInTouching = false;
        this.setEnable(GetValue$2e(o, 'enable', true));
        this.setCooldown(GetValue$2e(o, 'cooldown', undefined));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        var gameObject = this.parent;
        gameObject.on('pointerdown', this.onPointIn, this);
        gameObject.on('pointerover', this.onPointIn, this);
        gameObject.on('pointerup', this.onPointOut, this);
        gameObject.on('pointerout', this.onPointOut, this);
        this.scene.sys.events.on('preupdate', this.preupdate, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        // GameObject events will be removed when this gameObject destroyed 
        // this.parent.off('pointerdown', this.onPointIn, this);
        // this.parent.off('pointerover', this.onPointIn, this);
        // this.parent.off('pointerup', this.onPointOut, this);
        // this.parent.off('pointerout', this.onPointOut, this);
        this.scene.sys.events.off('preupdate', this.preupdate, this);
        this.pointer = undefined;
        _get(_getPrototypeOf(InTouching.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }
        if (!e) {
          this.prevIsInTouch = false;
          this.isInTouching = false;
          this.pointer = undefined;
        }
        this._enable = e;
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "cooldownTime",
      get: function get() {
        return this.cooldown.cooldownTime;
      },
      set: function set(time) {
        this.cooldown.setCooldownTime(time);
      }
    }, {
      key: "setCooldown",
      value: function setCooldown(time) {
        this.cooldownTime = time;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }

      // internal
    }, {
      key: "onPointIn",
      value: function onPointIn(pointer, localX, localY) {
        if (!this.enable || !pointer.isDown || this.pointer !== undefined) {
          return;
        }
        this.pointer = pointer;
        this.isInTouching = true;
      }
    }, {
      key: "onPointOut",
      value: function onPointOut(pointer) {
        if (!this.enable || this.pointer !== pointer) {
          return;
        }
        this.pointer = undefined;
        this.isInTouching = false;
      }
    }, {
      key: "preupdate",
      value: function preupdate(time, delta) {
        this.cooldown.update(time, delta);
        if (!this.prevIsInTouch && this.isInTouching) {
          this.emit('touchstart', this, this.parent);
        }
        if (this.isInTouching && this.cooldown.request()) {
          this.emit('intouch', this, this.parent, this.pointer);
        }
        if (this.prevIsInTouch && !this.isInTouching) {
          this.emit('touchend', this, this.parent);
        }
        this.prevIsInTouch = this.isInTouching;
      }
    }]);
    return InTouching;
  }(ComponentBase);

  var TouchingMethods = {
    isPointerInBounds: function isPointerInBounds(target) {
      if (target === undefined) {
        target = this;
      } else if (typeof target === 'string') {
        target = this.getElement(target);
      }
      if (!target) {
        return false;
      }
      return IsPointerInBounds(target);
    },
    onTouching: function onTouching(gameObject, callback, scope, config) {
      if (!gameObject) {
        return this;
      }
      if (typeof gameObject === 'function') {
        config = scope;
        scope = callback;
        callback = gameObject;
        gameObject = this;
      }
      if (gameObject._inTouching === undefined) {
        gameObject._inTouching = new InTouching(gameObject, config);
      }
      gameObject._inTouching.on('intouch', callback, scope);
      return this;
    },
    offTouching: function offTouching(gameObject, callback, scope) {
      if (typeof gameObject === 'function') {
        scope = callback;
        callback = gameObject;
        gameObject = this;
      }
      if (gameObject._inTouching === undefined) {
        return this;
      }
      gameObject._inTouching.off('intouch', callback, scope);
      return this;
    },
    onTouchingEnd: function onTouchingEnd(gameObject, callback, scope, config) {
      if (!gameObject) {
        return this;
      }
      if (typeof gameObject === 'function') {
        config = scope;
        scope = callback;
        callback = gameObject;
        gameObject = this;
      }
      if (gameObject._inTouching === undefined) {
        gameObject._inTouching = new InTouching(gameObject, config);
      }
      gameObject._inTouching.on('touchend', callback, scope);
      return this;
    },
    offTouchingEnd: function offTouchingEnd(gameObject, callback, scope) {
      if (typeof gameObject === 'function') {
        scope = callback;
        callback = gameObject;
        gameObject = this;
      }
      if (gameObject._inTouching === undefined) {
        return this;
      }
      gameObject._inTouching.off('touchend', callback, scope);
      return this;
    },
    enableTouching: function enableTouching(gameObject, enabled) {
      if (typeof gameObject === 'boolean') {
        enabled = gameObject;
        gameObject = undefined;
      }
      if (gameObject === undefined) {
        gameObject = this;
      }
      if (gameObject._inTouching === undefined) {
        return this;
      }
      gameObject._inTouching.setEnable(enabled);
      return this;
    },
    disableTouching: function disableTouching(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      if (gameObject._inTouching === undefined) {
        return this;
      }
      gameObject._inTouching.setEnable(false);
      return this;
    }
  };

  var PointToChild = function PointToChild(parents, x, y) {
    var parent;
    for (var i = 0, cnt = parents.length; i < cnt; i++) {
      parent = parents[i];
      if (!ContainsPoint(parent, x, y)) {
        continue;
      }
      return parent.pointToChild(x, y);
    }
    return null;
  };

  var EmitChildEvent = function EmitChildEvent(eventEmitter, eventName, targets, targetMode, x, y, pointer, event) {
    var child;
    if (y === undefined) {
      child = x;
    } else {
      if (targetMode === 'parent') {
        child = PointToChild(targets, x, y);
      } else {
        for (var i = 0, cnt = targets.length; i < cnt; i++) {
          var target = targets[i];
          if (ContainsPoint(target, x, y)) {
            child = target;
            break;
          }
        }
      }
    }
    if (!child) {
      return;
    }
    eventEmitter.emit(eventName, child, pointer, event);
  };

  var GetValue$2d = Phaser.Utils.Objects.GetValue;
  var DownChild = function DownChild(config) {
    var downConfig = GetValue$2d(config, 'down', undefined);
    if (downConfig === false) {
      return;
    } else if (downConfig === true) {
      downConfig = undefined;
    }
    this.on('pointerdown', OnDown, this);
  };
  var OnDown = function OnDown(pointer, localX, localY, event) {
    var childrenInteractive = this._childrenInteractive;
    EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "down"), childrenInteractive.targetSizers, childrenInteractive.targetMode, pointer.worldX, pointer.worldY, pointer, event);
  };

  var GetValue$2c = Phaser.Utils.Objects.GetValue;
  var UpChild = function UpChild(config) {
    var upConfig = GetValue$2c(config, 'up', undefined);
    if (upConfig === false) {
      return;
    } else if (upConfig === true) {
      upConfig = undefined;
    }
    this.on('pointerup', OnUp, this);
  };
  var OnUp = function OnUp(pointer, localX, localY, event) {
    var childrenInteractive = this._childrenInteractive;
    EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "up"), childrenInteractive.targetSizers, childrenInteractive.targetMode, pointer.worldX, pointer.worldY, pointer, event);
  };

  var GetValue$2b = Phaser.Utils.Objects.GetValue;
  var OverChild = function OverChild(config) {
    var overConfig = GetValue$2b(config, 'over', undefined);
    if (overConfig === false) {
      return;
    } else if (overConfig === true) {
      overConfig = undefined;
    }
    this.on('pointermove', OnMove$1, this).on('pointerover', OnMove$1, this).on('pointerout', OnOut$1, this); // pointer-up is included too
  };
  var OnMove$1 = function OnMove(pointer, localX, localY, event) {
    var childrenInteractive = this._childrenInteractive;
    var child = PointToChild(childrenInteractive.targetSizers, pointer.worldX, pointer.worldY);
    var preChild = childrenInteractive.lastOverChild;
    if (child && preChild && child === preChild) {
      return;
    }
    childrenInteractive.lastOverChild = child;
    EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "out"), childrenInteractive.targetSizers, childrenInteractive.targetMode, preChild, undefined, pointer, event);
    EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "over"), childrenInteractive.targetSizers, childrenInteractive.targetMode, child, undefined, pointer, event);
  };
  var OnOut$1 = function OnOut(pointer, event) {
    var childrenInteractive = this._childrenInteractive;
    var child = childrenInteractive.lastOverChild;
    childrenInteractive.lastOverChild = null;
    EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "out"), childrenInteractive.targetSizers, childrenInteractive.targetMode, child, undefined, pointer, event);
  };

  var GetValue$2a = Phaser.Utils.Objects.GetValue;
  var ClickChild = function ClickChild(config) {
    var clickConfig = GetValue$2a(config, 'click', undefined);
    if (clickConfig === false) {
      return;
    } else if (clickConfig === true) {
      clickConfig = undefined;
    }
    if (clickConfig === undefined) {
      clickConfig = {};
    }
    if (!clickConfig.hasOwnProperty('threshold')) {
      clickConfig.threshold = 10;
    }
    var childrenInteractive = this._childrenInteractive;
    this._click = new Button(this, clickConfig);
    this._click.on('click', function (button, gameObject, pointer, event) {
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "click"), childrenInteractive.targetSizers, childrenInteractive.targetMode, pointer.worldX, pointer.worldY, pointer, event);
    }, this);
  };

  var GetValue$29 = Phaser.Utils.Objects.GetValue;
  var OnePointerTracer = /*#__PURE__*/function (_TickTask) {
    _inherits(OnePointerTracer, _TickTask);
    function OnePointerTracer(gameObject, config) {
      var _this;
      _classCallCheck(this, OnePointerTracer);
      var scene = GetSceneObject(gameObject);
      if (scene === gameObject) {
        gameObject = undefined;
      }
      _this = _callSuper(this, OnePointerTracer, [scene, config]);
      _this.gameObject = gameObject;
      if (gameObject) {
        gameObject.setInteractive(GetValue$29(config, 'inputConfig', undefined));
      }
      _this._enable = undefined;
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(OnePointerTracer, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setEnable(GetValue$29(o, 'enable', true));
        this.setDetectBounds();
        if (this.gameObject === undefined) {
          this.setDetectBounds(GetValue$29(o, 'bounds', undefined));
        } else {
          this.setDetectBounds();
        }
        this.tracerState = TOUCH0$2;
        // this.recongizedState = new stateClass(this);
        this.pointer = undefined;
        this.lastPointer = undefined; // Last catched pointer
        this.movedState = false;
        this.isTouchingAnyObject = false;
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        _get(_getPrototypeOf(OnePointerTracer.prototype), "boot", this).call(this);
        if (this.gameObject) {
          this.gameObject.on('pointerdown', this.onPointerDown, this);
        } else {
          this.scene.input.on('pointerdown', this.onPointerDown, this);
        }
        this.scene.input.on('pointerup', this.onPointerUp, this);
        this.scene.input.on('gameout', this.dragCancel, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.sys.events.once('shutdown', this.destroy, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        if (!this.scene) {
          return;
        }
        if (this.gameObject) ; else {
          this.scene.input.off('pointerdown', this.onPointerDown, this);
        }
        this.scene.input.off('pointerup', this.onPointerUp, this);
        this.scene.input.off('gameout', this.dragCancel, this);
        this.scene.input.off('pointermove', this.onPointerMove, this);
        this.scene.sys.events.off('shutdown', this.destroy, this);
        this.gameObject = undefined;
        this.bounds = undefined;
        this.pointer = undefined;
        this.lastPointer = undefined; // Last catched pointer
        this.movedState = false;
        _get(_getPrototypeOf(OnePointerTracer.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }
        if (!e) {
          this.dragCancel();
        }
        this._enable = e;
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "setDetectBounds",
      value: function setDetectBounds(bounds) {
        this.bounds = bounds;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "onPointerDown",
      value: function onPointerDown(pointer, gameObjects) {
        if (!this.enable) {
          return;
        }
        if (this.pointer !== undefined) {
          return;
        }
        var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
        if (!isInsideBounds) {
          return;
        }
        if (this.pointer === pointer) {
          return;
        }
        this.pointer = pointer;
        this.lastPointer = pointer;
        this.movedState = false;
        this.tracerState = TOUCH1$2;
        if (this.gameObject === undefined) {
          this.isTouchingAnyObject = gameObjects.length > 0;
        }
        this.onDragStart();
      }
    }, {
      key: "onPointerUp",
      value: function onPointerUp(pointer) {
        if (!this.enable) {
          return;
        }
        var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
        if (!isInsideBounds) {
          return;
        }
        if (this.pointer !== pointer) {
          return;
        }
        this.pointer = undefined;
        this.movedState = false;
        this.tracerState = TOUCH0$2;
        this.onDragEnd();
      }
    }, {
      key: "onPointerMove",
      value: function onPointerMove(pointer) {
        if (!this.enable) {
          return;
        }
        if (pointer.isDown) {
          var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
          var isCatchedPointer = this.pointer === pointer;
          if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) {
            // Pointer moves out of bounds
            this.onPointerUp(pointer);
          } else {
            // Pointer drags in bounds
            if (!this.movedState) {
              this.movedState = pointer.x !== pointer.downX || pointer.y !== pointer.downY;
            }
            if (this.movedState) {
              this.onDrag();
            }
          }
        }
      }
    }, {
      key: "dragCancel",
      value: function dragCancel() {
        if (this.tracerState === TOUCH1$2) {
          this.onDragEnd();
        }
        this.pointer = undefined;
        this.tracerState = TOUCH0$2;
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.emit('dragstart', this);
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.emit('dragend', this);
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        this.emit('drag', this);
      }

      // onLastPointerMove() { }
    }, {
      key: "preUpdate",
      value: function preUpdate(time, delta) {}
    }, {
      key: "postUpdate",
      value: function postUpdate(time, delta) {}
    }, {
      key: "startTicking",
      value: function startTicking() {
        _get(_getPrototypeOf(OnePointerTracer.prototype), "startTicking", this).call(this);
        this.scene.sys.events.on('preupdate', this.preUpdate, this);
        this.scene.sys.events.on('postupdate', this.postUpdate, this);
      }
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        _get(_getPrototypeOf(OnePointerTracer.prototype), "stopTicking", this).call(this);
        if (this.scene) {
          // Scene might be destoryed
          this.scene.sys.events.off('preupdate', this.preUpdate, this);
          this.scene.sys.events.off('postupdate', this.postUpdate, this);
        }
      }
    }, {
      key: "setRecongizedStateObject",
      value: function setRecongizedStateObject(stateObject) {
        this.recongizedState = stateObject;
        return this;
      }
    }, {
      key: "state",
      get: function get() {
        return this.recongizedState.state;
      },
      set: function set(newState) {
        this.recongizedState.state = newState;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.state = IDLE$5;
        return this;
      }
    }, {
      key: "isPointerInGameObject",
      value: function isPointerInGameObject(gameObject, preTest, postTest) {
        var pointer = this.pointer;
        if (!pointer) {
          return false;
        }
        return IsPointerInBounds(gameObject, pointer, preTest, postTest);
      }
    }]);
    return OnePointerTracer;
  }(TickTask);
  var TOUCH0$2 = 0;
  var TOUCH1$2 = 1;
  var IDLE$5 = 'IDLE';

  var GetValue$28 = Phaser.Utils.Objects.GetValue;
  var DistanceBetween$4 = Phaser.Math.Distance.Between;
  var Tap = /*#__PURE__*/function (_OnePointerTracer) {
    _inherits(Tap, _OnePointerTracer);
    function Tap(gameObject, config) {
      var _this;
      _classCallCheck(this, Tap);
      _this = _callSuper(this, Tap, [gameObject, config]);
      var self = _assertThisInitialized(_this);
      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.stop();
              self.tapsCount = 0;
              self.x = 0;
              self.y = 0;
              self.worldX = 0;
              self.worldY = 0;
            },
            exit: function exit() {
              var pointer = self.lastPointer;
              self.x = pointer.x;
              self.y = pointer.y;
              self.worldX = pointer.worldX;
              self.worldY = pointer.worldY;
            }
          },
          BEGIN: {
            enter: function enter() {
              self.start();
              self.tapsCount = 0;
              self.emit('tappingstart', self, self.gameObject, self.lastPointer);
            }
          },
          RECOGNIZED: {
            enter: function enter() {
              self.start();
              self.emit('tap', self, self.gameObject, self.lastPointer);
              self.emit("".concat(self.tapsCount, "tap"), self, self.gameObject, self.lastPointer);
            }
          }
        },
        init: function init() {
          this.state = IDLE$4;
        },
        eventEmitter: false
      };
      _this.setRecongizedStateObject(new FSM(stateConfig));
      return _this;
    }
    _createClass(Tap, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Tap.prototype), "resetFromJSON", this).call(this, o);
        this.setHoldTime(GetValue$28(o, 'time', 250)); // min-hold-time of Press is 251
        this.setTapInterval(GetValue$28(o, 'tapInterval', 200));
        this.setDragThreshold(GetValue$28(o, 'threshold', 9));
        this.setTapOffset(GetValue$28(o, 'tapOffset', 10));
        var taps = GetValue$28(o, 'taps', undefined);
        if (taps !== undefined) {
          this.setTaps(taps);
        } else {
          this.setMaxTaps(GetValue$28(o, 'maxTaps', undefined));
          this.setMinTaps(GetValue$28(o, 'minTaps', undefined));
        }
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        switch (this.state) {
          case IDLE$4:
            this.state = BEGIN$3;
            break;
          case BEGIN$3:
            var pointer = this.lastPointer;
            var tapsOffset = DistanceBetween$4(pointer.upX, pointer.upY, pointer.x, pointer.y);
            if (tapsOffset > this.tapOffset) {
              // Can't recognize next level, restart here
              this.state = RECOGNIZED$3;
              this.state = BEGIN$3;
            }
            break;
          case RECOGNIZED$3:
            this.state = BEGIN$3;
            break;
        }
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        if (this.state === BEGIN$3) {
          this.tapsCount++; // Try recognize next level
          this.emit('tapping', this, this.gameObject, this.lastPointer);
          if (this.maxTaps !== undefined && this.tapsCount === this.maxTaps) {
            // Reach to maxTaps, stop here                
            this.state = RECOGNIZED$3;
          }
        }
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        if (this.state === IDLE$4) {
          return;
        }
        if (this.pointer.getDistance() > this.dragThreshold) {
          // Cancel
          this.state = IDLE$4;
        }
      }
    }, {
      key: "preUpdate",
      value: function preUpdate(time, delta) {
        if (!this.isRunning || !this.enable) {
          return;
        }
        if (this.state === BEGIN$3) {
          var pointer = this.lastPointer;
          if (pointer.isDown) {
            var holdTime = time - pointer.downTime;
            if (holdTime > this.holdTime) {
              this.state = IDLE$4;
            }
          } else {
            // isUp
            var releasedTime = time - pointer.upTime;
            if (releasedTime > this.tapInterval) {
              if (this.minTaps === undefined || this.tapsCount >= this.minTaps) {
                this.state = RECOGNIZED$3;
              } else {
                this.state = IDLE$4;
              }
            }
          }
        }
      }
    }, {
      key: "postUpdate",
      value: function postUpdate(time, delta) {
        if (!this.isRunning || !this.enable) {
          return;
        }
        // Clear RECOGNIZED after update()
        if (this.state === RECOGNIZED$3) {
          this.state = IDLE$4;
        }
      }
    }, {
      key: "isTapped",
      get: function get() {
        return this.state === RECOGNIZED$3;
      }
    }, {
      key: "setHoldTime",
      value: function setHoldTime(time) {
        this.holdTime = time; // ms
        return this;
      }
    }, {
      key: "setTapInterval",
      value: function setTapInterval(time) {
        this.tapInterval = time; // ms
        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }, {
      key: "setTapOffset",
      value: function setTapOffset(distance) {
        this.tapOffset = distance;
        return this;
      }
    }, {
      key: "setMaxTaps",
      value: function setMaxTaps(taps) {
        this.maxTaps = taps;
        return this;
      }
    }, {
      key: "setMinTaps",
      value: function setMinTaps(taps) {
        this.minTaps = taps;
        return this;
      }
    }, {
      key: "setTaps",
      value: function setTaps(minTaps, maxTaps) {
        if (maxTaps === undefined) {
          maxTaps = minTaps;
        }
        this.setMinTaps(minTaps).setMaxTaps(maxTaps);
        return this;
      }
    }]);
    return Tap;
  }(OnePointerTracer);
  var IDLE$4 = 'IDLE';
  var BEGIN$3 = 'BEGIN';
  var RECOGNIZED$3 = 'RECOGNIZED';

  var GetValue$27 = Phaser.Utils.Objects.GetValue;
  var Press = /*#__PURE__*/function (_OnePointerTracer) {
    _inherits(Press, _OnePointerTracer);
    function Press(gameObject, config) {
      var _this;
      _classCallCheck(this, Press);
      _this = _callSuper(this, Press, [gameObject, config]);
      var self = _assertThisInitialized(_this);
      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.x = 0;
              self.y = 0;
              self.worldX = 0;
              self.worldY = 0;
            },
            exit: function exit() {
              var pointer = self.lastPointer;
              self.x = pointer.x;
              self.y = pointer.y;
              self.worldX = pointer.worldX;
              self.worldY = pointer.worldY;
            }
          },
          BEGIN: {
            enter: function enter() {
              self.start();
            },
            exit: function exit() {
              self.stop();
            }
          },
          RECOGNIZED: {
            enter: function enter() {
              self.emit('pressstart', self, self.gameObject, self.lastPointer);
            },
            exit: function exit() {
              self.emit('pressend', self, self.gameObject, self.lastPointer);
            }
          }
        },
        init: function init() {
          this.state = IDLE$3;
        },
        eventEmitter: false
      };
      _this.setRecongizedStateObject(new FSM(stateConfig));
      return _this;
    }
    _createClass(Press, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Press.prototype), "resetFromJSON", this).call(this, o);
        this.setDragThreshold(GetValue$27(o, 'threshold', 9));
        this.setHoldTime(GetValue$27(o, 'time', 251));
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.state = BEGIN$2;
        if (this.holdTime === 0) {
          this.state = RECOGNIZED$2;
        }
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.state = IDLE$3;
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        if (this.state === IDLE$3) {
          return;
        }
        if (this.pointer.getDistance() > this.dragThreshold) {
          this.state = IDLE$3;
        }
      }
    }, {
      key: "preUpdate",
      value: function preUpdate(time, delta) {
        if (!this.isRunning || !this.enable) {
          return;
        }
        if (this.state === BEGIN$2) {
          var holdTime = time - this.pointer.downTime;
          if (holdTime >= this.holdTime) {
            this.state = RECOGNIZED$2;
          }
        }
      }
    }, {
      key: "isPressed",
      get: function get() {
        return this.state === RECOGNIZED$2;
      }
    }, {
      key: "setHoldTime",
      value: function setHoldTime(time) {
        this.holdTime = time; // ms
        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }]);
    return Press;
  }(OnePointerTracer);
  var IDLE$3 = 'IDLE';
  var BEGIN$2 = 'BEGIN';
  var RECOGNIZED$2 = 'RECOGNIZED';

  Phaser.Utils.Objects.GetValue;

  var DistanceBetween$3 = Phaser.Math.Distance.Between;
  var AngleBetween$1 = Phaser.Math.Angle.Between;
  var VelocityMethods = {
    getDt: function getDt() {
      var dt = GetTickDelta(this.scene);
      return dt;
    },
    getVelocity: function getVelocity() {
      var p1 = this.pointer.position;
      var p0 = this.pointer.prevPosition;
      var d = DistanceBetween$3(p0.x, p0.y, p1.x, p1.y);
      var velocity = d / (this.getDt() * 0.001);
      return velocity;
    },
    getVelocityX: function getVelocityX() {
      var p1 = this.pointer.position;
      var p0 = this.pointer.prevPosition;
      var d = Math.abs(p1.x - p0.x);
      var velocity = d / (this.getDt() * 0.001);
      return velocity;
    },
    getVelocityY: function getVelocityY() {
      var p1 = this.pointer.position;
      var p0 = this.pointer.prevPosition;
      var d = Math.abs(p1.y - p0.y);
      var velocity = d / (this.getDt() * 0.001);
      return velocity;
    },
    getVelocityAngle: function getVelocityAngle() {
      var p1 = this.pointer.position;
      var p0 = this.pointer.prevPosition;
      var angle = AngleBetween$1(p0.x, p0.y, p1.x, p1.y);
      return angle;
    }
  };

  var DIRMODE$1 = {
    'up&down': 0,
    'left&right': 1,
    '4dir': 2,
    '8dir': 3
  };

  var AngleToDirections = function AngleToDirections(angle, dirMode, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = globOut$1;
    }
    out.left = false;
    out.right = false;
    out.up = false;
    out.down = false;
    angle = (angle + 360) % 360;
    switch (dirMode) {
      case 0:
        // up & down
        if (angle < 180) {
          out.down = true;
        } else {
          out.up = true;
        }
        break;
      case 1:
        // left & right
        if (angle > 90 && angle <= 270) {
          out.left = true;
        } else {
          out.right = true;
        }
        break;
      case 2:
        // 4 dir
        if (angle > 45 && angle <= 135) {
          out.down = true;
        } else if (angle > 135 && angle <= 225) {
          out.left = true;
        } else if (angle > 225 && angle <= 315) {
          out.up = true;
        } else {
          out.right = true;
        }
        break;
      case 3:
        // 8 dir
        if (angle > 22.5 && angle <= 67.5) {
          out.down = true;
          out.right = true;
        } else if (angle > 67.5 && angle <= 112.5) {
          out.down = true;
        } else if (angle > 112.5 && angle <= 157.5) {
          out.down = true;
          out.left = true;
        } else if (angle > 157.5 && angle <= 202.5) {
          out.left = true;
        } else if (angle > 202.5 && angle <= 247.5) {
          out.left = true;
          out.up = true;
        } else if (angle > 247.5 && angle <= 292.5) {
          out.up = true;
        } else if (angle > 292.5 && angle <= 337.5) {
          out.up = true;
          out.right = true;
        } else {
          out.right = true;
        }
        break;
    }
    return out;
  };
  var globOut$1 = {};

  var GetValue$26 = Phaser.Utils.Objects.GetValue;
  var RadToDeg$3 = Phaser.Math.RadToDeg;
  var Swipe = /*#__PURE__*/function (_OnePointerTracer) {
    _inherits(Swipe, _OnePointerTracer);
    function Swipe(gameObject, config) {
      var _this;
      _classCallCheck(this, Swipe);
      _this = _callSuper(this, Swipe, [gameObject, config]);
      var self = _assertThisInitialized(_this);
      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.x = 0;
              self.y = 0;
              self.worldX = 0;
              self.worldY = 0;
            },
            exit: function exit() {
              var pointer = self.lastPointer;
              self.x = pointer.x;
              self.y = pointer.y;
              self.worldX = pointer.worldX;
              self.worldY = pointer.worldY;
            }
          },
          BEGIN: {
            enter: function enter() {
              self.validDrag = false;
            }
          },
          RECOGNIZED: {
            enter: function enter() {
              self.start();
              self.updateDirectionStates();
              self.emit('swipe', self, self.gameObject, self.lastPointer);
            },
            exit: function exit() {
              self.stop();
              self.clearDirectionStates();
            }
          }
        },
        init: function init() {
          this.state = IDLE$2;
        },
        eventEmitter: false
      };
      _this.setRecongizedStateObject(new FSM(stateConfig));
      _this.clearDirectionStates();
      return _this;
    }
    _createClass(Swipe, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Swipe.prototype), "resetFromJSON", this).call(this, o);
        this.setDragThreshold(GetValue$26(o, 'threshold', 10));
        this.setVelocityThreshold(GetValue$26(o, 'velocityThreshold', 1000));
        this.setDirectionMode(GetValue$26(o, 'dir', '8dir'));
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.state = BEGIN$1;
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.state = IDLE$2;
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        if (this.state === BEGIN$1) {
          if (!this.validDrag) {
            this.validDrag = this.dragThreshold === 0 || this.pointer.getDistance() >= this.dragThreshold;
          }
          if (this.validDrag && this.dragVelocity > this.velocityThreshold) {
            this.state = RECOGNIZED$1;
          }
        }
      }
    }, {
      key: "postUpdate",
      value: function postUpdate(time, delta) {
        if (!this.isRunning || !this.enable) {
          return;
        }
        // Clear RECOGNIZED after update()
        if (this.state === RECOGNIZED$1) {
          this.state = IDLE$2;
        }
      }
    }, {
      key: "isSwiped",
      get: function get() {
        return this.state === RECOGNIZED$1;
      }
    }, {
      key: "dragVelocity",
      get: function get() {
        var velocity;
        switch (this.dirMode) {
          case 0:
            velocity = this.getVelocityY();
            break;
          // up & down
          case 1:
            velocity = this.getVelocityX();
            break;
          // left & right
          default:
            velocity = this.getVelocity();
            break;
          // 4 dir, 8 dir
        }
        return velocity;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }, {
      key: "setVelocityThreshold",
      value: function setVelocityThreshold(velocity) {
        this.velocityThreshold = velocity;
        return this;
      }
    }, {
      key: "setDirectionMode",
      value: function setDirectionMode(m) {
        if (typeof m === 'string') {
          m = DIRMODE$1[m];
        }
        this.dirMode = m;
        return this;
      }
    }, {
      key: "updateDirectionStates",
      value: function updateDirectionStates() {
        var angle = RadToDeg$3(this.getVelocityAngle());
        AngleToDirections(angle, this.dirMode, this);
        return this;
      }
    }, {
      key: "clearDirectionStates",
      value: function clearDirectionStates() {
        this.left = false;
        this.right = false;
        this.up = false;
        this.down = false;
        return this;
      }
    }]);
    return Swipe;
  }(OnePointerTracer);
  Object.assign(Swipe.prototype, VelocityMethods);
  var IDLE$2 = 'IDLE';
  var BEGIN$1 = 'BEGIN';
  var RECOGNIZED$1 = 'RECOGNIZED';

  var GetValue$25 = Phaser.Utils.Objects.GetValue;
  var SpliceOne$2 = Phaser.Utils.Array.SpliceOne;
  var DistanceBetween$2 = Phaser.Math.Distance.Between;
  var AngleBetween = Phaser.Math.Angle.Between;
  var TwoPointersTracer = /*#__PURE__*/function () {
    function TwoPointersTracer(gameObject, config) {
      _classCallCheck(this, TwoPointersTracer);
      var scene = GetSceneObject(gameObject);
      if (scene === gameObject) {
        gameObject = undefined;
      }
      var amount = scene.input.manager.pointersTotal - 1;
      if (amount < 2) {
        scene.input.addPointer(2 - amount);
      }
      this.scene = scene;
      this.gameObject = gameObject;
      if (gameObject) {
        gameObject.setInteractive(GetValue$25(config, 'inputConfig', undefined));
      }

      // Event emitter
      this.setEventEmitter(GetValue$25(config, 'eventEmitter', undefined));
      this._enable = undefined;
      this.pointers = [];
      this.movedState = {};
      this.resetFromJSON(config);
      this.boot();
    }
    _createClass(TwoPointersTracer, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setEnable(GetValue$25(o, "enable", true));
        this.bounds = GetValue$25(o, 'bounds', undefined);
        this.tracerState = TOUCH0$1;
        this.pointers.length = 0;
        Clear$1(this.movedState);
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        if (this.gameObject) {
          this.gameObject.on('pointerdown', this.onPointerDown, this);
        } else {
          this.scene.input.on('pointerdown', this.onPointerDown, this);
        }
        this.scene.input.on('pointerup', this.onPointerUp, this);
        this.scene.input.on('gameout', this.dragCancel, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.sys.events.once('shutdown', this.destroy, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown() {
        if (!this.scene) {
          return;
        }
        this.destroyEventEmitter();
        this.pointers.length = 0;
        Clear$1(this.movedState);
        if (this.gameObject) ; else {
          this.scene.input.off('pointerdown', this.onPointerDown, this);
        }
        this.scene.input.off('pointerup', this.onPointerUp, this);
        this.scene.input.off('gameout', this.dragCancel, this);
        this.scene.input.off('pointermove', this.onPointerMove, this);
        this.scene.sys.events.off('shutdown', this.destroy, this);
        this.scene = undefined;
        this.gameObject = undefined;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.shutdown();
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }
        if (!e) {
          this.dragCancel();
        }
        this._enable = e;
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "onPointerDown",
      value: function onPointerDown(pointer) {
        if (!this.enable) {
          return;
        }
        if (this.pointers.length === 2) {
          return;
        }
        var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
        if (!isInsideBounds) {
          return;
        }
        var index = this.pointers.indexOf(pointer);
        if (index !== -1) {
          // Already in catched pointers
          return;
        }
        this.movedState[pointer.id] = false;
        this.pointers.push(pointer);
        switch (this.tracerState) {
          case TOUCH0$1:
            this.tracerState = TOUCH1$1;
            this.onDrag1Start();
            break;
          case TOUCH1$1:
            this.tracerState = TOUCH2;
            this.onDrag2Start();
            break;
        }
      }
    }, {
      key: "onPointerUp",
      value: function onPointerUp(pointer) {
        if (!this.enable) {
          return;
        }
        var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
        if (!isInsideBounds) {
          return;
        }
        var index = this.pointers.indexOf(pointer);
        if (index === -1) {
          // Not in catched pointers
          return;
        } else {
          delete this.movedState[pointer.id];
          SpliceOne$2(this.pointers, index);
        }
        switch (this.tracerState) {
          case TOUCH1$1:
            this.tracerState = TOUCH0$1;
            this.onDrag1End();
            break;
          case TOUCH2:
            this.tracerState = TOUCH1$1;
            this.onDrag2End();
            this.onDrag1Start();
            break;
        }
      }
    }, {
      key: "onPointerMove",
      value: function onPointerMove(pointer) {
        if (!this.enable) {
          return;
        }
        if (pointer.isDown) {
          var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
          var isCatchedPointer = this.pointers.indexOf(pointer) !== -1;
          if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) {
            // Pointer moves out of bounds, lose pointer
            this.onPointerUp(pointer);
          } else {
            // Pointer drags in bounds
            if (!this.movedState[pointer.id]) {
              this.movedState[pointer.id] = pointer.x !== pointer.downX || pointer.y !== pointer.downY;
            }
            if (this.movedState[pointer.id]) {
              switch (this.tracerState) {
                case TOUCH1$1:
                  this.onDrag1();
                  break;
                case TOUCH2:
                  this.onDrag2();
                  break;
              }
            }
          }
        }
      }
    }, {
      key: "dragCancel",
      value: function dragCancel() {
        if (this.tracerState === TOUCH2) {
          this.onDrag2End();
        }
        this.pointers.length = 0;
        Clear$1(this.movedState);
        this.tracerState = TOUCH0$1;
        return this;
      }
    }, {
      key: "onDrag1Start",
      value: function onDrag1Start() {
        this.emit('drag1start', this);
      }
    }, {
      key: "onDrag1End",
      value: function onDrag1End() {
        this.emit('drag1end', this);
      }
    }, {
      key: "onDrag1",
      value: function onDrag1() {
        this.emit('drag1', this);
      }
    }, {
      key: "onDrag2Start",
      value: function onDrag2Start() {
        this.emit('drag2start', this);
      }
    }, {
      key: "onDrag2End",
      value: function onDrag2End() {
        this.emit('drag2end', this);
      }
    }, {
      key: "onDrag2",
      value: function onDrag2() {
        this.emit('drag2', this);
      }
    }, {
      key: "distanceBetween",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }
        var p0 = this.pointers[0],
          p1 = this.pointers[1];
        return DistanceBetween$2(p0.x, p0.y, p1.x, p1.y);
      }
    }, {
      key: "angleBetween",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }
        var p0 = this.pointers[0],
          p1 = this.pointers[1];
        return AngleBetween(p0.x, p0.y, p1.x, p1.y);
      }
    }, {
      key: "drag1Vector",
      get: function get() {
        var pointer = this.pointers[0];
        if (pointer && this.movedState[pointer.id]) {
          var p1 = pointer.position;
          var p0 = pointer.prevPosition;
          tmpDragVector.x = p1.x - p0.x;
          tmpDragVector.y = p1.y - p0.y;
        } else {
          tmpDragVector.x = 0;
          tmpDragVector.y = 0;
        }
        return tmpDragVector;
      }
    }, {
      key: "centerX",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }
        var p0 = this.pointers[0].position;
        var p1 = this.pointers[1].position;
        return (p0.x + p1.x) / 2;
      }
    }, {
      key: "centerY",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }
        var p0 = this.pointers[0].position;
        var p1 = this.pointers[1].position;
        return (p0.y + p1.y) / 2;
      }
    }, {
      key: "prevCenterX",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }
        var preP0 = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position;
        var preP1 = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position;
        return (preP0.x + preP1.x) / 2;
      }
    }, {
      key: "prevCenterY",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }
        var preP0 = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position;
        var preP1 = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position;
        return (preP0.y + preP1.y) / 2;
      }
    }, {
      key: "movementCenterX",
      get: function get() {
        return this.centerX - this.prevCenterX;
      }
    }, {
      key: "movementCenterY",
      get: function get() {
        return this.centerY - this.prevCenterY;
      }
    }, {
      key: "setRecongizedStateObject",
      value: function setRecongizedStateObject(stateObject) {
        this.recongizedState = stateObject;
        return this;
      }
    }, {
      key: "state",
      get: function get() {
        return this.recongizedState.state;
      },
      set: function set(newState) {
        this.recongizedState.state = newState;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.state = IDLE$1;
        return this;
      }
    }, {
      key: "isPointer0InGameObject",
      value: function isPointer0InGameObject(gameObject, preTest, postTest) {
        var pointer = this.pointers[0];
        if (!pointer) {
          return false;
        }
        return IsPointerInBounds(gameObject, pointer, preTest, postTest);
      }
    }, {
      key: "isPointer1InGameObject",
      value: function isPointer1InGameObject(gameObject, preTest, postTest) {
        var pointer = this.pointers[1];
        if (!pointer) {
          return false;
        }
        return IsPointerInBounds(gameObject, pointer, preTest, postTest);
      }
    }]);
    return TwoPointersTracer;
  }();
  Object.assign(TwoPointersTracer.prototype, EventEmitterMethods$1);
  var tmpDragVector = {};
  var TOUCH0$1 = 0;
  var TOUCH1$1 = 1;
  var TOUCH2 = 2;
  var IDLE$1 = 'IDLE';

  Phaser.Utils.Objects.GetValue;

  var RotateAround$2 = Phaser.Math.RotateAround;
  var RotateObjectAround = function RotateObjectAround(gameObject, x, y, angle) {
    RotateAround$2(gameObject, x, y, angle);
    gameObject.rotation += angle;
    return gameObject;
  };

  var ScreenXYToWorldXY = function ScreenXYToWorldXY(screenX, screenY, camera, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = globalOut;
    }
    camera.getWorldPoint(screenX, screenY, out);
    return out;
  };
  var globalOut = {};

  var SpinObject = function SpinObject(gameObject, camera) {
    if (!this.isRotation) {
      return this;
    }
    if (camera === undefined) {
      camera = this.pointers[0].camera;
    }
    var movementX = this.movementCenterX,
      movementY = this.movementCenterY;
    var worldXY = ScreenXYToWorldXY(this.centerX, this.centerY, camera, true);
    var centerWorldX = worldXY.x;
    var centerWorldY = worldXY.y;
    var angle = this.rotation;
    if (Array.isArray(gameObject)) {
      var gameObjects = gameObject;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        gameObject = gameObjects[i];
        gameObject.x += movementX;
        gameObject.y += movementY;
        RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
      }
    } else {
      gameObject.x += movementX;
      gameObject.y += movementY;
      RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
    }
    return this;
  };

  var GetValue$24 = Phaser.Utils.Objects.GetValue;
  var WrapDegrees = Phaser.Math.Angle.WrapDegrees; // Wrap degrees: -180 to 180 
  var ShortestBetween = Phaser.Math.Angle.ShortestBetween;
  var RadToDeg$2 = Phaser.Math.RadToDeg;
  var DegToRad$3 = Phaser.Math.DegToRad;
  var Rotate = /*#__PURE__*/function (_TwoPointersTracer) {
    _inherits(Rotate, _TwoPointersTracer);
    function Rotate(gameObject, config) {
      var _this;
      _classCallCheck(this, Rotate);
      _this = _callSuper(this, Rotate, [gameObject, config]);
      var self = _assertThisInitialized(_this);
      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.prevAngle = undefined;
              self.angle = 0;
            }
          },
          BEGIN: {},
          RECOGNIZED: {
            enter: function enter() {
              self.emit('rotatestart', self);
            },
            exit: function exit() {
              self.emit('rotateend', self);
            }
          }
        },
        init: function init() {
          this.state = IDLE;
        },
        eventEmitter: false
      };
      _this.setRecongizedStateObject(new FSM(stateConfig));
      return _this;
    }
    _createClass(Rotate, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Rotate.prototype), "resetFromJSON", this).call(this, o);
        this.setDragThreshold(GetValue$24(o, 'threshold', 0));
        return this;
      }
    }, {
      key: "onDrag2Start",
      value: function onDrag2Start() {
        this.prevAngle = WrapDegrees(RadToDeg$2(this.angleBetween)); // Degrees
        this.state = BEGIN;
        if (this.dragThreshold === 0) {
          this.state = RECOGNIZED;
        }
      }
    }, {
      key: "onDrag2End",
      value: function onDrag2End() {
        this.state = IDLE;
      }
    }, {
      key: "onDrag2",
      value: function onDrag2() {
        switch (this.state) {
          case BEGIN:
            if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) {
              var curAngle = WrapDegrees(RadToDeg$2(this.angleBetween));
              this.angle = ShortestBetween(this.prevAngle, curAngle);
              this.prevAngle = curAngle;
              this.state = RECOGNIZED;
            }
            break;
          case RECOGNIZED:
            var curAngle = WrapDegrees(RadToDeg$2(this.angleBetween));
            this.angle = ShortestBetween(this.prevAngle, curAngle);
            this.prevAngle = curAngle;
            this.emit('rotate', this);
            break;
        }
      }
    }, {
      key: "isRotated",
      get: function get() {
        return this.state === RECOGNIZED;
      }
    }, {
      key: "rotation",
      get: function get() {
        return DegToRad$3(this.angle);
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }]);
    return Rotate;
  }(TwoPointersTracer);
  var methods$s = {
    spinObject: SpinObject
  };
  Object.assign(Rotate.prototype, methods$s);
  var IDLE = 'IDLE';
  var BEGIN = 'BEGIN';
  var RECOGNIZED = 'RECOGNIZED';

  var GetValue$23 = Phaser.Utils.Objects.GetValue;
  var TapChild = function TapChild(config) {
    var tapConfig = GetValue$23(config, 'tap', undefined);
    if (tapConfig === false) {
      return;
    } else if (tapConfig === true) {
      tapConfig = undefined;
    }
    var childrenInteractive = this._childrenInteractive;
    this._tap = new Tap(this, tapConfig);
    this._tap.on('tap', function (tap, gameObject, lastPointer) {
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix).concat(tap.tapsCount, "tap"), childrenInteractive.targetSizers, childrenInteractive.targetMode, tap.worldX, tap.worldY, lastPointer);
    }, this);
  };

  var GetValue$22 = Phaser.Utils.Objects.GetValue;
  var PressChild = function PressChild(config) {
    var pressConfig = GetValue$22(config, 'press', undefined);
    if (pressConfig === false) {
      return;
    } else if (pressConfig === true) {
      pressConfig = undefined;
    }
    var childrenInteractive = this._childrenInteractive;
    this._press = new Press(this, pressConfig);
    this._press.on('pressstart', function (press, gameObject, lastPointer) {
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "pressstart"), childrenInteractive.targetSizers, childrenInteractive.targetMode, press.worldX, press.worldY, lastPointer);
    }, this).on('pressend', function (press, gameObject, lastPointer) {
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "pressend"), childrenInteractive.targetSizers, childrenInteractive.targetMode, press.worldX, press.worldY, lastPointer);
    }, this);
  };

  var GetValue$21 = Phaser.Utils.Objects.GetValue;
  var SwipeChild = function SwipeChild(config) {
    var swipeConfig = GetValue$21(config, 'swipe', undefined);
    if (swipeConfig === false) {
      return;
    } else if (swipeConfig === true) {
      swipeConfig = undefined;
    }
    if (swipeConfig === undefined) {
      swipeConfig = {};
    }
    if (!swipeConfig.hasOwnProperty('dir')) {
      swipeConfig.dir = '4dir';
    }
    var childrenInteractive = this._childrenInteractive;
    this._swipe = new Swipe(this, swipeConfig);
    this._swipe.on('swipe', function (swipe, gameObject, lastPointer) {
      var dirName = swipe.left ? 'left' : swipe.right ? 'right' : swipe.up ? 'up' : 'down';
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "swipe").concat(dirName), childrenInteractive.targetSizers, childrenInteractive.targetMode, swipe.worldX, swipe.worldY, lastPointer);
    }, this);
  };

  var GetValue$20 = Phaser.Utils.Objects.GetValue;
  var SetChildrenInteractive = function SetChildrenInteractive(gameObject, config) {
    gameObject.setInteractive();
    if (GetValue$20(config, 'dropZone', false)) {
      gameObject.input.dropZone = true;
    }
    gameObject._childrenInteractive = {
      targetSizers: GetValue$20(config, 'targets', [gameObject]),
      targetMode: GetValue$20(config, 'targetMode', 'parent'),
      eventEmitter: GetValue$20(config, 'eventEmitter', gameObject),
      eventNamePrefix: GetValue$20(config, 'inputEventPrefix', 'child.')
    };
    DownChild.call(gameObject, config);
    UpChild.call(gameObject, config);
    OverChild.call(gameObject, config);
    ClickChild.call(gameObject, config);
    TapChild.call(gameObject, config);
    PressChild.call(gameObject, config);
    SwipeChild.call(gameObject, config);
    return gameObject;
  };

  var SetChildrenInteractiveWrap = function SetChildrenInteractiveWrap(config) {
    SetChildrenInteractive(this, config);
    return this;
  };

  var BroadcastEvent = function BroadcastEvent() {
    var gameObjects = this.getAllChildren([this]);
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var gameObject = gameObjects[i];
      gameObject.emit.apply(gameObject, arguments);
    }
    return this;
  };

  var methods$r = {
    getSizerConfig: GetSizerConfig,
    getChildPrevState: GetChildPrevState,
    pushIntoBounds: PushIntoBounds,
    drawBounds: DrawBounds,
    resolveWidth: ResolveWidth$3,
    hasWidthWrap: HasWidthWrap$2,
    resolveChildrenWidth: ResolveChildrenWidth$1,
    runWidthWrap: RunWidthWrap$3,
    resolveHeight: ResolveHeight$3,
    hasHeightWrap: HasHeightWrap$2,
    resolveChildrenHeight: ResolveChildrenHeight$1,
    runHeightWrap: RunHeightWrap$3,
    getChildWidth: GetChildWidth,
    getChildHeight: GetChildHeight,
    getExpandedChildWidth: GetExpandedChildWidth$3,
    getExpandedChildHeight: GetExpandedChildHeight$3,
    getChildrenWidth: GetChildrenWidth$5,
    getChildrenHeight: GetChildrenHeight$5,
    addChildrenMap: AddChildrenMap,
    addElement: AddChildrenMap,
    removeChildrenMap: RemoveChildrenMap,
    getElement: GetElement,
    getChildIndex: GetChildIndex,
    getAllChildrenSizers: GetAllChildrenSizers,
    getChildrenSizers: GetChildrenSizers$5,
    preLayout: PreLayout$4,
    layout: Layout,
    runLayout: RunLayout,
    layoutChildren: LayoutChildren$6,
    layoutBackgrounds: LayoutBackgrounds,
    postLayout: PostLayout,
    _postLayout: _PostLayout,
    setAnchor: SetAnchor,
    isInTouching: IsInTouching,
    pointToChild: PointToChild$1,
    setDraggable: SetDraggable,
    setChildrenInteractive: SetChildrenInteractiveWrap,
    broadcastEvent: BroadcastEvent
  };
  Object.assign(methods$r, PaddingMethods, AddChildMethods$8, RemoveChildMethods$7, GetParentSizerMethods, ScaleMethods, FadeMethods, EaseMoveMethods, ShakeMethods, EaseDataMethods, ClickMethods, ClickOutsideMethods, TouchingMethods, HideMethods, ModalMethods$1, GetShownChildrenMethods);

  var GetValue$1$ = Phaser.Utils.Objects.GetValue;
  var Base = /*#__PURE__*/function (_Container) {
    _inherits(Base, _Container);
    function Base(scene, x, y, minWidth, minHeight, config) {
      var _this;
      _classCallCheck(this, Base);
      _this = _callSuper(this, Base, [scene, x, y, 1, 1]);
      _this.isRexSizer = true;
      _this.setMinSize(minWidth, minHeight);
      _this.setName(GetValue$1$(config, 'name', ''));
      _this.rexSizer = {};
      _this.space = {};
      _this.backgroundChildren = undefined;
      _this.sizerChildren = undefined; // [] or {}
      _this.childrenMap = {};
      _this.layoutedChildren = undefined;
      _this.enableLayoutWarn(false);
      var anchorConfig = GetValue$1$(config, 'anchor', undefined);
      if (anchorConfig) {
        _this.setAnchor(anchorConfig);
      }
      _this.setInnerPadding(GetValue$1$(config, 'space', 0));
      var draggable = GetValue$1$(config, 'draggable', false);
      if (draggable) {
        _this.setDraggable(draggable);
      }
      _this.setSizerEventsEnable(GetValue$1$(config, 'sizerEvents', false));
      _this.setDirty(true);
      if (GetValue$1$(config, 'enableLayer', false)) {
        _this.enableLayer();
      }
      return _this;
    }
    _createClass(Base, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        if (fromScene) {
          // In this case, children will be cleared and destroy in scene level
          var sizers = this.getAllChildrenSizers([this]);
          for (var i = 0, cnt = sizers.length; i < cnt; i++) {
            sizers[i].sizerEventsEnable = false;
          }
        }
        _get(_getPrototypeOf(Base.prototype), "destroy", this).call(this, fromScene);
        Clear$1(this.backgroundChildren);
        Clear$1(this.sizerChildren);
        this.childrenMap = undefined;
        this.space = undefined;
        this.rexSizer = undefined;
        this.layoutedChildren = undefined;
      }
    }, {
      key: "setMinSize",
      value: function setMinSize(minWidth, minHeight) {
        this.setMinWidth(minWidth).setMinHeight(minHeight);
        return this;
      }
    }, {
      key: "setMinWidth",
      value: function setMinWidth(minWidth) {
        if (minWidth == null) {
          minWidth = 0;
        }
        this.minWidth = minWidth;
        return this;
      }
    }, {
      key: "setMinHeight",
      value: function setMinHeight(minHeight) {
        if (minHeight == null) {
          minHeight = 0;
        }
        this.minHeight = minHeight;
        return this;
      }
    }, {
      key: "setDirty",
      value: function setDirty(dirty) {
        if (dirty === undefined) {
          dirty = true;
        }
        this.dirty = dirty;
        return this;
      }
    }, {
      key: "setSizerEventsEnable",
      value: function setSizerEventsEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.sizerEventsEnable = enable;
        return this;
      }
    }, {
      key: "enableLayoutWarn",
      value: function enableLayoutWarn(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.layoutWarnEnable = enable;
        return this;
      }
    }, {
      key: "ignoreLayout",
      get: function get() {
        // Skip hidden or !dirty sizer
        return this.rexSizer.hidden || !this.dirty;
      }
    }, {
      key: "childrenWidth",
      get: function get() {
        if (this._childrenWidth === undefined) {
          this._childrenWidth = this.getChildrenWidth();
        }
        return this._childrenWidth;
      }
    }, {
      key: "childrenHeight",
      get: function get() {
        if (this._childrenHeight === undefined) {
          this._childrenHeight = this.getChildrenHeight();
        }
        return this._childrenHeight;
      }
    }, {
      key: "left",
      get: function get() {
        return this.x - GetDisplayWidth(this) * this.originX;
      },
      set: function set(value) {
        this.x += value - this.left;
      }
    }, {
      key: "alignLeft",
      value: function alignLeft(value) {
        this.left = value;
        return this;
      }
    }, {
      key: "right",
      get: function get() {
        return this.left + GetDisplayWidth(this);
      },
      set: function set(value) {
        this.x += value - this.right;
      }
    }, {
      key: "alignRight",
      value: function alignRight(value) {
        this.right = value;
        return this;
      }
    }, {
      key: "centerX",
      get: function get() {
        return this.left + GetDisplayWidth(this) / 2;
      },
      set: function set(value) {
        this.x += value - this.centerX;
      }
    }, {
      key: "alignCenterX",
      value: function alignCenterX(value) {
        this.centerX = value;
        return this;
      }
    }, {
      key: "top",
      get: function get() {
        return this.y - GetDisplayHeight(this) * this.originY;
      },
      set: function set(value) {
        this.y += value - this.top;
      }
    }, {
      key: "alignTop",
      value: function alignTop(value) {
        this.top = value;
        return this;
      }
    }, {
      key: "bottom",
      get: function get() {
        return this.top + GetDisplayHeight(this);
      },
      set: function set(value) {
        this.y += value - this.bottom;
      }
    }, {
      key: "alignBottom",
      value: function alignBottom(value) {
        this.bottom = value;
        return this;
      }
    }, {
      key: "centerY",
      get: function get() {
        return this.top + GetDisplayHeight(this) / 2;
      },
      set: function set(value) {
        this.y += value - this.centerY;
      }
    }, {
      key: "alignCenterY",
      value: function alignCenterY(value) {
        this.centerY = value;
        return this;
      }
    }, {
      key: "innerLeft",
      get: function get() {
        return this.left + this.space.left * this.scaleX;
      }
    }, {
      key: "innerRight",
      get: function get() {
        return this.right - this.space.right * this.scaleX;
      }
    }, {
      key: "innerTop",
      get: function get() {
        return this.top + this.space.top * this.scaleY;
      }
    }, {
      key: "innerBottom",
      get: function get() {
        return this.bottom - this.space.bottom * this.scaleY;
      }
    }, {
      key: "innerWidth",
      get: function get() {
        return (this.width - this.space.left - this.space.right) * this.scaleX;
      }
    }, {
      key: "innerHeight",
      get: function get() {
        return (this.height - this.space.top - this.space.bottom) * this.scaleY;
      }
    }, {
      key: "minInnerWidth",
      get: function get() {
        var result = (this.minWidth - this.space.left - this.space.right) * this.scaleX;
        return Math.max(result, 0);
      }
    }, {
      key: "minInnerHeight",
      get: function get() {
        var result = (this.minHeight - this.space.top - this.space.bottom) * this.scaleY;
        return Math.max(result, 0);
      }
    }]);
    return Base;
  }(ContainerLite);
  Object.assign(Base.prototype, methods$r);

  var GetChildrenWidth$4 = function GetChildrenWidth() {
    if (this.rexSizer.hidden) {
      return 0;
    }
    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childWidth;
    var hasUnknownChildWidth = false;
    for (var key in children) {
      child = children[key];
      childWidth = this.getChildWidth(child);
      if (childWidth === undefined) {
        hasUnknownChildWidth = true;
      }
      if (hasUnknownChildWidth) {
        continue;
      }
      padding = child.rexSizer.padding;
      childWidth += padding.left + padding.right;
      result = Math.max(childWidth, result);
    }
    if (hasUnknownChildWidth) {
      return undefined;
    }
    return result + this.space.left + this.space.right;
  };

  var GetChildrenHeight$4 = function GetChildrenHeight() {
    if (this.rexSizer.hidden) {
      return 0;
    }
    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childHeight;
    var hasUnknownChildHeight = false;
    for (var key in children) {
      child = children[key];
      childHeight = this.getChildHeight(child);
      if (childHeight === undefined) {
        hasUnknownChildHeight = true;
      }
      if (hasUnknownChildHeight) {
        continue;
      }
      padding = child.rexSizer.padding;
      childHeight += padding.top + padding.bottom;
      result = Math.max(childHeight, result);
    }
    if (hasUnknownChildHeight) {
      return undefined;
    }
    return result + this.space.top + this.space.bottom;
  };

  var GetExpandedChildWidth$2 = function GetExpandedChildWidth(child, parentWidth) {
    if (parentWidth === undefined) {
      parentWidth = this.width;
    }
    var childWidth;
    var childConfig = child.rexSizer;
    if (childConfig.expandWidth) {
      var space = this.space;
      var innerWidth = parentWidth - space.left - space.right;
      var padding = childConfig.padding;
      childWidth = innerWidth - padding.left - padding.right;
    }
    return childWidth;
  };

  var GetExpandedChildHeight$2 = function GetExpandedChildHeight(child, parentHeight) {
    if (parentHeight === undefined) {
      parentHeight = this.height;
    }
    var childHeight;
    var childConfig = child.rexSizer;
    if (childConfig.expandHeight) {
      var space = this.space;
      var innerHeight = parentHeight - space.top - space.bottom;
      var padding = childConfig.padding;
      childHeight = innerHeight - padding.top - padding.bottom;
    }
    return childHeight;
  };

  var GetChildrenSizers$4 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }
    var children = this.sizerChildren,
      child;
    for (var key in children) {
      child = children[key];
      if (child.isRexSizer) {
        out.push(child);
      }
    }
    return out;
  };

  var FitTo = function FitTo(source, target, scaleUp, out) {
    if (scaleUp === undefined) {
      scaleUp = true;
    }
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = globalSize;
    }
    var sourceWidth = source.width,
      sourceHeight = source.height,
      targetWidth = target.width,
      targetHeight = target.height;
    if (sourceWidth <= targetWidth && sourceHeight <= targetHeight) {
      if (scaleUp) {
        var sourceRatio = sourceWidth / sourceHeight;
        var targetRatio = targetWidth / targetHeight;
        if (targetRatio < sourceRatio) {
          out.width = targetWidth;
          out.height = targetWidth / sourceRatio;
        } else if (targetRatio > sourceRatio) {
          out.width = targetHeight * sourceRatio;
          out.height = targetHeight;
        } else {
          out.width = targetWidth;
          out.height = targetHeight;
        }
      } else {
        out.width = sourceWidth;
        out.height = sourceHeight;
      }
    } else {
      var sourceRatio = sourceWidth / sourceHeight;
      out.width = Math.min(sourceWidth, targetWidth);
      out.height = Math.min(sourceHeight, targetHeight);
      var ratio = out.width / out.height;
      if (ratio < sourceRatio) {
        out.height = out.width / sourceRatio;
      } else if (ratio > sourceRatio) {
        out.width = out.height * sourceRatio;
      }
    }
    return out;
  };
  var globalSize = {};

  var CheckSize = function CheckSize(child, parent) {
    if (child.layoutWarnEnable) {
      if (child.width < child.childrenWidth) {
        // Warning
        console.warn("Layout width error: Parent=".concat(parent.constructor.name, ", Child=").concat(child.constructor.name));
      }
      if (child.height < child.childrenHeight) {
        // Warning
        console.warn("Layout height error: Parent=".concat(parent.constructor.name, ", Child=").concat(child.constructor.name));
      }
    }
  };

  var LayoutChildren$5 = function LayoutChildren() {
    var child, childConfig, padding;
    var startX = this.innerLeft,
      startY = this.innerTop;
    var innerWidth = this.innerWidth,
      innerHeight = this.innerHeight;
    var x, y, width, height; // Align zone
    var childWidth, childHeight, childSize;
    // Layout current page
    var children = this.sizerChildren;
    for (var key in children) {
      child = children[key];
      if (child.rexSizer.hidden) {
        continue;
      }
      childConfig = child.rexSizer;
      padding = childConfig.padding;
      PreLayoutChild.call(this, child);
      childWidth = this.getExpandedChildWidth(child);
      childHeight = this.getExpandedChildHeight(child);
      if (childConfig.aspectRatio > 0) {
        sourceSize.width = childConfig.aspectRatio;
        sourceSize.height = 1;
        targetSize.width = childWidth;
        targetSize.height = childHeight;
        childSize = FitTo(sourceSize, targetSize, true, true);
        childWidth = childSize.width;
        childHeight = childSize.height;
      }

      // Set size
      if (child.isRexSizer) {
        child.runLayout(this, childWidth, childHeight);
        CheckSize(child, this);
      } else {
        ResizeGameObject(child, childWidth, childHeight);
      }

      // Set position
      x = startX + padding.left;
      width = innerWidth - padding.left - padding.right;
      y = startY + padding.top;
      height = innerHeight - padding.top - padding.bottom;
      LayoutChild.call(this, child, x, y, width, height, childConfig.align, childConfig.alignOffsetX, childConfig.alignOffsetY);
    }
  };
  var sourceSize = {};
  var targetSize = {};

  var IsPlainObject$r = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1_ = Phaser.Utils.Objects.GetValue;
  var ALIGN_CENTER$3 = Phaser.Display.Align.CENTER;
  var UUID$3 = Phaser.Utils.String.UUID;
  var Add$7 = function Add(gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY, aspectRatio) {
    AddChild$1.call(this, gameObject);
    if (IsPlainObject$r(childKey)) {
      var config = childKey;
      childKey = GetValue$1_(config, 'key', undefined);
      align = GetValue$1_(config, 'align', ALIGN_CENTER$3);
      padding = GetValue$1_(config, 'padding', 0);
      expand = GetValue$1_(config, 'expand', true);
      if (!gameObject.isRexSizer) {
        // Get minWidth,minHeight from config
        minWidth = GetValue$1_(config, 'minWidth', gameObject._minWidth);
        minHeight = GetValue$1_(config, 'minHeight', gameObject._minHeighted);
      }
      offsetX = GetValue$1_(config, 'offsetX', 0);
      offsetY = GetValue$1_(config, 'offsetY', 0);
      aspectRatio = GetValue$1_(config, 'aspectRatio', 0);
    }
    var hasValidKey = childKey !== undefined;
    if (!hasValidKey) {
      childKey = UUID$3();
    }
    if (typeof align === 'string') {
      align = AlignConst[align];
    }
    if (align === undefined) {
      align = ALIGN_CENTER$3;
    }
    if (padding === undefined) {
      padding = 0;
    }
    if (expand === undefined) {
      expand = true;
    }
    if (!gameObject.isRexSizer) {
      // Get minWidth,minHeight from game object
      if (minWidth === undefined) {
        minWidth = gameObject._minWidth;
      }
      if (minHeight === undefined) {
        minHeight = gameObject._minHeight;
      }
    }
    if (offsetX === undefined) {
      offsetX = 0;
    }
    if (offsetY === undefined) {
      offsetY = 0;
    }
    if (aspectRatio === undefined) {
      aspectRatio = 0;
    } else if (aspectRatio === true) {
      aspectRatio = GetDisplayWidth(gameObject) / GetDisplayHeight(gameObject);
    }
    if (aspectRatio > 0) {
      expand = true;
      if (minWidth === undefined) {
        minWidth = 0;
      }
      if (minHeight === undefined) {
        minHeight = 0;
      }
    }
    var config = this.getSizerConfig(gameObject);
    config.align = align;
    config.padding = GetBoundsConfig(padding);
    if (IsPlainObject$r(expand)) {
      config.expandWidth = GetValue$1_(expand, 'width', false);
      config.expandHeight = GetValue$1_(expand, 'height', false);
    } else {
      config.expandWidth = expand;
      config.expandHeight = expand;
    }
    if (!gameObject.isRexSizer) {
      // Expand normal game object
      if (config.expandWidth) {
        // minWidth is still undefined, uses current display width
        gameObject.minWidth = minWidth === undefined ? GetDisplayWidth(gameObject) : minWidth;
      }
      if (config.expandHeight) {
        // minHeight is still undefined, uses current display height
        gameObject.minHeight = minHeight === undefined ? GetDisplayHeight(gameObject) : minHeight;
      }
    }
    config.alignOffsetX = offsetX;
    config.alignOffsetY = offsetY;
    config.aspectRatio = aspectRatio;
    if (this.sizerChildren.hasOwnProperty(childKey)) {
      this.sizerChildren[childKey].destroy();
    }
    this.sizerChildren[childKey] = gameObject;
    if (hasValidKey) {
      this.addChildrenMap(childKey, gameObject);
    }
    return this;
  };
  var AddChildMethods$7 = {
    add: Add$7
  };

  var ContainerClear = ContainerLite.prototype.clear;
  var ClearChildren = function ClearChildren(destroyChild) {
    if (this.backgroundChildren) {
      this.backgroundChildren.length = 0;
    }
    var fireRemoveEvent = !destroyChild && this.sizerEventsEnable;
    var children;
    if (fireRemoveEvent) {
      children = this.getChildren([]);
    }
    ContainerClear.call(this, destroyChild);
    if (fireRemoveEvent) {
      var gameObject;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        gameObject = children[i];
        gameObject.emit('sizer.remove', gameObject, this);
        this.emit('remove', gameObject, this);
      }
    }
    return this;
  };

  var RemoveChildMethods$6 = {
    remove: function remove(gameObject, destroyChild) {
      var key;
      if (typeof gameObject === 'string') {
        key = gameObject;
        gameObject = this.sizerChildren[key];
        if (!gameObject) {
          return this;
        }
      } else if (this.getParentSizer(gameObject) !== this) {
        return this;
      } else {
        key = this.childToKey(gameObject);
      }
      if (key) {
        delete this.sizerChildren[key];
        if (this.childrenMap.hasOwnProperty(key)) {
          delete this.childrenMap[key];
        }
      }
      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAll: function removeAll(destroyChild) {
      for (var key in this.sizerChildren) {
        this.remove(key, destroyChild);
      }
      return this;
    },
    clear: function clear(destroyChild) {
      for (var key in this.sizerChildren) {
        delete this.sizerChildren[key];
        if (this.childrenMap.hasOwnProperty(key)) {
          delete this.childrenMap[key];
        }
      }
      ClearChildren.call(this, destroyChild);
      return this;
    }
  };

  var methods$q = {
    getChildrenWidth: GetChildrenWidth$4,
    getChildrenHeight: GetChildrenHeight$4,
    getExpandedChildWidth: GetExpandedChildWidth$2,
    getExpandedChildHeight: GetExpandedChildHeight$2,
    getChildrenSizers: GetChildrenSizers$4,
    layoutChildren: LayoutChildren$5
  };
  Object.assign(methods$q, AddChildMethods$7, RemoveChildMethods$6);

  var IndexOf = function IndexOf(obj, child) {
    if (Array.isArray(obj)) {
      return obj.indexOf(child);
    } else {
      for (var key in obj) {
        if (obj[key] === child) {
          return key;
        }
      }
      return null;
    }
  };

  var IsPlainObject$q = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1Z = Phaser.Utils.Objects.GetValue;
  var OverlapSizer = /*#__PURE__*/function (_BaseSizer) {
    _inherits(OverlapSizer, _BaseSizer);
    function OverlapSizer(scene, x, y, minWidth, minHeight, config) {
      var _this;
      _classCallCheck(this, OverlapSizer);
      if (IsPlainObject$q(x)) {
        config = x;
        x = GetValue$1Z(config, 'x', 0);
        y = GetValue$1Z(config, 'y', 0);
        minWidth = GetValue$1Z(config, 'width', undefined);
        minHeight = GetValue$1Z(config, 'height', undefined);
      } else if (IsPlainObject$q(minWidth)) {
        config = minWidth;
        minWidth = GetValue$1Z(config, 'width', undefined);
        minHeight = GetValue$1Z(config, 'height', undefined);
      }
      _this = _callSuper(this, OverlapSizer, [scene, x, y, minWidth, minHeight, config]);
      _this.type = 'rexOverlapSizer';
      _this.sizerChildren = {};
      _this.addChildrenMap('items', _this.sizerChildren);
      return _this;
    }
    _createClass(OverlapSizer, [{
      key: "childToKey",
      value: function childToKey(gameObject) {
        if (typeof gameObject === 'string') {
          var key = gameObject;
          if (this.sizerChildren.hasOwnPropery(key)) {
            return key;
          }
        } else {
          return IndexOf(this.sizerChildren, gameObject);
        }
        return null;
      }
    }]);
    return OverlapSizer;
  }(Base);
  Object.assign(OverlapSizer.prototype, methods$q);

  var GetDistance = Phaser.Math.Distance.Between;
  var IsLocalPointInKnob = function IsLocalPointInKnob(knob, localX, localY) {
    var centerX = knob.width / 2;
    return GetDistance(centerX, centerX, localX, localY) <= centerX;
  };

  var GetAngle$1 = Phaser.Math.Angle.Between;
  var NormalizeAngle = Phaser.Math.Angle.Normalize;
  var OnTouchPad = function OnTouchPad(pointer, localX, localY) {
    if (!this.enable) {
      return;
    }
    if (!pointer.isDown) {
      return;
    }
    var knob = this.sizerChildren.knob;
    if (!IsLocalPointInKnob(knob, localX, localY)) {
      return;
    }
    var centerX = knob.width / 2;
    var startAngle = knob.startAngle;
    var endAngle = GetAngle$1(centerX, centerX, localX, localY);
    var deltaAngle = knob.anticlockwise ? startAngle - endAngle : endAngle - startAngle;
    var value = NormalizeAngle(deltaAngle) / (2 * Math.PI);
    this.stopEaseValue();
    if (this.easeValueDuration === 0 || Math.abs(this.value - value) < 0.1) {
      this.value = value;
    } else {
      this.easeValueTo(value);
    }
  };
  var InstallEvents$1 = function InstallEvents() {
    var knob = this.sizerChildren.knob;
    knob.on('pointerdown', OnTouchPad, this).on('pointermove', OnTouchPad, this).setInteractive();
  };

  var GetAngle = Phaser.Math.Angle.Between;
  var WrapAngle = Phaser.Math.Angle.Wrap;
  var OnPointerDown = function OnPointerDown(pointer, localX, localY) {
    if (!this.enable || this.panPointer) {
      return;
    }
    var knob = this.sizerChildren.knob;
    if (!IsLocalPointInKnob(knob, localX, localY)) {
      return;
    }
    OnPanStart.call(this, pointer);
  };
  var OnPointerMove = function OnPointerMove(pointer, localX, localY) {
    if (!this.enable) {
      return;
    }
    if (!pointer.isDown) {
      return;
    }
    var knob = this.sizerChildren.knob;
    switch (this.panState) {
      case TOUCH0:
        if (IsLocalPointInKnob(knob, localX, localY)) {
          OnPanStart.call(this, pointer);
        }
        break;
      case TOUCH1:
        if (IsLocalPointInKnob(knob, localX, localY)) {
          OnPan.call(this);
        } else {
          OnPanEnd.call(this);
        }
        break;
    }
  };
  var OnPointerUp = function OnPointerUp(pointer, localX, localY) {
    if (!this.enable || this.panPointer !== pointer) {
      return;
    }
    OnPanEnd.call(this);
  };
  var OnPanStart = function OnPanStart(pointer) {
    this.panPointer = pointer;
    this.panState = TOUCH1;
  };
  var OnPanEnd = function OnPanEnd() {
    this.panPointer = undefined;
    this.panState = TOUCH0;
  };
  var OnPan = function OnPan() {
    var p0 = this.panPointer.prevPosition,
      p1 = this.panPointer.position;
    var knob = this.sizerChildren.knob;
    var startAngle = GetAngle(knob.x, knob.y, p0.x, p0.y),
      endAngle = GetAngle(knob.x, knob.y, p1.x, p1.y);
    var deltaAngle = knob.anticlockwise ? startAngle - endAngle : endAngle - startAngle;
    var deltaValue = WrapAngle(deltaAngle) / (Math.PI * 2);
    this.stopEaseValue();
    this.value += deltaValue;
  };
  var TOUCH0 = 0;
  var TOUCH1 = 1;
  var InstallEvents = function InstallEvents() {
    var knob = this.sizerChildren.knob;
    knob.on('pointerdown', OnPointerDown, this).on('pointermove', OnPointerMove, this).on('pointerup', OnPointerUp, this).setInteractive();
    this.panPointer = undefined;
    this.panState = TOUCH0;
  };

  var SetTextFormatCallback = function SetTextFormatCallback(callback, scope) {
    this.textFormatCallback = callback;
    this.textFormatCallbackScope = scope;
    return this;
  };
  var GetFormatText = function GetFormatText(value) {
    if (value === undefined) {
      value = this.value;
    }
    var text;
    if (this.textFormatCallbackScope) {
      text = this.textFormatCallback(value);
    } else {
      text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
    }
    return text;
  };
  var UpdateText = function UpdateText(value) {
    var textObject = this.sizerChildren.text;
    if (textObject && this.textFormatCallback) {
      textObject.setText(GetFormatText.call(this, value));
      if (textObject.layout) {
        textObject.layout();
      }
    }
    return this;
  };
  var TextObjectMethods = {
    setTextFormatCallback: SetTextFormatCallback,
    getFormatText: GetFormatText,
    updateText: UpdateText
  };

  var GetValue$1Y = Phaser.Utils.Objects.GetValue;
  var SnapTo$1 = Phaser.Math.Snap.To;
  var Knob = /*#__PURE__*/function (_ProgressBase) {
    _inherits(Knob, _ProgressBase);
    function Knob(scene, config) {
      var _this;
      _classCallCheck(this, Knob);
      if (config === undefined) {
        config = {};
      }

      // Create sizer
      _this = _callSuper(this, Knob, [scene, config]);
      _this.type = 'rexKnob';
      _this.bootProgressBase(config);

      // Add elements
      var background = GetValue$1Y(config, 'background', undefined);
      var textObject = GetValue$1Y(config, 'text', undefined);
      if (background) {
        _this.addBackground(background);
      }
      // Get text object
      if (textObject) {
        // Don't draw text on knob directly
        config.textColor = undefined;
        config.textStrokeColor = undefined;
        _this.setTextFormatCallback(GetValue$1Y(config, 'textFormatCallback', undefined), GetValue$1Y(config, 'textFormatCallbackScope', undefined));
      }
      // Create circular progress object
      var knob = new CircularProgress$1(scene, config);
      knob.setDepth(GetValue$1Y(config, 'knobDepth', 0));
      knob._value = -1; // To trigger text updating
      scene.add.existing(knob);
      _this.add(knob, 'knob');
      if (textObject) {
        _this.add(textObject, 'text', 'center', 0, false);
        scene.children.moveBelow(knob, textObject); // Move knob below textObject
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('knob', knob);
      _this.addChildrenMap('text', textObject);
      _this.setEnable(GetValue$1Y(config, 'enable', undefined));
      _this.setGap(GetValue$1Y(config, 'gap', undefined));
      _this.setValue(GetValue$1Y(config, 'value', 0), GetValue$1Y(config, 'min', undefined), GetValue$1Y(config, 'max', undefined));

      // Input
      var inputMode = GetValue$1Y(config, 'input', 0);
      if (typeof inputMode === 'string') {
        inputMode = INPUTMODE$1[inputMode];
      }
      switch (inputMode) {
        case 0:
          // 'pan'
          InstallEvents.call(_assertThisInitialized(_this));
          break;
        case 1:
          // 'click'
          InstallEvents$1.call(_assertThisInitialized(_this));
          break;
      }
      return _this;
    }
    _createClass(Knob, [{
      key: "setEnable",
      value: function setEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.enable = enable;
        return this;
      }
    }, {
      key: "setGap",
      value: function setGap(gap) {
        this.gap = gap;
        return this;
      }

      // Override
    }, {
      key: "value",
      get: function get() {
        return this.sizerChildren.knob.value;
      }

      // Override
      ,
      set: function set(value) {
        if (this.gap !== undefined) {
          value = SnapTo$1(value, this.gap);
        }
        var oldValue = this.value;
        this.sizerChildren.knob.value = value;
        var newValue = this.value;
        if (oldValue !== newValue) {
          this.updateText();
          this.eventEmitter.emit('valuechange', newValue, oldValue, this.eventEmitter);
        }
      }
    }]);
    return Knob;
  }(ProgressBase(OverlapSizer));
  var INPUTMODE$1 = {
    pan: 0,
    drag: 0,
    click: 1,
    none: -1
  };
  Object.assign(Knob.prototype, TextObjectMethods);

  var ShapeClasses = {
    arc: Arc,
    circle: Circle,
    curve: Curve,
    ellipse: Ellipse,
    line: Line,
    lines: Lines,
    rectangle: Rectangle$2,
    roundRectangle: RoundRectangle,
    triangle: Triangle$1
  };
  var GetValue$1X = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$p = Phaser.Utils.Objects.IsPlainObject;
  var ClearAll = function ClearAll() {
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      shapes[i].lineStyle().fillStyle();
    }
  };
  var ShapesUpdateMethods = {
    createShape: function createShape(shapeType, name) {
      var ShapeClass = ShapeClasses[shapeType];
      var shape = new ShapeClass();
      if (name) {
        shape.setName(name);
      }
      return shape;
    },
    buildShapes: function buildShapes(config) {
      var createCallback = GetValue$1X(config, 'create', undefined);
      if (IsPlainObject$p(createCallback)) {
        var shapes = createCallback;
        for (var shapeType in shapes) {
          var name = shapes[shapeType];
          switch (_typeof(name)) {
            case 'number':
              for (var i = 0; i < name; i++) {
                this.addShape(this.createShape(shapeType));
              }
              break;
            case 'string':
              this.addShape(this.createShape(shapeType, name));
              break;
            default:
              //Array
              var names = name;
              for (var i = 0, cnt = names.length; i < cnt; i++) {
                this.addShape(this.createShape(shapeType, names[i]));
              }
              break;
          }
        }
      } else if (Array.isArray(createCallback)) {
        var shapes = createCallback;
        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
          var shape = shapes[i];
          this.addShape(this.createShape(shape.type, shape.name));
        }
      } else if (typeof createCallback === 'function') {
        createCallback.call(this);
      }
      this.setUpdateShapesCallback(GetValue$1X(config, 'update'));
    },
    setUpdateShapesCallback: function setUpdateShapesCallback(callback) {
      if (callback === undefined) {
        callback = ClearAll;
      }
      this.dirty = this.dirty || this.updateCallback !== callback;
      this.updateCallback = callback;
      return this;
    },
    updateShapes: function updateShapes() {
      this.updateCallback.call(this);
    }
  };

  var TransformMatrix = Phaser.GameObjects.Components.TransformMatrix;
  var TransformXY = Phaser.Math.TransformXY;
  var WorldXYToGameObjectLocalXY = function WorldXYToGameObjectLocalXY(gameObject, worldX, worldY, camera, out) {
    if (camera === undefined) {
      camera = gameObject.scene.cameras.main;
    }
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = globOut;
    }
    var csx = camera.scrollX;
    var csy = camera.scrollY;
    var px = worldX + csx * gameObject.scrollFactorX - csx;
    var py = worldY + csy * gameObject.scrollFactorY - csy;
    if (gameObject.parentContainer) {
      if (tempMatrix$1 === undefined) {
        tempMatrix$1 = new TransformMatrix();
        parentMatrix = new TransformMatrix();
      }
      gameObject.getWorldTransformMatrix(tempMatrix$1, parentMatrix);
      tempMatrix$1.applyInverse(px, py, out);
    } else {
      TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, out);
    }
    out.x += gameObject.displayOriginX;
    out.y += gameObject.displayOriginY;
    return out;
  };
  var tempMatrix$1, parentMatrix;
  var globOut = {};

  var GetValue$1W = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$o = Phaser.Utils.Objects.IsPlainObject;
  var CustomShapes = /*#__PURE__*/function (_BaseShapes) {
    _inherits(CustomShapes, _BaseShapes);
    function CustomShapes(scene, x, y, width, height, config) {
      var _this;
      _classCallCheck(this, CustomShapes);
      if (IsPlainObject$o(x)) {
        config = x;
        x = GetValue$1W(config, 'x', 0);
        y = GetValue$1W(config, 'y', 0);
        width = GetValue$1W(config, 'width', 2);
        height = GetValue$1W(config, 'height', 2);
      }
      _this = _callSuper(this, CustomShapes, [scene, x, y, width, height]);
      _this.type = GetValue$1W(config, 'type', 'rexCustomShapes');
      _this.buildShapes(config);
      return _this;
    }
    _createClass(CustomShapes, [{
      key: "centerX",
      get: function get() {
        return this.width / 2;
      }
    }, {
      key: "centerY",
      get: function get() {
        return this.height / 2;
      }
    }, {
      key: "worldToLocalXY",
      value: function worldToLocalXY(worldX, worldY, camera, out) {
        if (typeof camera === 'boolean') {
          out = camera;
          camera = undefined;
        }
        return WorldXYToGameObjectLocalXY(this, worldX, worldY, camera, out);
      }
    }]);
    return CustomShapes;
  }(BaseShapes);
  Object.assign(CustomShapes.prototype, ShapesUpdateMethods);

  var GetValue$1V = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$n = Phaser.Utils.Objects.IsPlainObject;
  var CustomProgress = /*#__PURE__*/function (_ProgressBase) {
    _inherits(CustomProgress, _ProgressBase);
    function CustomProgress(scene, x, y, width, height, config) {
      var _this;
      _classCallCheck(this, CustomProgress);
      if (IsPlainObject$n(x)) {
        config = x;
        x = GetValue$1V(config, 'x', 0);
        y = GetValue$1V(config, 'y', 0);
        width = GetValue$1V(config, 'width', 2);
        height = GetValue$1V(config, 'height', 2);
      }
      if (config === undefined) {
        config = {};
      }
      if (!config.type) {
        config.type = 'rexCustomProgress';
      }
      _this = _callSuper(this, CustomProgress, [scene, x, y, width, height, config]);
      _this.bootProgressBase(config);
      _this.setValue(GetValue$1V(config, 'value', 0));
      return _this;
    }
    _createClass(CustomProgress, [{
      key: "centerX",
      get: function get() {
        return this.width / 2;
      }
    }, {
      key: "centerY",
      get: function get() {
        return this.height / 2;
      }
    }, {
      key: "radius",
      get: function get() {
        return Math.min(this.centerX, this.centerY);
      }
    }]);
    return CustomProgress;
  }(ProgressBase(CustomShapes));

  var SetTransitionCallbackMethods = {
    setTransitionStartCallback: function setTransitionStartCallback(callback, scope) {
      this.onStartCallback = callback;
      this.onStartCallbackScope = scope;
      return this;
    },
    setTransitionProgressCallback: function setTransitionProgressCallback(callback, scope) {
      this.onProgressCallback = callback;
      this.onProgressCallbackScope = scope;
      return this;
    },
    setTransitionCompleteCallback: function setTransitionCompleteCallback(callback, scope) {
      this.onCompleteCallback = callback;
      this.onCompleteCallbackScope = scope;
      return this;
    }
  };

  var IsPlainObject$m = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1U = Phaser.Utils.Objects.GetValue;
  var GetRandomItem = Phaser.Utils.Array.GetRandom;
  var DirMode = {
    out: 0,
    "in": 1
  };
  var GetValueFromConfigs = function GetValueFromConfigs(key, defaultValue) {
    for (var i = 0, cnt = arguments.length <= 2 ? 0 : arguments.length - 2; i < cnt; i++) {
      var config = i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2];
      if (config && config.hasOwnProperty(key)) {
        return config[key];
      }
    }
    return defaultValue;
  };
  var TransitionMethods = {
    setTransitionDirection: function setTransitionDirection(dir) {
      if (typeof dir === 'string') {
        dir = DirMode[dir];
      }
      this.dir = dir;
      return this;
    },
    setDuration: function setDuration(duration) {
      this.duration = duration;
      return this;
    },
    setEaseFunction: function setEaseFunction(ease) {
      this.easeFunction = ease;
      return this;
    },
    setNextTexture: function setNextTexture(texture, frame) {
      this.nextImage.setTexture(texture, frame);
      return this;
    },
    transit: function transit(texture, frame, mode) {
      if (this.isRunning) {
        this.ignoreCompleteEvent = true;
        this.stop();
        this.ignoreCompleteEvent = false;
      }
      if (mode !== undefined) {
        texture = {
          key: texture,
          frame: frame,
          mode: mode
        };
      }
      this.currentTransitionMode = undefined;
      if (IsPlainObject$m(texture)) {
        var config = texture;
        texture = GetValue$1U(config, 'key', undefined);
        frame = GetValue$1U(config, 'frame', undefined);
        mode = GetValue$1U(config, 'mode');
        if (Array.isArray(mode)) {
          mode = GetRandomItem(mode);
        }
        var modeConfig;
        if (this.transitionModes && this.transitionModes.hasOwnProperty(mode)) {
          modeConfig = this.transitionModes[mode];
          this.currentTransitionMode = mode;
        }
        this.setDuration(GetValueFromConfigs('duration', this.duration, config, modeConfig)).setEaseFunction(GetValueFromConfigs('ease', this.easeFunction, config, modeConfig)).setTransitionDirection(GetValueFromConfigs('dir', this.dir, config, modeConfig));
        var maskGameObject = GetValueFromConfigs('mask', undefined, config, modeConfig);
        if (maskGameObject) {
          this.setMaskGameObject(maskGameObject);
        }
        this.setMaskEnable(maskGameObject === true);
        var onStart = GetValueFromConfigs('onStart', undefined, config, modeConfig);
        var onProgress = GetValueFromConfigs('onProgress', undefined, config, modeConfig);
        var onComplete = GetValueFromConfigs('onComplete', undefined, config, modeConfig);
        if (onStart !== undefined || onProgress !== undefined || onComplete !== undefined) {
          this.setTransitionStartCallback(onStart, GetValueFromConfigs('onStartScope', undefined, config, modeConfig)).setTransitionProgressCallback(onProgress, GetValueFromConfigs('onProgressScope', undefined, config, modeConfig)).setTransitionCompleteCallback(onComplete, GetValueFromConfigs('onCompleteScope', undefined, config, modeConfig));
        }
      }
      this.setNextTexture(texture, frame);
      this.start();
      return this;
    },
    addTransitionMode: function addTransitionMode(name, config) {
      if (this.transitionModes === undefined) {
        this.transitionModes = {};
      }
      if (IsPlainObject$m(name)) {
        config = name;
        name = config.name;
        delete config.name;
      }
      this.transitionModes[name] = config;
      return this;
    },
    start: function start() {
      if (this.easeValueTask === undefined) {
        this.easeValueTask = new EaseValueTask(this, {
          eventEmitter: null
        });
      }
      this.easeValueTask.restart({
        key: 't',
        from: 0,
        to: 1,
        duration: this.duration,
        ease: this.easeFunction
      });
      return this;
    },
    pause: function pause() {
      if (this.easeValueTask) {
        this.easeValueTask.pause();
      }
      return this;
    },
    resume: function resume() {
      if (this.easeValueTask) {
        this.easeValueTask.resume();
      }
      return this;
    },
    stop: function stop() {
      if (this.easeValueTask) {
        this.easeValueTask.stop();
      }
      this.setT(1);
      return this;
    }
  };

  var DrawShape = function DrawShape(width, height, padding, originX, originY) {
    this.clear().fillStyle(0xffffff);
    switch (this.shapeType) {
      case 1:
        // circle
        // Assume that all padding are the same value in this circle shape
        padding = padding.left;
        var radius = Math.min(width, height) / 2;
        this.fillCircle(-width * (originX - 0.5),
        // centerX
        -height * (originY - 0.5),
        // centerY
        radius + padding // radius
        );
        break;
      default:
        // 0|'rectangle'
        this.fillRect(-(width * originX) - padding.left,
        // x
        -(height * originY) - padding.top,
        // y
        width + padding.left + padding.right,
        // width
        height + padding.top + padding.bottom // height
        );
        break;
    }
  };

  var Graphics = Phaser.GameObjects.Graphics;
  var DefaultMaskGraphics = /*#__PURE__*/function (_Graphics) {
    _inherits(DefaultMaskGraphics, _Graphics);
    function DefaultMaskGraphics(parent, shapeType, padding) {
      var _this;
      _classCallCheck(this, DefaultMaskGraphics);
      if (shapeType === undefined) {
        shapeType = 0;
      }
      if (typeof shapeType === 'string') {
        shapeType = SHAPEMODE[shapeType];
      }
      _this = _callSuper(this, DefaultMaskGraphics, [parent.scene]);
      _this.parent = parent;
      _this.shapeType = shapeType;
      _this.padding = GetBoundsConfig(padding);
      _this.setPosition().resize().setVisible(false);
      // Don't add it to display list
      return _this;
    }
    _createClass(DefaultMaskGraphics, [{
      key: "destroy",
      value: function destroy() {
        this.parent = undefined;
        _get(_getPrototypeOf(DefaultMaskGraphics.prototype), "destroy", this).call(this);
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y) {
        var parent = this.parent;
        if (x === undefined) {
          x = parent.x;
        }
        if (y === undefined) {
          y = parent.y;
        }
        _get(_getPrototypeOf(DefaultMaskGraphics.prototype), "setPosition", this).call(this, x, y);
        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height, padding) {
        var parent = this.parent;
        if (width === undefined) {
          width = parent.width;
        }
        if (height === undefined) {
          height = parent.height;
        }
        if (padding === undefined) {
          padding = this.padding;
        } else if (typeof padding === 'number') {
          padding = GetBoundsConfig(padding);
        }
        var isSizeChanged = this.width !== width || this.height !== height;
        var isPaddingChanged = this.padding !== padding && !IsKeyValueEqual(this.padding, padding);
        if (!isSizeChanged && !isPaddingChanged) {
          return this;
        }
        this.width = width;
        this.height = height;
        if (isPaddingChanged) {
          Clone$2(padding, this.padding);
        }

        // Graphics does not have originX, originY properties
        this.originX = parent.originX;
        this.originY = parent.originY;
        DrawShape.call(this, width, height, padding, parent.originX, parent.originY);
        return this;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(originX, originY) {
        if (originY === undefined) {
          originY = originX;
        }
        var parent = this.parent;
        if (originX === undefined) {
          originX = parent.originX;
        }
        if (originY === undefined) {
          originY = parent.originY;
        }
        if (this.originX === originX && this.originY === originY) {
          return this;
        }
        this.originX = originX;
        this.originY = originY;
        DrawShape.call(this, this.width, this.height, this.padding, originX, originY);
        return this;
      }
    }]);
    return DefaultMaskGraphics;
  }(Graphics);
  var SHAPEMODE = {
    rectangle: 0,
    circle: 1
  };

  var MaskMethods = {
    setMaskGameObject: function setMaskGameObject(gameObject) {
      if (!gameObject) {
        this.removeMaskGameObject();
        return this;
      }
      if (this.maskGameObject) {
        if (gameObject === true && this.maskGameObject instanceof DefaultMaskGraphics) {
          return this;
        }
        if (this.maskGameObject === gameObject) {
          return this;
        }

        // Remove previous Mask Game Object
        this.removeMaskGameObject();
      }

      // Add new Mask Game Object
      if (gameObject === true) {
        gameObject = new DefaultMaskGraphics(this);
      }
      gameObject.resize(this.width, this.height).setOrigin(this.originX, this.originY).setPosition(0, 0).setScale(1).setVisible(false);
      this.addLocal(gameObject);
      this.maskGameObject = gameObject;
      if (!gameObject._maskObject) {
        gameObject._maskObject = gameObject.createGeometryMask();
        gameObject.once('destroy', function () {
          gameObject._maskObject.destroy();
          gameObject._maskObject = undefined;
        });
      }
      this.childrenMask = gameObject._maskObject;
      return this;
    },
    removeMaskGameObject: function removeMaskGameObject(destroyMaskGameObject) {
      if (destroyMaskGameObject === undefined) {
        destroyMaskGameObject = true;
      }
      this.backImage.clearMask();
      this.frontImage.clearMask();
      this.childrenMask = undefined;
      this.remove(this.maskGameObject, destroyMaskGameObject);
      this.maskGameObject = undefined;
      return this;
    },
    setImageMaskEnable: function setImageMaskEnable(gameObject, enable, invertAlpha) {
      if (enable === undefined) {
        enable = true;
      }
      if (invertAlpha === undefined) {
        invertAlpha = false;
      }
      if (enable) {
        // Use DefaultMaskGraphics if not given    
        if (!this.childrenMask) {
          this.setMaskGameObject(true);
        }
        gameObject.setMask(this.childrenMask);
        this.childrenMask.setInvertAlpha(invertAlpha);
      } else {
        gameObject.clearMask();
      }
      return this;
    },
    setCurrentImageMaskEnable: function setCurrentImageMaskEnable(enable, invertAlpha) {
      this.setImageMaskEnable(this.currentImage, enable, invertAlpha);
      return this;
    },
    setNextImageMaskEnable: function setNextImageMaskEnable(enable, invertAlpha) {
      this.setImageMaskEnable(this.nextImage, enable, invertAlpha);
      return this;
    },
    setCellImagesMaskEnable: function setCellImagesMaskEnable(enable, invertAlpha) {
      var cellImages = this.getCellImages();
      for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
        this.setImageMaskEnable(cellImages[i], enable, invertAlpha);
      }
      return this;
    },
    setMaskEnable: function setMaskEnable(enable, invertAlpha) {
      this.setImageMaskEnable(this.backImage, enable, invertAlpha);
      this.setImageMaskEnable(this.frontImage, enable, invertAlpha);
      this.setCellImagesMaskEnable(enable, invertAlpha);
      return this;
    }
  };

  var GetFrameNameCallback = function GetFrameNameCallback(baseFrameName, delimiter) {
    if (_typeof(baseFrameName) === 'object') {
      baseFrameName = baseFrameName.name;
    }
    if (delimiter === undefined) {
      delimiter = ',';
    }
    var callback;
    if (baseFrameName === '__BASE') {
      callback = function callback(colIndex, rowIndex) {
        return "".concat(colIndex).concat(delimiter).concat(rowIndex);
      };
    } else {
      callback = function callback(colIndex, rowIndex) {
        return "".concat(baseFrameName, "_").concat(colIndex).concat(delimiter).concat(rowIndex);
      };
    }
    return callback;
  };

  var GenerateFrames = function GenerateFrames(scene, key, frame, columns, rows, getFrameNameCallback) {
    if (frame == null) {
      frame = '__BASE';
    }
    if (!getFrameNameCallback) {
      getFrameNameCallback = GetFrameNameCallback(frame, getFrameNameCallback);
    }
    var texture = scene.sys.textures.get(key);
    var baseFrame = _typeof(frame) === 'object' ? frame : texture.get(frame);
    var baseWidth = baseFrame.width,
      baseHeight = baseFrame.height;
    var cellX, cellY, cellName;
    var cellWidth = baseWidth / columns,
      cellHeight = baseHeight / rows;
    var frameCutX = baseFrame.cutX,
      frameCutY = baseFrame.cutY;
    var offsetX = 0,
      offsetY = 0;
    for (var y = 0; y < rows; y++) {
      offsetX = 0;
      for (var x = 0; x < columns; x++) {
        cellName = getFrameNameCallback(x, y);
        cellX = offsetX + frameCutX;
        cellY = offsetY + frameCutY;
        texture.add(cellName, 0, cellX, cellY, cellWidth, cellHeight);
        offsetX += cellWidth;
      }
      offsetY += cellHeight;
    }
    return {
      getFrameNameCallback: getFrameNameCallback,
      cellWidth: cellWidth,
      cellHeight: cellHeight,
      columns: columns,
      rows: rows
    };
  };

  var GetValue$1T = Phaser.Utils.Objects.GetValue;
  var DefaultImageClass = Phaser.GameObjects.Image;
  var IsPlainObject$l = Phaser.Utils.Objects.IsPlainObject;
  var RotateAround$1 = Phaser.Math.RotateAround;
  var GridCutImage = function GridCutImage(gameObject, columns, rows, config) {
    if (IsPlainObject$l(columns)) {
      config = columns;
      columns = GetValue$1T(config, 'columns', 1);
      rows = GetValue$1T(config, 'rows', 1);
    }
    var createImageCallback = GetValue$1T(config, 'createImageCallback');
    if (!createImageCallback) {
      var ImageClass = GetValue$1T(config, 'ImageClass', DefaultImageClass);
      createImageCallback = function createImageCallback(scene, key, frame) {
        return new ImageClass(scene, 0, 0, key, frame);
      };
    }
    var originX = GetValue$1T(config, 'originX', 0.5);
    var originY = GetValue$1T(config, 'originY', 0.5);
    var addToScene = GetValue$1T(config, 'add', true);
    var align = GetValue$1T(config, 'align', addToScene);
    var imageObjectPool = GetValue$1T(config, 'objectPool', undefined);
    var scene = gameObject.scene;
    var texture = gameObject.texture;
    var frame = gameObject.frame;
    var result = GenerateFrames(scene, texture, frame, columns, rows);
    var getFrameNameCallback = result.getFrameNameCallback;
    var scaleX = gameObject.scaleX,
      scaleY = gameObject.scaleY;
    var rotation = gameObject.rotation;
    var topLeft = gameObject.getTopLeft(),
      startX = topLeft.x,
      startY = topLeft.y;
    var cellGameObjects = [];
    var scaleCellWidth = result.cellWidth * scaleX,
      scaleCellHeight = result.cellHeight * scaleY;
    for (var y = 0; y < rows; y++) {
      for (var x = 0; x < columns; x++) {
        var cellGameObject;
        var frameName = getFrameNameCallback(x, y);
        if (imageObjectPool && imageObjectPool.length > 0) {
          cellGameObject = imageObjectPool.pop().setTexture(texture, frameName);
        } else {
          cellGameObject = createImageCallback(scene, texture, frameName);
        }
        if (addToScene) {
          scene.add.existing(cellGameObject);
        }
        if (align) {
          var cellTLX = startX + scaleCellWidth * x;
          var cellTLY = startY + scaleCellHeight * y;
          var cellX = cellTLX + originX * scaleCellWidth;
          var cellY = cellTLY + originY * scaleCellHeight;
          cellGameObject.setOrigin(originX, originY).setPosition(cellX, cellY).setScale(scaleX, scaleY).setRotation(rotation);
          RotateAround$1(cellGameObject, startX, startY, rotation);
        }
        cellGameObjects.push(cellGameObject);
      }
    }
    return cellGameObjects;
  };

  var GridCutMethods = {
    gridCutImage: function gridCutImage(gameObject, columns, rows, config) {
      if (config === undefined) {
        config = {};
      }
      config.objectPool = this.imagesPool;
      var cellImages = GridCutImage(gameObject, columns, rows, config),
        cellImage;
      for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
        cellImage = cellImages[i];
        cellImage.setVisible(true);
        this.add(cellImage);
      }
      this.cellImages = cellImages;
      this.setChildLocalVisible(gameObject, false); // Set cut target to invisible
      return cellImages;
    },
    gridCutCurrentImage: function gridCutCurrentImage(columns, rows, config) {
      return this.gridCutImage(this.currentImage, columns, rows, config);
    },
    gridCutNextImage: function gridCutNextImage(columns, rows, config) {
      return this.gridCutImage(this.nextImage, columns, rows, config);
    },
    getCellImages: function getCellImages() {
      return this.cellImages;
    },
    freeCellImages: function freeCellImages() {
      var _this$imagesPool;
      if (this.cellImages.length === 0) {
        return this;
      }
      var texture = this.cellImages[0].texture;
      var cellImages = this.cellImages,
        cellImage,
        frameName;
      for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
        cellImage = cellImages[i];

        // Reset property of cell image
        this.setChildLocalAlpha(cellImage, 1).setChildLocalScale(cellImage, 1).setChildLocalVisible(cellImage, false);
        cellImage.clearMask();

        // Remove frame object
        frameName = cellImage.frame.name;
        cellImage.setTexture();
        texture.remove(frameName);
      }
      (_this$imagesPool = this.imagesPool).push.apply(_this$imagesPool, _toConsumableArray(cellImages));
      cellImages.length = 0;
      return this;
    }
  };

  var FlipMethods = {
    setFlipX: function setFlipX(value) {
      this.flipX = value;
      return this;
    },
    setFlipY: function setFlipY(value) {
      this.flipY = value;
      return this;
    },
    toggleFlipX: function toggleFlipX() {
      this.flipX = !this.flipX;
      return this;
    },
    toggleFlipY: function toggleFlipY() {
      this.flipY = !this.flipY;
      return this;
    },
    setFlip: function setFlip(x, y) {
      this.flipX = x;
      this.flipY = y;
      return this;
    },
    resetFlip: function resetFlip() {
      this.flipX = false;
      this.flipY = false;
      return this;
    }
  };

  var methods$p = {};
  Object.assign(methods$p, SetTransitionCallbackMethods, TransitionMethods, MaskMethods, GridCutMethods, FlipMethods);

  var OnStart = function OnStart(parent, currentImage, nextImage, t) {};
  var OnProgress = function OnProgress(parent, currentImage, nextImage, t) {
    parent.setChildLocalAlpha(currentImage, 1 - t).setChildLocalAlpha(nextImage, t);
  };
  var OnComplete = function OnComplete(parent, currentImage, nextImage, t) {
    parent.setChildLocalAlpha(currentImage, 1);
  };

  var IsPlainObject$k = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1S = Phaser.Utils.Objects.GetValue;
  var Clamp$a = Phaser.Math.Clamp;
  var TransitionImage = /*#__PURE__*/function (_Container) {
    _inherits(TransitionImage, _Container);
    function TransitionImage(scene, x, y, texture, frame, config) {
      var _this;
      _classCallCheck(this, TransitionImage);
      if (IsPlainObject$k(x)) {
        config = x;
        x = GetValue$1S(config, 'x', 0);
        y = GetValue$1S(config, 'y', 0);
        texture = GetValue$1S(config, 'key', undefined);
        frame = GetValue$1S(config, 'frame', undefined);
      } else if (IsPlainObject$k(frame)) {
        config = frame;
        frame = undefined;
      }
      var backImage = GetValue$1S(config, 'back', undefined);
      var frontImage = GetValue$1S(config, 'front', undefined);
      if (!backImage) {
        backImage = scene.add.image(x, y, texture, frame);
      }
      if (!frontImage) {
        frontImage = scene.add.image(x, y, texture, frame);
      }
      var width = GetValue$1S(config, 'width', frontImage.width);
      var height = GetValue$1S(config, 'height', frontImage.height);
      _this = _callSuper(this, TransitionImage, [scene, x, y, width, height]);
      _this.type = 'rexTransitionImage';
      backImage.setVisible(false);
      _this.addMultiple([backImage, frontImage]);
      _this.backImage = backImage;
      _this.frontImage = frontImage;
      _this.maskGameObject = undefined;
      _this.cellImages = [];
      _this.imagesPool = [];
      _this.transitionModes = undefined;
      _this.currentTransitionMode = undefined;

      // Transition parameters
      var onStart = GetValue$1S(config, 'onStart', undefined);
      var onProgress = GetValue$1S(config, 'onProgress', undefined);
      var onComplete = GetValue$1S(config, 'onComplete', undefined);
      var dir = GetValue$1S(config, 'dir', 0);
      if (onStart === undefined && onProgress === undefined && onComplete === undefined) {
        onStart = OnStart;
        onProgress = OnProgress;
        onComplete = OnComplete;
        dir = 0;
      }
      _this.setTransitionStartCallback(onStart, GetValue$1S(config, 'onStartScope', undefined)).setTransitionProgressCallback(onProgress, GetValue$1S(config, 'onProgressScope', undefined)).setTransitionCompleteCallback(onComplete, GetValue$1S(config, 'onCompleteScope', undefined)).setTransitionDirection(dir).setDuration(GetValue$1S(config, 'duration', 1000)).setEaseFunction(GetValue$1S(config, 'ease', 'Linear'));
      var maskGameObject = GetValue$1S(config, 'mask', undefined);
      if (maskGameObject) {
        _this.setMaskGameObject(maskGameObject);
      }
      _this.setMaskEnable(false);
      _this.ignoreCompleteEvent = false;
      return _this;
    }
    _createClass(TransitionImage, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        if (this.childrenMask) {
          this.childrenMask.destroy();
          this.childrenMask = undefined;
        }
        this.backImage = undefined;
        this.frontImage = undefined;
        this.maskGameObject = undefined;
        this.cellImages.length = 0;
        this.imagesPool.length = 0;
        this.transitionModes = undefined;
        _get(_getPrototypeOf(TransitionImage.prototype), "destroy", this).call(this, fromScene);
        this.onStartCallback = undefined;
        this.onStartCallbackScope = undefined;
        this.onProgressCallback = undefined;
        this.onProgressCallbackScope = undefined;
        this.onCompleteCallback = undefined;
        this.onCompleteCallbackScope = undefined;
        this.easeValueTask = undefined;
      }
    }, {
      key: "currentImage",
      get: function get() {
        return this.dir === 0 ? this.frontImage : this.backImage;
      }
    }, {
      key: "nextImage",
      get: function get() {
        return this.dir === 0 ? this.backImage : this.frontImage;
      }
    }, {
      key: "texture",
      get: function get() {
        return this.nextImage.texture;
      }
    }, {
      key: "frame",
      get: function get() {
        return this.nextImage.frame;
      }
    }, {
      key: "flipX",
      get: function get() {
        return this._flipX;
      },
      set: function set(value) {
        if (this._flipX === value) {
          return;
        }
        this._flipX = value;
        this.backImage.setFlipX(value);
        this.frontImage.setFlipX(value);
      }
    }, {
      key: "flipY",
      get: function get() {
        return this._flipY;
      },
      set: function set(value) {
        if (this._flipY === value) {
          return;
        }
        this._flipY = value;
        this.backImage.setFlipY(value);
        this.frontImage.setFlipY(value);
      }
    }, {
      key: "t",
      get: function get() {
        return this._t;
      },
      set: function set(value) {
        value = Clamp$a(value, 0, 1);
        if (this._t === value) {
          return;
        }
        this._t = value;
        var currentImage = this.currentImage;
        var nextImage = this.nextImage;

        // Start
        if (value === 0) {
          this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, true);
          RunCallback(this.onStartCallback, this.onStartCallbackScope, this, currentImage, nextImage, value);
        }

        // Progress
        RunCallback(this.onProgressCallback, this.onProgressCallbackScope, this, currentImage, nextImage, value);

        // Complete
        if (value === 1) {
          RunCallback(this.onCompleteCallback, this.onCompleteCallbackScope, this, currentImage, nextImage, value);
          var key = nextImage.texture.key,
            frame = nextImage.frame.name;
          this.frontImage.setTexture(key, frame);
          this.backImage.setTexture(key, frame);
          this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, false).setMaskEnable(false).freeCellImages();
        }
        if (value === 1 && !this.ignoreCompleteEvent) {
          this.emit('complete');
        }
      }
    }, {
      key: "setT",
      value: function setT(value) {
        this.t = value;
        return this;
      }
    }, {
      key: "isRunning",
      get: function get() {
        return this.easeValueTask ? this.easeValueTask.isRunning : false;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(originX, originY) {
        _get(_getPrototypeOf(TransitionImage.prototype), "setOrigin", this).call(this, originX, originY);
        this.backImage.setOrigin(originX, originY);
        this.frontImage.setOrigin(originX, originY);
        if (this.maskGameObject) {
          this.maskGameObject.setOrigin(originX, originY);
        }
        return this;
      }
    }, {
      key: "setTexture",
      value: function setTexture(texture, frame) {
        // Without transition
        this.frontImage.setTexture(texture, frame);
        this.backImage.setTexture(texture, frame).setVisible(false);
        return this;
      }
    }]);
    return TransitionImage;
  }(ContainerLite);
  var RunCallback = function RunCallback(callback, scope, parent, currentImage, nextImage, t) {
    if (!callback) {
      return;
    }
    if (scope) {
      callback.call(scope, parent, currentImage, nextImage, t);
    } else {
      callback(parent, currentImage, nextImage, t);
    }
  };

  // mixin
  Object.assign(TransitionImage.prototype, methods$p);

  // Slide modes
  var SlideLeft = 'slideLeft';
  var SlideRight = 'slideRight';
  var SlideUp = 'slideUp';
  var SlideDown = 'slideDown';
  var SlideAwayLeft = 'slideAwayLeft';
  var SlideAwayRight = 'slideAwayRight';
  var SlideAwayUp = 'slideAwayUp';
  var SlideAwayDown = 'slideAwayDown';
  var PushLeft = 'pushLeft';
  var PushRight = 'pushRight';
  var PushUp = 'pushUp';
  var PushDown = 'pushDown';

  // Zoom modes
  var ZoomOut = 'zoomOut';
  var ZoomIn = 'zoomIn';
  var ZoomInOut = 'zoomInOut';

  // Fade effect mode
  var Fade$1 = 'fade';
  var CrossFade = 'crossFade';

  // Wipe modes
  var WipeLeft = 'wipeLeft';
  var WipeRight = 'wipeRight';
  var WipeUp = 'wipeUp';
  var WipeDown = 'wipeDown';

  // Iris modes
  var IrisOut = 'irisOut';
  var IrisIn = 'irisIn';
  var IrisInOut = 'irisInOut';

  // Pie modes
  var PieOut = 'pieOut';
  var PieIn = 'pieIn';
  var PieInOut = 'pieInOut';

  // blinds, squares, diamonds, circles, curtain
  var Blinds = 'blinds';
  var Squares = 'squares';
  var Diamonds = 'diamonds';
  var Circles = 'circles';
  var Curtain = 'curtain';

  // Shader effect modes
  var Pixellate = 'pixellate';
  var Dissolve = 'dissolve';
  var RevealLeft = 'revealLeft';
  var RevealRight = 'revealRight';
  var RevealUp = 'revealUp';
  var RevealDown = 'revealDown';

  var AddSlideAwayModes = function AddSlideAwayModes(image) {
    image.addTransitionMode(SlideAwayRight, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var x = currentImage.width * t;
        parent.setChildLocalPosition(currentImage, x, 0);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(currentImage, 0, 0);
      }
    }).addTransitionMode(SlideAwayLeft, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var x = currentImage.width * -t;
        parent.setChildLocalPosition(currentImage, x, 0);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(currentImage, 0, 0);
      }
    }).addTransitionMode(SlideAwayDown, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var y = currentImage.height * t;
        parent.setChildLocalPosition(currentImage, 0, y);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(currentImage, 0, 0);
      }
    }).addTransitionMode(SlideAwayUp, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var y = currentImage.height * -t;
        parent.setChildLocalPosition(currentImage, 0, y);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(currentImage, 0, 0);
      }
    });
  };

  var AddSlideModes = function AddSlideModes(image) {
    image.addTransitionMode(SlideRight, {
      ease: 'Linear',
      dir: 'in',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var x = nextImage.width * (t - 1);
        parent.setChildLocalPosition(nextImage, x, 0);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(nextImage, 0, 0);
      }
    }).addTransitionMode(SlideLeft, {
      ease: 'Linear',
      dir: 'in',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var x = nextImage.width * (1 - t);
        parent.setChildLocalPosition(nextImage, x, 0);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(nextImage, 0, 0);
      }
    }).addTransitionMode(SlideDown, {
      ease: 'Linear',
      dir: 'in',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var y = nextImage.height * (t - 1);
        parent.setChildLocalPosition(nextImage, 0, y);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(nextImage, 0, 0);
      }
    }).addTransitionMode(SlideUp, {
      ease: 'Linear',
      dir: 'in',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var y = nextImage.height * (1 - t);
        parent.setChildLocalPosition(nextImage, 0, y);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(nextImage, 0, 0);
      }
    });
  };

  var AddSliderModes = function AddSliderModes(image) {
    image.addTransitionMode(PushRight, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        // SlideAwayRight
        var x = currentImage.width * t;
        parent.setChildLocalPosition(currentImage, x, 0);

        // SlideLeft
        var x = nextImage.width * (t - 1);
        parent.setChildLocalPosition(nextImage, x, 0);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(currentImage, 0, 0);
        parent.setChildLocalPosition(nextImage, 0, 0);
      }
    }).addTransitionMode(PushLeft, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        // SlideAwayLeft
        var x = currentImage.width * -t;
        parent.setChildLocalPosition(currentImage, x, 0);

        // SlideRight
        var x = nextImage.width * (1 - t);
        parent.setChildLocalPosition(nextImage, x, 0);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(currentImage, 0, 0);
        parent.setChildLocalPosition(nextImage, 0, 0);
      }
    }).addTransitionMode(PushDown, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        // SlideAwayDown
        var y = currentImage.height * t;
        parent.setChildLocalPosition(currentImage, 0, y);

        // SlideUp
        var y = nextImage.height * (t - 1);
        parent.setChildLocalPosition(nextImage, 0, y);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(currentImage, 0, 0);
        parent.setChildLocalPosition(nextImage, 0, 0);
      }
    }).addTransitionMode(PushUp, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        // SlideAwayUp
        var y = currentImage.height * -t;
        parent.setChildLocalPosition(currentImage, 0, y);

        // SlideDown
        var y = nextImage.height * (1 - t);
        parent.setChildLocalPosition(nextImage, 0, y);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalPosition(currentImage, 0, 0);
        parent.setChildLocalPosition(nextImage, 0, 0);
      }
    });
  };

  var AddZoomModes = function AddZoomModes(image) {
    image.addTransitionMode(ZoomOut, {
      ease: 'Linear',
      dir: 'out',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var scale = 1 - t;
        parent.setChildLocalScale(currentImage, scale, scale);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalScale(currentImage, 1, 1);
      }
    }).addTransitionMode(ZoomIn, {
      ease: 'Linear',
      dir: 'in',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var scale = t;
        parent.setChildLocalScale(nextImage, scale, scale);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalScale(nextImage, 1, 1);
      }
    }).addTransitionMode(ZoomInOut, {
      ease: 'Linear',
      dir: 'out',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.tint = 0; // Turn nextImage to black
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var scale;
        if (t < 0.5) {
          scale = 1 - Yoyo$1(t);
          parent.setChildLocalScale(currentImage, scale, scale);
        } else {
          if (currentImage.visible) {
            parent.setChildVisible(currentImage, false);
          }
          scale = 1 - Yoyo$1(t);
          parent.setChildLocalScale(nextImage, scale, scale);
        }
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalScale(currentImage, 1, 1);
        parent.setChildVisible(currentImage, true);
        currentImage.tint = 0xffffff;
        parent.setChildLocalScale(nextImage, 1, 1);
        parent.setChildVisible(nextImage, true);
        nextImage.tint = 0xffffff;
      }
    });
  };

  var AddFadeModes = function AddFadeModes(image) {
    image.addTransitionMode(Fade$1, {
      ease: 'Linear',
      dir: 'out',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.tint = 0; // Turn nextImage to black
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var tintGray;
        if (t < 0.5) {
          t = Yoyo$1(t);
          tintGray = Math.floor(255 * (1 - t));
          currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
        } else {
          if (currentImage.visible) {
            parent.setChildVisible(currentImage, false);
          }
          t = Yoyo$1(t);
          tintGray = Math.floor(255 * (1 - t));
          nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
        }
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildVisible(currentImage, true);
        currentImage.tint = 0xffffff;
        parent.setChildVisible(nextImage, true);
        nextImage.tint = 0xffffff;
      }
    }).addTransitionMode(CrossFade, {
      ease: 'Linear',
      dir: 'out',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {},
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.setChildLocalAlpha(currentImage, 1 - t);
        parent.setChildLocalAlpha(nextImage, t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.setChildLocalAlpha(currentImage, 1);
      }
    });
  };

  var CreateMask$7 = function CreateMask(scene) {
    var maskGameObject = new CustomProgress(scene, {
      type: 'Graphics',
      create: [{
        name: 'rect',
        type: 'rectangle'
      }],
      update: function update() {
        var rect = this.getShape('rect').fillStyle(0xffffff);
        var t = 1 - this.value;
        switch (this.wipeMode) {
          case 'right':
            rect.setSize(this.width * t, this.height).setTopLeftPosition(this.width - rect.width, 0);
            break;
          case 'left':
            rect.setSize(this.width * t, this.height).setTopLeftPosition(0, 0);
            break;
          case 'down':
            rect.setSize(this.width, this.height * t).setTopLeftPosition(0, this.height - rect.height);
            break;
          case 'up':
            rect.setSize(this.width, this.height * t).setTopLeftPosition(0, 0);
            break;
        }
      }
    });
    return maskGameObject;
  };
  var AddWipeModes = function AddWipeModes(image) {
    var maskGameObject = CreateMask$7(image.scene);
    image.once('destroy', function () {
      maskGameObject.destroy();
    }).addTransitionMode(WipeRight, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true);
        parent.maskGameObject.wipeMode = 'right';
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    }).addTransitionMode(WipeLeft, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true);
        parent.maskGameObject.wipeMode = 'left';
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    }).addTransitionMode(WipeDown, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true);
        parent.maskGameObject.wipeMode = 'down';
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    }).addTransitionMode(WipeUp, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true);
        parent.maskGameObject.wipeMode = 'up';
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    });
  };

  var CreateMask$6 = function CreateMask(scene) {
    var maskGameObject = new CustomProgress(scene, {
      type: 'Graphics',
      create: [{
        name: 'rect',
        type: 'rectangle'
      }],
      update: function update() {
        this.getShape('rect').fillStyle(0xffffff).setSize(this.width * this.value, this.height * this.value).setCenterPosition(this.centerX, this.centerY);
      }
    });
    return maskGameObject;
  };
  var AddIrisModes = function AddIrisModes(image) {
    var maskGameObject = CreateMask$6(image.scene);
    image.once('destroy', function () {
      maskGameObject.destroy();
    }).addTransitionMode(IrisOut, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    }).addTransitionMode(IrisIn, {
      ease: 'Linear',
      dir: 'in',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setNextImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(1 - t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    }).addTransitionMode(IrisInOut, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.tint = 0; // Turn nextImage to black
        parent.setCurrentImageMaskEnable(true);
        parent.setNextImageMaskEnable(true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var tintGray;
        if (t < 0.5) {
          t = Yoyo$1(t);
          tintGray = Math.floor(255 * (1 - t));
          parent.maskGameObject.setValue(1 - t);
          currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
        } else {
          if (currentImage.visible) {
            parent.setChildVisible(currentImage, false);
          }
          t = Yoyo$1(t);
          tintGray = Math.floor(255 * (1 - t));
          parent.maskGameObject.setValue(1 - t);
          nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
        }
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
        parent.setChildVisible(currentImage, true);
        currentImage.tint = 0xffffff;
        parent.setChildVisible(nextImage, true);
        nextImage.tint = 0xffffff;
      }
    });
  };

  var CreateMask$5 = function CreateMask(scene) {
    var maskGameObject = new CustomProgress(scene, {
      type: 'Graphics',
      create: [{
        name: 'pie',
        type: 'arc'
      }],
      update: function update() {
        var radius = Math.max(this.width, this.height) * 2;
        var deltaAngle = 90 * this.value;
        this.getShape('pie').fillStyle(0xffffff).setCenterPosition(this.centerX, 0).setRadius(radius).setAngle(90 - deltaAngle, 90 + deltaAngle).setPie();
      }
    });
    return maskGameObject;
  };
  var AddPieModes = function AddPieModes(image) {
    var maskGameObject = CreateMask$5(image.scene);
    image.once('destroy', function () {
      maskGameObject.destroy();
    }).addTransitionMode(PieOut, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    }).addTransitionMode(PieIn, {
      ease: 'Linear',
      dir: 'in',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setNextImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(1 - t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    }).addTransitionMode(PieInOut, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.tint = 0; // Turn nextImage to black
        parent.setCurrentImageMaskEnable(true);
        parent.setNextImageMaskEnable(true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var tintGray;
        if (t < 0.5) {
          t = Yoyo$1(t);
          tintGray = Math.floor(255 * (1 - t));
          parent.maskGameObject.setValue(1 - t);
          currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
        } else {
          if (currentImage.visible) {
            parent.setChildVisible(currentImage, false);
          }
          t = Yoyo$1(t);
          tintGray = Math.floor(255 * (1 - t));
          parent.maskGameObject.setValue(1 - t);
          nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
        }
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
        parent.setChildVisible(currentImage, true);
        currentImage.tint = 0xffffff;
        parent.setChildVisible(nextImage, true);
        nextImage.tint = 0xffffff;
      }
    });
  };

  var CreateMask$4 = function CreateMask(scene, columns) {
    var maskGameObject = new CustomProgress(scene, {
      type: 'Graphics',
      create: {
        rectangle: columns
      },
      update: function update() {
        var shapes = this.getShapes();
        var shapeWidth = this.width / columns;
        for (var i = 0; i < columns; i++) {
          shapes[i].fillStyle(0xffffff).setSize(shapeWidth * this.value, this.height).setTopLeftPosition(shapeWidth * i, 0);
        }
      }
    });
    return maskGameObject;
  };
  var AddBlindsModes = function AddBlindsModes(image) {
    var maskGameObject = CreateMask$4(image.scene, 10);
    image.once('destroy', function () {
      maskGameObject.destroy();
    }).addTransitionMode(Blinds, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    });
  };

  var CreateMask$3 = function CreateMask(scene, columns, rows) {
    var maskGameObject = new CustomProgress(scene, {
      type: 'Graphics',
      create: {
        rectangle: columns * rows
      },
      update: function update() {
        var shapes = this.getShapes();
        var shapeWidth = this.width / columns,
          shapeHeight = this.height / rows;
        for (var r = 0; r < rows; r++) {
          for (var c = 0; c < columns; c++) {
            shapes[c * rows + r].fillStyle(0xffffff).setSize(shapeWidth * this.value, shapeHeight * this.value).setCenterPosition(shapeWidth * (c + 0.5), shapeHeight * (r + 0.5));
          }
        }
      }
    });
    return maskGameObject;
  };
  var AddSquaresModes = function AddSquaresModes(image) {
    var maskGameObject = CreateMask$3(image.scene, Math.ceil(image.width / 40), Math.ceil(image.height / 40));
    image.once('destroy', function () {
      maskGameObject.destroy();
    }).addTransitionMode(Squares, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    });
  };

  var CreateMask$2 = function CreateMask(scene, columns, rows) {
    var maskGameObject = new CustomProgress(scene, {
      type: 'Graphics',
      create: {
        lines: columns * rows
      },
      update: function update() {
        var shapes = this.getShapes();
        var shapeHalfWidth = this.width / (columns - 1),
          shapeHelfHeight = this.height / rows;
        var shapeHeight = shapeHelfHeight * 2;
        var halfWidth = shapeHalfWidth * this.value,
          halfHeight = shapeHelfHeight * this.value;
        for (var r = 0; r < rows; r++) {
          for (var c = 0; c < columns; c++) {
            var centerX = c * shapeHalfWidth;
            var centerY = r * shapeHeight + c % 2 * shapeHelfHeight;
            shapes[c * rows + r].fillStyle(0xffffff).start(centerX + halfWidth, centerY).lineTo(centerX, centerY + halfHeight).lineTo(centerX - halfWidth, centerY).lineTo(centerX, centerY - halfHeight).lineTo(centerX + halfWidth, centerY).close();
          }
        }
      }
    });
    return maskGameObject;
  };
  var AddDiamondsMode = function AddDiamondsMode(image) {
    var maskGameObject = CreateMask$2(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));
    image.once('destroy', function () {
      maskGameObject.destroy();
    }).addTransitionMode(Diamonds, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    });
  };

  var CreateMask$1 = function CreateMask(scene, columns, rows) {
    var maskGameObject = new CustomProgress(scene, {
      type: 'Graphics',
      create: {
        circle: columns * rows
      },
      update: function update() {
        var shapes = this.getShapes();
        var shapeHalfWidth = this.width / (columns - 1),
          shapeHelfHeight = this.height / rows;
        var shapeHeight = shapeHelfHeight * 2;
        var radius = Math.max(shapeHalfWidth, shapeHelfHeight) * this.value;
        for (var r = 0; r < rows; r++) {
          for (var c = 0; c < columns; c++) {
            var centerX = c * shapeHalfWidth;
            var centerY = r * shapeHeight + c % 2 * shapeHelfHeight;
            shapes[c * rows + r].fillStyle(0xffffff).setCenterPosition(centerX, centerY).setRadius(radius);
          }
        }
      }
    });
    return maskGameObject;
  };
  var AddCirclesMode = function AddCirclesMode(image) {
    var maskGameObject = CreateMask$1(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));
    image.once('destroy', function () {
      maskGameObject.destroy();
    }).addTransitionMode(Circles, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setCurrentImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        parent.maskGameObject.setValue(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
      }
    });
  };

  var CreateMask = function CreateMask(scene, columns) {
    var maskGameObject = new CustomProgress(scene, {
      type: 'Graphics',
      create: {
        lines: columns
      },
      update: function update() {
        var shapes = this.getShapes();
        var shapeWidth = this.width / columns;
        var radius = shapeWidth / 2;
        for (var i = 0; i < columns; i++) {
          var leftX = shapeWidth * i;
          var bottomY = this.height * this.value;
          var centerX = leftX + radius;
          shapes[i].fillStyle(0xffffff).start(leftX, 0).horizontalLineTo(bottomY).arc(centerX, bottomY, radius, 180, 0, true).horizontalLineTo(-bottomY).lineTo(leftX, 0).close();
        }
      }
    });
    return maskGameObject;
  };
  var AddCurtainMode = function AddCurtainMode(image) {
    var maskGameObject = CreateMask(image.scene, 10);
    image.once('destroy', function () {
      maskGameObject.destroy();
    }).addTransitionMode(Curtain, {
      ease: 'Linear',
      dir: 'out',
      mask: maskGameObject,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.tint = 0; // Turn nextImage to black
        parent.setCurrentImageMaskEnable(true, true);
        parent.setNextImageMaskEnable(true, true);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        var tintGray;
        if (t < 0.5) {
          t = Yoyo$1(t);
          tintGray = Math.floor(255 * (1 - t));
          parent.maskGameObject.setValue(t);
          currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
        } else {
          if (currentImage.visible) {
            parent.setChildVisible(currentImage, false);
          }
          t = Yoyo$1(t);
          tintGray = Math.floor(255 * (1 - t));
          parent.maskGameObject.setValue(t);
          nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
        }
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        parent.removeMaskGameObject(false);
        parent.setChildVisible(currentImage, true);
        currentImage.tint = 0xffffff;
        parent.setChildVisible(nextImage, true);
        nextImage.tint = 0xffffff;
      }
    });
  };

  var AddPixellateMode = function AddPixellateMode(image) {
    image.addTransitionMode(Pixellate, {
      ease: 'Linear',
      dir: 'out',
      mask: true,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        parent.setChildVisible(nextImage, false);
        currentImage.effect = currentImage.preFX.addPixelate(0);
        nextImage.effect = nextImage.preFX.addPixelate(0);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        if (t < 0.5) {
          t = Yoyo$1(t);
          var maxAmount = Math.min(currentImage.width, currentImage.height) / 5;
          currentImage.effect.amount = Math.ceil(maxAmount * t);
        } else {
          if (currentImage.visible) {
            parent.setChildVisible(currentImage, false);
          }
          if (!nextImage.visible) {
            parent.setChildVisible(nextImage, true);
          }
          t = Yoyo$1(t);
          var maxAmount = Math.min(nextImage.width, nextImage.height) / 5;
          nextImage.effect.amount = Math.ceil(maxAmount * t);
        }
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        currentImage.preFX.remove(currentImage.effect);
        delete currentImage.effect;
        parent.setChildVisible(currentImage, true);
        nextImage.preFX.remove(nextImage.effect);
        delete nextImage.effect;
      }
    });
  };

  // Reference: https://medium.com/neosavvy-labs/webgl-with-perlin-noise-part-1-a87b56bbc9fb
  var frag$1 = "vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nfloat Perlin(vec3 P) {\n    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));\n    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);\n    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);\n    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0); gx1 = fract(gx1);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\n        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\n        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\n        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\n    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\n}\nfloat Perlin(vec2 P) { return Perlin(vec3(P, 0.0)); }\n";

  // https://github.com/ykob/glsl-dissolve/blob/master/src/glsl/dissolve.fs

  var frag = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision highmedp float;\n// Scene buffer\nuniform sampler2D uMainSampler;\nuniform sampler2D uMainSampler2;\n\nuniform int resizeMode;\nuniform float progress;\nuniform float fromRatio;\nuniform float toRatio;\nvarying vec2 outFragCoord;\n// Effect parameters\nuniform float noiseX;\nuniform float noiseY;\nuniform float noiseZ;\nuniform float fromEdgeStart;\nuniform float fromEdgeWidth;\nuniform float toEdgeStart;\nuniform float toEdgeWidth;\n\n".concat(frag$1, "\n\nvec4 getFromColor (vec2 uv) {\n  return texture2D(uMainSampler, uv);\n}\n\nvec4 getToColor (vec2 uv) {\n  if (resizeMode == 2) {\n    //  cover\n    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(min(fromRatio / toRatio, 1.0), min((toRatio / fromRatio), 1.0)));\n  } else if (resizeMode == 1) {\n    //  contain\n    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(max(fromRatio / toRatio, 1.0), max((toRatio / fromRatio), 1.0)));\n  } else {\n    //  stretch\n    return texture2D(uMainSampler2, vec2(uv.x, 1.0 - uv.y));\n  }\n}\n\nvec4 transition (vec2 uv) {    \n  vec4 colorFront = getFromColor(uv);\n  vec4 colorTo = getToColor(uv);\n\n  float noise = (Perlin(vec3(uv.x * noiseX, uv.y * noiseY, noiseZ)) + 1.0) / 2.0\n    * (1.0 - (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth))\n    + (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth) * 0.5;\n  vec4 colorResult = colorFront * smoothstep(progress - (fromEdgeStart + fromEdgeWidth), progress - fromEdgeStart, noise)\n    + colorTo * smoothstep((1.0 - progress) - (toEdgeStart + toEdgeWidth), (1.0 - progress) - toEdgeStart, (1.0 - noise));\n  return colorResult;\n}\n\nvoid main () {\n  vec2 uv = outFragCoord;\n  gl_FragColor = transition(uv);\n}\n");

  var PostFXPipeline = Phaser.Renderer.WebGL.Pipelines.PostFXPipeline;
  var GetValue$1R = Phaser.Utils.Objects.GetValue;
  var Clamp$9 = Phaser.Math.Clamp;
  var DissolvePostFxPipeline = /*#__PURE__*/function (_PostFXPipeline) {
    _inherits(DissolvePostFxPipeline, _PostFXPipeline);
    function DissolvePostFxPipeline(game) {
      var _this;
      _classCallCheck(this, DissolvePostFxPipeline);
      _this = _callSuper(this, DissolvePostFxPipeline, [{
        name: 'rexDissolvePostFx',
        game: game,
        renderTarget: true,
        fragShader: frag
      }]);
      _this._progress = 0;
      _this.toFrame = null;
      _this.targetTexture = null;
      _this.resizeMode = 1;
      _this.toRatio = 1;
      _this.noiseX = 0;
      _this.noiseY = 0;
      _this.noiseZ = 0;
      _this.fromEdgeStart = 0.01;
      _this.fromEdgeWidth = 0.05;
      _this.toEdgeStart = 0.01;
      _this.toEdgeWidth = 0.05;
      return _this;
    }
    _createClass(DissolvePostFxPipeline, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setProgress(GetValue$1R(o, 'progress', 0));
        this.setTransitionTargetTexture(GetValue$1R(o, 'toTexture', '__DEFAULT'), GetValue$1R(o, 'toFrame', undefined), GetValue$1R(o, 'resizeMode', 1));
        this.setNoise(GetValue$1R(o, 'noiseX', undefined), GetValue$1R(o, 'noiseY', undefined), GetValue$1R(o, 'noiseZ', undefined));
        this.setFromEdge(GetValue$1R(o, 'fromEdgeStart', 0.01), GetValue$1R(o, 'fromEdgeWidth', 0.05));
        this.setToEdge(GetValue$1R(o, 'toEdgeStart', 0.01), GetValue$1R(o, 'toEdgeWidth', 0.05));
        return this;
      }
    }, {
      key: "onBoot",
      value: function onBoot() {}
    }, {
      key: "onPreRender",
      value: function onPreRender() {
        this.set1f('progress', this.progress);
        this.set1i('resizeMode', this.resizeMode);
        this.set1f('noiseX', this.noiseX);
        this.set1f('noiseY', this.noiseY);
        this.set1f('noiseZ', this.noiseZ);
        this.set1f('fromEdgeStart', this.fromEdgeStart);
        this.set1f('fromEdgeWidth', this.fromEdgeWidth);
        this.set1f('toEdgeStart', this.toEdgeStart);
        this.set1f('toEdgeWidth', this.toEdgeWidth);
      }
    }, {
      key: "onDraw",
      value: function onDraw(renderTarget) {
        this.set1f('fromRatio', renderTarget.width / renderTarget.height);
        this.set1f('toRatio', this.toRatio);
        this.set1i('uMainSampler2', 1);
        this.bindTexture(this.targetTexture, 1);
        this.bindAndDraw(renderTarget);
      }
    }, {
      key: "progress",
      get: function get() {
        return this._progress;
      },
      set: function set(value) {
        this._progress = Clamp$9(value, 0, 1);
      }
    }, {
      key: "setProgress",
      value: function setProgress(value) {
        this.progress = value;
        return this;
      }
    }, {
      key: "setTransitionTargetTexture",
      value: function setTransitionTargetTexture(key, frame, resizeMode) {
        if (key === undefined) {
          key = '__DEFAULT';
        }
        var phaserTexture = this.game.textures.getFrame(key, frame);
        if (!phaserTexture) {
          phaserTexture = this.game.textures.getFrame('__DEFAULT');
        }
        this.toRatio = phaserTexture.width / phaserTexture.height;
        this.toFrame = phaserTexture;
        this.targetTexture = phaserTexture.glTexture;
        if (resizeMode !== undefined) {
          this.resizeMode = resizeMode;
        }
        return this;
      }
    }, {
      key: "setResizeMode",
      value: function setResizeMode(mode) {
        if (typeof mode === 'string') {
          mode = ResizeMode[mode];
        }
        this.resizeMode = mode;
        return this;
      }
    }, {
      key: "setNoise",
      value: function setNoise(x, y, z) {
        if (x === undefined) {
          x = 4 + Math.random() * 6;
        }
        if (y === undefined) {
          y = 4 + Math.random() * 6;
        }
        if (z === undefined) {
          z = Math.random() * 10;
        }
        this.noiseX = x;
        this.noiseY = y;
        this.noiseZ = z;
        return this;
      }
    }, {
      key: "setFromEdge",
      value: function setFromEdge(edgeStart, edgeWidth) {
        this.fromEdgeStart = edgeStart;
        this.fromEdgeWidth = edgeWidth;
        return this;
      }
    }, {
      key: "setToEdge",
      value: function setToEdge(edgeStart, edgeWidth) {
        this.toEdgeStart = edgeStart;
        this.toEdgeWidth = edgeWidth;
        return this;
      }
    }]);
    return DissolvePostFxPipeline;
  }(PostFXPipeline);
  /**
   * Set the resize mode of the target texture.
   * 
   * Can be either:
   * 
   * 0 - Stretch. The target texture is stretched to the size of the source texture.
   * 1 - Contain. The target texture is resized to fit the source texture. This is the default.
   * 2 - Cover. The target texture is resized to cover the source texture.
   * 
   * If the source and target textures are the same size, then use a resize mode of zero
   * for speed.
   *
   */
  var ResizeMode = {
    stretch: 0,
    contain: 1,
    cover: 2
  };

  var RegisterPostPipeline = function RegisterPostPipeline(game, postFxPipelineName, PostFxPipelineClass) {
    GetGame(game).renderer.pipelines.addPostPipeline(postFxPipelineName, PostFxPipelineClass);
  };

  var AddPostFxPipelineInstance = function AddPostFxPipelineInstance(gameObject, PostFxPipelineClass, config) {
    if (config === undefined) {
      config = {};
    }
    gameObject.setPostPipeline(PostFxPipelineClass);
    var pipeline = gameObject.postPipelines[gameObject.postPipelines.length - 1];
    pipeline.resetFromJSON(config);
    if (config.name) {
      pipeline.name = config.name;
    }
    return pipeline;
  };

  var SpliceOne$1 = Phaser.Utils.Array.SpliceOne;
  var RemovePostFxPipelineInstance = function RemovePostFxPipelineInstance(gameObject, PostFxPipelineClass, name) {
    if (name === undefined) {
      var pipelines = gameObject.postPipelines;
      for (var i = pipelines.length - 1; i >= 0; i--) {
        var instance = pipelines[i];
        if (instance instanceof PostFxPipelineClass) {
          instance.destroy();
          SpliceOne$1(pipelines, i);
        }
      }
    } else {
      var pipelines = gameObject.postPipelines;
      for (var i = 0, cnt = pipelines.length; i < cnt; i++) {
        var instance = pipelines[i];
        if (instance instanceof PostFxPipelineClass && instance.name === name) {
          instance.destroy();
          SpliceOne$1(pipelines, i);
        }
      }
    }
  };

  var AddDissolveMode = function AddDissolveMode(image) {
    RegisterPostPipeline(image.scene.game, 'rexDissolvePostFx', DissolvePostFxPipeline);
    image.addTransitionMode(Dissolve, {
      ease: 'Linear',
      dir: 'out',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        currentImage.effect = AddPostFxPipelineInstance(currentImage, DissolvePostFxPipeline);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        currentImage.effect.setProgress(t);
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        RemovePostFxPipelineInstance(currentImage, DissolvePostFxPipeline);
        delete currentImage.effect;
      }
    });
  };

  var WipeWidth = 0.1;
  var DirLeftToRight = 0;
  var DirTopToBottom = 0;
  var DirRightToLeft = 1;
  var DirBottomToTop = 1;
  var AxisX = 0;
  var AxisY = 1;
  var AddRevealModes = function AddRevealModes(image) {
    image.addTransitionMode(RevealRight, {
      ease: 'Linear',
      dir: 'in',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirLeftToRight, AxisX);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        nextImage.effect.progress = t;
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        nextImage.preFX.remove(nextImage.effect);
        delete nextImage.effect;
      }
    }).addTransitionMode(RevealLeft, {
      ease: 'Linear',
      dir: 'in',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirRightToLeft, AxisX);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        nextImage.effect.progress = t;
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        nextImage.preFX.remove(nextImage.effect);
        delete nextImage.effect;
      }
    }).addTransitionMode(RevealDown, {
      ease: 'Linear',
      dir: 'in',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirTopToBottom, AxisY);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        nextImage.effect.progress = t;
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        nextImage.preFX.remove(nextImage.effect);
        delete nextImage.effect;
      }
    }).addTransitionMode(RevealUp, {
      ease: 'Linear',
      dir: 'in',
      mask: false,
      onStart: function onStart(parent, currentImage, nextImage, t) {
        nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirBottomToTop, AxisY);
      },
      onProgress: function onProgress(parent, currentImage, nextImage, t) {
        nextImage.effect.progress = t;
      },
      onComplete: function onComplete(parent, currentImage, nextImage, t) {
        nextImage.preFX.remove(nextImage.effect);
        delete nextImage.effect;
      }
    });
  };

  var Modes = [AddSlideAwayModes, AddSlideModes, AddSliderModes, AddZoomModes, AddFadeModes, AddIrisModes, AddPieModes, AddWipeModes, AddBlindsModes, AddSquaresModes, AddDiamondsMode, AddCirclesMode, AddCurtainMode, AddPixellateMode, AddDissolveMode, AddRevealModes];

  var TransitionImagePack = /*#__PURE__*/function (_TransitionImage) {
    _inherits(TransitionImagePack, _TransitionImage);
    function TransitionImagePack(scene, x, y, texture, frame, config) {
      var _this;
      _classCallCheck(this, TransitionImagePack);
      _this = _callSuper(this, TransitionImagePack, [scene, x, y, texture, frame, config]);
      for (var i = 0, cnt = Modes.length; i < cnt; i++) {
        Modes[i](_assertThisInitialized(_this));
      }
      return _this;
    }
    return _createClass(TransitionImagePack);
  }(TransitionImage);

  var ScaleImage = function ScaleImage() {
    var image = this.image;
    var result = FitTo(image, {
      width: this.width,
      height: this.height
    }, this.scaleUp, true);
    image.setDisplaySize(result.width, result.height);
    this.resetChildScaleState(image);
    return this;
  };

  var methods$o = {
    scaleImage: ScaleImage
  };
  Object.assign(methods$o, FlipMethods);

  var ResizeBackground = function ResizeBackground() {
    var background = this.background;
    if (!background) {
      return this;
    }
    background.setOrigin(this.originX, this.originY);
    background.setPosition(this.x, this.y);
    ResizeGameObject(background, this.displayWidth, this.displayHeight);
    this.resetChildScaleState(background);
    return this;
  };

  var IsPlainObject$j = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1Q = Phaser.Utils.Objects.GetValue;
  var ImageBox = /*#__PURE__*/function (_Container) {
    _inherits(ImageBox, _Container);
    function ImageBox(scene, x, y, texture, frame, config) {
      var _this;
      _classCallCheck(this, ImageBox);
      if (IsPlainObject$j(x)) {
        config = x;
        x = GetValue$1Q(config, 'x', 0);
        y = GetValue$1Q(config, 'y', 0);
        texture = GetValue$1Q(config, 'key', undefined);
        frame = GetValue$1Q(config, 'frame', undefined);
      } else if (IsPlainObject$j(frame)) {
        config = frame;
        frame = undefined;
      }
      var image = GetValue$1Q(config, 'image');
      if (!image) {
        image = scene.add.image(x, y, texture, frame);
        if (texture === undefined) {
          image.setVisible(false);
        }
      } else {
        image.setPosition(x, y).setOrigin(0.5);
      }
      _this = _callSuper(this, ImageBox, [scene, x, y, 1, 1]);
      _this.type = 'rexImageBox';
      var background = GetValue$1Q(config, 'background');
      if (background) {
        _this.add(background);
      }
      _this.background = background;
      _this.add(image);
      _this.image = image;
      _this.scaleUp = GetValue$1Q(config, 'scaleUp', false);
      var width = GetValue$1Q(config, 'width', image.width);
      var height = GetValue$1Q(config, 'height', image.height);
      _this.resize(width, height);
      return _this;
    }
    _createClass(ImageBox, [{
      key: "texture",
      get: function get() {
        return this.image.texture;
      }
    }, {
      key: "frame",
      get: function get() {
        return this.image.frame;
      }
    }, {
      key: "flipX",
      get: function get() {
        return this._flipX;
      },
      set: function set(value) {
        if (this._flipX === value) {
          return;
        }
        this._flipX = value;
        this.image.setFlipX(value);
      }
    }, {
      key: "flipY",
      get: function get() {
        return this._flipY;
      },
      set: function set(value) {
        if (this._flipY === value) {
          return;
        }
        this._flipY = value;
        this.image.setFlipY(value);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        _get(_getPrototypeOf(ImageBox.prototype), "resize", this).call(this, width, height);
        ResizeBackground.call(this);
        this.scaleImage();
        return this;
      }
    }, {
      key: "setTexture",
      value: function setTexture(texture, frame) {
        var image = this.image;
        image.setTexture(texture, frame);
        if (texture !== null) {
          this.setChildVisible(image, true);
          this.scaleImage();
        } else {
          this.setChildVisible(image, false);
        }
        return this;
      }
    }]);
    return ImageBox;
  }(ContainerLite);
  Object.assign(ImageBox.prototype, methods$o);

  var GetChildrenWidth$3 = function GetChildrenWidth(minimumMode) {
    if (this.rexSizer.hidden) {
      return 0;
    }
    if (minimumMode === undefined) {
      minimumMode = true;
    }
    var result = 0;
    var children = this.sizerChildren;
    var child, sizerConfig, proportion, padding, childWidth;
    var hasUnknownChildWidth = false;
    this.childrenProportion; // To update this.hasProportion0Child member

    if (this.orientation === 0) {
      // x
      // Get summation of minimum width
      var itemSpace = this.space.item;
      var isFirstChild = true;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (!child.hasOwnProperty('rexSizer')) {
          continue;
        }
        sizerConfig = child.rexSizer;
        if (sizerConfig.hidden) {
          continue;
        }
        proportion = sizerConfig.proportion;
        if (proportion === 0 || minimumMode) {
          childWidth = this.getChildWidth(child);
          if (sizerConfig.fitRatio > 0 && !sizerConfig.resolved) {
            childWidth = undefined;
          }
          if (childWidth === undefined) {
            if (proportion !== 0 && !this.hasProportion0Child) {
              childWidth = 0;
            } else {
              hasUnknownChildWidth = true;
            }
          }
        } else {
          childWidth = 0;
        }
        if (hasUnknownChildWidth) {
          continue;
        }
        padding = child.rexSizer.padding;
        childWidth += padding.left + padding.right;
        if (isFirstChild) {
          isFirstChild = false;
        } else {
          childWidth += itemSpace;
        }
        result += childWidth;
      }
    } else {
      // Get maximun width
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (!child.hasOwnProperty('rexSizer')) {
          continue;
        }
        sizerConfig = child.rexSizer;
        if (sizerConfig.hidden) {
          continue;
        }
        childWidth = this.getChildWidth(child);
        if (childWidth === undefined) {
          hasUnknownChildWidth = true;
        }
        if (hasUnknownChildWidth) {
          continue;
        }
        padding = sizerConfig.padding;
        childWidth += padding.left + padding.right;
        result = Math.max(childWidth, result);
      }
    }
    if (hasUnknownChildWidth) {
      return undefined;
    }
    return result + this.space.left + this.space.right;
  };

  var GetChildrenHeight$3 = function GetChildrenHeight(minimumMode) {
    if (this.rexSizer.hidden) {
      return 0;
    }
    if (minimumMode === undefined) {
      minimumMode = true;
    }
    var result = 0;
    var children = this.sizerChildren;
    var child, sizerConfig, proportion, padding, childHeight;
    var hasUnknownChildHeight = false;
    this.childrenProportion; // To update this.hasProportion0Child member

    if (this.orientation === 0) {
      // x
      // Get maximun height
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (!child.hasOwnProperty('rexSizer')) {
          continue;
        }
        sizerConfig = child.rexSizer;
        if (sizerConfig.hidden) {
          continue;
        }
        childHeight = this.getChildHeight(child);
        if (childHeight === undefined) {
          hasUnknownChildHeight = true;
        }
        if (hasUnknownChildHeight) {
          continue;
        }
        padding = sizerConfig.padding;
        childHeight += padding.top + padding.bottom;
        result = Math.max(childHeight, result);
      }
    } else {
      // Get summation of minimum height
      var itemSpace = this.space.item;
      var isFirstChild = true;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (!child.hasOwnProperty('rexSizer')) {
          continue;
        }
        sizerConfig = child.rexSizer;
        if (sizerConfig.hidden) {
          continue;
        }
        proportion = sizerConfig.proportion;
        if (proportion === 0 || minimumMode) {
          childHeight = this.getChildHeight(child);
          if (sizerConfig.fitRatio > 0 && !sizerConfig.resolved) {
            childHeight = undefined;
          }
          if (childHeight === undefined) {
            if (proportion !== 0 && !this.hasProportion0Child) {
              childHeight = 0;
            } else {
              hasUnknownChildHeight = true;
            }
          }
        } else {
          childHeight = 0;
        }
        if (hasUnknownChildHeight) {
          continue;
        }
        padding = sizerConfig.padding;
        childHeight += padding.top + padding.bottom;
        if (isFirstChild) {
          isFirstChild = false;
        } else {
          childHeight += itemSpace;
        }
        result += childHeight;
      }
    }
    if (hasUnknownChildHeight) {
      return undefined;
    }
    return result + this.space.top + this.space.bottom;
  };

  var GetExpandedChildWidth$1 = function GetExpandedChildWidth(child, parentWidth) {
    if (parentWidth === undefined) {
      parentWidth = this.width;
    }
    var childWidth;
    var childConfig = child.rexSizer;
    if (this.orientation === 0) {
      // x
      if (childConfig.proportion > 0 && this.proportionLength > 0) {
        childWidth = childConfig.proportion * this.proportionLength;
      }
    } else {
      // y
      if (childConfig.expand) {
        var space = this.space;
        var innerWidth = parentWidth - space.left - space.right;
        var padding = childConfig.padding;
        childWidth = innerWidth - padding.left - padding.right;
      }
    }
    return childWidth;
  };

  var GetExpandedChildHeight$1 = function GetExpandedChildHeight(child, parentHeight) {
    if (parentHeight === undefined) {
      parentHeight = this.height;
    }
    var childHeight;
    var childConfig = child.rexSizer;
    if (this.orientation === 0) {
      // x
      if (childConfig.expand) {
        var space = this.space;
        var innerHeight = parentHeight - space.top - space.bottom;
        var padding = childConfig.padding;
        childHeight = innerHeight - padding.top - padding.bottom;
      }
    } else {
      // y
      if (childConfig.proportion > 0 && this.proportionLength > 0) {
        childHeight = childConfig.proportion * this.proportionLength;
      }
    }
    return childHeight;
  };

  var GetChildrenSizers$3 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }
    var children = this.sizerChildren,
      child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child.isRexSizer) {
        out.push(child);
      }
    }
    return out;
  };

  var PreLayout$3 = function PreLayout() {
    // Resize child to 1x1 for ratio-fit 
    this.hasRatioFitChild = false;
    var child, sizerConfig;
    var children = this.sizerChildren;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      sizerConfig = child.rexSizer;
      if (sizerConfig.hidden) {
        continue;
      }
      if (sizerConfig.fitRatio > 0) {
        ResizeGameObject(child, 0, 0);
        sizerConfig.resolved = false;
        this.hasRatioFitChild = true;
      }
    }
    this._childrenProportion = undefined;
    this.hasProportion0Child = false;
    this.proportionLength = undefined;
    PreLayout$4.call(this);
    return this;
  };

  var Wrap = Phaser.Math.Wrap;
  var LayoutChildren$4 = function LayoutChildren() {
    var children = this.sizerChildren;
    var child, childConfig, padding;
    var startX = this.innerLeft,
      startY = this.innerTop;
    var innerWidth = this.innerWidth;
    var innerHeight = this.innerHeight;
    var itemX = startX,
      itemY = startY;
    var x, y, width, height; // Align zone
    var childWidth, childHeight;
    var childIndex,
      startChildIndex = this.startChildIndex;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      if (startChildIndex === 0) {
        childIndex = i;
      } else {
        childIndex = Wrap(i + startChildIndex, 0, cnt);
      }
      if (this.rtl) {
        childIndex = cnt - childIndex - 1;
      }
      child = children[childIndex];
      if (child.rexSizer.hidden) {
        continue;
      }
      childConfig = child.rexSizer;
      padding = childConfig.padding;
      PreLayoutChild.call(this, child);

      // Set size
      if (child.isRexSpace) {
        childWidth = 0;
        childHeight = 0;
      } else {
        childWidth = this.getExpandedChildWidth(child);
        childHeight = this.getExpandedChildHeight(child);
      }
      if (child.isRexSizer) {
        child.runLayout(this, childWidth, childHeight);
        CheckSize(child, this);
      } else {
        ResizeGameObject(child, childWidth, childHeight);
      }
      if (childWidth === undefined) {
        childWidth = GetDisplayWidth(child);
      }
      if (childHeight === undefined) {
        childHeight = GetDisplayHeight(child);
      }

      // Set position
      if (this.orientation === 0) {
        // x
        x = itemX + padding.left;
        if (childConfig.proportion === 0 || this.proportionLength === 0) {
          width = childWidth;
        } else {
          width = childConfig.proportion * this.proportionLength;
        }
        y = itemY + padding.top;
        height = innerHeight - padding.top - padding.bottom;
      } else {
        // y
        x = itemX + padding.left;
        width = innerWidth - padding.left - padding.right;
        y = itemY + padding.top;
        if (childConfig.proportion === 0 || this.proportionLength === 0) {
          height = childHeight;
        } else {
          height = childConfig.proportion * this.proportionLength;
        }
      }
      LayoutChild.call(this, child, x, y, width, height, childConfig.align);
      if (this.orientation === 0) {
        // x
        itemX += width + padding.left + padding.right + this.space.item;
      } else {
        // y
        itemY += height + padding.top + padding.bottom + this.space.item;
      }
    }
  };

  var ResolveWidth$1 = function ResolveWidth(width) {
    var width = ResolveWidth$3.call(this, width);

    // Calculate proportionLength
    if (width !== undefined && this.orientation === 0 && this.proportionLength === undefined) {
      var remainder = width - this.childrenWidth;
      if (remainder > 0) {
        remainder = width - this.getChildrenWidth(false);
        this.proportionLength = remainder / this.childrenProportion;
      } else {
        this.proportionLength = 0;
      }
    }
    return width;
  };

  var ResolveHeight$1 = function ResolveHeight(height) {
    var height = ResolveHeight$3.call(this, height);

    // Get proportionLength
    if (height !== undefined && this.orientation === 1 && this.proportionLength === undefined) {
      var remainder = height - this.childrenHeight;
      if (remainder > 0) {
        remainder = height - this.getChildrenHeight(false);
        this.proportionLength = remainder / this.childrenProportion;
      } else {
        this.proportionLength = 0;
      }
    }
    return height;
  };

  var HasWidthWrap$1 = function HasWidthWrap() {
    if (this.hasRatioFitChild && this.orientation === 1) {
      return true;
    }
    return HasWidthWrap$2.call(this);
  };

  var ExpandFitRatioChildren = function ExpandFitRatioChildren(width, height) {
    if (!this.hasRatioFitChild) {
      return;
    }
    var innerHeight;
    if (this.orientation === 0) {
      innerHeight = height - this.getInnerPadding('top') - this.getInnerPadding('bottom');
    } else {
      width - this.getInnerPadding('left') - this.getInnerPadding('right');
    }
    var child, sizerConfig;
    var childWidth, childHeight;
    var children = this.sizerChildren;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      var sizerConfig = child.rexSizer;
      if (sizerConfig.hidden) {
        continue;
      }
      var fitRatio = sizerConfig.fitRatio;
      if (!fitRatio) {
        continue;
      }
      if (this.orientation === 0) {
        // Set child width by child height 
        childHeight = innerHeight - this.getChildOuterPadding(child, 'top') - this.getChildOuterPadding(child, 'bottom');
        childWidth = childHeight * fitRatio;
      } else {
        // Set child height by child width
        childWidth = innerHeight - this.getChildOuterPadding(child, 'top') - this.getChildOuterPadding(child, 'bottom');
        childHeight = childWidth / fitRatio;
      }
      ResizeGameObject(child, childWidth, childHeight);
      if (child.isRexSizer) {
        child.setMinSize(childWidth, childHeight);
      }
      sizerConfig.resolved = true;
    }
  };

  var RunWidthWrap$2 = function RunWidthWrap(width) {
    if (this.wrapResult) {
      // Already got wrapResult
      return;
    }
    if (this.orientation === 1) {
      ExpandFitRatioChildren.call(this, width, undefined);
    }
    RunWidthWrap$3.call(this, width);
  };

  var HasHeightWrap$1 = function HasHeightWrap() {
    if (this.hasRatioFitChild && this.orientation === 0) {
      return true;
    }
    return HasHeightWrap$2.call(this);
  };

  var RunHeightWrap$2 = function RunHeightWrap(height) {
    if (this.wrapResult) {
      // Already got wrapResult
      return;
    }
    if (this.orientation === 0) {
      ExpandFitRatioChildren.call(this, undefined, height);
    }
    RunHeightWrap$3.call(this, height);
  };

  var Zone = Phaser.GameObjects.Zone;
  var Space = /*#__PURE__*/function (_Zone) {
    _inherits(Space, _Zone);
    function Space(scene) {
      var _this;
      _classCallCheck(this, Space);
      _this = _callSuper(this, Space, [scene, 0, 0, 1, 1]);
      // Don't add Zone into scene
      _this.isRexSpace = true;
      return _this;
    }
    return _createClass(Space);
  }(Zone);

  var GetNearestChildIndex$1 = function GetNearestChildIndex(x, y) {
    var children = this.sizerChildren;
    if (children.length === 0) {
      return -1;
    }
    var nearestIndex = -1,
      minDistance = Infinity;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      var distance;
      if (this.orientation === 0) {
        // x
        distance = Math.abs(child.left - x);
      } else {
        distance = Math.abs(child.top - y);
      }
      if (minDistance > distance) {
        minDistance = distance;
        nearestIndex = i;
      }
    }

    // Check right bound of last child
    var child = children[children.length - 1];
    var distance;
    if (this.orientation === 0) {
      // x
      distance = Math.abs(child.right - x);
    } else {
      distance = Math.abs(child.bottom - y);
    }
    if (minDistance > distance) {
      minDistance = distance;
      nearestIndex = i + 1;
    }
    return nearestIndex;
  };

  var IsPlainObject$i = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1P = Phaser.Utils.Objects.GetValue;
  var ALIGN_CENTER$2 = Phaser.Display.Align.CENTER;
  var PROPORTIONMODE = {
    min: 0,
    full: -1
  };
  var Add$6 = function Add(gameObject, proportion, align, paddingConfig, expand, childKey, index, minWidth, minHeight, fitRatio) {
    AddChild$1.call(this, gameObject);
    var isRexSpace = gameObject.isRexSpace;
    var proportionType = _typeof(proportion);
    if (proportion === null) {
      return this;
    } else if (proportionType === 'number') ; else if (proportionType === 'string') {
      proportion = PROPORTIONMODE[proportion];
    } else if (IsPlainObject$i(proportion)) {
      var config = proportion;
      proportion = GetValue$1P(config, 'proportion', undefined);
      align = GetValue$1P(config, 'align', ALIGN_CENTER$2);
      paddingConfig = GetValue$1P(config, 'padding', 0);
      expand = GetValue$1P(config, 'expand', false);
      childKey = GetValue$1P(config, 'key', undefined);
      index = GetValue$1P(config, 'index', undefined);
      if (!gameObject.isRexSizer) {
        minWidth = GetValue$1P(config, 'minWidth', undefined);
        minHeight = GetValue$1P(config, 'minHeight', undefined);
      }
      fitRatio = GetValue$1P(config, 'fitRatio', 0); // width/height
    }
    if (typeof align === 'string') {
      align = AlignConst[align];
    }
    if (proportion === undefined) {
      proportion = isRexSpace ? 1 : 0;
    }
    if (align === undefined) {
      align = ALIGN_CENTER$2;
    }
    if (paddingConfig === undefined) {
      paddingConfig = 0;
    }
    if (expand === undefined) {
      expand = false;
    }
    if (minWidth === undefined) {
      if (isRexSpace) {
        minWidth = 0;
      } else if (!gameObject.isRexSizer) {
        minWidth = gameObject._minWidth;
      }
    }
    if (minHeight === undefined) {
      if (isRexSpace) {
        minHeight = 0;
      } else if (!gameObject.isRexSizer) {
        minHeight = gameObject._minHeight;
      }
    }
    if (fitRatio === undefined || fitRatio === false) {
      fitRatio = 0;
    } else if (fitRatio === true) {
      fitRatio = GetDisplayWidth(gameObject) / GetDisplayHeight(gameObject);
    }
    var config = this.getSizerConfig(gameObject);
    config.proportion = proportion;
    config.align = align;
    config.padding = GetBoundsConfig(paddingConfig);
    config.expand = expand;
    config.fitRatio = proportion === 0 ? fitRatio : 0;
    if (index === undefined || index >= this.sizerChildren.length) {
      this.sizerChildren.push(gameObject);
    } else {
      this.sizerChildren.splice(index, 0, gameObject);
    }
    if (!gameObject.isRexSizer) {
      // Expand normal game object
      if (proportion > 0) {
        if (this.orientation === 0) {
          // x
          // minWidth is still undefined, uses current display width
          gameObject.minWidth = minWidth === undefined ? GetDisplayWidth(gameObject) : minWidth;
        } else {
          // minHeight is still undefined, uses current display height
          gameObject.minHeight = minHeight === undefined ? GetDisplayHeight(gameObject) : minHeight;
        }
      }
      if (expand) {
        if (this.orientation === 0) {
          // x
          // Might have minHeight value, or still undefined
          gameObject.minHeight = minHeight;
        } else {
          // Might have minWidth value, or still undefined
          gameObject.minWidth = minWidth;
        }
      }
    }
    if (childKey !== undefined) {
      this.addChildrenMap(childKey, gameObject);
    }
    return this;
  };
  var AddChildMethods$6 = {
    add: Add$6,
    // sizer.add could be override
    addSpace: function addSpace(proportion) {
      this.insertSpace(undefined, proportion);
      return this;
    },
    insertSpace: function insertSpace(index, proportion) {
      if (proportion === undefined) {
        proportion = 1;
      }
      Add$6.call(this, new Space(this.scene), {
        proportion: proportion,
        minWidth: 0,
        minHeight: 0,
        index: index
      });
      // No problem if sizer.add is override
      return this;
    },
    insert: function insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
      if (IsPlainObject$i(proportion)) {
        proportion.index = index;
      }
      Add$6.call(this, gameObject, proportion, align, paddingConfig, expand, childKey, index, minSize);
      // No problem if sizer.add is override
      return this;
    },
    insertAtPosition: function insertAtPosition(x, y, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
      var index = GetNearestChildIndex$1.call(this, x, y);
      if (index === -1) {
        index = undefined;
      }
      this.insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize);
      return this;
    }
  };

  var RemoveItem$2 = Phaser.Utils.Array.Remove;
  var RemoveChildMethods$5 = {
    remove: function remove(gameObject, destroyChild) {
      if (this.getParentSizer(gameObject) !== this) {
        return this;
      }
      RemoveItem$2(this.sizerChildren, gameObject);
      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAll: function removeAll(destroyChild) {
      for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
        this.remove(this.sizerChildren[i], destroyChild);
      }
      return this;
    },
    clear: function clear(destroyChild) {
      this.sizerChildren.length = 0;
      ClearChildren.call(this, destroyChild);
      return this;
    }
  };

  var AlignMethods = {
    getChildAlign: function getChildAlign(gameObject) {
      return this.getSizerConfig(gameObject).align;
    },
    setChildAlign: function setChildAlign(gameObject, align) {
      if (typeof align === 'string') {
        align = AlignConst[align];
      }
      this.getSizerConfig(gameObject).align = align;
      return this;
    }
  };

  var ProportionMethods = {
    getChildProportion: function getChildProportion(gameObject) {
      return this.getSizerConfig(gameObject).proportion;
    },
    setChildProportion: function setChildProportion(gameObject, proportion) {
      this.getSizerConfig(gameObject).proportion = proportion;
      return this;
    }
  };

  var ExpandMethods$1 = {
    getChildExpand: function getChildExpand(gameObject) {
      return this.getSizerConfig(gameObject).expand;
    },
    setChildExpand: function setChildExpand(gameObject, expand) {
      this.getSizerConfig(gameObject).expand = expand;
      return this;
    }
  };

  var SetChildrenAlignMode = function SetChildrenAlignMode(mode) {
    if (mode === undefined) {
      mode = 'left';
    }
    var children = this.sizerChildren;
    var firstChild = children[0];
    var isFirstChildASpace = firstChild && firstChild.isRexSpace;
    if (
    // Has left space
    mode === 'right' || mode === 'bottom' || mode === 'center') {
      if (!isFirstChildASpace) {
        this.insertSpace(0);
      }
    } else {
      // Does not have left space
      if (isFirstChildASpace) {
        this.remove(firstChild, true);
      }
    }
    var lastChildIndex = children.length - 1;
    var lastChild = children[lastChildIndex];
    var isLastChildASpace = lastChild && lastChild.isRexSpace;
    if (mode === 'center') {
      // Has right space
      if (!isLastChildASpace) {
        this.insertSpace(lastChildIndex + 1);
      }
    } else {
      // Does not have right space
      if (isLastChildASpace) {
        this.remove(lastChild, true);
      }
    }
    return this;
  };

  var methods$n = {
    getChildrenWidth: GetChildrenWidth$3,
    getChildrenHeight: GetChildrenHeight$3,
    getExpandedChildWidth: GetExpandedChildWidth$1,
    getExpandedChildHeight: GetExpandedChildHeight$1,
    getChildrenSizers: GetChildrenSizers$3,
    preLayout: PreLayout$3,
    layoutChildren: LayoutChildren$4,
    resolveWidth: ResolveWidth$1,
    resolveHeight: ResolveHeight$1,
    hasWidthWrap: HasWidthWrap$1,
    runWidthWrap: RunWidthWrap$2,
    hasHeightWrap: HasHeightWrap$1,
    runHeightWrap: RunHeightWrap$2,
    setChildrenAlignMode: SetChildrenAlignMode
  };
  Object.assign(methods$n, AddChildMethods$6, RemoveChildMethods$5, AlignMethods, ProportionMethods, ExpandMethods$1);

  var GetChildrenProportion = function GetChildrenProportion() {
    var result = 0;
    var children = this.sizerChildren;
    var child, proportion;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child.rexSizer.hidden) {
        continue;
      }
      proportion = child.rexSizer.proportion;
      if (proportion > 0) {
        result += proportion;
      } else if (proportion === 0) {
        this.hasProportion0Child = true;
      }
    }
    return result;
  };

  var OrientationMode = {
    x: 0,
    h: 0,
    horizontal: 0,
    'left-to-right': 0,
    y: 1,
    v: 1,
    vertical: 1,
    'top-to-bottom': 1
  };
  var GetOrientationMode = function GetOrientationMode(orientation) {
    if (typeof orientation === 'string') {
      orientation = OrientationMode[orientation];
    }
    return orientation;
  };

  var IsPlainObject$h = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1O = Phaser.Utils.Objects.GetValue;
  var Sizer = /*#__PURE__*/function (_BaseSizer) {
    _inherits(Sizer, _BaseSizer);
    function Sizer(scene, x, y, minWidth, minHeight, orientation, config) {
      var _this;
      _classCallCheck(this, Sizer);
      if (IsPlainObject$h(x)) {
        config = x;
        x = GetValue$1O(config, 'x', 0);
        y = GetValue$1O(config, 'y', 0);
        minWidth = GetValue$1O(config, 'width', undefined);
        minHeight = GetValue$1O(config, 'height', undefined);
        orientation = GetValue$1O(config, 'orientation', 0);
      } else if (IsPlainObject$h(minWidth)) {
        config = minWidth;
        minWidth = GetValue$1O(config, 'width', undefined);
        minHeight = GetValue$1O(config, 'height', undefined);
        orientation = GetValue$1O(config, 'orientation', 0);
      } else if (IsPlainObject$h(orientation)) {
        config = orientation;
        orientation = GetValue$1O(config, 'orientation', 0);
      }
      if (orientation === undefined) {
        orientation = 0;
      }
      _this = _callSuper(this, Sizer, [scene, x, y, minWidth, minHeight, config]);
      _this.type = 'rexSizer';
      _this.sizerChildren = [];
      _this.setOrientation(orientation);
      _this.setItemSpacing(GetValue$1O(config, 'space.item', 0));
      _this.setStartChildIndex(GetValue$1O(config, 'startChildIndex', 0));
      _this.setRTL(GetValue$1O(config, 'rtl', false));
      _this.addChildrenMap('items', _this.sizerChildren);
      return _this;
    }
    _createClass(Sizer, [{
      key: "setOrientation",
      value: function setOrientation(orientation) {
        this.orientation = GetOrientationMode(orientation);
        return this;
      }
    }, {
      key: "setItemSpacing",
      value: function setItemSpacing(space) {
        this.space.item = space;
        return this;
      }
    }, {
      key: "setStartChildIndex",
      value: function setStartChildIndex(index) {
        this.startChildIndex = index;
        return this;
      }
    }, {
      key: "setRTL",
      value: function setRTL(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.rtl = enable;
        return this;
      }
    }, {
      key: "childrenProportion",
      get: function get() {
        if (this._childrenProportion === undefined) {
          this._childrenProportion = GetChildrenProportion.call(this);
        }
        return this._childrenProportion;
      }
    }]);
    return Sizer;
  }(Base);
  Object.assign(Sizer.prototype, methods$n);

  var SetDisplaySize = function SetDisplaySize(gameObject, width, height) {
    if (!gameObject) {
      return;
    }
    var unknownWidth = width == null;
    var unknownHeight = height == null;
    if (unknownWidth && unknownHeight) {
      return gameObject;
    }
    if (!unknownWidth) {
      gameObject.displayWidth = width;
    }
    if (!unknownHeight) {
      gameObject.displayHeight = height;
    }
    if (unknownWidth) {
      gameObject.scaleX = gameObject.scaleY;
    }
    if (unknownHeight) {
      gameObject.scaleY = gameObject.scaleX;
    }
    return gameObject;
  };

  var ResetDisplayContent$1 = function ResetDisplayContent(config) {
    if (config === undefined) {
      config = {};
    } else if (typeof config === 'string') {
      config = {
        text: config
      };
    }
    var text = config.text || '';
    this.setText(text);
    var iconGameObjct = this.childrenMap.icon;
    if (iconGameObjct) {
      if (!config.icon) {
        this.hide(iconGameObjct);
      } else {
        this.show(iconGameObjct);
      }
      var iconSize = config.iconSize;
      if (iconSize) {
        this.setChildDisplaySize(iconGameObjct, iconSize, iconSize);
        if (this.iconWidth !== undefined) {
          this.setIconSize(iconSize);
        }
      }
      if (config.icon !== true) {
        this.setIconTexture(config.icon, config.iconFrame);
      }
    }
    var actionGameObjct = this.childrenMap.action;
    if (actionGameObjct) {
      if (!config.action) {
        this.hide(actionGameObjct);
      } else {
        this.show(actionGameObjct);
      }
      var actionSize = config.actionSize;
      if (actionSize) {
        this.setChildDisplaySize(actionGameObjct, actionSize, actionSize);
        if (this.actionWidth !== undefined) {
          this.setActionSize(actionSize);
        }
      }
      if (config.action !== true) {
        this.setActionTexture(config.action, config.actionFrame);
      }
    }
    return this;
  };

  var methods$m = {
    appendText: AppendText$1,
    resetDisplayContent: ResetDisplayContent$1
  };

  var LabelBase = /*#__PURE__*/function (_Sizer) {
    _inherits(LabelBase, _Sizer);
    function LabelBase() {
      _classCallCheck(this, LabelBase);
      return _callSuper(this, LabelBase, arguments);
    }
    _createClass(LabelBase, [{
      key: "text",
      get:
      /*
      Elements in childrenMap: 
      
      - background
      - icon, iconMask
      - text, 
      - action, actionMask
      */

      // Access text game object
      function get() {
        var textObject = this.childrenMap.text;
        if (!textObject) {
          return '';
        }
        return textObject.text;
      },
      set: function set(value) {
        var textObject = this.childrenMap.text;
        if (!textObject) {
          return;
        }
        textObject.setText(value);
      }
    }, {
      key: "setText",
      value: function setText(value) {
        this.text = value;
        return this;
      }

      // Access icon game object
    }, {
      key: "setIconTexture",
      value: function setIconTexture(key, frame) {
        var imageObject = this.childrenMap.icon;
        if (!imageObject || !imageObject.setTexture) {
          return this;
        }
        imageObject.setTexture(key, frame);
        if (this.iconWidth !== undefined && this.iconHeight !== undefined) {
          SetDisplaySize(imageObject, this.iconWidth, this.iconHeight);
          this.resetChildScaleState(imageObject);
        }
        return this;
      }
    }, {
      key: "setTexture",
      value: function setTexture(key, frame) {
        this.setIconTexture(key, frame);
        return this;
      }
    }, {
      key: "setIconSize",
      value: function setIconSize(width, height) {
        if (height === undefined) {
          height = width;
        }
        this.iconWidth = width;
        this.iconHeight = height;
        return this;
      }
    }, {
      key: "texture",
      get: function get() {
        var imageObject = this.childrenMap.icon;
        if (!imageObject) {
          return undefined;
        }
        return imageObject.texture;
      }
    }, {
      key: "frame",
      get: function get() {
        var imageObject = this.childrenMap.icon;
        if (!imageObject) {
          return undefined;
        }
        return imageObject.frame;
      }
    }, {
      key: "setActionTexture",
      value: function setActionTexture(key, frame) {
        var imageObject = this.childrenMap.action;
        if (!imageObject || !imageObject.setTexture) {
          return this;
        }
        imageObject.setTexture(key, frame);
        if (this.actionWidth !== undefined && this.actionHeight !== undefined) {
          SetDisplaySize(imageObject, this.actionWidth, this.actionHeight);
          this.resetChildScaleState(imageObject);
        }
        return this;
      }
    }, {
      key: "actionTexture",
      get: function get() {
        var imageObject = this.childrenMap.action;
        if (!imageObject) {
          return undefined;
        }
        return imageObject.texture;
      }
    }, {
      key: "actionFrame",
      get: function get() {
        var imageObject = this.childrenMap.action;
        if (!imageObject) {
          return undefined;
        }
        return imageObject.frame;
      }
    }, {
      key: "setActionSize",
      value: function setActionSize(width, height) {
        if (height === undefined) {
          height = width;
        }
        this.actionWidth = width;
        this.actionHeight = height;
        return this;
      }
    }, {
      key: "preLayout",
      value: function preLayout() {
        var icon = this.childrenMap.icon;
        if (icon && this.iconWidth !== undefined && this.iconHeight !== undefined) {
          SetDisplaySize(icon, this.iconWidth, this.iconHeight);
        }
        var action = this.childrenMap.action;
        if (action && this.actionWidth !== undefined && this.actionHeight !== undefined) {
          SetDisplaySize(action, this.actionWidth, this.actionHeight);
        }
        _get(_getPrototypeOf(LabelBase.prototype), "preLayout", this).call(this);
      }
    }, {
      key: "postLayout",
      value: function postLayout(parent, newWidth, newHeight) {
        // Pin icon-mask to icon game object
        var iconMask = this.childrenMap.iconMask;
        if (iconMask) {
          iconMask.setPosition();
          this.resetChildPositionState(iconMask);
        }
        // Pin action-mask to action game object
        var actionMask = this.childrenMap.actionMask;
        if (actionMask) {
          actionMask.setPosition();
          this.resetChildPositionState(actionMask);
        }
        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        _get(_getPrototypeOf(LabelBase.prototype), "resize", this).call(this, width, height);
        // Resize icon-mask to icon game object
        var iconMask = this.childrenMap.iconMask;
        if (iconMask) {
          iconMask.resize();
        }
        // Resize action-mask to icon game object
        var actionMask = this.childrenMap.actionMask;
        if (actionMask) {
          actionMask.resize();
        }
        return this;
      }
    }]);
    return LabelBase;
  }(Sizer);
  Object.assign(LabelBase.prototype, methods$m);

  var AddChildMask = function AddChildMask(maskTarget, sizeTarget, shape, padding) {
    var maskGameObject = new DefaultMaskGraphics(sizeTarget, shape, padding); // A Graphics game object
    if (maskTarget && !maskTarget.isRexSizer) {
      // Sizer game object can't apply mask
      var mask = maskGameObject.createGeometryMask();
      maskTarget.setMask(mask);
      this.once('destroy', function () {
        maskTarget.setMask();
        mask.destroy();
      });
    }
    this.pin(maskGameObject);
    return maskGameObject;
  };

  var GetValue$1N = Phaser.Utils.Objects.GetValue;
  var Label = /*#__PURE__*/function (_LabelBase) {
    _inherits(Label, _LabelBase);
    function Label(scene, config) {
      var _this;
      _classCallCheck(this, Label);
      // Create sizer
      _this = _callSuper(this, Label, [scene, config]);
      _this.type = 'rexLabel';

      // Add elements
      var background = GetValue$1N(config, 'background', undefined);
      var icon = GetValue$1N(config, 'icon', undefined);
      var iconMask = GetValue$1N(config, 'iconMask', undefined);
      var text = GetValue$1N(config, 'text', undefined);
      var action = GetValue$1N(config, 'action', undefined);
      var actionMask = GetValue$1N(config, 'actionMask', undefined);
      // Align
      var align = GetValue$1N(config, 'align', undefined); // undefined/left/top: no space

      if (background) {
        _this.addBackground(background);
      }
      if (icon) {
        var padding;
        if (_this.orientation === 0) {
          if (text || action) {
            padding = {
              right: GetValue$1N(config, 'space.icon', 0),
              top: GetValue$1N(config, 'space.iconTop', 0),
              bottom: GetValue$1N(config, 'space.iconBottom', 0),
              left: GetValue$1N(config, 'space.iconLeft', 0)
            };
          }
        } else {
          if (text || action) {
            padding = {
              bottom: GetValue$1N(config, 'space.icon', 0),
              left: GetValue$1N(config, 'space.iconLeft', 0),
              right: GetValue$1N(config, 'space.iconRight', 0),
              top: GetValue$1N(config, 'space.iconTop', 0)
            };
          }
        }
        var fitRatio = GetValue$1N(config, 'squareFitIcon', false) ? 1 : 0;
        _this.add(icon, {
          proportion: 0,
          padding: padding,
          fitRatio: fitRatio
        });
        if (iconMask) {
          iconMask = AddChildMask.call(_assertThisInitialized(_this), icon, icon, 1); // Circle mask
        }
        if (!fitRatio) {
          var iconSize = GetValue$1N(config, 'iconSize', undefined);
          _this.setIconSize(GetValue$1N(config, 'iconWidth', iconSize), GetValue$1N(config, 'iconHeight', iconSize));
        }
      }
      if (text) {
        var textSpace = GetValue$1N(config, 'space.text', 0);
        var expandTextWidth = GetValue$1N(config, 'expandTextWidth', false);
        var expandTextHeight = GetValue$1N(config, 'expandTextHeight', false);
        var proportion, padding, expand;
        if (_this.orientation === 0) {
          proportion = expandTextWidth ? 1 : 0;
          if (action) {
            padding = {
              right: textSpace
            };
          }
          expand = expandTextHeight;
        } else {
          proportion = expandTextHeight ? 1 : 0;
          if (action) {
            padding = {
              bottom: textSpace
            };
          }
          expand = expandTextWidth;
        }
        _this.add(text, {
          proportion: proportion,
          expand: expand,
          padding: padding
        });
      }
      if (action) {
        var padding;
        if (_this.orientation === 0) {
          padding = {
            top: GetValue$1N(config, 'space.actionTop', 0),
            bottom: GetValue$1N(config, 'space.actionBottom', 0),
            right: GetValue$1N(config, 'space.actionRight', 0)
          };
        } else {
          padding = {
            left: GetValue$1N(config, 'space.actionLeft', 0),
            right: GetValue$1N(config, 'space.actionRight', 0),
            bottom: GetValue$1N(config, 'space.actionBottom', 0)
          };
        }
        var fitRatio = GetValue$1N(config, 'squareFitAction', false) ? 1 : 0;
        _this.add(action, {
          proportion: 0,
          padding: padding,
          fitRatio: fitRatio
        });
        if (actionMask) {
          actionMask = AddChildMask.call(_assertThisInitialized(_this), action, action, 1); // Circle mask
        }
        if (!fitRatio) {
          var actionSize = GetValue$1N(config, 'actionSize');
          _this.setActionSize(GetValue$1N(config, 'actionWidth', actionSize), GetValue$1N(config, 'actionHeight', actionSize));
        }
      }
      _this.setChildrenAlignMode(align);
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('icon', icon);
      _this.addChildrenMap('iconMask', iconMask);
      _this.addChildrenMap('text', text);
      _this.addChildrenMap('action', action);
      _this.addChildrenMap('actionMask', actionMask);
      return _this;
    }
    return _createClass(Label);
  }(LabelBase);

  var GetValue$1M = Phaser.Utils.Objects.GetValue;
  var CreateCanvas = function CreateCanvas(scene, config) {
    var canvasConfig = GetValue$1M(config, 'canvas');
    var width = GetValue$1M(canvasConfig, 'width', 128);
    var height = GetValue$1M(canvasConfig, 'height', 128);
    var canvas = new Canvas(scene, 0, 0, width, height);
    scene.add.existing(canvas);
    var key = GetValue$1M(canvasConfig, 'key');
    var frame = GetValue$1M(canvasConfig, 'frame');
    var fillColor = GetValue$1M(canvasConfig, 'fill');
    if (fillColor !== undefined) {
      canvas.fill(fillColor);
    } else if (key !== undefined) {
      canvas.loadTexture(key, frame);
    }

    // Compatible with Image game object for ImageBox
    canvas.setTexture = canvas.loadTexture.bind(canvas);
    return canvas;
  };
  var CreateImageBox = function CreateImageBox(scene, config) {
    var icon = new ImageBox(scene, {
      scaleUp: GetValue$1M(config, 'scaleUpIcon', false),
      background: GetValue$1M(config, 'iconBackground'),
      image: CreateCanvas(scene, config)
    });
    scene.add.existing(icon);
    return icon;
  };

  var GetValue$1L = Phaser.Utils.Objects.GetValue;
  var GetClickTarget = function GetClickTarget(parent, config) {
    var clickTarget = GetValue$1L(config, 'clickTarget', this);
    if (typeof clickTarget === 'string') {
      clickTarget = parent.getElement(clickTarget);
    }
    return clickTarget;
  };

  var GetValue$1K = Phaser.Utils.Objects.GetValue;
  var CreateClickBehavior = function CreateClickBehavior(parent, config) {
    var clickTarget = GetClickTarget(parent, config);
    if (!clickTarget) {
      return undefined;
    }
    var clickConfig = GetValue$1K(config, 'click');
    var clickBehavior = new Button(clickTarget, clickConfig);
    clickBehavior.on('click', parent.open, parent);
    return clickBehavior;
  };

  var GetValue$1J = Phaser.Utils.Objects.GetValue;
  var CreateFileInput = function CreateFileInput(game, config) {
    var fileInput = document.createElement('input');
    fileInput.type = 'file';
    var accept = GetValue$1J(config, 'accept', '');
    var multiple = GetValue$1J(config, 'multiple', false);
    fileInput.setAttribute('accept', accept);
    if (multiple) {
      fileInput.setAttribute('multiple', '');
    } else {
      fileInput.removeAttribute('multiple');
    }
    return fileInput;
  };

  var Delay = function Delay(time, result) {
    if (time === undefined) {
      time = 0;
    }
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        resolve(result);
      }, time);
    });
  };

  var ClickPromise = function ClickPromise(_ref) {
    var game = _ref.game,
      fileInput = _ref.fileInput,
      closeDelay = _ref.closeDelay;
    return WaitEvent(GetGame(game).events, 'focus').then(function () {
      return Delay(closeDelay);
    }).then(function () {
      var result = {
        files: fileInput.files
      };
      return Promise.resolve(result);
    });
  };

  // Note: Not working in iOS9+

  var GetValue$1I = Phaser.Utils.Objects.GetValue;
  var RemoveFromDOM = Phaser.DOM.RemoveFromDOM;
  var Open$1 = function Open(game, config) {
    // game: game, scene, or game object
    var closeDelay = GetValue$1I(config, 'closeDelay', 200);
    var fileInput = CreateFileInput(game, config);
    fileInput.click();
    return ClickPromise({
      game: game,
      fileInput: fileInput,
      closeDelay: closeDelay
    }).then(function (result) {
      RemoveFromDOM(fileInput);
      fileInput.remove();
      return Promise.resolve(result);
    });
  };

  var Resize = function Resize(width, height) {
    if (this.scene.sys.scale.autoRound) {
      width = Math.floor(width);
      height = Math.floor(height);
    }
    if (this.width === width && this.height === height) {
      return this;
    }
    var style = this.node.style;
    style.width = "".concat(width, "px");
    style.height = "".concat(height, "px");
    this.updateSize();
    return this;
  };

  var SyncTo = function SyncTo(gameObject) {
    this.setOrigin(gameObject.originX, gameObject.originY);
    this.setPosition(gameObject.x, gameObject.y);
    this.resize(gameObject.displayWidth, gameObject.displayHeight);
    return this;
  };

  var GetCache = function GetCache(game, loaderType, cacheType) {
    if (cacheType === undefined) {
      switch (loaderType) {
        case 'image':
        case 'svg':
          cacheType = 'textures';
          break;
        case 'animation':
          cacheType = 'json';
          break;
        case 'tilemapTiledJSON':
        case 'tilemapCSV':
          cacheType = 'tilemap';
          break;
        case 'glsl':
          cacheType = 'shader';
          break;
        default:
          cacheType = loaderType;
          break;
      }
    }
    game = GetGame(game);
    var cache;
    if (cacheType === 'textures') {
      cache = game.textures;
    } else {
      cache = game.cache[cacheType];
    }
    return cache;
  };

  var FileObjectToCache = function FileObjectToCache(scene, file, loaderType, key, cacheType, onComplete) {
    // Remove data from cache
    if (cacheType === null || cacheType === false) ; else if (IsFunction(cacheType)) {
      cacheType();
    } else {
      var cache = GetCache(scene, loaderType, cacheType);
      if (cache.exists(key)) {
        cache.remove(key);
      }
    }

    // Add filecomplete event
    var loader = scene.load;
    if (onComplete) {
      loader.once("filecomplete-".concat(loaderType, "-").concat(key), function (key, type, data) {
        onComplete(data);
      });
    }

    // Load file from url
    if (IsFunction(file)) {
      file();
    } else {
      var url = window.URL.createObjectURL(file);
      loader[loaderType](key, url);
    }
    loader.start();
  };

  var LoadFile = function LoadFile(file, loaderType, key, cacheType, onComplete) {
    var scene = this.scene;
    FileObjectToCache(scene, file, loaderType, key, cacheType, onComplete);
    return this;
  };
  var LoadFilePromise = function LoadFilePromise(file, loaderType, key, cacheType) {
    var scene = this.scene;
    return new Promise(function (resolve, reject) {
      var onComplete = function onComplete(data) {
        resolve(data);
      };
      FileObjectToCache(scene, file, loaderType, key, cacheType, onComplete);
    });
  };
  var LoadFileMethods = {
    loadFile: LoadFile,
    loadFilePromise: LoadFilePromise
  };

  var DOMElement$2 = Phaser.GameObjects.DOMElement;
  var IsPlainObject$g = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1H = Phaser.Utils.Objects.GetValue;
  var FileChooser = /*#__PURE__*/function (_DOMElement) {
    _inherits(FileChooser, _DOMElement);
    function FileChooser(scene, x, y, width, height, config) {
      var _this;
      _classCallCheck(this, FileChooser);
      if (IsPlainObject$g(x)) {
        config = x;
        x = GetValue$1H(config, 'x', 0);
        y = GetValue$1H(config, 'y', 0);
        width = GetValue$1H(config, 'width', 0);
        height = GetValue$1H(config, 'height', 0);
      } else if (IsPlainObject$g(width)) {
        config = width;
        width = GetValue$1H(config, 'width', 0);
        height = GetValue$1H(config, 'height', 0);
      }

      // Create a hidden file input
      var inputElement = document.createElement('input');
      inputElement.type = 'file';
      var inputStyle = inputElement.style;
      inputStyle.display = 'none';

      // Create a label parent
      var labelElement = document.createElement('label');
      labelElement.appendChild(inputElement);
      var style = GetValue$1H(config, 'style', undefined);
      _this = _callSuper(this, FileChooser, [scene, x, y, labelElement, style]);
      _this.type = 'rexFileChooser';
      _this.resetFromJSON(config);
      _this.resize(width, height);

      // Register events
      var self = _assertThisInitialized(_this);
      inputElement.onchange = function () {
        self.emit('change', self);
      };
      _this.setCloseDelay(GetValue$1H(config, 'closeDelay', 200));
      inputElement.onclick = function () {
        ClickPromise({
          game: scene,
          fileInput: inputElement,
          closeDelay: self.closeDelay
        }).then(function () {
          self.emit('select', self);
        });
      };
      return _this;
    }
    _createClass(FileChooser, [{
      key: "resetFromJSON",
      value: function resetFromJSON(config) {
        this.setAccept(GetValue$1H(config, 'accept', ''));
        this.setMultiple(GetValue$1H(config, 'multiple', false));
        return this;
      }
    }, {
      key: "setAccept",
      value: function setAccept(accept) {
        if (accept === undefined) {
          accept = '';
        }
        this.fileInput.setAttribute('accept', accept);
        return this;
      }
    }, {
      key: "setMultiple",
      value: function setMultiple(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        if (enabled) {
          this.fileInput.setAttribute('multiple', '');
        } else {
          this.fileInput.removeAttribute('multiple');
        }
        return this;
      }
    }, {
      key: "setCloseDelay",
      value: function setCloseDelay(delay) {
        if (delay === undefined) {
          delay = 200;
        }
        this.closeDelay = delay;
        return this;
      }
    }, {
      key: "fileInput",
      get: function get() {
        return this.node.children[0];
      }
    }, {
      key: "open",
      value: function open() {
        // Only work under any touch event
        this.fileInput.click();
        return this;
      }
    }, {
      key: "files",
      get: function get() {
        return this.fileInput.files;
      }
    }, {
      key: "setOpenEnable",
      value: function setOpenEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.fileInput.disabled = !enable;
        return this;
      }
    }]);
    return FileChooser;
  }(DOMElement$2);
  var methods$l = {
    resize: Resize,
    syncTo: SyncTo
  };
  Object.assign(FileChooser.prototype, methods$l, LoadFileMethods);

  var Config = {
    accept: 'image/*',
    multiple: false
  };

  var OnSelectFile = function OnSelectFile(parent, files) {
    if (files.length === 0) {
      return;
    }
    var imageBox = parent.childrenMap.icon;
    var canvas = imageBox.image;
    var selectedFile = files[0];
    return canvas.loadFromFilePromise(selectedFile).then(function () {
      imageBox.scaleImage();
      parent.emit('select', selectedFile, parent);
      return Promise.resolve(selectedFile);
    });
  };

  var CreateFileChooser = function CreateFileChooser(parent, config) {
    var scene = parent.scene;
    var fileChooser = new FileChooser(scene, Config);
    scene.add.existing(fileChooser);
    parent.pin(fileChooser);
    fileChooser.on('change', function () {
      OnSelectFile(parent, fileChooser.files);
    });
    return fileChooser;
  };

  var OpenMethods = {
    openPromise: function openPromise() {
      var _this = this;
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var self;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              self = _this;
              return _context.abrupt("return", Open$1(_this.scene.game, Config).then(function (result) {
                return OnSelectFile(self, result.files);
              }));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    },
    open: function open() {
      this.openPromise();
      return this;
    },
    setClickOpenEnable: function setClickOpenEnable(enable) {
      if (enable === undefined) {
        enable = true;
      }
      if (this.clickBehavior) {
        this.clickBehavior.setEnable(enable);
      }
      if (this.fileChooser) {
        this.fileChooser.setOpenEnable(enable);
      }
      return this;
    }
  };

  var GetFileName = function GetFileName(file) {
    if (!file) {
      return null;
    }
    var name = file.name;
    return name.substr(0, name.lastIndexOf('.'));
  };

  var SaveTexture = function SaveTexture(key) {
    var canvas = this.childrenMap.canvas;
    canvas.generateTexture(key);
    return this;
  };

  var methods$k = {
    getFileName: GetFileName,
    saveTexture: SaveTexture
  };
  Object.assign(methods$k, OpenMethods);

  var GetValue$1G = Phaser.Utils.Objects.GetValue;

  /*
  Label :
      - icon : imageBox
          - image: canvas
  */
  var ImageInputLabel = /*#__PURE__*/function (_Label) {
    _inherits(ImageInputLabel, _Label);
    function ImageInputLabel(scene, config) {
      var _this;
      _classCallCheck(this, ImageInputLabel);
      var icon = CreateImageBox(scene, config);
      config.icon = icon;
      _this = _callSuper(this, ImageInputLabel, [scene, config]);
      _this.type = 'rexImageFileInputLabel';

      // Set initial size of icon(imageBox)
      var iconWidth = _this.iconWidth,
        iconHeight = _this.iconWidth;
      if (iconWidth !== undefined && iconHeight !== undefined) {
        icon.resize(iconWidth, iconHeight);
      }
      _this.clickTarget = GetClickTarget(_assertThisInitialized(_this), config);
      if (_this.clickTarget) {
        if (!GetValue$1G(config, 'domButton', true)) {
          _this.clickBehavior = CreateClickBehavior(_assertThisInitialized(_this), config);
        } else {
          _this.fileChooser = CreateFileChooser(_assertThisInitialized(_this));
        }
      }
      _this.addChildrenMap('canvas', icon.image);
      _this.addChildrenMap('iconBackground', icon.background);
      _this.addChildrenMap('fileChooser', _this.fileChooser);
      return _this;
    }
    _createClass(ImageInputLabel, [{
      key: "postLayout",
      value: function postLayout() {
        if (this.fileChooser) {
          this.fileChooser.syncTo(this.clickTarget);
          this.resetChildState(this.fileChooser);
        }
      }
    }]);
    return ImageInputLabel;
  }(Label);
  Object.assign(ImageInputLabel.prototype, methods$k);

  var ElementProperties = {
    id: ['id', undefined],
    text: ['value', undefined],
    maxLength: ['maxLength', undefined],
    minLength: ['minLength', undefined],
    placeholder: ['placeholder', undefined],
    tooltip: ['title', undefined],
    readOnly: ['readOnly', false],
    spellCheck: ['spellcheck', false],
    autoComplete: ['autocomplete', 'off']
  };
  var StyleProperties = {
    align: ['textAlign', undefined],
    paddingLeft: ['padding-left', undefined],
    paddingRight: ['padding-right', undefined],
    paddingTop: ['padding-top', undefined],
    paddingBottom: ['padding-bottom', undefined],
    fontFamily: ['fontFamily', undefined],
    fontSize: ['font-size', undefined],
    color: ['color', '#ffffff'],
    backgroundColor: ['backgroundColor', 'transparent'],
    border: ['border', 0],
    borderColor: ['borderColor', 'transparent'],
    outline: ['outline', 'none'],
    direction: ['direction', undefined]
  };
  var ElementEvents = {
    input: 'textchange',
    click: 'click',
    dblclick: 'dblclick',
    mousedown: 'pointerdown',
    mousemove: 'pointermove',
    mouseup: 'pointerup',
    touchstart: 'pointerdown',
    touchmove: 'pointermove',
    touchend: 'pointerup',
    keydown: 'keydown',
    keyup: 'keyup',
    keypress: 'keypress',
    compositionstart: 'compositionStart',
    compositionend: 'compositionEnd',
    compositionupdate: 'compositionUpdate',
    focus: 'focus',
    blur: 'blur',
    select: 'select'
  };

  var GetValue$1F = Phaser.Utils.Objects.GetValue;
  var RouteEvents = function RouteEvents(gameObject, element, elementEvents, config) {
    var preventDefault = GetValue$1F(config, 'preventDefault', false);
    var preTest = GetValue$1F(config, 'preTest');
    var _loop = function _loop(elementEventName) {
      // Note: Don't use `var` here
      element.addEventListener(elementEventName, function (e) {
        if (!preTest || preTest(gameObject, elementEventName)) {
          gameObject.emit(elementEvents[elementEventName], gameObject, e);
        }
        if (preventDefault) {
          e.preventDefault();
        }
      });
    };
    for (var elementEventName in elementEvents) {
      _loop(elementEventName);
    }
  };

  var DOMElement$1 = Phaser.GameObjects.DOMElement;
  var IsPlainObject$f = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1E = Phaser.Utils.Objects.GetValue;
  var InputText = /*#__PURE__*/function (_DOMElement) {
    _inherits(InputText, _DOMElement);
    function InputText(scene, x, y, width, height, config) {
      var _this;
      _classCallCheck(this, InputText);
      if (IsPlainObject$f(x)) {
        config = x;
        x = GetValue$1E(config, 'x', 0);
        y = GetValue$1E(config, 'y', 0);
        width = GetValue$1E(config, 'width', 0);
        height = GetValue$1E(config, 'height', 0);
      } else if (IsPlainObject$f(width)) {
        config = width;
        width = GetValue$1E(config, 'width', 0);
        height = GetValue$1E(config, 'height', 0);
      }
      if (config === undefined) {
        config = {};
      }
      var element;
      var textType = GetValue$1E(config, 'inputType', undefined);
      if (textType === undefined) {
        textType = GetValue$1E(config, 'type', 'text');
      }
      if (textType === 'textarea') {
        element = document.createElement('textarea');
        element.style.resize = 'none';
      } else {
        element = document.createElement('input');
        element.type = textType;
      }
      SetProperties(ElementProperties, config, element);
      var style = GetValue$1E(config, 'style', undefined);
      style = SetProperties(StyleProperties, config, style);
      // Apply other style properties
      var elementStyle = element.style;
      for (var key in config) {
        if (key in ElementProperties || key in StyleProperties) {
          continue;
        } else if (key in elementStyle) {
          style[key] = config[key];
        }
      }
      style['box-sizing'] = 'border-box';
      _this = _callSuper(this, InputText, [scene, x, y, element, style]);
      _this.type = 'rexInputText';
      _this.resize(width, height);

      // Apply events
      RouteEvents(_assertThisInitialized(_this), element, ElementEvents);

      // Don't propagate touch/mouse events to parent(game canvas)
      StopPropagationTouchEvents(element);
      if (GetValue$1E(config, 'selectAll', false)) {
        _this.selectAll();
      }
      _this._isFocused = false;
      _this.on('focus', function () {
        this._isFocused = true;
      }, _assertThisInitialized(_this)).on('blur', function () {
        this._isFocused = false;
      }, _assertThisInitialized(_this));
      return _this;
    }
    _createClass(InputText, [{
      key: "inputType",
      get: function get() {
        if (this.node.tagName.toLowerCase() === 'textarea') {
          return 'textarea';
        } else {
          return this.node.type;
        }
      }
    }, {
      key: "text",
      get: function get() {
        return this.node.value;
      },
      set: function set(value) {
        this.node.value = value;
      }
    }, {
      key: "setText",
      value: function setText(value) {
        // Override
        this.text = value;
        return this;
      }
    }, {
      key: "maxLength",
      get: function get() {
        return this.node.maxLength;
      },
      set: function set(value) {
        this.node.maxLength = value;
      }
    }, {
      key: "setMaxLength",
      value: function setMaxLength(value) {
        this.maxLength = value;
        return this;
      }
    }, {
      key: "minLength",
      get: function get() {
        return this.node.minLength;
      },
      set: function set(value) {
        this.node.minLength = value;
      }
    }, {
      key: "setMinLength",
      value: function setMinLength(value) {
        this.minLength = value;
        return this;
      }
    }, {
      key: "placeholder",
      get: function get() {
        return this.node.placeholder;
      },
      set: function set(value) {
        this.node.placeholder = value;
      }
    }, {
      key: "setPlaceholder",
      value: function setPlaceholder(value) {
        this.placeholder = value;
        return this;
      }
    }, {
      key: "selectText",
      value: function selectText(selectionStart, selectionEnd) {
        if (selectionStart === undefined) {
          this.node.select();
        } else {
          this.node.setSelectionRange(selectionStart, selectionEnd);
        }
        return this;
      }
    }, {
      key: "selectAll",
      value: function selectAll() {
        this.selectText();
        return this;
      }
    }, {
      key: "selectionStart",
      get: function get() {
        return this.node.selectionStart;
      }
    }, {
      key: "selectionEnd",
      get: function get() {
        return this.node.selectionEnd;
      }
    }, {
      key: "selectedText",
      get: function get() {
        var node = this.node;
        return node.value.substring(node.selectionStart, node.selectionEnd);
      }
    }, {
      key: "cursorPosition",
      get: function get() {
        return this.node.selectionStart;
      },
      set: function set(value) {
        this.node.setSelectionRange(value, value);
      }
    }, {
      key: "setCursorPosition",
      value: function setCursorPosition(value) {
        if (value === undefined) {
          value = this.text.length;
        } else if (value < 0) {
          value = this.text.length + value;
        }
        this.cursorPosition = value;
        return this;
      }
    }, {
      key: "tooltip",
      get: function get() {
        return this.node.title;
      },
      set: function set(value) {
        this.node.title = value;
      }
    }, {
      key: "setTooltip",
      value: function setTooltip(value) {
        this.tooltip = value;
        return this;
      }
    }, {
      key: "setTextChangedCallback",
      value: function setTextChangedCallback(callback) {
        this.onTextChanged = callback;
        return this;
      }
    }, {
      key: "readOnly",
      get: function get() {
        return this.node.readOnly;
      },
      set: function set(value) {
        this.node.readOnly = value;
      }
    }, {
      key: "setReadOnly",
      value: function setReadOnly(value) {
        if (value === undefined) {
          value = true;
        }
        this.readOnly = value;
        return this;
      }
    }, {
      key: "spellCheck",
      get: function get() {
        return this.node.spellcheck;
      },
      set: function set(value) {
        this.node.spellcheck = value;
      }
    }, {
      key: "setSpellCheck",
      value: function setSpellCheck(value) {
        this.spellCheck = value;
        return this;
      }
    }, {
      key: "fontColor",
      get: function get() {
        return this.node.style.color;
      },
      set: function set(value) {
        this.node.style.color = value;
      }
    }, {
      key: "setFontColor",
      value: function setFontColor(value) {
        this.fontColor = value;
        return this;
      }
    }, {
      key: "setStyle",
      value: function setStyle(key, value) {
        this.node.style[key] = value;
        return this;
      }
    }, {
      key: "getStyle",
      value: function getStyle(key) {
        return this.node.style[key];
      }
    }, {
      key: "scrollToBottom",
      value: function scrollToBottom() {
        this.node.scrollTop = this.node.scrollHeight;
        return this;
      }
    }, {
      key: "setEnabled",
      value: function setEnabled(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        this.node.disabled = !enabled;
        return this;
      }
    }, {
      key: "setBlur",
      value: function setBlur() {
        this.node.blur();
        return this;
      }
    }, {
      key: "setFocus",
      value: function setFocus() {
        this.node.focus();
        return this;
      }
    }, {
      key: "isFocused",
      get: function get() {
        return this._isFocused;
      }
    }]);
    return InputText;
  }(DOMElement$1);
  var methods$j = {
    resize: Resize
  };
  Object.assign(InputText.prototype, methods$j);

  var DropEnableMethods = {
    setDropEnable: function setDropEnable(enable) {
      if (enable === undefined) {
        enable = true;
      }
      this.dropEnable = enable;
      return this;
    },
    toggleDropEnable: function toggleDropEnable() {
      this.dropEnable = !this.dropEnable;
      return this;
    }
  };

  var FilterMethods = {
    addFilter: function addFilter(name, callback) {
      if (!this.filters) {
        this.filters = {};
      }
      this.filters[name] = callback;
      return this;
    },
    addFilters: function addFilters(filters) {
      if (!this.filters) {
        this.filters = {};
      }
      for (var name in filters) {
        this.filters[name] = filters[name];
      }
      return this;
    }
  };

  var Methods$8 = {
    resize: Resize,
    syncTo: SyncTo
  };
  Object.assign(Methods$8, DropEnableMethods, FilterMethods, LoadFileMethods);

  var DragDropEvents = {
    dragenter: 'dragenter',
    dragleave: 'dragleave',
    dragover: 'dragover',
    drop: 'drop'
  };

  var DOMElement = Phaser.GameObjects.DOMElement;
  var IsPlainObject$e = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1D = Phaser.Utils.Objects.GetValue;
  var FileDropZone = /*#__PURE__*/function (_DOMElement) {
    _inherits(FileDropZone, _DOMElement);
    function FileDropZone(scene, x, y, width, height, config) {
      var _this;
      _classCallCheck(this, FileDropZone);
      if (IsPlainObject$e(x)) {
        config = x;
        x = GetValue$1D(config, 'x', 0);
        y = GetValue$1D(config, 'y', 0);
        width = GetValue$1D(config, 'width', 0);
        height = GetValue$1D(config, 'height', 0);
      } else if (IsPlainObject$e(width)) {
        config = width;
        width = GetValue$1D(config, 'width', 0);
        height = GetValue$1D(config, 'height', 0);
      }
      if (config === undefined) {
        config = {};
      }
      var element = document.createElement('div');
      var style = GetValue$1D(config, 'style', undefined);
      _this = _callSuper(this, FileDropZone, [scene, x, y, element, style]);
      _this.type = 'rexFileDropZone';
      _this.resize(width, height);
      _this._files = [];
      _this.setDropEnable(GetValue$1D(config, 'dropEnable', true));
      var filters = GetValue$1D(config, 'filters');
      if (filters) {
        _this.addFilters(filters);
      }

      // Apply events
      RouteEvents(_assertThisInitialized(_this), element, DragDropEvents, {
        preventDefault: true,
        preTest: function preTest(gameObject) {
          return gameObject.dropEnable;
        }
      });
      _this.on('drop', function (gameObject, e) {
        this._files = e.dataTransfer.files;
        var files = this._files;
        if (files && this.filters) {
          for (var filterType in this.filters) {
            var filterCallback = this.filters[filterType];
            var filteredFiles = [];
            for (var i = 0, cnt = files.length; i < cnt; i++) {
              var file = files[i];
              if (filterCallback(file, files)) {
                filteredFiles.push(file);
              }
            }
            if (filteredFiles.length > 0) {
              this.emit("drop.".concat(filterType), filteredFiles);
            }
          }
        }
      }, _assertThisInitialized(_this));
      return _this;
    }
    _createClass(FileDropZone, [{
      key: "files",
      get: function get() {
        return this._files;
      }
    }]);
    return FileDropZone;
  }(DOMElement);
  Object.assign(FileDropZone.prototype, Methods$8);

  var Style$3 = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Style, _ComponentBase);
    function Style(gameObject, style) {
      var _this;
      _classCallCheck(this, Style);
      _this = _callSuper(this, Style, [gameObject]);
      // this.parent = gameObject;

      return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), _assertThisInitialized(_this)));
    }
    _createClass(Style, [{
      key: "get",
      value: function get(target, prop) {
        if (HasProperty(target, prop)) {
          return target[prop];
        }
        var gameObject = target.parent;
        if (HasProperty(gameObject, prop)) {
          return gameObject[prop];
        }
      }
    }, {
      key: "set",
      value: function set(target, prop, value) {
        if (HasProperty(target, prop)) {
          target[prop] = value;
        } else if (HasProperty(target.parent, prop)) {
          target.parent[prop] = value;
        }
        return true;
      }
    }, {
      key: "key",
      get: function get() {
        return this.parent.texture.key;
      },
      set: function set(value) {
        this.parent.setTexture(value, this.frame);
      }
    }, {
      key: "fontSize",
      get: function get() {
        return this.parent.fontSize;
      },
      set: function set(value) {
        this.parent.setFontSize(value);
      }
    }, {
      key: "tint",
      get: function get() {
        return this.parent.tintTopLeft;
      },
      set: function set(value) {
        this.parent.setTint(value);
      }
    }, {
      key: "letterSpacing",
      get: function get() {
        return this.parent.letterSpacing;
      },
      set: function set(value) {
        this.parent.setLetterSpacing(value);
      }
    }, {
      key: "lineSpacing",
      get: function get() {
        return this.parent.lineSpacing;
      },
      set: function set(value) {
        this.parent.setLineSpacing(value);
      }
    }]);
    return Style;
  }(ComponentBase);

  var GetValue$1C = Phaser.Utils.Objects.GetValue;
  var StyleManager = /*#__PURE__*/function (_ComponentBase) {
    _inherits(StyleManager, _ComponentBase);
    function StyleManager(gameObject, config) {
      var _this;
      _classCallCheck(this, StyleManager);
      _this = _callSuper(this, StyleManager, [gameObject, config]);
      // this.parent = gameObject;

      _this.style = GetValue$1C(config, 'style', _assertThisInitialized(_this));
      var propertiesMap = GetValue$1C(config, 'propertiesMap');
      _this.activeStyle = ExtractStyle(config, 'active', propertiesMap);
      _this.hoverStyle = ExtractStyle(config, 'hover', propertiesMap);
      _this.disableStyle = ExtractStyle(config, 'disable', propertiesMap);
      _this.onModifyStyle = GetValue$1C(config, 'onModifyStyle');
      return _this;
    }
    _createClass(StyleManager, [{
      key: "getStyle",
      value: function getStyle(keys) {
        return GetPartialData(this.style, keys);
      }
    }, {
      key: "modifyStyle",
      value: function modifyStyle(style) {
        for (var key in style) {
          this.style[key] = style[key];
        }
        if (this.onModifyStyle) {
          this.onModifyStyle(this.parent, style);
        }
        return this;
      }
    }, {
      key: "applyStyle",
      value: function applyStyle(newStyle) {
        if (!newStyle) {
          return undefined;
        }
        var currentStyle = this.getStyle(newStyle);
        if (!IsKeyValueEqual(currentStyle, newStyle)) {
          this.modifyStyle(newStyle);
          return currentStyle;
        } else {
          return undefined;
        }
      }
    }, {
      key: "setActiveState",
      value: function setActiveState(enable) {
        SetStateEnableMethod.call(this, 'active', enable);
        return this;
      }
    }, {
      key: "setHoverState",
      value: function setHoverState(enable) {
        SetStateEnableMethod.call(this, 'hover', enable);
        return this;
      }
    }, {
      key: "setDisableState",
      value: function setDisableState(enable) {
        SetStateEnableMethod.call(this, 'disable', enable);
        return this;
      }
    }]);
    return StyleManager;
  }(ComponentBase);
  var ExtractStyle = function ExtractStyle(config, prefix, propertiesMap) {
    var result = ExtractByPrefix(config, prefix);
    if (propertiesMap) {
      for (var name in result) {
        if (propertiesMap.hasOwnProperty(name)) {
          result[propertiesMap[name]] = result[name];
          delete result[name];
        }
      }
    }
    return result;
  };
  var SetStateEnableMethod = function SetStateEnableMethod(stateName, enable) {
    if (enable === undefined) {
      enable = true;
    }
    var stateVarName = "".concat(stateName, "State");
    var styleVarName = "".concat(stateName, "Style");
    var styleSaveVarName = "".concat(stateName, "StyleSave");
    if (this[stateVarName] === enable) {
      return;
    }
    this[stateVarName] = enable;
    if (enable) {
      this[styleSaveVarName] = this.applyStyle(this[styleVarName]);
    } else {
      this.applyStyle(this[styleSaveVarName]);
      this[styleSaveVarName] = undefined;
    }
  };

  var HelperMethods = {
    addStyleManager: function addStyleManager(config) {
      this.styleManager = new StyleManager(this, config);
      return this;
    },
    setActiveState: function setActiveState(enable) {
      this.styleManager.setActiveState(enable);
      return this;
    },
    setHoverState: function setHoverState(enable) {
      this.styleManager.setHoverState(enable);
      return this;
    },
    setDisableState: function setDisableState(enable) {
      this.styleManager.setDisableState(enable);
      return this;
    }
  };

  var PhaserBitmapText = Phaser.GameObjects.BitmapText;
  var GetValue$1B = Phaser.Utils.Objects.GetValue;
  var StatesBitmapText = /*#__PURE__*/function (_PhaserBitmapText) {
    _inherits(StatesBitmapText, _PhaserBitmapText);
    function StatesBitmapText(scene, config) {
      var _this;
      _classCallCheck(this, StatesBitmapText);
      if (config === undefined) {
        config = {};
      }
      var x = GetValue$1B(config, 'x', 0);
      var y = GetValue$1B(config, 'y', 0);
      var font = GetValue$1B(config, 'font', '');
      var size = GetValue$1B(config, 'fontSize', false);
      var align = GetValue$1B(config, 'align', 0);
      var tint = GetValue$1B(config, 'tint');
      _this = _callSuper(this, StatesBitmapText, [scene, x, y, font, '', size, align]);
      _this.type = 'rexStatesBitmapText';
      if (tint !== undefined) {
        _this.setTint(tint);
      }
      var effectConfig = GetValue$1B(config, 'effects', true);
      if (effectConfig) {
        AddEffectProperties(_assertThisInitialized(_this), effectConfig);
      }
      _this.style = new Style$3(_assertThisInitialized(_this), config);
      config.style = _this.style;
      _this.addStyleManager(config);
      delete config.style;
      return _this;
    }
    return _createClass(StatesBitmapText);
  }(PhaserBitmapText);
  Object.assign(StatesBitmapText.prototype, HelperMethods);

  var Style$2 = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Style, _ComponentBase);
    function Style(gameObject, style) {
      var _this;
      _classCallCheck(this, Style);
      _this = _callSuper(this, Style, [gameObject]);
      // this.parent = gameObject;

      return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), _assertThisInitialized(_this)));
    }
    _createClass(Style, [{
      key: "get",
      value: function get(target, prop) {
        if (HasProperty(target, prop)) {
          return target[prop];
        }
        var gameObject = target.parent;
        if (HasProperty(gameObject, prop)) {
          return gameObject[prop];
        }
      }
    }, {
      key: "set",
      value: function set(target, prop, value) {
        if (HasProperty(target, prop)) {
          target[prop] = value;
        } else if (HasProperty(target.parent, prop)) {
          target.parent[prop] = value;
        }
        return true;
      }
    }, {
      key: "key",
      get: function get() {
        return this.parent.texture.key;
      },
      set: function set(value) {
        this.parent.setTexture(value, this.frame);
      }
    }, {
      key: "frame",
      get: function get() {
        return this.parent.frame.name;
      },
      set: function set(value) {
        this.parent.setFrame(value);
      }
    }, {
      key: "scale",
      get: function get() {
        return this.parent.scaleX;
      },
      set: function set(value) {
        this.parent.setScale(value);
      }
    }]);
    return Style;
  }(ComponentBase);

  var PhaserImage = Phaser.GameObjects.Image;
  var GetValue$1A = Phaser.Utils.Objects.GetValue;
  var StatesImage = /*#__PURE__*/function (_PhaserImage) {
    _inherits(StatesImage, _PhaserImage);
    function StatesImage(scene, config) {
      var _this;
      _classCallCheck(this, StatesImage);
      if (config === undefined) {
        config = {};
      }
      var x = GetValue$1A(config, 'x', 0);
      var y = GetValue$1A(config, 'y', 0);
      var key = GetValue$1A(config, 'key', '');
      var frame = GetValue$1A(config, 'frame', undefined);
      _this = _callSuper(this, StatesImage, [scene, x, y, key, frame]);
      _this.type = 'rexStatesImage';
      var effectConfig = GetValue$1A(config, 'effects', true);
      if (effectConfig) {
        AddEffectProperties(_assertThisInitialized(_this), effectConfig);
      }
      _this.style = new Style$2(_assertThisInitialized(_this), config);
      config.style = _this.style;
      _this.addStyleManager(config);
      delete config.style;
      return _this;
    }
    return _createClass(StatesImage);
  }(PhaserImage);
  Object.assign(StatesImage.prototype, HelperMethods);

  var Style$1 = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Style, _ComponentBase);
    function Style(gameObject, style) {
      var _this;
      _classCallCheck(this, Style);
      _this = _callSuper(this, Style, [gameObject]);
      // this.parent = gameObject;

      return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), _assertThisInitialized(_this)));
    }
    _createClass(Style, [{
      key: "get",
      value: function get(target, prop) {
        if (HasProperty(target, prop)) {
          return target[prop];
        }
        var gameObject = target.parent;
        if (HasProperty(gameObject, prop)) {
          return gameObject[prop];
        }
      }
    }, {
      key: "set",
      value: function set(target, prop, value) {
        if (HasProperty(target, prop)) {
          target[prop] = value;
        } else if (HasProperty(target.parent, prop)) {
          target.parent[prop] = value;
        }
        return true;
      }
    }, {
      key: "key",
      get: function get() {
        return this.parent.textureKey;
      },
      set: function set(value) {
        if (this.key === value) {
          return;
        }
        this.parent.setBaseTexture(value, this.baseFrameName);
      }
    }, {
      key: "frame",
      get: function get() {
        return this.parent.baseFrameName;
      },
      set: function set(value) {
        if (this.frame === value) {
          return;
        }
        this.parent.setBaseTexture(this.parent.textureKey, value);
      }
    }]);
    return Style;
  }(ComponentBase);

  var GetValue$1z = Phaser.Utils.Objects.GetValue;
  var StatesNinePatch = /*#__PURE__*/function (_NinePatch) {
    _inherits(StatesNinePatch, _NinePatch);
    function StatesNinePatch(scene, config) {
      var _this;
      _classCallCheck(this, StatesNinePatch);
      if (config === undefined) {
        config = {};
      }
      _this = _callSuper(this, StatesNinePatch, [scene, config]);
      _this.type = 'rexStatesNinePatch';
      var effectConfig = GetValue$1z(config, 'effects', true);
      if (effectConfig) {
        AddEffectProperties(_assertThisInitialized(_this), effectConfig);
      }
      _this.style = new Style$1(_assertThisInitialized(_this), config);
      config.style = _this.style;
      _this.addStyleManager(config);
      delete config.style;
      return _this;
    }
    return _createClass(StatesNinePatch);
  }(NinePatch$1);
  Object.assign(StatesNinePatch.prototype, HelperMethods);

  var Style = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Style, _ComponentBase);
    function Style(gameObject, style) {
      var _this;
      _classCallCheck(this, Style);
      _this = _callSuper(this, Style, [gameObject]);
      // this.parent = gameObject;

      return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), _assertThisInitialized(_this)));
    }
    _createClass(Style, [{
      key: "get",
      value: function get(target, prop) {
        if (HasProperty(target, prop)) {
          return target[prop];
        }
        var gameObject = target.parent;
        if (HasProperty(gameObject, prop)) {
          return gameObject[prop];
        }
      }
    }, {
      key: "set",
      value: function set(target, prop, value) {
        if (HasProperty(target, prop)) {
          target[prop] = value;
        } else if (HasProperty(target.parent, prop)) {
          target.parent[prop] = value;
        }
        return true;
      }
    }, {
      key: "key",
      get: function get() {
        return this.parent.texture.key;
      },
      set: function set(value) {
        if (this.key === value) {
          return;
        }
        this.parent.setTexture(value, this.frame);
      }
    }, {
      key: "frame",
      get: function get() {
        return this.parent.frame.name;
      },
      set: function set(value) {
        if (this.frame === value) {
          return;
        }
        this.parent.setFrame(value);
      }
    }]);
    return Style;
  }(ComponentBase);

  var PhaserNineSlice = Phaser.GameObjects.NineSlice;
  var GetValue$1y = Phaser.Utils.Objects.GetValue;
  var StatesNineSlice = /*#__PURE__*/function (_PhaserNineSlice) {
    _inherits(StatesNineSlice, _PhaserNineSlice);
    function StatesNineSlice(scene, config) {
      var _this;
      _classCallCheck(this, StatesNineSlice);
      if (config === undefined) {
        config = {};
      }
      var x = GetValue$1y(config, 'x', 0);
      var y = GetValue$1y(config, 'y', 0);
      var key = GetValue$1y(config, 'key', null);
      var frame = GetValue$1y(config, 'frame', null);
      var width = GetValue$1y(config, 'width', 0);
      var height = GetValue$1y(config, 'height', 0);
      var leftWidth = GetValue$1y(config, 'leftWidth', 0);
      var rightWidth = GetValue$1y(config, 'rightWidth', 0);
      var topHeight = GetValue$1y(config, 'topHeight', 0);
      var bottomHeight = GetValue$1y(config, 'bottomHeight', 0);
      _this = _callSuper(this, StatesNineSlice, [scene, x, y, key, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight]);
      _this.type = 'rexStatesNineSlice';
      var effectConfig = GetValue$1y(config, 'effects', true);
      if (effectConfig) {
        AddEffectProperties(_assertThisInitialized(_this), effectConfig);
      }
      _this.style = new Style(_assertThisInitialized(_this), config);
      config.style = _this.style;
      _this.addStyleManager(config);
      delete config.style;
      return _this;
    }
    return _createClass(StatesNineSlice);
  }(PhaserNineSlice);
  Object.assign(StatesNineSlice.prototype, HelperMethods);

  var StatesRoundRectangle = /*#__PURE__*/function (_RoundRectangle) {
    _inherits(StatesRoundRectangle, _RoundRectangle);
    function StatesRoundRectangle(scene, config) {
      var _this;
      _classCallCheck(this, StatesRoundRectangle);
      if (config === undefined) {
        config = {};
      }
      _this = _callSuper(this, StatesRoundRectangle, [scene, config]);
      _this.type = 'rexStatesRoundRectangleShape';
      config.style = _assertThisInitialized(_this);
      config.propertiesMap = PropertiesMap;
      _this.addStyleManager(config);
      delete config.style;
      delete config.propertiesMap;
      return _this;
    }
    return _createClass(StatesRoundRectangle);
  }(RoundRectangle$1);
  var PropertiesMap = {
    color: 'fillColor',
    alpha: 'fillAlpha',
    // strokeColor: 'strokeColor',
    // strokeAlpha: 'strokeAlpha',
    strokeWidth: 'lineWidth'
  };
  Object.assign(StatesRoundRectangle.prototype, HelperMethods);

  var PhaserText = Phaser.GameObjects.Text;
  var GetValue$1x = Phaser.Utils.Objects.GetValue;
  var StatesText = /*#__PURE__*/function (_PhaserText) {
    _inherits(StatesText, _PhaserText);
    function StatesText(scene, config) {
      var _this;
      _classCallCheck(this, StatesText);
      if (config === undefined) {
        config = {};
      }
      var x = GetValue$1x(config, 'x', 0);
      var y = GetValue$1x(config, 'y', 0);
      var text = GetValue$1x(config, 'text', '');
      _this = _callSuper(this, StatesText, [scene, x, y, text, config]);
      _this.type = 'rexStatesText';
      config.style = _this.style;
      config.onModifyStyle = function (gameObject, style) {
        var recalculateMetrics = style.hasOwnProperty('fontStyle') || style.hasOwnProperty('fontSize') || style.hasOwnProperty('fontFamily');
        gameObject.style.update(recalculateMetrics);
      };
      _this.addStyleManager(config);
      delete config.style;
      return _this;
    }
    return _createClass(StatesText);
  }(PhaserText);
  Object.assign(StatesText.prototype, HelperMethods);

  var SetChart = function SetChart(config) {
    if (!window.Chart) {
      var msg = "Can not find chartjs! Load chartjs in preload stage.\nscene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');";
      console.error(msg);
      return this;
    }
    if (this.chart) {
      this.chart.destroy();
    }
    this.chart = new Chart(this.context, FillConfig(this, config));
    return this;
  };
  var FillConfig = function FillConfig(canvas, config) {
    // Get options
    if (config === undefined) {
      config = {};
    }
    if (config.options === undefined) {
      config.options = {};
    }
    var options = config.options;

    // Fill options
    options.responsive = false;
    options.maintainAspectRatio = false;
    if (!options.hasOwnProperty('devicePixelRatio')) {
      options.devicePixelRatio = 1;
    }

    // Get animation config
    var noAnimation = false;
    if (options.animation === undefined) {
      options.animation = {};
    } else if (options.animation === false) {
      noAnimation = true;
      options.animation = {};
    }
    var animationConfig = options.animation;

    // Fill animation config
    if (noAnimation) {
      animationConfig.duration = 0;
    }
    var onProgress = animationConfig.onProgress;
    animationConfig.onProgress = function (animation) {
      if (onProgress) {
        onProgress(animation);
      }
      canvas.needRedraw();
    };
    var onComplete = animationConfig.onComplete;
    animationConfig.onComplete = function (animation) {
      if (onComplete) {
        onComplete(animation);
      }
      canvas.needRedraw();
    };
    return config;
  };

  var GetChartDataset = function GetChartDataset(datasetIndex) {
    if (this.chart === undefined) {
      return undefined;
    }
    if (typeof datasetIndex === 'string') {
      var datasets = this.chart.data.datasets,
        dataset;
      for (var i = 0, cnt = datasets.length; i < cnt; i++) {
        dataset = datasets[i];
        if (dataset.label === datasetIndex) {
          return dataset;
        }
      }
    } else {
      return this.chart.data.datasets[datasetIndex];
    }
    return undefined;
  };

  var GetChartData = function GetChartData(datasetIndex, dataIndex) {
    var dataset = this.getChartDataset(datasetIndex);
    if (dataset === undefined) {
      return undefined;
    }
    if (typeof dataIndex === 'string') {
      var labels = this.chart.data.labels;
      dataIndex = labels.indexOf(dataIndex);
      if (dataIndex === -1) {
        return undefined;
      }
    }
    return dataset.data[dataIndex];
  };

  var SetChartData = function SetChartData(datasetIndex, dataIndex, value) {
    if (this.chart === undefined) {
      return this;
    }
    var dataset = this.getChartDataset(datasetIndex);
    if (typeof dataIndex === 'string') {
      var labels = this.chart.data.labels;
      dataIndex = labels.indexOf(dataIndex);
      if (dataIndex === -1) {
        return this;
      }
    }
    dataset.data[dataIndex] = value;
    return this;
  };

  var UpdateChart = function UpdateChart() {
    if (this.chart === undefined) {
      return this;
    }
    this.chart.update();
    return this;
  };

  // This plugin does not contain chart.js
  // Load chart.js in preload stage -
  // scene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');
  var Chart$1 = /*#__PURE__*/function (_Canvas) {
    _inherits(Chart, _Canvas);
    function Chart(scene, x, y, width, height, config) {
      var _this;
      _classCallCheck(this, Chart);
      _this = _callSuper(this, Chart, [scene, x, y, width, height]);
      _this.type = 'rexChart';
      _this.chart = undefined;
      if (config !== undefined) {
        _this.setChart(config);
      }
      return _this;
    }
    _createClass(Chart, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }
        if (this.chart) {
          this.chart.destroy();
          this.chart = undefined;
        }
        _get(_getPrototypeOf(Chart.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        if (width === this.width && height === this.height) {
          return this;
        }
        _get(_getPrototypeOf(Chart.prototype), "resize", this).call(this, width, height);
        if (this.chart) {
          var chart = this.chart;
          chart.height = this.canvas.height;
          chart.width = this.canvas.width;
          chart.aspectRatio = chart.height ? chart.width / chart.height : null;
          chart.update();
        }
        return this;
      }
    }]);
    return Chart;
  }(Canvas);
  var methods$i = {
    setChart: SetChart,
    getChartDataset: GetChartDataset,
    getChartData: GetChartData,
    setChartData: SetChartData,
    updateChart: UpdateChart
  };
  Object.assign(Chart$1.prototype, methods$i);

  var Sum = function Sum() {
    return Array.prototype.reduce.call(arguments, Add$5, 0);
  };
  var Add$5 = function Add(a, b) {
    return a + b;
  };

  var GetChildrenWidth$2 = function GetChildrenWidth(minimumMode) {
    if (this.rexSizer.hidden) {
      return 0;
    }
    if (minimumMode === undefined) {
      minimumMode = true;
    }
    var result = 0,
      columnWidth;
    var children = this.sizerChildren;
    var child, padding, childWidth, proportion;
    var hasUnknownChildWidth = false;
    this.totalColumnProportions; // To update this.hasColumnProportion0Child member

    for (var i = 0; i < this.columnCount; i++) {
      proportion = this.columnProportions[i];
      columnWidth = 0;
      if (proportion === 0 || minimumMode) {
        for (var j = 0; j < this.rowCount; j++) {
          child = children[j * this.columnCount + i];
          if (!child) {
            continue;
          }
          if (child.rexSizer.hidden) {
            continue;
          }
          childWidth = this.getChildWidth(child);
          if (childWidth === undefined) {
            if (proportion !== 0 && !this.hasColumnProportion0Child) {
              childWidth = 0;
            } else {
              hasUnknownChildWidth = true;
            }
          }
          if (hasUnknownChildWidth) {
            continue;
          }
          padding = child.rexSizer.padding;
          childWidth += padding.left + padding.right;
          columnWidth = Math.max(columnWidth, childWidth);
        }
        if (!hasUnknownChildWidth) {
          result += columnWidth;
        }
      }

      // else,(proportion > 0) : columnWidth is 0
      if (!hasUnknownChildWidth) {
        if (minimumMode) {
          this.columnWidth[i] = columnWidth;
        }
      }
    }
    if (hasUnknownChildWidth) {
      return undefined;
    }
    var space = this.space;
    var indentLeft = Math.max(space.indentLeftOdd, space.indentLeftEven);
    return result + Sum.apply(void 0, [space.left, indentLeft].concat(_toConsumableArray(space.column), [space.right]));
  };

  var GetChildrenHeight$2 = function GetChildrenHeight(minimumMode) {
    if (this.rexSizer.hidden) {
      return 0;
    }
    if (minimumMode === undefined) {
      minimumMode = true;
    }
    var result = 0,
      rowHeight;
    var children = this.sizerChildren;
    var child, padding, childHeight, proportion;
    var hasUnknownChildHeight = false;
    this.totalRowProportions; // To update this.hasColumnProportion0Child member

    for (var i = 0; i < this.rowCount; i++) {
      proportion = this.rowProportions[i];
      rowHeight = 0;
      if (proportion === 0 || minimumMode) {
        for (var j = 0; j < this.columnCount; j++) {
          child = children[i * this.columnCount + j];
          if (!child) {
            continue;
          }
          if (child.rexSizer.hidden) {
            continue;
          }
          childHeight = this.getChildHeight(child);
          if (childHeight === undefined) {
            if (proportion !== 0 && !this.hasRowProportion0Child) {
              childHeight = 0;
            } else {
              hasUnknownChildHeight = true;
            }
          }
          if (hasUnknownChildHeight) {
            continue;
          }
          padding = child.rexSizer.padding;
          childHeight += padding.top + padding.bottom;
          rowHeight = Math.max(rowHeight, childHeight);
        }
        if (!hasUnknownChildHeight) {
          result += rowHeight;
        }
      }
      // else,(proportion > 0) : rowHeight is 0

      if (!hasUnknownChildHeight) {
        if (minimumMode) {
          this.rowHeight[i] = rowHeight;
        }
      }
    }
    if (hasUnknownChildHeight) {
      return undefined;
    }
    var space = this.space;
    var indentTop = Math.max(space.indentTopOdd, space.indentTopEven);
    return result + Sum.apply(void 0, [space.top, indentTop].concat(_toConsumableArray(space.row), [space.bottom]));
  };

  var GetExpandedChildWidth = function GetExpandedChildWidth(child, colWidth) {
    var childWidth;
    var childConfig = child.rexSizer;
    if (childConfig.expandWidth) {
      var padding = childConfig.padding;
      childWidth = colWidth - padding.left - padding.right;
    }
    return childWidth;
  };

  var GetExpandedChildHeight = function GetExpandedChildHeight(child, rowHeight) {
    var childHeight;
    var childConfig = child.rexSizer;
    if (childConfig.expandHeight) {
      var padding = childConfig.padding;
      childHeight = rowHeight - padding.top - padding.bottom;
    }
    return childHeight;
  };

  var GetChildrenSizers$2 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }
    var children = this.sizerChildren,
      child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child && child.isRexSizer) {
        out.push(child);
      }
    }
    return out;
  };

  var PreLayout$2 = function PreLayout() {
    this._totalColumnProportions = undefined;
    this._totalRowProportions = undefined;
    this.hasColumnProportion0Child = false;
    this.hasRowProportion0Child = false;
    this.proportionWidthLength = undefined;
    this.proportionHeightLength = undefined;
    PreLayout$4.call(this);
    return this;
  };

  var LayoutChildren$3 = function LayoutChildren() {
    var child, childConfig, padding;
    var startX = this.innerLeft,
      startY = this.innerTop;
    var itemX,
      itemY = startY;
    var x, y, width, height; // Align zone
    var childWidth, childHeight;
    // Layout grid children
    var columnSpace = this.space.column,
      rowSpace = this.space.row,
      indentLeftOdd = this.space.indentLeftOdd,
      indentLeftEven = this.space.indentLeftEven,
      indentTopOdd = this.space.indentTopOdd,
      indentTopEven = this.space.indentTopEven;
    var colWidth, rowHeight;
    var indentLeft, indentTop;
    for (var rowIndex = 0; rowIndex < this.rowCount; rowIndex++) {
      rowHeight = this.getRowHeight(rowIndex);
      indentLeft = rowIndex % 2 ? indentLeftEven : indentLeftOdd;
      itemX = startX + indentLeft;
      for (var columnIndex = 0; columnIndex < this.columnCount; columnIndex++) {
        colWidth = this.getColumnWidth(columnIndex);
        child = this.getChildAt(columnIndex, rowIndex);
        if (!child || child.rexSizer.hidden) {
          itemX += colWidth + columnSpace[columnIndex];
          continue;
        }
        PreLayoutChild.call(this, child);
        childWidth = this.getExpandedChildWidth(child, colWidth);
        childHeight = this.getExpandedChildHeight(child, rowHeight);
        if (child.isRexSizer) {
          child.runLayout(this, childWidth, childHeight);
          CheckSize(child, this);
        } else {
          ResizeGameObject(child, childWidth, childHeight);
        }
        childConfig = child.rexSizer;
        padding = childConfig.padding;
        x = itemX + padding.left;
        width = colWidth - padding.left - padding.right;
        indentTop = columnIndex % 2 ? indentTopEven : indentTopOdd;
        y = itemY + indentTop + padding.top;
        height = rowHeight - padding.top - padding.bottom;
        LayoutChild.call(this, child, x, y, width, height, childConfig.align);
        itemX += colWidth + columnSpace[columnIndex];
      }
      itemY += rowHeight + rowSpace[rowIndex];
    }
  };

  var ResolveWidth = function ResolveWidth(width) {
    var width = ResolveWidth$3.call(this, width);

    // Calculate proportionLength
    if (width !== undefined && this.proportionWidthLength === undefined) {
      var totalColumnProportions = this.totalColumnProportions;
      if (totalColumnProportions > 0) {
        var remainder = width - this.getChildrenWidth(false);
        if (remainder >= 0) {
          this.proportionWidthLength = remainder / totalColumnProportions;
        }
      } else {
        this.proportionWidthLength = 0;
      }
    }
    return width;
  };

  var ResolveHeight = function ResolveHeight(height) {
    var height = ResolveHeight$3.call(this, height);

    // Get proportionLength    
    if (height !== undefined && this.proportionHeightLength === undefined) {
      var totalRowProportions = this.totalRowProportions;
      if (totalRowProportions > 0) {
        var remainder = height - this.getChildrenHeight(false);
        if (remainder >= 0) {
          this.proportionHeightLength = remainder / totalRowProportions;
        }
      } else {
        this.proportionHeightLength = 0;
      }
    }
    return height;
  };

  var ResolveChildrenWidth = function ResolveChildrenWidth(parentWidth) {
    // Resolve width of sizer children
    var child, expandedChildWidth, childWidth;
    var colWidth;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (child && child.isRexSizer && !child.ignoreLayout) {
        colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
        expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
        childWidth = child.resolveWidth(expandedChildWidth);
        if (childWidth === undefined) {
          childWidth = expandedChildWidth;
        }
        child.resolveChildrenWidth(childWidth);
      }
    }
  };

  var ResolveChildrenHeight = function ResolveChildrenHeight(parentHeight) {
    // Resolve width of sizer children
    var child, expandedChildHeight, childHeight;
    var rowHeight;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (child && child.isRexSizer && !child.ignoreLayout) {
        rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
        expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
        childHeight = child.resolveHeight(expandedChildHeight);
        if (childHeight === undefined) {
          childHeight = expandedChildHeight;
        }
        child.resolveChildrenHeight(childHeight);
      }
    }
  };

  var RunWidthWrap$1 = function RunWidthWrap(width) {
    var child, expandedChildWidth, childWidth;
    var colWidth;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
        continue;
      }
      colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
      expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
      if (child.isRexSizer) {
        childWidth = child.resolveWidth(expandedChildWidth);
        if (childWidth === undefined) {
          childWidth = expandedChildWidth;
        }
      }
      child.runWidthWrap(childWidth);
    }
    return this;
  };

  var RunHeightWrap$1 = function RunHeightWrap(height) {
    var child, expandedChildHeight, childHeight;
    var rowHeight;
    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];
      if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
        continue;
      }
      rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
      expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
      if (child.isRexSizer) {
        childHeight = child.resolveHeight(expandedChildHeight);
        if (childHeight === undefined) {
          childHeight = expandedChildHeight;
        }
      }
      child.runHeightWrap(childHeight);
    }
    return this;
  };

  var IsPlainObject$d = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1w = Phaser.Utils.Objects.GetValue;
  var ALIGN_CENTER$1 = Phaser.Display.Align.CENTER;
  var GetEmptyCellIndex = function GetEmptyCellIndex(columnIndex, rowIndex, cells, columnCount, rowCount) {
    if (typeof columnIndex === 'number' || typeof rowIndex === 'number') {
      if (columnIndex === undefined) {
        var idx;
        for (var i = 0; i < columnCount; i++) {
          idx = rowIndex * columnCount + i;
          if (!cells[idx]) {
            return idx;
          }
        }
      } else if (rowIndex === undefined) {
        var idx;
        for (var i = 0; i < rowCount; i++) {
          idx = i * columnCount + columnIndex;
          if (!cells[idx]) {
            return idx;
          }
        }
      } else {
        var idx = rowIndex * columnCount + columnIndex;
        if (!cells[idx]) {
          return idx;
        }
      }
    } else if (rowIndex === true) {
      var idx;
      for (var i = 0; i < columnCount; i++) {
        for (var j = 0; j < rowCount; j++) {
          idx = j * columnCount + i;
          if (!cells[idx]) {
            return idx;
          }
        }
      }
    } else {
      for (var i = 0, cnt = cells.length; i < cnt; i++) {
        if (!cells[i]) {
          return i;
        }
      }
    }
    return null;
  };
  var Add$4 = function Add(gameObject, columnIndex, rowIndex, align, paddingConfig, expand, childKey) {
    AddChild$1.call(this, gameObject);
    if (IsPlainObject$d(columnIndex)) {
      var config = columnIndex;
      columnIndex = GetValue$1w(config, 'column', undefined);
      rowIndex = GetValue$1w(config, 'row', undefined);
      align = GetValue$1w(config, 'align', ALIGN_CENTER$1);
      paddingConfig = GetValue$1w(config, 'padding', 0);
      expand = GetValue$1w(config, 'expand', false);
      childKey = GetValue$1w(config, 'key', undefined);
    }

    // Get insert index
    var itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
    if (itemIndex === null) {
      // Specific index mode
      if (typeof columnIndex === 'number' && typeof rowIndex === 'number') {
        return this;
      }
      if (rowIndex === true || typeof rowIndex === 'number') {
        this.addEmptyColumn();
      } else {
        this.addEmptyRow();
      }

      // Get insert index again
      itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
    }
    if (typeof align === 'string') {
      align = AlignConst[align];
    }
    if (align === undefined) {
      align = ALIGN_CENTER$1;
    }
    if (paddingConfig === undefined) {
      paddingConfig = 0;
    }
    if (expand === undefined) {
      expand = true;
    }
    var config = this.getSizerConfig(gameObject);
    config.align = align;
    config.padding = GetBoundsConfig(paddingConfig);
    if (IsPlainObject$d(expand)) {
      config.expandWidth = GetValue$1w(expand, 'width', false);
      config.expandHeight = GetValue$1w(expand, 'height', false);
    } else {
      config.expandWidth = expand;
      config.expandHeight = expand;
    }
    this.sizerChildren[itemIndex] = gameObject;
    if (childKey !== undefined) {
      this.addChildrenMap(childKey, gameObject);
    }
    return this;
  };
  var AddChildMethods$5 = {
    add: Add$4
  };

  var Fill = function Fill(arr, value, startIdx, endIdx) {
    if (startIdx === undefined) {
      startIdx = 0;
    }
    if (endIdx === undefined) {
      endIdx = arr.length - 1;
    }
    for (var i = startIdx; i <= endIdx; i++) {
      arr[i] = value;
    }
    return arr;
  };

  var RemoveChildMethods$4 = {
    remove: function remove(gameObject, destroyChild) {
      if (this.getParentSizer(gameObject) !== this) {
        return this;
      }
      var idx = this.sizerChildren.indexOf(gameObject);
      if (idx !== -1) {
        this.sizerChildren[idx] = null;
      }
      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAt: function removeAt(columnIndex, rowIndex, destroyChild) {
      var child = this.getChildAt(columnIndex, rowIndex);
      if (child) {
        this.remove(child, destroyChild);
      }
      return this;
    },
    removeAll: function removeAll(destroyChild) {
      for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
        var child = this.sizerChildren[i];
        if (!child) {
          continue;
        }
        this.remove(child, destroyChild);
      }
      return this;
    },
    clear: function clear(destroyChild) {
      Fill(this.sizerChildren, null);
      ClearChildren.call(this, destroyChild);
      return this;
    }
  };

  var SetSpaceMethods = {
    setColumnSpace: function setColumnSpace(columnSpace) {
      if (!this.space.column) {
        this.space.column = [];
      }
      this.space.column.length = this.columnCount - 1;
      if (typeof columnSpace === 'number') {
        Fill(this.space.column, columnSpace);
      } else {
        for (var i = 0, cnt = this.columnCount - 1; i < cnt; i++) {
          this.space.column[i] = columnSpace[i] || 0;
        }
      }
      return this;
    },
    setRowSpace: function setRowSpace(rowSpace) {
      if (!this.space.row) {
        this.space.row = [];
      }
      this.space.row.length = this.rowCount - 1;
      if (typeof rowSpace === 'number') {
        Fill(this.space.row, rowSpace);
      } else {
        for (var i = 0, cnt = this.rowCount - 1; i < cnt; i++) {
          this.space.row[i] = rowSpace[i] || 0;
        }
      }
      return this;
    },
    setIndentLeft: function setIndentLeft(odd, even) {
      this.space.indentLeftOdd = odd;
      this.space.indentLeftEven = even;
      return this;
    },
    setIndentTop: function setIndentTop(odd, even) {
      this.space.indentTopOdd = odd;
      this.space.indentTopEven = even;
      return this;
    }
  };

  var GetValue$1v = Phaser.Utils.Objects.GetValue;
  var ResetGrid = function ResetGrid(columnCount, rowCount, columnProportions, rowProportions, space) {
    if (columnProportions === undefined) {
      columnProportions = 0;
    }
    if (rowProportions === undefined) {
      rowProportions = 0;
    }
    this.columnCount = columnCount;
    this.rowCount = rowCount;
    this.gridCount = columnCount * rowCount;

    // children
    this.removeAll();
    this.sizerChildren.length = columnCount * rowCount;
    Fill(this.sizerChildren, null);

    // proportions
    this.columnProportions = [];
    this.columnProportions.length = columnCount;
    if (typeof columnProportions === 'number') {
      Fill(this.columnProportions, columnProportions);
    } else {
      for (var i = 0; i < columnCount; i++) {
        this.columnProportions[i] = columnProportions[i] || 0;
      }
    }
    this.rowProportions = [];
    this.rowProportions.length = rowCount;
    if (typeof rowProportions === 'number') {
      Fill(this.rowProportions, rowProportions);
    } else {
      for (var i = 0; i < rowCount; i++) {
        this.rowProportions[i] = rowProportions[i] || 0;
      }
    }

    // width & height
    this.columnWidth = [];
    this.columnWidth.length = columnCount;
    this.rowHeight = [];
    this.rowHeight.length = rowCount;

    // space
    this.setColumnSpace(GetValue$1v(space, 'column', 0));
    this.setRowSpace(GetValue$1v(space, 'row', 0));
    var scene = this.scene;
    var createCellContainerCallback = this.createCellContainerCallback;
    if (createCellContainerCallback) {
      for (var y = 0, ycnt = this.rowCount; y < ycnt; y++) {
        for (var x = 0, xcnt = this.columnCount; x < xcnt; x++) {
          var addConfig = {
            column: x,
            row: y
          };
          var child = createCellContainerCallback(scene, x, y, addConfig);
          if (child) {
            this.add(child, addConfig);
          }
        }
      }
    }
    return this;
  };

  var InseryEmptyRow = function InseryEmptyRow(rowIndex, proportion, space) {
    if (proportion === undefined) {
      proportion = this.rowProportions[0] || 0;
    }
    if (space === undefined) {
      space = this.space.row[0] || 0;
    }
    this.rowCount += 1;
    this.gridCount += this.columnCount;
    var args = [rowIndex * this.columnCount, 0];
    for (var i = 0; i < this.columnCount; i++) {
      args.push(null);
    }
    this.sizerChildren.splice.apply(this.sizerChildren, args);
    this.rowProportions.push(proportion);
    this.rowHeight.length += 1; // this.rowHeight will be recalculated when layout()    

    this.space.row.splice(rowIndex, 0, space);
    return this;
  };
  var AddEmptyRow = function AddEmptyRow(proportion, space) {
    InseryEmptyRow.call(this, this.rowCount, proportion, space);
    return this;
  };

  var InsertEmptyColumn = function InsertEmptyColumn(colIndex, proportion, space) {
    if (proportion === undefined) {
      proportion = this.columnProportions[0] || 0;
    }
    if (space === undefined) {
      space = this.space.column[0] || 0;
    }
    this.columnCount += 1;
    this.gridCount += this.rowCount;
    for (var i = this.rowCount - 1; i >= 0; i--) {
      var insertIndex = i * this.columnCount + colIndex;
      this.sizerChildren.splice(insertIndex, 0, null);
    }
    this.columnProportions.push(proportion);
    this.columnWidth.length += 1; // this.columnWidth will be recalculated when layout()    

    this.space.column.splice(colIndex, 0, space);
    return this;
  };
  var AddEmptyColumn = function AddEmptyColumn(proportion, space) {
    InsertEmptyColumn.call(this, this.columnCount, proportion, space);
    return this;
  };

  var methods$h = {
    getChildrenWidth: GetChildrenWidth$2,
    getChildrenHeight: GetChildrenHeight$2,
    getExpandedChildWidth: GetExpandedChildWidth,
    getExpandedChildHeight: GetExpandedChildHeight,
    getChildrenSizers: GetChildrenSizers$2,
    preLayout: PreLayout$2,
    layoutChildren: LayoutChildren$3,
    resolveWidth: ResolveWidth,
    resolveHeight: ResolveHeight,
    resolveChildrenWidth: ResolveChildrenWidth,
    resolveChildrenHeight: ResolveChildrenHeight,
    runWidthWrap: RunWidthWrap$1,
    runHeightWrap: RunHeightWrap$1,
    resetGrid: ResetGrid,
    inseryEmptyRow: InseryEmptyRow,
    addEmptyRow: AddEmptyRow,
    insertEmptyColumn: InsertEmptyColumn,
    addEmptyColumn: AddEmptyColumn
  };
  Object.assign(methods$h, AddChildMethods$5, RemoveChildMethods$4, SetSpaceMethods);

  var GetTotalColumnProportions = function GetTotalColumnProportions() {
    var result = 0,
      proportion;
    for (var i = 0; i < this.columnCount; i++) {
      proportion = this.columnProportions[i];
      if (proportion > 0) {
        result += proportion;
      } else if (proportion === 0) {
        this.hasColumnProportion0Child = true;
      }
    }
    return result;
  };

  var GetTotalRowProportions = function GetTotalRowProportions() {
    var result = 0,
      proportion;
    for (var i = 0; i < this.rowCount; i++) {
      proportion = this.rowProportions[i];
      if (proportion > 0) {
        result += proportion;
      } else if (proportion === 0) {
        this.hasRowProportion0Child = true;
      }
    }
    return result;
  };

  var IsPlainObject$c = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1u = Phaser.Utils.Objects.GetValue;
  var GridSizer = /*#__PURE__*/function (_BaseSizer) {
    _inherits(GridSizer, _BaseSizer);
    function GridSizer(scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportions, config) {
      var _this;
      _classCallCheck(this, GridSizer);
      if (IsPlainObject$c(x)) {
        config = x;
        x = GetValue$1u(config, 'x', 0);
        y = GetValue$1u(config, 'y', 0);
        minWidth = GetValue$1u(config, 'width', undefined);
        minHeight = GetValue$1u(config, 'height', undefined);
        columnCount = GetValue$1u(config, 'column', config.col || 0);
        rowCount = GetValue$1u(config, 'row', 0);
        columnProportions = GetValue$1u(config, 'columnProportions', 0);
        rowProportions = GetValue$1u(config, 'rowProportions', 0);
      } else if (IsPlainObject$c(minWidth)) {
        config = minWidth;
        minWidth = GetValue$1u(config, 'width', undefined);
        minHeight = GetValue$1u(config, 'height', undefined);
        columnCount = GetValue$1u(config, 'column', config.col || 0);
        rowCount = GetValue$1u(config, 'row', 0);
        columnProportions = GetValue$1u(config, 'columnProportions', 0);
        rowProportions = GetValue$1u(config, 'rowProportions', 0);
      } else if (IsPlainObject$c(columnCount)) {
        config = columnCount;
        columnCount = GetValue$1u(config, 'column', config.col || 0);
        rowCount = GetValue$1u(config, 'row', 0);
        columnProportions = GetValue$1u(config, 'columnProportions', 0);
        rowProportions = GetValue$1u(config, 'rowProportions', 0);
      } else if (IsPlainObject$c(columnProportions)) {
        config = columnProportions;
        columnProportions = GetValue$1u(config, 'columnProportions', 0);
        rowProportions = GetValue$1u(config, 'rowProportions', 0);
      }
      _this = _callSuper(this, GridSizer, [scene, x, y, minWidth, minHeight, config]);
      _this.type = 'rexGridSizer';
      _this.sizerChildren = [];
      _this.addChildrenMap('items', _this.sizerChildren);
      _this.setCreateCellContainerCallback(GetValue$1u(config, 'createCellContainerCallback'));
      _this.setIndentLeft(GetValue$1u(config, 'space.indentLeftOdd', 0), GetValue$1u(config, 'space.indentLeftEven', 0));
      _this.setIndentTop(GetValue$1u(config, 'space.indentTopOdd', 0), GetValue$1u(config, 'space.indentTopEven', 0));
      _this.resetGrid(columnCount, rowCount, columnProportions, rowProportions, GetValue$1u(config, 'space', undefined));
      return _this;
    }
    _createClass(GridSizer, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        _get(_getPrototypeOf(GridSizer.prototype), "destroy", this).call(this, fromScene);

        // More free resources
        this.columnProportions = undefined;
        this.rowProportions = undefined;
        this.columnWidth = undefined;
        this.rowHeight = undefined;
        this.createCellContainerCallback = undefined;
      }
    }, {
      key: "setColumnProportion",
      value: function setColumnProportion(columnIndex, proportion) {
        if (columnIndex >= this.columnProportions.length) {
          return this;
        }
        this.columnProportions[columnIndex] = proportion;
        return this;
      }
    }, {
      key: "setRowProportion",
      value: function setRowProportion(rowIndex, proportion) {
        if (rowIndex >= this.rowProportions.length) {
          return this;
        }
        this.rowProportions[rowIndex] = proportion;
        return this;
      }
    }, {
      key: "totalColumnProportions",
      get: function get() {
        if (this._totalColumnProportions === undefined) {
          this._totalColumnProportions = GetTotalColumnProportions.call(this);
        }
        return this._totalColumnProportions;
      }
    }, {
      key: "totalRowProportions",
      get: function get() {
        if (this._totalRowProportions === undefined) {
          this._totalRowProportions = GetTotalRowProportions.call(this);
        }
        return this._totalRowProportions;
      }
    }, {
      key: "getChildAt",
      value: function getChildAt(columnIndex, rowIndex) {
        return this.sizerChildren[rowIndex * this.columnCount + columnIndex];
      }
    }, {
      key: "childToGridIndex",
      value: function childToGridIndex(child, out) {
        if (!child) {
          return null;
        }
        var index = this.sizerChildren.indexOf(child);
        if (index === -1) {
          return null;
        }
        if (out === undefined) {
          out = {};
        }
        out.x = index % this.columnCount;
        out.y = Math.floor(index / this.columnCount);
        return out;
      }
    }, {
      key: "getColumnWidth",
      value: function getColumnWidth(columnIndex) {
        var colProportion = this.columnProportions[columnIndex];
        var colWidth = colProportion === 0 ? this.columnWidth[columnIndex] : colProportion * this.proportionWidthLength;
        return colWidth;
      }
    }, {
      key: "getRowHeight",
      value: function getRowHeight(rowIndex) {
        var rowProportion = this.rowProportions[rowIndex];
        var rowHeight = rowProportion === 0 ? this.rowHeight[rowIndex] : rowProportion * this.proportionHeightLength;
        return rowHeight;
      }
    }, {
      key: "setCreateCellContainerCallback",
      value: function setCreateCellContainerCallback(callback) {
        this.createCellContainerCallback = callback;
        return this;
      }
    }]);
    return GridSizer;
  }(Base);
  Object.assign(GridSizer.prototype, methods$h);

  var GetChildrenWidth$1 = function GetChildrenWidth(minimumMode) {
    if (this.rexSizer.hidden) {
      return 0;
    }
    if (minimumMode === undefined) {
      minimumMode = true;
    }
    var childrenWidth;
    if (this.orientation === 0) {
      if (minimumMode) {
        childrenWidth = this.maxChildWidth;
      } else {
        childrenWidth = this.rexSizer.resolved ? this.wrapResult.width : undefined;
      }
    } else {
      childrenWidth = this.rexSizer.resolved ? this.wrapResult.width : undefined;
    }
    if (childrenWidth === undefined) {
      return undefined;
    }
    return childrenWidth + this.space.left + this.space.right;
  };

  var GetChildrenHeight$1 = function GetChildrenHeight(minimumMode) {
    if (this.rexSizer.hidden) {
      return 0;
    }
    if (minimumMode === undefined) {
      minimumMode = true;
    }
    var childrenHeight;
    if (this.orientation === 1) {
      if (minimumMode) {
        childrenHeight = this.maxChildHeight;
      } else {
        childrenHeight = this.rexSizer.resolved ? this.wrapResult.height : undefined;
      }
    } else {
      childrenHeight = this.rexSizer.resolved ? this.wrapResult.height : undefined;
    }
    if (childrenHeight === undefined) {
      return undefined;
    }
    return childrenHeight + this.space.top + this.space.bottom;
  };

  var GetChildrenSizers$1 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }
    var children = this.sizerChildren,
      child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child === '\n') {
        continue;
      }
      if (child.isRexSizer) {
        out.push(child);
      }
    }
    return out;
  };

  var PreLayout$1 = function PreLayout() {
    this._maxChildWidth = undefined;
    this._maxChildHeight = undefined;
    this.wrapResult = undefined;
    this.rexSizer.resolved = false;
    PreLayout$4.call(this);
    return this;
  };

  var LayoutChildren$2 = function LayoutChildren() {
    var horizontalWrap = this.orientation === 0;
    var innerLineWidth = horizontalWrap ? this.innerWidth : this.innerHeight;
    var justifyPercentage = this.justifyPercentage;
    var itemSpace = this.space.item,
      lineSpace = this.space.line,
      indentLeftOdd = this.space.indentLeftOdd,
      indentLeftEven = this.space.indentLeftEven,
      indentTopOdd = this.space.indentTopOdd,
      indentTopEven = this.space.indentTopEven;
    var child,
      childConfig,
      padding,
      justifySpace = 0,
      indentLeft,
      indentTop;
    var startX = this.innerLeft,
      startY = this.innerTop;
    var x, y, width, height; // Align zone
    var lines = this.wrapResult.lines; // Get this.wrapResult from RunChildrenWrap()
    var line, lineChlidren, remainderLineWidth;
    var itemX = startX,
      itemY = startY;
    for (var i = 0, icnt = lines.length; i < icnt; i++) {
      // Layout this line
      line = lines[i];
      lineChlidren = line.children;
      if (this.rtl) {
        lineChlidren.reverse();
      }
      if (horizontalWrap) {
        indentLeft = i % 2 ? indentLeftEven : indentLeftOdd;
        itemX = startX + indentLeft;
      } else {
        indentTop = i % 2 ? indentTopEven : indentTopOdd;
        itemY = startY + indentTop;
      }
      remainderLineWidth = innerLineWidth - (horizontalWrap ? line.width : line.height);
      switch (this.align) {
        case 0:
          // left
          break;
        case 1:
          // right
          if (horizontalWrap) {
            itemX += remainderLineWidth;
          } else {
            itemY += remainderLineWidth;
          }
          break;
        case 2:
          // center
          if (horizontalWrap) {
            itemX += remainderLineWidth / 2;
          } else {
            itemY += remainderLineWidth / 2;
          }
          break;
        case 3:
          // justify-left            
          justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
          break;
        case 4:
          // justify-right
          justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
          if (justifySpace === 0) {
            // Align right
            if (horizontalWrap) {
              itemX += remainderLineWidth;
            } else {
              itemY += remainderLineWidth;
            }
          }
          break;
        case 5:
          // justify-center
          justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
          if (justifySpace === 0) {
            // Align center
            if (horizontalWrap) {
              itemX += remainderLineWidth / 2;
            } else {
              itemY += remainderLineWidth / 2;
            }
          }
          break;
      }
      var isFirstChild = true;
      for (var j = 0, jcnt = lineChlidren.length; j < jcnt; j++) {
        child = lineChlidren[j];
        if (child.rexSizer.hidden) {
          continue;
        }
        childConfig = child.rexSizer;
        padding = childConfig.padding;
        PreLayoutChild.call(this, child);
        if (horizontalWrap) {
          x = itemX + padding.left;
        } else {
          y = itemY + padding.top;
        }
        if (isFirstChild) {
          isFirstChild = false;
        } else {
          if (horizontalWrap) {
            x += itemSpace;
          } else {
            y += itemSpace;
          }
        }
        width = GetDisplayWidth(child);
        height = GetDisplayHeight(child);
        if (horizontalWrap) {
          indentTop = j % 2 ? indentTopEven : indentTopOdd;
          y = itemY + indentTop + padding.top;
          itemX = x + width + padding.right + justifySpace;
        } else {
          indentLeft = j % 2 ? indentLeftEven : indentLeftOdd;
          x = itemX + indentLeft + padding.left;
          itemY = y + height + padding.top + justifySpace;
        }
        LayoutChild.call(this, child, x, y, width, height, childConfig.align);
      }
      if (horizontalWrap) {
        itemY += line.height + lineSpace;
      } else {
        itemX += line.width + lineSpace;
      }
    }
  };
  var GetJustifySpace = function GetJustifySpace(total, remainder, justifyPercentage, childCount) {
    return remainder / total <= justifyPercentage ? remainder / (childCount - 1) : 0;
  };

  var HasWidthWrap = function HasWidthWrap() {
    if (this.orientation === 0) {
      return true;
    }
    return HasWidthWrap$2.call(this);
  };

  var RunChildrenWrap = function RunChildrenWrap(lineWidth) {
    var out = {
      lines: [],
      width: 0,
      height: 0
    };
    var children = this.sizerChildren;
    var itemSpace = this.space.item,
      lineSpace = this.space.line,
      indentLeftOdd = this.space.indentLeftOdd,
      indentLeftEven = this.space.indentLeftEven,
      indentTopOdd = this.space.indentTopOdd,
      indentTopEven = this.space.indentTopEven;
    var child,
      padding,
      childWidth,
      childHeight,
      remainder = 0,
      indentLeft,
      indentTop;
    var lines = out.lines,
      lastLine = undefined,
      newLine;
    if (this.orientation === 0) {
      // x
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
          child = undefined;
          childWidth = 0;
          newLine = true;
        } else {
          if (child.rexSizer.hidden) {
            continue;
          }
          if (child.isRexSizer) {
            child.layout(); // Use original size
          }
          childWidth = this.getChildWidth(child);
          padding = child.rexSizer.padding;
          childWidth += padding.left + padding.right;
          newLine = remainder < childWidth || lastLine === undefined;
        }
        // New line
        if (newLine) {
          if (lastLine) {
            lastLine.width = lineWidth - (remainder + itemSpace);
            out.width = Math.max(out.width, lastLine.width);
            out.height += lastLine.height + lineSpace;
          }
          lastLine = {
            children: [],
            width: 0,
            height: 0
          };
          lines.push(lastLine);
          indentLeft = lines.length % 2 ? indentLeftOdd : indentLeftEven;
          remainder = lineWidth - indentLeft;
        }
        remainder -= childWidth + itemSpace;
        if (child) {
          lastLine.children.push(child);
          childHeight = this.getChildHeight(child);
          padding = child.rexSizer.padding;
          childHeight += padding.top + padding.bottom;
          lastLine.height = Math.max(lastLine.height, childHeight);
        }
      }
      if (lastLine) {
        lastLine.width = lineWidth - (remainder + itemSpace);
        out.width = Math.max(out.width, lastLine.width);
        out.height += lastLine.height;
      }
      out.height += Math.max(indentTopOdd, indentTopEven);
    } else {
      var lineHeight = lineWidth;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
          child = undefined;
          childWidth = 0;
          newLine = true;
        } else {
          if (child.rexSizer.hidden) {
            continue;
          }
          if (child.isRexSizer) {
            child.layout(); // Use original size
          }
          childHeight = this.getChildHeight(child);
          padding = child.rexSizer.padding;
          childHeight += padding.top + padding.bottom;
          newLine = remainder < childHeight || lastLine === undefined;
        }
        // New line
        if (newLine) {
          if (lastLine) {
            lastLine.height = lineHeight - (remainder + itemSpace);
            out.height = Math.max(out.height, lastLine.height);
            out.width += lastLine.width + lineSpace;
          }
          lastLine = {
            children: [],
            width: 0,
            height: 0
          };
          lines.push(lastLine);
          indentTop = lines.length % 2 ? indentTopOdd : indentTopEven;
          remainder = lineHeight - indentTop;
        }
        remainder -= childHeight + itemSpace;
        if (child) {
          lastLine.children.push(child);
          childWidth = this.getChildWidth(child);
          padding = child.rexSizer.padding;
          childWidth += padding.left + padding.right;
          lastLine.width = Math.max(lastLine.width, childWidth);
        }
      }
      if (lastLine) {
        lastLine.height = lineHeight - (remainder + itemSpace);
        out.height = Math.max(out.height, lastLine.height);
        out.width += lastLine.width;
      }
      out.width += Math.max(indentLeftOdd, indentLeftEven);
    }
    return out;
  };

  var RunWidthWrap = function RunWidthWrap(width) {
    if (this.wrapResult) {
      // Already got wrapResult
      return;
    }
    if (this.orientation === 0) {
      var innerWidth = width - this.space.left - this.space.right;
      this.wrapResult = RunChildrenWrap.call(this, innerWidth);
      this.rexSizer.resolved = true;
      RunWidthWrap$3.call(this, width);
    }
  };

  var HasHeightWrap = function HasHeightWrap() {
    if (this.orientation === 1) {
      return true;
    }
    return HasHeightWrap$2.call(this);
  };

  var RunHeightWrap = function RunHeightWrap(height) {
    if (this.wrapResult) {
      // Already got wrapResult
      return;
    }
    if (this.orientation === 1) {
      var innerHeight = height - this.space.top - this.space.bottom;
      this.wrapResult = RunChildrenWrap.call(this, innerHeight);
      this.rexSizer.resolved = true;
      RunHeightWrap$3.call(this, height);
    }
  };

  var DistanceBetween$1 = Phaser.Math.Distance.Between;
  var GetNearestChildIndex = function GetNearestChildIndex(x, y) {
    var children = this.sizerChildren;
    if (children.length === 0) {
      return -1;
    }
    var nearestIndex = -1,
      minDistance = Infinity;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      // position is not at this line
      if (Math.abs(child.centerY - y) > child.height / 2) {
        continue;
      }

      // Check left bound
      var distance = DistanceBetween$1(child.left, child.centerY, x, y);
      if (minDistance > distance) {
        minDistance = distance;
        nearestIndex = i;
      }

      // Is last child of this line
      var nextChild = children[i + 1];
      if (nextChild && nextChild.y === child.y) {
        continue;
      }
      var distance = DistanceBetween$1(child.right, child.centerY, x, y);
      if (minDistance > distance) {
        minDistance = distance;
        nearestIndex = i + 1;
      }
    }
    return nearestIndex;
  };

  var IsPlainObject$b = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1t = Phaser.Utils.Objects.GetValue;
  var ALIGN_CENTER = Phaser.Display.Align.CENTER;
  var Add$3 = function Add(gameObject, paddingConfig, childKey, index) {
    if (gameObject === '\n') {
      this.addNewLine();
      return this;
    }
    AddChild$1.call(this, gameObject);
    if (IsPlainObject$b(paddingConfig)) {
      var config = paddingConfig;
      paddingConfig = GetValue$1t(config, 'padding', 0);
      childKey = GetValue$1t(config, 'key', undefined);
      index = GetValue$1t(config, 'index', undefined);
    }
    if (paddingConfig === undefined) {
      paddingConfig = 0;
    }
    var config = this.getSizerConfig(gameObject);
    config.align = ALIGN_CENTER;
    config.padding = GetBoundsConfig(paddingConfig);
    if (index === undefined || index >= this.sizerChildren.length) {
      this.sizerChildren.push(gameObject);
    } else {
      this.sizerChildren.splice(index, 0, gameObject);
    }
    if (childKey !== undefined) {
      this.addChildrenMap(childKey, gameObject);
    }
    return this;
  };
  var AddChildMethods$4 = {
    add: function add(gameObject, paddingConfig, childKey) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$3.call(this, gameObjects[i], paddingConfig);
        }
      } else {
        Add$3.call(this, gameObject, paddingConfig, childKey);
      }
      return this;
    },
    addNewLine: function addNewLine() {
      this.sizerChildren.push('\n');
      return this;
    },
    insert: function insert(index, gameObject, paddingConfig, childKey) {
      Add$3.call(this, gameObject, paddingConfig, childKey, index);
      return this;
    },
    insertAtPosition: function insertAtPosition(x, y, gameObject, paddingConfig, childKey) {
      var index = GetNearestChildIndex.call(this, x, y);
      if (index === -1) {
        index = undefined;
      }
      this.insert(index, gameObject, paddingConfig, childKey);
      return this;
    }
  };

  var RemoveItem$1 = Phaser.Utils.Array.Remove;
  var RemoveChildMethods$3 = {
    remove: function remove(gameObject, destroyChild) {
      if (this.getParentSizer(gameObject) !== this) {
        return this;
      }
      RemoveItem$1(this.sizerChildren, gameObject);
      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAll: function removeAll(destroyChild) {
      for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
        this.remove(this.sizerChildren[i], destroyChild);
      }
      return this;
    },
    clear: function clear(destroyChild) {
      this.sizerChildren.length = 0;
      ClearChildren.call(this, destroyChild);
      return this;
    }
  };

  var methods$g = {
    getChildrenWidth: GetChildrenWidth$1,
    getChildrenHeight: GetChildrenHeight$1,
    getChildrenSizers: GetChildrenSizers$1,
    preLayout: PreLayout$1,
    layoutChildren: LayoutChildren$2,
    hasWidthWrap: HasWidthWrap,
    runWidthWrap: RunWidthWrap,
    hasHeightWrap: HasHeightWrap,
    runHeightWrap: RunHeightWrap
  };
  Object.assign(methods$g, AddChildMethods$4, RemoveChildMethods$3);

  var GetMaxChildWidth = function GetMaxChildWidth(children) {
    if (children === undefined) {
      children = this.sizerChildren;
    }
    var result = 0;
    var child, childWidth;
    var hasUnknownChildWidth = false;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child === '\n') {
        continue;
      }
      childWidth = this.getChildWidth(child);
      if (childWidth === undefined) {
        hasUnknownChildWidth = true;
      }
      if (hasUnknownChildWidth) {
        continue;
      }
      result = Math.max(childWidth, result);
    }
    if (hasUnknownChildWidth) {
      return undefined;
    }
    return result;
  };

  var GetMaxChildHeight = function GetMaxChildHeight(children) {
    if (children === undefined) {
      children = this.sizerChildren;
    }
    var result = 0;
    var child, childHeight;
    var hasUnknownChildHeight = false;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child === '\n') {
        continue;
      }
      childHeight = this.getChildHeight(child);
      if (childHeight === undefined) {
        hasUnknownChildHeight = true;
      }
      if (hasUnknownChildHeight) {
        continue;
      }
      result = Math.max(childHeight, result);
    }
    if (hasUnknownChildHeight) {
      return undefined;
    }
    return result;
  };

  var IsPlainObject$a = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1s = Phaser.Utils.Objects.GetValue;
  var FixWidthSizer = /*#__PURE__*/function (_BaseSizer) {
    _inherits(FixWidthSizer, _BaseSizer);
    function FixWidthSizer(scene, x, y, minWidth, minHeight, config) {
      var _this;
      _classCallCheck(this, FixWidthSizer);
      if (IsPlainObject$a(x)) {
        config = x;
        x = GetValue$1s(config, 'x', 0);
        y = GetValue$1s(config, 'y', 0);
        minWidth = GetValue$1s(config, 'width', undefined);
        minHeight = GetValue$1s(config, 'height', undefined);
      } else if (IsPlainObject$a(minWidth)) {
        config = minWidth;
        minWidth = GetValue$1s(config, 'width', undefined);
        minHeight = GetValue$1s(config, 'height', undefined);
      }
      _this = _callSuper(this, FixWidthSizer, [scene, x, y, minWidth, minHeight, config]);
      _this.type = 'rexFixWidthSizer';
      _this.sizerChildren = [];
      _this.setOrientation(GetValue$1s(config, 'orientation', 0));
      _this.setItemSpacing(GetValue$1s(config, 'space.item', 0));
      _this.setLineSpacing(GetValue$1s(config, 'space.line', 0));
      _this.setIntentLeft(GetValue$1s(config, 'space.indentLeftOdd', 0), GetValue$1s(config, 'space.indentLeftEven', 0));
      _this.setIntentTop(GetValue$1s(config, 'space.indentTopOdd', 0), GetValue$1s(config, 'space.indentTopEven', 0));
      _this.setAlign(GetValue$1s(config, 'align', 0));
      _this.setJustifyPercentage(GetValue$1s(config, 'justifyPercentage', 0.25));
      _this.setRTL(GetValue$1s(config, 'rtl', false));
      _this.wrapResult = undefined; // {lines, width, height}

      _this.addChildrenMap('items', _this.sizerChildren);
      return _this;
    }
    _createClass(FixWidthSizer, [{
      key: "setOrientation",
      value: function setOrientation(orientation) {
        this.orientation = GetOrientationMode(orientation);
        return this;
      }
    }, {
      key: "setItemSpacing",
      value: function setItemSpacing(space) {
        this.space.item = space;
        return this;
      }
    }, {
      key: "setLineSpacing",
      value: function setLineSpacing(space) {
        this.space.line = space;
        return this;
      }
    }, {
      key: "setIntentLeft",
      value: function setIntentLeft(odd, even) {
        this.space.indentLeftOdd = odd;
        this.space.indentLeftEven = even;
        return this;
      }
    }, {
      key: "setIntentTop",
      value: function setIntentTop(odd, even) {
        this.space.indentTopOdd = odd;
        this.space.indentTopEven = even;
        return this;
      }
    }, {
      key: "setAlign",
      value: function setAlign(align) {
        if (typeof align === 'string') {
          align = ALIGN[align];
        }
        this.align = align;
        return this;
      }
    }, {
      key: "setJustifyPercentage",
      value: function setJustifyPercentage(value) {
        this.justifyPercentage = value;
        return this;
      }
    }, {
      key: "setRTL",
      value: function setRTL(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        this.rtl = enabled;
        return this;
      }
    }, {
      key: "maxChildWidth",
      get: function get() {
        if (this._maxChildWidth === undefined) {
          this._maxChildWidth = GetMaxChildWidth.call(this);
        }
        return this._maxChildWidth;
      }
    }, {
      key: "maxChildHeight",
      get: function get() {
        if (this._maxChildHeight === undefined) {
          this._maxChildHeight = GetMaxChildHeight.call(this);
        }
        return this._maxChildHeight;
      }
    }]);
    return FixWidthSizer;
  }(Base);
  var ALIGN = {
    left: 0,
    top: 0,
    right: 1,
    bottom: 1,
    center: 2,
    justify: 3,
    'justify-left': 3,
    'justify-top': 3,
    'justify-right': 4,
    'justify-bottom': 4,
    'justify-center': 5
  };
  Object.assign(FixWidthSizer.prototype, methods$g);

  var Properties = ['alpha', 'tint'];
  var DecorateGameObject = function DecorateGameObject(gameObject, config) {
    if (!config) {
      return gameObject;
    }
    for (var i = 0, cnt = Properties.length; i < cnt; i++) {
      var propertyName = Properties[i];
      if (propertyName in config && propertyName in gameObject) {
        gameObject[propertyName] = config[propertyName];
      }
    }
    return gameObject;
  };

  var CreateBackground$2 = function CreateBackground(scene, config) {
    var gameObjectType;
    if (config) {
      if (config.hasOwnProperty('$type')) {
        gameObjectType = config.$type;
      } else {
        if (config.hasOwnProperty('leftWidth')) {
          gameObjectType = 'nineSlice';
        } else if (config.hasOwnProperty('key')) {
          gameObjectType = 'image';
        }
      }
    }
    var gameObject;
    switch (gameObjectType) {
      case 'image':
        gameObject = new StatesImage(scene, config);
        break;
      case 'nineSlice':
        if (!config.hasOwnProperty('stretchMode')) {
          gameObject = new StatesNineSlice(scene, config);
        } else {
          gameObject = new StatesNinePatch(scene, config);
        }
        break;
      default:
        gameObject = new StatesRoundRectangle(scene, config);
        break;
    }
    DecorateGameObject(gameObject, config);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var SCROLLMODE$1 = {
    v: 0,
    vertical: 0,
    y: 0,
    h: 1,
    horizontal: 1,
    x: 1,
    xy: 2,
    vh: 2
  };

  var GetScrollMode = function GetScrollMode(config, key) {
    if (key === undefined) {
      key = 'scrollMode';
    }
    if (!config.hasOwnProperty(key)) {
      config[key] = GetDefaultScrollMode(config);
    }
    var scrollMode = config[key];
    if (typeof scrollMode === 'string') {
      scrollMode = SCROLLMODE$1[scrollMode];
    }
    return scrollMode;
  };
  var GetDefaultScrollMode = function GetDefaultScrollMode(config) {
    var hasSliderY = !!config.sliderY || !!config.scrollerY;
    var hasSliderX = !!config.sliderX || !!config.scrollerX;
    var scrollMode;
    if (hasSliderY && hasSliderX) {
      scrollMode = 2;
    } else if (hasSliderY) {
      scrollMode = 0;
    } else if (hasSliderX) {
      scrollMode = 1;
    } else {
      scrollMode = 0;
    }
    return scrollMode;
  };

  var GetValue$1r = Phaser.Utils.Objects.GetValue;
  var AddChild = function AddChild(topPatent, childParent, config) {
    var childConfig = GetValue$1r(config, 'child');
    var child = GetValue$1r(childConfig, 'gameObject', undefined);
    if (child) {
      var childSpace = GetValue$1r(config, 'space.child', 0);
      topPatent.childMargin = {};
      var childMargin = topPatent.childMargin;
      var childPadding = {};
      if (typeof childSpace === 'number') {
        // Legacy, add childSpace to slider
        switch (topPatent.scrollMode) {
          case 0:
          case 1:
            childMargin.top = 0;
            childMargin.bottom = 0;
            childMargin.left = 0;
            childMargin.right = 0;
            break;
          default:
            childMargin.top = childSpace;
            childMargin.bottom = childSpace;
            childMargin.left = childSpace;
            childMargin.right = childSpace;
            break;
        }
      } else {
        switch (topPatent.scrollMode) {
          case 0:
            childMargin.top = GetValue$1r(childSpace, 'top', 0);
            childMargin.bottom = GetValue$1r(childSpace, 'bottom', 0);
            childPadding.left = GetValue$1r(childSpace, 'left', 0);
            childPadding.right = GetValue$1r(childSpace, 'right', 0);
            break;
          case 1:
            childMargin.top = GetValue$1r(childSpace, 'left', 0);
            childMargin.bottom = GetValue$1r(childSpace, 'right', 0);
            childPadding.top = GetValue$1r(childSpace, 'top', 0);
            childPadding.bottom = GetValue$1r(childSpace, 'bottom', 0);
            break;
          default:
            // 2
            childMargin.top = GetValue$1r(childSpace, 'top', 0);
            childMargin.bottom = GetValue$1r(childSpace, 'bottom', 0);
            childMargin.left = GetValue$1r(childSpace, 'left', 0);
            childMargin.right = GetValue$1r(childSpace, 'right', 0);
            break;
        }
      }
      childParent.add(child, {
        column: 1,
        row: 1,
        align: GetValue$1r(childConfig, 'align', 'center'),
        padding: childPadding,
        expand: {
          width: GetValue$1r(childConfig, 'expandWidth', true),
          // Private
          height: GetValue$1r(childConfig, 'expandHeight', true) // Private
        }
      });
    }
    topPatent.addChildrenMap('child', child);
  };

  var Percent$3 = Phaser.Math.Percent;
  var PositionToPercent = function PositionToPercent(startPoint, endPoint, currentPoint) {
    var value;
    if (startPoint.y === endPoint.y) {
      value = Percent$3(currentPoint.x, startPoint.x, endPoint.x);
    } else if (startPoint.x === endPoint.x) {
      value = Percent$3(currentPoint.y, startPoint.y, endPoint.y);
    }
    return value;
  };

  var OnDragThumb = function OnDragThumb(pointer, dragX, dragY) {
    if (!this.enable) {
      return;
    }
    tmpPoint$4.x = dragX;
    tmpPoint$4.y = dragY;
    var startPoint, endPoint;
    if (!this.reverseAxis) {
      startPoint = this.getStartPoint();
      endPoint = this.getEndPoint();
    } else {
      startPoint = this.getEndPoint();
      endPoint = this.getStartPoint();
    }
    this.value = PositionToPercent(startPoint, endPoint, tmpPoint$4);
  };
  var tmpPoint$4 = {};

  var OnTouchTrack = function OnTouchTrack(pointer, localX, localY) {
    if (!this.enable) {
      return;
    }
    if (!pointer.isDown) {
      return;
    }
    tmpPoint$3.x = pointer.worldX;
    tmpPoint$3.y = pointer.worldY;
    var startPoint, endPoint;
    if (!this.reverseAxis) {
      startPoint = this.getStartPoint();
      endPoint = this.getEndPoint();
    } else {
      startPoint = this.getEndPoint();
      endPoint = this.getStartPoint();
    }
    var value = PositionToPercent(startPoint, endPoint, tmpPoint$3);
    this.stopEaseValue();
    if (this.easeValueDuration === 0 || Math.abs(this.value - value) < 0.1) {
      this.value = value;
    } else {
      this.easeValueTo(value);
    }
  };
  var tmpPoint$3 = {};

  var GetThumbAlignPoint = function GetThumbAlignPoint(align, out) {
    if (out === undefined) {
      out = tmpPoint$2;
    }
    var thumb = this.childrenMap.thumb;
    var currentX = thumb.x;
    var currentY = thumb.y;
    AlignIn(thumb, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, align);
    out.x = thumb.x;
    out.y = thumb.y;
    thumb.x = currentX;
    thumb.y = currentY;
    return out;
  };
  var tmpPoint$2 = {};

  var AlignLeft$1 = Phaser.Display.Align.LEFT_CENTER;
  var AlignTop$1 = Phaser.Display.Align.TOP_CENTER;
  var GetStartPoint = function GetStartPoint(out) {
    if (out === undefined) {
      out = tmpPoint$1;
    }
    if (this.childrenMap.thumb) {
      var align = this.orientation === 0 ? AlignLeft$1 : AlignTop$1;
      GetThumbAlignPoint.call(this, align, out);
    } else {
      if (this.orientation === 0) {
        out.x = this.innerLeft + 1; // Add 1 pixel margin
        out.y = this.centerY;
      } else {
        out.x = this.centerX;
        out.y = this.innerTop + 1; // Add 1 pixel margin
      }
    }
    return out;
  };
  var tmpPoint$1 = {};

  var AlignRight$1 = Phaser.Display.Align.RIGHT_CENTER;
  var AlignBottom$1 = Phaser.Display.Align.BOTTOM_CENTER;
  var GetEndoint = function GetEndoint(out) {
    if (out === undefined) {
      out = tmpPoint;
    }
    if (this.childrenMap.thumb) {
      var align = this.orientation === 0 ? AlignRight$1 : AlignBottom$1;
      GetThumbAlignPoint.call(this, align, out);
    } else {
      if (this.orientation === 0) {
        out.x = this.innerRight - 1; // Add 1 pixel margin
        out.y = this.centerY;
      } else {
        out.x = this.centerX;
        out.y = this.innerBottom - 1; // Add 1 pixel margin
      }
    }
    return out;
  };
  var tmpPoint = {};

  var Linear$1 = Phaser.Math.Linear;
  var PercentToPosition = function PercentToPosition(t, startPoint, endPoint, out) {
    if (out === undefined) {
      out = tmpOut;
    }
    out.x = Linear$1(startPoint.x, endPoint.x, t);
    out.y = Linear$1(startPoint.y, endPoint.y, t);
    return out;
  };
  var tmpOut = {};

  var UpdateThumb = function UpdateThumb(t) {
    var thumb = this.childrenMap.thumb;
    if (thumb === undefined) {
      return this;
    }
    if (t === undefined) {
      t = this.value;
    }
    var startPoint, endPoint;
    if (!this.reverseAxis) {
      startPoint = this.getStartPoint();
      endPoint = this.getEndPoint();
    } else {
      startPoint = this.getEndPoint();
      endPoint = this.getStartPoint();
    }
    PercentToPosition(t, startPoint, endPoint, thumb);
    this.resetChildPositionState(thumb);
    return this;
  };

  var AlignLeft = Phaser.Display.Align.LEFT_CENTER;
  var AlignTop = Phaser.Display.Align.TOP_CENTER;
  var AlignRight = Phaser.Display.Align.RIGHT_CENTER;
  var AlignBottom = Phaser.Display.Align.BOTTOM_CENTER;
  var UpdateIndicator = function UpdateIndicator(t) {
    var indicator = this.childrenMap.indicator;
    if (indicator === undefined) {
      return this;
    }
    if (t === undefined) {
      t = this.value;
    }
    var reverseAxis = this.reverseAxis;
    var newWidth, newHeight;
    var thumb = this.childrenMap.thumb;
    if (thumb) {
      if (this.orientation === 0) {
        // x, extend width
        var thumbWidth = GetDisplayWidth(thumb);
        if (!reverseAxis) {
          var thumbLeft = thumb.x - thumbWidth * thumb.originX;
          var thumbRight = thumbLeft + thumbWidth;
          newWidth = thumbRight - this.left;
        } else {
          var thumbLeft = thumb.x - thumbWidth * thumb.originX;
          newWidth = this.right - thumbLeft;
        }
      } else {
        // y, extend height
        var thumbHeight = GetDisplayHeight(thumb);
        if (!reverseAxis) {
          var thumbTop = thumb.y - thumbHeight * thumb.originY;
          var thumbBottom = thumbTop + thumbHeight;
          newHeight = thumbBottom - this.top;
        } else {
          var thumbTop = thumb.y - thumbHeight * thumb.originY;
          newHeight = this.bottom - thumbTop;
        }
      }
    } else {
      if (this.orientation === 0) {
        // x, extend width
        newWidth = this.width * t;
      } else {
        // y, extend eight
        newHeight = this.height * t;
      }
    }
    ResizeGameObject(indicator, newWidth, newHeight);
    var align;
    if (!reverseAxis) {
      align = this.orientation === 0 ? AlignLeft : AlignTop;
    } else {
      align = this.orientation === 0 ? AlignRight : AlignBottom;
    }
    QuickSet(indicator, this, align);
    this.resetChildPositionState(indicator);
  };

  var GetValue$1q = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$9 = Phaser.Utils.Objects.IsPlainObject;
  var Clamp$8 = Phaser.Math.Clamp;
  var SnapTo = Phaser.Math.Snap.To;
  var Slider = /*#__PURE__*/function (_ProgressBase) {
    _inherits(Slider, _ProgressBase);
    function Slider(scene, config) {
      var _this;
      _classCallCheck(this, Slider);
      // Create sizer
      _this = _callSuper(this, Slider, [scene, config]);
      _this.type = 'rexSlider';
      _this.bootProgressBase(config);
      _this.reverseAxis = GetValue$1q(config, 'reverseAxis', false);

      // Add elements
      var background = GetValue$1q(config, 'background', undefined);
      var track = GetValue$1q(config, 'track', undefined);
      var indicator = GetValue$1q(config, 'indicator', undefined);
      var thumb = GetValue$1q(config, 'thumb', undefined);
      if (background) {
        if (IsPlainObject$9(background)) {
          background = CreateBackground$2(scene, background);
        }
        _this.addBackground(background);
      }
      if (track) {
        if (IsPlainObject$9(track)) {
          track = CreateBackground$2(scene, track);
        }
        _this.add(track, {
          proportion: 1,
          expand: true,
          minWidth: _this.orientation === 0 ? 0 : undefined,
          minHeight: _this.orientation === 1 ? 0 : undefined
        });
      }
      if (indicator) {
        if (IsPlainObject$9(indicator)) {
          indicator = CreateBackground$2(scene, indicator);
        }
        _this.pin(indicator); // Put into container but not layout it
      }
      if (thumb) {
        if (IsPlainObject$9(thumb)) {
          thumb = CreateBackground$2(scene, thumb);
        }
        _this.pin(thumb); // Put into container but not layout it
      }

      // Input
      var inputMode = GetValue$1q(config, 'input', 0);
      if (typeof inputMode === 'string') {
        inputMode = INPUTMODE[inputMode];
      }
      switch (inputMode) {
        case 0:
          // 'drag'
          if (thumb) {
            thumb.setInteractive();
            _this.scene.input.setDraggable(thumb);
            thumb.on('drag', OnDragThumb, _assertThisInitialized(_this)).on('dragstart', function (pointer) {
              this.eventEmitter.emit('inputstart', pointer);
            }, _assertThisInitialized(_this)).on('dragend', function (pointer) {
              this.eventEmitter.emit('inputend', pointer);
            }, _assertThisInitialized(_this));
          }
          break;
        case 1:
          // 'click'
          _this.on('pointerdown', OnTouchTrack, _assertThisInitialized(_this)).on('pointermove', OnTouchTrack, _assertThisInitialized(_this)).on('pointerdown', function (pointer) {
            this.eventEmitter.emit('inputstart', pointer);
          }, _assertThisInitialized(_this)).on('pointerup', function (pointer) {
            this.eventEmitter.emit('inputend', pointer);
          }, _assertThisInitialized(_this)).on('pointerover', function (pointer) {
            if (pointer.isDown) {
              this.eventEmitter.emit('inputstart', pointer);
            }
          }, _assertThisInitialized(_this)).on('pointerout', function (pointer) {
            if (pointer.isDown) {
              this.eventEmitter.emit('inputend', pointer);
            }
          }, _assertThisInitialized(_this)).setInteractive();
          break;
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('track', track);
      _this.addChildrenMap('indicator', indicator);
      _this.addChildrenMap('thumb', thumb);
      _this.setEnable(GetValue$1q(config, 'enable', undefined));
      _this.setGap(GetValue$1q(config, 'gap', undefined));
      _this.setValue(GetValue$1q(config, 'value', 0), GetValue$1q(config, 'min', undefined), GetValue$1q(config, 'max', undefined));
      return _this;
    }
    _createClass(Slider, [{
      key: "setEnable",
      value: function setEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.enable = enable;
        return this;
      }
    }, {
      key: "setGap",
      value: function setGap(gap, min, max) {
        if (gap && min !== undefined) {
          gap = gap / (max - min);
        }
        this.gap = gap;
        return this;
      }

      // Override
    }, {
      key: "value",
      get: function get() {
        return this._value;
      }

      // Override
      ,
      set: function set(value) {
        if (this.gap !== undefined) {
          value = SnapTo(value, this.gap);
        }
        var oldValue = this._value;
        this._value = Clamp$8(value, 0, 1);
        if (oldValue !== this._value) {
          this.updateThumb(this._value);
          this.updateIndicator(this._value);
          this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
      }
    }, {
      key: "postLayout",
      value: function postLayout(parent, newWidth, newHeight) {
        this.updateThumb();
        this.updateIndicator();
        return this;
      }
    }]);
    return Slider;
  }(ProgressBase(Sizer));
  var INPUTMODE = {
    pan: 0,
    drag: 0,
    click: 1,
    none: -1
  };
  var methods$f = {
    getStartPoint: GetStartPoint,
    getEndPoint: GetEndoint,
    updateThumb: UpdateThumb,
    updateIndicator: UpdateIndicator
  };
  Object.assign(Slider.prototype, methods$f);

  var GetValue$1p = Phaser.Utils.Objects.GetValue;
  var ScrollBar = /*#__PURE__*/function (_Sizer) {
    _inherits(ScrollBar, _Sizer);
    function ScrollBar(scene, config) {
      var _this;
      _classCallCheck(this, ScrollBar);
      // Create sizer
      _this = _callSuper(this, ScrollBar, [scene, config]);
      _this.type = 'rexScrollBar';

      // Add elements
      var background = GetValue$1p(config, 'background', undefined);
      var buttonsConfig = GetValue$1p(config, 'buttons', undefined);
      var button0 = GetValue$1p(buttonsConfig, 'top', GetValue$1p(buttonsConfig, 'left', undefined));
      var button1 = GetValue$1p(buttonsConfig, 'bottom', GetValue$1p(buttonsConfig, 'right', undefined));
      var slider,
        sliderConfig = GetValue$1p(config, 'slider', undefined);
      if (background) {
        _this.addBackground(background);
      }
      if (button0) {
        _this.add(button0);
        var inTouching = new InTouching(button0);
        inTouching.on('intouch', function () {
          if (!this.enable) {
            return;
          }
          var step = !slider.reverseAxis ? -this.scrollStep : this.scrollStep;
          this.value += step;
        }, _assertThisInitialized(_this));
      }
      if (sliderConfig) {
        sliderConfig.orientation = _this.orientation;
        sliderConfig.eventEmitter = _assertThisInitialized(_this);
        sliderConfig.value = null;
        var proportion;
        if (_this.orientation === 0) {
          var sliderWidth = GetValue$1p(sliderConfig, 'width', undefined);
          proportion = sliderWidth === undefined ? 1 : 0;
        } else {
          var sliderHeight = GetValue$1p(sliderConfig, 'height', undefined);
          proportion = sliderHeight === undefined ? 1 : 0;
        }
        slider = new Slider(scene, sliderConfig);
        scene.add.existing(slider);
        _this.add(slider, {
          proportion: proportion
        });
      }
      if (button1) {
        _this.add(button1);
        var inTouching = new InTouching(button1);
        inTouching.on('intouch', function () {
          if (!this.enable) {
            return;
          }
          var step = !slider.reverseAxis ? this.scrollStep : -this.scrollStep;
          this.value += step;
        }, _assertThisInitialized(_this));
      }
      var buttons = [button0, button1];
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('slider', slider);
      _this.addChildrenMap('buttons', buttons);
      var callback = GetValue$1p(config, 'valuechangeCallback', null);
      if (callback !== null) {
        var scope = GetValue$1p(config, 'valuechangeCallbackScope', undefined);
        _this.on('valuechange', callback, scope);
      }
      _this.setEnable(GetValue$1p(config, 'enable', undefined));
      _this.setValue(GetValue$1p(config, 'value', 0));
      _this.setScrollStep(GetValue$1p(buttonsConfig, 'step', 0.01));
      return _this;
    }
    _createClass(ScrollBar, [{
      key: "setScrollStep",
      value: function setScrollStep(value) {
        this.scrollStep = value;
        return this;
      }
    }, {
      key: "enable",
      get: function get() {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.enable;
        } else {
          return false;
        }
      },
      set: function set(value) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEnable(value);
        }
      }
    }, {
      key: "setEnable",
      value: function setEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.enable = enable;
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.value;
        } else {
          return 0;
        }
      },
      set: function set(value) {
        if (!this.childrenMap.slider) {
          return;
        }
        this.childrenMap.slider.value = value;
      }
    }, {
      key: "setValue",
      value: function setValue(value, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setValue(value, min, max);
        }
        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.addValue(inc, min, max);
        }
        return this;
      }
    }, {
      key: "getValue",
      value: function getValue(min, max) {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.getValue(min, max);
        } else {
          return 0;
        }
      }
    }, {
      key: "easeValueTo",
      value: function easeValueTo(value, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.easeValueTo(value, min, max);
        }
        return this;
      }
    }, {
      key: "stopEaseValue",
      value: function stopEaseValue() {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.stopEaseValue();
        }
        return this;
      }
    }, {
      key: "setEaseValueDuration",
      value: function setEaseValueDuration(duration) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEaseValueDuration(duration);
        }
        return this;
      }
    }, {
      key: "setEaseValueFunction",
      value: function setEaseValueFunction(ease) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEaseValueFunction(ease);
        }
        return this;
      }
    }]);
    return ScrollBar;
  }(Sizer);

  var CreateScrollbar = function CreateScrollbar(scene, config) {
    if (config === undefined) {
      config = {};
    }
    var sliderConfig = Clone$2(config);
    config = {
      slider: sliderConfig
    };

    // Move orientation parameter from sliderConfig to config
    config.orientation = sliderConfig.orientation;
    delete sliderConfig.orientation;

    // Move background parameter from sliderConfig to config
    config.background = sliderConfig.background;
    delete sliderConfig.background;

    // Move buttons parameter from sliderConfig to config
    config.buttons = sliderConfig.buttons;
    delete sliderConfig.buttons;
    config.value = null; // Don't assign initial value (0)

    var scrollBar = new ScrollBar(scene, config);
    scene.add.existing(scrollBar);
    var slider = scrollBar.childrenMap.slider;
    scrollBar.addChildrenMap('track', slider.childrenMap.track);
    scrollBar.addChildrenMap('indicator', slider.childrenMap.indicator);
    scrollBar.addChildrenMap('thumb', slider.childrenMap.thumb);
    return scrollBar;
  };

  var State = /*#__PURE__*/function (_FSM) {
    _inherits(State, _FSM);
    function State(parent, config) {
      var _this;
      _classCallCheck(this, State);
      _this = _callSuper(this, State, [config]);
      _this.parent = parent;
      _this.init();
      return _this;
    }
    _createClass(State, [{
      key: "init",
      value: function init() {
        this.start('IDLE');
      }

      // IDLE -> DRAGBEGIN|DRAG
    }, {
      key: "next_IDLE",
      value: function next_IDLE() {
        var nextState,
          parent = this.parent,
          dragState = parent.dragState;
        if (dragState.isDown) {
          nextState = parent.dragThreshold === 0 ? 'DRAG' : 'DRAGBEGIN';
        }
        return nextState;
      }
    }, {
      key: "update_IDLE",
      value: function update_IDLE(time, delta) {
        this.next();
      }
      // IDLE

      // DRAGBEGIN -> DRAG|IDLE
    }, {
      key: "next_DRAGBEGIN",
      value: function next_DRAGBEGIN() {
        var nextState,
          parent = this.parent,
          dragState = parent.dragState;
        if (dragState.isDown) {
          nextState = dragState.pointer.getDistance() >= parent.dragThreshold ? 'DRAG' : 'DRAGBEGIN';
        } else {
          // dragState.isUp
          nextState = 'IDLE';
        }
        return nextState;
      }
    }, {
      key: "update_DRAGBEGIN",
      value: function update_DRAGBEGIN(time, delta) {
        this.next();
      }
      // DRAGBEGIN

      // DRAG -> BACK|SLIDE|IDLE
    }, {
      key: "next_DRAG",
      value: function next_DRAG() {
        var nextState,
          parent = this.parent,
          dragState = parent.dragState;
        if (dragState.isUp) {
          if (parent.outOfBounds) {
            nextState = 'BACK';
          } else if (parent.slidingEnable) {
            nextState = 'SLIDE';
          } else {
            nextState = 'IDLE';
          }
        }
        return nextState;
      }
    }, {
      key: "update_DRAG",
      value: function update_DRAG(time, delta) {
        var parent = this.parent,
          dragState = parent.dragState;
        if (dragState.justMoved) {
          parent.dragging();
        }
        this.next();
      }
    }, {
      key: "enter_DRAG",
      value: function enter_DRAG() {
        this.parent.onDragStart();
      }
    }, {
      key: "exit_DRAG",
      value: function exit_DRAG() {
        this.parent.onDragEnd();
      }
      // DRAG    

      // SLIDE -> DRAG|IDLE
    }, {
      key: "next_SLIDE",
      value: function next_SLIDE() {
        var nextState,
          parent = this.parent,
          dragState = parent.dragState;
        if (dragState.isDown) {
          nextState = 'DRAG';
        } else if (!parent.isSliding) {
          nextState = 'IDLE';
        }
        return nextState;
      }
    }, {
      key: "enter_SLIDE",
      value: function enter_SLIDE() {
        this.parent.onSliding();
      }
    }, {
      key: "exit_SLIDE",
      value: function exit_SLIDE() {
        this.parent.stop();
      }
    }, {
      key: "update_SLIDE",
      value: function update_SLIDE(time, delta) {
        this.parent.sliding(time, delta);
        this.next();
      }
      // SLIDE    

      // BACK -> DRAG|IDLE
    }, {
      key: "next_BACK",
      value: function next_BACK() {
        var nextState,
          parent = this.parent,
          dragState = parent.dragState;
        if (dragState.isDown) {
          nextState = 'DRAG';
        } else if (!parent.isPullBack) {
          nextState = 'IDLE';
        }
        return nextState;
      }
    }, {
      key: "enter_BACK",
      value: function enter_BACK() {
        this.parent.onPullBack();
      }
    }, {
      key: "exit_BACK",
      value: function exit_BACK() {
        this.parent.stop();
      }
    }, {
      key: "update_BACK",
      value: function update_BACK(time, delta) {
        this.parent.pullBack(time, delta);
        this.next();
      }
      // BACK
    }]);
    return State;
  }(FSM);

  var GetValue$1o = Phaser.Utils.Objects.GetValue;
  var DistanceBetween = Phaser.Math.Distance.Between;
  var DragSpeed = /*#__PURE__*/function (_ComponentBase) {
    _inherits(DragSpeed, _ComponentBase);
    function DragSpeed(gameObject, config) {
      var _this;
      _classCallCheck(this, DragSpeed);
      _this = _callSuper(this, DragSpeed, [gameObject, config]);
      // this.parent = gameObject;

      _this._enable = undefined;
      gameObject.setInteractive(GetValue$1o(config, "inputConfig", undefined));
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(DragSpeed, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.pointer = undefined;
        this.isInTouched = false;
        this.holdStartTime = undefined;
        this.x = undefined;
        this.y = undefined;
        this.preX = undefined;
        this.preY = undefined;
        this.localX = undefined;
        this.localY = undefined;
        this.justMoved = false;
        this.setEnable(GetValue$1o(o, 'enable', true));
        this.holdThreshold = GetValue$1o(o, 'holdThreshold', 50); // ms
        this.pointerOutReleaseEnable = GetValue$1o(o, 'pointerOutRelease', true);
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        // Drag start only when pointer down
        this.parent.on('pointerdown', this.onPointIn, this);
        // this.parent.on('pointerover', this.onPointIn, this);

        this.parent.on('pointerup', this.onPointOut, this);
        if (this.pointerOutReleaseEnable) {
          this.parent.on('pointerout', this.onPointOut, this);
        }
        this.parent.on('pointermove', this.onPointerMove, this);
        this.scene.sys.events.on('preupdate', this.preupdate, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        // GameObject events will be removed when this gameObject destroyed 
        // this.parent.off('pointerdown', this.onPointIn, this);
        // this.parent.off('pointerup', this.onPointOut, this);
        // this.parent.off('pointerout', this.onPointOut, this);
        // this.parent.off('pointermove', this.onPointerMove, this);

        this.scene.sys.events.off('preupdate', this.preupdate, this);
        this.pointer = undefined;
        _get(_getPrototypeOf(DragSpeed.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }
        if (!e) {
          this.isInTouched = false;
          this.pointer = undefined;
        }
        this._enable = e;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setPointerOutReleaseEnable",
      value: function setPointerOutReleaseEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.pointerOutReleaseEnable = enable;
        return this;
      }
    }, {
      key: "isDown",
      get: function get() {
        return this.pointer && this.pointer.isDown;
      }
    }, {
      key: "isUp",
      get: function get() {
        return !this.isDown;
      }
    }, {
      key: "dx",
      get: function get() {
        return this.x - this.preX;
      }
    }, {
      key: "dy",
      get: function get() {
        return this.y - this.preY;
      }
    }, {
      key: "dt",
      get: function get() {
        var delta = GetTickDelta(this.scene);
        return delta;
      }
    }, {
      key: "speed",
      get: function get() {
        if (this.x === this.preX && this.y === this.preY) {
          return 0;
        }
        var d = DistanceBetween(this.preX, this.preY, this.x, this.y);
        var speed = d / (this.dt * 0.001);
        return speed;
      }
    }, {
      key: "speedX",
      get: function get() {
        return this.dx / (this.dt * 0.001);
      }
    }, {
      key: "speedY",
      get: function get() {
        return this.dy / (this.dt * 0.001);
      }

      // internal
    }, {
      key: "onPointIn",
      value: function onPointIn(pointer, localX, localY) {
        if (!this.enable || !pointer.isDown || this.pointer !== undefined) {
          return;
        }
        this.pointer = pointer;
        this.localX = localX;
        this.localY = localY;
      }
    }, {
      key: "onPointOut",
      value: function onPointOut(pointer) {
        if (!this.enable || this.pointer !== pointer) {
          return;
        }
        this.pointer = undefined;
      }
    }, {
      key: "onPointerMove",
      value: function onPointerMove(pointer, localX, localY) {
        if (!this.enable || !pointer.isDown || this.pointer !== pointer) {
          return;
        }
        this.localX = localX;
        this.localY = localY;
      }
    }, {
      key: "preupdate",
      value: function preupdate(time, delta) {
        if (!this.enable) {
          return;
        }
        var pointer = this.pointer;
        this.justMoved = false;
        if (pointer && !this.isInTouched) {
          // Touch start
          this.x = pointer.worldX;
          this.y = pointer.worldY;
          this.preX = pointer.worldX;
          this.preY = pointer.worldY;
          this.isInTouched = true;
          this.holdStartTime = undefined;
          this.emit('touchstart', pointer, this.localX, this.localY);
        } else if (pointer && this.isInTouched) {
          // In touch
          if (this.x === pointer.x && this.y === pointer.y) {
            // Hold
            if (this.holdStartTime === undefined) {
              this.holdStartTime = time;
            } else if (time - this.holdStartTime > this.holdThreshold) {
              this.preX = this.x;
              this.preY = this.y;
            }
          } else {
            // Move
            this.preX = this.x;
            this.preY = this.y;
            this.x = pointer.worldX;
            this.y = pointer.worldY;
            this.holdStartTime = undefined;
            this.justMoved = true;
            this.emit('touchmove', pointer, this.localX, this.localY);
          }
        } else if (!pointer && this.isInTouched) {
          // Touch end
          this.isInTouched = false;
          this.holdStartTime = undefined;
          this.emit('touchend', pointer);
        }
      }
    }]);
    return DragSpeed;
  }(ComponentBase);

  var GetValue$1n = Phaser.Utils.Objects.GetValue;
  var Movement = /*#__PURE__*/function () {
    function Movement(config) {
      _classCallCheck(this, Movement);
      this.resetFromJSON(config);
    }
    _createClass(Movement, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setValue(GetValue$1n(o, 'value', 0));
        this.setSpeed(GetValue$1n(o, 'speed', 0));
        this.setAcceleration(GetValue$1n(o, 'acceleration', 0));
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.setValue(0);
        this.setSpeed(0);
        this.setAcceleration(0);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }, {
      key: "setSpeed",
      value: function setSpeed(speed) {
        // speed == 0 : stop
        // speed  > 0 : move
        this.speed = speed;
        return this;
      }
    }, {
      key: "setAcceleration",
      value: function setAcceleration(acc) {
        // acc == 0 : constant speed
        // acc  > 0 : acceleration
        // acc  < 0 : deceleration
        this.acceleration = acc;
        return this;
      }
    }, {
      key: "updateSpeed",
      value: function updateSpeed(delta) {
        // delta in sec
        if (this.acceleration !== 0) {
          this.speed += this.acceleration * delta;
          if (this.speed < 0) {
            this.speed = 0;
          }
        }
        return this;
      }
    }, {
      key: "getDeltaValue",
      value: function getDeltaValue(delta) {
        // delta in sec
        this.updateSpeed(delta);
        if (this.speed <= 0) {
          return 0;
        }
        return this.speed * delta;
      }
    }, {
      key: "update",
      value: function update(delta) {
        // delta in sec
        this.updateSpeed(delta);
        if (this.speed > 0) {
          this.value += this.getDeltaValue(delta);
        }
        return this;
      }
    }, {
      key: "isMoving",
      get: function get() {
        return this.speed > 0;
      }
    }]);
    return Movement;
  }();

  var SlowDown = /*#__PURE__*/function () {
    function SlowDown() {
      _classCallCheck(this, SlowDown);
      this.value;
      this.dir; // true:+, false:-
      this.movement = new Movement();
    }
    _createClass(SlowDown, [{
      key: "init",
      value: function init(start, dir, speed, dec, end) {
        this.value = start;
        this.end = end;
        if (end !== undefined) {
          this.dir = start < end;
        } else {
          this.dir = dir;
        }
        this.movement.setSpeed(speed).setAcceleration(-dec);
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.movement.reset();
      }
    }, {
      key: "update",
      value: function update(delta) {
        // delta in sec
        var d = this.movement.getDeltaValue(delta);
        if (!this.dir) {
          d = -d;
        }
        if (this.end === undefined) {
          this.value += d;
        } else {
          if (d === 0) {
            this.value = this.end;
          } else {
            this.value += d;
            if (this.dir) {
              // +
              if (this.value > this.end) {
                this.value = this.end;
              }
            } else {
              // -
              if (this.value < this.end) {
                this.value = this.end;
              }
            }
          }
        }
        return this;
      }
    }, {
      key: "isMoving",
      get: function get() {
        return this.movement.isMoving;
      }
    }]);
    return SlowDown;
  }();

  var GetValue$1m = Phaser.Utils.Objects.GetValue;
  var Clamp$7 = Phaser.Math.Clamp;
  var Scroller = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Scroller, _ComponentBase);
    function Scroller(gameObject, config) {
      var _this;
      _classCallCheck(this, Scroller);
      _this = _callSuper(this, Scroller, [gameObject, config]);
      // this.parent = gameObject;

      var enable = GetValue$1m(config, 'enable', true);
      _this._state = new State(_assertThisInitialized(_this), {
        enable: enable,
        eventEmitter: false
      });
      var drapSpeedConfig = {
        inputConfig: GetValue$1m(config, 'inputConfig', undefined),
        enable: enable,
        pointerOutRelease: GetValue$1m(config, 'pointerOutRelease', true),
        eventEmitter: false
      };
      _this.dragState = new DragSpeed(gameObject, drapSpeedConfig);
      _this._enable = undefined;
      _this._value = undefined;
      _this._slowDown = new SlowDown();
      var callback = GetValue$1m(config, 'valuechangeCallback', null);
      if (callback !== null) {
        var scope = GetValue$1m(config, 'valuechangeCallbackScope', undefined);
        _this.on('valuechange', callback, scope);
      }
      callback = GetValue$1m(config, 'overmaxCallback', null);
      if (callback !== null) {
        var scope = GetValue$1m(config, 'overmaxCallbackScope', undefined);
        _this.on('overmax', callback, scope);
      }
      callback = GetValue$1m(config, 'overminCallback', null);
      if (callback !== null) {
        var scope = GetValue$1m(config, 'overminCallbackScope', undefined);
        _this.on('overmin', callback, scope);
      }
      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(Scroller, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setOrientationMode(GetValue$1m(o, 'orientation', 0));
        this.setDragThreshold(GetValue$1m(o, 'threshold', 10));
        this.setSlidingDeceleration(GetValue$1m(o, 'slidingDeceleration', 5000));
        this.setBackDeceleration(GetValue$1m(o, 'backDeceleration', 2000));
        var dragRate = GetValue$1m(o, 'dragRate', 1);
        dragRate = dragRate * (GetValue$1m(o, 'dragReverse', false) ? -1 : 1);
        this.setDragRate(dragRate);
        var bounds = GetValue$1m(o, 'bounds', undefined);
        if (bounds) {
          this.setBounds(bounds);
        } else {
          this.setBounds(GetValue$1m(o, 'max', 0), GetValue$1m(o, 'min', 0));
        }
        this.setValue(GetValue$1m(o, 'value', this.maxValue || 0));
        this.setEnable(GetValue$1m(o, "enable", true));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        this.scene.sys.events.on('preupdate', this._state.update, this._state);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        this.scene.sys.events.off('preupdate', this._state.update, this._state);
        this._state.destroy(fromScene);
        this.dragState.destroy(fromScene);
        this._state = undefined;
        this.dragState = undefined;
        _get(_getPrototypeOf(Scroller.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }
        this._enable = e;
        this._state.setEnable(e);
        this.dragState.setEnable(e);
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setOrientationMode",
      value: function setOrientationMode(m) {
        if (typeof m === 'string') {
          m = ORIENTATIONMODE$1[m];
        }
        this.orientationMode = m;
        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }, {
      key: "setSlidingDeceleration",
      value: function setSlidingDeceleration(dec) {
        this.slidingDeceleration = dec;
        return this;
      }
    }, {
      key: "setBackDeceleration",
      value: function setBackDeceleration(dec) {
        this.backDeceleration = dec;
        return this;
      }
    }, {
      key: "setDragRate",
      value: function setDragRate(ratio) {
        this.dragRate = ratio;
        return this;
      }
    }, {
      key: "setBounds",
      value: function setBounds(value0, value1) {
        if (Array.isArray(value0)) {
          var bounds = value0;
          value0 = bounds[0];
          value1 = bounds[1];
        }
        if (value0 < value1) {
          this.minValue = value0;
          this.maxValue = value1;
        } else {
          this.minValue = value1;
          this.maxValue = value0;
        }
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (value === this._value) {
          return;
        }
        var oldValue = this._value;
        var isOverMax = this.overMax(value);
        var isOverMin = this.overMin(value);
        if (isOverMax) {
          this.emit('overmax', value, oldValue);
        }
        if (isOverMin) {
          this.emit('overmin', value, oldValue);
        }
        if (!this.backEnable) {
          if (isOverMax) {
            value = this.maxValue;
          }
          if (isOverMin) {
            value = this.minValue;
          }
        }
        this._value = value;
        this.emit('valuechange', value, oldValue);
      }
    }, {
      key: "setValue",
      value: function setValue(value, clamp) {
        if (clamp === undefined) {
          clamp = false;
        }
        if (clamp) {
          value = Clamp$7(value, this.minValue, this.maxValue);
        }
        this.value = value;
        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, clamp) {
        this.setValue(this.value + inc, clamp);
        return this;
      }
    }, {
      key: "state",
      get: function get() {
        return this._state.state;
      }
    }, {
      key: "isDragging",
      get: function get() {
        return this.dragState.isInTouched;
      }
    }, {
      key: "outOfMaxBound",
      get: function get() {
        return this.overMax(this.value);
      }
    }, {
      key: "outOfMinBound",
      get: function get() {
        return this.overMin(this.value);
      }
    }, {
      key: "outOfBounds",
      get: function get() {
        return this.outOfMinBound || this.outOfMaxBound;
      }

      // internal
    }, {
      key: "overMax",
      value: function overMax(value) {
        return this.maxValue != null && value > this.maxValue;
      }
    }, {
      key: "overMin",
      value: function overMin(value) {
        return this.minValue != null && value < this.minValue;
      }
    }, {
      key: "backEnable",
      get: function get() {
        return typeof this.backDeceleration === 'number';
      }
    }, {
      key: "isPullBack",
      get: function get() {
        return this._slowDown.isMoving;
      }
    }, {
      key: "slidingEnable",
      get: function get() {
        return typeof this.slidingDeceleration === 'number';
      }
    }, {
      key: "isSliding",
      get: function get() {
        return this._slowDown.isMoving;
      }
    }, {
      key: "dragDelta",
      get: function get() {
        var delta;
        if (this.orientationMode === 0) {
          // y
          delta = this.dragState.dy;
        } else if (this.orientationMode === 1) {
          // x
          delta = this.dragState.dx;
        } else {
          delta = 0;
        }
        delta *= this.dragRate;
        return delta;
      }
    }, {
      key: "dragSpeed",
      get: function get() {
        var speed;
        if (this.orientationMode === 0) {
          // y
          speed = this.dragState.speedY;
        } else if (this.orientationMode === 1) {
          // x
          speed = this.dragState.speedX;
        } else {
          speed = 0;
        }
        speed *= this.dragRate;
        return speed;
      }

      // enter_DRAG
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.emit('dragstart');
      }

      // exit_DRAG
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.emit('dragend');
      }

      // everyTick_DRAG
    }, {
      key: "dragging",
      value: function dragging() {
        this.value += this.dragDelta;
      }

      // enter_SLIDE 
    }, {
      key: "onSliding",
      value: function onSliding() {
        var start = this.value;
        var speed = this.dragSpeed;
        if (speed === 0) {
          this._slowDown.stop();
          this._state.next();
          return;
        }
        var dec = this.slidingDeceleration;
        this._slowDown.init(start, speed > 0, Math.abs(speed), dec);
      }

      // everyTick_SLIDE
    }, {
      key: "sliding",
      value: function sliding(time, delta) {
        delta *= 0.001;
        var newValue = this._slowDown.update(delta).value;
        if (this.overMax(newValue)) {
          this.value = this.maxValue;
          this._slowDown.stop();
        } else if (this.overMin(newValue)) {
          this.value = this.minValue;
          this._slowDown.stop();
        } else {
          this.value = newValue;
        }
      }

      // enter_BACK
    }, {
      key: "onPullBack",
      value: function onPullBack() {
        var start = this.value;
        var end = this.outOfMinBound ? this.minValue : this.maxValue;
        var dist = Math.abs(end - start);
        var dec = this.backDeceleration;
        var speed = Math.sqrt(2 * dec * dist);
        this._slowDown.init(start, undefined, speed, dec, end);
      }

      // everyTick_BACK
    }, {
      key: "pullBack",
      value: function pullBack(time, delta) {
        delta *= 0.001;
        this.value = this._slowDown.update(delta).value;
        if (!this._slowDown.isMoving) {
          this._state.next();
        }
      }

      // exit_SLIDE, exit_BACK
    }, {
      key: "stop",
      value: function stop() {
        this._slowDown.stop();
      }
    }]);
    return Scroller;
  }(ComponentBase);
  var ORIENTATIONMODE$1 = {
    y: 0,
    v: 0,
    vertical: 0,
    x: 1,
    h: 1,
    horizontal: 1
  };

  var GetValue$1l = Phaser.Utils.Objects.GetValue;
  var MouseWheelScroller = /*#__PURE__*/function (_ComponentBase) {
    _inherits(MouseWheelScroller, _ComponentBase);
    function MouseWheelScroller(gameObject, config) {
      var _this;
      _classCallCheck(this, MouseWheelScroller);
      _this = _callSuper(this, MouseWheelScroller, [gameObject, config]);
      // this.parent = gameObject;

      if (_this.parent !== _this.scene) {
        _this.focusMode = GetValue$1l(config, 'focus', true);
      } else {
        _this.focusMode = false;
      }
      _this.setSpeed(GetValue$1l(config, 'speed', 0.1));
      _this.setEnable(GetValue$1l(config, 'enable', true));
      if (!_this.focusMode) {
        // Register on scene
        _this.scene.input.on('wheel', _this.onSceneScroll, _assertThisInitialized(_this));
      } else {
        var gameObject = _this.parent;
        gameObject.setInteractive(GetValue$1l(config, "inputConfig", undefined)).on('wheel', function (pointer, dx, dy, dz, event) {
          if (!this.enable) {
            return;
          }
          this.scroll(dy);
        }, _assertThisInitialized(_this));
      }
      return _this;
    }
    _createClass(MouseWheelScroller, [{
      key: "destroy",
      value: function destroy() {
        if (!this.focusMode) {
          this.scene.input.off('wheel', this.onSceneScroll, this);
        }
      }
    }, {
      key: "onSceneScroll",
      value: function onSceneScroll(pointer, currentlyOver, dx, dy, dz, event) {
        if (!this.enable) {
          return;
        }
        this.scroll(dy);
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }
        this.enable = e;
        return this;
      }
    }, {
      key: "setSpeed",
      value: function setSpeed(speed) {
        this.speed = speed;
        return this;
      }
    }, {
      key: "scroll",
      value: function scroll(dy) {
        dy *= this.speed;
        this.emit('scroll', dy, this.parent, this);
      }
    }]);
    return MouseWheelScroller;
  }(ComponentBase);

  var GetValue$1k = Phaser.Utils.Objects.GetValue;
  var AddSlider = function AddSlider(topPatent, sliderParent, axis, config) {
    axis = axis.toUpperCase();
    var isAxisY = axis === 'Y';
    var isScrollXYMode = topPatent.scrollMode === 2;
    var child = topPatent.childrenMap.child;
    var sliderConfig, slider;
    var sliderConfigKey = "slider".concat(axis);
    if (isScrollXYMode) {
      sliderConfig = GetValue$1k(config, sliderConfigKey, undefined);
    } else {
      if (config.hasOwnProperty(sliderConfigKey)) {
        sliderConfig = GetValue$1k(config, sliderConfigKey, undefined);
      } else {
        sliderConfig = GetValue$1k(config, 'slider', undefined);
      }
    }
    if (sliderConfig) {
      if (sliderConfig === true) {
        sliderConfig = {};
      }
      sliderConfig.orientation = isAxisY ? 1 : 0;
      slider = CreateScrollbar(topPatent.scene, sliderConfig);
      var column, row, padding;
      var sliderPosition = GetValue$1k(sliderConfig, 'position', 0);
      if (typeof sliderPosition === 'string') {
        sliderPosition = SLIDER_POSITION_MAP[sliderPosition];
      }

      /*
      1. space.sliderX, space.sliderY
      2. space.slider
      3. space.child
      */
      var sliderPadding = GetValue$1k(config, "space.slider".concat(axis), undefined);
      var childPadding; // Legacy
      if (sliderPadding === undefined) {
        sliderPadding = GetValue$1k(config, 'space.slider', undefined);
        if (sliderPadding === undefined) {
          if (isScrollXYMode) {
            sliderPadding = 0;
          } else {
            childPadding = GetValue$1k(config, 'space.child', 0);
          }
        }
      }
      var isNumberSliderPadding;
      if (childPadding === undefined) {
        isNumberSliderPadding = typeof sliderPadding === 'number';
      } else {
        isNumberSliderPadding = typeof childPadding === 'number';
      }
      if (isAxisY) {
        if (sliderPosition === 0) {
          // right
          column = 2;
          row = 1;
          if (childPadding === undefined) {
            padding = isNumberSliderPadding ? {
              left: sliderPadding
            } : sliderPadding;
          } else {
            padding = {
              left: GetValue$1k(childPadding, 'right', childPadding)
            };
          }
        } else {
          // left
          column = 0;
          row = 1;
          if (childPadding === undefined) {
            padding = isNumberSliderPadding ? {
              right: sliderPadding
            } : sliderPadding;
          } else {
            padding = {
              right: GetValue$1k(childPadding, 'left', childPadding)
            };
          }
        }
      } else {
        if (sliderPosition === 0) {
          // bottom
          column = 1;
          row = 2;
          if (childPadding === undefined) {
            padding = isNumberSliderPadding ? {
              top: sliderPadding
            } : sliderPadding;
          } else {
            padding = {
              top: GetValue$1k(childPadding, 'bottom', childPadding)
            };
          }
        } else {
          // top
          column = 1;
          row = 0;
          if (childPadding === undefined) {
            padding = isNumberSliderPadding ? {
              bottom: sliderPadding
            } : sliderPadding;
          } else {
            padding = {
              bottom: GetValue$1k(childPadding, 'top', childPadding)
            };
          }
        }
      }
      sliderParent.add(slider, {
        column: column,
        row: row,
        align: 'center',
        padding: padding,
        expand: true
      });
      topPatent["hideUnscrollableSlider".concat(axis)] = GetValue$1k(sliderConfig, 'hideUnscrollableSlider', false);
      topPatent["adaptThumb".concat(axis, "SizeMode")] = GetValue$1k(sliderConfig, 'adaptThumbSize', false);
      topPatent["minThumb".concat(axis, "Size")] = GetValue$1k(sliderConfig, 'minThumbSize', undefined);
    } else {
      topPatent["hideUnscrollableSlider".concat(axis)] = false;
      topPatent["adaptThumb".concat(axis, "SizeMode")] = false;
      topPatent["minThumb".concat(axis, "Size")] = undefined;
    }
    var scrollerConfig, scroller;
    var scrollerConfigKey = "scroller".concat(axis);
    if (isScrollXYMode) {
      scrollerConfig = GetValue$1k(config, scrollerConfigKey, true);
    } else {
      if (config.hasOwnProperty(scrollerConfigKey)) {
        scrollerConfig = GetValue$1k(config, scrollerConfigKey, true);
      } else {
        scrollerConfig = GetValue$1k(config, 'scroller', true);
      }
    }
    if (scrollerConfig && child) {
      if (scrollerConfig === true) {
        scrollerConfig = {};
      }
      scrollerConfig.orientation = isAxisY ? 0 : 1;
      scroller = new Scroller(child, scrollerConfig);
    }
    var mouseWheelScrollerConfig = GetValue$1k(config, isScrollXYMode ? "mouseWheelScroller".concat(axis) : 'mouseWheelScroller', false),
      mouseWheelScroller;
    if (mouseWheelScrollerConfig && child) {
      mouseWheelScroller = new MouseWheelScroller(child, mouseWheelScrollerConfig);
    }
    topPatent.addChildrenMap("slider".concat(axis), slider);
    topPatent.addChildrenMap("scroller".concat(axis), scroller);
    topPatent.addChildrenMap("mouseWheelScroller".concat(axis), mouseWheelScroller);
    if (!isScrollXYMode || isAxisY) {
      topPatent['hideUnscrollableSlider'] = topPatent["hideUnscrollableSlider".concat(axis)];
      topPatent['adaptThumbSizeMode'] = topPatent["adaptThumb".concat(axis, "SizeMode")];
      topPatent['minThumbSize'] = topPatent["minThumb".concat(axis, "Size")];
      topPatent.addChildrenMap('slider', slider);
      topPatent.addChildrenMap('scroller', scroller);
      topPatent.addChildrenMap('mouseWheelScroller', mouseWheelScroller);
    }

    // Control
    if (slider) {
      var keyST, eventName;
      if (isScrollXYMode) {
        keyST = isAxisY ? 't' : 's';
        eventName = "scroll".concat(axis);
      } else {
        keyST = 't';
        eventName = 'scroll';
      }
      slider.on('valuechange', function (newValue) {
        topPatent[keyST] = newValue;
        topPatent.emit(eventName, topPatent);
      });
    }
    if (scroller) {
      var keyChildOXY, eventName;
      if (isScrollXYMode) {
        keyChildOXY = "childO".concat(axis);
        eventName = "scroll".concat(axis);
      } else {
        keyChildOXY = 'childOY';
        eventName = 'scroll';
      }
      scroller.on('valuechange', function (newValue) {
        topPatent[keyChildOXY] = newValue;
        topPatent.emit(eventName, topPatent);
      });
    }
    if (mouseWheelScroller) {
      var methodAddChildOXY;
      if (isScrollXYMode) {
        methodAddChildOXY = "addChildO".concat(axis);
      } else {
        methodAddChildOXY = 'addChildOY';
      }
      mouseWheelScroller.on('scroll', function (incValue) {
        topPatent[methodAddChildOXY](-incValue, true);
      });
    }
  };
  var SLIDER_POSITION_MAP = {
    right: 0,
    left: 1,
    bottom: 0,
    top: 1
  };

  var GetValue$1j = Phaser.Utils.Objects.GetValue;
  var CreateScrollableSizer = function CreateScrollableSizer(parent, config) {
    var scene = parent.scene;
    var columnProportions = [0, 1, 0],
      rowProportions = [0, 1, 0];
    var parentMinWidth = GetValue$1j(config, 'width');
    var parentMinHeight = GetValue$1j(config, 'height');
    if (!parentMinWidth) {
      var expandChildWidth = GetValue$1j(config, 'child.expandWidth', true);
      if (!expandChildWidth) {
        columnProportions[1] = 0; // Calculate parent's width by child's width
      }
    }
    if (!parentMinHeight) {
      var expandChildHeight = GetValue$1j(config, 'child.expandHeight', true);
      if (!expandChildHeight) {
        rowProportions[1] = 0; // Calculate parent's height by child's height
      }
    }
    var scrollableSizer = new GridSizer(scene, {
      column: 3,
      row: 3,
      columnProportions: columnProportions,
      rowProportions: rowProportions
    });
    AddChild(parent, scrollableSizer, config);
    switch (parent.scrollMode) {
      case 0:
        // y
        AddSlider(parent, scrollableSizer, 'y', config);
        break;
      case 1:
        // x
        AddSlider(parent, scrollableSizer, 'x', config);
        break;
      default:
        // xy
        AddSlider(parent, scrollableSizer, 'y', config);
        AddSlider(parent, scrollableSizer, 'x', config);
        break;
    }
    return scrollableSizer;
  };

  var ResizeController = function ResizeController() {
    switch (this.scrollMode) {
      case 0:
      case 1:
        SetControllerBounds.call(this);
        this.updateController();
        HideUnscrollableSlider.call(this);
        AdaptThumbSize.call(this);
        break;
      default:
        // 2
        SetControllerBounds.call(this, 'y');
        SetControllerBounds.call(this, 'x');
        this.updateController();
        HideUnscrollableSlider.call(this, 'y');
        HideUnscrollableSlider.call(this, 'x');
        AdaptThumbSize.call(this, 'y');
        AdaptThumbSize.call(this, 'x');
        break;
    }
    return this;
  };
  var SetControllerBounds = function SetControllerBounds(axis) {
    var bound0, bound1;
    var scroller, slider;
    switch (this.scrollMode) {
      case 0:
      case 1:
        bound0 = this.topChildOY;
        bound1 = this.bottomChildOY;
        scroller = this.childrenMap.scroller;
        slider = this.childrenMap.slider;
        break;
      default:
        // 2
        axis = axis.toUpperCase();
        if (axis === 'Y') {
          bound0 = this.topChildOY;
          bound1 = this.bottomChildOY;
        } else {
          bound0 = this.leftChildOX;
          bound1 = this.rightChildOX;
        }
        scroller = this.childrenMap["scroller".concat(axis)];
        slider = this.childrenMap["slider".concat(axis)];
    }
    if (scroller) {
      scroller.setBounds(bound0, bound1);
    }
    if (slider) {
      slider.setEnable(bound0 !== bound1);
    }
  };
  var HideUnscrollableSlider = function HideUnscrollableSlider(axis) {
    switch (this.scrollMode) {
      case 0:
      case 1:
        var slider = this.childrenMap.slider;
        if (slider && this.hideUnscrollableSlider) {
          this.setChildVisible(slider, this.isOverflow);
        }
        break;
      default:
        axis = axis.toUpperCase();
        var slider = this.childrenMap["slider".concat(axis)];
        var hideUnscrollableSlider = this["hideUnscrollableSlider".concat(axis)];
        var isOverflow = this["isOverflow".concat(axis)];
        if (slider && hideUnscrollableSlider) {
          this.setChildVisible(slider, isOverflow);
        }
        break;
    }
  };
  var AdaptThumbSize = function AdaptThumbSize(axis) {
    switch (this.scrollMode) {
      case 0:
      case 1:
        if (!this.adaptThumbSizeMode) {
          return;
        }
        var slider = this.childrenMap.slider;
        if (!slider) {
          return;
        }

        // Change slider size according to visible ratio
        var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
        var track = slider.childrenMap.track;
        var thumb = slider.childrenMap.thumb;
        var minThumbSize = this.minThumbSize;
        if (this.scrollMode === 0) {
          var newHeight = track.displayHeight * ratio;
          if (minThumbSize !== undefined && newHeight < minThumbSize) {
            newHeight = minThumbSize;
          }
          ResizeGameObject(thumb, undefined, newHeight);
        } else {
          var newWidth = track.displayWidth * ratio;
          if (minThumbSize !== undefined && newWidth < minThumbSize) {
            newWidth = minThumbSize;
          }
          ResizeGameObject(thumb, newWidth, undefined);
        }
        LayoutSlider(slider);
        break;
      default:
        // TODO
        axis = axis.toUpperCase();
        var adaptThumbSizeMode = this["adaptThumb".concat(axis, "SizeMode")];
        if (!adaptThumbSizeMode) {
          return;
        }
        var slider = this.childrenMap["slider".concat(axis)];
        if (!slider) {
          return;
        }

        // Change slider size according to visible ratio            
        var track = slider.childrenMap.track;
        var thumb = slider.childrenMap.thumb;
        var minThumbSize = this["minThumb".concat(axis, "Size")];
        if (axis === 'Y') {
          var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
          var newHeight = track.displayHeight * ratio;
          if (minThumbSize !== undefined && newHeight < minThumbSize) {
            newHeight = minThumbSize;
          }
          ResizeGameObject(thumb, undefined, newHeight);
        } else {
          var ratio = Math.min(this.childVisibleWidth / this.childWidth, 1);
          var newWidth = track.displayWidth * ratio;
          if (minThumbSize !== undefined && newWidth < minThumbSize) {
            newWidth = minThumbSize;
          }
          ResizeGameObject(thumb, newWidth, undefined);
        }
        LayoutSlider(slider);
        break;
    }
  };
  var LayoutSlider = function LayoutSlider(slider) {
    // Save minSize
    var minWidthSave = slider.minWidth;
    var minHeightSave = slider.minHeight;
    // Set minSize to current size
    slider.minWidth = slider.width;
    slider.minHeight = slider.height;
    // Layout slider
    slider.layout();
    // Restore minSize
    slider.minWidth = minWidthSave;
    slider.minHeight = minHeightSave;
  };

  var UpdateController = function UpdateController() {
    switch (this.scrollMode) {
      case 0:
      case 1:
        var scroller = this.childrenMap.scroller;
        var slider = this.childrenMap.slider;
        if (scroller) {
          scroller.setValue(this.childOY);
        }
        if (slider) {
          slider.setValue(this.t);
        }
        break;
      default:
        var scrollerY = this.childrenMap.scrollerY;
        var sliderY = this.childrenMap.sliderY;
        var scrollerX = this.childrenMap.scrollerX;
        var sliderX = this.childrenMap.sliderX;
        if (scrollerY) {
          scrollerY.setValue(this.childOY);
        }
        if (sliderY) {
          sliderY.setValue(this.t);
        }
        if (scrollerX) {
          scrollerX.setValue(this.childOX);
        }
        if (sliderX) {
          sliderX.setValue(this.s);
        }
        break;
    }
  };

  var GetValue$1i = Phaser.Utils.Objects.GetValue;
  var Clamp$6 = Phaser.Math.Clamp;
  var Scrollable = /*#__PURE__*/function (_Sizer) {
    _inherits(Scrollable, _Sizer);
    function Scrollable(scene, config) {
      var _this;
      _classCallCheck(this, Scrollable);
      if (config === undefined) {
        config = {};
      }
      var scrollMode = GetScrollMode(config); // 0:y, 1:x, 2:xy
      // Create sizer
      var isRevererXY = scrollMode === 1;
      config.orientation = !isRevererXY ? 1 : 0;
      _this = _callSuper(this, Scrollable, [scene, config]);
      _this.type = GetValue$1i(config, 'type', 'rexScrollable');
      _this.scrollMode = scrollMode;

      // Add elements
      // Background
      var background = GetValue$1i(config, 'background', undefined);
      if (background) {
        _this.addBackground(background);
      }
      var header = GetValue$1i(config, 'header', undefined);
      if (header) {
        var align = GetValue$1i(config, 'align.header', 'center');
        var headerSpace = GetValue$1i(config, 'space.header', 0);
        var padding;
        if (!isRevererXY) {
          padding = {
            bottom: headerSpace
          };
        } else {
          padding = {
            right: headerSpace
          };
        }
        _this.add(header, {
          proportion: 0,
          align: align,
          padding: padding,
          expand: GetValue$1i(config, 'expand.header', true)
        });
      }
      var scrollableSizer = CreateScrollableSizer(_assertThisInitialized(_this), config);
      if (scrollableSizer) {
        _this.add(scrollableSizer, {
          proportion: 1,
          align: 'center',
          padding: 0,
          expand: true
        });
      }
      var footer = GetValue$1i(config, 'footer', undefined);
      if (footer) {
        var align = GetValue$1i(config, 'align.footer', 'center');
        var footerSpace = GetValue$1i(config, 'space.footer', 0);
        var padding;
        if (!isRevererXY) {
          padding = {
            top: footerSpace
          };
        } else {
          padding = {
            left: footerSpace
          };
        }
        _this.add(footer, {
          proportion: 0,
          align: align,
          padding: padding,
          expand: GetValue$1i(config, 'expand.footer', true)
        });
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('header', header);
      _this.addChildrenMap('footer', footer);
      _this.runLayoutFlag = false;

      /* 
      Necessary properties of child object :
        - child.t (RW), 
      - child.childOY (RW)        
      - child.topChildOY (R)
      - child.bottomChildOY (R)
      - child.childVisibleHeight (R)
      - child.childHeight (R)
        - child.s (RW), 
      - child.childOX (RW)
      - child.leftChildOX (R)
      - child.rightChildOX (R)
      - child.childVisibleWidth (R)
      - child.childWidth (R)        
      */
      return _this;
    }
    _createClass(Scrollable, [{
      key: "postLayout",
      value: function postLayout(parent, newWidth, newHeight) {
        var s = 0,
          t = 0;
        if (!this.runLayoutFlag) {
          this.runLayoutFlag = true;
        } else {
          t = this.t;
          if (this.scrollMode === 2) {
            s = this.s;
          }
        }
        this.resizeController();
        this.setT(t);
        if (this.scrollMode === 2) {
          this.setS(s);
        }
        return this;
      }
    }, {
      key: "t",
      get: function get() {
        var t = this.childrenMap.child.t;

        // Get outer childT
        var childMargin = this.childMargin;
        if (childMargin.top !== 0 || childMargin.bottom !== 0) {
          var child = this.childrenMap.child;
          var innerHeight = child.topChildOY - child.bottomChildOY;
          var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
          var outerChildOY = innerHeight * t + childMargin.top;
          t = outerHeight !== 0 ? outerChildOY / outerHeight : 0;
        }
        return t;
      },
      set: function set(value) {
        // Get inner childT
        var childMargin = this.childMargin;
        if (childMargin.top !== 0 || childMargin.bottom !== 0) {
          var child = this.childrenMap.child;
          var innerHeight = child.topChildOY - child.bottomChildOY;
          var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
          var innerChildOY = outerHeight * value - childMargin.top;
          value = innerHeight !== 0 ? innerChildOY / innerHeight : 0;
        }
        this.childrenMap.child.t = value;
        this.updateController();
      }
    }, {
      key: "s",
      get: function get() {
        var s = this.childrenMap.child.s;

        // Get outer childT
        var childMargin = this.childMargin;
        if (childMargin.left !== 0 || childMargin.right !== 0) {
          var child = this.childrenMap.child;
          var innerWidth = child.leftChildOX - child.rightChildOX;
          var outerWidth = innerWidth + childMargin.left + childMargin.right;
          var outerChildOX = innerWidth * s + childMargin.left;
          s = outerWidth !== 0 ? outerChildOX / outerWidth : 0;
        }
        return s;
      },
      set: function set(value) {
        // Get inner childS
        var childMargin = this.childMargin;
        if (childMargin.left !== 0 || childMargin.right !== 0) {
          var child = this.childrenMap.child;
          var innerWidth = child.leftChildOX - child.rightChildOX;
          var outerWidth = innerWidth + childMargin.left + childMargin.right;
          var innerChildOX = outerWidth * value - childMargin.left;
          value = innerWidth !== 0 ? innerChildOX / innerWidth : 0;
        }
        this.childrenMap.child.s = value;
        this.updateController();
      }
    }, {
      key: "childOY",
      get: function get() {
        return this.childrenMap.child.childOY;
      },
      set: function set(value) {
        this.childrenMap.child.childOY = value;
        this.updateController();
      }
    }, {
      key: "childOX",
      get: function get() {
        return this.childrenMap.child.childOX;
      },
      set: function set(value) {
        this.childrenMap.child.childOX = value;
        this.updateController();
      }
    }, {
      key: "topChildOY",
      get: function get() {
        return this.childrenMap.child.topChildOY + this.childMargin.top;
      }
    }, {
      key: "bottomChildOY",
      get: function get() {
        return this.childrenMap.child.bottomChildOY - this.childMargin.bottom;
      }
    }, {
      key: "leftChildOX",
      get: function get() {
        return this.childrenMap.child.leftChildOX + this.childMargin.left;
      }
    }, {
      key: "rightChildOX",
      get: function get() {
        return this.childrenMap.child.rightChildOX - this.childMargin.right;
      }
    }, {
      key: "childVisibleHeight",
      get: function get() {
        return this.childrenMap.child.childVisibleHeight;
      }
    }, {
      key: "childHeight",
      get: function get() {
        return this.childrenMap.child.childHeight;
      }
    }, {
      key: "childVisibleWidth",
      get: function get() {
        return this.childrenMap.child.childVisibleWidth;
      }
    }, {
      key: "childWidth",
      get: function get() {
        return this.childrenMap.child.childWidth;
      }
    }, {
      key: "isOverflow",
      get: function get() {
        var child = this.childrenMap.child;
        return child.topChildOY !== child.bottomChildOY;
      }
    }, {
      key: "isOverflowY",
      get: function get() {
        return this.isOverflow;
      }
    }, {
      key: "isOverflowX",
      get: function get() {
        var child = this.childrenMap.child;
        return child.leftChildOX !== child.rightChildOX;
      }
    }, {
      key: "setChildOY",
      value: function setChildOY(value, clamp) {
        if (clamp === undefined) {
          clamp = false;
        }
        if (clamp) {
          value = Clamp$6(value, this.bottomChildOY, this.topChildOY);
        }
        this.childOY = value;
        return this;
      }
    }, {
      key: "addChildOY",
      value: function addChildOY(inc, clamp) {
        this.setChildOY(this.childOY + inc, clamp);
        return this;
      }
    }, {
      key: "setT",
      value: function setT(value, clamp) {
        if (clamp === undefined) {
          clamp = false;
        }
        if (clamp) {
          value = Clamp$6(value, 0, 1);
        }
        this.t = value;
        return this;
      }
    }, {
      key: "addT",
      value: function addT(inc, clamp) {
        this.setT(this.t + inc, clamp);
        return this;
      }
    }, {
      key: "scrollToTop",
      value: function scrollToTop() {
        this.t = 0;
        return this;
      }
    }, {
      key: "scrollToBottom",
      value: function scrollToBottom() {
        this.t = 1;
        // t will be 0 if panel/table does not exceed visible area
        if (this.t === 0) {
          return this;
        }

        // Panel/Table height might be expanded while cells are visible        
        do {
          this.t = 1;
        } while (this.t !== 1);
        return this;
      }
    }, {
      key: "setChildOX",
      value: function setChildOX(value, clamp) {
        if (clamp === undefined) {
          clamp = false;
        }
        if (clamp) {
          value = Clamp$6(value, this.leftChildOX, this.rightChildOX);
        }
        this.childOX = value;
        return this;
      }
    }, {
      key: "addChildOX",
      value: function addChildOX(inc, clamp) {
        this.setChildOX(this.childOX + inc, clamp);
        return this;
      }
    }, {
      key: "setS",
      value: function setS(value, clamp) {
        if (clamp === undefined) {
          clamp = false;
        }
        if (clamp) {
          value = Clamp$6(value, 0, 1);
        }
        this.s = value;
        return this;
      }
    }, {
      key: "addS",
      value: function addS(inc, clamp) {
        this.setS(this.s + inc, clamp);
        return this;
      }
    }, {
      key: "scrollToLeft",
      value: function scrollToLeft() {
        this.s = 0;
        return this;
      }
    }, {
      key: "scrollToRight",
      value: function scrollToRight() {
        this.s = 1;
        // s will be 0 if panel/table does not exceed visible area
        if (this.s === 0) {
          return this;
        }

        // Panel/Table height might be expanded while cells are visible        
        do {
          this.s = 1;
        } while (this.s !== 1);
        return this;
      }
    }, {
      key: "sliderEnable",
      get: function get() {
        var slider = this.childrenMap.slider;
        if (!slider) {
          return false;
        }
        return slider.enable;
      },
      set: function set(value) {
        var slider = this.childrenMap.slider;
        if (!slider) {
          return;
        }
        slider.setEnable(value);
      }
    }, {
      key: "setSliderEnable",
      value: function setSliderEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        this.sliderEnable = enabled;
        return this;
      }
    }, {
      key: "sliderYEnable",
      get: function get() {
        return this.sliderEnable;
      },
      set: function set(value) {
        this.sliderEnable = value;
      }
    }, {
      key: "setSliderYEnable",
      value: function setSliderYEnable(enabled) {
        this.setSliderEnable(enabled);
        return this;
      }
    }, {
      key: "sliderXEnable",
      get: function get() {
        var slider = this.childrenMap.sliderX;
        if (!slider) {
          return false;
        }
        return slider.enable;
      },
      set: function set(value) {
        var slider = this.childrenMap.sliderX;
        if (!slider) {
          return;
        }
        slider.setEnable(value);
      }
    }, {
      key: "setSliderXEnable",
      value: function setSliderXEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        this.sliderXEnable = enabled;
        return this;
      }
    }, {
      key: "scrollerEnable",
      get: function get() {
        var scroller = this.childrenMap.scroller;
        if (!scroller) {
          return false;
        }
        return scroller.enable;
      },
      set: function set(value) {
        var scroller = this.childrenMap.scroller;
        if (!scroller) {
          return;
        }
        scroller.setEnable(value);
      }
    }, {
      key: "setScrollerEnable",
      value: function setScrollerEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        this.scrollerEnable = enabled;
        return this;
      }
    }, {
      key: "scrollerYEnable",
      get: function get() {
        return this.scrollerEnable;
      },
      set: function set(value) {
        this.scrollerEnable = value;
      }
    }, {
      key: "setScrollerYEnable",
      value: function setScrollerYEnable(enabled) {
        this.setScrollerEnable(enabled);
        return this;
      }
    }, {
      key: "scrollerXEnable",
      get: function get() {
        var scroller = this.childrenMap.scrollerX;
        if (!scroller) {
          return false;
        }
        return scroller.enable;
      },
      set: function set(value) {
        var scroller = this.childrenMap.scrollerX;
        if (!scroller) {
          return;
        }
        scroller.setEnable(value);
      }
    }, {
      key: "setScrollerXEnable",
      value: function setScrollerXEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        this.scrollerXEnable = enabled;
        return this;
      }
    }, {
      key: "mouseWheelScrollerEnable",
      get: function get() {
        var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
        if (!mouseWheelScroller) {
          return false;
        }
        return mouseWheelScroller.enable;
      },
      set: function set(value) {
        var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
        if (!mouseWheelScroller) {
          return;
        }
        mouseWheelScroller.setEnable(value);
      }
    }, {
      key: "setMouseWheelScrollerEnable",
      value: function setMouseWheelScrollerEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        this.mouseWheelScrollerEnable = enabled;
        return this;
      }
    }, {
      key: "mouseWheelScrollerYEnable",
      get: function get() {
        return this.mouseWheelScrollerEnable;
      },
      set: function set(value) {
        this.mouseWheelScrollerEnable = value;
      }
    }, {
      key: "setMouseWheelScrollerYEnable",
      value: function setMouseWheelScrollerYEnable(enabled) {
        this.setMouseWheelScrollerEnable(enabled);
        return this;
      }
    }, {
      key: "mouseWheelScrollerXEnable",
      get: function get() {
        var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
        if (!mouseWheelScroller) {
          return false;
        }
        return mouseWheelScroller.enable;
      },
      set: function set(value) {
        var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
        if (!mouseWheelScroller) {
          return;
        }
        mouseWheelScroller.setEnable(value);
      }
    }, {
      key: "setMouseWheelScrollerXEnable",
      value: function setMouseWheelScrollerXEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        this.mouseWheelScrollerXEnable = enabled;
        return this;
      }
    }, {
      key: "setDropZoneEnable",
      value: function setDropZoneEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        var child = this.childrenMap.child;
        child.setInteractive();
        child.input.dropZone = enable;
        return this;
      }
    }]);
    return Scrollable;
  }(Sizer);
  var Methods$7 = {
    resizeController: ResizeController,
    updateController: UpdateController
  };

  // mixin
  Object.assign(Scrollable.prototype, Methods$7);

  var TextClass = Phaser.GameObjects.Text;
  var IsTextGameObject = function IsTextGameObject(gameObject) {
    return gameObject instanceof TextClass;
  };

  var BitmapTextClass = Phaser.GameObjects.BitmapText;
  var IsBitmapTextGameObject = function IsBitmapTextGameObject(gameObject) {
    return gameObject instanceof BitmapTextClass;
  };

  var TextType = 0;
  var TagTextType = 1;
  var BitmapTextType = 2;
  var GetTextObjectType = function GetTextObjectType(textObject) {
    var textObjectType;
    if (IsBitmapTextGameObject(textObject)) {
      textObjectType = BitmapTextType;
    } else if (IsTextGameObject(textObject)) {
      textObjectType = TextType;
    } else {
      textObjectType = TagTextType;
    }
    return textObjectType;
  };

  var TextToLines = function TextToLines(textObject, text, lines) {
    var textObjectType = GetTextObjectType(textObject);
    switch (textObjectType) {
      case TextType:
        lines = textObject.getWrappedText(text); // Array of string
        break;
      case TagTextType:
        lines = textObject.getPenManager(text, lines); // Pens-manager
        break;
      case BitmapTextType:
        if (textObject.maxWidth > 0) {
          lines = textObject.setText(text).getTextBounds().wrappedText.split('\n');
        } else {
          lines = text.split('\n');
        }
        break;
    }
    return lines;
  };

  var SetText = function SetText(text) {
    if (text !== undefined) {
      this.text = text;
    }

    // Wrap content in lines
    this.lines = TextToLines(this.textObject, this.text, this.lines);

    // Get lines count
    this.linesCount = this.lines.length;

    // Re-calculate these values later
    this._textHeight = undefined;
    this._textVisibleHeight = undefined;
    this.updateTextObject();
    return this;
  };

  var TextHeightToLinesCount$1 = function TextHeightToLinesCount(height) {
    // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
    return (height - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing);
  };

  var LinesCountToTextHeight = function LinesCountToTextHeight(linesCount) {
    // height = (linesCount * (lineHeight + lineSpacing)) - lineSpacing
    return linesCount * (this.textLineHeight + this.textLineSpacing) - this.textLineSpacing;
  };

  var GetLines$1 = function GetLines(startLineIdx) {
    var endLineIdx = startLineIdx + this.visibleLinesCount + 1;
    var text;
    switch (this.textObjectType) {
      case TextType:
        text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
        break;
      case TagTextType:
        var startIdx = this.lines.getLineStartIndex(startLineIdx);
        var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
        text = this.lines.getSliceTagText(startIdx, endIdx, true);
        break;
      case BitmapTextType:
        text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
        break;
    }
    return text;
  };

  var SetNoWrapText = function SetNoWrapText(textObject, text) {
    var textObjectType = GetTextObjectType(textObject);
    switch (textObjectType) {
      case TextType:
        // Store wrap properties
        var style = textObject.style;
        var wordWrapWidth = style.wordWrapWidth;
        var wordWrapCallback = style.wordWrapCallback;
        // Disable wrap
        style.wordWrapWidth = 0;
        style.wordWrapCallback = undefined;
        // Set text
        textObject.setText(text);
        // Restore wrap
        style.wordWrapWidth = wordWrapWidth;
        style.wordWrapCallback = wordWrapCallback;
        break;
      case TagTextType:
        // Store wrap properties
        var style = textObject.style;
        var wrapMode = style.wrapMode;
        // Disable wrap
        style.wrapMode = 0;
        // Set text
        textObject.setText(text);
        // Restore wrap
        style.wrapMode = wrapMode;
        break;
      case BitmapTextType:
        // Store wrap properties
        var maxWidth = textObject._maxWidth;
        // Disable wrap
        textObject._maxWidth = 0;
        // Set text
        textObject.setText(text);
        // Restore wrap
        textObject._maxWidth = maxWidth;
        break;
    }
  };

  var ResetTextObjectPosition = function ResetTextObjectPosition() {
    var config = this.textObject.rexSizer;
    this.textObject.y += config.offsetY - config.preOffsetY;
    config.preOffsetY = config.offsetY;
    this.resetChildPositionState(this.textObject);
    if (this.textCropEnable) {
      CropTextObject.call(this);
    }
  };
  var CropTextObject = function CropTextObject() {
    // Don't have setCrop method, return
    if (!this.textObject.setCrop) {
      return;
    }
    var offsetY = this.textObject.rexSizer.offsetY;
    var cropY, cropHeight;
    if (offsetY <= 0) {
      cropY = -offsetY;
      cropHeight = this.height;
    } else {
      cropY = 0;
      cropHeight = this.height - offsetY;
    }
    this.textObject.setCrop(0, cropY, this.width, cropHeight);
  };

  var UpdateTextObject = function UpdateTextObject() {
    var startLineIndex = Math.max(Math.floor(TextHeightToLinesCount$1.call(this, -this.textOY)), 0);
    var textOffset = LinesCountToTextHeight.call(this, startLineIndex) + this.textOY;

    // Grab visible lines
    var text = GetLines$1.call(this, startLineIndex);

    // Display visible content
    SetNoWrapText(this.textObject, text);
    this.textObject.rexSizer.offsetY = textOffset;
    ResetTextObjectPosition.call(this);
    return this;
  };

  var PreLayout = function PreLayout() {
    // Style of text
    this._textLineHeight = undefined;
    this._textLineSpacing = undefined;
    // Style of text, width of text
    this._visibleLinesCount = undefined;
    // Style of text, total lines of content
    this._textHeight = undefined;
    this._textVisibleHeight = undefined;
    PreLayout$4.call(this);
    return this;
  };

  var ResizeText = function ResizeText(textObject, width, height) {
    height += this.textLineHeight + this.textLineSpacing; // Add 1 line
    if (this.textObjectWidth === width && this._textObjectRealHeight === height) {
      return;
    }
    this.textObjectWidth = width;
    this._textObjectRealHeight = height;
    switch (this.textObjectType) {
      case TextType:
      case TagTextType:
        textObject.setFixedSize(width, height);
        var style = textObject.style;
        var wrapWidth = Math.max(width, 0);
        if (this.textObjectType === TextType) {
          // Built-in text
          style.wordWrapWidth = wrapWidth;
        } else {
          // BBCode text, Tag text
          if (style.wrapMode === 0) {
            // Turn no-wrap to word-wrap
            style.wrapMode = 1;
          }
          style.wrapWidth = wrapWidth;
        }
        break;
      case BitmapTextType:
        textObject.setMaxWidth(width);
        break;
    }

    // Render content again
    this.setText();
  };

  var LayoutChildren$1 = function LayoutChildren() {
    var child, childConfig, padding;
    var startX = this.left,
      startY = this.top;
    var x, y, width, height; // Align zone

    // LayoutChildren text child
    // Skip invisible child
    child = this.textObject;
    if (!child.rexSizer.hidden) {
      childConfig = child.rexSizer;
      padding = childConfig.padding;
      x = startX + padding.left;
      y = startY + padding.top;
      width = this.width - padding.left - padding.right;
      height = this.height - padding.top - padding.bottom;
      ResizeText.call(this, child, width, height);
      AlignIn(child, x, y, width, height, childConfig.align);
      childConfig.preOffsetY = 0; // Clear preOffsetY
      ResetTextObjectPosition.call(this);
      if (this.textMask) {
        this.textMask.setPosition().resize();
        this.resetChildPositionState(this.textMask);
      }
    }
  };

  var Methods$6 = {
    setText: SetText,
    updateTextObject: UpdateTextObject,
    preLayout: PreLayout,
    layoutChildren: LayoutChildren$1
  };

  var IsPlainObject$8 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1h = Phaser.Utils.Objects.GetValue;
  var ALIGN_LEFTTOP$1 = Phaser.Display.Align.TOP_LEFT;
  var TextBlock = /*#__PURE__*/function (_BaseSizer) {
    _inherits(TextBlock, _BaseSizer);
    function TextBlock(scene, x, y, minWidth, minHeight, config) {
      var _this;
      _classCallCheck(this, TextBlock);
      if (IsPlainObject$8(x)) {
        config = x;
        x = GetValue$1h(config, 'x', 0);
        y = GetValue$1h(config, 'y', 0);
        minWidth = GetValue$1h(config, 'width', undefined);
        minHeight = GetValue$1h(config, 'height', undefined);
      } else if (IsPlainObject$8(minWidth)) {
        config = minWidth;
        minWidth = GetValue$1h(config, 'width', undefined);
        minHeight = GetValue$1h(config, 'height', undefined);
      }
      _this = _callSuper(this, TextBlock, [scene, x, y, minWidth, minHeight, config]);
      _this.type = 'rexTextBlock';
      _this.textObject = undefined;
      _this.linesCount = 0;
      _this.textMask = undefined;
      _this.textObjectType = undefined;
      _this._textLineHeight = undefined;
      _this._textLineSpacing = undefined;
      _this._visibleLinesCount = undefined;
      _this._textHeight = undefined;
      _this._textVisibleHeight = undefined;
      _this._textObjectRealHeight = 0;
      _this.lines = undefined;
      // Text object : array of string
      // Tag text object : pens-manager
      // Bitmap text object : array of string

      _this.text = GetValue$1h(config, 'content', '');
      _this._textOY = 0;
      _this.execeedTopState = false;
      _this.execeedBottomState = false;
      _this.setClampMode(GetValue$1h(config, 'clamplTextOY', true));
      _this.alwaysScrollable = GetValue$1h(config, 'alwaysScrollable', false);

      // Add elements
      var background = GetValue$1h(config, 'background', undefined);
      var textObject = GetValue$1h(config, 'text', undefined);
      if (textObject === undefined) {
        textObject = CreateDefaultTextObject(scene);
      }
      _this.textCropEnable = GetValue$1h(config, 'textCrop', !!textObject.setCrop);
      var textMaskEnable = GetValue$1h(config, 'textMask', !_this.textCropEnable);
      if (background) {
        _this.addBackground(background);
      }
      _this.add(textObject);
      _this.sizerChildren = [textObject];
      var sizerConfig = _this.getSizerConfig(textObject);
      sizerConfig.align = ALIGN_LEFTTOP$1;
      sizerConfig.padding = GetBoundsConfig(0);
      sizerConfig.expand = true;
      _this.textObject = textObject;
      _this.textObjectType = GetTextObjectType(textObject);

      // Add more variables
      sizerConfig.preOffsetY = 0;
      sizerConfig.offsetY = 0;

      // Create mask of text object
      if (textMaskEnable) {
        _this.textMask = AddChildMask.call(_assertThisInitialized(_this), _this.textObject, _assertThisInitialized(_this));
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('text', textObject);
      return _this;
    }
    _createClass(TextBlock, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.textObject = undefined;
        this.textMask = undefined;
        if (this.lines) {
          switch (this.textObjectType) {
            case TextType:
              this.lines.length = 0;
              break;
            case TagTextType:
              this.lines.destroy();
              break;
            case BitmapTextType:
              this.lines.length = 0;
              break;
          }
          this.lines = undefined;
        }
        _get(_getPrototypeOf(TextBlock.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setClampMode",
      value: function setClampMode(mode) {
        if (mode === undefined) {
          mode = true;
        }
        this.clampTextOY = mode;
        return this;
      }
    }, {
      key: "textLineHeight",
      get: function get() {
        if (this._textLineHeight === undefined) {
          var lineHeight;
          switch (this.textObjectType) {
            case TextType:
            case TagTextType:
              var style = this.textObject.style;
              lineHeight = style.metrics.fontSize + style.strokeThickness;
              break;
            case BitmapTextType:
              var scale = this.textObject.fontSize / this.textObject.fontData.size;
              lineHeight = this.textObject.fontData.lineHeight * scale;
              break;
          }
          this._textLineHeight = lineHeight;
        }
        return this._textLineHeight;
      }
    }, {
      key: "textLineSpacing",
      get: function get() {
        if (this._textLineSpacing === undefined) {
          var lineSpacing;
          switch (this.textObjectType) {
            case TextType:
            case TagTextType:
              lineSpacing = this.textObject.lineSpacing;
              break;
            case BitmapTextType:
              lineSpacing = 0;
              break;
          }
          this._textLineSpacing = lineSpacing;
        }
        return this._textLineSpacing;
      }
    }, {
      key: "visibleLinesCount",
      get: function get() {
        if (this._visibleLinesCount === undefined) {
          this._visibleLinesCount = Math.floor(TextHeightToLinesCount$1.call(this, this._textObjectRealHeight));
        }
        return this._visibleLinesCount;
      }
    }, {
      key: "topTextOY",
      get: function get() {
        return 0;
      }
    }, {
      key: "bottomTextOY",
      get: function get() {
        return -this.textVisibleHeight;
      }
    }, {
      key: "textHeight",
      get: function get() {
        if (this._textHeight === undefined) {
          this._textHeight = LinesCountToTextHeight.call(this, this.linesCount);
        }
        return this._textHeight;
      }
    }, {
      key: "textObjectHeight",
      get: function get() {
        return this._textObjectRealHeight - (this.textLineHeight + this.textLineSpacing); // Remove 1 text line
      }
    }, {
      key: "textVisibleHeight",
      get: function get() {
        if (this._textVisibleHeight === undefined) {
          var h = this.textHeight - this.textObjectHeight;
          if (!this.alwaysScrollable && h < 0) {
            h = 0;
          }
          this._textVisibleHeight = h;
        }
        return this._textVisibleHeight;
      }
    }, {
      key: "textOYExceedTop",
      value: function textOYExceedTop(oy) {
        if (oy === undefined) {
          oy = this.textOY;
        }
        return oy > this.topTextOY;
      }
    }, {
      key: "textOYExeceedBottom",
      value: function textOYExeceedBottom(oy) {
        if (oy === undefined) {
          oy = this.textOY;
        }
        return oy < this.bottomTextOY;
      }
    }, {
      key: "textOY",
      get: function get() {
        return this._textOY;
      },
      set: function set(oy) {
        var topTextOY = this.topTextOY;
        var bottomTextOY = this.bottomTextOY;
        var textOYExceedTop = this.textOYExceedTop(oy);
        var textOYExeceedBottom = this.textOYExeceedBottom(oy);
        if (this.clampTextOY) {
          if (this.visibleLinesCount > this.linesCount) {
            oy = 0;
          } else if (textOYExceedTop) {
            oy = topTextOY;
          } else if (textOYExeceedBottom) {
            oy = bottomTextOY;
          }
        }
        if (this._textOY !== oy) {
          this._textOY = oy;
          this.updateTextObject();
        }
        if (textOYExceedTop) {
          if (!this.execeedTopState) {
            this.emit('execeedtop', this, oy, topTextOY);
          }
        }
        this.execeedTopState = textOYExceedTop;
        if (textOYExeceedBottom) {
          if (!this.execeedBottomState) {
            this.emit('execeedbottom', this, oy, bottomTextOY);
          }
        }
        this.execeedBottomState = textOYExeceedBottom;
      }
    }, {
      key: "setTextOY",
      value: function setTextOY(oy) {
        this.textOY = oy;
        return this;
      }
    }, {
      key: "t",
      get: function get() {
        var textVisibleHeight = this.textVisibleHeight;
        if (textVisibleHeight === 0) {
          return 0;
        }
        return this.textOY / -textVisibleHeight;
      },
      set: function set(value) {
        this.textOY = -this.textVisibleHeight * value;
      }
    }, {
      key: "setTextOYByPercentage",
      value: function setTextOYByPercentage(percentage) {
        this.t = percentage;
        return this;
      }
    }]);
    return TextBlock;
  }(Base);
  var CreateDefaultTextObject = function CreateDefaultTextObject(scene) {
    return scene.add.text(0, 0, '');
  };
  Object.assign(TextBlock.prototype, Methods$6);

  var InjectProperties$2 = function InjectProperties(textBlock) {
    Object.defineProperty(textBlock, 'childOY', {
      configurable: true,
      get: function get() {
        return textBlock.textOY;
      },
      set: function set(value) {
        textBlock.textOY = value;
      }
    });
    Object.defineProperty(textBlock, 'topChildOY', {
      get: function get() {
        return textBlock.topTextOY;
      }
    });
    Object.defineProperty(textBlock, 'bottomChildOY', {
      get: function get() {
        return textBlock.bottomTextOY;
      }
    });
    Object.defineProperty(textBlock, 'childVisibleHeight', {
      get: function get() {
        return textBlock.textObjectHeight;
      }
    });
    Object.defineProperty(textBlock, 'childHeight', {
      get: function get() {
        return textBlock.textHeight;
      }
    });
  };

  var SetTextMethods$1 = {
    setText: function setText(text) {
      var textBlock = this.childrenMap.child;
      textBlock.setText(text);
      this.resizeController();
      return this;
    },
    appendText: function appendText(text) {
      this.setText(this.text + text);
      return this;
    }
  };

  var ScrollMethods$2 = {
    scrollToLine: function scrollToLine(lineIndex) {
      this.setChildOY(-this.lineHeight * lineIndex);
      return this;
    },
    scrollToNextLine: function scrollToNextLine(lineCount) {
      if (lineCount === undefined) {
        lineCount = 1;
      }
      var lineIndex = this.lineIndex + lineCount;
      this.scrollToLine(lineIndex);
      return this;
    }
  };

  var GetValue$1g = Phaser.Utils.Objects.GetValue;
  var TextArea = /*#__PURE__*/function (_Scrollable) {
    _inherits(TextArea, _Scrollable);
    function TextArea(scene, config) {
      var _this;
      _classCallCheck(this, TextArea);
      if (config === undefined) {
        config = {};
      }

      // Create text-block
      var textObject = GetValue$1g(config, 'text', undefined);
      var textWidth = GetValue$1g(config, 'textWidth', undefined);
      var textHeight = GetValue$1g(config, 'textHeight', undefined);
      var textCrop = GetValue$1g(config, 'textCrop', !!textObject.setCrop);
      var textMask = GetValue$1g(config, 'textMask', !textCrop);
      var content = GetValue$1g(config, 'content', '');
      var textBlock = new TextBlock(scene, {
        width: textWidth,
        height: textHeight,
        text: textObject,
        textMask: textMask,
        textCrop: textCrop && !textMask,
        content: content,
        clamplTextOY: GetValue$1g(config, 'clamplChildOY', false),
        alwaysScrollable: GetValue$1g(config, 'alwaysScrollable', false)
      });
      scene.add.existing(textBlock); // Important: Add to display list for touch detecting
      // Inject properties for scrollable interface
      InjectProperties$2(textBlock);

      // Fill config of scrollable
      config.scrollMode = 0; // Vertical
      config.type = 'rexTextArea';
      config.child = {
        gameObject: textBlock,
        expandWidth: textWidth === undefined,
        expandHeight: textHeight === undefined
      };
      var spaceConfig = GetValue$1g(config, 'space', undefined);
      if (spaceConfig) {
        spaceConfig.child = GetValue$1g(spaceConfig, 'text', 0);
      }
      _this = _callSuper(this, TextArea, [scene, config]);
      _this.addChildrenMap('text', textObject);
      return _this;
    }
    _createClass(TextArea, [{
      key: "text",
      get: function get() {
        return this.childrenMap.child.text;
      }
    }, {
      key: "lineHeight",
      get: function get() {
        var textBlock = this.childrenMap.child;
        return textBlock.textLineHeight + textBlock.textLineSpacing;
      }
    }, {
      key: "lineIndex",
      get: function get() {
        return Math.floor(-this.childOY / this.lineHeight);
      }
    }, {
      key: "linesCount",
      get: function get() {
        var textBlock = this.childrenMap.child;
        return textBlock.linesCount;
      }
    }, {
      key: "contentHeight",
      get: function get() {
        var textBlock = this.childrenMap.child;
        return textBlock.textHeight;
      }
    }]);
    return TextArea;
  }(Scrollable);
  Object.assign(TextArea.prototype, SetTextMethods$1, ScrollMethods$2);

  var GetValue$1f = Phaser.Utils.Objects.GetValue;
  var CreateTextArea = function CreateTextArea(scene, config, creators) {
    config = config ? DeepClone(config) : {};
    var createBackground = GetValue$1f(creators, 'background', CreateBackground$2);
    var createText = GetValue$1f(creators, 'text', CreateText);
    var createTrack = GetValue$1f(creators, 'track', CreateBackground$2);
    var createThumb = GetValue$1f(creators, 'thumb', CreateBackground$2);
    if (createBackground) {
      config.background = createBackground(scene, config.background);
    } else {
      delete config.background;
    }
    if (createText) {
      config.text = createText(scene, config.text);
    } else {
      delete config.text;
    }
    var sliderConfig = config.slider;
    if (sliderConfig !== false && sliderConfig !== null) {
      if (sliderConfig === undefined) {
        sliderConfig = {};
      }
      if (createTrack) {
        sliderConfig.track = createTrack(scene, sliderConfig.track);
      } else {
        delete sliderConfig.track;
      }
      if (createThumb) {
        sliderConfig.thumb = createThumb(scene, sliderConfig.thumb);
      } else {
        delete sliderConfig.thumb;
      }
      config.slider = sliderConfig;
    }

    // No header
    // No footer

    var gameObject = new TextArea(scene, config);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var CreateText = function CreateText(scene, config) {
    var gameObjectType;
    if (config) {
      if (config.hasOwnProperty('$type')) {
        gameObjectType = config.$type;
      } else {
        if (config.hasOwnProperty('key')) {
          gameObjectType = 'bitmaptext';
        }
      }
    }
    var gameObject;
    switch (gameObjectType) {
      case 'bitmaptext':
      case 'bitmap':
        gameObject = new StatesBitmapText(scene, config);
        break;
      case 'bbcodetext':
      case 'bbcode':
        gameObject = new BBCodeText(scene, 0, 0, '', config);
        break;
      case 'label':
        gameObject = new SimpleLabel(scene, config);
        break;
      case 'textarea':
        gameObject = CreateTextArea(scene, config);
        break;
      default:
        gameObject = new StatesText(scene, config);
        break;
    }
    DecorateGameObject(gameObject, config);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var TextRunWidthWrap = function TextRunWidthWrap(textObject) {
    var RunWidthWrap = function RunWidthWrap(width) {
      var padding = textObject.padding;
      var wrapWidth = width - padding.left - padding.right;
      var style = textObject.style;
      if (IsTextGameObject(textObject)) {
        style.wordWrapWidth = wrapWidth;
        style.maxLines = 0;
      } else {
        // BBCode text, Tag text
        if (style.wrapMode === 0) {
          // Turn no-wrap to word-wrap
          style.wrapMode = 1;
        }
        style.wrapWidth = wrapWidth;
        style.maxLines = 0;
      }
      style.fixedWidth = width;
      style.fixedHeight = 0;
      textObject.updateText(); // Redraw text

      textObject.minHeight = textObject.height;
      return textObject;
    };
    return RunWidthWrap;
  };

  var DynamicTextRunWidthWrap = function DynamicTextRunWidthWrap(textObject) {
    var RunWidthWrap = function RunWidthWrap(width) {
      textObject.setFixedSize(width, 0).runWordWrap();
      textObject.minHeight = textObject.height;
      return textObject;
    };
    return RunWidthWrap;
  };

  var BitmapTextRunWidthWrap = function BitmapTextRunWidthWrap(textObject) {
    var RunWidthWrap = function RunWidthWrap(width) {
      textObject.setMaxWidth(width);
      textObject.minHeight = textObject.height;
      return textObject;
    };
    return RunWidthWrap;
  };

  var IsDynamicTextGameObject = function IsDynamicTextGameObject(gameObject) {
    return gameObject instanceof DynamicText;
  };
  var WrapExpandText = function WrapExpandText(textObject, minWidth) {
    if (minWidth === undefined) {
      minWidth = 0;
    }
    textObject._minWidth = minWidth;
    textObject.runWidthWrap = IsDynamicTextGameObject(textObject) ? DynamicTextRunWidthWrap(textObject) : IsBitmapTextGameObject(textObject) ? BitmapTextRunWidthWrap(textObject) : TextRunWidthWrap(textObject);
    return textObject;
  };

  var CreateImage = function CreateImage(scene, config) {
    var gameObjectType;
    if (config) {
      if (config.hasOwnProperty('$type')) {
        gameObjectType = config.$type;
      } else {
        if (config.hasOwnProperty('leftWidth')) {
          gameObjectType = 'nineSlice';
        } else if (config.hasOwnProperty('color') || config.hasOwnProperty('strokeColor')) {
          gameObjectType = 'roundRectangle';
        }
      }
    }
    var gameObject;
    switch (gameObjectType) {
      case 'nineSlice':
        if (!config.hasOwnProperty('stretchMode')) {
          gameObject = new StatesNineSlice(scene, config);
        } else {
          gameObject = new StatesNinePatch(scene, config);
        }
        break;
      case 'roundRectangle':
        gameObject = new StatesRoundRectangle(scene, config);
        break;
      default:
        gameObject = new StatesImage(scene, config);
        break;
    }
    DecorateGameObject(gameObject, config);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var GetValue$1e = Phaser.Utils.Objects.GetValue;
  var BuildLabelConfig = function BuildLabelConfig(scene, config, creators) {
    config = config ? DeepClone(config) : {};
    var createBackground = GetValue$1e(creators, 'background', CreateBackground$2);
    var createText = GetValue$1e(creators, 'text', CreateText);
    var createIcon = GetValue$1e(creators, 'icon', CreateImage);
    var createAction = GetValue$1e(creators, 'action', CreateImage);
    if (config.background !== null && createBackground) {
      config.background = createBackground(scene, config.background);
    } else {
      delete config.background;
    }
    if (config.text !== null && createText) {
      var wrapText = GetValue$1e(config, 'wrapText', false);
      if (wrapText) {
        if (wrapText === true) {
          wrapText = 'word';
        }
        SetValue(config, 'text.wrap.mode', wrapText);
        config.expandTextWidth = true;
      }
      config.text = createText(scene, config.text);
      if (wrapText) {
        config.text = WrapExpandText(config.text);
      }
    } else {
      delete config.text;
    }
    if (config.icon !== null && createIcon) {
      config.icon = createIcon(scene, config.icon);
    } else {
      delete config.icon;
    }
    if (config.action !== null && createAction) {
      config.action = createAction(scene, config.action);
    } else {
      delete config.action;
    }
    return config;
  };

  var SimpleLabel = /*#__PURE__*/function (_Label) {
    _inherits(SimpleLabel, _Label);
    function SimpleLabel(scene, config, creators) {
      var _this;
      _classCallCheck(this, SimpleLabel);
      config = BuildLabelConfig(scene, config, creators);
      _this = _callSuper(this, SimpleLabel, [scene, config]);
      _this.type = 'rexSimpleLabel';
      return _this;
    }
    _createClass(SimpleLabel, [{
      key: "setActiveState",
      value: function setActiveState(enable) {
        RunMethod(this.getChildren(), 'setActiveState', enable);
        return this;
      }
    }, {
      key: "setHoverState",
      value: function setHoverState(enable) {
        RunMethod(this.getChildren(), 'setHoverState', enable);
        return this;
      }
    }, {
      key: "setDisableState",
      value: function setDisableState(enable) {
        RunMethod(this.getChildren(), 'setDisableState', enable);
        return this;
      }
    }]);
    return SimpleLabel;
  }(Label);
  var RunMethod = function RunMethod(children, methodName, enable) {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var gameObject = children[i];
      if (gameObject && gameObject[methodName]) {
        gameObject[methodName](enable);
      }
    }
  };

  /*
  Elements:

  Icon  Title      ActionIcon
  Icon  Separator  ActionIcon
  Icon  Text       ActionIcon

  */

  var GetValue$1d = Phaser.Utils.Objects.GetValue;
  var LayoutMode0$2 = function LayoutMode0(config) {
    var scene = this.scene;
    var orientation = GetValue$1d(config, 'orientation', 0);
    this.setOrientation(orientation);

    // Add elements
    var icon = GetValue$1d(config, 'icon', undefined);
    var iconMask = GetValue$1d(config, 'iconMask', undefined);
    var innerBackground = GetValue$1d(config, 'innerBackground', undefined);
    var title = GetValue$1d(config, 'title', undefined);
    var separator = GetValue$1d(config, 'separator', undefined);
    var text = GetValue$1d(config, 'text', undefined);
    var action = GetValue$1d(config, 'action', undefined);
    var actionMask = GetValue$1d(config, 'actionMask', undefined);
    if (icon) {
      var padding;
      if (this.orientation === 0) {
        padding = {
          right: GetValue$1d(config, 'space.icon', 0),
          top: GetValue$1d(config, 'space.iconTop', 0),
          bottom: GetValue$1d(config, 'space.iconBottom', 0),
          left: GetValue$1d(config, 'space.iconLeft', 0)
        };
      } else {
        padding = {
          bottom: GetValue$1d(config, 'space.icon', 0),
          left: GetValue$1d(config, 'space.iconLeft', 0),
          right: GetValue$1d(config, 'space.iconRight', 0),
          top: GetValue$1d(config, 'space.iconTop', 0)
        };
      }
      var fitRatio = GetValue$1d(config, 'squareFitIcon', false) ? 1 : 0;
      this.add(icon, {
        proportion: 0,
        padding: padding,
        fitRatio: fitRatio
      });
      if (iconMask) {
        iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
      }
      if (!fitRatio) {
        var iconSize = GetValue$1d(config, 'iconSize', undefined);
        this.setIconSize(GetValue$1d(config, 'iconWidth', iconSize), GetValue$1d(config, 'iconHeight', iconSize));
      }
    }

    // InnerSizer : title, separator, text
    var innerSizer = new Sizer(scene, {
      orientation: 1
    });
    if (innerBackground) {
      innerSizer.addBackground(innerBackground);
    }
    var separatorSpace = GetValue$1d(config, 'space.separator', 0);
    if (title) {
      var align = GetValue$1d(config, 'align.title', 'left');
      var padding = {
        bottom: !separator && text ? separatorSpace : 0,
        left: GetValue$1d(config, 'space.titleLeft', 0),
        right: GetValue$1d(config, 'space.titleRight', 0)
      };
      innerSizer.add(title, {
        proportion: 0,
        align: align,
        padding: padding
      });
    }
    if (separator) {
      var padding = {
        top: title ? separatorSpace : 0,
        bottom: text ? separatorSpace : 0,
        left: GetValue$1d(config, 'space.separatorLeft', 0),
        right: GetValue$1d(config, 'space.separatorRight', 0)
      };
      innerSizer.add(separator, {
        expand: true,
        padding: padding
      }
      // Fixed height, expand width
      );
    }
    if (text) {
      var align = GetValue$1d(config, 'align.text', 'left');
      var padding = {
        left: GetValue$1d(config, 'space.textLeft', 0),
        right: GetValue$1d(config, 'space.textRight', 0)
      };
      innerSizer.add(text, {
        proportion: 0,
        align: align,
        padding: padding
      });
    }
    var padding = undefined;
    if (action) {
      padding = {
        right: GetValue$1d(config, 'space.text', 0)
      };
    }
    this.add(innerSizer, {
      proportion: 1,
      padding: padding
    });
    // InnerSizer : title, separator, text

    if (action) {
      var padding;
      if (this.orientation === 0) {
        padding = {
          top: GetValue$1d(config, 'space.actionTop', 0),
          bottom: GetValue$1d(config, 'space.actionBottom', 0),
          right: GetValue$1d(config, 'space.actionRight', 0)
        };
      } else {
        padding = {
          left: GetValue$1d(config, 'space.actionLeft', 0),
          right: GetValue$1d(config, 'space.actionRight', 0),
          bottom: GetValue$1d(config, 'space.actionBottom', 0)
        };
      }
      var fitRatio = GetValue$1d(config, 'squareFitAction', false) ? 1 : 0;
      this.add(action, {
        proportion: 0,
        padding: padding,
        fitRatio: fitRatio
      });
      if (actionMask) {
        actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
      }
      if (!fitRatio) {
        var actionSize = GetValue$1d(config, 'actionSize');
        this.setActionSize(GetValue$1d(config, 'actionWidth', actionSize), GetValue$1d(config, 'actionHeight', actionSize));
      }
    }
    this.addChildrenMap('icon', icon);
    this.addChildrenMap('iconMask', iconMask);
    this.addChildrenMap('innerSizer', innerSizer);
    this.addChildrenMap('innerBackground', innerBackground);
    this.addChildrenMap('title', title);
    this.addChildrenMap('separator', separator);
    this.addChildrenMap('text', text);
    this.addChildrenMap('action', action);
    this.addChildrenMap('actionMask', actionMask);
  };

  /*
  Elements:

  Title      Title       Title
  Separator  Separator   Separator
  Icon       Text        ActionIcon 

  */

  var GetValue$1c = Phaser.Utils.Objects.GetValue;
  var LayoutMode1$1 = function LayoutMode1(config) {
    this.setOrientation(1);
    this.setRTL(false);
    var scene = this.scene;

    // Add elements
    var title = GetValue$1c(config, 'title', undefined);
    var separator = GetValue$1c(config, 'separator', undefined);
    var innerBackground = GetValue$1c(config, 'innerBackground', undefined);
    var icon = GetValue$1c(config, 'icon', undefined);
    var iconMask = GetValue$1c(config, 'iconMask', undefined);
    var text = GetValue$1c(config, 'text', undefined);
    var action = GetValue$1c(config, 'action', undefined);
    var actionMask = GetValue$1c(config, 'actionMask', undefined);
    if (title) {
      var align = GetValue$1c(config, 'align.title', 'left');
      var padding = {
        bottom: GetValue$1c(config, 'space.title', 0),
        left: GetValue$1c(config, 'space.titleLeft', 0),
        right: GetValue$1c(config, 'space.titleRight', 0)
      };
      this.add(title, {
        proportion: 0,
        align: align,
        padding: padding
      });
    }
    if (separator) {
      var separatorSpace = GetValue$1c(config, 'space.separator', 0);
      var padding = {
        top: title ? separatorSpace : 0,
        bottom: text ? separatorSpace : 0,
        left: GetValue$1c(config, 'space.separatorLeft', 0),
        right: GetValue$1c(config, 'space.separatorRight', 0)
      };
      this.add(separator, {
        proportion: 0,
        expand: true,
        padding: padding
      }
      // Fixed height, expand width
      );
    }
    var orientation = GetValue$1c(config, 'orientation', 0);
    var innerSizer = new Sizer(scene, {
      orientation: orientation,
      rtl: GetValue$1c(config, 'rtl', false),
      space: {
        left: GetValue$1c(config, 'space.innerLeft', 0),
        right: GetValue$1c(config, 'space.innerRight', 0),
        top: GetValue$1c(config, 'space.innerTop', 0),
        bottom: GetValue$1c(config, 'space.innerBottom', 0)
      }
    });
    if (innerBackground) {
      innerSizer.addBackground(innerBackground);
    }
    this.add(innerSizer, {
      proportion: 1,
      expand: true
    });
    if (icon) {
      var padding = undefined;
      if (innerSizer.orientation === 0) {
        padding = {
          right: GetValue$1c(config, 'space.icon', 0),
          top: GetValue$1c(config, 'space.iconTop', 0),
          bottom: GetValue$1c(config, 'space.iconBottom', 0),
          left: GetValue$1c(config, 'space.iconLeft', 0)
        };
      } else {
        padding = {
          bottom: GetValue$1c(config, 'space.icon', 0),
          left: GetValue$1c(config, 'space.iconLeft', 0),
          right: GetValue$1c(config, 'space.iconRight', 0),
          top: GetValue$1c(config, 'space.iconTop', 0)
        };
      }
      var fitRatio = GetValue$1c(config, 'squareFitIcon', false) ? 1 : 0;
      innerSizer.add(icon, {
        proportion: 0,
        padding: padding,
        fitRatio: fitRatio
      });
      if (iconMask) {
        iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
      }
      if (!fitRatio) {
        var iconSize = GetValue$1c(config, 'iconSize', undefined);
        this.setIconSize(GetValue$1c(config, 'iconWidth', iconSize), GetValue$1c(config, 'iconHeight', iconSize));
      }
    }
    if (text) {
      var align = GetValue$1c(config, 'align.text', 'left');
      var textSpace = GetValue$1c(config, 'space.text', 0);
      var expandTextWidth = GetValue$1c(config, 'expandTextWidth', false);
      var expandTextHeight = GetValue$1c(config, 'expandTextHeight', false);
      var proportion, padding, expand;
      if (innerSizer.orientation === 0) {
        proportion = expandTextWidth ? 1 : 0;
        if (action) {
          padding = {
            right: textSpace
          };
        }
        expand = expandTextHeight;
      } else {
        proportion = expandTextHeight ? 1 : 0;
        if (action) {
          padding = {
            bottom: textSpace
          };
        }
        expand = expandTextWidth;
      }
      innerSizer.add(text, {
        proportion: proportion,
        expand: expand,
        align: align,
        padding: padding
      });
    }
    if (action) {
      var padding;
      if (innerSizer.orientation === 0) {
        padding = {
          top: GetValue$1c(config, 'space.actionTop', 0),
          bottom: GetValue$1c(config, 'space.actionBottom', 0),
          right: GetValue$1c(config, 'space.actionRight', 0)
        };
      } else {
        padding = {
          left: GetValue$1c(config, 'space.actionLeft', 0),
          right: GetValue$1c(config, 'space.actionRight', 0),
          bottom: GetValue$1c(config, 'space.actionBottom', 0)
        };
      }
      var fitRatio = GetValue$1c(config, 'squareFitAction', false) ? 1 : 0;
      innerSizer.add(action, {
        proportion: 0,
        padding: padding,
        fitRatio: fitRatio
      });
      if (actionMask) {
        actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
      }
      if (!fitRatio) {
        var actionSize = GetValue$1c(config, 'actionSize');
        this.setActionSize(GetValue$1c(config, 'actionWidth', actionSize), GetValue$1c(config, 'actionHeight', actionSize));
      }
    }
    this.addChildrenMap('title', title);
    this.addChildrenMap('separator', separator);
    this.addChildrenMap('innerSizer', innerSizer);
    this.addChildrenMap('innerBackground', innerBackground);
    this.addChildrenMap('icon', icon);
    this.addChildrenMap('iconMask', iconMask);
    this.addChildrenMap('text', text);
    this.addChildrenMap('action', action);
    this.addChildrenMap('actionMask', actionMask);
  };

  var GetValue$1b = Phaser.Utils.Objects.GetValue;
  var LayoutCallbacks$1 = [LayoutMode0$2, LayoutMode1$1];
  var TitleLabel = /*#__PURE__*/function (_LabelBase) {
    _inherits(TitleLabel, _LabelBase);
    function TitleLabel(scene, config) {
      var _this;
      _classCallCheck(this, TitleLabel);
      // Create sizer
      _this = _callSuper(this, TitleLabel, [scene, config]);
      _this.type = 'rexTitleLabel';

      // Add Background
      var background = GetValue$1b(config, 'background', undefined);
      if (background) {
        _this.addBackground(background);
      }
      var layoutMode = GetValue$1b(config, 'layoutMode', 0);
      var layoutCallback = LayoutCallbacks$1[layoutMode] || LayoutCallbacks$1[0];
      layoutCallback.call(_assertThisInitialized(_this), config);

      // Elements : title, separator, innerBackground,
      //            icon, iconMask, text, action, actionMask, background
      //            innerSizer
      _this.addChildrenMap('background', config.background);
      return _this;
    }

    // Access title game object
    _createClass(TitleLabel, [{
      key: "title",
      get: function get() {
        var textObject = this.childrenMap.title;
        if (!textObject) {
          return '';
        }
        return textObject.title;
      },
      set: function set(value) {
        var textObject = this.childrenMap.title;
        if (!textObject) {
          return;
        }
        textObject.setText(value);
      }
    }, {
      key: "setTitle",
      value: function setTitle(value) {
        this.title = value;
        return this;
      }
    }, {
      key: "resetDisplayContent",
      value: function resetDisplayContent(config) {
        if (config === undefined) {
          config = {};
        } else if (typeof config === 'string') {
          config = {
            text: config
          };
        }
        _get(_getPrototypeOf(TitleLabel.prototype), "resetDisplayContent", this).call(this, config);
        var textObject = this.childrenMap.title;
        if (textObject) {
          if (config.title === undefined) ; else if (config.title) {
            this.show(textObject);
            this.setTitle(config.title);
          } else {
            // false, null
            this.hide(textObject);
          }
        }
        return this;
      }
    }]);
    return TitleLabel;
  }(LabelBase);

  var GetValue$1a = Phaser.Utils.Objects.GetValue;
  var BuildTitleLabelConfig = function BuildTitleLabelConfig(scene, config, creators) {
    var createInnerBackground = GetValue$1a(creators, 'innerBackground', CreateBackground$2);
    var createSeparator = GetValue$1a(creators, 'separator', CreateBackground$2);
    var createTitle = GetValue$1a(creators, 'title', CreateText);
    var innerBackground, separator;

    // Create innerBackground before background
    if (config.innerBackground !== null && createInnerBackground) {
      innerBackground = createInnerBackground(scene, config.innerBackground);
    }

    // Create separator before background
    if (config.separator !== null && createSeparator) {
      separator = createSeparator(scene, config.separator);
    }
    config = BuildLabelConfig(scene, config, creators);
    if (innerBackground) {
      config.innerBackground = innerBackground;
    } else {
      delete config.innerBackground;
    }
    if (separator) {
      config.separator = separator;
    } else {
      delete config.separator;
    }
    if (config.title !== null && createTitle) {
      var wrapTitle = GetValue$1a(config, 'wrapTitle', false);
      if (wrapTitle) {
        if (wrapTitle === true) {
          wrapTitle = 'word';
        }
        SetValue(config, 'title.wrap.mode', wrapTitle);
        config.expandTitleWidth = true;
      }
      config.title = createTitle(scene, config.title);
      if (wrapTitle) {
        config.title = WrapExpandText(config.title);
      }
    } else {
      delete config.title;
    }

    // Keep background as the bottom element
    var background = config.background;
    if (background) {
      if (innerBackground) {
        scene.children.moveBelow(background, innerBackground); // Move child1 below child2
      } else if (separator) {
        scene.children.moveBelow(background, separator); // Move child1 below child2
      }
    }
    return config;
  };

  var GetValue$19 = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$7 = Phaser.Utils.Objects.IsPlainObject;
  var Build$1 = function Build(scene, config) {
    // Add elements
    var background = GetValue$19(config, 'background', undefined);
    var icon = GetValue$19(config, 'icon', undefined);
    var iconMask = GetValue$19(config, 'iconMask', undefined);
    var nameText = GetValue$19(config, 'nameText', undefined);
    var valueText = GetValue$19(config, 'valueText', undefined);
    var bar = GetValue$19(config, 'bar', undefined);
    var action = GetValue$19(config, 'action', undefined);
    var actionMask = GetValue$19(config, 'actionMask', undefined);
    var isLineBar = GetValue$19(config, 'barShape', 'line') === 'line';
    if (IsPlainObject$7(bar)) {
      var BarClass = isLineBar ? LineProgress : CircularProgress;
      bar = new BarClass(scene, bar);
      scene.add.existing(bar);
      // Move bar game object below nameText and valueText
      if (nameText) {
        scene.children.moveBelow(bar, nameText);
      }
      if (valueText) {
        scene.children.moveBelow(bar, valueText);
      }
    }
    var hasTextSizer = nameText || valueText || bar;
    if (background) {
      this.addBackground(background);
    }
    if (icon) {
      var padding = undefined;
      if (this.orientation === 0) {
        if (hasTextSizer || action) {
          padding = {
            right: GetValue$19(config, 'space.icon', 0),
            top: GetValue$19(config, 'space.iconTop', 0),
            bottom: GetValue$19(config, 'space.iconBottom', 0)
          };
        }
      } else {
        if (hasTextSizer || action) {
          padding = {
            bottom: GetValue$19(config, 'space.icon', 0),
            left: GetValue$19(config, 'space.iconLeft', 0),
            right: GetValue$19(config, 'space.iconRight', 0)
          };
        }
      }
      this.add(icon, {
        proportion: 0,
        padding: padding
      });
      if (iconMask) {
        iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
      }
    }
    if (hasTextSizer) {
      var textSizer = new Sizer(scene, {
        orientation: 1
      });
      var nameValueSizer;
      if (nameText || valueText) {
        nameValueSizer = new Sizer(scene, {
          orientation: 0
        });
        if (nameText) {
          // A space character to reserve text height
          if (nameText.text === '') {
            nameText.setText(' ');
          }
          nameText.setOrigin(0, nameText.originY);
          var padding = {
            left: GetValue$19(config, 'space.name', 0)
          };
          nameValueSizer.add(nameText, {
            padding: padding
          });
        }
        if (valueText) {
          // A space character to reserve text height
          if (valueText.text === '') {
            valueText.setText(' ');
          }
          valueText.setOrigin(1, valueText.originY);
          nameValueSizer.addSpace();
          var padding = {
            right: GetValue$19(config, 'space.value', 0)
          };
          nameValueSizer.add(valueText, {
            padding: padding
          });
          this.setValueTextFormatCallback(GetValue$19(config, 'valueTextFormatCallback', DefaultValueTextFormatCallback), GetValue$19(config, 'valueTextFormatCallbackScope', undefined));
        }
        textSizer.add(nameValueSizer, {
          expand: true
        });
      }
      if (bar) {
        if (isLineBar) {
          var paddingTop = nameValueSizer ? GetValue$19(config, 'space.bar') : 0;
          if (paddingTop === undefined) {
            paddingTop = GetValue$19(config, 'space.barTop', 0);
          }
          var padding = {
            top: paddingTop,
            bottom: GetValue$19(config, 'space.barBottom', 0),
            left: GetValue$19(config, 'space.barLeft', 0),
            right: GetValue$19(config, 'space.barRight', 0)
          };
          textSizer.add(bar, {
            expand: true,
            padding: padding
          });
        } else {
          var padding = {
            top: GetValue$19(config, 'space.barTop', 0),
            bottom: GetValue$19(config, 'space.barBottom', 0),
            left: GetValue$19(config, 'space.barLeft', 0),
            right: GetValue$19(config, 'space.barRight', 0)
          };
          this.addBackground(bar, padding);
        }
      }
      var padding = undefined;
      if (action) {
        padding = {
          right: GetValue$19(config, 'space.text', 0)
        };
      }
      var textAlign = GetValue$19(config, 'align.text', 'bottom');
      this.add(textSizer, {
        proportion: 1,
        align: textAlign,
        padding: padding
      });
    }
    if (action) {
      var padding;
      if (this.orientation === 0) {
        padding = {
          top: GetValue$19(config, 'space.actionTop', 0),
          bottom: GetValue$19(config, 'space.actionBottom', 0)
        };
      } else {
        padding = {
          left: GetValue$19(config, 'space.actionLeft', 0),
          right: GetValue$19(config, 'space.actionRight', 0)
        };
      }
      this.add(action, {
        proportion: 0,
        padding: padding
      });
      if (actionMask) {
        actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
      }
    }
    this.addChildrenMap('background', background);
    this.addChildrenMap('icon', icon);
    this.addChildrenMap('iconMask', iconMask);
    this.addChildrenMap('name', nameText);
    this.addChildrenMap('value', valueText);
    this.addChildrenMap('bar', bar);
    this.addChildrenMap('action', action);
    this.addChildrenMap('actionMask', actionMask);
  };
  var DefaultValueTextFormatCallback = function DefaultValueTextFormatCallback(value, min, max) {
    return value.toString();
  };

  var Clamp$5 = Phaser.Math.Clamp;
  var SetValueMethods = {
    setValueTextFormatCallback: function setValueTextFormatCallback(callback, scope) {
      this.valueTextFormatCallback = callback;
      this.valueTextFormatCallbackScope = scope;
      return this;
    },
    getFormatValueText: function getFormatValueText(value, min, max) {
      if (value === undefined) {
        value = this.value;
      }
      if (min === undefined) {
        min = this.minValue;
      }
      if (max === undefined) {
        max = this.maxValue;
      }
      var text;
      if (this.valueTextFormatCallbackScope) {
        text = this.valueTextFormatCallback(value, min, max);
      } else {
        text = this.valueTextFormatCallback.call(this.valueTextFormatCallbackScope, value, min, max);
      }
      return text;
    },
    updateValueText: function updateValueText(value, min, max) {
      var textObject = this.childrenMap.value;
      if (textObject && this.valueTextFormatCallback) {
        textObject.setText(this.getFormatValueText(value, min, max));
        if (textObject.layout) {
          textObject.layout();
        }
      }
      return this;
    },
    setValue: function setValue(value, min, max) {
      value = Clamp$5(value, min, max);
      this.value = value;
      this.minValue = min;
      this.maxValue = max;
      this.updateValueText(value, min, max);
      this.setBarValue(value, min, max);
      return this;
    },
    setEaseValueDuration: function setEaseValueDuration(duration) {
      this.easeValueDuration = duration;
      return this;
    },
    easeValueTo: function easeValueTo(value, min, max) {
      this.minValue = min;
      this.maxValue = max;
      if (this.easeValueTask === undefined) {
        this.easeValueTask = new EaseValueTask(this);
        this.easeValueTask.on('update', function () {
          this.setValue(this.value, this.minValue, this.maxValue);
        }, this);
      }
      this.easeValueTask.restart({
        key: 'value',
        to: value,
        duration: this.easeValueDuration
      });
      return this;
    }
  };

  var NameValueLabel = /*#__PURE__*/function (_Sizer) {
    _inherits(NameValueLabel, _Sizer);
    function NameValueLabel(scene, config) {
      var _this;
      _classCallCheck(this, NameValueLabel);
      // Create sizer
      _this = _callSuper(this, NameValueLabel, [scene, config]);
      _this.type = 'rexNameValueLabel';
      Build$1.call(_assertThisInitialized(_this), scene, config);
      _this.setEaseValueDuration(1000);
      return _this;
    }

    // Access nameText game object
    _createClass(NameValueLabel, [{
      key: "nameText",
      get: function get() {
        var textObject = this.childrenMap.name;
        if (textObject === undefined) {
          return '';
        }
        return textObject.text;
      },
      set: function set(value) {
        var textObject = this.childrenMap.name;
        if (textObject === undefined) {
          return;
        }
        textObject.setText(value);
      }
    }, {
      key: "setNameText",
      value: function setNameText(value) {
        this.nameText = value;
        return this;
      }

      // Access valueText game object
    }, {
      key: "valueText",
      get: function get() {
        var textObject = this.childrenMap.value;
        if (textObject === undefined) {
          return '';
        }
        return textObject.text;
      },
      set: function set(value) {
        var textObject = this.childrenMap.value;
        if (textObject === undefined) {
          return;
        }
        textObject.setText(value);
      }
    }, {
      key: "setValueText",
      value: function setValueText(value) {
        this.valueText = value;
        return this;
      }

      // Accrss bar game object
    }, {
      key: "barValue",
      get: function get() {
        var bar = this.childrenMap.bar;
        if (bar === undefined) {
          return;
        }
        return bar.value;
      },
      set: function set(value) {
        var bar = this.childrenMap.bar;
        if (bar === undefined) {
          return;
        }
        bar.setValue(value);
      }
    }, {
      key: "setBarValue",
      value: function setBarValue(value, min, max) {
        var bar = this.childrenMap.bar;
        if (bar === undefined) {
          return this;
        }
        bar.setValue(value, min, max);
        return this;
      }
    }, {
      key: "easeBarValueTo",
      value: function easeBarValueTo(value, min, max) {
        var bar = this.childrenMap.bar;
        if (bar === undefined) {
          return this;
        }
        bar.easeValueTo(value, min, max);
        return this;
      }

      // Access icon game object
    }, {
      key: "setTexture",
      value: function setTexture(key, frame) {
        var imageObject = this.childrenMap.icon;
        if (imageObject === undefined) {
          return;
        }
        imageObject.setTexture(key, frame);
        return this;
      }
    }, {
      key: "texture",
      get: function get() {
        var imageObject = this.childrenMap.icon;
        if (imageObject === undefined) {
          return undefined;
        }
        return imageObject.texture;
      }
    }, {
      key: "frame",
      get: function get() {
        var imageObject = this.childrenMap.icon;
        if (imageObject === undefined) {
          return undefined;
        }
        return imageObject.frame;
      }
    }, {
      key: "postLayout",
      value: function postLayout(parent, newWidth, newHeight) {
        // Pin icon-mask to icon game object
        var iconMask = this.childrenMap.iconMask;
        if (iconMask) {
          iconMask.setPosition();
          this.resetChildPositionState(iconMask);
        }
        // Pin action-mask to action game object
        var actionMask = this.childrenMap.actionMask;
        if (actionMask) {
          actionMask.setPosition();
          this.resetChildPositionState(actionMask);
        }
        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        _get(_getPrototypeOf(NameValueLabel.prototype), "resize", this).call(this, width, height);
        // Resize icon-mask to icon game object
        var iconMask = this.childrenMap.iconMask;
        if (iconMask) {
          iconMask.resize();
        }
        // Resize action-mask to icon game object
        var actionMask = this.childrenMap.actionMask;
        if (actionMask) {
          actionMask.resize();
        }
        return this;
      }
    }]);
    return NameValueLabel;
  }(Sizer);
  Object.assign(NameValueLabel.prototype, SetValueMethods);

  var LevelCounter = /*#__PURE__*/function (_EventEmitter) {
    _inherits(LevelCounter, _EventEmitter);
    function LevelCounter(config) {
      var _this;
      _classCallCheck(this, LevelCounter);
      _this = _callSuper(this, LevelCounter);
      _this.setTable(GetValue$38(config, 'table'));
      _this.setMaxLevel(GetValue$38(config, 'maxLevel'));
      var exp = GetValue$38(config, 'exp', 0);
      var level = GetValue$38(config, 'level', undefined);
      if (level !== undefined && !_this.checkLevel(level, exp)) {
        console.error("Level ".concat(level, " and Exp ").concat(exp, " are mismatch"));
        level = undefined;
      }
      _this.resetExp(exp, level);
      return _this;
    }

    // Configuration
    _createClass(LevelCounter, [{
      key: "setTable",
      value: function setTable(table) {
        this.levelTable = table;
        this.isLevelMapFunction = IsFunction(table);
        return this;
      }
    }, {
      key: "setMaxLevel",
      value: function setMaxLevel(maxLevel) {
        if (maxLevel === undefined) {
          if (Array.isArray(this.levelTable)) {
            maxLevel = this.levelTable.length - 1;
          } else {
            maxLevel = -1;
          }
        }
        var maxExp;
        if (maxLevel !== -1) {
          maxExp = this.getExp(maxLevel);
        } else {
          maxExp = -1;
        }
        this.hasMaxLevel = maxLevel !== -1;
        this.maxLevel = maxLevel;
        this.maxExp = maxExp;
        return this;
      }
    }, {
      key: "resetExp",
      value: function resetExp(exp, level) {
        if (this.hasMaxLevel && exp > this.maxExp) {
          exp = this.maxExp;
        }
        if (level === undefined) {
          level = this.getLevel(exp);
        }
        this._exp = exp;
        this._level = level;
        this._requiredExp = this.getRequiredExpToNextLevel(level, exp);
        // Won't fire `levelup` event
        return this;
      }
    }, {
      key: "exp",
      get: function get() {
        return this._exp;
      },
      set: function set(exp) {
        if (this.hasMaxLevel && exp > this.maxExp) {
          exp = this.maxExp;
        }
        if (exp < this._exp) {
          this.resetExp(exp);
          return;
        }
        if (exp === this._exp) {
          return;
        }
        var level = this.getLevel(exp, this._level);

        // Emit levelup event
        var prevLevel = this._level;
        var fromExp = this._exp,
          toExp;
        while (1) {
          var levelStartExp = this.getExp(prevLevel);
          var levelEndExp = this.getExp(prevLevel + 1);
          toExp = Math.min(levelEndExp, exp);
          this.emit('levelup', prevLevel, fromExp, toExp, levelStartExp, levelEndExp);
          if (prevLevel === level && toExp === exp) {
            break;
          }
          prevLevel++;
          fromExp = levelEndExp;
        }
        this.resetExp(exp, level);
      }
    }, {
      key: "level",
      get: function get() {
        return this._level;
      },
      set: function set(value) {
        if (this.hasMaxLevel && value > this.maxLevel) {
          this.exp = this.maxExp;
        } else {
          this.exp = this.getExp(value);
        }
      }
    }, {
      key: "requiredExp",
      get: function get() {
        return this._requiredExp;
      }
    }, {
      key: "getExp",
      value: function getExp(level) {
        if (level === undefined) {
          return this._exp;
        }
        if (this.isLevelMapFunction) {
          return this.levelTable(level);
        } else {
          if (this.hasMaxLevel && level > this.maxLevel) {
            level = this.maxLevel;
          }
          return this.levelTable[level];
        }
      }
    }, {
      key: "getLevel",
      value: function getLevel(exp, level) {
        if (exp === undefined) {
          return this._level;
        }
        if (level === undefined) {
          level = 0;
        }
        while (1) {
          var nextLevelExp = this.getExp(level + 1);
          if (nextLevelExp > exp) {
            break;
          }
          level++;
          if (this.hasMaxLevel && nextLevelExp === this.maxExp) {
            break;
          }
        }
        return level;
      }
    }, {
      key: "getRequiredExpToNextLevel",
      value: function getRequiredExpToNextLevel(level, exp) {
        if (level === undefined) {
          level = this.level;
        }
        if (exp === undefined) {
          exp = this.exp;
        }
        return this.getExp(level + 1) - exp;
      }
    }, {
      key: "checkLevel",
      value: function checkLevel(level, exp) {
        return exp >= this.getExp(level) && exp < this.getExp(level + 1);
      }
    }, {
      key: "gainExp",
      value: function gainExp(incExp, callback, scope) {
        if (callback) {
          this.on('levelup', callback, scope);
        }
        this.exp += incExp;
        if (callback) {
          this.off('levelup', callback, scope);
        }
        return this;
      }
    }, {
      key: "setExp",
      value: function setExp(exp, callback, scope) {
        if (callback) {
          this.on('levelup', callback, scope);
        }
        this.exp = exp;
        if (callback) {
          this.off('levelup', callback, scope);
        }
        return this;
      }
    }, {
      key: "setLevel",
      value: function setLevel(level, callback, scope) {
        if (callback) {
          this.on('levelup', callback, scope);
        }
        this.level = level;
        if (callback) {
          this.off('levelup', callback, scope);
        }
        return this;
      }
    }]);
    return LevelCounter;
  }(EventEmitter$2);

  var RunCommands = function RunCommands(queue, scope, config) {
    var reverse = GetValue$38(config, 'reverse', false);
    var retVal;
    if (IsArray(queue[0])) {
      if (!reverse) {
        for (var i = 0, len = queue.length; i < len; i++) {
          retVal = RunCommands(queue[i], scope, config);
        }
      } else {
        for (var len = queue.length, i = len - 1; i >= 0; i--) {
          retVal = RunCommands(queue[i], scope, config);
        }
      }
    } else {
      retVal = RunCommand(queue, scope, config);
    }
    return retVal;
  };
  var RunCommand = function RunCommand(cmd, scope, config) {
    var argsConvert = GetValue$38(config, 'argsConvert', undefined);
    var argsConvertScope = GetValue$38(config, 'argsConvertScope', undefined);
    var fnName = cmd[0];
    ARGS = Copy(ARGS, cmd, 1);
    if (argsConvert) {
      // convert string to floating number, boolean, null, or string        
      if (argsConvert === true) {
        argsConvert = TypeConvert;
        argsConvertScope = undefined;
      }
      for (var i = 0, len = ARGS.length; i < len; i++) {
        if (argsConvertScope) {
          ARGS[i] = argsConvert.call(argsConvertScope, ARGS[i], cmd);
        } else {
          ARGS[i] = argsConvert(ARGS[i], cmd);
        }
      }
    }
    var fn;
    if (typeof fnName === 'string') {
      fn = scope[fnName];
      if (fn == null) {
        fn = GetValue$38(scope, fnName, null);
      }
    } else {
      fn = fnName;
    }
    var retValue = fn.apply(scope, ARGS);
    return retValue;
  };
  var ARGS = []; // reuse this array

  var GetValue$18 = Phaser.Utils.Objects.GetValue;
  var Player = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Player, _ComponentBase);
    function Player(parent, config) {
      var _this;
      _classCallCheck(this, Player);
      _this = _callSuper(this, Player, [parent, config]);
      var clock = GetValue$18(config, 'clock', undefined);
      if (!clock) {
        clock = new Clock(parent);
      }
      _this.clock = clock;
      _this.clock.on('update', _this.update, _assertThisInitialized(_this));
      _this.commands = [];
      _this.resetFromJSON(config); // this function had been called in super(config)
      return _this;
    }
    _createClass(Player, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.clock.resetFromJSON(GetValue$18(o, 'clock', undefined));
        this.state = GetValue$18(o, 'state', 0); // 0=idle, 1=run, 2=completed
        this.commands = GetValue$18(o, 'commands', []); // [[time, cmds], [time, cmds], ...]
        this.scope = GetValue$18(o, 'scope', undefined);
        this.setTimeUnit(GetValue$18(o, 'timeUnit', 0));
        this.setDtMode(GetValue$18(o, 'dtMode', 0));
        this.index = GetValue$18(o, 'index', 0);
        this.nextTime = GetValue$18(o, 'nextTime', 0);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          clock: this.clock.toJSON(),
          state: this.state,
          commands: this.commands,
          scope: this.scope,
          timeUnit: this.timeUnit,
          dtMode: this.dtMode,
          index: this.index,
          nextTime: this.nextTime
        };
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        this.clock.shutdown(fromScene);
        this.commands = undefined;
        _get(_getPrototypeOf(Player.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "load",
      value: function load(commands, scope, config) {
        this.stop();
        var timeUnit = GetValue$18(config, 'timeUnit', undefined);
        if (timeUnit !== undefined) {
          this.setTimeUnit(timeUnit);
        }
        var dtMode = GetValue$18(config, 'dtMode', undefined);
        if (dtMode !== undefined) {
          this.setDtMode(dtMode);
        }
        commands = commands.filter(function (item) {
          var dt = item[0];
          return !isNaN(dt);
        }).map(function (item) {
          var dt = item[0];
          if (typeof dt === 'string') {
            item[0] = parseFloat(item[0]);
          }
          return item;
        });
        if (this.dtMode === 0) {
          commands.sort(function (itemA, itemB) {
            var dtA = itemA[0],
              dtB = itemB[0];
            return dtA > dtB ? 1 : dtA < dtB ? -1 : 0;
          });
        }
        Copy(this.commands, commands);
        this.scope = scope;
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.commands.length = 0;
        return this;
      }
    }, {
      key: "append",
      value: function append(time, fn) {
        var command;
        if (Array.isArray(fn)) {
          command = fn;
        } else {
          for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            params[_key - 2] = arguments[_key];
          }
          command = [fn].concat(params);
        }
        this.commands.push([time, command]);
        return this;
      }
    }, {
      key: "start",
      value: function start(startAt) {
        if (startAt === undefined) {
          startAt = 0;
        }
        this.stop();
        this.index = 0;
        this.state = 1;
        this.nextTime = this.getNextDt(0);
        this.clock.start(startAt);
        this.update(startAt);
        this.emit('start', this.parent, this);
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        this.clock.pause();
        this.emit('pause', this.parent, this);
        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        this.clock.resume();
        this.emit('resume', this.parent, this);
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.clock.stop();
        this.state = 0;
        this.emit('stop', this.parent, this);
        return this;
      }
    }, {
      key: "seek",
      value: function seek(time) {
        this.clock.seek(time);
        return this;
      }
    }, {
      key: "seekToNext",
      value: function seekToNext() {
        this.seek(this.nextTime);
        return this;
      }
    }, {
      key: "isPlaying",
      get: function get() {
        return this.clock.isRunning;
      }
    }, {
      key: "completed",
      get: function get() {
        return this.state === 2;
      }
    }, {
      key: "timeScale",
      get: function get() {
        return this.clock.timeScale;
      },
      set: function set(timeScale) {
        this.clock.timeScale = timeScale;
      }
    }, {
      key: "setTimeScale",
      value: function setTimeScale(timeScale) {
        this.timeScale = timeScale;
        return this;
      }
    }, {
      key: "now",
      get: function get() {
        return this.clock.now;
      }
    }, {
      key: "update",
      value: function update(now) {
        if (this.nextTime > now) {
          return this;
        }
        var commands = this.commands;
        while (1) {
          // Execute a command
          var item = commands[this.index];
          var command = item[1];
          if (!IsArray(command)) {
            // [dt, fnName, param0, param1, ...]
            command = Copy(CMD, item, 1);
          }
          RunCommands(command, this.scope);
          this.emit('runcommand', command, this.scope);
          // Execute a command

          if (this.index >= commands.length - 1) {
            this.nextTime = 0;
            this.complete();
            return this;
          } else {
            // Get next time
            this.index++; // Point to next command
            this.nextTime = this.getNextDt(this.nextTime);
            if (this.nextTime > now) {
              return this;
            }
            // Get next time
          }
        }
      }
    }, {
      key: "complete",
      value: function complete() {
        this.clock.stop();
        this.state = 2;
        this.emit('complete', this.parent, this);
      }
    }, {
      key: "getNextDt",
      value: function getNextDt(currentDt) {
        var time = this.commands[this.index][0];
        if (this.timeUnit === 1) {
          // Second mode
          time = time * 1000;
        }
        if (this.dtMode === 1) {
          time += currentDt;
        }
        return time;
      }
    }, {
      key: "setDtMode",
      value: function setDtMode(dtMode) {
        if (typeof dtMode === 'string') {
          dtMode = DTMODE[dtMode];
        }
        this.dtMode = dtMode;
        return this;
      }
    }, {
      key: "setTimeUnit",
      value: function setTimeUnit(timeUnit) {
        if (typeof timeUnit === 'string') {
          timeUnit = TIMEUNITMODE[timeUnit];
        }
        this.timeUnit = timeUnit;
        return this;
      }
    }]);
    return Player;
  }(ComponentBase);
  var CMD = []; // reuse this array

  var TIMEUNITMODE = {
    ms: 0,
    s: 1,
    sec: 1
  };
  var DTMODE = {
    abs: 0,
    absolute: 0,
    inc: 1,
    increment: 1
  };

  var OnLevelUp = function OnLevelUp(level, fromExp, toExp, levelStartExp, levelEndExp) {
    var time = (toExp - fromExp) / (levelEndExp - levelStartExp) * this.totalEaseDuration;
    var levelEnd = toExp === levelEndExp ? level + 1 : level;
    this.player
    //.append(0, this.setValue, fromExp, levelStartExp, levelEndExp)
    .append(0, this.setEaseValueDuration, time).append(0, this.easeValueTo, toExp, levelStartExp, levelEndExp).append(0, this.emit, 'levelup.start', level, fromExp, toExp, this).append(time, NOOP).append(0, this.emit, 'levelup.end', levelEnd, fromExp, toExp, this);
    if (!this.player.isPlaying) {
      this.player.start();
    }
  };

  var ExpMethods = {
    setExpTable: function setExpTable(table) {
      this.levelCounter.setTable(table);
      return this;
    },
    resetExp: function resetExp(exp) {
      this.levelCounter.resetExp(exp);
      this.setValue(this.exp, this.getExp(this.level), this.getExp(this.level + 1));
      return this;
    },
    getExp: function getExp(level) {
      return this.levelCounter.getExp(level);
    },
    getLevel: function getLevel(exp, level) {
      return this.levelCounter.getLevel(exp, level);
    },
    getRequiredExpToNextLevel: function getRequiredExpToNextLevel(level, exp) {
      return this.levelCounter.getRequiredExpToNextLevel(level, exp);
    },
    gainExp: function gainExp(exp) {
      this.levelCounter.gainExp(exp);
      return this;
    },
    setExp: function setExp(exp) {
      this.levelCounter.setExp(exp);
      return this;
    },
    setLevel: function setLevel(level) {
      this.levelCounter.setLevel(level);
      return this;
    }
  };

  var GetValue$17 = Phaser.Utils.Objects.GetValue;
  var ExpBar = /*#__PURE__*/function (_NameValueLabel) {
    _inherits(ExpBar, _NameValueLabel);
    function ExpBar(scene, config) {
      var _this;
      _classCallCheck(this, ExpBar);
      _this = _callSuper(this, ExpBar, [scene, config]);
      _this.type = 'rexExpBar';
      _this.setTotalEaseDuration(GetValue$17(config, 'easeDuration', 1000));
      _this.levelCounter = new LevelCounter(GetValue$17(config, 'levelCounter'));
      _this.player = new Player(_assertThisInitialized(_this), {
        scope: _assertThisInitialized(_this),
        dtMode: 1
      });
      _this.levelCounter.on('levelup', OnLevelUp, _assertThisInitialized(_this));
      _this.player.on('complete', function () {
        this.player.clear();
        this.emit('levelup.complete', this.level, this);
      }, _assertThisInitialized(_this));
      _this.setValue(_this.exp, _this.getExp(_this.level), _this.getExp(_this.level + 1));
      return _this;
    }
    _createClass(ExpBar, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.levelCounter.destroy();
        this.levelCounter = undefined;
        this.player.destroy();
        this.player = undefined;
        _get(_getPrototypeOf(ExpBar.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "exp",
      get: function get() {
        return this.levelCounter.exp;
      },
      set: function set(value) {
        this.levelCounter.exp = value;
      }
    }, {
      key: "level",
      get: function get() {
        return this.levelCounter.level;
      },
      set: function set(value) {
        this.levelCounter.level = value;
      }
    }, {
      key: "requiredExp",
      get: function get() {
        return this.levelCounter.requiredExp;
      }
    }, {
      key: "setTotalEaseDuration",
      value: function setTotalEaseDuration(duration) {
        this.totalEaseDuration = duration;
        return this;
      }
    }]);
    return ExpBar;
  }(NameValueLabel);
  Object.assign(ExpBar.prototype, ExpMethods);

  var SizerAdd$3 = Sizer.prototype.add;
  var SizerAddSpace = Sizer.prototype.addSpace;
  var Add$2 = function Add(gameObject) {
    var isNormalGameObject = !gameObject.isRexSpace;
    var proportion = !isNormalGameObject || this.buttonsExpand ? 1 : 0;
    if (this.sizerChildren.length === 0) {
      // First element
      if (isNormalGameObject) {
        // Add space at head
        var hasHeadSpace = !this.buttonsExpand && (this.buttonsAlign === 'right' || this.buttonsAlign === 'center' || this.buttonsAlign === 'bottom');
        if (hasHeadSpace) {
          SizerAddSpace.call(this);
        }
        SizerAdd$3.call(this, gameObject, {
          proportion: proportion,
          expand: true
        });

        // Add space at tail
        var hasTailSpace = !this.buttonsExpand && this.buttonsAlign === 'center';
        if (hasTailSpace) {
          SizerAddSpace.call(this);
        }
        this.hasTailSpace = hasTailSpace;
      } else {
        // A space
        SizerAdd$3.call(this, gameObject, {
          proportion: proportion,
          expand: true
        });
        this.hasTailSpace = false;
      }
    } else {
      // Others
      if (this.hasTailSpace) {
        var lastIndex = this.sizerChildren.length - 1;
        SizerAdd$3.call(this, gameObject, {
          index: lastIndex,
          proportion: proportion,
          expand: true
        });
      } else {
        SizerAdd$3.call(this, gameObject, {
          proportion: proportion,
          expand: true
        });
      }
    }

    // Space or other game object as button
    if (isNormalGameObject) {
      this.buttonGroup.add(gameObject);
    }
    return this;
  };
  var AddChildMethods$3 = {
    addButton: function addButton(gameObject) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$2.call(this, gameObjects[i]);
        }
      } else {
        Add$2.call(this, gameObject);
      }
      return this;
    },
    addButtons: function addButtons(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Add$2.call(this, gameObjects[i]);
      }
      return this;
    }
  };

  var SizerRmove$2 = Sizer.prototype.remove;
  var SizerClear$2 = Sizer.prototype.clear;
  var Remove$3 = function Remove(gameObject, destroyChild) {
    if (this.getParentSizer(gameObject) !== this) {
      return this;
    }
    this.buttonGroup.remove(gameObject);
    SizerRmove$2.call(this, gameObject, destroyChild);
    return this;
  };
  var RemoveChildMethods$2 = {
    remove: function remove(gameObject, destroyChild) {
      // Remove gameObject no matter it is a button or not
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Remove$3.call(this, gameObjects[i], destroyChild);
        }
      } else {
        Remove$3.call(this, gameObject, destroyChild);
      }
      return this;
    },
    clear: function clear(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      buttons.length = 0;
      SizerClear$2.call(this, destroyChild);
      return this;
    },
    removeButton: function removeButton(gameObject, destroyChild) {
      var gameObject = this.getButton(gameObject);
      // Don't remove this gameObject, it is not a button
      if (!gameObject) {
        return this;
      }
      this.remove(gameObject, destroyChild);
      return this;
    },
    clearButtons: function clearButtons(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      for (var i = buttons.length - 1; i >= 0; i--) {
        Remove$3.call(this, buttons[i], destroyChild);
      }
      return this;
    }
  };

  var OnButtonStateChange = function OnButtonStateChange(button, value, previousValue) {
    if (!button) {
      return;
    }
    var callback = this.setValueCallback;
    var scope = this.setValueCallbackScope;
    if (callback) {
      if (scope) {
        callback.call(scope, button, value, previousValue);
      } else {
        callback(button, value, previousValue);
      }
    }
    this.fireEvent('button.statechange', button, value, previousValue);
  };

  var InjectSelectedProperty = function InjectSelectedProperty(gameObject) {
    var self = this;
    gameObject._selected = undefined;
    Object.defineProperty(gameObject, 'selected', {
      get: function get() {
        return gameObject._selected;
      },
      set: function set(newValue) {
        if (gameObject._selected === newValue) {
          return;
        }
        var previousValue = gameObject._selected;
        gameObject._selected = newValue;
        OnButtonStateChange.call(self, gameObject, newValue, previousValue);
      },
      enumerable: true,
      configurable: true
    });
    gameObject.selected = false;
  };

  var AddMethods = {
    add: function add(gameObject) {
      this.buttons.push(gameObject);

      //Default: Fire 'click' event when touch released after pressed.
      if (!gameObject._click) {
        gameObject._click = new Button(gameObject, this.clickConfig);
        gameObject._click.on('click', function (buttonBehavior, gameObject, pointer, event) {
          this.fireEvent('button.click', gameObject, pointer, event);
        }, this).on('enable', function (buttonBehavior, gameObject) {
          this.fireEvent('button.enable', gameObject);
        }, this).on('disable', function (buttonBehavior, gameObject) {
          this.fireEvent('button.disable', gameObject);
        }, this).on('over', function (buttonBehavior, gameObject, pointer, event) {
          this.fireEvent('button.over', gameObject, pointer, event);
        }, this).on('out', function (buttonBehavior, gameObject, pointer, event) {
          this.fireEvent('button.out', gameObject, pointer, event);
        }, this).on('down', function (buttonBehavior, gameObject, pointer, event) {
          this.fireEvent('button.down', gameObject, pointer, event);
        }, this).on('up', function (buttonBehavior, gameObject, pointer, event) {
          this.fireEvent('button.up', gameObject, pointer, event);
        }, this);
      }
      if (this.buttonsType) {
        if (gameObject.name === undefined) {
          console.error("".concat(this.parent.constructor.name, ": Option button miss value"));
        }
        InjectSelectedProperty.call(this, gameObject);
      }
      return this;
    },
    addMultiple: function addMultiple(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        this.add(gameObjects[i]);
      }
      return this;
    }
  };

  var RemoveItem = Phaser.Utils.Array.Remove;
  var RemoveMethods = {
    remove: function remove(gameObject) {
      if (this.buttonsType) {
        delete gameObject.selected;
      }
      RemoveItem(this.buttons, gameObject);
      return this;
    },
    clear: function clear() {
      if (this.buttonsType) {
        var buttons = this.buttons;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          delete buttons[i].selected;
        }
      }
      this.buttons.length = 0;
      return this;
    }
  };

  var FireEvent = function FireEvent(eventName, button) {
    if (!this.buttons) {
      // ButtonGroup has been destroyed
      return;
    }
    var index;
    if (typeof button === 'number') {
      index = button;
      button = this.buttons[index];
      if (!button) {
        return;
      }
    } else {
      index = this.buttons.indexOf(button);
      if (index === -1) {
        return;
      }
    }

    // Buttons is a child. Fire internal events.
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    if (this.eventEmitter !== this.parent) {
      var _this$parent;
      (_this$parent = this.parent).emit.apply(_this$parent, [eventName, button, index].concat(args));
    }
    if (this.groupName !== undefined) {
      var _this$eventEmitter;
      (_this$eventEmitter = this.eventEmitter).emit.apply(_this$eventEmitter, [eventName, button, this.groupName, index].concat(args));
    } else {
      var _this$eventEmitter2;
      (_this$eventEmitter2 = this.eventEmitter).emit.apply(_this$eventEmitter2, [eventName, button, index].concat(args));
    }
  };

  var GetValue$16 = Phaser.Utils.Objects.GetValue;
  var ButtonsTypeMethods = {
    setButtonsType: function setButtonsType(config) {
      if (config === undefined) {
        config = {};
      }
      var buttonsType = GetValue$16(config, 'buttonsType', config.type);
      this.buttonsType = buttonsType;
      if (!this.buttonsType) {
        return this;
      }

      // Assign this.setValueCallback, this.setValueCallbackScope
      var setValueCallback, setValueCallbackScope;
      setValueCallback = GetValue$16(config, 'setValueCallback', undefined);
      setValueCallbackScope = GetValue$16(config, 'setValueCallbackScope', undefined);
      if (setValueCallback === undefined) {
        setValueCallback = GetValue$16(config, 'setButtonStateCallback', undefined);
        setValueCallbackScope = GetValue$16(config, 'setButtonStateCallbackScope', undefined);
      }
      this.setValueCallback = setValueCallback;
      this.setValueCallbackScope = setValueCallbackScope;
      switch (buttonsType) {
        case 'radio':
          this.setRadioType();
          break;
        case 'checkboxes':
          this.setCheckboxesType();
          break;
      }
      return this;
    },
    setRadioType: function setRadioType() {
      var parent = this.parent,
        buttons = this.buttons;
      parent._value = undefined;
      var selectedIndex = undefined;
      Object.defineProperty(parent, 'value', {
        get: function get() {
          return parent._value;
        },
        set: function set(newValue) {
          if (parent._value === newValue) {
            return;
          }
          parent._value = newValue;
          for (var i = 0, cnt = buttons.length; i < cnt; i++) {
            var button = buttons[i];
            if (button.rexSizer.hidden) {
              continue;
            }
            if (selectedIndex === undefined) {
              if (button.name === newValue) {
                button.selected = true;
              } else {
                button.selected = false;
              }
            } else {
              if (selectedIndex === i) {
                button.selected = true;
              } else {
                button.selected = false;
              }
            }
          }
        },
        enumerable: true,
        configurable: true
      });
      parent.on('button.click', function (button) {
        selectedIndex = this.buttons.indexOf(button);
        parent.value = button.name;
        selectedIndex = undefined;
      }, this);
      return this;
    },
    setCheckboxesType: function setCheckboxesType() {
      var parent = this.parent;
      parent.on('button.click', function (button) {
        button.selected = !button.selected;
      });
      return this;
    },
    // Common
    clearAllButtonsState: function clearAllButtonsState() {
      var buttons = this.buttons;
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        var button = buttons[i];
        button.selected = false;
      }
      return this;
    },
    getAllButtonsState: function getAllButtonsState() {
      var states = {};
      var buttons = this.buttons;
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        var button = buttons[i];
        if (button.rexSizer.hidden) {
          continue;
        }
        states[button.name] = button.selected;
      }
      return states;
    },
    // For radio
    setSelectedButtonName: function setSelectedButtonName(name) {
      this.parent.value = name;
      return this;
    },
    getSelectedButtonName: function getSelectedButtonName() {
      return this.parent.value;
    },
    // For checkboxes
    setButtonState: function setButtonState(name, state) {
      if (state === undefined) {
        state = true;
      }
      var buttons = this.buttons;
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        var button = buttons[i];
        if (button.rexSizer.hidden) {
          continue;
        }
        if (button.name === name) {
          button.selected = state;
          break;
        }
      }
      return this;
    },
    getButtonState: function getButtonState(name) {
      var buttons = this.buttons;
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        var button = buttons[i];
        if (button.rexSizer.hidden) {
          continue;
        }
        if (button.name === name) {
          return button.selected;
        }
      }
      return undefined;
    }
  };

  var GetGameObjectByName = function GetGameObjectByName(children, name) {
    if (!children) {
      return null;
    } else if (IsArray(children)) {
      var child;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = TestName(children[i], name);
        if (child) {
          return child;
        }
      }
    } else {
      // Is plain object
      var child;
      for (var key in children) {
        child = TestName(children[key], name);
        if (child) {
          return child;
        }
      }
    }
  };
  var TestName = function TestName(gameObject, name) {
    if (!gameObject) {
      return null;
    } else if (gameObject.hasOwnProperty('name')) {
      return gameObject.name === name ? gameObject : null;
    } else {
      // Array, or plain object
      return GetElementByName(gameObject, name);
    }
  };

  var ButtonMethods$2 = {
    getButton: function getButton(index) {
      // buttonGroup and button-sizer have *buttons* member both
      var buttons = this.buttons,
        button;
      var indexType = _typeof(index);
      switch (indexType) {
        case 'number':
          button = buttons[index];
          break;
        case 'string':
          button = GetGameObjectByName(buttons, index);
          break;
        default:
          button = index;
          if (buttons.indexOf(button) === -1) {
            button = undefined;
          }
          break;
      }
      return button;
    },
    getButtons: function getButtons() {
      return this.buttons;
    },
    hasAnyButton: function hasAnyButton() {
      return this.buttons.length > 0;
    },
    setButtonEnable: function setButtonEnable(index, enabled) {
      // buttonGroup and button-sizer have *buttons* member both
      var buttons = this.buttons;
      if (index === undefined || typeof index === 'boolean') {
        enabled = index;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          buttons[i]._click.setEnable(enabled);
        }
      } else {
        this.getButton(index)._click.setEnable(enabled);
      }
      return this;
    },
    toggleButtonEnable: function toggleButtonEnable(index) {
      // buttonGroup and button-sizer have *buttons* member both
      var buttons = this.buttons;
      if (index === undefined || typeof index === 'boolean') {
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          buttons[i]._click.toggleEnable();
        }
      } else {
        this.getButton(index)._click.toggleEnable();
      }
      return this;
    },
    getButtonEnable: function getButtonEnable(index) {
      if (index === undefined) {
        index = 0;
      }
      return this.getButton(index)._click.enable;
    },
    emitButtonClick: function emitButtonClick(index) {
      // index or button game object
      // this: buttonGroup or button-sizer
      var buttonGroup = this.buttonGroup ? this.buttonGroup : this;
      buttonGroup.fireEvent('button.click', index);
      return this;
    },
    emitButtonOver: function emitButtonOver(index) {
      // this: buttonGroup or button-sizer
      var buttonGroup = this.buttonGroup ? this.buttonGroup : this;
      var buttons = this.buttons;

      // Fire 'button.out' of overed button(s)
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        var button = buttons[i];
        if (!button._click.isOver) {
          continue;
        }
        button._click.isOver = false;
        buttonGroup.fireEvent('button.out', button);
      }

      // Fire 'button.over'
      var button = this.getButton(index);
      if (button) {
        button._click.isOver = true;
        buttonGroup.fireEvent('button.over', button);
      }
      return this;
    },
    showButton: function showButton(index) {
      Show(this.getButton(index));
      return this;
    },
    hideButton: function hideButton(index) {
      Hide(this.getButton(index));
      return this;
    },
    isButtonShown: function isButtonShown(index) {
      IsShown(this.getButton(index));
      return this;
    },
    forEachButtton: function forEachButtton(callback, scope) {
      // buttonGroup and button-sizer have *buttons* member both
      var buttons = this.buttons;
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        if (scope) {
          callback.call(scope, buttons[i], i, buttons);
        } else {
          callback(buttons[i], i, buttons);
        }
      }
      return this;
    }
  };

  var ButtonGroup = /*#__PURE__*/function () {
    function ButtonGroup(config) {
      _classCallCheck(this, ButtonGroup);
      this.parent = config.parent;
      this.eventEmitter = config.eventEmitter;
      this.groupName = config.groupName;
      this.clickConfig = config.clickConfig;
      this.buttonsType = undefined;
      this.buttons = [];
    }
    _createClass(ButtonGroup, [{
      key: "destroy",
      value: function destroy() {
        this.parent = undefined;
        this.eventEmitter = undefined;
        this.clickConfig = undefined;
        this.buttons = undefined; // GameObjects will be destroyed outside
      }
    }]);
    return ButtonGroup;
  }();
  var methods$e = {
    fireEvent: FireEvent
  };
  Object.assign(ButtonGroup.prototype, AddMethods, RemoveMethods, ButtonsTypeMethods, ButtonMethods$2, methods$e);

  // Include in Buttons/GridButtons/FixedWidthButtons class

  var ButtonStateMethods = {
    // Common
    clearAllButtonsState: function clearAllButtonsState() {
      this.buttonGroup.clearAllButtonsState();
      return this;
    },
    getAllButtonsState: function getAllButtonsState() {
      return this.buttonGroup.getAllButtonsState();
    },
    // For radio
    setSelectedButtonName: function setSelectedButtonName(name) {
      this.buttonGroup.setSelectedButtonName(name);
      return this;
    },
    getSelectedButtonName: function getSelectedButtonName() {
      return this.buttonGroup.getSelectedButtonName();
    },
    // For checkboxes
    setButtonState: function setButtonState(name, state) {
      this.buttonGroup.setButtonState(name, state);
      return this;
    },
    getButtonState: function getButtonState(name) {
      return this.buttonGroup.getButtonState(name);
    }
  };

  var GetValue$15 = Phaser.Utils.Objects.GetValue;
  var Buttons$1 = /*#__PURE__*/function (_Sizer) {
    _inherits(Buttons, _Sizer);
    function Buttons(scene, config) {
      var _this;
      _classCallCheck(this, Buttons);
      if (config === undefined) {
        config = {};
      }
      var buttonSpace = config.space;
      if (typeof buttonSpace === 'number') {
        config.space = {
          item: buttonSpace
        };
      }

      // Create
      _this = _callSuper(this, Buttons, [scene, config]);
      _this.type = 'rexButtons';
      _this.buttonGroup = new ButtonGroup({
        parent: _assertThisInitialized(_this),
        eventEmitter: GetValue$15(config, 'eventEmitter', _assertThisInitialized(_this)),
        groupName: GetValue$15(config, 'groupName', undefined),
        clickConfig: GetValue$15(config, 'click', undefined)
      }).setButtonsType(config);

      // Add elements
      var background = GetValue$15(config, 'background', undefined);
      var buttons = GetValue$15(config, 'buttons', undefined);

      // Buttons properties
      _this.buttonsExpand = GetValue$15(config, 'expand', false);
      _this.buttonsAlign = GetValue$15(config, 'align', undefined); // undefined/left/top: no space                

      if (background) {
        _this.addBackground(background);
      }
      if (buttons) {
        _this.addButtons(buttons);
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('buttons', _this.buttonGroup.buttons);
      return _this;
    }
    _createClass(Buttons, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        _get(_getPrototypeOf(Buttons.prototype), "destroy", this).call(this, fromScene);
        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
      }
    }, {
      key: "buttons",
      get: function get() {
        return this.buttonGroup.buttons;
      }
    }, {
      key: "groupName",
      get: function get() {
        return this.buttonGroup.groupName;
      },
      set: function set(value) {
        this.buttonGroup.groupName = value;
      }
    }, {
      key: "eventEmitter",
      get: function get() {
        return this.buttonGroup.eventEmitter;
      }
    }]);
    return Buttons;
  }(Sizer);
  Object.assign(Buttons$1.prototype, AddChildMethods$3, RemoveChildMethods$2, ButtonMethods$2, ButtonStateMethods);

  var SizerAdd$2 = GridSizer.prototype.add;
  var AddChildMethods$2 = {
    addButton: function addButton(gameObject, columnIndex, rowIndex) {
      SizerAdd$2.call(this, gameObject, columnIndex, rowIndex, undefined, 0, this.buttonsExpand);
      this.buttonGroup.add(gameObject);
      return this;
    },
    addButtons: function addButtons(gameObjects, rowThenColumn) {
      for (var i = 0, cnt = gameObjects; i < cnt; i++) {
        this.addButton(gameObjects[i], undefined, rowThenColumn);
      }
      return this;
    }
  };

  var SizerRmove$1 = GridSizer.prototype.remove;
  var SizerClear$1 = GridSizer.prototype.clear;
  var Remove$2 = function Remove(gameObject, destroyChild) {
    var gameObject = this.getButton(gameObject);
    if (!gameObject) {
      return this;
    }
    this.buttonGroup.remove(gameObject);
    SizerRmove$1.call(this, gameObject, destroyChild);
    return this;
  };
  var RemoveChildMethods$1 = {
    remove: function remove(gameObject, destroyChild) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Remove$2.call(this, gameObjects[i], destroyChild);
        }
      } else {
        Remove$2.call(this, gameObject, destroyChild);
      }
      return this;
    },
    clear: function clear(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      buttons.length = 0;
      SizerClear$1.call(this, destroyChild);
      return this;
    },
    removeButton: function removeButton(gameObject, destroyChild) {
      this.remove(gameObject, destroyChild);
      return this;
    },
    clearButtons: function clearButtons(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      for (var i = buttons.length - 1; i >= 0; i--) {
        Remove$2.call(this, buttons[i], destroyChild);
      }
      return this;
    }
  };

  var GetValue$14 = Phaser.Utils.Objects.GetValue;
  var GridButtons = /*#__PURE__*/function (_GridSizer) {
    _inherits(GridButtons, _GridSizer);
    function GridButtons(scene, config) {
      var _this;
      _classCallCheck(this, GridButtons);
      if (config === undefined) {
        config = {};
      }
      var rowCount = GetValue$14(config, 'row', 0);
      var columnCount = GetValue$14(config, 'column', config.col || 0);
      var createCellContainerCallback = GetValue$14(config, 'createCellContainerCallback');
      var buttons = GetValue$14(config, 'buttons', undefined);
      var buttonsExpand = GetValue$14(config, 'expand', true);
      var buttonProportion = buttonsExpand ? 1 : 0;
      if (createCellContainerCallback) {
        config.createCellContainerCallback = undefined;
      }
      if (buttons !== undefined) {
        rowCount = Math.max(rowCount, buttons.length);
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          columnCount = Math.max(columnCount, buttons[i].length);
        }
      }
      config.row = rowCount;
      config.column = columnCount;
      config.columnProportions = buttonProportion;
      config.rowProportions = buttonProportion;

      // Create
      _this = _callSuper(this, GridButtons, [scene, config]);
      _this.type = 'rexGridButtons';
      _this.buttonGroup = new ButtonGroup({
        parent: _assertThisInitialized(_this),
        eventEmitter: GetValue$14(config, 'eventEmitter', _assertThisInitialized(_this)),
        groupName: GetValue$14(config, 'groupName', undefined),
        clickConfig: GetValue$14(config, 'click', undefined)
      }).setButtonsType(config);

      // Add elements
      var background = GetValue$14(config, 'background', undefined);

      // Buttons properties
      _this.buttonsExpand = buttonsExpand;
      GetValue$14(config, 'space', undefined);
      if (background) {
        _this.addBackground(background);
      }
      if (buttons) {
        var rowButtons, button;
        for (var r = 0, rcnt = buttons.length; r < rcnt; r++) {
          // row
          rowButtons = buttons[r];
          for (var c = 0, ccnt = rowButtons.length; c < ccnt; c++) {
            // col
            button = rowButtons[c];
            if (button) {
              _this.addButton(button, c, r);
            }
          }
        }
      } else if (createCellContainerCallback) {
        for (var y = 0; y < rowCount; y++) {
          for (var x = 0; x < columnCount; x++) {
            var button = createCellContainerCallback(scene, x, y);
            if (button) {
              _this.addButton(button, x, y);
            }
          }
        }
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('buttons', _this.buttonGroup.buttons);
      return _this;
    }
    _createClass(GridButtons, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        _get(_getPrototypeOf(GridButtons.prototype), "destroy", this).call(this, fromScene);
        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
      }
    }, {
      key: "buttons",
      get: function get() {
        return this.buttonGroup.buttons;
      }
    }, {
      key: "groupName",
      get: function get() {
        return this.buttonGroup.groupName;
      },
      set: function set(value) {
        this.buttonGroup.groupName = value;
      }
    }, {
      key: "eventEmitter",
      get: function get() {
        return this.buttonGroup.eventEmitter;
      }
    }]);
    return GridButtons;
  }(GridSizer);
  Object.assign(GridButtons.prototype, AddChildMethods$2, RemoveChildMethods$1, ButtonMethods$2, ButtonStateMethods);

  var SizerAdd$1 = FixWidthSizer.prototype.add;
  var Add$1 = function Add(gameObject) {
    SizerAdd$1.call(this, gameObject);
    this.buttonGroup.add(gameObject);
    return this;
  };
  var AddChildMethods$1 = {
    addButton: function addButton(gameObject) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$1.call(this, gameObjects[i]);
        }
      } else {
        Add$1.call(this, gameObject);
      }
      return this;
    },
    addButtons: function addButtons(gameObjects) {
      if (IsArray(gameObjects[0])) {
        // 2d array
        var lines = gameObjects,
          line;
        for (var lineIdx = 0, lastLineIdx = lines.length - 1; lineIdx <= lastLineIdx; lineIdx++) {
          line = lines[lineIdx];
          for (var i = 0, cnt = line.length; i < cnt; i++) {
            Add$1.call(this, line[i]);
          }
          if (lineIdx > lastLineIdx) {
            SizerAdd$1.addNewLine(this);
          }
        }
      } else {
        // 1d array
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$1.call(this, gameObjects[i]);
        }
      }
      return this;
    }
  };

  var SizerRmove = FixWidthSizer.prototype.remove;
  var SizerClear = FixWidthSizer.prototype.clear;
  var Remove$1 = function Remove(gameObject, destroyChild) {
    var gameObject = this.getButton(gameObject);
    if (!gameObject) {
      return this;
    }
    this.buttonGroup.remove(gameObject);
    SizerRmove.call(this, gameObject, destroyChild);
    return this;
  };
  var RemoveChildMethods = {
    remove: function remove(gameObject, destroyChild) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Remove$1.call(this, gameObjects[i], destroyChild);
        }
      } else {
        Remove$1.call(this, gameObject, destroyChild);
      }
      return this;
    },
    clear: function clear(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      buttons.length = 0;
      SizerClear.call(this, destroyChild);
      return this;
    },
    removeButton: function removeButton(gameObject, destroyChild) {
      this.remove(gameObject, destroyChild);
      return this;
    },
    clearButtons: function clearButtons(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      for (var i = buttons.length - 1; i >= 0; i--) {
        Remove$1.call(this, buttons[i], destroyChild);
      }
      return this;
    }
  };

  var GetValue$13 = Phaser.Utils.Objects.GetValue;
  var Buttons = /*#__PURE__*/function (_FixWidthSizer) {
    _inherits(Buttons, _FixWidthSizer);
    function Buttons(scene, config) {
      var _this;
      _classCallCheck(this, Buttons);
      if (config === undefined) {
        config = {};
      }
      var buttonSpace = config.space;
      if (typeof buttonSpace === 'number') {
        config.space = {
          item: buttonSpace,
          line: buttonSpace
        };
      }

      // Create
      _this = _callSuper(this, Buttons, [scene, config]);
      _this.type = 'rexFixWidthButtons';
      _this.buttonGroup = new ButtonGroup({
        parent: _assertThisInitialized(_this),
        eventEmitter: GetValue$13(config, 'eventEmitter', _assertThisInitialized(_this)),
        groupName: GetValue$13(config, 'groupName', undefined),
        clickConfig: GetValue$13(config, 'click', undefined)
      }).setButtonsType(config);

      // Add elements
      var background = GetValue$13(config, 'background', undefined);
      var buttons = GetValue$13(config, 'buttons', undefined);

      // Buttons properties
      _this.buttonsAlign = GetValue$13(config, 'align', undefined);
      if (background) {
        _this.addBackground(background);
      }
      if (buttons) {
        _this.addButtons(buttons);
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('buttons', _this.buttonGroup.buttons);
      return _this;
    }
    _createClass(Buttons, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        _get(_getPrototypeOf(Buttons.prototype), "destroy", this).call(this, fromScene);
        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
      }
    }, {
      key: "buttons",
      get: function get() {
        return this.buttonGroup.buttons;
      }
    }, {
      key: "groupName",
      get: function get() {
        return this.buttonGroup.groupName;
      },
      set: function set(value) {
        this.buttonGroup.groupName = value;
      }
    }, {
      key: "eventEmitter",
      get: function get() {
        return this.buttonGroup.eventEmitter;
      }
    }]);
    return Buttons;
  }(FixWidthSizer);
  Object.assign(Buttons.prototype, AddChildMethods$1, RemoveChildMethods, ButtonMethods$2, ButtonStateMethods);

  var FileChooserMethods = {
    setAccept: function setAccept(accept) {
      this.childrenMap.fileChooser.setAccept(accept);
      return this;
    },
    setMultiple: function setMultiple(enabled) {
      this.childrenMap.fileChooser.setMultiple(enabled);
      return this;
    },
    loadFile: function loadFile(file, loaderType, key, cacheType, onComplete) {
      this.childrenMap.fileChooser.loadFile(file, loaderType, key, cacheType, onComplete);
      return this;
    },
    loadFilePromise: function loadFilePromise(file, loaderType, key, cacheType) {
      return this.childrenMap.fileChooser.loadFilePromise(file, loaderType, key, cacheType);
    }
  };

  var GetValue$12 = Phaser.Utils.Objects.GetValue;
  var FileSelectorButton = /*#__PURE__*/function (_Label) {
    _inherits(FileSelectorButton, _Label);
    function FileSelectorButton(scene, config) {
      var _this;
      _classCallCheck(this, FileSelectorButton);
      _this = _callSuper(this, FileSelectorButton, [scene, config]);
      _this.type = 'rexFileSelectorButton';
      var fileChooser = new FileChooser(scene);
      scene.add.existing(fileChooser);
      _this.addBackground(fileChooser);
      _this.addChildrenMap('fileChooser', fileChooser);
      _this.setAccept(GetValue$12(config, 'accept', ''));
      _this.setMultiple(GetValue$12(config, 'multiple', false));
      fileChooser.on('change', function (gameObject) {
        var files = gameObject.files;
        if (files.length === 0) {
          return;
        }
        files = Array.from(files);
        this.emit('select', files, this);
      }, _assertThisInitialized(_this));
      return _this;
    }
    _createClass(FileSelectorButton, [{
      key: "files",
      get: function get() {
        return this.childrenMap.fileChooser.files;
      }
    }]);
    return FileSelectorButton;
  }(Label);
  Object.assign(FileSelectorButton.prototype, FileChooserMethods);

  var ButtonMethods$1 = {
    getChoice: function getChoice(index) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        return choicesSizer.getButton(index);
      } else {
        return undefined;
      }
    },
    getAction: function getAction(index) {
      return this.childrenMap.actionsSizer.getButton(index);
    },
    getToolbar: function getToolbar(index) {
      return this.childrenMap.toolbarSizer.getButton(index);
    },
    getLeftToolbar: function getLeftToolbar(index) {
      return this.childrenMap.leftToolbarSizer.getButton(index);
    },
    setChoiceEnable: function setChoiceEnable(index, enabled) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.setButtonEnable(index, enabled);
      }
      return this;
    },
    setActionEnable: function setActionEnable(index, enabled) {
      this.childrenMap.actionsSizer.setButtonEnable(index, enabled);
      return this;
    },
    setToolbarEnable: function setToolbarEnable(index, enabled) {
      this.childrenMap.toolbarSizer.setButtonEnable(index, enabled);
      return this;
    },
    setLeftToolbarEnable: function setLeftToolbarEnable(index, enabled) {
      this.childrenMap.leftToolbarSizer.setButtonEnable(index, enabled);
      return this;
    },
    toggleChoiceEnable: function toggleChoiceEnable(index) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.toggleButtonEnable(index);
      }
      return this;
    },
    toggleActionEnable: function toggleActionEnable(index) {
      this.childrenMap.actionsSizer.toggleButtonEnable(index);
      return this;
    },
    toggleToolbarEnable: function toggleToolbarEnable(index) {
      this.childrenMap.toolbarSizer.toggleButtonEnable(index);
      return this;
    },
    toggleLeftToolbarEnable: function toggleLeftToolbarEnable(index) {
      this.childrenMap.leftToolbarSizer.toggleButtonEnable(index);
      return this;
    },
    getChoiceEnable: function getChoiceEnable(index) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        return choicesSizer.getButtonEnable(index);
      } else {
        return false;
      }
    },
    getActionEnable: function getActionEnable(index) {
      return this.childrenMap.actionsSizer.getButtonEnable(index);
    },
    getToolbarEnable: function getToolbarEnable(index) {
      return this.childrenMap.toolbarSizer.getButtonEnable(index);
    },
    getLeftToolbarEnable: function getLeftToolbarEnable(index) {
      return this.childrenMap.leftToolbarSizer.getButtonEnable(index);
    },
    emitChoiceClick: function emitChoiceClick(index) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.emitButtonClick(index);
      }
      return this;
    },
    emitActionClick: function emitActionClick(index) {
      this.childrenMap.actionsSizer.emitButtonClick(index);
      return this;
    },
    emitToolbarClick: function emitToolbarClick(index) {
      this.childrenMap.toolbarSizer.emitButtonClick(index);
      return this;
    },
    emitLeftToolbarClick: function emitLeftToolbarClick(index) {
      this.childrenMap.leftToolbarSizer.emitButtonClick(index);
      return this;
    },
    showChoice: function showChoice(index) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.showButton(index);
      }
      return this;
    },
    showAction: function showAction(index) {
      this.childrenMap.actionsSizer.showButton(index);
      return this;
    },
    showToolbar: function showToolbar(index) {
      this.childrenMap.toolbarSizer.showButton(index);
      return this;
    },
    showLeftToolbar: function showLeftToolbar(index) {
      this.childrenMap.leftToolbarSizer.showButton(index);
      return this;
    },
    hideChoice: function hideChoice(index) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.hideButton(index);
      }
      return this;
    },
    hideAction: function hideAction(index) {
      this.childrenMap.actionsSizer.hideButton(index);
      return this;
    },
    hideToolbar: function hideToolbar(index) {
      this.childrenMap.toolbarSizer.hideButton(index);
      return this;
    },
    hideLeftToolbar: function hideLeftToolbar(index) {
      this.childrenMap.leftToolbarSizer.hideButton(index);
      return this;
    },
    addChoice: function addChoice(gameObject) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.addButton(gameObject);
      }
      return this;
    },
    addAction: function addAction(gameObject) {
      this.childrenMap.actionsSizer.addButton(gameObject);
      return this;
    },
    addToolbar: function addToolbar(gameObject) {
      this.childrenMap.toolbarSizer.addButton(gameObject);
      return this;
    },
    addLeftToolbar: function addLeftToolbar(gameObject) {
      this.childrenMap.leftToolbarSizer.addButton(gameObject);
      return this;
    },
    removeChoice: function removeChoice(index, destroyChild) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.removeButton(index, destroyChild);
      }
      return this;
    },
    removeAction: function removeAction(index, destroyChild) {
      this.childrenMap.actionsSizer.removeButton(index, destroyChild);
      return this;
    },
    removeToolbar: function removeToolbar(index, destroyChild) {
      this.childrenMap.toolbarSizer.removeButton(index, destroyChild);
      return this;
    },
    removeLeftToolbar: function removeLeftToolbar(index, destroyChild) {
      this.childrenMap.leftToolbarSizer.removeButton(index, destroyChild);
      return this;
    },
    clearChoices: function clearChoices(destroyChild) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.clearButtons(destroyChild);
      }
      return this;
    },
    clearActions: function clearActions(destroyChild) {
      this.childrenMap.actionsSizer.clearButtons(destroyChild);
      return this;
    },
    clearToolbar: function clearToolbar(destroyChild) {
      this.childrenMap.toolbarSizer.clearButtons(destroyChild);
      return this;
    },
    clearLeftToolbar: function clearLeftToolbar(destroyChild) {
      this.childrenMap.leftToolbarSizer.clearButtons(destroyChild);
      return this;
    },
    forEachChoice: function forEachChoice(callback, scope) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.forEachButtton(callback, scope);
      }
      return this;
    },
    forEachAction: function forEachAction(callback, scope) {
      this.childrenMap.actionsSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachToolbar: function forEachToolbar(callback, scope) {
      this.childrenMap.toolbarSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachLeftToolbar: function forEachLeftToolbar(callback, scope) {
      this.childrenMap.leftToolbarSizer.forEachButtton(callback, scope);
      return this;
    },
    setAllButtonsEnable: function setAllButtonsEnable(enabled) {
      if (enabled === undefined) {
        enabled = true;
      }
      if (this.childrenMap.toolbarSizer) {
        this.setToolbarEnable(enabled);
      }
      if (this.childrenMap.leftToolbarSizer) {
        this.setLeftToolbarEnable(enabled);
      }
      if (this.childrenMap.actionsSizer) {
        this.setActionEnable(enabled);
      }
      if (this.childrenMap.choicesSizer) {
        this.setChoiceEnable(enabled);
      }
      return this;
    },
    // Checkboxes
    getChoicesButtonStates: function getChoicesButtonStates() {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        return choicesSizer.getAllButtonsState();
      } else {
        return {};
      }
    },
    getChoicesButtonState: function getChoicesButtonState(name) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (name === undefined) {
        if (choicesSizer) {
          return choicesSizer.getAllButtonsState();
        } else {
          return {};
        }
      } else {
        if (choicesSizer) {
          return choicesSizer.getButtonState(name);
        } else {
          return false;
        }
      }
    },
    setChoicesButtonState: function setChoicesButtonState(name, state) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.setButtonState(name, state);
      }
      return this;
    },
    clearChoicesButtonStates: function clearChoicesButtonStates() {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.clearAllButtonsState();
      }
      return this;
    },
    // Radio buttons
    getChoicesSelectedButtonName: function getChoicesSelectedButtonName() {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        return choicesSizer.getSelectedButtonName();
      } else {
        return '';
      }
    },
    setChoicesSelectedButtonName: function setChoicesSelectedButtonName(name) {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        choicesSizer.setSelectedButtonName(name);
      }
      return this;
    },
    hasAnyChoice: function hasAnyChoice() {
      var choicesSizer = this.childrenMap.choicesSizer;
      if (choicesSizer) {
        return choicesSizer.hasAnyButton();
      }
      return false;
    },
    hasAnyAction: function hasAnyAction() {
      var actionsSizer = this.childrenMap.actionsSizer;
      if (actionsSizer) {
        return actionsSizer.hasAnyButton();
      }
      return false;
    },
    hasAnyToolbar: function hasAnyToolbar() {
      var toolbarSizer = this.childrenMap.toolbarSizer;
      if (toolbarSizer) {
        return toolbarSizer.hasAnyButton();
      }
      return false;
    },
    hasAnyLeftToolbar: function hasAnyLeftToolbar() {
      var leftToolbarSizer = this.childrenMap.leftToolbarSizer;
      if (leftToolbarSizer) {
        return leftToolbarSizer.hasAnyButton();
      }
      return false;
    }
  };

  var ModalMethods = {
    onCreateModalBehavior: function onCreateModalBehavior(self) {
      self.on('button.click', function (button, groupName, index, pointer, event) {
        var canClose = false;
        switch (groupName) {
          case 'actions':
            // Click any action button
            canClose = true;
            break;
          case 'choices':
            // Click any choice button, and no action button in this dialog
            if (!self.hasAnyAction()) {
              canClose = true;
            }
            break;
        }
        if (!canClose) {
          return;
        }
        var closeEventData = {
          index: index,
          text: button.text,
          button: button,
          dialog: self
        };
        switch (self.buttonsType) {
          case 'radio':
            closeEventData.value = self.getChoicesSelectedButtonName();
            break;
          case 'checkboxes':
            closeEventData.value = self.getChoicesButtonStates();
            break;
          default:
            closeEventData.value = undefined;
        }
        self.modalClose(closeEventData);
      });
    },
    modal: function modal(config, onClose) {
      if (config && config.defaultBehavior === false) {
        this.onCreateModalBehavior = false;
      } else {
        delete this.onCreateModalBehavior;
      }
      ModalMethods$1.modal.call(this, config, onClose);
      return this;
    }
  };

  var Methods$5 = {};
  Object.assign(Methods$5, ButtonMethods$1, ModalMethods);

  var GetValue$11 = Phaser.Utils.Objects.GetValue;
  var Dialog = /*#__PURE__*/function (_Sizer) {
    _inherits(Dialog, _Sizer);
    function Dialog(scene, config) {
      var _this;
      _classCallCheck(this, Dialog);
      if (config === undefined) {
        config = {};
      }
      // Create sizer        
      config.orientation = 1; // Top to bottom
      _this = _callSuper(this, Dialog, [scene, config]);
      _this.type = 'rexDialog';
      _this.eventEmitter = GetValue$11(config, 'eventEmitter', _assertThisInitialized(_this));

      // Add elements
      var background = GetValue$11(config, 'background', undefined);
      var title = GetValue$11(config, 'title', undefined);
      var toolbar = GetValue$11(config, 'toolbar', undefined);
      var toolbarBackground = GetValue$11(config, 'toolbarBackground', undefined);
      var leftToolbar = GetValue$11(config, 'leftToolbar', undefined);
      var leftToolbarBackground = GetValue$11(config, 'leftToolbarBackground', undefined);
      var content = GetValue$11(config, 'content', undefined);
      var description = GetValue$11(config, 'description', undefined);
      var choicesSizer;
      var choices = GetValue$11(config, 'choices', undefined);
      var choicesBackground = GetValue$11(config, 'choicesBackground', undefined);
      var actionsSizer;
      var actions = GetValue$11(config, 'actions', undefined);
      var actionsBackground = GetValue$11(config, 'actionsBackground', undefined);
      var clickConfig = GetValue$11(config, 'click', undefined);
      if (background) {
        _this.addBackground(background);
      }
      var toolbarSizer;
      if (toolbar) {
        toolbarSizer = new Buttons$1(scene, {
          groupName: 'toolbar',
          background: toolbarBackground,
          buttons: toolbar,
          orientation: 0,
          // Left-right
          space: {
            item: GetValue$11(config, 'space.toolbarItem', 0)
          },
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
      }
      var leftToolbarSizer;
      if (leftToolbar) {
        leftToolbarSizer = new Buttons$1(scene, {
          groupName: 'leftToolbar',
          background: leftToolbarBackground,
          buttons: leftToolbar,
          orientation: 0,
          // Left-right
          space: {
            item: GetValue$11(config, 'space.leftToolbarItem', 0)
          },
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
      }

      // title or toolbar or leftToolbar
      if (title || toolbar || leftToolbar) {
        var titleExpandWidth = !!title && GetValue$11(config, 'expand.title', true);
        var titleAlign = GetValue$11(config, 'align.title', 'center');
        var useOverlapSizer =
        // Has title, title is not exapnd-width, title align to center
        title && !titleExpandWidth && titleAlign === 'center' ||
        // No title
        !title && (toolbar || leftToolbar);
        var useSizer = !useOverlapSizer;
        var titleSizer;
        if (useSizer) {
          titleSizer = new Sizer(scene, {
            orientation: 0
          });
        } else {
          titleSizer = new OverlapSizer(scene);
        }
        var titleChildExpand = useSizer ? true : {
          height: true
        };

        // Add leftToolbar
        if (leftToolbarSizer) {
          titleSizer.add(leftToolbarSizer, {
            align: 'left',
            expand: titleChildExpand
          });
        }

        // Add title
        if (title) {
          // Add space if not expand, align to right
          if (useSizer && !titleExpandWidth && titleAlign === 'right') {
            titleSizer.addSpace();
          }
          var padding = {
            left: GetValue$11(config, 'space.titleLeft', 0),
            right: GetValue$11(config, 'space.titleRight', 0)
          };
          var proportion = titleExpandWidth ? 1 : 0;
          titleSizer.add(title, {
            align: titleAlign,
            proportion: proportion,
            expand: titleChildExpand,
            padding: padding
          });

          // Add space if not expand, align to left
          if (useSizer && !titleExpandWidth && titleAlign === 'left') {
            titleSizer.addSpace();
          }
        }

        // Add toolbar
        if (toolbarSizer) {
          // Add space if not title
          if (useSizer && !title) {
            titleSizer.addSpace();
          }
          titleSizer.add(toolbarSizer, {
            align: 'right',
            expand: titleChildExpand
          });
        }

        // Add sizer to dialog
        var padding;
        if (content || description || choices || actions) {
          padding = {
            bottom: GetValue$11(config, 'space.title', 0),
            top: GetValue$11(config, 'space.titleTop', 0)
          };
        }
        var proportion = GetValue$11(config, 'proportion.title', 0);
        _this.add(titleSizer, {
          padding: padding,
          proportion: proportion,
          expand: true
        });
      }
      if (content) {
        var align = GetValue$11(config, 'align.content', 'center');
        var contentSpace = GetValue$11(config, 'space.content', 0);
        var padding = {
          left: GetValue$11(config, 'space.contentLeft', 0),
          right: GetValue$11(config, 'space.contentRight', 0),
          bottom: description || choices || actions ? contentSpace : 0
        };
        var proportion = GetValue$11(config, 'proportion.content', 0);
        var expand = GetValue$11(config, 'expand.content', true);
        _this.add(content, {
          align: align,
          padding: padding,
          proportion: proportion,
          expand: expand
        });
      }
      if (description) {
        var align = GetValue$11(config, 'align.description', 'center');
        var descriptionSpace = GetValue$11(config, 'space.description', 0);
        var padding = {
          left: GetValue$11(config, 'space.descriptionLeft', 0),
          right: GetValue$11(config, 'space.descriptionRight', 0),
          bottom: choices || actions ? descriptionSpace : 0
        };
        var proportion = GetValue$11(config, 'proportion.description', 0);
        var expand = GetValue$11(config, 'expand.description', true);
        _this.add(description, {
          align: align,
          padding: padding,
          proportion: proportion,
          expand: expand
        });
      }
      if (choices) {
        var choicesType = GetValue$11(config, 'choicesType', '').split('-');
        var ButtonsClass = Contains(choicesType, 'wrap') ? Buttons : Contains(choicesType, 'grid') ? GridButtons : Buttons$1;
        var buttonsType = Contains(choicesType, 'radio') ? 'radio' : Contains(choicesType, 'checkboxes') ? 'checkboxes' : undefined;
        var space = {
          left: GetValue$11(config, 'space.choicesBackgroundLeft', 0),
          right: GetValue$11(config, 'space.choicesBackgroundRight', 0),
          top: GetValue$11(config, 'space.choicesBackgroundTop', 0),
          bottom: GetValue$11(config, 'space.choicesBackgroundBottom', 0)
        };
        var itemSpace = GetValue$11(config, 'space.choice', 0);
        if (ButtonsClass === Buttons$1) {
          space.item = itemSpace;
        } else if (ButtonsClass === Buttons) {
          space.item = itemSpace;
          space.line = GetValue$11(config, 'space.choiceLine', itemSpace);
        } else {
          // GridButtons
          space.column = GetValue$11(config, 'space.choiceColumn', itemSpace);
          space.row = GetValue$11(config, 'space.choiceRow', itemSpace);
        }
        var choicesConfig = {
          width: GetValue$11(config, 'choicesWidth', undefined),
          height: GetValue$11(config, 'choicesHeight', undefined),
          groupName: 'choices',
          buttonsType: buttonsType,
          background: choicesBackground,
          buttons: choices,
          space: space,
          click: clickConfig,
          eventEmitter: _this.eventEmitter,
          setValueCallback: GetValue$11(config, 'choicesSetValueCallback', undefined),
          setValueCallbackScope: GetValue$11(config, 'choicesSetValueCallbackScope', undefined)
        };
        if (ButtonsClass === Buttons$1) {
          choicesConfig.orientation = Contains(choicesType, 'x') ? 0 : 1;
        }
        choicesSizer = new ButtonsClass(scene, choicesConfig);
        var choicesSpace = GetValue$11(config, 'space.choices', 0);
        var padding = {
          left: GetValue$11(config, 'space.choicesLeft', 0),
          right: GetValue$11(config, 'space.choicesRight', 0),
          bottom: actions ? choicesSpace : 0
        };
        var align = GetValue$11(config, 'align.choices', 'center');
        var proportion = GetValue$11(config, 'proportion.choices', 0);
        var expand = GetValue$11(config, 'expand.choices', true);
        _this.add(choicesSizer, {
          align: align,
          padding: padding,
          proportion: proportion,
          expand: expand
        });
        _this.buttonsType = buttonsType;
      }
      if (actions) {
        actionsSizer = new Buttons$1(scene, {
          groupName: 'actions',
          background: actionsBackground,
          buttons: actions,
          orientation: 0,
          // Left-right
          space: {
            item: GetValue$11(config, 'space.action', 0)
          },
          expand: GetValue$11(config, 'expand.actions', false),
          align: GetValue$11(config, 'align.actions', 'center'),
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        var padding = {
          left: GetValue$11(config, 'space.actionsLeft', 0),
          right: GetValue$11(config, 'space.actionsRight', 0),
          bottom: GetValue$11(config, 'space.actionsBottom', 0)
        };
        var proportion = GetValue$11(config, 'proportion.action', 0);
        _this.add(actionsSizer, {
          align: 'center',
          padding: padding,
          proportion: proportion,
          expand: true
        });
      }
      EmitButtonEvent(_assertThisInitialized(_this), 'click');
      EmitButtonEvent(_assertThisInitialized(_this), 'over');
      EmitButtonEvent(_assertThisInitialized(_this), 'out');
      EmitButtonEvent(_assertThisInitialized(_this), 'enable');
      EmitButtonEvent(_assertThisInitialized(_this), 'disable');
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('title', title);
      _this.addChildrenMap('toolbar', toolbar);
      _this.addChildrenMap('leftToolbar', leftToolbar);
      _this.addChildrenMap('content', content);
      _this.addChildrenMap('description', description);
      _this.addChildrenMap('choices', choicesSizer ? choicesSizer.buttons : undefined);
      _this.addChildrenMap('actions', actionsSizer ? actionsSizer.buttons : undefined);
      _this.addChildrenMap('choicesSizer', choicesSizer);
      _this.addChildrenMap('actionsSizer', actionsSizer);
      _this.addChildrenMap('toolbarSizer', toolbarSizer);
      _this.addChildrenMap('leftToolbarSizer', leftToolbarSizer);
      return _this;
    }
    return _createClass(Dialog);
  }(Sizer);
  var Contains = function Contains(arr, item) {
    return arr.indexOf(item) !== -1;
  };
  var ButtonsGroupEventNameMap = {
    actions: 'action',
    choices: 'choice',
    toolbar: 'toolbar',
    leftToolbar: 'leftToolbar'
  };
  var EmitButtonEvent = function EmitButtonEvent(dialog, postEventName) {
    dialog.on("button.".concat(postEventName), function (button, groupName, index, pointer, event) {
      if (!ButtonsGroupEventNameMap.hasOwnProperty(groupName)) {
        return;
      }
      dialog.emit("".concat(ButtonsGroupEventNameMap[groupName], ".").concat(postEventName), button, index, pointer, event);
    });
  };
  Object.assign(Dialog.prototype, Methods$5);

  var CreateLabel = function CreateLabel(scene, config, creators) {
    var gameObject = new SimpleLabel(scene, config, creators);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var ResetDisplayContent = function ResetDisplayContent(config) {
    if (config === undefined) {
      config = {};
    }
    ResetTitle.call(this, config);
    ResetContent.call(this, config);
    ResetActions.call(this, config);
    ResetChoices.call(this, config);
    return this;
  };
  var ResetTitle = function ResetTitle(config) {
    var title = this.childrenMap.title;
    config = config.title;
    if (config === null) {
      title.hide();
    } else {
      title.show();
      title.resetDisplayContent(config);
    }
  };
  var ResetContent = function ResetContent(config) {
    var content = this.childrenMap.content;
    config = config.content;
    if (config === null) {
      content.hide();
    } else {
      content.show();
      if (content.resetDisplayContent) {
        // Label
        content.resetDisplayContent(config);
      } else {
        // TextArea
        var text = config || '';
        content.setText(text);
      }
    }
  };
  var ResetActions = function ResetActions(config) {
    var actionButtons = this.childrenMap.actions;
    if (!actionButtons) {
      return;
    }
    var buttonContentArray = config.buttons;
    if (!buttonContentArray) {
      var buttonA = actionButtons[0];
      if (buttonA) {
        if (config.buttonA === null) {
          buttonA.hide();
        } else {
          buttonA.show();
          buttonA.resetDisplayContent(config.buttonA);
        }
      }
      var buttonB = actionButtons[1];
      if (buttonB) {
        if (config.buttonB === null) {
          buttonB.hide();
        } else {
          buttonB.show();
          buttonB.resetDisplayContent(config.buttonB);
        }
      }
    } else {
      var scene = this.scene;
      var defaultActionConfig = this.defaultActionConfig;
      var defaultActionButtonCreator = this.defaultActionButtonCreator;
      for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
        var buttonContent = buttonContentArray[i];
        var button = actionButtons[i];
        if (!button) {
          button = CreateLabel(scene, defaultActionConfig, defaultActionButtonCreator);
          this.addAction(button);
        }
        button.show().resetDisplayContent(buttonContent);
      }
      this.buttonMode = buttonContentArray.length;
      for (var i = buttonContentArray.length, cnt = actionButtons.length; i < cnt; i++) {
        actionButtons[i].hide();
      }
    }
  };
  var ResetChoices = function ResetChoices(config) {
    var choices = this.childrenMap.choices;
    if (!choices) {
      return;
    }
    var buttonContentArray = config.choices;
    if (!buttonContentArray) {
      buttonContentArray = [];
    }
    var scene = this.scene;
    var defaultChoiceConfig = this.defaultChoiceConfig;
    var defaultActionButtonCreator = this.defaultActionButtonCreator;
    for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
      var buttonContent = buttonContentArray[i];
      if (typeof buttonContent === 'string') {
        buttonContent = {
          text: buttonContent
        };
      }
      var button = choices[i];
      if (!button) {
        button = CreateLabel(scene, defaultChoiceConfig, defaultActionButtonCreator);
        this.addChoice(button);
      }
      button.show().resetDisplayContent(buttonContent);
      var optionValue;
      if (buttonContent.hasOwnProperty('value')) {
        optionValue = buttonContent.value;
      } else {
        optionValue = buttonContent.text;
      }
      button.setName(optionValue);
    }
    for (var i = buttonContentArray.length, cnt = choices.length; i < cnt; i++) {
      choices[i].hide();
    }
  };

  Phaser.Utils.Objects.GetValue;
  var Modal = function Modal(config, onClose) {
    if (IsFunction(config)) {
      onClose = config;
      config = undefined;
    }
    if (config === undefined) {
      config = {};
    }
    var zeroButtonMode;
    if (this.buttonMode === 0) {
      if (this.hasAnyChoice()) {
        zeroButtonMode = false;
      } else {
        zeroButtonMode = true;
      }
    } else {
      zeroButtonMode = false;
    }
    if (!config.hasOwnProperty('anyTouchClose')) {
      config.anyTouchClose = zeroButtonMode;
    }
    if (!config.hasOwnProperty('manualClose')) {
      config.manualClose = !zeroButtonMode;
    }
    var self = this;
    var onCloseWrap = function onCloseWrap(data) {
      var buttonIndex = data.index;
      if (buttonIndex === self.confirmButtonIndex) {
        self.emit('confirm', data);
      } else if (buttonIndex === self.cancelButtonIndex) {
        self.emit('cancel', data);
      }
      if (onClose) {
        onClose(data);
      }
    };
    ModalMethods$1.modal.call(this, config, onCloseWrap);
    return this;
  };

  var SetButtonIndexMethods = {
    setConfirmButtonIndex: function setConfirmButtonIndex(index) {
      this.confirmButtonIndex = index;
      return this;
    },
    setCancelButtonIndex: function setCancelButtonIndex(index) {
      this.cancelButtonIndex = index;
      return this;
    }
  };

  var Methods$4 = {
    resetDisplayContent: ResetDisplayContent,
    modal: Modal
  };
  Object.assign(Methods$4, SetButtonIndexMethods);

  var OnPointerOverCallback = function OnPointerOverCallback(button) {
    if (button.setHoverState) {
      button.setHoverState(true);
    }
  };
  var OnPointerOutCallback = function OnPointerOutCallback(button) {
    if (button.setHoverState) {
      button.setHoverState(false);
    }
  };
  var OnChoiceButtonStateChange = function OnChoiceButtonStateChange(button, groupName, index, value) {
    if (button.setActiveState) {
      button.setActiveState(value);
    }
  };
  var OnButtonEnable = function OnButtonEnable(button) {
    if (button.setDisableState) {
      button.setDisableState(false);
    }
  };
  var OnButtonDisable = function OnButtonDisable(button) {
    if (button.setDisableState) {
      button.setDisableState(true);
    }
  };
  var RegisterEvents = function RegisterEvents() {
    this.on('button.over', OnPointerOverCallback).on('button.out', OnPointerOutCallback).on('button.enable', OnButtonEnable).on('button.disable', OnButtonDisable).on('button.statechange', OnChoiceButtonStateChange);
  };

  var GetValue$10 = Phaser.Utils.Objects.GetValue;
  var CreateContent = function CreateContent(scene, config, creators) {
    var type = GetValue$10(config, '$type');
    if (type === undefined) {
      if (config && (config.hasOwnProperty('slider') || config.hasOwnProperty('scroller'))) {
        type = 'textarea';
      }
    }
    var gameObject;
    switch (type) {
      case 'textarea':
        gameObject = new CreateTextArea(scene, config, creators);
        break;
      default:
        gameObject = new CreateLabel(scene, config, creators);
        break;
    }
    scene.add.existing(gameObject);
    return gameObject;
  };

  var GetValue$$ = Phaser.Utils.Objects.GetValue;
  var ConfirmDialog = /*#__PURE__*/function (_Dialog) {
    _inherits(ConfirmDialog, _Dialog);
    function ConfirmDialog(scene, config, creators) {
      var _this;
      _classCallCheck(this, ConfirmDialog);
      config = config ? DeepClone(config) : {};
      if (creators === undefined) {
        creators = {};
      }
      var createBackground = GetValue$$(creators, 'background', CreateBackground$2);
      if (createBackground) {
        config.background = createBackground(scene, config.background);
      } else {
        delete config.background;
      }
      config.title = CreateLabel(scene, config.title, creators.title);
      config.content = CreateContent(scene, config.content, creators.content);
      if (config.content instanceof TextArea) {
        if (HasValue(config, 'height') && !HasValue(config, 'proportion.content')) {
          SetValue(config, 'proportion.content', 1);
        }
      }
      var defaultButtonConfig = config.button;
      var buttonAConfig = config.buttonA || defaultButtonConfig;
      var buttonBConfig = config.buttonB || defaultButtonConfig;
      var buttonMode = config.buttonMode;
      if (buttonMode === undefined) {
        buttonMode = !!buttonAConfig && !!buttonBConfig ? 2 : !!buttonAConfig ? 1 : 0;
      }
      var defaultButtonCreator = creators.button;
      var buttonACreators = creators.buttonA || defaultButtonCreator;
      var buttonBCreators = creators.buttonB || defaultButtonCreator;
      switch (buttonMode) {
        case 2:
          config.actions = [CreateLabel(scene, buttonAConfig, buttonACreators), CreateLabel(scene, buttonBConfig, buttonBCreators)];
          break;
        case 1:
          config.actions = [CreateLabel(scene, buttonAConfig, buttonACreators)];
          break;
        case 0:
          break;
        default:
          config.actions = [];
          break;
      }
      var defaultChoiceConfig = config.choice;
      if (defaultChoiceConfig) {
        config.choices = [];
      }
      _this = _callSuper(this, ConfirmDialog, [scene, config]);
      _this.type = 'rexConfirmDialog';
      _this.buttonMode = buttonMode;
      _this.defaultActionConfig = defaultButtonConfig;
      _this.defaultActionButtonCreator = defaultButtonCreator;
      _this.defaultChoiceConfig = defaultChoiceConfig;
      _this.defaultChoiceCreator = creators.choice;
      var buttons = _this.childrenMap.actions;
      _this.addChildrenMap('buttonA', buttons ? buttons[0] : null);
      _this.addChildrenMap('buttonB', buttons ? buttons[1] : null);

      // Interactive
      RegisterEvents.call(_assertThisInitialized(_this));

      // Assign button index for comfirm, cancel events
      _this.setConfirmButtonIndex(GetValue$$(config, 'confirmButtonIndex', 0));
      _this.setCancelButtonIndex(GetValue$$(config, 'cancelButtonIndex', 1));
      return _this;
    }
    return _createClass(ConfirmDialog);
  }(Dialog);
  Object.assign(ConfirmDialog.prototype, Methods$4);

  Phaser.Utils.Objects.GetValue;

  var RemoveFromParent = function RemoveFromParent(gameObject, destroyChild) {
    if (!gameObject) {
      return;
    }
    var parent = GetParent$1(gameObject);
    if (!parent) {
      return;
    }
    parent.remove(gameObject, destroyChild);
  };

  var GetValue$_ = Phaser.Utils.Objects.GetValue;
  var GetAddChildConfig = function GetAddChildConfig(config, key, defaultValues) {
    var proportion = GetValue$_(config, "proportion.".concat(key), defaultValues.proportion);
    var align = GetValue$_(config, "align.".concat(key), 'center');
    var padding = GetValue$_(config, "space.".concat(key), undefined);
    if (typeof padding === 'number' && defaultValues.paddingKey) {
      var paddingNum = padding;
      padding = {};
      padding[defaultValues.paddingKey] = paddingNum;
    }
    var expand = GetValue$_(config, "expand.".concat(key), true);
    return {
      proportion: proportion,
      align: align,
      padding: padding,
      expand: expand
    };
  };
  var GetAddHeaderConfig = function GetAddHeaderConfig(config) {
    return GetAddChildConfig(config, 'header', {
      proportion: 0,
      paddingKey: 'bottom'
    });
  };
  var GetAddLeftSideConfig = function GetAddLeftSideConfig(config) {
    return GetAddChildConfig(config, 'leftSide', {
      proportion: 0,
      paddingKey: 'right'
    });
  };
  var GetAddContentConfig = function GetAddContentConfig(config) {
    return GetAddChildConfig(config, 'content', {
      proportion: 1
    });
  };
  var GetAddRightSideConfig = function GetAddRightSideConfig(config) {
    return GetAddChildConfig(config, 'rightSide', {
      proportion: 0,
      paddingKey: 'left'
    });
  };
  var GetAddFooterConfig = function GetAddFooterConfig(config) {
    return GetAddChildConfig(config, 'footer', {
      proportion: 0,
      paddingKey: 'top'
    });
  };
  var GetAddContainerConfig = function GetAddContainerConfig(config) {
    return {
      proportion: 1,
      align: 'center',
      padding: 0,
      expand: true
    };
  };

  var CreatExpandContainer = function CreatExpandContainer(scene, orientation) {
    var container = new Sizer(scene, {
      orientation: orientation
    });
    scene.add.existing(container);
    return container;
  };

  /*
  Elements:
      ```
      HHH
      LCR
      FFF
      ```
  */

  var LayoutMode0$1 = function LayoutMode0(config) {
    var scene = this.scene;

    // Add Header
    var header = config.header;
    if (header) {
      this.add(header, GetAddHeaderConfig(config));
    }

    /*
    L C R
    */
    var bodySizer = CreatExpandContainer(scene, 0);
    this.add(bodySizer, GetAddContainerConfig());

    // Add Left-side
    var leftSide = config.leftSide;
    if (leftSide) {
      bodySizer.add(leftSide, GetAddLeftSideConfig(config));
    }

    // Add content
    var content = config.content;
    if (content) {
      bodySizer.add(content, GetAddContentConfig(config));
    }

    // Add Right-side
    var rightSide = config.rightSide;
    if (rightSide) {
      bodySizer.add(rightSide, GetAddRightSideConfig(config));
    }

    // Add Footer
    var footer = config.footer;
    if (footer) {
      this.add(footer, GetAddFooterConfig(config));
    }
  };

  /*
  Elements:
      ```
      HHH
      LCR
      LFF
      ```
  */

  var LayoutMode1 = function LayoutMode1(config) {
    var scene = this.scene;

    // Add Header
    var header = config.header;
    if (header) {
      this.add(header, GetAddHeaderConfig(config));
    }

    /*
    L CR
    L FF
    */
    var bodySizer0 = CreatExpandContainer(scene, 0);
    this.add(bodySizer0, GetAddContainerConfig());

    // Add Left-side
    var leftSide = config.leftSide;
    if (leftSide) {
      bodySizer0.add(leftSide, GetAddLeftSideConfig(config));
    }

    /*
    CR
      FF
    */
    var bodySizer1 = CreatExpandContainer(scene, 1);
    bodySizer0.add(bodySizer1, GetAddContainerConfig());

    /*
    C R
    */
    var bodySizer2 = CreatExpandContainer(scene, 0);
    bodySizer1.add(bodySizer2, GetAddContainerConfig());

    // Add content
    var content = config.content;
    if (content) {
      bodySizer2.add(content, GetAddContentConfig(config));
    }

    // Add Right-side
    var rightSide = config.rightSide;
    if (rightSide) {
      bodySizer2.add(rightSide, GetAddRightSideConfig(config));
    }

    // Add Footer
    var footer = config.footer;
    if (footer) {
      bodySizer1.add(footer, GetAddFooterConfig(config));
    }
  };

  /*
  Elements:
      ```
      HHH
      LCR
      FFR
      ```
  */

  var LayoutMode2 = function LayoutMode2(config) {
    var scene = this.scene;

    // Add Header
    var header = config.header;
    if (header) {
      this.add(header, GetAddHeaderConfig(config));
    }

    /*
    LC R
    FF R
    */
    var bodySizer0 = CreatExpandContainer(scene, 0);
    this.add(bodySizer0, GetAddContainerConfig());

    /*
    LC
      FF
    */
    var bodySizer1 = CreatExpandContainer(scene, 1);
    bodySizer0.add(bodySizer1, GetAddContainerConfig());

    /*
    L C
    */
    var bodySizer2 = CreatExpandContainer(scene, 0);
    bodySizer1.add(bodySizer2, GetAddContainerConfig());

    // Add Left-side
    var leftSide = config.leftSide;
    if (leftSide) {
      bodySizer2.add(leftSide, GetAddLeftSideConfig(config));
    }

    // Add content
    var content = config.content;
    if (content) {
      bodySizer2.add(content, GetAddContentConfig(config));
    }

    // Add Footer
    var footer = config.footer;
    if (footer) {
      bodySizer1.add(footer, GetAddFooterConfig(config));
    }

    // Add Right-side
    var rightSide = config.rightSide;
    if (rightSide) {
      bodySizer0.add(rightSide, GetAddRightSideConfig(config));
    }
  };

  /*
  Elements:
      ```
      HHH
      LCR
      LFR
      ```
  */

  var LayoutMode0 = function LayoutMode0(config) {
    var scene = this.scene;

    // Add Header
    var header = config.header;
    if (header) {
      this.add(header, GetAddHeaderConfig(config));
    }

    /*
    L C R
    L F R
    */
    var bodySizer0 = CreatExpandContainer(scene, 0);
    this.add(bodySizer0, GetAddContainerConfig());

    // Add Left-side
    var leftSide = config.leftSide;
    if (leftSide) {
      bodySizer0.add(leftSide, GetAddLeftSideConfig(config));
    }

    /*
    C
      F
    */
    var bodySizer1 = CreatExpandContainer(scene, 1);
    bodySizer0.add(bodySizer1, GetAddContainerConfig());

    // Add content
    var content = config.content;
    if (content) {
      bodySizer1.add(content, GetAddContentConfig(config));
    }

    // Add Footer
    var footer = config.footer;
    if (footer) {
      bodySizer1.add(footer, GetAddFooterConfig(config));
    }

    // Add Right-side
    var rightSide = config.rightSide;
    if (rightSide) {
      bodySizer0.add(rightSide, GetAddRightSideConfig(config));
    }
  };

  var GetValue$Z = Phaser.Utils.Objects.GetValue;
  var LayoutCallbacks = [LayoutMode0$1, LayoutMode1, LayoutMode2, LayoutMode0];
  var Build = function Build(config) {
    if (config === undefined) {
      config = {};
    }
    var background = config.background;
    var header = config.header;
    var leftSide = config.leftSide;
    var content = config.content;
    var rightSide = config.rightSide;
    var footer = config.footer;

    // Remove from parent
    RemoveFromParent(background);
    RemoveFromParent(header);
    RemoveFromParent(leftSide);
    RemoveFromParent(content);
    RemoveFromParent(rightSide);
    RemoveFromParent(footer);
    this.clear(true);

    // Add Background
    if (background) {
      this.addBackground(background);
    }
    var layoutMode = GetValue$Z(config, 'layoutMode', 0);
    if (typeof layoutMode === 'string') {
      layoutMode = LayoutModesMap[layoutMode.toUpperCase()];
    }
    var layoutCallback = LayoutCallbacks[layoutMode] || LayoutCallbacks[0];
    layoutCallback.call(this, config);
    this.addChildrenMap('background', background);
    this.addChildrenMap('header', header);
    this.addChildrenMap('leftSide', leftSide);
    this.addChildrenMap('content', content);
    this.addChildrenMap('rightSide', rightSide);
    this.addChildrenMap('footer', footer);
    return this;
  };
  var LayoutModesMap = {
    'FFF': 0,
    'LFF': 1,
    'FFR': 2,
    'LFR': 3
  };

  var HolyGrail = /*#__PURE__*/function (_Sizer) {
    _inherits(HolyGrail, _Sizer);
    function HolyGrail(scene, config) {
      var _this;
      _classCallCheck(this, HolyGrail);
      if (config === undefined) {
        config = {};
      }
      config.orientation = 1; // top-to-bottom
      // Create sizer
      _this = _callSuper(this, HolyGrail, [scene, config]);
      _this.type = 'rexHolyGrail';
      _this.build(config);
      return _this;
    }
    return _createClass(HolyGrail);
  }(Sizer);
  var methods$d = {
    build: Build
  };
  Object.assign(HolyGrail.prototype, methods$d);

  var ButtonMethods = {
    getButtonsSizer: function getButtonsSizer(groupName) {
      return this.childrenMap["".concat(groupName, "ButtonsSizer")];
    },
    getButton: function getButton(groupName, index) {
      var buttonsSizer = this.getButtonsSizer(groupName);
      return buttonsSizer ? buttonsSizer.getButton(index) : undefined;
    },
    setButtonEnable: function setButtonEnable(groupName, index, enabled) {
      this.getButtonsSizer(groupName).setButtonEnable(index, enabled);
      return this;
    },
    setLeftButtonEnable: function setLeftButtonEnable(index, enabled) {
      this.childrenMap.leftButtonsSizer.setButtonEnable(index, enabled);
      return this;
    },
    setRightButtonEnable: function setRightButtonEnable(index, enabled) {
      this.childrenMap.rightButtonsSizer.setButtonEnable(index, enabled);
      return this;
    },
    setTopButtonEnable: function setTopButtonEnable(index, enabled) {
      this.childrenMap.topButtonsSizer.setButtonEnable(index, enabled);
      return this;
    },
    setBottomButtonEnable: function setBottomButtonEnable(index, enabled) {
      this.childrenMap.bottomButtonsSizer.setButtonEnable(index, enabled);
      return this;
    },
    toggleButtonEnable: function toggleButtonEnable(groupName, index) {
      this.getButtonsSizer(groupName).toggleButtonEnable(index);
      return this;
    },
    toggleLeftButtonEnable: function toggleLeftButtonEnable(index) {
      this.childrenMap.leftButtonsSizer.toggleButtonEnable(index);
      return this;
    },
    toggleRightButtonEnable: function toggleRightButtonEnable(index) {
      this.childrenMap.rightButtonsSizer.toggleButtonEnable(index);
      return this;
    },
    toggleTopButtonEnable: function toggleTopButtonEnable(index) {
      this.childrenMap.topButtonsSizer.toggleButtonEnable(index);
      return this;
    },
    toggleBottomButtonEnable: function toggleBottomButtonEnable(index) {
      this.childrenMap.bottomButtonsSizer.toggleButtonEnable(index);
      return this;
    },
    getButtonEnable: function getButtonEnable(groupName, index) {
      return this.getButtonsSizer(groupName).getButtonEnable(index);
    },
    getLeftButtonEnable: function getLeftButtonEnable(index) {
      return this.childrenMap.leftButtonsSizer.getButtonEnable(index);
    },
    getRightButtonEnable: function getRightButtonEnable(index) {
      return this.childrenMap.rightButtonsSizer.getButtonEnable(index);
    },
    getTopButtonEnable: function getTopButtonEnable(index) {
      return this.childrenMap.topButtonsSizer.getButtonEnable(index);
    },
    getBottomButtonEnable: function getBottomButtonEnable(index) {
      return this.childrenMap.bottomButtonsSizer.getButtonEnable(index);
    },
    emitButtonClick: function emitButtonClick(groupName, index) {
      var buttonsSizer = this.getButtonsSizer(groupName);
      if (!buttonsSizer) {
        return this;
      }
      buttonsSizer.emitButtonClick(index);
      return this;
    },
    emitLeftButtonClick: function emitLeftButtonClick(index) {
      this.childrenMap.leftButtonsSizer.emitButtonClick(index);
      return this;
    },
    emitRightButtonClick: function emitRightButtonClick(index) {
      this.childrenMap.rightButtonsSizer.emitButtonClick(index);
      return this;
    },
    emitTopButtonClick: function emitTopButtonClick(index) {
      this.childrenMap.topButtonsSizer.emitButtonClick(index);
      return this;
    },
    emitBottomButtonClick: function emitBottomButtonClick(index) {
      this.childrenMap.bottomButtonsSizer.emitButtonClick(index);
      return this;
    },
    getLeftButton: function getLeftButton(index) {
      return this.childrenMap.leftButtonsSizer.getButton(index);
    },
    getRightButton: function getRightButton(index) {
      return this.childrenMap.rightButtonsSizer.getButton(index);
    },
    getTopButton: function getTopButton(index) {
      return this.childrenMap.topButtonsSizer.getButton(index);
    },
    getBottomButton: function getBottomButton(index) {
      return this.childrenMap.bottomButtonsSizer.getButton(index);
    },
    showButton: function showButton(groupName, index) {
      Show(this.getButton(groupName, index));
      return this;
    },
    showLeftButton: function showLeftButton(index) {
      Show(this.getLeftButton(index));
      return this;
    },
    showRightButton: function showRightButton(index) {
      Show(this.getRightButton(index));
      return this;
    },
    showTopButton: function showTopButton(index) {
      Show(this.getTopButton(index));
      return this;
    },
    showBottomButton: function showBottomButton(index) {
      Show(this.getBottomButton(index));
      return this;
    },
    hideButton: function hideButton(groupName, index) {
      Hide(this.getButton(groupName, index));
      return this;
    },
    hideLeftButton: function hideLeftButton(index) {
      Hide(this.getLeftButton(index));
      return this;
    },
    hideRightButton: function hideRightButton(index) {
      Hide(this.getRightButton(index));
      return this;
    },
    hideTopButton: function hideTopButton(index) {
      Hide(this.getTopButton(index));
      return this;
    },
    hideBottomButton: function hideBottomButton(index) {
      Hide(this.getBottomButton(index));
      return this;
    },
    addButton: function addButton(groupName, gameObject) {
      this.getButtonsSizer(groupName).addButton(gameObject);
      return this;
    },
    addLeftButton: function addLeftButton(gameObject) {
      this.addButton('left', gameObject);
      return this;
    },
    addRightButton: function addRightButton(gameObject) {
      this.addButton('right', gameObject);
      return this;
    },
    addTopButton: function addTopButton(gameObject) {
      this.addButton('top', gameObject);
      return this;
    },
    removeButton: function removeButton(groupName, index, destroyChild) {
      this.getButtonsSizer(groupName).removeButton(index, destroyChild);
      return this;
    },
    removeLeftButton: function removeLeftButton(index, destroyChild) {
      this.removeButton('left', index, destroyChild);
      return this;
    },
    removeRightButton: function removeRightButton(index, destroyChild) {
      this.removeButton('right', index, destroyChild);
      return this;
    },
    removeTopButton: function removeTopButton(index, destroyChild) {
      this.removeButton('top', index, destroyChild);
      return this;
    },
    removeBottomButton: function removeBottomButton(index, destroyChild) {
      this.removeButton('bottom', index, destroyChild);
      return this;
    },
    clearButtons: function clearButtons(groupName, destroyChild) {
      this.getButtonsSizer(groupName).clearButtons(destroyChild);
      return this;
    },
    clearLeftButtons: function clearLeftButtons(destroyChild) {
      this.clearButtons('left', destroyChild);
      return this;
    },
    clearRightButtons: function clearRightButtons(destroyChild) {
      this.clearButtons('right', destroyChild);
      return this;
    },
    clearTopButtons: function clearTopButtons(destroyChild) {
      this.clearButtons('top', destroyChild);
      return this;
    },
    clearBottomButtonss: function clearBottomButtonss(destroyChild) {
      this.clearButtons('bottom', destroyChild);
      return this;
    },
    forEachButton: function forEachButton(groupName, callback, scope) {
      this.getButtonsSizer(groupName).forEachButtton(callback, scope);
      return this;
    },
    forEachLeftButton: function forEachLeftButton(callback, scope) {
      this.childrenMap.leftButtonsSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachRightButton: function forEachRightButton(callback, scope) {
      this.childrenMap.rightButtonsSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachTopButton: function forEachTopButton(callback, scope) {
      this.childrenMap.topButtonsSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachBottomButton: function forEachBottomButton(callback, scope) {
      this.childrenMap.bottomButtonsSizer.forEachButtton(callback, scope);
      return this;
    }
  };

  var GetValue$Y = Phaser.Utils.Objects.GetValue;
  var Tabs = /*#__PURE__*/function (_GridSizer) {
    _inherits(Tabs, _GridSizer);
    function Tabs(scene, config) {
      var _this;
      _classCallCheck(this, Tabs);
      if (config === undefined) {
        config = {};
      }
      // Create sizer
      config.column = 3;
      config.row = 3;
      config.columnProportions = [0, 0, 0];
      config.rowProportions = [0, 0, 0];
      var expandPanel = GetValue$Y(config, 'expand.panel', false);
      if (expandPanel) {
        config.columnProportions[1] = 1;
        config.rowProportions[1] = 1;
      }
      _this = _callSuper(this, Tabs, [scene, config]);
      _this.type = 'rexTabs';
      _this.eventEmitter = GetValue$Y(config, 'eventEmitter', _assertThisInitialized(_this));

      // Add elements
      var background = GetValue$Y(config, 'background', undefined);
      var panel = GetValue$Y(config, 'panel', undefined);
      var leftButtons = GetValue$Y(config, 'leftButtons', undefined);
      var leftButtonsBackground = GetValue$Y(config, 'leftButtonsBackground', undefined);
      var leftButtonsSizer;
      var rightButtons = GetValue$Y(config, 'rightButtons', undefined);
      var rightButtonsBackground = GetValue$Y(config, 'rightButtonsBackground', undefined);
      var rightButtonsSizer;
      var topButtons = GetValue$Y(config, 'topButtons', undefined);
      var topButtonsBackground = GetValue$Y(config, 'topButtonsBackground', undefined);
      var topButtonsSizer;
      var bottomButtons = GetValue$Y(config, 'bottomButtons', undefined);
      var bottomButtonsBackground = GetValue$Y(config, 'bottomButtonsBackground', undefined);
      var bottomButtonsSizer;
      var clickConfig = GetValue$Y(config, 'click', undefined);
      if (background) {
        _this.addBackground(background);
      }
      if (panel) {
        _this.add(panel, {
          column: 1,
          row: 1,
          expand: expandPanel
        });
      }
      if (leftButtons) {
        var leftButtonsOffset = GetValue$Y(config, 'space.leftButtonsOffset', 0);
        var leftButtonSpace = GetValue$Y(config, 'space.leftButton', 0);
        var leftButtonExpand = GetValue$Y(config, 'expand.leftButtons', false);
        var leftButtonsAlign = GetValue$Y(config, 'align.leftButtons', 'top');
        leftButtonsSizer = new Buttons$1(scene, {
          groupName: 'left',
          background: leftButtonsBackground,
          buttons: leftButtons,
          orientation: 'y',
          // Top-Bottom
          space: {
            item: leftButtonSpace
          },
          expand: leftButtonExpand,
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        _this.add(leftButtonsSizer, {
          column: 0,
          row: 1,
          align: leftButtonsAlign,
          padding: {
            top: leftButtonsOffset
          },
          expand: leftButtonExpand
        });
      }
      if (rightButtons) {
        var rightButtonsOffset = GetValue$Y(config, 'space.rightButtonsOffset', 0);
        var rightButtonSpace = GetValue$Y(config, 'space.rightButton', 0);
        var rightButtonExpand = GetValue$Y(config, 'expand.rightButtons', false);
        var rightButtonsAlign = GetValue$Y(config, 'align.rightButtons', 'top');
        rightButtonsSizer = new Buttons$1(scene, {
          groupName: 'right',
          background: rightButtonsBackground,
          buttons: rightButtons,
          orientation: 'y',
          // Top-Bottom
          space: {
            item: rightButtonSpace
          },
          expand: rightButtonExpand,
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        _this.add(rightButtonsSizer, {
          column: 2,
          row: 1,
          align: rightButtonsAlign,
          padding: {
            top: rightButtonsOffset
          },
          expand: rightButtonExpand
        });
      }
      if (topButtons) {
        var toptButtonsOffset = GetValue$Y(config, 'space.topButtonsOffset', 0);
        var topButtonSpace = GetValue$Y(config, 'space.topButton', 0);
        var topButtonExpand = GetValue$Y(config, 'expand.topButtons', false);
        var topButtonsAlign = GetValue$Y(config, 'align.topButtons', 'left');
        topButtonsSizer = new Buttons$1(scene, {
          groupName: 'top',
          background: topButtonsBackground,
          buttons: topButtons,
          orientation: 'x',
          // Left-Right
          space: {
            item: topButtonSpace
          },
          expand: topButtonExpand,
          align: GetValue$Y(config, 'align.topButtons', undefined),
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        _this.add(topButtonsSizer, {
          column: 1,
          row: 0,
          align: topButtonsAlign,
          padding: {
            left: toptButtonsOffset
          },
          expand: topButtonExpand
        });
      }
      if (bottomButtons) {
        var bottomButtonsOffset = GetValue$Y(config, 'space.bottomButtonsOffset', 0);
        var bottomButtonSpace = GetValue$Y(config, 'space.bottomButton', 0);
        var bottomButtonExpand = GetValue$Y(config, 'expand.bottomButtons', false);
        var bottomButtonsAlign = GetValue$Y(config, 'align.bottomButtons', 'left');
        bottomButtonsSizer = new Buttons$1(scene, {
          groupName: 'bottom',
          background: bottomButtonsBackground,
          buttons: bottomButtons,
          orientation: 'x',
          // Left-Right
          space: {
            item: bottomButtonSpace
          },
          expand: bottomButtonExpand,
          align: GetValue$Y(config, 'align.bottomButtons', undefined),
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        _this.add(bottomButtonsSizer, {
          column: 1,
          row: 2,
          align: bottomButtonsAlign,
          padding: {
            left: bottomButtonsOffset
          },
          expand: bottomButtonExpand
        });
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('panel', panel);
      _this.addChildrenMap('leftButtons', leftButtons);
      _this.addChildrenMap('rightButtons', rightButtons);
      _this.addChildrenMap('topButtons', topButtons);
      _this.addChildrenMap('bottomButtons', bottomButtons);
      _this.addChildrenMap('leftButtonsSizer', leftButtonsSizer);
      _this.addChildrenMap('rightButtonsSizer', rightButtonsSizer);
      _this.addChildrenMap('topButtonsSizer', topButtonsSizer);
      _this.addChildrenMap('bottomButtonsSizer', bottomButtonsSizer);
      return _this;
    }
    return _createClass(Tabs);
  }(GridSizer);
  Object.assign(Tabs.prototype, ButtonMethods);

  var Cell = /*#__PURE__*/function () {
    function Cell(parent, config) {
      _classCallCheck(this, Cell);
      this.container = null;
      this._deltaHeight = 0;
      this.setParent(parent);
      // this.resetFromJSON(config);
    }
    _createClass(Cell, [{
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent; // parent: table
        this.parentContainer = parent.getParentContainer();
      }

      // resetFromJSON(o) {
      //     return this;
      // }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        if (fromScene === undefined) {
          fromScene = false;
        }
        if (!fromScene) {
          this.destroyContainer();
        }
        this.deltaHeight = 0;
        this.data = undefined;
        this.container = null;
        this.parent = undefined;
        this.parentContainer = undefined;
      }
    }, {
      key: "table",
      get: function get() {
        return this.parent;
      }
    }, {
      key: "scrollMode",
      get: function get() {
        return this.parentContainer.scrollMode;
      }
    }, {
      key: "colIndx",
      get: function get() {
        return this.parent.cellIndxeToColIndex(this.index);
      }
    }, {
      key: "rowIndx",
      get: function get() {
        return this.parent.cellIndxeToRowIndex(this.index);
      }
    }, {
      key: "getContainer",
      value: function getContainer() {
        return this.container;
      }
    }, {
      key: "setContainer",
      value: function setContainer(container) {
        if (!container) {
          this.destroyContainer();
          return this;
        }
        if (this.container) {
          this.container.destroy();
        }
        this.container = container;
        this.parentContainer.add(container);
        return this;
      }
    }, {
      key: "destroyContainer",
      value: function destroyContainer() {
        if (this.container) {
          this.container.destroy();
          this.container = null;
        }
        return this;
      }
    }, {
      key: "popContainer",
      value: function popContainer() {
        if (this.container) {
          var container = this.container;
          this.container = null;
          this.parentContainer.remove(container);
          return container;
        } else {
          return null;
        }
      }
    }, {
      key: "setXY",
      value: function setXY(x, y) {
        if (this.container) {
          this.parentContainer.setChildLocalPosition(this.container, x, y);
        }
        return this;
      }
    }, {
      key: "setCellContainerAlign",
      value: function setCellContainerAlign(align) {
        if (typeof align === 'string') {
          align = AlignConst[align];
        }
        this.cellContainerAlign = align;
        return this;
      }
    }, {
      key: "deltaHeight",
      get: function get() {
        return this._deltaHeight;
      },
      set: function set(deltaHeight) {
        if (deltaHeight == null) {
          deltaHeight = 0;
        }
        var table = this.parent;
        if (this._deltaHeight === 0 && deltaHeight !== 0) {
          table.nonZeroDeltaHeightCount++;
        } else if (this._deltaHeight !== 0 && deltaHeight === 0) {
          table.nonZeroDeltaHeightCount--;
        }
        var isTableHeightChanged = this._deltaHeight !== deltaHeight;
        this._deltaHeight = deltaHeight;
        if (isTableHeightChanged) {
          table.resetTotalRowsHeight();
          var eventName = this.scrollMode === 0 ? 'cellheightchange' : 'cellwidthchange';
          this.parentContainer.emit(eventName, this, this.container, this.parentContainer);
        }
      }
    }, {
      key: "deltaWidth",
      get: function get() {
        return this.deltaHeight;
      },
      set: function set(deltaWidth) {
        this.deltaHeight = deltaWidth;
      }
    }, {
      key: "setDeltaHeight",
      value: function setDeltaHeight(deltaHeight) {
        this.deltaHeight = deltaHeight;
        return this;
      }
    }, {
      key: "setDeltaWidth",
      value: function setDeltaWidth(deltaWidth) {
        this.deltaHeight = deltaWidth;
        return this;
      }
    }, {
      key: "height",
      get: function get() {
        if (this.scrollMode === 0) {
          return this.deltaHeight + this.parent.defaultCellHeight;
        } else {
          return this.parent.defaultCellWidth;
        }
      },
      set: function set(height) {
        // Only worked when scrollMode is 0
        if (this.scrollMode === 1) {
          return;
        }
        this.setDeltaHeight(height - this.parent.defaultCellHeight);
      }
    }, {
      key: "setHeight",
      value: function setHeight(height) {
        // Only worked when scrollMode is 0
        this.height = height;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        if (this.scrollMode === 0) {
          return this.parent.defaultCellWidth;
        } else {
          return this.deltaHeight + this.parent.defaultCellHeight;
        }
      },
      set: function set(width) {
        // Only worked when scrollMode is 1
        if (this.scrollMode === 0) {
          return;
        }
        this.setDeltaHeight(width - this.parent.defaultCellHeight);
      }
    }, {
      key: "setWidth",
      value: function setWidth(width) {
        this.width = width;
        return this;
      }
    }, {
      key: "scene",
      get: function get() {
        return this.parentContainer.scene;
      }
    }]);
    return Cell;
  }();
  Object.assign(Cell.prototype, DataMethods);

  var GetValue$X = Phaser.Utils.Objects.GetValue;
  var SpliceOne = Phaser.Utils.Array.SpliceOne;
  var Table = /*#__PURE__*/function () {
    function Table(parent, config) {
      _classCallCheck(this, Table);
      this.parent = parent; // parent: GridTable game object (Container)
      this.cells = [];
      this.cellPool = new Stack();
      this.resetFromJSON(config);
    }
    _createClass(Table, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        if (o === undefined) {
          o = {};
        }
        this.colCount = undefined;
        this.nonZeroDeltaHeightCount = 0;
        this.resetTotalRowsHeight();
        var cellHeight = o.cellHeight;
        if (cellHeight === undefined) {
          cellHeight = 30;
        }
        var cellWidth = o.cellWidth;
        if (cellWidth === undefined) {
          cellWidth = 30;
        }
        this.setDefaultCellHeight(cellHeight);
        this.setDefaultCellWidth(cellWidth);
        this.initCells(GetValue$X(o, 'cellsCount', 0));
        this.setColumnCount(GetValue$X(o, 'columns', 1));
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        // GridTable is destroyed, all cell containers will also be destroyed too
        // Don't have to freeCell
        this.cellPool.destroy();
        this.cells = undefined;
        this.parent = undefined;
      }
    }, {
      key: "defaultCellHeightMode",
      get: function get() {
        return this.nonZeroDeltaHeightCount === 0;
      }
    }, {
      key: "setDefaultCellHeight",
      value: function setDefaultCellHeight(height) {
        this.defaultCellHeight = height;
        return this;
      }
    }, {
      key: "setDefaultCellWidth",
      value: function setDefaultCellWidth(width) {
        this.defaultCellWidth = width;
        return this;
      }
    }, {
      key: "initCells",
      value: function initCells(size) {
        var cells = this.cells;
        cells.length = size;
        for (var i = 0; i < size; i++) {
          cells[i] = null;
        }
        return this;
      }
    }, {
      key: "insertNewCells",
      value: function insertNewCells(cellIdx, count) {
        var cells = this.cells;
        if (cellIdx === cells.length) {
          // append at end of array
          var endIdx = cellIdx + count;
          cells.legth = endIdx;
          for (var i = cellIdx; i < endIdx; i++) {
            cells[i] = null;
          }
        } else {
          var _this$cells;
          var newCells = [];
          newCells.length = count;
          for (var i = 0; i < count; i++) {
            newCells[i] = null;
          }
          (_this$cells = this.cells).splice.apply(_this$cells, [cellIdx, 0].concat(newCells));
        }
        this.resetTotalRowsHeight();
        return this;
      }
    }, {
      key: "removeCells",
      value: function removeCells(cellIdx, count) {
        var endIdx = cellIdx + count;
        for (var i = cellIdx; i < endIdx; i++) {
          this.freeCell(i);
        }
        if (endIdx === this.cells.length) {
          // remove until end of array
          this.cells.length = cellIdx;
        } else {
          if (count === 1) {
            SpliceOne(this.cells, cellIdx);
          } else {
            this.cells.splice(cellIdx, count);
          }
          this.buildCellIndex(cellIdx);
        }
        this.resetTotalRowsHeight();
        return this;
      }
    }, {
      key: "setColumnCount",
      value: function setColumnCount(cnt) {
        this.colCount = cnt;
        this.resetTotalRowsHeight();
        return this;
      }
    }, {
      key: "rowCount",
      get: function get() {
        return Math.ceil(this.cells.length / this.colCount);
      }
    }, {
      key: "cellsCount",
      get: function get() {
        return this.cells.length;
      }
    }, {
      key: "isValidCellIdx",
      value: function isValidCellIdx(idx) {
        return idx >= 0 && idx < this.cells.length;
      }
    }, {
      key: "heightToRowIndex",
      value: function heightToRowIndex(height, roundMode) {
        if (roundMode === undefined) {
          roundMode = 0;
        }
        /*
        roundMode:
        - 0 : floor
        - 1 : ceil
        - 2 :             
            - Default : floor
            - Vary : plus one if rowIdx is an integer, else floor
        */

        if (height === 0) {
          return 0;
        }

        // defaultCellHeightMode
        if (this.defaultCellHeightMode) {
          var rowIdx = height / this.defaultCellHeight;
          switch (roundMode) {
            case 1:
              rowIdx = Math.ceil(rowIdx);
              break;
            default:
              // 0, 2
              rowIdx = Math.floor(rowIdx);
              break;
          }
          return rowIdx;
        }

        // count cell height one by one
        var rowCount = this.rowCount;
        var remainder = height,
          isValidIdx;
        var rowHeight,
          rowIdx = 0;
        while (1) {
          rowHeight = this.getRowHeight(rowIdx);
          remainder -= rowHeight;
          isValidIdx = rowIdx >= 0 && rowIdx < rowCount;
          if (remainder > 0 && isValidIdx) {
            rowIdx += 1;
          } else if (remainder === 0) {
            if (roundMode === 2) {
              rowIdx += 1;
            }
            return rowIdx;
          } else {
            if (roundMode === 1) {
              var preRowIdx = rowIdx;
              rowIdx += 1;
              isValidIdx = rowIdx >= 0 && rowIdx < rowCount;
              if (!isValidIdx) {
                rowIdx = preRowIdx;
              }
            }
            return rowIdx;
          }
        }
      }
    }, {
      key: "widthToColIndex",
      value: function widthToColIndex(width, isCeil) {
        if (width === 0) {
          return 0;
        }
        var colIdx = width / this.defaultCellWidth;
        if (isCeil) {
          colIdx = Math.ceil(colIdx);
        } else {
          colIdx = Math.floor(colIdx);
        }
        return colIdx;
      }
    }, {
      key: "colRowToCellIndex",
      value: function colRowToCellIndex(colIdx, rowIdx) {
        if (colIdx >= this.colCount) {
          return null;
        }
        return rowIdx * this.colCount + colIdx;
      }
    }, {
      key: "rowIndexToHeight",
      value: function rowIndexToHeight(start, end) {
        // defaultCellHeightMode
        if (this.defaultCellHeightMode) {
          return (end - start + 1) * this.defaultCellHeight;
        }
        var h,
          sum = 0;
        for (var i = start; i <= end; i++) {
          h = this.getRowHeight(i);
          sum += h;
        }
        return sum;
      }
    }, {
      key: "colIndexToWidth",
      value: function colIndexToWidth(start, end) {
        return (end - start + 1) * this.defaultCellWidth;
      }
    }, {
      key: "getRowHeight",
      value: function getRowHeight(rowIdx) {
        var cnt = this.colCount;
        // single column
        if (cnt <= 1) {
          return this.getCellHeight(this.colRowToCellIndex(0, rowIdx));
        }

        // multiple columns, get the maximum height
        var maxHeight = 0,
          cellHeight;
        for (var i = 0; i < cnt; i++) {
          cellHeight = this.getCellHeight(this.colRowToCellIndex(i, rowIdx));
          if (maxHeight < cellHeight) maxHeight = cellHeight;
        }
        return maxHeight;
      }
    }, {
      key: "getColWidth",
      value: function getColWidth(idx) {
        return this.defaultCellWidth;
      }
    }, {
      key: "getCellHeight",
      value: function getCellHeight(cellIdx) {
        if (!this.isValidCellIdx(cellIdx)) {
          return 0;
        }
        var cellHeight;
        if (this.defaultCellHeightMode) cellHeight = this.defaultCellHeight;else {
          var cell = this.getCell(cellIdx, false);
          var deltaHeight = cell ? cell.deltaHeight : 0;
          cellHeight = this.defaultCellHeight + deltaHeight;
        }
        return cellHeight;
      }
    }, {
      key: "resetTotalRowsHeight",
      value: function resetTotalRowsHeight() {
        this._totalRowsHeight = null;
      }
    }, {
      key: "totalRowsHeight",
      get: function get() {
        if (this._totalRowsHeight === null) {
          this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1);
        }
        return this._totalRowsHeight;
      }
    }, {
      key: "totalColumnWidth",
      get: function get() {
        return this.colCount * this.defaultCellWidth;
      }
    }, {
      key: "cellIndxeToColIndex",
      value: function cellIndxeToColIndex(cellIdx) {
        return cellIdx % this.colCount;
      }
    }, {
      key: "cellIndxeToRowIndex",
      value: function cellIndxeToRowIndex(cellIdx) {
        return Math.floor(cellIdx / this.colCount);
      }
    }, {
      key: "getCell",
      value: function getCell(cellIdx, createNewCell) {
        if (!this.isValidCellIdx(cellIdx)) {
          return null;
        }
        if (createNewCell === undefined) {
          createNewCell = true;
        }
        if (this.cells[cellIdx] === null && createNewCell) {
          var cell = this.newCell(cellIdx);
          this.cells[cellIdx] = cell;
        }
        return this.cells[cellIdx];
      }
    }, {
      key: "newCell",
      value: function newCell(cellIdx) {
        var cell = this.cellPool.pop();
        if (cell === null) {
          cell = new Cell(this);
        } else {
          cell.setParent(this);
        }
        cell.index = cellIdx;
        return cell;
      }
    }, {
      key: "buildCellIndex",
      value: function buildCellIndex(startIdx) {
        if (startIdx === undefined) {
          startIdx = 0;
        }
        var cells = this.cells,
          cell;
        for (var i = startIdx, len = cells.length; i < len; i++) {
          cell = cells[i];
          if (cell) {
            cell.index = i;
          }
        }
        return this;
      }
    }, {
      key: "getParentContainer",
      value: function getParentContainer() {
        return this.parent;
      }
    }, {
      key: "freeCell",
      value: function freeCell(cell) {
        if (typeof cell === 'number') {
          cell = this.cells[cell];
        }
        if (!cell) {
          return this;
        }
        cell.destroy();
        this.cellPool.push(cell);
        return this;
      }
    }]);
    return Table;
  }();

  var SetTableOY = function SetTableOY(oy) {
    var table = this.table;
    var topTableOY = this.topTableOY;
    var bottomTableOY = this.bottomTableOY;
    var tableOYExceedTop = oy > this.topTableOY;
    var tableOYExeceedBottom = oy < this.bottomTableOY;
    if (this.clampTableOXY) {
      var rowCount = table.rowCount;
      var visibleRowCount = table.heightToRowIndex(this.instHeight, 1);

      // less then 1 page
      if (rowCount < visibleRowCount) {
        oy = 0;
      } else if (tableOYExceedTop) {
        oy = topTableOY;
      } else if (tableOYExeceedBottom) {
        oy = bottomTableOY;
      }
    }
    if (this._tableOY !== oy) {
      this._tableOY = oy;
    }
    if (tableOYExceedTop) {
      if (!this.execeedTopState) {
        this.emit('execeedtop', this, oy, topTableOY);
      }
    }
    this.execeedTopState = tableOYExceedTop;
    if (tableOYExeceedBottom) {
      if (!this.execeedBottomState) {
        this.emit('execeedbottom', this, oy, bottomTableOY);
      }
    }
    this.execeedBottomState = tableOYExeceedBottom;
    return this;
  };

  var SetTableOX = function SetTableOX(ox) {
    var table = this.table;
    var leftTableOX = this.leftTableOX;
    var rightTableOX = this.rightTableOX;
    var tableOXExeceedLeft = ox > this.leftTableOX;
    var tableOXExeceedRight = ox < this.rightTableOX;
    if (this.clampTableOXY) {
      var colCount = table.colCount;
      var visibleColCount = table.widthToColIndex(this.instWidth, true);

      // less then 1 page            
      if (colCount < visibleColCount) {
        ox = 0;
      } else if (tableOXExeceedLeft) {
        ox = leftTableOX;
      } else {
        // var tableVisibleWidth = this.tableVisibleWidth;
        if (tableOXExeceedRight) ox = rightTableOX;
      }
    }
    if (this._tableOX !== ox) {
      this._tableOX = ox;
    }
    if (tableOXExeceedLeft) {
      if (!this.execeedLeftState) {
        this.emit('execeedleft', this, ox, leftTableOX);
      }
    }
    this.execeedLeftState = tableOXExeceedLeft;
    if (tableOXExeceedRight) {
      if (!this.execeedRightState) {
        this.emit('execeedright', this, ox, rightTableOX);
      }
    }
    this.execeedRightState = tableOXExeceedRight;
    return this;
  };

  var MaskToGameObject = function MaskToGameObject(mask) {
    return mask.hasOwnProperty('geometryMask') ? mask.geometryMask : mask.bitmapMask;
  };

  var Intersects = Phaser.Geom.Intersects.RectangleToRectangle;
  var Overlaps = Phaser.Geom.Rectangle.Overlaps;
  var MaskChildren = function MaskChildren(parent, mask, children) {
    if (!mask) {
      return;
    }
    if (children === undefined) {
      children = parent.getAllChildren();
    }
    var parentBounds = parent.getBounds();
    var maskGameObject = MaskToGameObject(mask);
    var child, childBounds, visiblePointsNumber;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child === maskGameObject) {
        continue;
      }
      if (!IsVisible(child)) {
        // Child is invisible before masking
        continue;
      }
      if (child.getBounds) {
        childBounds = child.getBounds(childBounds);
        visiblePointsNumber = ContainsPoints(parentBounds, childBounds);
        switch (visiblePointsNumber) {
          case 4:
            // 4 points are all inside visible window, set visible
            ShowAll(parent, child);
            break;
          case 0:
            // No point is inside visible window
            // Parent intersects with child, or parent is inside child, set visible, and apply mask
            if (Intersects(parentBounds, childBounds) || Overlaps(parentBounds, childBounds)) {
              ShowSome(parent, child, mask);
            } else {
              // Set invisible
              ShowNone(parent, child);
            }
            break;
          default:
            // Part of points are inside visible window, set visible, and apply mask
            ShowSome(parent, child, mask);
            break;
        }
      } else {
        ShowSome(parent, child, mask);
      }
    }
  };
  var IsVisible = function IsVisible(gameObject) {
    if (!gameObject.displayList) {
      return false;
    }
    while (1) {
      var localState = gameObject.rexContainer;
      if (!localState) {
        // Top game object
        return gameObject.visible;
      } else if (localState.visible) {
        var parent = localState.parent;
        if (parent) {
          // Test parent's visible
          gameObject = parent;
          continue;
        } else {
          // Top visible game object
          return true;
        }
      } else {
        // Current game object is invisible
        return false;
      }
    }
  };
  var ContainsPoints = function ContainsPoints(rectA, rectB) {
    var top = rectB.top,
      bottom = rectB.bottom,
      left = rectB.left,
      right = rectB.right;
    var result = 0;
    result += rectA.contains(left, top) ? 1 : 0;
    result += rectA.contains(left, bottom) ? 1 : 0;
    result += rectA.contains(right, top) ? 1 : 0;
    result += rectA.contains(right, bottom) ? 1 : 0;
    return result;
  };
  var ShowAll = function ShowAll(parent, child, mask) {
    if (!child.hasOwnProperty('isRexContainerLite')) {
      if (child.clearMask) {
        child.clearMask();
      }
      parent.setChildMaskVisible(child, true);
    } else {
      child.syncChildrenEnable = false;
      parent.setChildMaskVisible(child, true);
      child.syncChildrenEnable = true;
    }
  };
  var ShowSome = function ShowSome(parent, child, mask) {
    if (!child.hasOwnProperty('isRexContainerLite')) {
      if (child.setMask) {
        child.setMask(mask);
      }
      parent.setChildMaskVisible(child, true);
    } else {
      child.syncChildrenEnable = false;
      parent.setChildMaskVisible(child, true);
      child.syncChildrenEnable = true;
    }
  };
  var ShowNone = function ShowNone(parent, child, mask) {
    if (!child.hasOwnProperty('isRexContainerLite')) {
      if (child.clearMask) {
        child.clearMask();
      }
      parent.setChildMaskVisible(child, false);
    } else {
      child.syncChildrenEnable = false;
      parent.setChildMaskVisible(child, false);
      child.syncChildrenEnable = true;
    }
  };

  var GetValue$W = Phaser.Utils.Objects.GetValue;
  var MASKUPDATEMODE = {
    update: 0,
    everyTick: 1
  };
  var ChildrenMaskMethods = {
    setupChildrenMask: function setupChildrenMask(config) {
      if (config === false) {
        // No children mask
        return this;
      }
      this.setMaskUpdateMode(GetValue$W(config, 'updateMode', 0));
      this.enableChildrenMask(GetValue$W(config, 'padding', 0));
      this.setMaskLayer(GetValue$W(config, 'layer', undefined));
      this.startMaskUpdate();
      return this;
    },
    destroyChildrenMask: function destroyChildrenMask() {
      if (!this.childrenMask) {
        return this;
      }
      this.stopMaskUpdate();
      this.childrenMask.destroy();
      this.childrenMask = undefined;
      return this;
    },
    setMaskUpdateMode: function setMaskUpdateMode(mode) {
      if (typeof mode === 'string') {
        mode = MASKUPDATEMODE[mode];
      }
      this.maskUpdateMode = mode;
      return this;
    },
    startMaskUpdate: function startMaskUpdate() {
      this.scene.game.events.on('poststep', this.maskChildren, this);
    },
    stopMaskUpdate: function stopMaskUpdate() {
      this.scene.game.events.off('poststep', this.maskChildren, this);
    },
    enableChildrenMask: function enableChildrenMask(maskPadding) {
      var maskGameObject = AddChildMask.call(this, null, this, 0, maskPadding);
      this.childrenMask = maskGameObject.createGeometryMask();
      // this.childrenMask is a mask object, not a (Graphics) game object
      return this;
    },
    setMaskChildrenFlag: function setMaskChildrenFlag(value) {
      if (value === undefined) {
        value = true;
      }
      this.maskChildrenFlag = value;
      return this;
    },
    setMaskLayer: function setMaskLayer(layer) {
      // To reduce amount of masked game object
      this.maskLayer = layer;
      return this;
    },
    maskChildren: function maskChildren() {
      if (!this.childrenMask ||
      // No childrenMask
      !this.maskChildrenFlag ||
      // No maskChildrenFlag set
      this.alpha === 0 || !this.visible // Parent is not visible
      ) {
        return this;
      }
      if (this.privateRenderLayer) {
        this.privateRenderLayer.setMask(this.childrenMask);
      } else if (this.maskLayer) {
        // 1. Add parent and children into layer
        this.addToLayer(this.maskLayer);
        // 2. Mask this layer
        this.maskLayer.setMask(this.childrenMask);
      } else {
        MaskChildren(this, this.childrenMask);
      }
      if (this.maskUpdateMode === 0) {
        this.maskChildrenFlag = false;
      }
      return this;
    },
    layoutChildrenMask: function layoutChildrenMask() {
      if (!this.childrenMask) {
        return this;
      }
      var maskGameObject = MaskToGameObject(this.childrenMask);
      maskGameObject.setPosition().resize();
      this.resetChildPositionState(maskGameObject);
      return this;
    }
  };

  var ShowCells = function ShowCells() {
    if (this.cellsCount === 0) {
      return;
    }
    var table = this.table;
    this.startRowIndex = Math.max(table.heightToRowIndex(-this.tableOY, 2), 0);
    var rowIndex = this.startRowIndex;
    var startColumnIndex = Math.max(table.widthToColIndex(-this.tableOX), 0);
    var columnIndex = startColumnIndex;
    var cellIdx = table.colRowToCellIndex(columnIndex, rowIndex);
    var bottomBound = this.bottomBound;
    var rightBound = this.rightBound;
    var lastIdx = table.cellsCount - 1;
    var lastColIdx = table.colCount - 1;
    var startCellTLX = this.getCellTLX(columnIndex),
      cellTLX = startCellTLX;
    var cellTLY = this.getCellTLY(rowIndex);
    while (cellTLY < bottomBound && cellIdx <= lastIdx) {
      if (this.table.isValidCellIdx(cellIdx)) {
        var cell = table.getCell(cellIdx, true);
        this.visibleCells.set(cell);
        if (!this.preVisibleCells.contains(cell)) {
          this.showCell(cell);
        }
        var x, y;
        if (this.scrollMode === 0) {
          x = cellTLX;
          y = cellTLY;
        } else {
          x = cellTLY;
          y = cellTLX;
        }
        if (cell.cellContainerAlign == null) {
          cell.setXY(x, y);
        } else {
          var cellContainer = cell.getContainer();
          AlignIn(cellContainer, x, y, cell.width, cell.height, cell.cellContainerAlign);
          cell.setXY(cellContainer.x, cellContainer.y);
        }
      }
      if (cellTLX < rightBound && columnIndex < lastColIdx) {
        cellTLX += table.getColWidth(columnIndex);
        columnIndex += 1;
      } else {
        cellTLX = startCellTLX;
        cellTLY += table.getRowHeight(rowIndex);
        columnIndex = startColumnIndex;
        rowIndex += 1;
      }
      cellIdx = table.colRowToCellIndex(columnIndex, rowIndex);
    }
  };

  var ShowCell = function ShowCell(cell) {
    // Attach container to cell by cell.setContainer(container) under this event
    var reusedCellContainer = null;
    var cellContainer = cell.getContainer();
    if (cellContainer) {
      reusedCellContainer = cellContainer;
      cell.popContainer();
    } else if (this.cellContainersPool) {
      reusedCellContainer = this.cellContainersPool.getFirstDead();
      if (reusedCellContainer !== null) {
        // Reuse this game object
        reusedCellContainer.setActive(true).setVisible(true);
      }
    }
    this.emit('cellvisible', cell, reusedCellContainer, this);
    if (this.cellContainersPool) {
      var cellContainer = cell.getContainer();
      if (cellContainer) {
        if (reusedCellContainer === null) {
          this.cellContainersPool.add(cellContainer); // New cell container, add to pool
        } else if (reusedCellContainer !== cellContainer) {
          // Why reusedCellContainer is not equal to cellContainer?
          this.cellContainersPool.add(cellContainer); // New cell container, add to pool
          this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
        }
      } else {
        // No cell container added
        if (reusedCellContainer !== null) {
          this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
        }
      }
    }
  };

  var GetCellTLX = function GetCellTLX(colIdx) {
    var ox = this.scrollMode === 0 ? this.topLeftX : this.topLeftY;
    var x = this.tableOX + this.table.colIndexToWidth(0, colIdx - 1) + ox;
    return x;
  };

  var GetCellTLY = function GetCellTLY(rowIdx) {
    var oy = this.scrollMode === 0 ? this.topLeftY : this.topLeftX;
    var y = this.tableOY + this.table.rowIndexToHeight(0, rowIdx - 1) + oy;
    return y;
  };

  var HideCells = function HideCells() {
    var preList = this.preVisibleCells;
    var curList = this.visibleCells;
    preList.iterate(function (cell) {
      if (!curList.contains(cell)) {
        this.hideCell(cell);
      }
    }, this);
  };

  var HideCell = function HideCell(cell) {
    // Option: pop container of cell by cell.popContainer() under this event 
    this.emit('cellinvisible', cell);
    if (this.cellContainersPool) {
      var cellContainer = cell.popContainer(); // null if already been removed
      if (cellContainer) {
        this.cellContainersPool.killAndHide(cellContainer);
      }
    }
    cell.destroyContainer(); // Destroy container of cell
  };

  var UpdateTable = function UpdateTable(refresh) {
    if (refresh === undefined) {
      refresh = false;
    }
    if (refresh) {
      ClearVisibleCellIndexes.call(this);
      this.hideCells();
    }
    ClearVisibleCellIndexes.call(this);
    this.showCells();
    this.hideCells();
    this.setMaskChildrenFlag();
    return this;
  };
  var ClearVisibleCellIndexes = function ClearVisibleCellIndexes() {
    var tmp = this.preVisibleCells;
    this.preVisibleCells = this.visibleCells;
    this.visibleCells = tmp;
    this.visibleCells.clear();
  };

  var IsCellVisible = function IsCellVisible(cellIdx) {
    var cell = this.table.getCell(cellIdx, false);
    return cell && this.visibleCells.contains(cell);
  };

  var PointToCellIndex = function PointToCellIndex(x, y) {
    y -= this.y + this.topLeftY;
    x -= this.x + this.topLeftX;
    var offsetTableOY = this.tableOY - (this.scrollMode === 0 ? y : x);
    var offsetTableOX = this.tableOX - (this.scrollMode === 0 ? x : y);
    var table = this.table;
    var rowIdx = table.heightToRowIndex(-offsetTableOY, 0);
    var colIdx = table.widthToColIndex(-offsetTableOX);
    var cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
    if (cellIdx === null) {
      return null;
    }
    if (!this.isCellVisible(cellIdx)) {
      return null;
    }
    return cellIdx;
  };
  var PointToCellContainer = function PointToCellContainer(x, y) {
    var cellIdx = PointToCellIndex.call(this, x, y);
    if (cellIdx === null) {
      return undefined;
    }
    return this.getCellContainer(cellIdx);
  };

  // For when you know this Set will be modified during the iteration
  var EachVisibleCell = function EachVisibleCell(callback, scope) {
    this.visibleCells.each(callback, scope);
    return this;
  };

  // For when you absolutely know this Set won't be modified during the iteration
  var IterateVisibleCell = function IterateVisibleCell(callback, scope) {
    this.visibleCells.iterate(callback, scope);
    return this;
  };
  var EachCell = function EachCell(callback, scope) {
    this.table.cells.slice().forEach(callback, scope);
    return this;
  };
  var IterateCell = function IterateCell(callback, scope) {
    this.table.cells.forEach(callback, scope);
    return this;
  };

  var SetCellsCount = function SetCellsCount(count) {
    var cellsCount = this.cellsCount;
    if (cellsCount === count) {
      return this;
    }
    if (cellsCount > count) {
      this.removeCells(count, cellsCount - count);
    } else {
      // cellsCount < count
      this.insertNewCells(cellsCount, count - cellsCount);
    }
    return this;
  };

  var Clamp$4 = Phaser.Math.Clamp;
  var InsertNewCells = function InsertNewCells(cellIdx, count) {
    if (_typeof(cellIdx) === 'object') {
      cellIdx = cellIdx.index;
    }
    if (count === undefined) {
      count = 1;
    }
    if (count <= 0) {
      return this;
    }
    cellIdx = Clamp$4(cellIdx, 0, this.cellsCount);
    this.table.insertNewCells(cellIdx, count);
    return this;
  };

  var RemoveCells = function RemoveCells(cellIdx, count) {
    if (_typeof(cellIdx) === 'object') {
      cellIdx = cellIdx.index;
    }
    if (count === undefined) {
      count = 1;
    }
    if (cellIdx < 0) {
      count += cellIdx;
      cellIdx = 0;
    }
    if (count <= 0) {
      return this;
    }
    // out-of-range
    if (cellIdx > this.cellsCount) {
      return this;
    }
    var cell;
    for (var i = cellIdx, endIdx = cellIdx + count; i < endIdx; i++) {
      cell = this.getCell(i, false);
      if (cell) {
        if (this.visibleCells.contains(cell)) {
          HideCell.call(this, cell);
          this.visibleCells["delete"](cell);
        }
        this.preVisibleCells["delete"](cell);
      }
    }
    this.table.removeCells(cellIdx, count);
    return this;
  };

  var SetColumnCount = function SetColumnCount(count) {
    if (this.table.colCount === count) {
      return this;
    }
    this.table.setColumnCount(count);
    return this;
  };

  var SetGridSize = function SetGridSize(colCount, rowCount) {
    this.setCellsCount(colCount * rowCount);
    this.table.setColumnCount(colCount);
    return this;
  };

  var UpdateVisibleCell = function UpdateVisibleCell(cellIdx) {
    var cell = this.table.getCell(cellIdx, false);
    if (!cell || !cell.container) {
      return this;
    }
    ShowCell.call(this, cell);
    return this;
  };

  var methods$c = {
    setTableOY: SetTableOY,
    setTableOX: SetTableOX,
    showCells: ShowCells,
    showCell: ShowCell,
    getCellTLX: GetCellTLX,
    getCellTLY: GetCellTLY,
    hideCells: HideCells,
    hideCell: HideCell,
    updateTable: UpdateTable,
    isCellVisible: IsCellVisible,
    pointToCellIndex: PointToCellIndex,
    pointToCellContainer: PointToCellContainer,
    eachVisibleCell: EachVisibleCell,
    iterateVisibleCell: IterateVisibleCell,
    eachCell: EachCell,
    iterateCell: IterateCell,
    setCellsCount: SetCellsCount,
    insertNewCells: InsertNewCells,
    removeCells: RemoveCells,
    setColumnCount: SetColumnCount,
    setGridSize: SetGridSize,
    updateVisibleCell: UpdateVisibleCell
  };
  Object.assign(methods$c, ChildrenMaskMethods);

  var Group = Phaser.GameObjects.Group;
  var Set$1 = Phaser.Structs.Set;
  var GetValue$V = Phaser.Utils.Objects.GetValue;
  var GridTable$1 = /*#__PURE__*/function (_ContainerLite) {
    _inherits(GridTable, _ContainerLite);
    function GridTable(scene, x, y, width, height, config) {
      var _this;
      _classCallCheck(this, GridTable);
      if (config === undefined) {
        config = {};
      }
      _this = _callSuper(this, GridTable, [scene, x, y, width, height]);
      _this.type = 'rexGridTable';
      _this._tableOX = 0;
      _this._tableOY = 0;
      _this.visibleCells = new Set$1();
      _this.preVisibleCells = new Set$1();
      _this.execeedTopState = false;
      _this.execeedBottomState = false;
      _this.execeedLeftState = false;
      _this.execeedRightState = false;
      var reuseCellContainer = GetValue$V(config, 'reuseCellContainer', false);
      if (reuseCellContainer) {
        _this.cellContainersPool = new Group(scene); // Don't add Group into update list, I will destroy it manually
      }
      var callback = GetValue$V(config, 'cellVisibleCallback', null);
      if (callback !== null) {
        var scope = GetValue$V(config, 'cellVisibleCallbackScope', undefined);
        _this.on('cellvisible', callback, scope);
      }
      callback = GetValue$V(config, 'cellInvisibleCallback', null);
      if (callback !== null) {
        var scope = GetValue$V(config, 'cellInvisibleCallbackScope', undefined);
        _this.on('cellinvisible', callback, scope);
      }
      if (GetValue$V(config, 'enableLayer', false)) {
        _this.enableLayer();
      }
      _this.setupChildrenMask(GetValue$V(config, 'mask', undefined));
      _this.setScrollMode(GetValue$V(config, 'scrollMode', 0));
      _this.setClampMode(GetValue$V(config, 'clamplTableOXY', true));

      // Pre-process cell size
      var cellWidth, cellHeight, columns;
      var scrollY = _this.scrollMode === 0;
      if (scrollY) {
        // scroll y
        cellWidth = config.cellWidth;
        cellHeight = config.cellHeight;
        columns = config.columns;
      } else {
        // scroll x
        cellWidth = config.cellHeight;
        cellHeight = config.cellWidth;
        columns = GetValue$V(config, 'rows', config.columns);
      }
      if (!columns) {
        columns = 1; // Default columns
      }
      _this.expandCellSize = cellWidth === undefined;
      if (_this.expandCellSize) {
        var width = scrollY ? _this.width : _this.height;
        cellWidth = width / columns;
      }
      config.cellWidth = cellWidth;
      config.cellHeight = cellHeight;
      config.columns = columns;
      _this.table = new Table(_assertThisInitialized(_this), config);
      _this.updateTable();
      return _this;
    }
    _createClass(GridTable, [{
      key: "destroy",
      value: function destroy(fromScene) {
        // preDestroy method does not have fromScene parameter
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.destroyChildrenMask();
        this.table.destroy(fromScene);
        this.table = undefined;
        if (this.cellContainersPool) {
          this.cellContainersPool.destroy(true);
          this.cellContainersPool = undefined;
        }
        _get(_getPrototypeOf(GridTable.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setScrollMode",
      value: function setScrollMode(mode) {
        if (typeof mode === 'string') {
          mode = SCROLLMODE[mode.toLowerCase()];
        }
        this.scrollMode = mode;
        return this;
      }
    }, {
      key: "setClampMode",
      value: function setClampMode(mode) {
        if (mode === undefined) {
          mode = true;
        }
        this.clampTableOXY = mode;
        return this;
      }
    }, {
      key: "tableOY",
      get: function get() {
        return this._tableOY;
      },
      set: function set(oy) {
        this.setTableOY(oy).updateTable();
      }
    }, {
      key: "tableOX",
      get: function get() {
        return this._tableOX;
      },
      set: function set(ox) {
        this.setTableOX(ox).updateTable();
      }
    }, {
      key: "setTableOXY",
      value: function setTableOXY(ox, oy) {
        this.setTableOY(oy).setTableOX(ox);
        return this;
      }
    }, {
      key: "addTableOY",
      value: function addTableOY(dy) {
        this.setTableOY(this.tableOY + dy);
        return this;
      }
    }, {
      key: "addTableOX",
      value: function addTableOX(dx) {
        this.setTableOX(this.tableOX + dx);
        return this;
      }
    }, {
      key: "addTableOXY",
      value: function addTableOXY(dx, dy) {
        this.addTableOY(dy).addTableOX(dx);
        return this;
      }
    }, {
      key: "setTableOYByPercentage",
      value: function setTableOYByPercentage(percentage) {
        this.setTableOY(-this.tableVisibleHeight * percentage);
        return this;
      }
    }, {
      key: "getTableOYPercentage",
      value: function getTableOYPercentage() {
        var tableVisibleHeight = this.tableVisibleHeight;
        if (tableVisibleHeight === 0) {
          return 0;
        }
        return this.tableOY / -tableVisibleHeight;
      }
    }, {
      key: "setTableOXByPercentage",
      value: function setTableOXByPercentage(percentage) {
        this.setTableOX(-this.tableVisibleWidth * percentage);
        return this;
      }
    }, {
      key: "getTableOXPercentage",
      value: function getTableOXPercentage() {
        var tableVisibleWidth = this.tableVisibleWidth;
        if (tableVisibleWidth === 0) {
          return 0;
        }
        return this.tableOX / -tableVisibleWidth;
      }
    }, {
      key: "t",
      get: function get() {
        return this.getTableOYPercentage();
      },
      set: function set(value) {
        this.setTableOYByPercentage(value).updateTable();
      }
    }, {
      key: "s",
      get: function get() {
        return this.getTableOXPercentage();
      },
      set: function set(value) {
        this.setTableOXByPercentage(value).updateTable();
      }
    }, {
      key: "scrollToBottom",
      value: function scrollToBottom() {
        this.t = 1;
        // t will be 0 if table does not exceed visible area
        if (this.t === 0) {
          return this;
        }

        // Table height might be expanded while cells are visible        
        do {
          this.t = 1;
        } while (this.t !== 1);
        return this;
      }
    }, {
      key: "scrollToRow",
      value: function scrollToRow(rowIndex) {
        // To get all height of cells
        this.scrollToBottom();
        var height = this.table.rowIndexToHeight(0, rowIndex - 1);
        this.setTableOY(-height).updateTable();
        return this;
      }
    }, {
      key: "scrollToNextRow",
      value: function scrollToNextRow(rowCount) {
        if (rowCount === undefined) {
          rowCount = 1;
        }
        this.scrollToRow(this.startRowIndex + rowCount);
        return this;
      }
    }, {
      key: "getCell",
      value: function getCell(cellIdx) {
        return this.table.getCell(cellIdx, true);
      }
    }, {
      key: "getCellContainer",
      value: function getCellContainer(cellIdx) {
        var cell = this.table.getCell(cellIdx, false);
        var container;
        if (cell) {
          container = cell.getContainer();
        }
        return container;
      }
    }, {
      key: "cellsCount",
      get: function get() {
        return this.table.cellsCount;
      }
    }, {
      key: "columnCount",
      get: function get() {
        return this.table.colCount;
      }
    }, {
      key: "setCellHeight",
      value: function setCellHeight(cellIdx, height) {
        var cell;
        if (typeof cellIdx === 'number') {
          cell = this.table.getCell(cellIdx, true);
        } else {
          cell = cellIdx;
        }
        cell.height = height; // Only worked when scrollMode is 0
        return this;
      }
    }, {
      key: "setCellWidth",
      value: function setCellWidth(cellIdx, width) {
        var cell;
        if (typeof cellIdx === 'number') {
          cell = this.table.getCell(cellIdx, true);
        } else {
          cell = cellIdx;
        }
        cell.width = width; // Only worked when scrollMode is 1
        return this;
      }
    }, {
      key: "instHeight",
      get: function get() {
        return this.scrollMode === 0 ? this.height : this.width;
      }
    }, {
      key: "instWidth",
      get: function get() {
        return this.scrollMode === 0 ? this.width : this.height;
      }
    }, {
      key: "tableHeight",
      get: function get() {
        return this.table.totalRowsHeight;
      }
    }, {
      key: "tableWidth",
      get: function get() {
        return this.table.totalColumnWidth;
      }
    }, {
      key: "topTableOY",
      get: function get() {
        return 0;
      }
    }, {
      key: "bottomTableOY",
      get: function get() {
        return -this.tableVisibleHeight;
      }
    }, {
      key: "leftTableOX",
      get: function get() {
        return 0;
      }
    }, {
      key: "rightTableOX",
      get: function get() {
        return -this.tableVisibleWidth;
      }
    }, {
      key: "tableVisibleHeight",
      get: function get() {
        var h = this.tableHeight - this.instHeight;
        if (h < 0) {
          h = 0;
        }
        return h;
      }
    }, {
      key: "tableVisibleWidth",
      get: function get() {
        var w = this.tableWidth - this.instWidth;
        if (w < 0) {
          w = 0;
        }
        return w;
      }
    }, {
      key: "bottomLeftY",
      get: function get() {
        return -(this.displayHeight * this.originY) + this.displayHeight;
      }
    }, {
      key: "topRightX",
      get: function get() {
        return -(this.displayWidth * this.originX) + this.displayWidth;
      }
    }, {
      key: "topLeftX",
      get: function get() {
        return -(this.displayWidth * this.originX);
      }
    }, {
      key: "topLeftY",
      get: function get() {
        return -(this.displayHeight * this.originY);
      }
    }, {
      key: "bottomBound",
      get: function get() {
        if (this.scrollMode === 0) {
          return this.bottomLeftY;
        } else {
          return this.topRightX;
        }
      }
    }, {
      key: "rightBound",
      get: function get() {
        if (this.scrollMode === 0) {
          return this.topRightX;
        } else {
          return this.bottomLeftY;
        }
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        if (this.width === width && this.height === height) {
          return this;
        }
        _get(_getPrototypeOf(GridTable.prototype), "resize", this).call(this, width, height);
        if (this.expandCellSize) {
          this.table.setDefaultCellWidth(this.instWidth / this.table.colCount);
        }
        this.updateTable(true);

        // Layout children-mask
        this.layoutChildrenMask();
        // Re-mask children
        this.maskChildren();
        return this;
      }
    }]);
    return GridTable;
  }(ContainerLite);

  // mixin
  Object.assign(GridTable$1.prototype, methods$c);
  var SCROLLMODE = {
    v: 0,
    vertical: 0,
    h: 1,
    horizontal: 1
  };

  var InjectProperties$1 = function InjectProperties(table) {
    Object.defineProperty(table, 'childOY', {
      configurable: true,
      get: function get() {
        return table.tableOY;
      },
      set: function set(value) {
        table.tableOY = value;
      }
    });
    Object.defineProperty(table, 'childOX', {
      configurable: true,
      get: function get() {
        return table.tableOX;
      },
      set: function set(value) {
        table.tableOX = value;
      }
    });
    Object.defineProperty(table, 'topChildOY', {
      get: function get() {
        return table.topTableOY;
      }
    });
    Object.defineProperty(table, 'bottomChildOY', {
      get: function get() {
        return table.bottomTableOY;
      }
    });
    Object.defineProperty(table, 'leftChildOX', {
      get: function get() {
        return table.leftTableOX;
      }
    });
    Object.defineProperty(table, 'rightChildOX', {
      get: function get() {
        return table.rightTableOX;
      }
    });
    Object.defineProperty(table, 'childVisibleHeight', {
      get: function get() {
        return table.instHeight;
      }
    });
    Object.defineProperty(table, 'childHeight', {
      get: function get() {
        return table.tableHeight;
      }
    });
    Object.defineProperty(table, 'childVisibleWidth', {
      get: function get() {
        return table.instWidth;
      }
    });
    Object.defineProperty(table, 'childWidth', {
      get: function get() {
        return table.tableWidth;
      }
    });
  };

  var TableOnCellVisible = function TableOnCellVisible(table) {
    table.on('cellvisible', function (cell, cellContainer, table) {
      var callback = this.createCellContainerCallback;
      var scope = this.createCellContainerCallbackScope;
      cell.item = this.items[cell.index];
      cell.items = this.items;
      var cellContainer;
      if (scope) {
        cellContainer = callback.call(scope, cell, cellContainer, table);
      } else {
        cellContainer = callback(cell, cellContainer, table);
      }
      if (cellContainer) {
        if (cell.cellContainerAlign == null && cellContainer.setOrigin) {
          cellContainer.setOrigin(0);
        }
        if (cellContainer.isRexSizer) {
          cellContainer.layout(); // Use original size
        }
      }
      cell.item = undefined;
      cell.items = undefined;
      cell.setContainer(cellContainer);
    }, this);
  };

  var EmitCellEvent = function EmitCellEvent(eventEmitter, eventName, table, x, y, pointer, event) {
    var cellIndex;
    if (y === undefined) {
      cellIndex = x;
    } else {
      cellIndex = table.pointToCellIndex(x, y);
    }
    if (cellIndex === null || cellIndex === undefined) {
      return;
    }
    var cellContainer = table.getCellContainer(cellIndex);
    if (cellContainer) {
      eventEmitter.emit(eventName, cellContainer, cellIndex, pointer, event);
    }
  };

  var PointerUpDownCell = function PointerUpDownCell(table, tableConfig) {
    table.on('pointerdown', function (pointer, localX, localY, event) {
      EmitCellEvent(this.eventEmitter, 'cell.down', table, pointer.worldX, pointer.worldY, pointer, event);
    }, this).on('pointerup', function (pointer, localX, localY, event) {
      EmitCellEvent(this.eventEmitter, 'cell.up', table, pointer.worldX, pointer.worldY, pointer, event);
    }, this);
  };

  var OverCell = function OverCell(table, tableConfig) {
    table.on('pointermove', OnMove, this).on('pointerover', OnMove, this).on('pointerout', OnOut, this); // pointer-up is included too
  };
  var OnMove = function OnMove(pointer, localX, localY, event) {
    var table = this.childrenMap.child;
    var cellIndex = table.pointToCellIndex(pointer.worldX, pointer.worldY);
    if (cellIndex === table.input.lastOverCellIndex) {
      return;
    }
    var preCellIndex = table.input.lastOverCellIndex;
    table.input.lastOverCellIndex = cellIndex;
    EmitCellEvent(this.eventEmitter, 'cell.out', table, preCellIndex, undefined, pointer, event);
    EmitCellEvent(this.eventEmitter, 'cell.over', table, cellIndex, undefined, pointer, event);
  };
  var OnOut = function OnOut(pointer, event) {
    var table = this.childrenMap.child;
    var cellIndex = table.input.lastOverCellIndex;
    table.input.lastOverCellIndex = undefined;
    EmitCellEvent(this.eventEmitter, 'cell.out', table, cellIndex, undefined, pointer, event);
  };

  var GetValue$U = Phaser.Utils.Objects.GetValue;
  var ClickCell = function ClickCell(table, tableConfig) {
    var buttonConfig = GetValue$U(tableConfig, 'click', undefined);
    if (buttonConfig === false) {
      return;
    } else if (buttonConfig === undefined) {
      buttonConfig = {};
    }
    buttonConfig.threshold = 10;
    table._click = new Button(table, buttonConfig);
    table._click.on('click', function (button, gameObject, pointer, event) {
      EmitCellEvent(this.eventEmitter, 'cell.click', gameObject, pointer.worldX, pointer.worldY, pointer, event);
    }, this);
  };

  var GetValue$T = Phaser.Utils.Objects.GetValue;
  var TapCell = function TapCell(table, tableConfig) {
    var tapConfig = GetValue$T(tableConfig, 'tap', undefined);
    if (tapConfig === false) {
      return;
    }
    table._tap = new Tap(table, tapConfig);
    table._tap.on('tap', function (tap, gameObject, lastPointer) {
      var eventName = "cell.".concat(tap.tapsCount, "tap");
      EmitCellEvent(this.eventEmitter, eventName, tap.gameObject, tap.worldX, tap.worldY, lastPointer);
    }, this);
  };

  var GetValue$S = Phaser.Utils.Objects.GetValue;
  var PressCell = function PressCell(table, tableConfig) {
    var pressConfig = GetValue$S(tableConfig, 'press', undefined);
    if (pressConfig === false) {
      return;
    }
    table._press = new Press(table, pressConfig);
    table._press.on('pressstart', function (press, gameObject, lastPointer) {
      EmitCellEvent(this.eventEmitter, 'cell.pressstart', table, press.worldX, press.worldY, lastPointer);
    }, this).on('pressend', function (press, gameObject, lastPointer) {
      EmitCellEvent(this.eventEmitter, 'cell.pressend', table, press.worldX, press.worldY, lastPointer);
    }, this);
  };

  var GetValue$R = Phaser.Utils.Objects.GetValue;
  var SwipeCell = function SwipeCell(table, tableConfig) {
    var swipeConfig = GetValue$R(tableConfig, 'swipe', undefined);
    if (swipeConfig === false) {
      return;
    } else if (swipeConfig === undefined) {
      swipeConfig = {};
    }
    swipeConfig.dir = '4dir';
    table._swipe = new Swipe(table, swipeConfig);
    table._swipe.on('swipe', function (swipe, gameObject, lastPointer) {
      var dirName = swipe.left ? 'left' : swipe.right ? 'right' : swipe.up ? 'up' : 'down';
      EmitCellEvent(this.eventEmitter, "cell.swipe".concat(dirName), table, swipe.worldX, swipe.worldY, lastPointer);
    }, this);
  };

  var TableSetInteractive = function TableSetInteractive(table, tableConfig) {
    table.setInteractive();
    PointerUpDownCell.call(this, table, tableConfig);
    OverCell.call(this, table, tableConfig);
    ClickCell.call(this, table, tableConfig);
    TapCell.call(this, table, tableConfig);
    PressCell.call(this, table, tableConfig);
    SwipeCell.call(this, table, tableConfig);
  };

  var SetItems = function SetItems(items, updateTable) {
    if (items === undefined) {
      this.items = [];
    } else {
      this.items = items;
    }
    if (updateTable === undefined) {
      updateTable = true;
    }
    var table = this.childrenMap.child;
    table.setCellsCount(this.items.length);
    if (updateTable) {
      table.updateTable(true);
      this.resizeController();
    }
    return this;
  };

  var ScrollMethods$1 = {
    scrollToRow: function scrollToRow(rowIndex) {
      var table = this.childrenMap.child;
      table.scrollToRow(rowIndex);
      return this;
    },
    scrollToNextRow: function scrollToNextRow(rowCount) {
      var table = this.childrenMap.child;
      table.scrollToNextRow(rowCount);
      return this;
    }
  };

  var GetValue$Q = Phaser.Utils.Objects.GetValue;
  var GridTable = /*#__PURE__*/function (_Scrollable) {
    _inherits(GridTable, _Scrollable);
    function GridTable(scene, config) {
      var _this;
      _classCallCheck(this, GridTable);
      if (config === undefined) {
        config = {};
      }

      // Create grid table core
      var scrollMode = GetScrollMode(config);
      var tableConfig = GetValue$Q(config, 'table', undefined);
      if (tableConfig === undefined) {
        tableConfig = {};
      }
      tableConfig.scrollMode = scrollMode === 2 ? 0 : scrollMode;
      tableConfig.clamplTableOXY = GetValue$Q(config, 'clamplChildOY', false);
      var tableWidth = GetValue$Q(tableConfig, 'width', undefined);
      var tableHeight = GetValue$Q(tableConfig, 'height', undefined);
      var table = new GridTable$1(scene, 0, 0, tableWidth, tableHeight, tableConfig);
      scene.add.existing(table); // Important: Add to display list for touch detecting
      var expandWidth, expandHeight;
      if (tableConfig.scrollMode === 0) {
        expandWidth = tableWidth === undefined;
        expandHeight = tableHeight === undefined;
      } else {
        expandWidth = tableHeight === undefined;
        expandHeight = tableWidth === undefined;
      }
      // Inject properties for scrollable interface
      InjectProperties$1(table);
      // Set minWidth/minHeight to 0 if tableWidth/tableHeight is undefined
      table._minWidth = tableWidth === undefined ? 0 : undefined;
      table._minHeight = tableHeight === undefined ? 0 : undefined;

      // Fill config of scrollable
      config.type = 'rexGridTable';
      config.child = {
        gameObject: table,
        expandWidth: expandWidth,
        expandHeight: expandHeight
      };
      var spaceConfig = GetValue$Q(config, 'space', undefined);
      if (spaceConfig) {
        spaceConfig.child = GetValue$Q(spaceConfig, 'table', 0);
      }
      _this = _callSuper(this, GridTable, [scene, config]);
      _this.addChildrenMap('table', table);
      _this.addChildrenMap('tableLayer', table.maskLayer);
      _this.eventEmitter = GetValue$Q(config, 'eventEmitter', _assertThisInitialized(_this));
      var callback = GetValue$Q(config, 'createCellContainerCallback', NOOP);
      var scope = GetValue$Q(config, 'createCellContainerCallbackScope', undefined);
      _this.setCreateCellContainerCallback(callback, scope);
      TableOnCellVisible.call(_assertThisInitialized(_this), table);
      _this.resizeControllerFlag = false;
      var eventName = scrollMode === 0 ? 'cellheightchange' : 'cellwidthchange';
      table.on(eventName, function () {
        this.resizeControllerFlag = true;
      }, _assertThisInitialized(_this));
      if (GetValue$Q(tableConfig, 'interactive', true)) {
        TableSetInteractive.call(_assertThisInitialized(_this), table, tableConfig);
      }
      _this.setItems(GetValue$Q(config, 'items', []), false);
      scene.game.events.on('poststep', _this.onPostStep, _assertThisInitialized(_this));
      return _this;
    }
    _createClass(GridTable, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.scene.game.events.off('poststep', this.onPostStep, this);
        _get(_getPrototypeOf(GridTable.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setCreateCellContainerCallback",
      value: function setCreateCellContainerCallback(callback, scope) {
        this.createCellContainerCallback = callback;
        this.createCellContainerCallbackScope = scope;
        return this;
      }
    }, {
      key: "refresh",
      value: function refresh() {
        this.setItems(this.items);
        return this;
      }
    }, {
      key: "getCell",
      value: function getCell(cellIdx) {
        var table = this.childrenMap.child;
        return table.getCell(cellIdx);
      }
    }, {
      key: "getCellContainer",
      value: function getCellContainer(cellIdx) {
        var table = this.childrenMap.child;
        return table.getCellContainer(cellIdx);
      }
    }, {
      key: "updateVisibleCell",
      value: function updateVisibleCell(cellIdx) {
        var table = this.childrenMap.child;
        return table.updateVisibleCell(cellIdx);
      }
    }, {
      key: "onPostStep",
      value: function onPostStep() {
        if (this.resizeControllerFlag) {
          this.resizeController();
          this.resizeControllerFlag = false;
        }
      }
    }, {
      key: "startRowIndex",
      get: function get() {
        var table = this.childrenMap.child;
        return table.startRowIndex;
      }
    }]);
    return GridTable;
  }(Scrollable);
  var methods$b = {
    setItems: SetItems
  };
  Object.assign(GridTable.prototype, ScrollMethods$1, methods$b);

  var GetEaseConfig = function GetEaseConfig(easeConfig, menu) {
    if (easeConfig.sameOrientation) {
      easeConfig.orientation = menu.orientation;
    } else {
      easeConfig.orientation = menu.orientation === 0 ? 1 : 0;
    }
    return easeConfig;
  };

  var PopUp = function PopUp(menu, duration) {
    menu.popUp(GetEaseConfig(menu.root.easeIn, menu));
  };
  var ScaleDown$1 = function ScaleDown(menu, duration) {
    // Don't destroy here
    menu.scaleDown(GetEaseConfig(menu.root.easeOut, menu));
  };
  var SetTransitCallbackMethods = {
    setTransitInCallback: function setTransitInCallback(callback) {
      if (callback === undefined) {
        callback = PopUp;
      }
      this.transitInCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    },
    setTransitOutCallback: function setTransitOutCallback(callback) {
      if (callback === undefined) {
        callback = ScaleDown$1;
      }
      this.transitOutCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    }
  };

  var PostUpdateDelayCall = function PostUpdateDelayCall(gameObject, delay, callback, scope, args) {
    // Invoke callback under scene's 'postupdate' event
    var scene = GetSceneObject(gameObject);
    var timer = scene.time.delayedCall(delay, function () {
      scene.sys.events.once('postupdate', function () {
        callback.call(scope, args);
      });
    });
    return timer;
  };

  var DelayCallMethods = {
    delayCall: function delayCall(delay, callback, scope) {
      // Invoke callback under scene's 'postupdate' event
      this.timer = PostUpdateDelayCall(this, delay, callback, scope);
      return this;
    },
    removeDelayCall: function removeDelayCall() {
      if (this.timer) {
        this.timer.remove(false);
        this.timer = undefined;
      }
      return this;
    }
  };

  var ExpandSubMenu = function ExpandSubMenu(parentButton, items) {
    var subMenu = this.childrenMap.subMenu;
    // Submenu already expand
    if (subMenu && subMenu.parentButton === parentButton) {
      return this;
    }
    this.collapseSubMenu();
    var orientation;
    if (this.root.toggleOrientation) {
      orientation = this.orientation === 0 ? 1 : 0;
    } else {
      orientation = this.orientation;
    }
    var subMenu = new this.constructor(this.scene, {
      items: items,
      orientation: orientation,
      space: this.space,
      createBackgroundCallback: this.root.createBackgroundCallback,
      createBackgroundCallbackScope: this.root.createBackgroundCallbackScope,
      createButtonCallback: this.root.createButtonCallback,
      createButtonCallbackScope: this.root.createButtonCallbackScope,
      easeIn: this.root.easeIn,
      easeOut: this.root.easeOut,
      _rootMenu: this.root,
      _parentMenu: this,
      _parentButton: parentButton
    });
    this.pin(subMenu);
    this.childrenMap.subMenu = subMenu;
    this.root.emit('expand', subMenu, parentButton, this);
    return this;
  };

  var Collapse = function Collapse() {
    var root = this.root;
    root.emit('collapse', this, this.parentButton, root);
    var duration = root.easeOut.duration;
    // Don't destroy under transitOutCallback
    root.transitOutCallback(this, duration);
    this.collapseSubMenu();

    // Destroy by delayCall
    this.delayCall(duration, this.destroy, this);
    return this;
  };

  var CollapseSubMenu = function CollapseSubMenu() {
    var subMenu = this.childrenMap.subMenu;
    if (subMenu === undefined) {
      return this;
    }
    this.childrenMap.subMenu = undefined;
    this.remove(subMenu);
    subMenu.collapse();
    return this;
  };

  var Methods$3 = {
    expandSubMenu: ExpandSubMenu,
    collapse: Collapse,
    collapseSubMenu: CollapseSubMenu
  };
  Object.assign(Methods$3, SetTransitCallbackMethods, DelayCallMethods);

  var CreateBackground$1 = function CreateBackground(scene, items, callback, scope) {
    var background;
    if (callback) {
      items.scene = scene;
      if (scope) {
        background = callback.call(scope, items);
      } else {
        background = callback(items);
      }
      items.scene = undefined;
    }
    return background;
  };

  var CreateButtons$2 = function CreateButtons(scene, items, callback, scope) {
    var item;
    var buttons = [],
      button;
    if (items && callback) {
      for (var i = 0, cnt = items.length; i < cnt; i++) {
        item = items[i];
        item.scene = scene;
        if (scope) {
          button = callback.call(scope, item, i, items);
        } else {
          button = callback(item, i, items);
        }
        item.scene = undefined;
        buttons.push(button);
      }
    }
    return buttons;
  };

  var MenuSetInteractive = function MenuSetInteractive(menu) {
    menu
    // Expand sub event
    .on(menu.root.expandEventName, function (button, index) {
      if (this._isPassedEvent) {
        return;
      }
      var childrenKey = this.root.childrenKey;
      var subItems = this.items[index][childrenKey];
      if (subItems) {
        this.expandSubMenu(button, subItems);
      }
    }, menu)
    // Click any button
    .on('button.click', function (button, index, pointer, event) {
      // Pass event to root menu object
      if (this !== this.root) {
        this.root._isPassedEvent = true;
        this.root.emit('button.click', button, index, pointer, event);
        this.root._isPassedEvent = false;
      }
    }, menu)
    //Pointer over any button
    .on('button.over', function (button, index, pointer, event) {
      // Pass event to root menu object
      if (this !== this.root) {
        this.root._isPassedEvent = true;
        this.root.emit('button.over', button, index, pointer, event);
        this.root._isPassedEvent = false;
      }
    }, menu)
    //Pointer out any button
    .on('button.out', function (button, index, pointer, event) {
      // Pass event to root menu object
      if (this !== this.root) {
        this.root._isPassedEvent = true;
        this.root.emit('button.out', button, index, pointer, event);
        this.root._isPassedEvent = false;
      }
    }, menu);
  };

  var ParseEaseConfig = function ParseEaseConfig(menu, easeConfig) {
    if (typeof easeConfig === 'number') {
      easeConfig = {
        duration: easeConfig
      };
    }
    if (easeConfig.hasOwnProperty('orientation') && easeConfig.orientation !== undefined) {
      easeConfig.sameOrientation = GetOrientationMode(easeConfig.orientation) === menu.orientation;
    } else {
      easeConfig.sameOrientation = true;
    }
    easeConfig.destroy = false;
    return easeConfig;
  };

  var Expand = function Expand() {
    var root = this.root;
    var duration = root.easeIn.duration;
    // Ease in menu
    root.transitInCallback(this, duration);
    if (this !== this.root) {
      this.delayCall(duration, function () {
        // Pass event to root menu object
        this.root.emit('popup.complete', this);
      }, this);
    }
  };

  var GetValue$P = Phaser.Utils.Objects.GetValue;
  var Menu = /*#__PURE__*/function (_Buttons) {
    _inherits(Menu, _Buttons);
    function Menu(scene, config) {
      var _this;
      _classCallCheck(this, Menu);
      if (config === undefined) {
        config = {};
      }

      // Orientation
      if (!config.hasOwnProperty('orientation')) {
        config.orientation = 1; // y
      }

      // Parent
      var rootMenu = config._rootMenu;
      var parentMenu = config._parentMenu;
      var parentButton = config._parentButton;
      // Popup, root menu can be static, sub-menus are always popup.
      var popUp = GetValue$P(config, 'popup', true);
      // Items
      var items = GetValue$P(config, 'items', undefined);
      // Background
      var createBackgroundCallback = GetValue$P(config, 'createBackgroundCallback', undefined);
      var createBackgroundCallbackScope = GetValue$P(config, 'createBackgroundCallbackScope', undefined);
      config.background = CreateBackground$1(scene, items, createBackgroundCallback, createBackgroundCallbackScope);
      // Buttons
      var createButtonCallback = GetValue$P(config, 'createButtonCallback', undefined);
      var createButtonCallbackScope = GetValue$P(config, 'createButtonCallbackScope', undefined);
      config.buttons = CreateButtons$2(scene, items, createButtonCallback, createButtonCallbackScope);
      _this = _callSuper(this, Menu, [scene, config]);
      _this.type = 'rexMenu';
      _this.items = items;
      _this.root = rootMenu === undefined ? _assertThisInitialized(_this) : rootMenu;
      _this.isRoot = _this.root === _assertThisInitialized(_this);
      _this.parentMenu = parentMenu;
      _this.parentButton = parentButton;
      _this.timer = undefined;

      // Root menu
      if (_this.isRoot) {
        _this.isPopUpMode = popUp;
        // Bounds
        var bounds = config.bounds;
        if (bounds === undefined) {
          bounds = GetViewport(scene);
        }
        _this.bounds = bounds;

        // Side of submenu
        _this.subMenuSide = [_this.y < bounds.centerY ? SUBMENU_DOWN : SUBMENU_UP, _this.x < bounds.centerX ? SUBMENU_RIGHT : SUBMENU_LEFT];
        // Overwrite subMenuSide value if given
        var subMenuSide = GetValue$P(config, 'subMenuSide', undefined);
        if (subMenuSide !== undefined) {
          if (typeof subMenuSide === 'string') {
            subMenuSide = SubMenuSideMode[subMenuSide];
          }
          _this.subMenuSide[_this.orientation] = subMenuSide;
        }
        // ToggleOrientation mode
        _this.toggleOrientation = GetValue$P(config, 'toggleOrientation', false);
        // Expand mode
        _this.expandEventName = GetValue$P(config, 'expandEvent', 'button.click');
        // Transition
        _this.easeIn = ParseEaseConfig(_assertThisInitialized(_this), GetValue$P(config, 'easeIn', 0));
        _this.easeOut = ParseEaseConfig(_assertThisInitialized(_this), GetValue$P(config, 'easeOut', 0));
        _this.setTransitInCallback(GetValue$P(config, 'transitIn'));
        _this.setTransitOutCallback(GetValue$P(config, 'transitOut'));
        // Callbacks
        _this.createBackgroundCallback = createBackgroundCallback;
        _this.createBackgroundCallbackScope = createBackgroundCallbackScope;
        _this.createButtonCallback = createButtonCallback;
        _this.createButtonCallbackScope = createButtonCallbackScope;
        // Children key
        _this.childrenKey = GetValue$P(config, 'childrenKey', 'children');
        // Event flag
        _this._isPassedEvent = false;

        // pointerdown-outside-collapse
        _this.pointerDownOutsideCollapsing = GetValue$P(config, 'pointerDownOutsideCollapsing', true);
        if (_this.pointerDownOutsideCollapsing) {
          scene.input.on('pointerdown', _this.onPointerDownOutside, _assertThisInitialized(_this));
        }
      }
      var originX = 0,
        originY = 0;
      if (!_this.root.easeIn.sameOrientation) {
        var easeOrientation = GetEaseConfig(_this.root.easeIn, _assertThisInitialized(_this)).orientation;
        var menuOrientation = parentMenu ? parentMenu.orientation : _this.orientation;
        var subMenuSide = _this.root.subMenuSide[menuOrientation];
        if (easeOrientation === 0 && subMenuSide === SUBMENU_LEFT) {
          originX = 1;
        }
        if (easeOrientation === 1 && subMenuSide === SUBMENU_UP) {
          originY = 1;
        }
      }
      if (popUp) {
        _this.setOrigin(originX, originY).layout();
      }

      // Sub-menu: 
      // - scale to root's scale value
      // - align to parent button
      if (!_this.isRoot) {
        _this.setScale(_this.root.scaleX, _this.root.scaleY);
        var subMenuSide = _this.root.subMenuSide[parentMenu.orientation];
        switch (subMenuSide) {
          case SUBMENU_LEFT:
            //Put submene at left side
            _this.alignTop(parentButton.top).alignRight(parentButton.left);
            break;
          case SUBMENU_RIGHT:
            //Put submene at right side
            _this.alignTop(parentButton.top).alignLeft(parentButton.right);
            break;
          case SUBMENU_UP:
            //Put submene at up side
            _this.alignLeft(parentButton.left).alignBottom(parentButton.top);
            break;
          case SUBMENU_DOWN:
            //Put submene at down side
            _this.alignLeft(parentButton.left).alignTop(parentButton.bottom);
            break;
        }
      }
      MenuSetInteractive(_assertThisInitialized(_this));
      if (popUp) {
        _this.pushIntoBounds(_this.root.bounds);

        // Expand this menu
        Expand.call(_assertThisInitialized(_this));
      }
      return _this;
    }
    _createClass(Menu, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        if (this.isRoot && this.pointerDownOutsideCollapsing) {
          this.scene.input.off('pointerdown', this.onPointerDownOutside, this);
        }
        _get(_getPrototypeOf(Menu.prototype), "destroy", this).call(this, fromScene);
        this.removeDelayCall();
      }
    }, {
      key: "isInTouching",
      value: function isInTouching(pointer) {
        if (_get(_getPrototypeOf(Menu.prototype), "isInTouching", this).call(this, pointer)) {
          return true;
        } else if (this.childrenMap.subMenu) {
          return this.childrenMap.subMenu.isInTouching(pointer);
        } else {
          return false;
        }
      }
    }, {
      key: "onPointerDownOutside",
      value: function onPointerDownOutside(pointer) {
        if (this.isInTouching(pointer)) {
          return;
        }
        if (this.isPopUpMode) {
          this.collapse();
        } else {
          this.collapseSubMenu();
        }
      }
    }]);
    return Menu;
  }(Buttons$1);
  var SUBMENU_LEFT = 2;
  var SUBMENU_RIGHT = 0;
  var SUBMENU_UP = 3;
  var SUBMENU_DOWN = 1;
  var SubMenuSideMode = {
    up: SUBMENU_UP,
    down: SUBMENU_DOWN,
    left: SUBMENU_LEFT,
    right: SUBMENU_RIGHT
  };
  Object.assign(Menu.prototype, Methods$3);

  var methods$a = {
    setWrapEnable: function setWrapEnable(enable) {
      if (enable === undefined) {
        enable = true;
      }
      this.listWrapEnable = enable;
      return this;
    },
    setCreateButtonCallback: function setCreateButtonCallback(callback) {
      this.listCreateButtonCallback = callback;
      return this;
    },
    setCreateListBackgroundCallback: function setCreateListBackgroundCallback(callback) {
      this.listCreateBackgroundCallback = callback;
      return this;
    },
    setButtonClickCallback: function setButtonClickCallback(callback) {
      this.listOnButtonClick = callback;
      return this;
    },
    setButtonOverCallback: function setButtonOverCallback(callback) {
      this.listOnButtonOver = callback;
      return this;
    },
    setButtonOutCallback: function setButtonOutCallback(callback) {
      this.listOnButtonOut = callback;
      return this;
    },
    setListExpandDirection: function setListExpandDirection(direction) {
      if (typeof direction === 'string') {
        direction = ListExpandDirections[direction];
      }
      this.listExpandDirection = direction;
      return this;
    },
    setListEaseInDuration: function setListEaseInDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }
      this.listEaseInDuration = duration;
      return this;
    },
    setListEaseOutDuration: function setListEaseOutDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }
      this.listEaseOutDuration = duration;
      return this;
    },
    setListTransitInCallback: function setListTransitInCallback(callback) {
      this.listTransitInCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    },
    settListTransitOutCallback: function settListTransitOutCallback(callback) {
      this.listTransitOutCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    },
    setListBounds: function setListBounds(bounds) {
      this.listBounds = bounds;
      return this;
    },
    setListWidth: function setListWidth(width) {
      this.listWidth = width;
      return this;
    },
    setListHeight: function setListHeight(height) {
      this.listHeight = height;
      return this;
    },
    setListSize: function setListSize(width, height) {
      this.setListWidth(width).setListHeight(height);
      return this;
    },
    setListAlignmentMode: function setListAlignmentMode(mode) {
      this.listAlignMode = mode;
      return this;
    },
    setListAlignmentSide: function setListAlignmentSide(side) {
      if (side === undefined) {
        side = '';
      }
      this.listAlignSide = side;
      return this;
    },
    setListSpace: function setListSpace(space) {
      if (space === undefined) {
        space = {};
      }
      this.listSpace = space;
      return this;
    },
    setListDraggable: function setListDraggable(enable) {
      if (enable === undefined) {
        enable = true;
      }
      this.listDraggable = enable;
      return this;
    }
  };
  var ListExpandDirections = {
    down: 0,
    up: 1
  };

  var CreateListPanel = function CreateListPanel() {
    var scene = this.scene;
    var background;
    var createBackgroundCallback = this.listCreateBackgroundCallback;
    if (createBackgroundCallback) {
      background = createBackgroundCallback.call(this, scene);
      scene.add.existing(background);
    }
    var buttons = [];
    var createButtonCallback = this.listCreateButtonCallback;
    if (createButtonCallback) {
      var options = this.options;
      for (var i = 0, cnt = options.length; i < cnt; i++) {
        var button = createButtonCallback.call(this, scene, options[i], i, options);
        if (!button) {
          continue;
        }
        scene.add.existing(button);
        buttons.push(button);
      }
    }
    var width = this.listWidth;
    if (width === undefined) {
      if (this.listAlignMode === 'text') {
        width = this.getElement('text').width;
      } else {
        width = this.width;
      }
    }
    var height = this.listHeight;
    var listPanel;
    if (!this.listWrapEnable) {
      listPanel = new Buttons$1(scene, {
        width: width,
        height: height,
        orientation: 'y',
        background: background,
        buttons: buttons,
        space: this.listSpace,
        draggable: this.listDraggable
      });
    } else {
      listPanel = new Buttons(scene, {
        width: width,
        height: height,
        background: background,
        buttons: buttons,
        space: this.listSpace,
        draggable: this.listDraggable
      });
    }
    scene.add.existing(listPanel);
    return listPanel;
  };

  var ScaleDown = function ScaleDown(gameObject, duration, orientation, ease, scale) {
    if (ease === undefined) {
      ease = 'Linear';
    }
    var config = {};
    config.mode = 0;
    switch (orientation) {
      case 0:
      case 'x':
        config.end = {
          x: 0
        };
        break;
      case 1:
      case 'y':
        config.end = {
          y: 0
        };
        break;
      default:
        config.end = 0;
        break;
    }
    config.duration = duration;
    config.ease = ease;
    if (scale === undefined) {
      scale = new Scale(gameObject, config);
    } else {
      scale.resetFromJSON(config);
    }
    scale.restart();
    return scale;
  };

  var GetValueFromAliasKeys = function GetValueFromAliasKeys(source, key0, key1, key2, defaultValue) {
    if (HasValue(source, key0)) {
      return GetValue$38(source, key0);
    } else if (key1 && HasValue(source, key1)) {
      return GetValue$38(source, key1);
    } else if (key2 && HasValue(source, key2)) {
      return GetValue$38(source, key2);
    } else {
      return defaultValue;
    }
  };

  var GetValue$O = Phaser.Utils.Objects.GetValue;
  var SetPosition = function SetPosition(gameObject, config) {
    var expandDirection = GetValue$O(config, 'expandDirection', undefined);
    if (typeof expandDirection === 'string') {
      expandDirection = ExpandDirections[expandDirection];
    }
    var alignTargetX = GetValueFromAliasKeys(config, 'alignTarget', 'alignTargetX');
    var alignTargetY = GetValue$O(config, 'alignTargetY', alignTargetX);
    var alignOffsetX = GetValue$O(config, 'alignOffsetX', 0);
    var alignOffsetY = GetValue$O(config, 'alignOffsetY', 0);
    var alignSide = GetValue$O(config, 'alignSide', '');
    var alignRight = alignSide.includes('right');
    var positionBounds = GetValue$O(config, 'bounds');

    // Expand direction
    var isExpandDown = expandDirection === 0;
    var isExpandUp = expandDirection === 1;
    var flexExpand = !isExpandDown && !isExpandUp;
    var originX = alignRight ? 1 : 0;
    var originY = isExpandDown || flexExpand ? 0 : 1;
    gameObject.setOrigin(originX, originY);
    var x, y;
    if (alignRight) {
      x = alignTargetX.getTopRight().x;
    } else {
      x = alignTargetX.getTopLeft().x;
    }
    y = alignTargetY.getBottomLeft().y;
    gameObject.setPosition(x + alignOffsetX, y + alignOffsetY);
    var bounds = positionBounds;
    if (!bounds) {
      bounds = GetViewport(gameObject.scene);
    }
    if (flexExpand && gameObject.getBottomLeft().y > bounds.bottom) {
      // Out of bounds, can't put list-panel below parent
      y = alignTargetY.getTopLeft().y;
      gameObject.setOrigin(0, 1).setPosition(x + alignOffsetX, y + alignOffsetY);
    }
  };
  var ExpandDirections = {
    down: 0,
    up: 1
  };

  var GetValue$N = Phaser.Utils.Objects.GetValue;
  var DropDown = /*#__PURE__*/function (_OpenCloseTransition) {
    _inherits(DropDown, _OpenCloseTransition);
    function DropDown(gameObject, config) {
      var _this;
      _classCallCheck(this, DropDown);
      if (config === undefined) {
        config = {};
      }
      if (config.transitIn == null) {
        config.transitIn = function (gameObject, duration) {
          PopUp$1(gameObject, duration, 'y', 'Cubic');
        };
      }
      if (config.transitOut == null) {
        config.transitOut = function (gameObject, duration) {
          // Don't destroy here
          ScaleDown(gameObject, duration, 'y', 'Linear');
        };
      }
      config.manualClose = true;
      config.clickOutsideClose = true;
      config.destroy = true;
      _this = _callSuper(this, DropDown, [gameObject, config]);
      // this.parent = gameObject;
      // this.scene

      SetPosition(gameObject, config);
      if (gameObject.isRexSizer) {
        gameObject.layout();
      }

      // Close conditions:
      var touchOutsideClose = GetValue$N(config, 'touchOutsideClose', false);
      var anyTouchClose = GetValue$N(config, 'anyTouchClose', false);
      if (anyTouchClose) {
        touchOutsideClose = false;
      }

      // Registet touch-close event after opened
      if (anyTouchClose) {
        _this.once('open', _this.anyTouchClose, _assertThisInitialized(_this));
      } else if (touchOutsideClose) {
        _this.once('open', _this.touchOutsideClose, _assertThisInitialized(_this));
      }
      _this.requestOpen();
      return _this;
    }
    _createClass(DropDown, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        // Registered in touchOutsideClose()
        this.scene.input.off('pointerup', this.touchCloseCallback, this);
        _get(_getPrototypeOf(DropDown.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "touchOutsideClose",
      value: function touchOutsideClose() {
        this.scene.input.on('pointerup', this.touchCloseCallback, this);
        this.clickOutsideTest = true;
        return this;
      }
    }, {
      key: "anyTouchClose",
      value: function anyTouchClose() {
        this.scene.input.once('pointerup', this.touchCloseCallback, this);
        return this;
      }
    }, {
      key: "touchCloseCallback",
      value: function touchCloseCallback(pointer) {
        if (this.clickOutsideTest && IsPointInBounds(this.parent, pointer.worldX, pointer.worldY)) {
          return;
        }
        this.requestClose();
      }
    }, {
      key: "onOpen",
      value: function onOpen() {
        this.emit('open', this.parent, this);
        _get(_getPrototypeOf(DropDown.prototype), "onOpen", this).call(this);
      }
    }, {
      key: "onClose",
      value: function onClose() {
        this.emit('close', this.parent, this);
        _get(_getPrototypeOf(DropDown.prototype), "onClose", this).call(this);
      }
    }]);
    return DropDown;
  }(OpenCloseTransition);

  var OpenListPanel = function OpenListPanel() {
    if (this.listPanel) {
      return this;
    }
    var listPanel = CreateListPanel.call(this);

    // Button over/out
    listPanel.on('button.over', function (button, index, pointer, event) {
      this.currentOverIndex = index;
      if (this.listOnButtonOver) {
        this.listOnButtonOver.call(this, button, index, pointer, event);
      }
      this.emit('button.over', this, listPanel, button, index, pointer, event);
    }, this).on('button.out', function (button, index, pointer, event) {
      if (this.currentOverIndex === index) {
        this.currentOverIndex = undefined;
      }
      if (this.listOnButtonOut) {
        this.listOnButtonOut.call(this, button, index, pointer, event);
      }
      this.emit('button.out', this, listPanel, button, index, pointer, event);
    }, this);
    var alignTargetX;
    if (!this.listAlignMode || this.listAlignMode === 'label') {
      alignTargetX = this;
    } else {
      alignTargetX = this.getElement(this.listAlignMode);
    }
    var dropDownBehavior = new DropDown(listPanel, {
      // Transition
      duration: {
        "in": this.listEaseInDuration,
        out: this.listEaseOutDuration
      },
      transitIn: this.listTransitInCallback,
      transitOut: this.listTransitOutCallback,
      // Position
      expandDirection: this.listExpandDirection,
      alignTargetX: alignTargetX,
      alignTargetY: this,
      alignSide: this.listAlignSide,
      bounds: this.listBounds,
      // Close condition
      anyTouchClose: true
    }).on('open', function () {
      // After popping up
      // Can click
      listPanel.on('button.click', function (button, index, pointer, event) {
        if (this.listOnButtonClick) {
          this.listOnButtonClick.call(this, button, index, pointer, event);
        }
        this.emit('button.click', this, listPanel, button, index, pointer, event);
      }, this);
      this.emit('list.open', this, listPanel);
    }, this).on('close', function () {
      this.listPanel = undefined;
      this.dropDownBehavior = undefined;
      this.emit('list.close', this);
    }, this);
    this.listPanel = listPanel;
    this.dropDownBehavior = dropDownBehavior;
    this.pin(listPanel);
    return this;
  };

  var CloseListPanel = function CloseListPanel() {
    if (!this.dropDownBehavior) {
      return this;
    }
    this.dropDownBehavior.requestClose();
    this.currentOverIndex = undefined;
    return this;
  };

  var ToggleListPanel = function ToggleListPanel() {
    if (!this.listPanel) {
      this.openListPanel();
    } else {
      this.closeListPanel();
    }
    return this;
  };

  var EmitListButtonClick = function EmitListButtonClick(index) {
    if (index === undefined) {
      index = this.currentOverIndex;
    }
    if (index === undefined) {
      return this;
    }
    var listPanel = this.listPanel;

    // Use option if listPanel is not created.
    var button = listPanel ? listPanel.getButton(index) : this.options[index];
    if (this.listOnButtonClick) {
      this.listOnButtonClick.call(this, button, index);
    }
    this.emit('button.click', this, listPanel, button, index);
    return this;
  };

  var EmitButtonOver = function EmitButtonOver(index) {
    var listPanel = this.listPanel;
    if (!listPanel) {
      return this;
    }
    listPanel.emitButtonOver(index);
    return this;
  };

  var FocusButtonMethods = {
    focusNextButton: function focusNextButton() {
      if (!this.isOpened) {
        return this;
      }
      var currentIndex = this.currentOverIndex;
      var nextIndex;
      if (currentIndex === undefined) {
        nextIndex = 0;
      } else {
        var total = this.listPanel.getButtons().length;
        nextIndex = (currentIndex + 1) % total;
      }
      this.emitButtonOver(nextIndex);
      return this;
    },
    focusPrevButton: function focusPrevButton() {
      if (!this.isOpened) {
        return this;
      }
      var currentIndex = this.currentOverIndex;
      var nextIndex;
      if (currentIndex === undefined) {
        nextIndex = 0;
      } else {
        var total = this.listPanel.getButtons().length;
        nextIndex = (currentIndex - 1 + total) % total;
      }
      this.emitButtonOver(nextIndex);
      return this;
    }
  };

  var Methods$2 = {
    openListPanel: OpenListPanel,
    closeListPanel: CloseListPanel,
    toggleListPanel: ToggleListPanel,
    emitButtonClick: EmitListButtonClick,
    emitButtonOver: EmitButtonOver
  };
  Object.assign(Methods$2, methods$a, FocusButtonMethods);

  var GetValue$M = Phaser.Utils.Objects.GetValue;
  var DropDownList = /*#__PURE__*/function (_Label) {
    _inherits(DropDownList, _Label);
    function DropDownList(scene, config) {
      var _this;
      _classCallCheck(this, DropDownList);
      _this = _callSuper(this, DropDownList, [scene, config]);
      _this.type = 'rexDropDownList';
      _this.timer = undefined;
      _this.listPanel = undefined;
      _this.currentOverIndex = undefined;
      _this.setOptions(GetValue$M(config, 'options'));
      var listConfig = GetValue$M(config, 'list');
      _this.setWrapEnable(GetValue$M(listConfig, 'wrap', false));
      _this.setCreateButtonCallback(GetValue$M(listConfig, 'createButtonCallback'));
      _this.setCreateListBackgroundCallback(GetValue$M(listConfig, 'createBackgroundCallback'));
      _this.setButtonClickCallback(GetValue$M(listConfig, 'onButtonClick'));
      _this.setButtonOverCallback(GetValue$M(listConfig, 'onButtonOver'));
      _this.setButtonOutCallback(GetValue$M(listConfig, 'onButtonOut'));
      _this.setListExpandDirection(GetValue$M(listConfig, 'expandDirection'));
      _this.setListEaseInDuration(GetValue$M(listConfig, 'easeIn', 500));
      _this.setListEaseOutDuration(GetValue$M(listConfig, 'easeOut', 100));
      _this.setListTransitInCallback(GetValue$M(listConfig, 'transitIn'));
      _this.settListTransitOutCallback(GetValue$M(listConfig, 'transitOut'));
      _this.setListSize(GetValue$M(listConfig, 'width'), GetValue$M(listConfig, 'height'));
      _this.setListAlignmentMode(GetValue$M(listConfig, 'alignParent', 'text'));
      _this.setListAlignmentSide(GetValue$M(listConfig, 'alignSide', ''));
      _this.setListBounds(GetValue$M(listConfig, 'bounds'));
      _this.setListSpace(GetValue$M(listConfig, 'space'));
      _this.setListDraggable(GetValue$M(listConfig, 'draggable', false));
      _this.setValueChangeCallback(GetValue$M(config, 'setValueCallback'), GetValue$M(config, 'setValueCallbackScope'));
      _this.setValue(GetValue$M(config, 'value'));
      _this.onClick(_this.toggleListPanel, _assertThisInitialized(_this));
      return _this;
    }
    _createClass(DropDownList, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        if (this.listPanel) {
          this.listPanel.destroy(fromScene);
          this.listPanel = undefined;
        }
        _get(_getPrototypeOf(DropDownList.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "isOpened",
      get: function get() {
        return !!this.listPanel;
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        if (options === undefined) {
          options = [];
        }
        this.options = options;
        return this;
      }
    }, {
      key: "setValueChangeCallback",
      value: function setValueChangeCallback(callback, scope) {
        this.valueChangeCallback = callback;
        this.valueChangeCallbackScope = scope;
        return this;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (this._value === value) {
          return;
        }
        var previousValue = this._value;
        this._value = value;
        var callback = this.valueChangeCallback,
          scope = this.valueChangeCallbackScope;
        if (callback) {
          if (scope) {
            callback.call(scope, this, value, previousValue);
          } else {
            callback(this, value, previousValue);
          }
        }
        this.emit('valuechange', this, value, previousValue);
      }
    }]);
    return DropDownList;
  }(Label);
  Object.assign(DropDownList.prototype, Methods$2);

  var TextHeightToLinesCount = function TextHeightToLinesCount(textObject) {
    var textObjectType = GetTextObjectType(textObject);
    var height, lineSpacing, lineHeight;
    switch (textObjectType) {
      case TextType:
      case TagTextType:
        height = textObject.height - textObject.padding.top - textObject.padding.bottom;
        lineSpacing = textObject.lineSpacing;
        lineHeight = textObject.style.metrics.fontSize + textObject.style.strokeThickness;
        break;
      case BitmapTextType:
        height = textObject.height;
        lineSpacing = 0;
        var scale = textObject.fontSize / textObject.fontData.size;
        lineHeight = textObject.fontData.lineHeight * scale;
        break;
    }

    // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
    return (height - lineSpacing) / (lineHeight + lineSpacing);
  };

  var GetLines = function GetLines(startLineIndex, endLineIdx) {
    if (startLineIndex === undefined) {
      startLineIndex = this.startLineIndex;
    }
    if (endLineIdx === undefined) {
      endLineIdx = startLineIndex + this.pageLinesCount;
    }
    var text;
    switch (this.textObjectType) {
      case TextType:
      case BitmapTextType:
        text = this.lines.slice(startLineIndex, endLineIdx).join('\n');
        break;
      case TagTextType:
        var startIdx = this.lines.getLineStartIndex(startLineIndex);
        var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
        text = this.lines.getSliceTagText(startIdx, endIdx, true);
        break;
    }
    return text;
  };

  var GetString = function GetString(text) {
    if (Array.isArray(text)) {
      text = text.join('\n');
    } else if (typeof text === 'number') {
      text = text.toString();
    }
    return text;
  };
  var SetContentMethods = {
    clearText: function clearText() {
      this.sections.length = 0;
      this.pageStartIndexes.length = 0;
      this.lines.length = 0;
      return this;
    },
    appendPage: function appendPage(text) {
      var pageStartIndex = this.totalLinesCount;
      this.sections.push(GetString(text));
      var text = this.sections.join('\n');
      this.lines = TextToLines(this.parent, text, this.lines);
      var newLinesCount = this.totalLinesCount - pageStartIndex;
      var pageCount = Math.ceil(newLinesCount / this.pageLinesCount);
      for (var i = 0; i < pageCount; i++) {
        this.pageStartIndexes.push(pageStartIndex + i * this.pageLinesCount);
      }
      return this;
    },
    setText: function setText(text, resetPageIdx) {
      if (resetPageIdx === undefined) {
        resetPageIdx = true;
      }
      if (resetPageIdx) {
        this.resetPageIdx();
      }
      this.clearText();
      var sections = GetString(text).split(this.pageBreak);
      // if (sections[sections.length - 1] === '') { // Last section is an empty string
      //     sections.length -= 1;
      // }

      for (var i = 0, cnt = sections.length; i < cnt; i++) {
        this.appendPage(sections[i]);
      }
      return this;
    },
    appendText: function appendText(text) {
      var content = this.content + GetString(text);
      this.setText(content, false);
      return this;
    }
  };

  var Clamp$3 = Phaser.Math.Clamp;
  var GetPageMethods = {
    getPage: function getPage(idx) {
      if (idx === undefined) {
        idx = this.pageIndex;
      }
      return this.setPageIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
    },
    getNextPage: function getNextPage() {
      return this.getPage(this.pageIndex + 1);
    },
    getPreviousPage: function getPreviousPage() {
      return this.getPage(this.pageIndex - 1);
    },
    getFirstPage: function getFirstPage() {
      return this.getPage(0);
    },
    getLastPage: function getLastPage() {
      return this.getPage(this.lastPageIndex);
    },
    resetPageIdx: function resetPageIdx() {
      this.pageIndex = -1;
      return this;
    },
    setPageIndex: function setPageIndex(idx) {
      idx = Clamp$3(idx, 0, this.lastPageIndex);
      this.pageIndex = idx;
      this.startLineIndex = this.pageStartIndexes[idx];
      this.endLineIndex = this.pageStartIndexes[idx + 1];
      return this;
    }
  };

  var ShowMethods = {
    showPage: function showPage(idx) {
      this.displayText(this.getPage(idx));
      return this;
    },
    showNextPage: function showNextPage() {
      this.displayText(this.getNextPage());
      return this;
    },
    showPreviousPage: function showPreviousPage() {
      this.displayText(this.getPreviousPage());
      return this;
    },
    showFirstPage: function showFirstPage() {
      this.displayText(this.getFirstPage());
      return this;
    },
    showLastPage: function showLastPage() {
      this.displayText(this.getLastPage());
      return this;
    },
    show: function show() {
      this.displayText(this.getLines());
      return this;
    },
    showNextLine: function showNextLine() {
      this.displayText(this.setStartLineIndex(this.startLineIndex + 1).getLines());
      return this;
    },
    showPreviousLine: function showPreviousLine() {
      this.displayText(this.setStartLineIndex(this.startLineIndex - 1).getLines());
      return this;
    },
    displayText: function displayText(text) {
      SetNoWrapText(this.parent, text);
    }
  };

  var Methods$1 = {
    getLines: GetLines
  };
  Object.assign(Methods$1, SetContentMethods, GetPageMethods, ShowMethods);

  var GetValue$L = Phaser.Utils.Objects.GetValue;
  var Clamp$2 = Phaser.Math.Clamp;
  var TextPage = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TextPage, _ComponentBase);
    function TextPage(gameObject, config) {
      var _this;
      _classCallCheck(this, TextPage);
      _this = _callSuper(this, TextPage, [gameObject, {
        eventEmitter: false
      }]);
      // No event emitter
      // this.parent = gameObject;

      _this.textObjectType = GetTextObjectType(_this.parent);
      _this.pageStartIndexes = [];

      // Text object : array of string
      // Tag text object : pens-manager
      // Bitmap text object : array of string
      _this.lines = TextToLines(_this.parent, '');
      _this.sections = [];
      _this.resetFromJSON(config);
      return _this;
    }
    _createClass(TextPage, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setMaxLines(GetValue$L(o, 'maxLines', undefined));
        this.setPageBreak(GetValue$L(o, 'pageBreak', '\f\n'));
        this.setText(GetValue$L(o, 'text', ''));
        this.setStartLineIndex(GetValue$L(o, 'start', 0));
        this.setPageIndex(GetValue$L(o, 'page', -1));
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          maxLines: this.maxLines,
          text: this.content,
          start: this.startLineIndex,
          page: this.pageIndex,
          pageBreak: this.pageBreak
        };
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        switch (this.textObjectType) {
          case TextType:
            this.lines.length = 0;
            break;
          case TagTextType:
            this.lines.destroy();
            break;
          case BitmapTextType:
            this.lines.length = 0;
            break;
        }
        this.pageStartIndexes.length = 0;
        this.sections.length = 0;
        this.lines = undefined;
        this.pageStartIndexes = undefined;
        this.sections = undefined;
        _get(_getPrototypeOf(TextPage.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "setMaxLines",
      value: function setMaxLines(maxLines) {
        this.maxLines = maxLines;
        return this;
      }
    }, {
      key: "setPageBreak",
      value: function setPageBreak(pageBreak) {
        this.pageBreak = pageBreak;
        return this;
      }
    }, {
      key: "pageCount",
      get: function get() {
        return this.pageStartIndexes.length;
      }
    }, {
      key: "lastPageIndex",
      get: function get() {
        return this.pageCount - 1;
      }
    }, {
      key: "isFirstPage",
      get: function get() {
        return this.pageIndex <= 0;
      }
    }, {
      key: "isLastPage",
      get: function get() {
        return this.pageIndex >= this.pageCount - 1;
      }
    }, {
      key: "totalLinesCount",
      get: function get() {
        return this.lines ? this.lines.length : 0;
      }
    }, {
      key: "startLineIndex",
      get: function get() {
        return this._startLineIndex;
      },
      set: function set(value) {
        value = Clamp$2(value, 0, this.totalLinesCount - 1);
        this._startLineIndex = value;
      }
    }, {
      key: "setStartLineIndex",
      value: function setStartLineIndex(idx) {
        this.startLineIndex = idx;
        return this;
      }
    }, {
      key: "pageLinesCount",
      get: function get() {
        if (this.maxLines !== undefined) {
          return this.maxLines;
        } else {
          var count;
          switch (this.textObjectType) {
            case TextType:
            case TagTextType:
              var maxLines = this.parent.style.maxLines;
              if (maxLines > 0) {
                count = maxLines;
              } else {
                count = Math.floor(TextHeightToLinesCount(this.parent));
              }
              break;
            case BitmapTextType:
              count = this.totalLinesCount;
              break;
          }
          return count;
        }
      }
    }, {
      key: "content",
      get: function get() {
        return this.sections.join(this.pageBreak);
      }
    }]);
    return TextPage;
  }(ComponentBase);
  Object.assign(TextPage.prototype, Methods$1);

  var GetWrapText = function GetWrapText(textObject, text) {
    var textObjectType = GetTextObjectType(textObject);
    switch (textObjectType) {
      case TextType:
        textObject.style.syncFont(textObject.canvas, textObject.context);
        text = textObject.runWordWrap(text);
        break;
      case TagTextType:
        text = textObject.getText(text, undefined, undefined, true);
        break;
      case BitmapTextType:
        text = textObject.setText(text).getTextBounds().wrappedText;
        break;
    }
    return text;
  };

  var GetFastValue = Phaser.Utils.Objects.GetFastValue;
  var GetValue$K = Phaser.Utils.Objects.GetValue;
  var TextTyping = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TextTyping, _ComponentBase);
    function TextTyping(gameObject, config) {
      var _this;
      _classCallCheck(this, TextTyping);
      _this = _callSuper(this, TextTyping, [gameObject, config]);
      // this.parent = gameObject;

      _this.timer = null;
      _this.resetFromJSON(config);
      return _this;
    }
    _createClass(TextTyping, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setTextWrapEnable(GetValue$K(o, 'wrap', false));
        this.setTypeMode(GetValue$K(o, 'typeMode', 0));
        this.setTypingSpeed(GetValue$K(o, 'speed', 333));
        this.setTextCallback = GetFastValue(o, 'setTextCallback', null);
        this.setTextCallbackScope = GetFastValue(o, 'setTextCallbackScope', null);
        this.setTypingContent(GetFastValue(o, 'text', ''));
        this.typingIdx = GetFastValue(o, 'typingIdx', 0);
        this.insertIdx = null;
        this.insertChar = null;
        var elapsed = GetFastValue(o, 'elapsed', null);
        if (elapsed !== null) {
          this.start(undefined, undefined, this.typingIdx, elapsed);
        }
        return this;
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        this.freeTimer();
        _get(_getPrototypeOf(TextTyping.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "setTypeMode",
      value: function setTypeMode(m) {
        if (typeof m === 'string') {
          m = TYPEMODE[m];
        }
        this.typeMode = m;
        return this;
      }
    }, {
      key: "setTypeSpeed",
      value: function setTypeSpeed(speed) {
        this.speed = speed;
        return this;
      }
    }, {
      key: "setTypingSpeed",
      value: function setTypingSpeed(speed) {
        this.speed = speed;
        return this;
      }
    }, {
      key: "setTextWrapEnable",
      value: function setTextWrapEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.textWrapEnable = enable;
        return this;
      }
    }, {
      key: "text",
      get: function get() {
        return this._text;
      },
      set: function set(value) {
        var text = TransferText(value);
        if (this.textWrapEnable) {
          text = GetWrapText(this.parent, text);
        }
        this._text = text;
      }
    }, {
      key: "isTyping",
      get: function get() {
        return this.getTimer() !== null;
      }
    }, {
      key: "isLastChar",
      get: function get() {
        return this.typingIdx === this.textLen;
      }
    }, {
      key: "start",
      value: function start(text, speed, startIdx, timerStartAt) {
        if (text !== undefined) {
          this.setTypingContent(text);
        }
        if (speed !== undefined) {
          this.speed = speed;
        }
        if (startIdx === undefined) {
          startIdx = 0;
        }
        this.typingIdx = startIdx + 1;
        if (this.speed === 0) {
          this.stop(true);
        } else {
          this.setText('');
          this.startTimer(timerStartAt);
        }
        return this;
      }
    }, {
      key: "appendText",
      value: function appendText(text) {
        var newText = this.text.concat(TransferText(text));
        if (this.isTyping) {
          this.setTypingContent(newText);
        } else {
          this.start(newText, undefined, this.textLen);
        }
        return this;
      }
    }, {
      key: "stop",
      value: function stop(showAllText) {
        var timer = this.getTimer();
        if (timer) {
          this.freeTimer();
        }
        if (showAllText) {
          // Fire 'type' event for remainder characters until lastChar
          while (!this.isLastChar) {
            this.getTypingString(this.text, this.typingIdx, this.textLen, this.typeMode);
            this.emit('typechar', this.insertChar);
            this.typingIdx++;
          }
          // Display all characters on text game object
          this.setText(this.text);
          this.emit('type');
          this.emit('complete', this, this.parent);
        }
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        var timer = this.getTimer();
        if (timer) {
          timer.paused = true;
        }
        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        var timer = this.getTimer();
        if (timer) {
          timer.paused = false;
        }
        return this;
      }
    }, {
      key: "setTypingContent",
      value: function setTypingContent(text) {
        this.text = text;
        this.textLen = this.getTextLength(this.text);
        return this;
      }
    }, {
      key: "onTyping",
      value: function onTyping() {
        var newText = this.getTypingString(this.text, this.typingIdx, this.textLen, this.typeMode);
        this.setText(newText);
        this.emit('typechar', this.insertChar);
        this.emit('type');
        if (this.isLastChar) {
          this.freeTimer();
          this.emit('complete', this, this.parent);
        } else {
          this.timer.delay = this.speed; // delay of next typing            
          this.typingIdx++;
        }
      }
    }, {
      key: "getTypingString",
      value: function getTypingString(text, typeIdx, textLen, typeMode) {
        var result;
        if (typeMode === 0) {
          //left-to-right
          var startIdx = 0;
          var endIdx = typeIdx;
          this.insertIdx = endIdx;
          result = this.getSubString(text, startIdx, endIdx);
        } else if (typeMode === 1) {
          //right-to-left
          var endIdx = textLen;
          var startIdx = endIdx - typeIdx;
          this.insertIdx = 0;
          result = this.getSubString(text, startIdx, endIdx);
        } else if (typeMode === 2) {
          //middle-to-sides
          var midIdx = textLen / 2;
          var startIdx = Math.floor(midIdx - typeIdx / 2);
          var endIdx = startIdx + typeIdx;
          this.insertIdx = typeIdx % 2 ? typeIdx : 0;
          result = this.getSubString(text, startIdx, endIdx);
        } else if (typeMode === 3) {
          //sides-to-middle
          var lowerLen = Math.floor(typeIdx / 2);
          var lowerResult;
          if (lowerLen > 0) {
            var endIdx = textLen;
            var startIdx = endIdx - lowerLen;
            lowerResult = this.getSubString(text, startIdx, endIdx);
          } else {
            lowerResult = "";
          }
          var upperLen = typeIdx - lowerLen;
          var upperResult;
          if (upperLen > 0) {
            var startIdx = 0;
            var endIdx = startIdx + upperLen;
            this.insertIdx = endIdx;
            upperResult = this.getSubString(text, startIdx, endIdx);
          } else {
            upperResult = "";
            this.insertIdx = 0;
          }
          result = upperResult + lowerResult;
        }
        this.insertChar = result.charAt(this.insertIdx - 1);
        return result;
      }
    }, {
      key: "startTimer",
      value: function startTimer(timerStartAt) {
        if (this.timer) {
          this.freeTimer();
        }
        var startAt;
        if (timerStartAt === undefined) {
          startAt = 0;
        } else {
          this.speed;
          startAt = timerStartAt;
        }
        this.timer = this.scene.time.addEvent({
          delay: 0.0001,
          startAt: startAt,
          loop: true,
          callback: this.onTyping,
          callbackScope: this
        });
        // Note: Throw error message if delay is 0 with repeat/loop

        return this;
      }
    }, {
      key: "getTimer",
      value: function getTimer() {
        return this.timer;
      }
    }, {
      key: "freeTimer",
      value: function freeTimer() {
        if (this.timer) {
          this.timer.remove();
          this.timer = null;
        }
        return this;
      }
    }, {
      key: "setText",
      value: function setText(text) {
        if (this.setTextCallback) {
          if (this.setTextCallbackScope) {
            text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIdx);
          } else {
            text = this.setTextCallback(text, this.isLastChar, this.insertIdx);
          }
        }
        if (this.textWrapEnable) {
          SetNoWrapText(this.parent, text);
        } else {
          this.parent.setText(text);
        }
      }
    }, {
      key: "getTextLength",
      value: function getTextLength(text) {
        var gameObject = this.parent;
        var len;
        if (gameObject.getPlainText) {
          len = gameObject.getPlainText(text).length;
        } else {
          len = text.length;
        }
        return len;
      }
    }, {
      key: "getSubString",
      value: function getSubString(text, startIdx, endIdx) {
        var gameObject = this.parent;
        var result;
        if (gameObject.getSubString) {
          result = gameObject.getSubString(text, startIdx, endIdx);
        } else {
          result = text.slice(startIdx, endIdx);
        }
        return result;
      }
    }]);
    return TextTyping;
  }(ComponentBase);
  var TransferText = function TransferText(text) {
    if (Array.isArray(text)) {
      text = text.join('\n');
    } else if (typeof text === 'number') {
      text = text.toString();
    }
    return text;
  };
  var TYPEMODE = {
    'left-to-right': 0,
    'right-to-left': 1,
    'middle-to-sides': 2,
    'sides-to-middle': 3
  };

  var GetValue$J = Phaser.Utils.Objects.GetValue;
  var TextBoxBase = function TextBoxBase(GOClass, type) {
    if (type === undefined) {
      type = 'rexTextBox';
    }
    var TextBox = /*#__PURE__*/function (_GOClass) {
      _inherits(TextBox, _GOClass);
      function TextBox(scene, config) {
        var _this;
        _classCallCheck(this, TextBox);
        _this = _callSuper(this, TextBox, [scene, config]);
        _this.type = type;

        // childrenMap must have 'text' element
        var text = _this.childrenMap.text;
        _this.page = new TextPage(text, GetValue$J(config, 'page', undefined));
        _this.typing = new TextTyping(text, GetValue$J(config, 'typing', config.type));
        _this.typing.on('complete', _this.onPageEnd, _assertThisInitialized(_this)).on('type', _this.onType, _assertThisInitialized(_this)).on('typechar', _this.onTypeChar, _assertThisInitialized(_this));
        _this.textWidth = text.width;
        _this.textHeight = text.height;
        return _this;
      }
      _createClass(TextBox, [{
        key: "start",
        value: function start(text, speed) {
          this.page.setText(text);
          if (speed !== undefined) {
            this.setTypingSpeed(speed);
          }
          this.emit('start');
          this.typeNextPage();
          return this;
        }
      }, {
        key: "typeNextPage",
        value: function typeNextPage() {
          if (!this.isLastPage) {
            var txt = this.page.getNextPage();
            this.typing.start(txt);
          } else {
            this.emit('complete');
          }
          return this;
        }
      }, {
        key: "pause",
        value: function pause() {
          if (this.isTyping) {
            this.typing.pause();
            this.emit('pause');
          }
          return this;
        }
      }, {
        key: "resume",
        value: function resume() {
          if (!this.isTyping) {
            this.emit('resume');
            this.typing.resume();
          }
          return this;
        }
      }, {
        key: "stop",
        value: function stop(showAllText) {
          this.typing.stop(showAllText);
          return this;
        }
      }, {
        key: "showLastPage",
        value: function showLastPage() {
          this.typing.stop();
          this.page.showLastPage();
          this.emit('type');
          this.onPageEnd();
          return this;
        }
      }, {
        key: "setTypeSpeed",
        value: function setTypeSpeed(speed) {
          this.typing.setTypingSpeed(speed);
          return this;
        }
      }, {
        key: "setTypingSpeed",
        value: function setTypingSpeed(speed) {
          this.typing.setTypingSpeed(speed);
          return this;
        }
      }, {
        key: "isTyping",
        get: function get() {
          return this.typing.isTyping;
        }
      }, {
        key: "isLastPage",
        get: function get() {
          return this.page.isLastPage;
        }
      }, {
        key: "isFirstPage",
        get: function get() {
          return this.page.isFirstPage;
        }
      }, {
        key: "pageCount",
        get: function get() {
          return this.page.pageCount;
        }
      }, {
        key: "pageIndex",
        get: function get() {
          return this.page.pageIndex;
        }
      }, {
        key: "typingSpeed",
        get: function get() {
          return this.typing.speed;
        }
      }, {
        key: "onType",
        value: function onType() {
          var text = this.childrenMap.text;
          if (this.textWidth !== text.width || this.textHeight !== text.height) {
            this.textWidth = text.width;
            this.textHeight = text.height;
            this.getTopmostSizer().layout();
          }
          this.emit('type');
        }
      }, {
        key: "onTypeChar",
        value: function onTypeChar(_char) {
          this.emit('typechar', _char);
        }
      }, {
        key: "onPageEnd",
        value: function onPageEnd() {
          var isLastPage = this.isLastPage;
          this.emit('pageend');
          /*
          Might enter this method immediately, if invoking typeNextPage() in this 'pageend' event.
          */

          if (isLastPage) {
            this.emit('complete');
          }
        }
      }]);
      return TextBox;
    }(GOClass);
    return TextBox;
  };

  var TextBox = /*#__PURE__*/function (_TextBoxBase) {
    _inherits(TextBox, _TextBoxBase);
    function TextBox(scene, config) {
      _classCallCheck(this, TextBox);
      if (config === undefined) {
        config = {};
      }
      if (!config.hasOwnProperty('layoutMode')) {
        config.layoutMode = 1;
      }
      return _callSuper(this, TextBox, [scene, config]);
    }
    return _createClass(TextBox);
  }(TextBoxBase(TitleLabel));

  var SimpleTextBox = /*#__PURE__*/function (_TextBox) {
    _inherits(SimpleTextBox, _TextBox);
    function SimpleTextBox(scene, config, creators) {
      _classCallCheck(this, SimpleTextBox);
      config = BuildTitleLabelConfig(scene, config, creators);
      return _callSuper(this, SimpleTextBox, [scene, config]);
    }
    return _createClass(SimpleTextBox);
  }(TextBox);

  Phaser.Utils.Objects.GetValue;

  Phaser.Utils.Objects.GetValue;

  var OverlapSizerAdd = OverlapSizer.prototype.add;
  var Add = function Add(gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY) {
    gameObject.setVisible(false); // Default is invisible
    OverlapSizerAdd.call(this, gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY);
    return this;
  };
  var AddChildMethods = {
    add: Add,
    addPage: Add
  };

  var GetPage$1 = function GetPage(key) {
    if (key === undefined) {
      return null;
    } else if (!this.sizerChildren.hasOwnProperty(key)) {
      return null;
    } else {
      return this.sizerChildren[key];
    }
  };

  var ContainerSetChildVisible$1 = ContainerLite.prototype.setChildVisible;
  var SwapPage$1 = function SwapPage(key, fadeInDuration) {
    this._previousKey = this._currentKey;
    var prevoiusPage = this.previousPage;
    if (prevoiusPage) {
      if (this.swapMode === 0) {
        // Invisible
        ContainerSetChildVisible$1.call(this, prevoiusPage, false);
        this.emit('pageinvisible', prevoiusPage, this._previousKey, this);
      } else {
        // Destroy
        prevoiusPage.destroy();
      }
    }
    if (key && !this.sizerChildren.hasOwnProperty(key)) {
      this.emit('createpage', key, this);
    }
    this._currentKey = key;
    var currentPage = this.currentPage;
    if (currentPage) {
      ContainerSetChildVisible$1.call(this, currentPage, true);
      this.emit('pagevisible', currentPage, this._currentKey, this);
      if (fadeInDuration === undefined) {
        fadeInDuration = this.fadeInDuration;
      }
      if (fadeInDuration > 0) {
        currentPage.setAlpha(0).fadeIn(fadeInDuration, 1);
      }
    }
    return this;
  };

  var HasPage = function HasPage(key) {
    return this.sizerChildren.hasOwnProperty(key);
  };

  var methods$9 = {
    getPage: GetPage$1,
    swapPage: SwapPage$1,
    hasPage: HasPage
  };
  Object.assign(methods$9, AddChildMethods);

  var GetValue$I = Phaser.Utils.Objects.GetValue;
  var Pages = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(Pages, _OverlapSizer);
    function Pages(scene, config) {
      var _this;
      _classCallCheck(this, Pages);
      _this = _callSuper(this, Pages, [scene, config]);
      _this.type = 'rexPages';
      _this.childrenMap = _this.sizerChildren;
      _this._previousKey = undefined;
      _this._currentKey = undefined;
      _this.setSwapMode(GetValue$I(config, 'swapMode', 0));
      _this.setFadeInDuration(GetValue$I(config, 'fadeIn', 0));
      return _this;
    }
    _createClass(Pages, [{
      key: "setSwapMode",
      value: function setSwapMode(mode) {
        if (typeof mode === 'string') {
          mode = SWAPMODE[mode];
        }
        this.swapMode = mode;
        return this;
      }
    }, {
      key: "setFadeInDuration",
      value: function setFadeInDuration(duration) {
        this.fadeInDuration = duration;
        return this;
      }
    }, {
      key: "previousKey",
      get: function get() {
        return this._previousKey;
      }
    }, {
      key: "currentKey",
      get: function get() {
        return this._currentKey;
      },
      set: function set(key) {
        this.swapPage(key);
      }
    }, {
      key: "currentPage",
      get: function get() {
        return this.getPage(this.currentKey);
      }
    }, {
      key: "previousPage",
      get: function get() {
        return this.getPage(this.previousKey);
      }
    }, {
      key: "keys",
      get: function get() {
        return Object.keys(this.sizerChildren);
      }
    }]);
    return Pages;
  }(OverlapSizer);
  Object.assign(Pages.prototype, methods$9);
  var SWAPMODE = {
    invisible: 0,
    destroy: 1
  };

  var Mesh = Phaser.GameObjects.Mesh;
  var MeshBase = /*#__PURE__*/function (_Mesh) {
    _inherits(MeshBase, _Mesh);
    function MeshBase() {
      _classCallCheck(this, MeshBase);
      return _callSuper(this, MeshBase, arguments);
    }
    _createClass(MeshBase, [{
      key: "tint",
      get: function get() {
        if (this.vertices.length === 0) {
          return 0xffffff;
        } else {
          return this.vertices[0].color;
        }
      }
    }, {
      key: "forceUpdate",
      value: function forceUpdate() {
        this.dirtyCache[10] = 1;
        return this;
      }
    }]);
    return MeshBase;
  }(Mesh);

  var Vector3 = Phaser.Math.Vector3;
  var Matrix4 = Phaser.Math.Matrix4;
  var tempPosition = new Vector3();
  var tempRotation = new Vector3();
  var tempMatrix = new Matrix4();
  var TransformVerts = function TransformVerts(mesh, x, y, z, rotateX, rotateY, rotateZ) {
    if (x === undefined) {
      x = 0;
    }
    if (y === undefined) {
      y = 0;
    }
    if (z === undefined) {
      z = 0;
    }
    if (rotateX === undefined) {
      rotateX = 0;
    }
    if (rotateY === undefined) {
      rotateY = 0;
    }
    if (rotateZ === undefined) {
      rotateZ = 0;
    }
    tempPosition.set(x, y, z);
    tempRotation.set(rotateX, rotateY, rotateZ);
    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, true);
    for (var i = 0, cnt = mesh.vertices.length; i < cnt; i++) {
      mesh.vertices[i].transformMat4(tempMatrix);
    }
  };

  var IsPlainObject$6 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$H = Phaser.Utils.Objects.GetValue;
  var GenerateGridVerts = Phaser.Geom.Mesh.GenerateGridVerts;
  var RadToDeg$1 = Phaser.Math.RadToDeg;
  var DegToRad$2 = Phaser.Math.DegToRad;
  var FOV = 45;
  var PanZ = 1 + 1 / Math.sin(DegToRad$2(FOV));
  var Image$1 = /*#__PURE__*/function (_MeshBase) {
    _inherits(Image, _MeshBase);
    function Image(scene, x, y, key, frame, config) {
      var _this;
      _classCallCheck(this, Image);
      if (IsPlainObject$6(x)) {
        config = x;
        x = GetValue$H(config, 'x', 0);
        y = GetValue$H(config, 'y', 0);
        key = GetValue$H(config, 'key', null);
        frame = GetValue$H(config, 'frame', null);
      }
      _this = _callSuper(this, Image, [scene, x, y, key, frame]);
      _this.type = 'rexPerspectiveImage';
      _this.setSizeToFrame();
      _this.resetPerspective();
      _this.panZ(PanZ);
      _this.hideCCW = GetValue$H(config, 'hideCCW', true);
      var gridWidth = GetValue$H(config, 'gridWidth', 0);
      var gridHeight = GetValue$H(config, 'gridHeight', gridWidth);
      _this.resetVerts(gridWidth, gridHeight);
      _this.prevFrame = _this.frame;
      return _this;
    }
    _createClass(Image, [{
      key: "preUpdate",
      value: function preUpdate(time, delta) {
        // Reset size and vertex if frame is changed
        if (this.prevFrame !== this.frame) {
          this.prevFrame = this.frame;
          this.syncSize();
        }
        _get(_getPrototypeOf(Image.prototype), "preUpdate", this).call(this, time, delta);
      }
    }, {
      key: "originX",
      get: function get() {
        return 0.5;
      }
    }, {
      key: "originY",
      get: function get() {
        return 0.5;
      }
    }, {
      key: "resetPerspective",
      value: function resetPerspective() {
        this.setPerspective(this.width, this.height, FOV);
        return this;
      }
    }, {
      key: "resetVerts",
      value: function resetVerts(gridWidth, gridHeight) {
        if (gridWidth !== undefined) {
          this.gridWidth = gridWidth;
        }
        if (gridHeight !== undefined) {
          this.gridHeight = gridHeight;
        }

        // Clear faces and vertices
        this.clear();
        this.dirtyCache[9] = -1;
        if (this.width === 0 || this.height === 0) {
          return this;
        }

        // Generate faces and vertices
        var frameWidth = this.frame.cutWidth,
          frameHeight = this.frame.cutHeight;
        var gridWidth, gridHeight;
        if (this.gridWidth === 0) {
          gridWidth = Math.max(frameWidth / 8, 32);
        } else {
          gridHeight = this.gridWidth;
        }
        if (this.gridHeight === 0) {
          gridHeight = Math.max(frameHeight / 8, 32);
        } else {
          gridHeight = this.gridHeight;
        }
        GenerateGridVerts({
          mesh: this,
          width: frameWidth / this.height,
          height: frameHeight / this.height,
          widthSegments: Math.ceil(frameWidth / gridWidth),
          heightSegments: Math.ceil(frameHeight / gridHeight)
        });

        // Recover vertices transform
        var transformInfo = this.transformInfo;
        if (transformInfo) {
          this.transformVerts(transformInfo.x, transformInfo.y, transformInfo.z, transformInfo.rotateX, transformInfo.rotateY, transformInfo.rotateZ);
        }
        return this;
      }
    }, {
      key: "syncSize",
      value: function syncSize() {
        this.setSizeToFrame(); // Reset size
        this.resetPerspective(); // Reset perspective
        this.resetVerts(); // Reset verts
        return this;
      }
    }, {
      key: "rotationX",
      get: function get() {
        return this.modelRotation.x;
      },
      set: function set(value) {
        this.modelRotation.x = value;
      }
    }, {
      key: "angleX",
      get: function get() {
        return RadToDeg$1(this.rotationX);
      },
      set: function set(value) {
        this.rotationX = DegToRad$2(value);
      }
    }, {
      key: "rotationY",
      get: function get() {
        return this.modelRotation.y;
      },
      set: function set(value) {
        this.modelRotation.y = value;
      }
    }, {
      key: "angleY",
      get: function get() {
        return RadToDeg$1(this.rotationY);
      },
      set: function set(value) {
        this.rotationY = DegToRad$2(value);
      }
    }, {
      key: "rotationZ",
      get: function get() {
        return this.modelRotation.z;
      },
      set: function set(value) {
        this.modelRotation.z = value;
      }
    }, {
      key: "angleZ",
      get: function get() {
        return RadToDeg$1(this.rotationZ);
      },
      set: function set(value) {
        this.rotationZ = DegToRad$2(value);
      }
    }, {
      key: "transformVerts",
      value: function transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (z === undefined) {
          z = 0;
        }
        if (rotateX === undefined) {
          rotateX = 0;
        }
        if (rotateY === undefined) {
          rotateY = 0;
        }
        if (rotateZ === undefined) {
          rotateZ = 0;
        }
        if (!this.transformInfo) {
          this.transformInfo = {};
        }
        this.transformInfo.x = x;
        this.transformInfo.y = y;
        this.transformInfo.rotateX = rotateX;
        this.transformInfo.rotateY = rotateY;
        this.transformInfo.rotateZ = rotateZ;
        TransformVerts(this, x, y, z, rotateX, rotateY, rotateZ);
        return this;
      }
    }]);
    return Image;
  }(MeshBase);

  var DynamicTexture = Phaser.Textures.DynamicTexture;
  var CreateDynamicTexture = function CreateDynamicTexture(scene, width, height) {
    if (width === undefined) {
      width = 2;
    }
    if (height === undefined) {
      height = 2;
    }
    var dt = new DynamicTexture(scene.sys.textures, null, width, height);
    return dt;
  };

  var IsPlainObject$5 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$G = Phaser.Utils.Objects.GetValue;
  var RenderTexture = /*#__PURE__*/function (_Image) {
    _inherits(RenderTexture, _Image);
    function RenderTexture(scene, x, y, width, height, config) {
      var _this;
      _classCallCheck(this, RenderTexture);
      if (IsPlainObject$5(x)) {
        config = x;
        x = GetValue$G(config, 'x', 0);
        y = GetValue$G(config, 'y', 0);
        width = GetValue$G(config, 'width', 32);
        height = GetValue$G(config, 'height', 32);
      }

      // dynamic-texture -> quad-image
      var texture = CreateDynamicTexture(scene, width, height);
      _this = _callSuper(this, RenderTexture, [scene, x, y, texture, null, config]);
      _this.type = 'rexPerspectiveRenderTexture';
      _this.rt = _this.texture;
      return _this;
    }
    _createClass(RenderTexture, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        _get(_getPrototypeOf(RenderTexture.prototype), "destroy", this).call(this, fromScene);
        this.rt.destroy();
        this.rt = null;
      }
    }, {
      key: "snapshot",
      value: function snapshot(gameObjects, config) {
        if (config === undefined) {
          config = {};
        }
        config.gameObjects = gameObjects;
        config.renderTexture = this.rt;
        Snapshot(config);
        if (this.width !== this.frame.realWidth || this.height !== this.frame.realHeight) {
          this.syncSize();
        }
        return this;
      }
    }]);
    return RenderTexture;
  }(Image$1);

  Phaser.Animations.AnimationState;
  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;

  var ForEachFace = function ForEachFace(faces, callback, scope, ignoreInvalid) {
    if (Array.isArray(faces)) {
      var isBreak = false;
      for (var i = 0, cnt = faces.length; i < cnt; i++) {
        var face = faces[i];
        if (ignoreInvalid && !face) {
          continue;
        }
        if (scope) {
          isBreak = callback.call(scope, face, i, faces);
        } else {
          isBreak = callback(face, i, faces);
        }
        if (isBreak) {
          return;
        }
      }
    } else {
      var isBreak = false;
      for (var name in faces) {
        var face = faces[name];
        if (ignoreInvalid && !face) {
          continue;
        }
        if (scope) {
          isBreak = callback.call(scope, face, name, faces);
        } else {
          isBreak = callback(face, name, faces);
        }
        if (isBreak) {
          return;
        }
      }
    }
  };

  var RadToDeg = Phaser.Math.RadToDeg;
  var DegToRad$1 = Phaser.Math.DegToRad;
  var FaceContainer = /*#__PURE__*/function (_Container) {
    _inherits(FaceContainer, _Container);
    function FaceContainer(scene, x, y, width, height, faces) {
      var _this;
      _classCallCheck(this, FaceContainer);
      _this = _callSuper(this, FaceContainer, [scene, x, y, width, height]);
      _this.faces = faces; // Face Dictionary, or array

      ForEachFace(faces, function (face) {
        face.setPosition(x, y);
        this.add(face);
      }, _assertThisInitialized(_this), true);
      return _this;
    }

    // Override
    _createClass(FaceContainer, [{
      key: "rotationX",
      get: function get() {
        return 0;
      }

      // Override
      ,
      set: function set(value) {
        // rad
      }
    }, {
      key: "angleX",
      get: function get() {
        return RadToDeg(this.rotationX);
      },
      set: function set(value) {
        this.rotationX = DegToRad$1(value);
      }
    }, {
      key: "rotateX",
      get: function get() {
        return RadToDeg(this.rotationX);
      },
      set: function set(value) {
        this.rotationX = DegToRad$1(value);
      }

      // Override
    }, {
      key: "rotationY",
      get: function get() {
        return 0;
      }

      // Override
      ,
      set: function set(value) {
        // rad
      }
    }, {
      key: "angleY",
      get: function get() {
        return RadToDeg(this.rotationY);
      },
      set: function set(value) {
        this.rotationY = DegToRad$1(value);
      }
    }, {
      key: "rotateY",
      get: function get() {
        return RadToDeg(this.rotationY);
      },
      set: function set(value) {
        this.rotationY = DegToRad$1(value);
      }

      // Override
    }, {
      key: "rotationZ",
      get: function get() {
        return 0;
      }

      // Override
      ,
      set: function set(value) {
        // rad
      }
    }, {
      key: "angleZ",
      get: function get() {
        return RadToDeg(this.rotationZ);
      },
      set: function set(value) {
        this.rotationZ = DegToRad$1(value);
      }
    }, {
      key: "rotateZ",
      get: function get() {
        return RadToDeg(this.rotationZ);
      },
      set: function set(value) {
        this.rotationZ = DegToRad$1(value);
      }
    }, {
      key: "setDebug",
      value: function setDebug(graphic, callback) {
        ForEachFace(this.faces, function (face) {
          face.setDebug(graphic, callback);
        }, null, true);
        return this;
      }
    }, {
      key: "panX",
      value: function panX(v) {
        ForEachFace(this.faces, function (face) {
          face.panX(v);
        }, null, true);
        return this;
      }
    }, {
      key: "panY",
      value: function panY(v) {
        ForEachFace(this.faces, function (face) {
          face.panY(v);
        }, null, true);
        return this;
      }
    }, {
      key: "panZ",
      value: function panZ(v) {
        ForEachFace(this.faces, function (face) {
          face.panZ(v);
        }, null, true);
        return this;
      }
    }, {
      key: "transformVerts",
      value: function transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
        ForEachFace(this.faces, function (face) {
          face.transformVerts(x, y, z, rotateX, rotateY, rotateZ);
        }, null, true);
        return this;
      }
    }, {
      key: "forEachFace",
      value: function forEachFace(callback, scope, ignoreInvalid) {
        ForEachFace(this.faces, callback, scope, ignoreInvalid);
        return this;
      }
    }]);
    return FaceContainer;
  }(ContainerLite);

  var IsPlainObject$4 = Phaser.Utils.Objects.IsPlainObject;
  var DefaultImageConfig = {
    key: '__WHITE'
  };
  var ClassMap = {
    image: Image$1,
    rendertexture: RenderTexture
  };
  var CreatePerspectiveObject = function CreatePerspectiveObject(scene, config) {
    if (config === undefined) {
      config = DefaultImageConfig;
    }
    var perspectiveObject;
    if (IsPlainObject$4(config)) {
      if (!config.hasOwnProperty('type')) {
        if (config.hasOwnProperty('key')) {
          config.type = 'image';
        } else if (config.hasOwnProperty('width')) {
          config.type = 'rendertexture';
        }
      }
      perspectiveObject = new ClassMap[config.type](scene, config);
      scene.add.existing(perspectiveObject);
    } else {
      perspectiveObject = config;
    }
    return perspectiveObject;
  };

  var CreateFaces = function CreateFaces(scene, config, faceNames) {
    var faces;
    if (faceNames === undefined) {
      // Return an array of faces
      faces = [];
      var face, faceConfig;
      for (var i = 0, cnt = config.length; i < cnt; i++) {
        faceConfig = config[i];
        if (faceConfig) {
          face = CreatePerspectiveObject(scene, faceConfig);
        } else {
          face = null;
        }
        faces.push(face);
      }
    } else {
      // Return a face map
      faces = {};
      var face, name;
      for (var i = 0, cnt = faceNames.length; i < cnt; i++) {
        name = faceNames[i];
        if (config.hasOwnProperty(name)) {
          face = CreatePerspectiveObject(scene, config[name]);
        } else {
          face = null;
        }
        faces[name] = face;
      }
    }
    return faces;
  };

  var DegToRad = Phaser.Math.DegToRad;
  var RAD180 = DegToRad(180);
  var LayoutFaces = function LayoutFaces(parent, faces) {
    var backFace = faces.back;
    if (backFace) {
      if (parent.orientation === 0) {
        // Flip around Y
        backFace.transformVerts(0, 0, 0, 0, RAD180, 0);
      } else {
        // Flip around X
        backFace.transformVerts(0, 0, 0, RAD180, 0, 0);
      }
    }
  };

  var GetValue$F = Phaser.Utils.Objects.GetValue;
  var Linear = Phaser.Math.Linear;
  var Flip = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(Flip, _EaseValueTaskBase);
    function Flip(gameObject, config) {
      var _this;
      _classCallCheck(this, Flip);
      _this = _callSuper(this, Flip, [gameObject, config]);
      // this.parent = gameObject;
      // this.timer

      _this.resetFromJSON(config);
      _this.boot();
      return _this;
    }
    _createClass(Flip, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Flip.prototype), "resetFromJSON", this).call(this, o);
        this.setEase(GetValue$F(o, 'ease', 'Cubic'));
        this.setFrontToBackDirection(GetValue$F(o, 'frontToBack', 0));
        this.setBackToFrontDirection(GetValue$F(o, 'backToFront', 1));
        return this;
      }
    }, {
      key: "setFrontToBackDirection",
      value: function setFrontToBackDirection(direction) {
        if (typeof direction === 'string') {
          direction = DIRMODE[direction];
        }
        this.endAngleFB = direction === 0 ? 180 : -180;
        return this;
      }
    }, {
      key: "setBackToFrontDirection",
      value: function setBackToFrontDirection(direction) {
        if (typeof direction === 'string') {
          direction = DIRMODE[direction];
        }
        this.endAngleBF = direction === 0 ? -180 : 180;
        return this;
      }
    }, {
      key: "start",
      value: function start(duration, repeat) {
        if (this.timer.isRunning) {
          return this;
        }
        this.timer.setDelay(this.delay).setDuration(duration);
        var loop = repeat + 1;
        var gameObject = this.parent;
        if (gameObject.face === 0) {
          // isFrontToBack
          this.startAngle = 0;
          this.endAngle = this.endAngleFB * loop;
        } else {
          this.startAngle = this.endAngleBF;
          this.endAngle = this.startAngle - this.endAngleBF * loop;
        }
        _get(_getPrototypeOf(Flip.prototype), "start", this).call(this);
        return this;
      }
    }, {
      key: "flip",
      value: function flip(duration, repeat) {
        if (this.isRunning) {
          return this;
        }
        if (duration === undefined) {
          duration = this.duration;
        }
        if (repeat === undefined) {
          repeat = 0;
        }
        this.start(duration, repeat);
        this.emit('start', this.parent, this);

        // Set face index
        this.parent.currentFaceIndex = (this.parent.currentFaceIndex + repeat + 1) % 2;
        return this;
      }
    }, {
      key: "flipRight",
      value: function flipRight(duration, repeat) {
        if (this.parent.currentFaceIndex === 0) {
          // Front to back
          this.setFrontToBackDirection(0);
        } else {
          // Back to front
          this.setBackToFrontDirection(0);
        }
        this.flip(duration, repeat);
        return this;
      }
    }, {
      key: "flipLeft",
      value: function flipLeft(duration, repeat) {
        if (this.parent.currentFaceIndex === 0) {
          // Front to back
          this.setFrontToBackDirection(1);
        } else {
          // Back to front
          this.setBackToFrontDirection(1);
        }
        this.flip(duration, repeat);
        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(gameObject, timer) {
        var t = this.easeFn(timer.t);
        var value = Linear(this.startAngle, this.endAngle, t);
        if (gameObject.orientation === 0) {
          gameObject.angleY = value;
        } else {
          gameObject.angleX = value;
        }
      }
    }]);
    return Flip;
  }(EaseValueTaskBase);
  var DIRMODE = {
    'right': 0,
    'left-to-right': 0,
    'left': 1,
    'right-to-left': 1
  };

  var IsPlainObject$3 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$E = Phaser.Utils.Objects.GetValue;
  var FaceNames = ['back', 'front'];
  var Card = /*#__PURE__*/function (_FaceContainer) {
    _inherits(Card, _FaceContainer);
    function Card(scene, x, y, config) {
      var _this;
      _classCallCheck(this, Card);
      if (IsPlainObject$3(x)) {
        config = x;
        x = GetValue$E(config, 'x', 0);
        y = GetValue$E(config, 'y', 0);
      }
      var faces = CreateFaces(scene, config, FaceNames);
      var backFace = faces.back;
      var frontFace = faces.front;
      var width = GetValue$E(config, 'width');
      var height = GetValue$E(config, 'height');
      if (width === undefined || height === undefined) {
        if (width === undefined) {
          var frontFaceWidth = frontFace ? frontFace.width : 0;
          var backFaceWidth = backFace ? backFace.width : 0;
          width = Math.max(frontFaceWidth, backFaceWidth);
        }
        if (height === undefined) {
          var frontFaceHeight = frontFace ? frontFace.height : 0;
          var backFaceHeight = backFace ? backFace.height : 0;
          height = Math.max(frontFaceHeight, backFaceHeight);
        }
      }
      _this = _callSuper(this, Card, [scene, x, y, width, height, faces]);
      _this.type = 'rexPerspectiveCard';
      _this.frontFaceRotationX = 0;
      _this.frontFaceRotationY = 0;
      _this.frontFaceRotationZ = 0;
      ForEachFace(faces, function (face, name) {
        this["".concat(name, "Face")] = face;
      }, _assertThisInitialized(_this));
      var flipConfig = GetValue$E(config, 'flip', undefined);
      if (flipConfig !== false) {
        _this.flip = new Flip(_assertThisInitialized(_this), flipConfig);
      }
      _this.setOrientation(GetValue$E(config, 'orientation', 0));
      LayoutFaces(_assertThisInitialized(_this), faces);
      _this.setFace(GetValue$E(config, 'face', 0));
      return _this;
    }
    _createClass(Card, [{
      key: "rotationX",
      get: function get() {
        return this.frontFaceRotationX;
      },
      set: function set(value) {
        if (this.frontFaceRotationX === value) {
          return;
        }
        this.frontFaceRotationX = value;
        ForEachFace(this.faces, function (face) {
          face.rotationX = value;
        }, null, true);
      }
    }, {
      key: "rotationY",
      get: function get() {
        return this.frontFaceRotationY;
      },
      set: function set(value) {
        if (this.frontFaceRotationY === value) {
          return;
        }
        this.frontFaceRotationY = value;
        ForEachFace(this.faces, function (face) {
          face.rotationY = value;
        }, null, true);
      }
    }, {
      key: "rotationZ",
      get: function get() {
        return this.frontFaceRotationZ;
      },
      set: function set(value) {
        if (this.frontFaceRotationZ === value) {
          return;
        }
        this.frontFaceRotationZ = value;
        ForEachFace(this.faces, function (face) {
          face.rotationZ = value;
        }, null, true);
      }
    }, {
      key: "setOrientation",
      value: function setOrientation(orientation) {
        if (typeof orientation === 'string') {
          orientation = ORIENTATIONMODE[orientation];
        }
        this.orientation = orientation;
        return this;
      }
    }, {
      key: "face",
      get: function get() {
        return this.currentFaceIndex;
      },
      set: function set(index) {
        if (typeof index === 'string') {
          index = FACEMODE[index];
        }
        this.currentFaceIndex = index;
        var isBackFace = index === 1;
        var angle = isBackFace ? 180 : 0;
        if (this.orientation === 0) {
          // Flip around Y
          this.angleY = angle;
        } else {
          // Flip around X
          this.angleX = angle;
        }
      }
    }, {
      key: "setFace",
      value: function setFace(face) {
        this.face = face;
        return this;
      }
    }, {
      key: "toggleFace",
      value: function toggleFace() {
        var newFace = this.face === 0 ? 1 : 0;
        this.setFace(newFace);
        return this;
      }
    }]);
    return Card;
  }(FaceContainer);
  var ORIENTATIONMODE = {
    x: 0,
    horizontal: 0,
    h: 0,
    y: 1,
    vertical: 1,
    v: 1
  };
  var FACEMODE = {
    front: 0,
    back: 1
  };

  Phaser.Utils.Objects.GetValue;
  Phaser.Math.RadToDeg;
  Phaser.Math.DegToRad;
  Phaser.Math.Angle.WrapDegrees;
  Phaser.Math.Angle.ShortestBetween;
  Phaser.Math.Wrap;
  Phaser.Math.Linear;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;
  Phaser.Math.DegToRad;
  Phaser.Math.RadToDeg;
  Phaser.Math.Angle.WrapDegrees;
  Phaser.Math.Linear;
  Phaser.Math.Wrap;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;
  Phaser.Math.Wrap;

  Phaser.Utils.Objects.GetValue;

  var GetValue$D = Phaser.Utils.Objects.GetValue;
  var CreatePerspectiveCardMesh = function CreatePerspectiveCardMesh(config) {
    var scene = this.scene;
    this.setSnapshotPadding(GetValue$D(config, 'snapshotPadding', 0));
    config = Clone$2(config);
    // Remove size config
    delete config.width;
    delete config.height;
    // Initial size of render-texture is 1x1
    config.front = {
      width: 1,
      height: 1
    };
    config.back = {
      width: 1,
      height: 1
    };
    // Create PerspectiveCard as card-behavior
    var card = new Card(scene, config);
    scene.add.existing(card);
    var flip = card.flip;
    if (flip) {
      var parent = this;
      flip.on('start', function () {
        // Before flipping
        parent.enterPerspectiveMode();
      }).on('complete', function () {
        // After flipping
        parent.exitPerspectiveMode();
      });
    }
    return card;
  };

  var FaceIndexMap = ['front', 'back'];
  var PerspectiveMethods = {
    enterPerspectiveMode: function enterPerspectiveMode() {
      if (this.isInPerspectiveMode) {
        return this;
      }

      // Set card's visible to true
      this.setChildVisible(this.perspectiveCard, true);
      // Snapshot front and back children to card's faces
      this.snapshotFace(0);
      this.snapshotFace(1);
      // Set front and back children's visible to false
      this.setChildVisible(this.childrenMap.front, false);
      this.setChildVisible(this.childrenMap.back, false);
      // Reset size of card
      this.perspectiveCard.setSize(this.width, this.height);
      return this;
    },
    exitPerspectiveMode: function exitPerspectiveMode() {
      if (!this.isInPerspectiveMode) {
        return this;
      }

      // Set card's visible to false
      this.setChildVisible(this.perspectiveCard, false);
      // Set front or back children's visible to true, according to card's face
      var isFrontFace = this.perspectiveCard.face === 0;
      this.setChildVisible(this.childrenMap.front, isFrontFace);
      this.setChildVisible(this.childrenMap.back, !isFrontFace);
      return this;
    },
    setSnapshotPadding: function setSnapshotPadding(padding) {
      this.snapshotPadding = padding;
      return this;
    },
    snapshotFace: function snapshotFace(face) {
      if (typeof face === 'number') {
        face = FaceIndexMap[face];
      }
      var cardFace = this.perspectiveCard.faces[face];
      var faceChild = this.childrenMap[face];
      cardFace.rt.clear();
      var faceChildVisibleSave = faceChild.visible;
      faceChild.visible = true;
      var gameObjects = faceChild.isRexContainerLite ? faceChild.getAllVisibleChildren() : faceChild;
      cardFace.snapshot(gameObjects, {
        padding: this.snapshotPadding
      });
      faceChild.visible = faceChildVisibleSave;
      return this;
    }
  };

  var GetValue$C = Phaser.Utils.Objects.GetValue;
  var PerspectiveCard = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(PerspectiveCard, _OverlapSizer);
    function PerspectiveCard(scene, config) {
      var _this;
      _classCallCheck(this, PerspectiveCard);
      _this = _callSuper(this, PerspectiveCard, [scene, config]);
      _this.type = 'rexPerspectiveCard';

      // Layout faces
      var backFace = config.back;
      var backFaceExpand = GetValue$C(config, 'expand.back', true);
      _this.add(backFace, {
        key: 'back',
        expand: backFaceExpand
      });
      var frontFace = config.front;
      var frontFaceExpand = GetValue$C(config, 'expand.front', true);
      _this.add(frontFace, {
        key: 'front',
        expand: frontFaceExpand
      });

      // Add PerspectiveCardMesh
      _this.perspectiveCard = CreatePerspectiveCardMesh.call(_assertThisInitialized(_this), config);
      _this.pin(_this.perspectiveCard);
      _this.exitPerspectiveMode(false);
      return _this;
    }
    _createClass(PerspectiveCard, [{
      key: "flip",
      get: function get() {
        return this.perspectiveCard.flip;
      }
    }, {
      key: "face",
      get: function get() {
        return this.perspectiveCard.face;
      },
      set: function set(index) {
        // Can't set face during flipping
        if (this.flip && this.flip.isRunning) {
          return;
        }
        this.perspectiveCard.face = index;
        var isFrontFace = index === 0;
        var frontFace = this.childrenMap.front;
        var backFace = this.childrenMap.back;
        this.setChildVisible(frontFace, isFrontFace);
        this.setChildVisible(backFace, !isFrontFace);
      }
    }, {
      key: "setFace",
      value: function setFace(face) {
        this.face = face;
        return this;
      }
    }, {
      key: "toggleFace",
      value: function toggleFace() {
        var newFace = this.face === 0 ? 1 : 0;
        this.setFace(newFace);
        return this;
      }
    }, {
      key: "isInPerspectiveMode",
      get: function get() {
        return this.perspectiveCard.visible;
      }
    }, {
      key: "rotationX",
      get: function get() {
        return this.perspectiveCard.rotationX;
      },
      set: function set(value) {
        this.enterPerspectiveMode();
        this.perspectiveCard.rotationX = value;
      }
    }, {
      key: "angleX",
      get: function get() {
        return this.perspectiveCard.angleX;
      },
      set: function set(value) {
        this.enterPerspectiveMode();
        this.perspectiveCard.angleX = value;
      }
    }, {
      key: "rotationY",
      get: function get() {
        return this.perspectiveCard.rotationY;
      },
      set: function set(value) {
        this.enterPerspectiveMode();
        this.perspectiveCard.rotationY = value;
      }
    }, {
      key: "angleY",
      get: function get() {
        return this.perspectiveCard.angleY;
      },
      set: function set(value) {
        this.enterPerspectiveMode();
        this.perspectiveCard.angleY = value;
      }
    }, {
      key: "rotationZ",
      get: function get() {
        return this.perspectiveCard.rotationZ;
      },
      set: function set(value) {
        this.enterPerspectiveMode();
        this.perspectiveCard.rotationZ = value;
      }
    }, {
      key: "angleZ",
      get: function get() {
        return this.perspectiveCard.angleZ;
      },
      set: function set(value) {
        this.enterPerspectiveMode();
        this.perspectiveCard.angleZ = value;
      }
    }, {
      key: "panX",
      value: function panX(v) {
        this.enterPerspectiveMode();
        this.perspectiveCard.panX(v);
        return this;
      }
    }, {
      key: "panY",
      value: function panY(v) {
        this.enterPerspectiveMode();
        this.perspectiveCard.panY(v);
        return this;
      }
    }, {
      key: "panZ",
      value: function panZ(v) {
        this.enterPerspectiveMode();
        this.perspectiveCard.panZ(v);
        return this;
      }
    }, {
      key: "transformVerts",
      value: function transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
        this.enterPerspectiveMode();
        this.perspectiveCard.transformVerts(x, y, z, rotateX, rotateY, rotateZ);
        return this;
      }
    }, {
      key: "forEachFace",
      value: function forEachFace(callback, scope, ignoreInvalid) {
        this.enterPerspectiveMode();
        this.perspectiveCard.forEachFace(callback, scope, ignoreInvalid);
        return this;
      }
    }]);
    return PerspectiveCard;
  }(OverlapSizer);
  Object.assign(PerspectiveCard.prototype, PerspectiveMethods);

  var GetPageKeyByIndex = function GetPageKeyByIndex(index) {
    var buttons = this.getElement('tabs.buttons');
    if (index >= buttons.length) {
      return undefined;
    }
    return buttons[index].name;
  };

  var GetPageIndexByKey = function GetPageIndexByKey(key) {
    var buttons = this.getElement('tabs.buttons');
    for (var i = 0, cnt = buttons.length; i < cnt; i++) {
      if (buttons[i].name === key) {
        return i;
      }
    }
    return undefined;
  };

  var IsPlainObject$2 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$B = Phaser.Utils.Objects.GetValue;
  var UUID$2 = Phaser.Utils.String.UUID;
  var AddPage = function AddPage(key, tabGameObject, pageGameObject) {
    if (IsPlainObject$2(key)) {
      var config = key;
      key = GetValue$B(config, 'key');
      tabGameObject = GetValue$B(config, 'tab');
      pageGameObject = GetValue$B(config, 'page');
    }
    if (!key) {
      key = UUID$2();
    }
    tabGameObject.name = key; // For ratio buttons

    this.childrenMap.tabs.addButton(tabGameObject);
    this.childrenMap.pages.addPage(pageGameObject, {
      key: key
    });
    return this;
  };

  var SwapPage = function SwapPage(key, fadeInDuration) {
    var index;
    if (typeof key === 'number') {
      index = key;
    } else {
      index = this.getPageIndex(key);
    }
    if (index != null) {
      // Override fadeInDuration
      var fadeInDurationSave;
      if (fadeInDuration !== undefined) {
        fadeInDurationSave = this.childrenMap.pages.fadeInDuration;
        this.childrenMap.pages.fadeInDuration = fadeInDuration;
      }
      this.childrenMap.tabs.emitButtonClick(index);

      // Restore fadeInDuration
      if (fadeInDurationSave !== undefined) {
        this.childrenMap.pages.fadeInDuration = fadeInDurationSave;
      }
    }
    return this;
  };
  var SwapFirstPage = function SwapFirstPage(fadeInDuration) {
    this.swapPage(0, fadeInDuration);
    return this;
  };
  var SwapLastPage = function SwapLastPage(fadeInDuration) {
    var index = this.getElement('tabs.buttons').length - 1;
    this.swapPage(index, fadeInDuration);
    return this;
  };
  var SwapPageMethods = {
    swapPage: SwapPage,
    swapFirstPage: SwapFirstPage,
    swapLastPage: SwapLastPage
  };

  var RemovePageMethods = {
    removePage: function removePage(key, destroyChild) {
      if (typeof key === 'number') {
        key = this.getPageKey(key);
      }
      var tabs = this.childrenMap.tabs;
      var tabGameObject = tabs.getByName(key);
      var pages = this.childrenMap.pages;
      var pageGameObject = pages.getElement(key);
      if (!tabGameObject || !pageGameObject) {
        return this;
      }
      pages.removeChildrenMap(key);
      tabs.removeButton(tabGameObject, destroyChild);
      pages.remove(pageGameObject, destroyChild);
      return this;
    },
    removeAllPages: function removeAllPages(destroyChild) {
      var buttons = this.getElement('tabs.buttons');
      for (var i = buttons.length - 1; i >= 0; i--) {
        this.removePage(buttons[i].name, destroyChild);
      }
      return this;
    }
  };

  var GetPage = function GetPage(key) {
    if (typeof key === 'number') {
      key = this.getPageKey(key);
    }
    return this.childrenMap.pages.getPage(key);
  };

  var GetTab = function GetTab(key) {
    var index;
    if (typeof key === 'number') {
      index = key;
    } else {
      index = this.getPageIndex(key);
    }
    return this.getElement('tabs.buttons')[index];
  };

  var TabsPositionToIndex = {
    top: 1,
    left: 3,
    right: 5,
    bottom: 7
  };
  var TabsPositionToTabsPaddingKey = {
    top: 'bottom',
    left: 'right',
    right: 'left',
    bottom: 'top'
  };
  var SetTabPosition = function SetTabPosition(tabsPosition) {
    var newIndex = TabsPositionToIndex[tabsPosition];
    if (newIndex === undefined) {
      return this;
    }
    var tabs = this.childrenMap.tabs;
    var currentIndex = this.sizerChildren.indexOf(tabs);
    if (currentIndex === newIndex) {
      return this;
    }
    this.sizerChildren[currentIndex] = null;
    this.sizerChildren[newIndex] = tabs;
    var tabPadding = this.getSizerConfig(tabs).padding;
    var currentPaddingKey = TabsPositionToTabsPaddingKey[this.tabsPosition];
    var newPaddingKey = TabsPositionToTabsPaddingKey[tabsPosition];
    tabPadding[newPaddingKey] = tabPadding[currentPaddingKey];
    tabPadding[currentPaddingKey] = 0;
    this.tabsPosition = tabsPosition;
    return this;
  };

  var methods$8 = {
    getPageKey: GetPageKeyByIndex,
    getPageIndex: GetPageIndexByKey,
    addPage: AddPage,
    getPage: GetPage,
    getTab: GetTab,
    setTabPosition: SetTabPosition
  };
  Object.assign(methods$8, SwapPageMethods, RemovePageMethods);

  var GetValue$A = Phaser.Utils.Objects.GetValue;
  var SizerAdd = GridSizer.prototype.add;
  var TabPages$1 = /*#__PURE__*/function (_GridSizer) {
    _inherits(TabPages, _GridSizer);
    function TabPages(scene, config) {
      var _this;
      _classCallCheck(this, TabPages);
      if (config === undefined) {
        config = {};
      }
      // Create sizer
      config.column = 3;
      config.row = 3;
      config.columnProportions = [0, 0, 0];
      config.rowProportions = [0, 0, 0];
      var expandPages = GetValue$A(config, 'expand.pages', true);
      if (expandPages) {
        config.columnProportions[1] = 1;
        config.rowProportions[1] = 1;
      }
      _this = _callSuper(this, TabPages, [scene, config]);
      _this.type = 'rexTabPages';

      // Add elements
      var background = GetValue$A(config, 'background', undefined);
      if (background) {
        _this.addBackground(background);
      }
      var pagesConfig = GetValue$A(config, 'pages');
      var pages = new Pages(scene, pagesConfig);
      scene.add.existing(pages);
      var tabsPosition = GetValue$A(config, 'tabsPosition', undefined);
      if (tabsPosition === undefined) {
        tabsPosition = GetValue$A(config, 'tabPosition', 'top');
      }
      var wrapTabs = GetValue$A(config, 'wrapTabs', false);
      var ButtonsClass = wrapTabs ? Buttons : Buttons$1;
      var tabsConfig = GetValue$A(config, 'tabs', undefined);
      if (tabsConfig === undefined) {
        tabsConfig = {};
      }
      tabsConfig.orientation = tabsPosition === 'top' || tabsPosition === 'bottom' ? 'x' : 'y';
      tabsConfig.buttonsType = 'radio';
      if (!wrapTabs && !tabsConfig.hasOwnProperty('expand')) {
        tabsConfig.expand = GetValue$A(config, 'expand.tabs', false);
      }
      var tabs = new ButtonsClass(scene, tabsConfig);
      scene.add.existing(tabs);

      // Add to sizer
      SizerAdd.call(_assertThisInitialized(_this), pages, {
        column: 1,
        row: 1,
        expand: expandPages
      });
      var tabColumnIndex, tabRowIndex;
      var tabPadding = GetValue$A(config, 'space.item', 0); // Backward compatible
      switch (tabsPosition) {
        case 'top':
          tabColumnIndex = 1;
          tabRowIndex = 0;
          tabPadding = {
            bottom: tabPadding
          };
          break;
        case 'bottom':
          tabColumnIndex = 1;
          tabRowIndex = 2;
          tabPadding = {
            top: tabPadding
          };
          break;
        case 'left':
          tabColumnIndex = 0;
          tabRowIndex = 1;
          tabPadding = {
            right: tabPadding
          };
          break;
        case 'right':
          tabColumnIndex = 2;
          tabRowIndex = 1;
          tabPadding = {
            left: tabPadding
          };
          break;
      }
      SizerAdd.call(_assertThisInitialized(_this), tabs, {
        column: tabColumnIndex,
        row: tabRowIndex,
        padding: tabPadding,
        expand: wrapTabs ? true : GetValue$A(config, 'expand.tabs', false),
        align: GetValue$A(config, 'align.tabs', 'left')
      });
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('tabs', tabs);
      _this.addChildrenMap('pages', pages);
      _this.tabsPosition = tabsPosition;

      // Register events
      tabs.on('button.click', function (tab) {
        var key = tab.name;
        if (pages.hasPage(key)) {
          pages.swapPage(key);
        }
      });
      tabs.on('button.statechange', function (tab, index, value, previousValue) {
        var eventName = value ? 'tab.focus' : 'tab.blur';
        this.emit(eventName, tab, tab.name);
      }, _assertThisInitialized(_this));
      pages.on('pagevisible', function (pageObject, key, pages) {
        this.emit('page.focus', pageObject, key);
      });
      pages.on('pageinvisible', function (pageObject, key, pages) {
        this.emit('page.blur', pageObject, key);
      });
      return _this;
    }
    _createClass(TabPages, [{
      key: "currentKey",
      get: function get() {
        return this.getElement('pages').currentKey;
      },
      set: function set(key) {
        this.showPage(key);
      }
    }, {
      key: "keys",
      get: function get() {
        return this.getElement('pages').keys;
      }
    }, {
      key: "currentPage",
      get: function get() {
        return this.getElement('pages').currentPage;
      }
    }, {
      key: "previousPage",
      get: function get() {
        return this.getElement('pages').previousPage;
      }
    }]);
    return TabPages;
  }(GridSizer);
  Object.assign(TabPages$1.prototype, methods$8);

  var Transition = /*#__PURE__*/function (_OpenCloseTransition) {
    _inherits(Transition, _OpenCloseTransition);
    function Transition(gameObject, config) {
      _classCallCheck(this, Transition);
      if (config === undefined) {
        config = {};
      }
      config.destroy = false;
      return _callSuper(this, Transition, [gameObject, config]);
    }
    _createClass(Transition, [{
      key: "onOpen",
      value: function onOpen() {
        this.emit('open', this.parent, this);
        _get(_getPrototypeOf(Transition.prototype), "onOpen", this).call(this);
      }
    }, {
      key: "onClose",
      value: function onClose() {
        this.emit('close', this.parent, this);
        _get(_getPrototypeOf(Transition.prototype), "onClose", this).call(this);
      }
    }]);
    return Transition;
  }(OpenCloseTransition);

  var ExpandMethods = {
    expand: function expand(duration) {
      if (this.expanded === true) {
        return this;
      }
      if (duration === undefined) {
        duration = this.transitionDuration;
      }
      this.expanded = true;
      var title = this.childrenMap.title;
      var child = this.childrenMap.child;
      this.show(child);
      if (this.reLayoutEnable) {
        var layoutTarget = this.reLayoutTarget ? this.reLayoutTarget : this.getTopmostSizer();
        layoutTarget.layout();
      }
      title.emit('folder.expand', duration, this);
      child.emit('folder.expand', duration, this);
      this.emit('expand.start', this);
      this.childTransition.once('open', function () {
        this.emit('expand.complete', this);
      }, this).requestOpen(null, duration);
      return this;
    },
    collapse: function collapse(duration) {
      if (this.expanded === false) {
        return this;
      }
      if (duration === undefined) {
        duration = this.transitionDuration;
      }
      this.expanded = false;
      var title = this.childrenMap.title;
      var child = this.childrenMap.child;
      title.emit('folder.collapse', duration, this);
      child.emit('folder.collapse', duration, this);
      this.emit('collapse.start', this);
      this.childTransition.once('close', function () {
        this.setChildScale(child, 1, 1).hide(child);
        if (this.reLayoutEnable) {
          var layoutTarget = this.reLayoutTarget ? this.reLayoutTarget : this.getTopmostSizer();
          layoutTarget.layout();
        }
        this.emit('collapse.complete', this);
      }, this).requestClose(null, duration);
      return this;
    },
    toggle: function toggle(duration) {
      if (this.expanded) {
        this.collapse(duration);
      } else {
        this.expand(duration);
      }
      return this;
    },
    setExpandedState: function setExpandedState(expanded) {
      this.reLayoutEnable = false;
      if (expanded === undefined) {
        this.expanded = undefined;
      } else if (expanded) {
        this.expand(0);
      } else {
        this.collapse(0);
      }
      this.reLayoutEnable = true;
      return this;
    }
  };

  var DefaultExpandCallback = function DefaultExpandCallback(gameObject, duration) {
    ScaleMethods.popUp.call(gameObject, duration, this.expandDirection);
  };
  var DefaultCollapseCallback = function DefaultCollapseCallback(gameObject, duration) {
    ScaleMethods.scaleDown.call(gameObject, duration, this.expandDirection);
  };
  var ConfigurationMethods$1 = {
    setTransitionDuration: function setTransitionDuration(duration) {
      this.transitionDuration = duration;
      this.childTransition.setTransitInTime(duration).setTransitOutTime(duration);
      return this;
    },
    setExpandCallback: function setExpandCallback(callback) {
      if (callback === undefined) {
        callback = DefaultExpandCallback.bind(this);
      }
      this.childTransition.setTransitInCallback(callback);
      return this;
    },
    setCollapseCallback: function setCollapseCallback(callback) {
      if (callback === undefined) {
        callback = DefaultCollapseCallback.bind(this);
      }
      this.childTransition.setTransitOutCallback(callback);
      return this;
    }
  };

  var GetValue$z = Phaser.Utils.Objects.GetValue;
  var Folder$1 = /*#__PURE__*/function (_Sizer) {
    _inherits(Folder, _Sizer);
    function Folder(scene, config) {
      var _this;
      _classCallCheck(this, Folder);
      if (config === undefined) {
        config = {};
      }
      if (!config.hasOwnProperty('orientation')) {
        config.orientation = 1;
      }
      _this = _callSuper(this, Folder, [scene, config]);
      _this.type = 'rexFolder';
      _this.reLayoutEnable = true;
      _this.expanded = undefined;
      _this.expandDirection = _this.orientation === 1 ? 'y' : 'x';
      var background = config.background;
      var title = config.title;
      var child = config.child;

      // background
      if (background) {
        _this.addBackground(background);
      }
      var spaceConfig = GetValue$z(config, 'space');

      // title
      var defaultAlign = _this.orientation === 1 ? 'left' : 'top';
      var align = GetValue$z(config, 'align.title', defaultAlign);
      var expand = GetValue$z(config, 'expand.title', true);
      _this.add(title, {
        proportion: 0,
        align: align,
        expand: expand,
        padding: {
          left: GetValue$z(spaceConfig, 'titleLeft', 0),
          right: GetValue$z(spaceConfig, 'titleRight', 0),
          top: GetValue$z(spaceConfig, 'titleTop', 0),
          bottom: GetValue$z(spaceConfig, 'titleBottom', 0)
        }
      });
      var toggleByTarget = GetValue$z(config, 'toggleByTarget', undefined);
      var toggleClickConfig = GetValue$z(config, 'toggleClickConfig');
      if (toggleByTarget === undefined) {
        toggleByTarget = title;
      }
      if (toggleByTarget) {
        ClickMethods.onClick.call(toggleByTarget, function () {
          this.toggle();
        }, _assertThisInitialized(_this), toggleClickConfig);
      }

      // child
      _this.childTransition = new Transition(child);
      var customOrigin = GetValue$z(config, 'customChildOrigin', false);
      if (!customOrigin) {
        var origin = !_this.rtl ? 0 : 1;
        child.setOrigin(origin);
      }
      var align = GetValue$z(config, 'align.child', 'left');
      var expand = GetValue$z(config, 'expand.child', true);
      var proportion = expand ? 1 : 0;
      _this.add(child, {
        proportion: proportion,
        align: align,
        expand: expand,
        padding: {
          left: GetValue$z(spaceConfig, 'childLeft', 0),
          right: GetValue$z(spaceConfig, 'childRight', 0),
          top: GetValue$z(spaceConfig, 'childTop', 0),
          bottom: GetValue$z(spaceConfig, 'childBottom', 0)
        }
      });
      _this.addChildrenMap('title', title);
      _this.addChildrenMap('child', child);
      _this.addChildrenMap('background', background);
      var transitionConfig = config.transition;
      _this.setTransitionDuration(GetValue$z(transitionConfig, 'duration', 200));
      _this.setExpandCallback(GetValue$z(transitionConfig, 'expandCallback', undefined));
      _this.setCollapseCallback(GetValue$z(transitionConfig, 'collapseCallback', undefined));
      _this.reLayoutTarget = GetValue$z(config, 'reLayoutTarget', undefined);
      var onExpandStart = config.onExpandStart;
      if (onExpandStart) {
        _this.on('expand.start', onExpandStart);
      }
      var onExpandComplete = config.onExpandComplete;
      if (onExpandComplete) {
        _this.on('expand.complete', onExpandComplete);
      }
      var onCollapseStart = config.onCollapseStart;
      if (onCollapseStart) {
        _this.on('collapse.start', onCollapseStart);
      }
      var onCollapseComplete = config.onCollapseComplete;
      if (onCollapseComplete) {
        _this.on('collapse.complete', onCollapseComplete);
      }
      var expanded = GetValue$z(config, 'expanded', undefined);
      if (expanded !== undefined) {
        _this.setExpandedState(expanded);
      }
      return _this;
    }
    return _createClass(Folder);
  }(Sizer);
  Object.assign(Folder$1.prototype, ExpandMethods, ConfigurationMethods$1);

  var ExtendNodeClass = function ExtendNodeClass(GOClass) {
    return /*#__PURE__*/function (_GOClass) {
      _inherits(Base, _GOClass);
      function Base() {
        _classCallCheck(this, Base);
        return _callSuper(this, Base, arguments);
      }
      _createClass(Base, [{
        key: "setText",
        value:
        // Wrap text/setText() from nodeBody
        function setText(text) {
          this.text = text;
          return this;
        }
      }, {
        key: "text",
        get: function get() {
          var textObject = this.childrenMap.nodeBody;
          return textObject.text;
        },
        set: function set(value) {
          var textObject = this.childrenMap.nodeBody;
          if (textObject.setText) {
            textObject.setText(value);
          }
        }

        // Wrap setTexture() from nodeBody
      }, {
        key: "setTexture",
        value: function setTexture(key, frame) {
          var imageObject = this.childrenMap.nodeBody;
          if (imageObject.setTexture) {
            imageObject.setTexture(key, frame);
          }
          return this;
        }
      }, {
        key: "texture",
        get: function get() {
          var imageObject = this.childrenMap.nodeBody;
          if (!imageObject) {
            return undefined;
          }
          return imageObject.texture;
        }
      }, {
        key: "frame",
        get: function get() {
          var imageObject = this.childrenMap.nodeBody;
          if (!imageObject) {
            return undefined;
          }
          return imageObject.frame;
        }
      }]);
      return Base;
    }(GOClass);
  };

  var ParentMethods = {
    getTreePatent: function getTreePatent(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      if (!gameObject.rexSizer) {
        return undefined;
      }
      return gameObject.rexSizer.treeParent;
    },
    getTreeRoot: function getTreeRoot(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      var treeParent;
      while (1) {
        if (!gameObject.rexSizer) {
          return undefined;
        }
        treeParent = gameObject.rexSizer.treeParent;
        if (treeParent === null) {
          return gameObject;
        }
        gameObject = treeParent;
      }
      return undefined;
    },
    isGrandsonNode: function isGrandsonNode(gameObject) {
      if (gameObject === undefined || !gameObject.rexSizer) {
        return false;
      }
      var treeParent;
      while (1) {
        if (!gameObject.rexSizer) {
          return false;
        }
        treeParent = gameObject.rexSizer.treeParent;
        if (treeParent === this) {
          return true;
        } else if (treeParent === null) {
          return false;
        }
        gameObject = treeParent;
      }
      return false;
    }
  };

  var GetValue$y = Phaser.Utils.Objects.GetValue;
  var GetGameObjectFromConfig = function GetGameObjectFromConfig(scene, config, key, createCallbackData, defaultCreateGameObjectCallback) {
    var creatorConfig = GetValue$y(config, key);
    var gameObject;
    if (IsGameObject(creatorConfig)) {
      gameObject = creatorConfig;
      delete config[key]; // Remove reference of game object
    } else if (IsFunction(creatorConfig)) {
      gameObject = creatorConfig(scene, createCallbackData);
      scene.add.existing(gameObject);
    } else if (defaultCreateGameObjectCallback) {
      gameObject = defaultCreateGameObjectCallback(scene, creatorConfig, createCallbackData);
      scene.add.existing(gameObject);
    }
    return gameObject;
  };

  var GetValue$x = Phaser.Utils.Objects.GetValue;
  var Node = /*#__PURE__*/function (_ExtendNodeClass) {
    _inherits(Node, _ExtendNodeClass);
    function Node(scene, config, createCallbackData) {
      var _this;
      _classCallCheck(this, Node);
      var spaceConfig = config.space;
      _this = _callSuper(this, Node, [scene, {
        orientation: 'x',
        space: {
          left: GetValue$x(spaceConfig, 'nodeLeft', 0),
          right: GetValue$x(spaceConfig, 'nodeRight', 0),
          top: GetValue$x(spaceConfig, 'nodeTop', 0),
          bottom: GetValue$x(spaceConfig, 'nodeBottom', 0)
        }
      }]);
      _this.type = 'rexTreeNode';

      // Optional
      var nodeBackground = GetGameObjectFromConfig(scene, config, 'nodeBackground', createCallbackData);

      // Required
      var nodeBody = GetGameObjectFromConfig(scene, config, 'nodeBody', createCallbackData, DefaultCreateNodeBodyCallback);
      if (nodeBackground) {
        _this.addBackground(nodeBackground);
      }
      _this.add(nodeBody, {
        proportion: 1,
        key: 'nodeBody'
      });
      return _this;
    }
    _createClass(Node, [{
      key: "getTreePatent",
      value: function getTreePatent() {
        return this.rexSizer.treeParent;
      }
    }, {
      key: "getTreeRoot",
      value: function getTreeRoot() {
        var treeParent = this.rexSizer.treeParent;
        if (!treeParent) {
          return null;
        }
        return treeParent.getTreeRoot();
      }
    }]);
    return Node;
  }(ExtendNodeClass(Sizer));
  var DefaultCreateNodeBodyCallback = function DefaultCreateNodeBodyCallback(scene, config, createCallbackData) {
    var gameObject = new SimpleLabel(scene, config);
    gameObject.resetDisplayContent('');
    return gameObject;
  };

  var SyncDisplayList = function SyncDisplayList(sourceGameObject, targetGameObject) {
    var p3Container = sourceGameObject.parentContainer;
    if (p3Container) {
      if (targetGameObject.isRexContainerLite) {
        // Add containerLite and its children
        targetGameObject.addToContainer(p3Container);
      } else {
        // Add gameObject directly
        p3Container.add(targetGameObject);
      }
      return;
    }
    var layer = sourceGameObject.displayList;
    if (IsLayerGameObject(layer)) {
      if (targetGameObject.isRexContainerLite) {
        // Add containerLite and its children
        targetGameObject.addToLayer(layer);
      } else {
        // Add gameObject directly
        layer.add(targetGameObject);
      }
      return;
    }
    sourceGameObject.scene.add.existing(targetGameObject);
  };

  var UUID$1 = Phaser.Utils.String.UUID;
  var AddNodeMethods = {
    addTree: function addTree(config, nodeKey) {
      if (IsGameObject(config)) {
        var nodeBody = config;
        config = {
          nodeBody: nodeBody,
          nodeKey: nodeKey
        };
      }
      return this.insertTree(undefined, config);
    },
    insertTree: function insertTree(index, config) {
      var nodeKey;
      if (typeof config === 'string') {
        nodeKey = config;
        config = undefined;
      } else if (config) {
        nodeKey = config.nodeKey;
        delete config.nodeKey;
      }
      if (nodeKey === undefined) {
        nodeKey = UUID$1();
      }
      var tree = this.createTree(config);
      SyncDisplayList(this, tree);
      this.insertNode(index, tree, {
        expand: true
      });
      return tree;
    },
    addNode: function addNode(gameObject, config) {
      return this.insertNode(undefined, gameObject, config);
    },
    insertNode: function insertNode(index, gameObject, config) {
      var nodeKey;
      if (!IsGameObject(gameObject)) {
        config = gameObject;
        gameObject = new Node(this.scene, this.configSave, {
          isLeaf: true
        });
      }
      if (typeof config === 'string') {
        nodeKey = config;
        config = undefined;
      } else if (config) {
        nodeKey = config.nodeKey;
        delete config.nodeKey;
      }
      if (nodeKey === undefined) {
        nodeKey = UUID$1();
      }
      if (config === undefined) {
        config = {};
      }
      if (!config.hasOwnProperty('expand')) {
        config.expand = true;
      }
      this.removeNode(gameObject, false);
      gameObject.rexSizer.treeParent = this;
      if (this.nodesMap.hasOwnProperty(nodeKey)) {
        console.error("[Trees] Duplicate nodeKey '".concat(nodeKey, "'"));
        this.removeNode(this.nodesMap[nodeKey], true);
      }
      gameObject.nodeKey = nodeKey;
      this.nodesMap[nodeKey] = gameObject;
      var childrenSizer = this.childrenMap.child;
      childrenSizer.insert(index, gameObject, config);
      return gameObject;
    }
  };

  var RemoveNodeMethods = {
    removeNode: function removeNode(gameObject, destroyChild) {
      if (!gameObject) {
        return this;
      }
      var treeParent = this.getTreePatent(gameObject);
      if (!treeParent) {
        return this;
      }
      delete treeParent.nodesMap[gameObject.nodeKey];
      gameObject.nodeKey = null;
      gameObject.rexSizer.treeParent = null;
      var childrenSizer = treeParent.childrenMap.child;
      childrenSizer.remove(gameObject, destroyChild);
      return this;
    },
    removeAllNodes: function removeAllNodes(destroyChild) {
      var nodesMap = this.nodesMap;
      for (var nodeKey in nodesMap) {
        this.removeNode(nodesMap[nodeKey], destroyChild);
      }
      return this;
    }
  };

  var GetNodeMethods = {
    getNode: function getNode(mapNameList) {
      if (typeof mapNameList === 'string') {
        mapNameList = mapNameList.split('.');
      }
      if (mapNameList.length === 0) {
        return undefined;
      }
      var name = mapNameList.shift();
      var element = this.nodesMap[name];
      if (mapNameList.length === 0) {
        return element;
      } else if (element && this.isTree(element)) {
        return element.getNode(mapNameList);
      } else {
        return null;
      }
    },
    getNodes: function getNodes(out) {
      var nodesMap = this.nodesMap;
      if (!out) {
        out = nodes; // Return internal children array
      } else {
        for (var nodeKey in nodesMap) {
          out.push(nodesMap[nodeKey]);
        }
        // Copy children
      }
      return out;
    },
    getAllNodes: function getAllNodes(out) {}
  };

  var methods$7 = {};
  Object.assign(methods$7, ParentMethods, AddNodeMethods, RemoveNodeMethods, GetNodeMethods);

  var GetValue$w = Phaser.Utils.Objects.GetValue;
  var CreateTitleSizer = function CreateTitleSizer(scene, config) {
    var nodeSizer = new Node(scene, config, {
      isLeaf: false
    });
    scene.add.existing(nodeSizer);

    // Required
    var toggleButton = GetGameObjectFromConfig(scene, config, 'toggleButton', {
      isLeaf: false
    }, DefaultCreateToggleButtonCallback);
    nodeSizer.insert(0, toggleButton, {
      padding: {
        right: GetValue$w(config, 'space.toggleButton', 0)
      },
      fitRatio: 1,
      key: 'toggleButton'
    });
    return nodeSizer;
  };
  var DefaultCreateToggleButtonCallback = function DefaultCreateToggleButtonCallback(scene, config, createCallbackData) {
    var gameObject = new Triangle(scene, config);
    gameObject.on('expand.start', function (gameObject) {
      gameObject.setDirection('down');
    }).on('collapse.complete', function (gameObject) {
      gameObject.setDirection('right');
    });
    return gameObject;
  };

  var GetValue$v = Phaser.Utils.Objects.GetValue;
  var CreateChildrenSizer = function CreateChildrenSizer(scene, config) {
    var childrenSizer = new Sizer(scene, {
      orientation: GetValue$v(config, 'childrenOrientation', 'y')
    });
    scene.add.existing(childrenSizer);

    // Optional
    var childrenBackground = GetGameObjectFromConfig(scene, config, 'childrenBackground', {
      isLeaf: false
    });
    if (childrenBackground) {
      childrenSizer.addBackground(childrenBackground);
    }
    return childrenSizer;
  };

  var Clone$1 = Phaser.Utils.Objects.Clone;
  var Merge$1 = function Merge(defaultConfig, overrideConfig) {
    var config = defaultConfig ? Clone$1(defaultConfig) : {};
    if (!overrideConfig) {
      return config;
    }
    for (var name in overrideConfig) {
      config[name] = overrideConfig[name];
    }
    return config;
  };

  var GetValue$u = Phaser.Utils.Objects.GetValue;
  var Tree = /*#__PURE__*/function (_ExtendNodeClass) {
    _inherits(Tree, _ExtendNodeClass);
    function Tree(scene, config) {
      var _this;
      _classCallCheck(this, Tree);
      if (config === undefined) {
        config = {};
      }
      var background = GetGameObjectFromConfig(scene, config, 'background', {
        isLeaf: false
      });
      var child = CreateChildrenSizer(scene, config);
      var childrenNodes = child.childrenMap.items;
      var title = CreateTitleSizer(scene, config);
      var toggleButton = title.childrenMap.toggleButton;
      var nodeBody = title.childrenMap.nodeBody;
      var orientation = GetOrientationMode(GetValue$u(config, 'orientation', 'y'));
      var spaceConfig = config.space;
      if (spaceConfig) {
        var indent = GetValue$u(spaceConfig, 'indent', 0);
        spaceConfig.childLeft = GetValue$u(spaceConfig, 'indentLeft', orientation === 1 ? indent : 0);
        spaceConfig.childRight = GetValue$u(spaceConfig, 'indentRight', 0);
        spaceConfig.childTop = GetValue$u(spaceConfig, 'indentTop', orientation === 0 ? indent : 0);
        spaceConfig.childBottom = GetValue$u(spaceConfig, 'indentBottom', 0);
      }
      var folderConfig = {
        background: background,
        title: title,
        child: child,
        toggleByTarget: toggleButton,
        transition: config.transition,
        orientation: orientation,
        space: spaceConfig,
        align: config.align,
        expand: config.expand
      };
      _this = _callSuper(this, Tree, [scene, folderConfig]);
      _this.type = 'rexTree';
      _this.rexSizer.treeParent = null;
      _this.nodesMap = {};
      _this.configSave = config;
      _this.addChildrenMap('toggleButton', toggleButton);
      _this.addChildrenMap('nodeBody', nodeBody);
      _this.addChildrenMap('childrenNodes', childrenNodes);
      _this.on('expand.start', function () {
        toggleButton.emit('expand.start', toggleButton);
      }).on('expand.complete', function () {
        toggleButton.emit('expand.complete', toggleButton);
      }).on('collapse.start', function () {
        toggleButton.emit('collapse.start', toggleButton);
      }).on('collapse.complete', function () {
        toggleButton.emit('collapse.complete', toggleButton);
      });
      var expanded = GetValue$u(config, 'expanded', true);
      if (expanded !== undefined) {
        _this.setExpandedState(expanded);
      }
      return _this;
    }
    _createClass(Tree, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.configSave = undefined;
        Clear(this.nodesMap);
        this.nodesMap = undefined;
        _get(_getPrototypeOf(Tree.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "createTree",
      value: function createTree(config) {
        return Tree.CreateTree(this.scene, this.configSave, config);
      }
    }, {
      key: "isTree",
      value: function isTree(gameObject) {
        return !!gameObject && gameObject instanceof TreeNode;
      }
    }]);
    return Tree;
  }(ExtendNodeClass(Folder$1)); // Static method
  Tree.CreateTree = function (scene, defaultConfig, overrideConfig) {
    return new Tree(scene, Merge$1(defaultConfig, overrideConfig));
  };
  Object.assign(Tree.prototype, methods$7);

  var UUID = Phaser.Utils.String.UUID;
  var AddTreeMethods = {
    addTree: function addTree(config) {
      if (IsGameObject(config)) {
        var nodeBody = config;
        config = {
          nodeBody: nodeBody,
          nodeKey: nodeKey
        };
      }
      return this.insertTree(undefined, config);
    },
    insertTree: function insertTree(index, config) {
      var nodeKey;
      if (typeof config === 'string') {
        nodeKey = config;
        config = undefined;
      } else if (config) {
        nodeKey = config.nodeKey;
        delete config.nodeKey;
      }
      if (nodeKey === undefined) {
        nodeKey = UUID();
      }
      var tree = Tree.CreateTree(this.scene, this.treeConfig, config);
      SyncDisplayList(this, tree);
      tree.nodeKey = nodeKey;
      this.treesMap[nodeKey] = tree;
      this.insert(index, tree, {
        expand: true
      });
      return tree;
    }
  };

  var RemoveTreeMethods = {
    removeTree: function removeTree(gameObject, destroyChild) {
      if (!gameObject) {
        return this;
      }
      delete this.treesMap[gameObject.nodeKey];
      gameObject.nodeKey = null;
      this.remove(gameObject, destroyChild);
      return this;
    },
    removeAllNodes: function removeAllNodes(destroyChild) {
      var treesMap = this.treesMap;
      for (var nodeKey in treesMap) {
        this.removeTree(treesMap[nodeKey], destroyChild);
      }
      return this;
    }
  };

  var GetTreeMethods = {
    getTree: function getTree(nodeKey) {
      return this.treesMap[nodeKey];
    },
    getNode: function getNode(nodeKey) {
      var dotIndex = nodeKey.indexOf('.');
      if (dotIndex === -1) {
        return this.getTree(nodeKey);
      }
      var tree = this.getTree(nodeKey.substring(0, dotIndex));
      if (!tree) {
        return undefined;
      }
      return tree.getNode(nodeKey.substring(dotIndex + 1));
    }
  };

  var methods$6 = {};
  Object.assign(methods$6, AddTreeMethods, RemoveTreeMethods, GetTreeMethods);

  var GetValue$t = Phaser.Utils.Objects.GetValue;

  // TODO extend from TreeNode
  var Trees = /*#__PURE__*/function (_Sizer) {
    _inherits(Trees, _Sizer);
    function Trees(scene, config) {
      var _this;
      _classCallCheck(this, Trees);
      if (config === undefined) {
        config = {};
      }
      if (!config.hasOwnProperty('orientation')) {
        config.orientation = 'y';
      }
      _this = _callSuper(this, Trees, [scene, config]);
      _this.type = 'rexTrees';
      _this.treesMap = {};
      _this.treeConfig = GetValue$t(config, 'tree');
      return _this;
    }
    _createClass(Trees, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.treeConfig = undefined;
        Clear(this.treesMap);
        this.treesMap = undefined;
        _get(_getPrototypeOf(Trees.prototype), "destroy", this).call(this, fromScene);
      }
    }]);
    return Trees;
  }(Sizer);
  Object.assign(Trees.prototype, methods$6);

  var InjectProperties = function InjectProperties(inputText) {
    Object.defineProperty(inputText, 'childOY', {
      configurable: true,
      get: function get() {
        return inputText.textOY;
      },
      set: function set(value) {
        inputText.textOY = value;
      }
    });
    Object.defineProperty(inputText, 'topChildOY', {
      get: function get() {
        return inputText.topTextOY;
      }
    });
    Object.defineProperty(inputText, 'bottomChildOY', {
      get: function get() {
        return inputText.bottomTextOY;
      }
    });
    Object.defineProperty(inputText, 'childVisibleHeight', {
      get: function get() {
        return inputText.textVisibleHeight;
      }
    });
    Object.defineProperty(inputText, 'childHeight', {
      get: function get() {
        return inputText.contentHeight;
      }
    });
  };

  var SetTextMethods = {
    setText: function setText(text) {
      var inputText = this.childrenMap.child;
      inputText.setText(text);
      return this;
    },
    appendText: function appendText(text) {
      this.setText(this.text + text);
      return this;
    }
  };

  var ScrollMethods = {
    scrollToLine: function scrollToLine(lineIndex) {
      this.setChildOY(-this.lineHeight * lineIndex);
      return this;
    },
    scrollToNextLine: function scrollToNextLine(lineCount) {
      if (lineCount === undefined) {
        lineCount = 1;
      }
      var lineIndex = this.lineIndex + lineCount;
      this.scrollToLine(lineIndex);
      return this;
    }
  };

  var GetValue$s = Phaser.Utils.Objects.GetValue;
  var TextAreaInput = /*#__PURE__*/function (_Scrollable) {
    _inherits(TextAreaInput, _Scrollable);
    function TextAreaInput(scene, config) {
      var _this;
      _classCallCheck(this, TextAreaInput);
      if (config === undefined) {
        config = {};
      }

      // Create inputText
      var inputTextConfig = GetValue$s(config, 'text');
      var inputText;
      if (IsGameObject(inputTextConfig)) {
        inputText = inputTextConfig;
      } else {
        if (inputTextConfig === undefined) {
          inputTextConfig = {};
        }
        inputTextConfig.textArea = true;
        inputText = new CanvasInput(scene, inputTextConfig);
        scene.add.existing(inputText); // Important: Add to display list for touch detecting
      }

      // Inject properties for scrollable interface
      InjectProperties(inputText);

      // Fill config of scrollable
      var expandInputTextWidth = inputTextConfig.width === undefined;
      var expandInputTextHeight = inputTextConfig.height === undefined;
      if (expandInputTextWidth) {
        inputText.minWidth = 0;
      }
      if (expandInputTextHeight) {
        inputText.minHeight = 0;
      }
      config.scrollMode = 0; // Vertical
      config.type = 'rexTextAreaInput';
      config.child = {
        gameObject: inputText,
        expandWidth: expandInputTextWidth,
        expandHeight: expandInputTextHeight
      };
      var spaceConfig = GetValue$s(config, 'space', undefined);
      if (spaceConfig) {
        spaceConfig.child = GetValue$s(spaceConfig, 'text', 0);
      }
      config.scroller = false; // No scroller supported
      _this = _callSuper(this, TextAreaInput, [scene, config]);
      _this.addChildrenMap('text', inputText);

      // More setting...

      // Rsize and move slider
      var prevTextOY, prevContentHeight;
      inputText.on('cursorin', function () {
        var textOY = inputText.textOY,
          contentHeight = inputText.contentHeight;
        var isTextOYChanged = prevTextOY !== textOY;
        var isContentHeightChanged = prevContentHeight !== contentHeight;
        prevTextOY = textOY;
        prevContentHeight = contentHeight;
        if (isContentHeightChanged) {
          this.resizeController();
        }
        if (isTextOYChanged || isContentHeightChanged) {
          this.t = inputText.t;
        }
      }, _assertThisInitialized(_this));

      // Route 'textchange' event
      inputText.on('textchange', function (text) {
        this.emit('textchange', text, this);
      }, _assertThisInitialized(_this));

      // Set initial text if given
      var content = GetValue$s(config, 'content', undefined);
      if (content) {
        _this.setText(content);
      }
      return _this;
    }
    _createClass(TextAreaInput, [{
      key: "text",
      get: function get() {
        return this.childrenMap.child.text;
      }
    }, {
      key: "lineHeight",
      get: function get() {
        var inputText = this.childrenMap.child;
        return inputText.lineHeight;
      }
    }, {
      key: "lineIndex",
      get: function get() {
        return Math.floor(-this.childOY / this.lineHeight);
      }
    }, {
      key: "linesCount",
      get: function get() {
        var inputText = this.childrenMap.child;
        return inputText.linesCount;
      }
    }, {
      key: "contentHeight",
      get: function get() {
        var inputText = this.childrenMap.child;
        return inputText.contentHeight;
      }
    }, {
      key: "readOnly",
      get: function get() {
        var inputText = this.childrenMap.child;
        return inputText.readOnly;
      },
      set: function set(value) {
        var inputText = this.childrenMap.child;
        inputText.readOnly = value;
      }
    }, {
      key: "setReadOnly",
      value: function setReadOnly(value) {
        var inputText = this.childrenMap.child;
        inputText.setReadOnly(value);
        return this;
      }
    }]);
    return TextAreaInput;
  }(Scrollable);
  Object.assign(TextAreaInput.prototype, SetTextMethods, ScrollMethods);

  var GetChildrenWidth = function GetChildrenWidth() {
    if (this.rexSizer.hidden) {
      return 0;
    }
    var childWidth;
    var child = this.child,
      childConfig = child.rexSizer;
    var hasUnknownChildWidth = false;
    if (childConfig.hidden) {
      childWidth = 0;
    } else {
      switch (this.scrollMode) {
        case 0:
          childWidth = this.getChildWidth(child);
          if (childWidth === undefined) {
            hasUnknownChildWidth = true;
          }
          break;
        case 1:
          childWidth = 0;
          break;
        default:
          childWidth = 0;
          break;
      }
    }
    if (hasUnknownChildWidth) {
      return undefined;
    }
    return childWidth;
  };

  var GetChildrenHeight = function GetChildrenHeight() {
    if (this.rexSizer.hidden) {
      return 0;
    }
    var childHeight;
    var child = this.child,
      childConfig = child.rexSizer;
    var hasUnknownChildHeight = false;
    if (childConfig.hidden) {
      childHeight = 0;
    } else {
      switch (this.scrollMode) {
        case 0:
          childHeight = 0;
          break;
        case 1:
          childHeight = this.getChildHeight(child);
          if (childHeight === undefined) {
            hasUnknownChildHeight = true;
          }
          break;
        default:
          childHeight = 0;
          break;
      }
    }
    if (hasUnknownChildHeight) {
      return undefined;
    }
    return childHeight;
  };

  var GetChildrenSizers = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }
    if (this.child && this.child.isRexSizer) {
      out.push(this.child);
    }
    return out;
  };

  var ResetChildPosition = function ResetChildPosition() {
    var x = this.left;
    var y = this.top;
    switch (this.scrollMode) {
      case 0:
        y += this.childOY;
        break;
      case 1:
        x += this.childOY;
        break;
      default:
        // xy
        y += this.childOY;
        x += this.childOX;
        break;
    }
    this.child.setPosition(x, y);
    this.resetChildPositionState(this.child);
    this.setMaskChildrenFlag();
  };

  var LayoutChildren = function LayoutChildren() {
    // LayoutChildren child
    var child = this.child;
    var childWidth, childHeight;
    if (!child.rexSizer.hidden) {
      // Set size
      switch (this.scrollMode) {
        case 0:
          childWidth = this.width;
          break;
        case 1:
          childHeight = this.height;
          break;
      }
      if (child.isRexSizer) {
        child.runLayout(this, childWidth, childHeight);
      } else {
        ResizeGameObject(child, childWidth, childHeight);
      }

      // Update local state
      this.resetChildPosition();
      // Layout children-mask
      this.layoutChildrenMask();
      // Re-mask children
      this.maskChildren();
    }
  };

  var RemoveChildCallback = function RemoveChildCallback(gameObject, destroyChild) {
    if (destroyChild) {
      return;
    }
    if (gameObject.clearMask) {
      gameObject.clearMask(false);
    }
  };

  var methods$5 = {
    getChildrenWidth: GetChildrenWidth,
    getChildrenHeight: GetChildrenHeight,
    getChildrenSizers: GetChildrenSizers,
    resetChildPosition: ResetChildPosition,
    layoutChildren: LayoutChildren,
    removeChildCallback: RemoveChildCallback
  };
  Object.assign(methods$5, ChildrenMaskMethods);

  var IsPlainObject$1 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$r = Phaser.Utils.Objects.GetValue;
  var ALIGN_LEFTTOP = Phaser.Display.Align.TOP_LEFT;
  var ScrollableBlock = /*#__PURE__*/function (_BaseSizer) {
    _inherits(ScrollableBlock, _BaseSizer);
    function ScrollableBlock(scene, x, y, minWidth, minHeight, config) {
      var _this;
      _classCallCheck(this, ScrollableBlock);
      if (IsPlainObject$1(x)) {
        config = x;
        x = GetValue$r(config, 'x', 0);
        y = GetValue$r(config, 'y', 0);
        minWidth = GetValue$r(config, 'width', undefined);
        minHeight = GetValue$r(config, 'height', undefined);
      } else if (IsPlainObject$1(minWidth)) {
        config = minWidth;
        minWidth = GetValue$r(config, 'width', undefined);
        minHeight = GetValue$r(config, 'height', undefined);
      }
      _this = _callSuper(this, ScrollableBlock, [scene, x, y, minWidth, minHeight, config]);
      _this.type = 'rexScrollableBlock';
      _this.child = undefined;
      _this.childrenMask = undefined;
      _this._childOY = 0;
      _this._childOX = 0;
      _this.execeedTopState = false;
      _this.execeedBottomState = false;
      _this.execeedLeftState = false;
      _this.execeedRightState = false;
      _this.setScrollMode(GetValue$r(config, 'scrollMode', 0));
      var clampChildOY = GetValue$r(config, 'clamplChildOY', true);
      var clampChildOX = GetValue$r(config, 'clamplChildOX', clampChildOY);
      _this.setClampMode(clampChildOY, clampChildOX);

      // Add elements
      // No background object, and child does not have padding
      var child = GetValue$r(config, 'child', undefined);
      var expand = GetValue$r(config, 'expand', true);
      if (child.setOrigin) {
        child.setOrigin(0);
      }
      _this.add(child);
      _this.sizerChildren = [child];
      var sizerConfig = _this.getSizerConfig(child);
      sizerConfig.align = ALIGN_LEFTTOP;
      sizerConfig.expand = expand;
      _this.child = child;

      // Create mask of child object
      _this.setupChildrenMask(GetValue$r(config, 'mask', undefined));
      if (_this.childrenMask) {
        _this.maskGameObject = MaskToGameObject(_this.childrenMask);
      }
      return _this;
    }
    _createClass(ScrollableBlock, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.destroyChildrenMask();
        this.child = undefined;
        _get(_getPrototypeOf(ScrollableBlock.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setScrollMode",
      value: function setScrollMode(mode) {
        if (typeof mode === 'string') {
          mode = SCROLLMODE$1[mode.toLowerCase()];
        }
        this.scrollMode = mode;
        return this;
      }
    }, {
      key: "setClampMode",
      value: function setClampMode(clampChildOY, clampChildOX) {
        this.clampChildOY = clampChildOY;
        this.clampChildOX = clampChildOX;
        return this;
      }
    }, {
      key: "instHeight",
      get: function get() {
        if (this.scrollMode === 0 || this.scrollMode === 2) {
          return this.height;
        } else {
          // scrollMode === 1
          return this.width;
        }
      }
    }, {
      key: "instWidth",
      get: function get() {
        if (this.scrollMode === 0 || this.scrollMode === 2) {
          return this.width;
        } else {
          // scrollMode === 1
          return this.height;
        }
      }
    }, {
      key: "childHeight",
      get: function get() {
        if (this.scrollMode === 0 || this.scrollMode === 2) {
          return GetDisplayHeight(this.child);
        } else {
          // scrollMode === 1
          return GetDisplayWidth(this.child);
        }
      }
    }, {
      key: "childWidth",
      get: function get() {
        if (this.scrollMode === 0 || this.scrollMode === 2) {
          return GetDisplayWidth(this.child);
        } else {
          // scrollMode === 1
          return GetDisplayHeight(this.child);
        }
      }
    }, {
      key: "topChildOY",
      get: function get() {
        return 0;
      }
    }, {
      key: "bottomChildOY",
      get: function get() {
        return -this.visibleHeight;
      }
    }, {
      key: "leftChildOX",
      get: function get() {
        return 0;
      }
    }, {
      key: "rightChildOX",
      get: function get() {
        return -this.visibleWidth;
      }
    }, {
      key: "childVisibleHeight",
      get: function get() {
        return this.instHeight;
      }
    }, {
      key: "childVisibleWidth",
      get: function get() {
        return this.instWidth;
      }
    }, {
      key: "visibleHeight",
      get: function get() {
        var h = this.childHeight - this.childVisibleHeight;
        if (h < 0) {
          h = 0;
        }
        return h;
      }
    }, {
      key: "visibleWidth",
      get: function get() {
        var w = this.childWidth - this.childVisibleWidth;
        if (w < 0) {
          w = 0;
        }
        return w;
      }
    }, {
      key: "childOYExceedTop",
      value: function childOYExceedTop(oy) {
        if (oy === undefined) {
          oy = this.childOY;
        }
        return oy > this.topChildOY;
      }
    }, {
      key: "childOYExeceedBottom",
      value: function childOYExeceedBottom(oy) {
        if (oy === undefined) {
          oy = this.childOY;
        }
        return oy < this.bottomChildOY;
      }
    }, {
      key: "childOXExceedLeft",
      value: function childOXExceedLeft(ox) {
        if (ox === undefined) {
          ox = this.childOX;
        }
        return ox > this.leftChildOX;
      }
    }, {
      key: "childOXExeceedRight",
      value: function childOXExeceedRight(ox) {
        if (ox === undefined) {
          ox = this.childOX;
        }
        return ox < this.rightChildOX;
      }
    }, {
      key: "childOY",
      get: function get() {
        return this._childOY;
      },
      set: function set(oy) {
        var topChildOY = this.topChildOY;
        var bottomChildOY = this.bottomChildOY;
        var childOYExceedTop = this.childOYExceedTop(oy);
        var childOYExeceedBottom = this.childOYExeceedBottom(oy);
        if (this.clampChildOY) {
          if (this.childVisibleHeight > this.childHeight) {
            oy = 0;
          } else if (childOYExceedTop) {
            oy = topChildOY;
          } else if (childOYExeceedBottom) {
            oy = bottomChildOY;
          }
        }
        if (this._childOY !== oy) {
          this._childOY = oy;
          this.resetChildPosition();
        }
        if (childOYExceedTop) {
          if (!this.execeedTopState) {
            this.emit('execeedtop', this, oy, topChildOY);
          }
        }
        this.execeedTopState = childOYExceedTop;
        if (childOYExeceedBottom) {
          if (!this.execeedBottomState) {
            this.emit('execeedbottom', this, oy, bottomChildOY);
          }
        }
        this.execeedBottomState = childOYExeceedBottom;
      }
    }, {
      key: "childOX",
      get: function get() {
        return this._childOX;
      },
      set: function set(ox) {
        var leftChildOX = this.leftChildOX;
        var rightChildOX = this.rightChildOX;
        var childOXExceedLeft = this.childOXExceedLeft(ox);
        var childOXExeceedRight = this.childOXExeceedRight(ox);
        if (this.clampChildOX) {
          if (this.childVisibleWidth > this.childWidth) {
            ox = 0;
          } else if (childOXExceedLeft) {
            ox = leftChildOX;
          } else if (childOXExeceedRight) {
            ox = rightChildOX;
          }
        }
        if (this._childOX !== ox) {
          this._childOX = ox;
          this.resetChildPosition();
        }
        if (childOXExceedLeft) {
          if (!this.execeedLeftState) {
            this.emit('execeedleft', this, ox, leftChildOX);
          }
        }
        this.execeedLeftState = childOXExceedLeft;
        if (childOXExeceedRight) {
          if (!this.execeedRightState) {
            this.emit('execeedright', this, ox, rightChildOX);
          }
        }
        this.execeedRightState = childOXExeceedRight;
      }
    }, {
      key: "setChildOY",
      value: function setChildOY(oy) {
        this.childOY = oy;
        return this;
      }
    }, {
      key: "setChildOX",
      value: function setChildOX(ox) {
        this.childOX = ox;
        return this;
      }
    }, {
      key: "t",
      get: function get() {
        var visibleHeight = this.visibleHeight;
        if (visibleHeight === 0) {
          return 0;
        }
        return this.childOY / -visibleHeight;
      },
      set: function set(value) {
        this.childOY = -this.visibleHeight * value;
      }
    }, {
      key: "s",
      get: function get() {
        var visibleWidth = this.visibleWidth;
        if (visibleWidth === 0) {
          return 0;
        }
        return this.childOX / -visibleWidth;
      },
      set: function set(value) {
        this.childOX = -this.visibleWidth * value;
      }
    }, {
      key: "setChildOYByPercentage",
      value: function setChildOYByPercentage(percentage) {
        this.t = percentage;
        return this;
      }
    }, {
      key: "setChildOXByPercentage",
      value: function setChildOXByPercentage(percentage) {
        this.s = percentage;
        return this;
      }
    }]);
    return ScrollableBlock;
  }(Base);
  Object.assign(ScrollableBlock.prototype, methods$5);

  var ScrollToChild = function ScrollToChild(child, align) {
    if (!this.hasChild(child)) {
      return this;
    }
    switch (this.scrollMode) {
      case 0:
        AlignChild.call(this, child, 'y', align);
        break;
      case 1:
        AlignChild.call(this, child, 'x', align);
        break;
      default:
        AlignChild.call(this, child, 'y', align);
        AlignChild.call(this, child, 'x', align);
        break;
    }
    return this;
  };
  var AlignYModes = ['top', 'bottom', 'centerY', 'center'];
  var AlignXModes = ['left', 'right', 'centerX', 'center'];
  var AlignChild = function AlignChild(child, axis, align) {
    axis = axis.toUpperCase();
    var isAxisY = axis === 'Y';
    var scrollableBlock = this.childrenMap.child;
    var delta;
    if (isAxisY) {
      if (align) {
        for (var i = 0, cnt = AlignYModes.length; i < cnt; i++) {
          var modeName = AlignYModes[i];
          if (align.indexOf(modeName) !== -1) {
            align = modeName;
            break;
          }
        }
      }
      switch (align) {
        case 'top':
          delta = scrollableBlock.top - child.getTopLeft().y;
          break;
        case 'bottom':
          delta = scrollableBlock.bottom - child.getBottomLeft().y;
          break;
        case 'centerY':
        case 'center':
          delta = scrollableBlock.centerY - child.getCenter().y;
          break;
        default:
          var dTop = scrollableBlock.top - child.getTopLeft().y;
          var dBottom = scrollableBlock.bottom - child.getBottomLeft().y;
          if (dTop <= 0 && dBottom >= 0) {
            delta = 0;
          } else {
            delta = Math.abs(dTop) <= Math.abs(dBottom) ? dTop : dBottom;
          }
          break;
      }
    } else {
      if (align) {
        for (var i = 0, cnt = AlignXModes.length; i < cnt; i++) {
          var modeName = AlignXModes[i];
          if (align.indexOf(modeName) !== -1) {
            align = modeName;
            break;
          }
        }
      }
      switch (align) {
        case 'left':
          delta = scrollableBlock.left - child.getTopLeft().x;
          break;
        case 'right':
          delta = scrollableBlock.right - child.getTopRight().x;
          break;
        case 'centerX':
        case 'center':
          delta = scrollableBlock.centerX - child.getCenter().x;
          break;
        default:
          var dLeft = scrollableBlock.left - child.getTopLeft().x;
          var dRight = scrollableBlock.right - child.getTopRight().x;
          if (dLeft <= 0 && dRight >= 0) {
            delta = 0;
          } else {
            delta = Math.abs(dLeft) <= Math.abs(dRight) ? dLeft : dRight;
          }
          break;
      }
    }
    switch (this.scrollMode) {
      case 0:
      case 1:
        this.childOY += delta;
        break;
      default:
        this["childO".concat(axis)] += delta;
        break;
    }
  };

  var GetValue$q = Phaser.Utils.Objects.GetValue;
  var ScrollablePanel = /*#__PURE__*/function (_Scrollable) {
    _inherits(ScrollablePanel, _Scrollable);
    function ScrollablePanel(scene, config) {
      var _this;
      _classCallCheck(this, ScrollablePanel);
      if (config === undefined) {
        config = {};
      }

      // Create scrollable-block
      var scrollMode = GetScrollMode(config);
      var panelConfig = GetValue$q(config, 'panel', undefined);
      if (panelConfig === undefined) {
        panelConfig = {};
      }
      panelConfig.scrollMode = scrollMode;
      panelConfig.clamplChildOY = GetValue$q(config, 'clamplChildOY', false);
      panelConfig.clamplChildOX = GetValue$q(config, 'clamplChildOX', false);
      var scrollableBlock = new ScrollableBlock(scene, panelConfig);
      scene.add.existing(scrollableBlock); // Important: Add to display list for touch detecting

      var expandPanelWidth, expandPanelHeight;
      switch (scrollMode) {
        case 0:
          expandPanelWidth = GetValue$q(config, 'expand.panel', true);
          expandPanelHeight = true;
          break;
        case 1:
          expandPanelWidth = true;
          expandPanelHeight = GetValue$q(config, 'expand.panel', true);
          break;
        default:
          // 2
          expandPanelWidth = true;
          expandPanelHeight = true;
      }

      // Fill config of scrollable
      config.type = 'rexScrollablePanel';
      config.child = {
        gameObject: scrollableBlock,
        expandWidth: expandPanelWidth,
        expandHeight: expandPanelHeight,
        align: GetValue$q(config, 'align.panel', 'center')
      };
      var spaceConfig = GetValue$q(config, 'space', undefined);
      if (spaceConfig) {
        spaceConfig.child = GetValue$q(spaceConfig, 'panel', 0);
      }
      _this = _callSuper(this, ScrollablePanel, [scene, config]);
      _this.addChildrenMap('panel', scrollableBlock.child);
      _this.addChildrenMap('panelLayer', scrollableBlock.maskLayer);
      _this.addChildrenMap('mask', scrollableBlock.maskGameObject);
      _this.addChildrenMap('scrollableBlock', scrollableBlock);
      return _this;
    }
    _createClass(ScrollablePanel, [{
      key: "setChildrenInteractive",
      value: function setChildrenInteractive(config) {
        if (config === undefined) {
          config = {};
        }
        if (!config.hasOwnProperty('eventEmitter')) {
          config.eventEmitter = this;
        }
        if (!config.hasOwnProperty('targets')) {
          config.targets = [this.childrenMap.panel];
        }
        SetChildrenInteractive(this.childrenMap.child, config);
        return this;
      }
    }]);
    return ScrollablePanel;
  }(Scrollable);
  var methods$4 = {
    scrollToChild: ScrollToChild
  };
  Object.assign(ScrollablePanel.prototype, methods$4);

  var DefaultTransitCallbacks = {
    popUp: function popUp(gameObject, duration) {
      gameObject.popUp(duration);
    },
    scaleDown: function scaleDown(gameObject, duration) {
      gameObject.scaleDown(duration);
    },
    fadeIn: function fadeIn(gameObject, duration) {
      gameObject.fadeIn(duration);
    },
    fadeOut: function fadeOut(gameObject, duration) {
      gameObject.fadeOut(duration);
    }
  };

  var TransitionMode = {
    popUp: 0,
    fadeIn: 1,
    scaleDown: 0,
    fadeOut: 1
  };

  var ConfigurationMethods = {
    setDisplayTime: function setDisplayTime(time) {
      this.displayTime = time;
      return this;
    },
    setTransitOutTime: function setTransitOutTime(time) {
      this.transitOutTime = time;
      return this;
    },
    setTransitInTime: function setTransitInTime(time) {
      this.transitInTime = time;
      return this;
    },
    setTransitInCallback: function setTransitInCallback(callback) {
      if (typeof callback === 'string') {
        callback = TransitionMode[callback];
      }
      switch (callback) {
        case TransitionMode.popUp:
          callback = DefaultTransitCallbacks.popUp;
          break;
        case TransitionMode.fadeIn:
          callback = DefaultTransitCallbacks.fadeIn;
          break;
      }
      if (!callback) {
        callback = NOOP;
      }
      this.transitInCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    },
    setTransitOutCallback: function setTransitOutCallback(callback) {
      if (typeof callback === 'string') {
        callback = TransitionMode[callback];
      }
      switch (callback) {
        case TransitionMode.scaleDown:
          callback = DefaultTransitCallbacks.scaleDown;
          break;
        case TransitionMode.fadeOut:
          callback = DefaultTransitCallbacks.fadeOut;
          break;
      }
      if (!callback) {
        callback = NOOP;
      }
      this.transitOutCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    }
  };

  var MessageMethods = {
    showMessage: function showMessage(callback) {
      // Remember first scaleX, scaleY as initial scale
      if (this.scaleX0 === undefined) {
        this.scaleX0 = this.scaleX;
      }
      if (this.scaleY0 === undefined) {
        this.scaleY0 = this.scaleY;
      }
      if (callback === undefined) {
        // Try pop up a pendding message
        if (this.messages.length === 0) {
          return this;
        }
        callback = this.messages.shift();
      }
      if (this.player.isPlaying) {
        // Pend message
        this.messages.push(callback);
        return this;
      }

      // Recover to initial state
      this.setScale(this.scaleX0, this.scaleY0).setVisible(true);
      if (typeof callback === 'string') {
        this.setText(callback);
      } else {
        callback(this);
      }
      this.layout();
      var commands = [[
      // Transit-in
      0,
      // time
      [this.transitInCallback, this, this.transitInTime] // [callback, param, ...]
      ], [
      // Transit-in event
      0,
      // time
      [this.emit, 'transitin', this, this.transitInTime] // [callback, param, ...]
      ], [
      // Hold
      this.transitInTime, [NOOP]], [
      // Transit-out
      this.displayTime, [this.transitOutCallback, this, this.transitOutTime]],
      // Transit-out event
      [0,
      // time
      [this.emit, 'transitout', this, this.transitOutTime] // [callback, param, ...]
      ], [
      // End
      this.transitOutTime, [this.setVisible, false]], [
      // Complete - show next message
      30,
      // Add a small delay before complete
      [NOOP]]];
      this.player.load(commands, this).once('complete', function () {
        this.showMessage();
      }, this).start();
      return this;
    },
    removeAllMessages: function removeAllMessages() {
      this.messages.length = 0;
      return this;
    }
  };

  var GetValue$p = Phaser.Utils.Objects.GetValue;
  var Toast = /*#__PURE__*/function (_Label) {
    _inherits(Toast, _Label);
    function Toast(scene, config) {
      var _this;
      _classCallCheck(this, Toast);
      if (config === undefined) {
        config = {
          text: createDefaultTextObject(scene)
        };
      }
      _this = _callSuper(this, Toast, [scene, config]);
      _this.type = 'rexToast';
      _this.setTransitInTime(GetValue$p(config, 'duration.in', 200));
      _this.setDisplayTime(GetValue$p(config, 'duration.hold', 1200));
      _this.setTransitOutTime(GetValue$p(config, 'duration.out', 200));
      _this.setTransitInCallback(GetValue$p(config, 'transitIn', TransitionMode.popUp));
      _this.setTransitOutCallback(GetValue$p(config, 'transitOut', TransitionMode.scaleDown));
      _this.player = new Player(_assertThisInitialized(_this), {
        dtMode: 1
      });
      _this.messages = [];
      _this.scaleX0 = undefined;
      _this.scaleY0 = undefined;
      _this.setVisible(false);
      return _this;
    }
    _createClass(Toast, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.player.destroy();
        this.player = undefined;
        this.messages = undefined;
        _get(_getPrototypeOf(Toast.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setScale",
      value: function setScale(scaleX, scaleY) {
        if (scaleY === undefined) {
          scaleY = scaleX;
        }
        // Can override initial scale
        this.scaleX0 = scaleX;
        this.scaleY0 = scaleY;
        _get(_getPrototypeOf(Toast.prototype), "setScale", this).call(this, scaleX, scaleY);
        return this;
      }
    }]);
    return Toast;
  }(Label);
  Object.assign(Toast.prototype, ConfigurationMethods, MessageMethods);

  var CreateInputText$1 = function CreateInputText(scene, config, deepCloneConfig) {
    if (deepCloneConfig === undefined) {
      deepCloneConfig = true;
    }
    if (deepCloneConfig) {
      config = config ? DeepClone(config) : {};
    } else if (!config) {
      config = {};
    }
    var inputText = new CanvasInput(scene, config);
    scene.add.existing(inputText);
    return inputText;
  };

  var GetValue$o = Phaser.Utils.Objects.GetValue;
  var Color$3 = Phaser.Display.Color;
  var ColorToRGBA$2 = Phaser.Display.Color.ColorToRGBA;
  var HSVToRGB$2 = Phaser.Display.Color.HSVToRGB;
  var Clamp$1 = Phaser.Math.Clamp;
  var ColorComponents = /*#__PURE__*/function (_Sizer) {
    _inherits(ColorComponents, _Sizer);
    function ColorComponents(scene, config) {
      var _this;
      _classCallCheck(this, ColorComponents);
      if (config === undefined) {
        config = {};
      }
      config.orientation = 0;
      _this = _callSuper(this, ColorComponents, [scene, config]);
      _this.type = 'rexColorComponents';
      _this.colorObject = new Color$3();

      // Add elements
      var background = GetValue$o(config, 'background', undefined);
      var formatLabel = GetValue$o(config, 'formatLabel', undefined);
      if (!IsGameObject(formatLabel)) {
        formatLabel = CreateLabel(scene, formatLabel).resetDisplayContent();
      }
      var components = [];
      if (config.inputText0 && config.inputText1 && config.inputText2) {
        components.push(config.inputText0);
        components.push(config.inputText1);
        components.push(config.inputText2);
      } else {
        var inputTextConfig = GetValue$o(config, 'inputText');
        for (var i = 0; i < 3; i++) {
          var inputText = CreateInputText$1(scene, inputTextConfig).setMaxLength(3).setNumberInput();
          components.push(inputText);
        }
      }
      if (background) {
        _this.addBackground(background);
      }
      var proportion = GetValue$o(config, 'proportion.formatLabel', 0);
      var defaultExpand = formatLabel.isRexContainerLite ? true : false;
      var expand = GetValue$o(config, 'expand.formatLabel', defaultExpand);
      _this.add(formatLabel, {
        proportion: proportion,
        expand: expand
      });
      var proportion = GetValue$o(inputTextConfig, 'width') === undefined ? 1 : 0;
      var expand = GetValue$o(inputTextConfig, 'height') === undefined ? true : false;
      for (var i = 0, cnt = components.length; i < cnt; i++) {
        _this.add(components[i], {
          proportion: proportion,
          expand: expand
        });
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('formatLabel', formatLabel);
      _this.addChildrenMap('components', components);
      _this.onClick(formatLabel, _this.toggleColorFormat, _assertThisInitialized(_this));
      for (var i = 0, cnt = components.length; i < cnt; i++) {
        components[i].on('close', function () {
          this.updateColorObject();
          this.setValue(this.colorObject.color);
        }, _assertThisInitialized(_this));
      }
      var callback = GetValue$o(config, 'valuechangeCallback', null);
      if (callback !== null) {
        var scope = GetValue$o(config, 'valuechangeCallbackScope', undefined);
        _this.on('valuechange', callback, scope);
      }
      formatLabel.setText('RGB');
      _this.setValue(GetValue$o(config, 'value', 0xffffff));
      return _this;
    }
    _createClass(ColorComponents, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        value = Clamp$1(Math.floor(value), 0, 0xffffff);
        if (this._value === value) {
          return;
        }
        this._value = value;
        this.colorObject.setFromRGB(ColorToRGBA$2(value));
        this.updateComponents();
        this.emit('valuechange', this._value);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }, {
      key: "color",
      get: function get() {
        return this._value;
      },
      set: function set(color) {
        this.value = color;
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color = color;
        return this;
      }
    }, {
      key: "colorFormat",
      get: function get() {
        return this.childrenMap.formatLabel.text;
      },
      set: function set(value) {
        if (this.colorFormat === value) {
          return;
        }
        this.childrenMap.formatLabel.setText(value);
        this.updateComponents();
      }
    }, {
      key: "setColorFormat",
      value: function setColorFormat(colrType) {
        this.colorFormat = colrType;
        return this;
      }
    }, {
      key: "toggleColorFormat",
      value: function toggleColorFormat() {
        this.colorFormat = this.colorFormat === 'RGB' ? 'HSV' : 'RGB';
        return this;
      }
    }, {
      key: "updateComponents",
      value: function updateComponents() {
        var components = this.childrenMap.components;
        var value0, value1, value2;
        if (this.colorFormat === 'RGB') {
          value0 = this.colorObject.red;
          value1 = this.colorObject.green;
          value2 = this.colorObject.blue;
        } else {
          // colorFormat === 'HSV'
          value0 = Math.floor(this.colorObject.h * 360);
          value1 = Math.floor(this.colorObject.s * 100);
          value2 = Math.floor(this.colorObject.v * 100);
        }
        components[0].setValue(value0);
        components[1].setValue(value1);
        components[2].setValue(value2);
        return this;
      }
    }, {
      key: "updateColorObject",
      value: function updateColorObject() {
        var components = this.childrenMap.components;
        if (this.colorFormat === 'RGB') {
          var red = Clamp$1(components[0].value, 0, 255);
          var green = Clamp$1(components[1].value, 0, 255);
          var blue = Clamp$1(components[2].value, 0, 255);
          this.colorObject.setTo(red, green, blue);
        } else {
          var h = Clamp$1(components[0].value, 0, 359) / 360;
          var s = Clamp$1(components[1].value, 0, 100) / 100;
          var v = Clamp$1(components[2].value, 0, 100) / 100;
          this.colorObject.setFromRGB(HSVToRGB$2(h, s, v));
        }
        return this;
      }
    }]);
    return ColorComponents;
  }(Sizer);

  var CreateSwatch = function CreateSwatch(scene, config) {
    if (config === false) {
      return null;
    } else if (IsGameObject(config)) {
      return config;
    }
    var swatch = new RoundRectangle$1(scene, config);
    scene.add.existing(swatch);
    return swatch;
  };

  var ColorNames = ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGrey', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkSlateGrey', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DimGrey', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Grey', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGrey', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSlateGrey', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'RebeccaPurple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'SlateGrey', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];
  var ColorValues = [0xf0f8ff, 0xfaebd7, 0x00ffff, 0x7fffd4, 0xf0ffff, 0xf5f5dc, 0xffe4c4, 0x000000, 0xffebcd, 0x0000ff, 0x8a2be2, 0xa52a2a, 0xdeb887, 0x5f9ea0, 0x7fff00, 0xd2691e, 0xff7f50, 0x6495ed, 0xfff8dc, 0xdc143c, 0x00ffff, 0x00008b, 0x008b8b, 0xb8860b, 0xa9a9a9, 0xa9a9a9, 0x006400, 0xbdb76b, 0x8b008b, 0x556b2f, 0xff8c00, 0x9932cc, 0x8b0000, 0xe9967a, 0x8fbc8f, 0x483d8b, 0x2f4f4f, 0x2f4f4f, 0x00ced1, 0x9400d3, 0xff1493, 0x00bfff, 0x696969, 0x696969, 0x1e90ff, 0xb22222, 0xfffaf0, 0x228b22, 0xff00ff, 0xdcdcdc, 0xf8f8ff, 0xffd700, 0xdaa520, 0x808080, 0x808080, 0x008000, 0xadff2f, 0xf0fff0, 0xff69b4, 0xcd5c5c, 0x4b0082, 0xfffff0, 0xf0e68c, 0xe6e6fa, 0xfff0f5, 0x7cfc00, 0xfffacd, 0xadd8e6, 0xf08080, 0xe0ffff, 0xfafad2, 0xd3d3d3, 0xd3d3d3, 0x90ee90, 0xffb6c1, 0xffa07a, 0x20b2aa, 0x87cefa, 0x778899, 0x778899, 0xb0c4de, 0xffffe0, 0x00ff00, 0x32cd32, 0xfaf0e6, 0xff00ff, 0x800000, 0x66cdaa, 0x0000cd, 0xba55d3, 0x9370db, 0x3cb371, 0x7b68ee, 0x00fa9a, 0x48d1cc, 0xc71585, 0x191970, 0xf5fffa, 0xffe4e1, 0xffe4b5, 0xffdead, 0x000080, 0xfdf5e6, 0x808000, 0x6b8e23, 0xffa500, 0xff4500, 0xda70d6, 0xeee8aa, 0x98fb98, 0xafeeee, 0xdb7093, 0xffefd5, 0xffdab9, 0xcd853f, 0xffc0cb, 0xdda0dd, 0xb0e0e6, 0x800080, 0x663399, 0xff0000, 0xbc8f8f, 0x4169e1, 0x8b4513, 0xfa8072, 0xf4a460, 0x2e8b57, 0xfff5ee, 0xa0522d, 0xc0c0c0, 0x87ceeb, 0x6a5acd, 0x708090, 0x708090, 0xfffafa, 0x00ff7f, 0x4682b4, 0xd2b48c, 0x008080, 0xd8bfd8, 0xff6347, 0x40e0d0, 0xee82ee, 0xf5deb3, 0xffffff, 0xf5f5f5, 0xffff00, 0x9acd32];
  var ColorNameToIntegerDict = {},
    name;
  for (var i = 0, cnt = ColorNames.length; i < cnt; i++) {
    name = ColorNames[i].toLowerCase();
    ColorNameToIntegerDict[name] = ColorValues[i];
  }
  var ColorNameToInteger = function ColorNameToInteger(colorName) {
    colorName = colorName.toLowerCase();
    if (ColorNameToIntegerDict.hasOwnProperty(colorName)) {
      return ColorNameToIntegerDict[colorName];
    } else {
      return null;
    }
  };

  var ColorStringToInteger = function ColorStringToInteger(value) {
    if (typeof value !== 'string') {
      return value;
    }
    if (value.startsWith('#')) {
      value = parseInt(value.substring(1), 16);
    } else if (value.startsWith('0x')) {
      value = parseInt(value.substring(2), 16);
    } else {
      value = ColorNameToInteger(value);
    }
    return value;
  };

  var Pad = Phaser.Utils.String.Pad;
  var GetHexColorString = function GetHexColorString(value, prefix) {
    if (prefix === undefined) {
      prefix = '0x';
    }
    var colorString = value.toString(16).toUpperCase();
    colorString = Pad(colorString, 6, 0, 1);
    colorString = prefix + colorString;
    return colorString;
  };

  var SetSwatchColor = function SetSwatchColor(swatch, color) {
    if (!swatch) {
      return;
    }
    if (swatch.setTint) {
      swatch.setTint(color);
    } else if (swatch.setFillStyle) {
      swatch.setFillStyle(color);
    }
  };

  var GetValue$n = Phaser.Utils.Objects.GetValue;
  var IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
  var Clamp = Phaser.Math.Clamp;
  var ColorInput$1 = /*#__PURE__*/function (_Sizer) {
    _inherits(ColorInput, _Sizer);
    function ColorInput(scene, config) {
      var _this;
      _classCallCheck(this, ColorInput);
      if (config === undefined) {
        config = {};
      }
      config.orientation = 0;
      _this = _callSuper(this, ColorInput, [scene, config]);
      _this.type = 'rexColorInputLite';

      // Add elements
      var background = GetValue$n(config, 'background', undefined);
      var swatchConfig = GetValue$n(config, 'swatch');
      var swatchSize;
      if (IsPlainObject(swatchConfig)) {
        swatchSize = GetValue$n(swatchConfig, 'size');
      }
      var swatch = CreateSwatch(scene, GetValue$n(config, 'swatch'));
      var inputTextConfig = GetValue$n(config, 'inputText', {});
      var inputText;
      if (inputTextConfig) {
        inputText = CreateInputText$1(scene, inputTextConfig);
      }
      if (background) {
        _this.addBackground(background);
      }
      if (swatch) {
        swatchSize = GetValue$n(config, 'swatchSize', swatchSize);
        var squareExpandSwatch;
        if (swatchSize !== undefined) {
          ResizeGameObject(swatch, swatchSize, swatchSize);
          squareExpandSwatch = false;
        } else {
          squareExpandSwatch = GetValue$n(config, 'squareExpandSwatch', true);
        }
        var fitRatio = squareExpandSwatch ? 1 : 0;
        _this.add(swatch, {
          proportion: 0,
          expand: false,
          fitRatio: fitRatio
        });
      }
      if (inputText) {
        var proportion = GetValue$n(inputTextConfig, 'width') === undefined ? 1 : 0;
        var expand = GetValue$n(inputTextConfig, 'height') === undefined ? true : false;
        _this.add(inputText, {
          proportion: proportion,
          expand: expand
        });
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('swatch', swatch);
      _this.addChildrenMap('inputText', inputText);
      if (inputText) {
        inputText.on('close', function () {
          this.setValue(inputText.value);
        }, _assertThisInitialized(_this));
      }
      var callback = GetValue$n(config, 'valuechangeCallback', null);
      if (callback !== null) {
        var scope = GetValue$n(config, 'valuechangeCallbackScope', undefined);
        _this.on('valuechange', callback, scope);
      }
      _this.setValue(GetValue$n(config, 'value', 0x0));
      return _this;
    }
    _createClass(ColorInput, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (typeof value === 'string') {
          value = ColorStringToInteger(value);
          if (value == null) {
            var inputText = this.childrenMap.inputText;
            if (inputText) {
              inputText.setText(GetHexColorString(this._value));
            }
            return;
          }
        } else {
          value = Clamp(Math.floor(value), 0, 0xffffff);
        }
        if (this._value === value) {
          return;
        }
        this._value = value;
        var swatch = this.childrenMap.swatch;
        if (swatch) {
          SetSwatchColor(swatch, value);
        }
        var inputText = this.childrenMap.inputText;
        if (inputText) {
          inputText.setText(GetHexColorString(value));
        }
        this.emit('valuechange', this._value);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }, {
      key: "color",
      get: function get() {
        return this._value;
      },
      set: function set(color) {
        this.value = color;
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color = color;
        return this;
      }
    }]);
    return ColorInput;
  }(Sizer);

  var methods$3 = {
    // Color picker
    setCreateColorPickerBackgroundCallback: function setCreateColorPickerBackgroundCallback(callback) {
      this.colorPickerCreateBackgroundCallback = callback;
      return this;
    },
    setColorPickerHPalettePosition: function setColorPickerHPalettePosition(position) {
      this.colorPickerHPalettePosition = position;
      return this;
    },
    setColorPickerExpandDirection: function setColorPickerExpandDirection(direction) {
      if (typeof direction === 'string') {
        direction = ColorPickerExpandDirections[direction];
      }
      this.colorPickerExpandDirection = direction;
      return this;
    },
    setColorPickerEaseInDuration: function setColorPickerEaseInDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }
      this.colorPickerEaseInDuration = duration;
      return this;
    },
    setColorPickerEaseOutDuration: function setColorPickerEaseOutDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }
      this.colorPickerEaseOutDuration = duration;
      return this;
    },
    setColorPickerTransitInCallback: function setColorPickerTransitInCallback(callback) {
      this.colorPickerTransitInCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    },
    setColorPickerTransitOutCallback: function setColorPickerTransitOutCallback(callback) {
      this.colorPickerTransitOutCallback = callback;
      // callback = function(gameObject, duration) {}
      return this;
    },
    setColorPickerBounds: function setColorPickerBounds(bounds) {
      this.colorPickerBounds = bounds;
      return this;
    },
    setColorPickerWidth: function setColorPickerWidth(width) {
      this.colorPickerWidth = width;
      return this;
    },
    setColorPickerHeight: function setColorPickerHeight(height) {
      this.colorPickerHeight = height;
      return this;
    },
    setColorPickerSize: function setColorPickerSize(width, height) {
      this.setColorPickerWidth(width).setColorPickerHeight(height);
      return this;
    },
    setColorPickerSpace: function setColorPickerSpace(space) {
      if (space === undefined) {
        space = {};
      }
      this.colorPickerSpace = space;
      return this;
    },
    // Color components
    setColorComponentsHeight: function setColorComponentsHeight(height) {
      this.colorComponentsHeight = height;
      return this;
    },
    setColorComponentsFormatLabelConfig: function setColorComponentsFormatLabelConfig(config) {
      this.colorComponentsFormatLabelConfig = config;
      return this;
    },
    setColorComponentsInputTextConfig: function setColorComponentsInputTextConfig(config) {
      this.colorComponentsInputTextConfig = config;
      return this;
    },
    setColorComponentsSpace: function setColorComponentsSpace(space) {
      if (space === undefined) {
        space = {};
      }
      this.colorComponentsSpace = space;
      return this;
    }
  };
  var ColorPickerExpandDirections = {
    down: 0,
    up: 1
  };

  var Color$2 = Phaser.Display.Color;
  var Percent$2 = Phaser.Math.Percent;
  var DrawHPalette = function DrawHPalette(canvas, context, verticalMode) {
    if (verticalMode === undefined) {
      verticalMode = false;
    }
    var width = canvas.width;
    var height = canvas.height;
    var color = new Color$2();
    if (verticalMode) {
      for (var iy = 0; iy < height; iy++) {
        var h = Percent$2(iy, 0, height);
        color.setFromHSV(h, 1, 1);
        context.fillStyle = color.rgba;
        context.fillRect(0, iy, width, 1);
      }
    } else {
      for (var ix = 0; ix < width; ix++) {
        var h = Percent$2(ix, 0, width);
        color.setFromHSV(h, 1, 1);
        context.fillStyle = color.rgba;
        context.fillRect(ix, 0, 1, height);
      }
    }
  };
  var DrawSVPalette = function DrawSVPalette(canvas, context, h) {
    var width = canvas.width;
    var height = canvas.height;
    var imgData = context.getImageData(0, 0, width, height);
    var data = imgData.data;
    var color = new Color$2();
    for (var iy = 0; iy < height; iy++) {
      for (var ix = 0; ix < width; ix++) {
        var s = Percent$2(ix, 0, width);
        var v = 1 - Percent$2(iy, 0, height);
        color.setFromHSV(h, s, v);
        var i = (iy * width + ix) * 4;
        data[i] = color.red;
        data[i + 1] = color.green;
        data[i + 2] = color.blue;
        data[i + 3] = 255;
      }
    }
    context.putImageData(imgData, 0, 0);
  };

  var Color$1 = Phaser.Display.Color;
  var Percent$1 = Phaser.Math.Percent;
  var ColorToRGBA$1 = Phaser.Display.Color.ColorToRGBA;
  var HSVToRGB$1 = Phaser.Display.Color.HSVToRGB;
  var HPaletteCanvas = /*#__PURE__*/function (_Canvas) {
    _inherits(HPaletteCanvas, _Canvas);
    function HPaletteCanvas(scene, x, y, width, height, orientation) {
      var _this;
      _classCallCheck(this, HPaletteCanvas);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 2;
      }
      if (height === undefined) {
        height = 2;
      }
      _this = _callSuper(this, HPaletteCanvas, [scene, x, y, width, height]);
      _this.type = 'rexColorPicker.HPaletteCanvas';
      _this.colorObject = new Color$1();
      _this.setOrientation(orientation);
      _this.setSize(width, height);
      return _this;
    }
    _createClass(HPaletteCanvas, [{
      key: "setOrientation",
      value: function setOrientation(orientation) {
        this.orientation = GetOrientationMode(orientation);
        return this;
      }
    }, {
      key: "updateTexture",
      value: function updateTexture() {
        DrawHPalette(this.canvas, this.context, this.orientation);
        _get(_getPrototypeOf(HPaletteCanvas.prototype), "updateTexture", this).call(this);
        return this;
      }
    }, {
      key: "color",
      get: function get() {
        return this.colorObject.color;
      }
    }, {
      key: "hue",
      get: function get() {
        return this._hue;
      },
      set: function set(value) {
        this._hue = value;
      }
    }, {
      key: "getHue",
      value: function getHue(localX, localY) {
        if (localX === undefined) {
          return this.hue;
        }
        if (this.orientation === 0) {
          this.hue = Percent$1(localX, 0, this.width);
        } else {
          this.hue = Percent$1(localY, 0, this.height);
        }
        return this.hue;
      }
    }, {
      key: "getColor",
      value: function getColor(localX, localY) {
        if (localX === undefined) {
          return this.color;
        }
        var h = this.getHue(localX, localY);
        this.colorObject.setFromRGB(HSVToRGB$1(h, 1, 1));
        return this.colorObject.color;
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        if (this.color === color) {
          return this;
        }
        return this;
      }
    }, {
      key: "colorToLocalPosition",
      value: function colorToLocalPosition(color, out) {
        if (out === undefined) {
          out = {};
        } else if (out === true) {
          if (LocalXY$1 === undefined) {
            LocalXY$1 = {};
          }
          out = LocalXY$1;
        }
        this.colorObject.setFromRGB(ColorToRGBA$1(color));
        if (this.orientation === 0) {
          out.x = this.width * this.colorObject.h;
          out.y = this.height / 2;
        } else {
          out.x = this.width / 2;
          out.y = this.height * this.colorObject.h;
        }
        return out;
      }
    }]);
    return HPaletteCanvas;
  }(Canvas);
  var LocalXY$1 = undefined;

  var RotateAround = Phaser.Math.RotateAround;
  var LocalToWorld = function LocalToWorld(gameObject, localX, localY, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      if (GlobOut === undefined) {
        GlobOut = {};
      }
      out = GlobOut;
    }
    localX -= gameObject.width * gameObject.originX;
    localY -= gameObject.height * gameObject.originY;
    var point = {
      x: localX * gameObject.scaleX,
      y: localY * gameObject.scaleY
    };
    RotateAround(point, 0, 0, -gameObject.rotation);
    out.x = gameObject.x + localX;
    out.y = gameObject.y + localY;
    return out;
  };
  var GlobOut;

  var HPalette = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(HPalette, _OverlapSizer);
    function HPalette(scene, config) {
      var _this;
      _classCallCheck(this, HPalette);
      if (config === undefined) {
        config = {};
      }
      _this = _callSuper(this, HPalette, [scene, config]);
      var orientation = config.width != null ? 1 : 0;
      var paletteCanvas = new HPaletteCanvas(scene).setOrientation(orientation);
      scene.add.existing(paletteCanvas);
      _this.type = 'rexColorPicker.HPalette';
      paletteCanvas.setInteractive().on('pointerdown', _this.onPaletteCanvasPointerDown, _assertThisInitialized(_this)).on('pointermove', _this.onPaletteCanvasPointerDown, _assertThisInitialized(_this));
      var marker = new RoundRectangle$1(scene, {
        strokeColor: 0xffffff,
        strokeWidth: 2
      });
      scene.add.existing(marker);
      _this.add(paletteCanvas, {
        key: 'paletteCanvas',
        expand: true
      }).add(marker, {
        key: 'marker',
        expand: false
      });
      return _this;
    }
    _createClass(HPalette, [{
      key: "resize",
      value: function resize(width, height) {
        if (this.width === width && this.height === height) {
          return this;
        }
        _get(_getPrototypeOf(HPalette.prototype), "resize", this).call(this, width, height);
        var size = Math.min(width, height);
        this.childrenMap.marker.setSize(size, size);
        return this;
      }
    }, {
      key: "onPaletteCanvasPointerDown",
      value: function onPaletteCanvasPointerDown(pointer, localX, localY, event) {
        if (!pointer.isDown) {
          return;
        }
        var paletteCanvas = this.childrenMap.paletteCanvas;
        var color = paletteCanvas.getColor(localX, localY);
        this.setMarkerPosition(color);
        this.emit('input', color);
      }
    }, {
      key: "color",
      get: function get() {
        return this.childrenMap.paletteCanvas.color;
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        if (this.color === color) {
          return this;
        }
        var paletteCanvas = this.childrenMap.paletteCanvas;
        paletteCanvas.setColor(color);
        this.setMarkerPosition(color);
        return this;
      }
    }, {
      key: "setMarkerPosition",
      value: function setMarkerPosition(color) {
        var paletteCanvas = this.childrenMap.paletteCanvas;
        var marker = this.childrenMap.marker;
        var localXY = paletteCanvas.colorToLocalPosition(color, true);
        LocalToWorld(paletteCanvas, localXY.x, localXY.y, marker);
        this.resetChildPositionState(marker);
        return this;
      }
    }, {
      key: "getHue",
      value: function getHue(localX, localY) {
        var paletteCanvas = this.childrenMap.paletteCanvas;
        return paletteCanvas.getHue(localX, localY);
      }
    }]);
    return HPalette;
  }(OverlapSizer);

  var Color = Phaser.Display.Color;
  var Percent = Phaser.Math.Percent;
  var ColorToRGBA = Phaser.Display.Color.ColorToRGBA;
  var HSVToRGB = Phaser.Display.Color.HSVToRGB;
  var SVPaletteCanvas = /*#__PURE__*/function (_Canvas) {
    _inherits(SVPaletteCanvas, _Canvas);
    function SVPaletteCanvas(scene, x, y, width, height, hue) {
      var _this;
      _classCallCheck(this, SVPaletteCanvas);
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = 2;
      }
      if (height === undefined) {
        height = 2;
      }
      _this = _callSuper(this, SVPaletteCanvas, [scene, x, y, width, height]);
      _this.type = 'rexColorPicker.SVPaletteCanvas';
      if (hue === undefined) {
        hue = 1;
      }
      _this.colorObject = new Color();
      _this.setHue(hue);
      _this.setSize(width, height);
      return _this;
    }
    _createClass(SVPaletteCanvas, [{
      key: "color",
      get: function get() {
        return this.colorObject.color;
      }
    }, {
      key: "hue",
      get: function get() {
        return this._hue;
      },
      set: function set(hue) {
        if (this._hue === hue) {
          return;
        }
        this._hue = hue;
        this.colorObject.h = hue;
        this.dirty = true;
      }
    }, {
      key: "setHue",
      value: function setHue(hue) {
        this.hue = hue;
        return this;
      }
    }, {
      key: "updateTexture",
      value: function updateTexture() {
        DrawSVPalette(this.canvas, this.context, this.hue);
        _get(_getPrototypeOf(SVPaletteCanvas.prototype), "updateTexture", this).call(this);
        return this;
      }
    }, {
      key: "getColor",
      value: function getColor(localX, localY) {
        if (localX === undefined) {
          return this.colorObject.color;
        }
        var s = Percent(localX, 0, this.width);
        var v = 1 - Percent(localY, 0, this.height);
        this.colorObject.setFromRGB(HSVToRGB(this.hue, s, v));
        return this.colorObject.color;
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        if (this.color === color) {
          return this;
        }
        this.colorObject.setFromRGB(ColorToRGBA(color));
        this.setHue(this.colorObject.h);
        return this;
      }
    }, {
      key: "colorToLocalPosition",
      value: function colorToLocalPosition(color, out) {
        if (out === undefined) {
          out = {};
        } else if (out === true) {
          if (LocalXY === undefined) {
            LocalXY = {};
          }
          out = LocalXY;
        }
        this.colorObject.setFromRGB(ColorToRGBA(color));
        out.x = this.width * this.colorObject.s;
        out.y = this.height * (1 - this.colorObject.v);
        return out;
      }
    }]);
    return SVPaletteCanvas;
  }(Canvas);
  var LocalXY = undefined;

  var SVPalette = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(SVPalette, _OverlapSizer);
    function SVPalette(scene, config) {
      var _this;
      _classCallCheck(this, SVPalette);
      _this = _callSuper(this, SVPalette, [scene, config]);
      var paletteCanvas = new SVPaletteCanvas(scene);
      scene.add.existing(paletteCanvas);
      _this.type = 'rexColorPicker.SVPalette';
      paletteCanvas.setInteractive().on('pointerdown', _this.onPaletteCanvasPointerDown, _assertThisInitialized(_this)).on('pointermove', _this.onPaletteCanvasPointerDown, _assertThisInitialized(_this));
      var marker = new RoundRectangle$1(scene, {
        radius: 5,
        strokeColor: 0xffffff,
        strokeWidth: 2
      });
      scene.add.existing(marker);
      _this.add(paletteCanvas, {
        key: 'paletteCanvas',
        expand: true
      }).add(marker, {
        key: 'marker',
        expand: false
      });
      return _this;
    }
    _createClass(SVPalette, [{
      key: "onPaletteCanvasPointerDown",
      value: function onPaletteCanvasPointerDown(pointer, localX, localY, event) {
        if (!pointer.isDown) {
          return;
        }
        var paletteCanvas = this.childrenMap.paletteCanvas;
        var color = paletteCanvas.getColor(localX, localY);
        this.setMarkerPosition(color);
        this.emit('input', color);
      }
    }, {
      key: "color",
      get: function get() {
        return this.childrenMap.paletteCanvas.color;
      }
    }, {
      key: "setHue",
      value: function setHue(hue) {
        var paletteCanvas = this.childrenMap.paletteCanvas;
        paletteCanvas.setHue(hue); // Redraw paletteCanvas
        // Position of marker does not change
        return this;
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        if (this.color === color) {
          return this;
        }
        var paletteCanvas = this.childrenMap.paletteCanvas;
        paletteCanvas.setColor(color); // Redraw paletteCanvas
        this.setMarkerPosition(color);
        return this;
      }
    }, {
      key: "setMarkerPosition",
      value: function setMarkerPosition(color) {
        var paletteCanvas = this.childrenMap.paletteCanvas;
        var marker = this.childrenMap.marker;
        var localXY = paletteCanvas.colorToLocalPosition(color, true);
        LocalToWorld(paletteCanvas, localXY.x, localXY.y, marker);
        this.resetChildPositionState(marker);
        return this;
      }
    }]);
    return SVPalette;
  }(OverlapSizer);

  var GetValue$m = Phaser.Utils.Objects.GetValue;
  var ColorPicker = /*#__PURE__*/function (_Sizer) {
    _inherits(ColorPicker, _Sizer);
    function ColorPicker(scene, config) {
      var _this;
      _classCallCheck(this, ColorPicker);
      _this = _callSuper(this, ColorPicker, [scene, config]);
      _this.type = 'rexColorPicker';
      _this.freezePalettes = false;

      // orientation
      var hPalettePosition = GetValue$m(config, 'hPalette.position', 0);
      if (typeof hPalettePosition === 'string') {
        hPalettePosition = HPalettePositionNamesMap[hPalettePosition];
      }
      var orientation = hPalettePosition === 0 ||
      // bottom
      hPalettePosition === 2 // top
      ? 1 :
      // y
      0; // x
      _this.setOrientation(orientation);

      // Add elements
      var background = GetValue$m(config, 'background', undefined);
      var hPaletteWidth, hPaletteHeight;
      if (_this.orientation === 0) {
        var hPaletteWidth = GetValue$m(config, 'hPalette.width', undefined);
        if (hPaletteWidth === undefined) {
          hPaletteWidth = GetValue$m(config, 'hPalette.size', 10);
        }
      } else {
        hPaletteHeight = GetValue$m(config, 'hPalette.height', undefined);
        if (hPaletteHeight === undefined) {
          hPaletteHeight = GetValue$m(config, 'hPalette.size', 10);
        }
      }
      var hPalette = new HPalette(scene, {
        width: hPaletteWidth,
        height: hPaletteHeight
      });
      scene.add.existing(hPalette);
      var svPaletteWidth = GetValue$m(config, 'svPalette.width', undefined);
      var svPaletteHeight = GetValue$m(config, 'svPalette.height', undefined);
      var svPalette = new SVPalette(scene, {
        width: svPaletteWidth,
        height: svPaletteHeight
      });
      scene.add.existing(svPalette);
      if (background) {
        _this.addBackground(background);
      }
      var hPaletteAddConfig = {
        proportion: 0,
        expand: true
      };
      var svPaletteProportion, svPaletteExpand;
      if (_this.orientation === 0) {
        svPaletteProportion = svPaletteWidth === undefined ? 1 : 0;
        svPaletteExpand = svPaletteHeight === undefined ? true : false;
      } else {
        svPaletteProportion = svPaletteHeight === undefined ? 1 : 0;
        svPaletteExpand = svPaletteWidth === undefined ? true : false;
      }
      var svPaletteAddConfig = {
        proportion: svPaletteProportion,
        expand: svPaletteExpand
      };
      if (hPalettePosition === 0 || hPalettePosition === 3) {
        // bottom, right
        _this.add(svPalette, svPaletteAddConfig).add(hPalette, hPaletteAddConfig);
      } else {
        // left, top
        _this.add(hPalette, hPaletteAddConfig).add(svPalette, svPaletteAddConfig);
      }
      hPalette.on('input', function () {
        svPalette.setHue(hPalette.getHue());
        this.setValue(svPalette.color, true);
      }, _assertThisInitialized(_this));
      svPalette.on('input', function () {
        this.setValue(svPalette.color, true);
      }, _assertThisInitialized(_this));
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('hPalette', hPalette);
      _this.addChildrenMap('svPalette', svPalette);
      var callback = GetValue$m(config, 'valuechangeCallback', null);
      if (callback !== null) {
        var scope = GetValue$m(config, 'valuechangeCallbackScope', undefined);
        _this.on('valuechange', callback, scope);
      }
      _this.setValue(GetValue$m(config, 'value', 0xffffff));
      return _this;
    }
    _createClass(ColorPicker, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (this._value === value) {
          return;
        }
        var oldValue = this._value;
        this._value = value;
        if (!this.freezePalettes) {
          this.updatePalettes();
        }
        this.emit('valuechange', value, oldValue, this);
      }
    }, {
      key: "setValue",
      value: function setValue(value, freezePalettes) {
        this.freezePalettes = !!freezePalettes;
        this.value = value;
        this.freezePalettes = false;
        return this;
      }
    }, {
      key: "color",
      get: function get() {
        return this._value;
      },
      set: function set(color) {
        this.value = color;
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color = color;
        return this;
      }
    }, {
      key: "updatePalettes",
      value: function updatePalettes() {
        this.childrenMap.hPalette.setColor(this.color);
        this.childrenMap.svPalette.setColor(this.color);
        return this;
      }
    }, {
      key: "postLayout",
      value: function postLayout(parent, newWidth, newHeight) {
        this.childrenMap.hPalette.setMarkerPosition(this.value);
        this.childrenMap.svPalette.setMarkerPosition(this.value);
        return this;
      }
    }]);
    return ColorPicker;
  }(Sizer);
  var HPalettePositionNamesMap = {
    bottom: 0,
    left: 1,
    top: 2,
    right: 3
  };

  var GetValue$l = Phaser.Utils.Objects.GetValue;
  var ColorPickerPanel = /*#__PURE__*/function (_Sizer) {
    _inherits(ColorPickerPanel, _Sizer);
    function ColorPickerPanel(scene, config) {
      var _this;
      _classCallCheck(this, ColorPickerPanel);
      if (config === undefined) {
        config = {};
      }
      config.orientation = 1;
      _this = _callSuper(this, ColorPickerPanel, [scene, config]);
      _this.type = 'rexColorInput.ColorPickerPanel';

      // Add elements
      var background = GetValue$l(config, 'background', undefined);
      var colorPicker = new ColorPicker(scene, {
        hPalette: config.hPalette || {},
        svPalette: config.svPalette || {},
        space: {
          item: GetValue$l(config, 'space.hPalette', 8)
        }
      });
      scene.add.existing(colorPicker);
      var colorComponents;
      if (config.colorComponents) {
        colorComponents = new ColorComponents(scene, config.colorComponents);
        scene.add.existing(colorComponents);
      }
      if (background) {
        _this.addBackground(background);
        new TouchEventStop(background, {
          stopAllLevels: false
        });
      }
      _this.add(colorPicker, {
        proportion: 1,
        expand: true
      });
      if (colorComponents) {
        _this.add(colorComponents, {
          proportion: 0,
          expand: true
        });
      }
      _this.addChildrenMap('background', background);
      _this.addChildrenMap('colorPicker', colorPicker);
      _this.addChildrenMap('colorComponents', colorComponents);
      colorPicker.on('valuechange', function (value) {
        this.setValue(value);
      }, _assertThisInitialized(_this));
      if (colorComponents) {
        colorComponents.on('valuechange', function (value) {
          this.setValue(value);
        }, _assertThisInitialized(_this));
      }
      _this.setValue(GetValue$l(config, 'value', 0xffffff));
      return _this;
    }
    _createClass(ColorPickerPanel, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (this._value === value) {
          return;
        }
        this._value = value;
        var colorPicker = this.childrenMap.colorPicker;
        colorPicker.setValue(value);
        var colorComponents = this.childrenMap.colorComponents;
        if (colorComponents) {
          colorComponents.setValue(value);
        }
        this.emit('valuechange', value);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }]);
    return ColorPickerPanel;
  }(Sizer);

  Phaser.Utils.Objects.GetValue;
  var CreateColorPicker = function CreateColorPicker(scene) {
    var scene = this.scene;
    var background;
    var createBackgroundCallback = this.colorPickerCreateBackgroundCallback;
    if (createBackgroundCallback) {
      background = createBackgroundCallback.call(this, scene);
      scene.add.existing(background);
    }
    var width = this.colorPickerWidth;
    if (width === undefined) {
      width = this.width;
    }
    var height = this.colorPickerHeight;
    if (height === undefined) {
      height = width;
    }
    var colorComponentsConfig;
    if (this.colorComponentsHeight > 0) {
      colorComponentsConfig = {
        height: this.colorComponentsHeight,
        formatLabel: this.colorComponentsFormatLabelConfig,
        inputText: this.colorComponentsInputTextConfig,
        space: this.colorComponentsSpace
      };
    } else {
      colorComponentsConfig = false;
    }
    var colorPicker = new ColorPickerPanel(scene, {
      width: width,
      height: height,
      background: background,
      space: this.colorPickerSpace,
      hPalette: {
        position: this.colorPickerHPalettePosition
      },
      colorComponents: colorComponentsConfig,
      value: this.value
    });
    scene.add.existing(colorPicker);
    return colorPicker;
  };

  var OpenColorPicker = function OpenColorPicker() {
    if (this.colorPicker) {
      return;
    }

    // Layout it to get full height
    var colorPicker = CreateColorPicker.call(this).layout();
    var dropDownBehavior = new DropDown(colorPicker, {
      // Transition
      duration: {
        "in": this.colorPickerEaseInDuration,
        out: this.colorPickerEaseOutDuration
      },
      transitIn: this.colorPickerTransitInCallback,
      transitOut: this.colorPickerTransitOutCallback,
      // Position
      expandDirection: this.colorPickerExpandDirection,
      alignTargetX: this,
      alignTargetY: this,
      bounds: this.colorPickerBounds,
      // Close condition
      touchOutsideClose: true
    }).on('open', function () {
      // After popping up
      // Can click
      colorPicker.on('valuechange', function (value) {
        this.setValue(value);
      }, this);
    }, this).on('close', function () {
      this.colorPicker = undefined;
      this.dropDownBehavior = undefined;
    }, this);
    this.colorPicker = colorPicker;
    this.dropDownBehavior = dropDownBehavior;
    this.pin(colorPicker);
    return this;
  };

  var methods$2 = {
    openColorPicker: OpenColorPicker
  };
  Object.assign(methods$2, methods$3);

  var GetValue$k = Phaser.Utils.Objects.GetValue;
  var ColorInput = /*#__PURE__*/function (_ColorInputBase) {
    _inherits(ColorInput, _ColorInputBase);
    function ColorInput(scene, config) {
      var _this;
      _classCallCheck(this, ColorInput);
      if (config === undefined) {
        config = {};
      }
      _this = _callSuper(this, ColorInput, [scene, config]);
      _this.type = 'rexColorInput';
      if (!config.hasOwnProperty('colorPicker')) {
        config.colorPicker = {
          background: {
            color: 0x0
          }
        };
      }
      var colorPickerConfig = config.colorPicker;
      var hasColorPicker = colorPickerConfig !== false && colorPickerConfig !== null;
      if (hasColorPicker) {
        _this.setColorPickerSize(GetValue$k(colorPickerConfig, 'width', 160), GetValue$k(colorPickerConfig, 'height', 170));
        var createBackgroundCallback;
        var background = GetValue$k(colorPickerConfig, 'background');
        if (background) {
          createBackgroundCallback = function createBackgroundCallback(scene) {
            return CreateBackground$2(scene, background);
          };
        } else {
          createBackgroundCallback = GetValue$k(colorPickerConfig, 'createBackgroundCallback');
        }
        _this.setCreateColorPickerBackgroundCallback(createBackgroundCallback);
        _this.setColorPickerHPalettePosition(GetValue$k(colorPickerConfig, 'hPalettePosition', 0));
        _this.setColorPickerExpandDirection(GetValue$k(colorPickerConfig, 'expandDirection'));
        _this.setColorPickerEaseInDuration(GetValue$k(colorPickerConfig, 'easeIn', 200));
        _this.setColorPickerEaseOutDuration(GetValue$k(colorPickerConfig, 'easeOut', 200));
        _this.setColorPickerTransitInCallback(GetValue$k(colorPickerConfig, 'transitIn'));
        _this.setColorPickerTransitOutCallback(GetValue$k(colorPickerConfig, 'transitOut'));
        _this.setColorPickerBounds(GetValue$k(colorPickerConfig, 'bounds'));
        var colorPickerSpaceConfig = GetValue$k(colorPickerConfig, 'space');
        if (colorPickerSpaceConfig === undefined) {
          colorPickerSpaceConfig = {
            left: 10,
            right: 10,
            top: 10,
            bottom: 10,
            item: 8
          };
        }
        _this.setColorPickerSpace(colorPickerSpaceConfig);
      }
      var colorComponentsConfig = config.colorComponents;
      var hasColorComponents = colorComponentsConfig !== false && colorComponentsConfig !== null;
      if (hasColorPicker && hasColorComponents) {
        _this.setColorComponentsHeight(GetValue$k(colorComponentsConfig, 'height', 30));
        _this.setColorComponentsFormatLabelConfig(GetValue$k(colorComponentsConfig, 'formatLabel'));
        var colorComponentsInputTextConfig = GetValue$k(colorComponentsConfig, 'inputText');
        if (!colorComponentsInputTextConfig) {
          colorComponentsInputTextConfig = GetValue$k(config, 'inputText');
        }
        _this.setColorComponentsInputTextConfig(colorComponentsInputTextConfig);
        var colorComponentsSpace = GetValue$k(colorComponentsConfig, 'space');
        if (colorComponentsSpace === undefined) {
          colorComponentsSpace = {
            item: 8
          };
        }
        _this.setColorComponentsSpace(colorComponentsSpace);
      }
      var swatch = _this.childrenMap.swatch;
      if (swatch && hasColorPicker) {
        _this.onClick(swatch, _this.openColorPicker, _assertThisInitialized(_this));
      }
      return _this;
    }
    return _createClass(ColorInput);
  }(ColorInput$1);
  Object.assign(ColorInput.prototype, methods$2);

  Phaser.Utils.Objects.GetValue;
  Phaser.Math.Distance.Between;
  Phaser.Math.RotateAroundDistance;

  Phaser.Utils.Objects.GetValue;
  Phaser.Math.Clamp;

  var RegisterInputHandler = function RegisterInputHandler(config) {
    var isValidInputHandler = true;
    if (!config.hasOwnProperty('accept')) {
      isValidInputHandler = false;
      console.error("[Tweaker] Can't register inputHandler '".concat(config.name, "', missing 'accept' callback."));
    }
    if (!config.hasOwnProperty('build')) {
      isValidInputHandler = false;
      console.error("[Tweaker] Can't register inputHandler '".concat(config.name, "', missing 'build' callback."));
    }
    if (isValidInputHandler) {
      this.inputHandlers.unshift(config);
    }
    return this;
  };

  var GetFirst = Phaser.Utils.Array.GetFirst;
  var Remove = Phaser.Utils.Array.Remove;
  var RemoveInputHandler = function RemoveInputHandler(name) {
    var handler = GetFirst(this.inputHandlers, 'name', name);
    if (handler) {
      Remove(this.inputHandlers, handler);
    }
    return this;
  };

  var Title = /*#__PURE__*/function (_Label) {
    _inherits(Title, _Label);
    function Title(scene, config) {
      var _this;
      _classCallCheck(this, Title);
      config = BuildLabelConfig(scene, config);
      _this = _callSuper(this, Title, [scene, config]);
      _this.type = 'rexTweaker.Title';
      return _this;
    }
    _createClass(Title, [{
      key: "setTitle",
      value: function setTitle(config) {
        config = config ? DeepClone(config) : {};
        if (config.hasOwnProperty('text')) ; else if (config.hasOwnProperty('title')) {
          config.text = config.title;
        } else {
          config.text = '';
        }
        this.resetDisplayContent(config);
        return this;
      }
    }]);
    return Title;
  }(Label);

  var FolderTitle = /*#__PURE__*/function (_Title) {
    _inherits(FolderTitle, _Title);
    function FolderTitle(scene, config) {
      var _this;
      _classCallCheck(this, FolderTitle);
      if (config === undefined) {
        config = {};
      }
      _this = _callSuper(this, FolderTitle, [scene, config]);
      _this.type = 'rexTweaker.FolderTitle';
      var expandedIcon = new Triangle(scene, config.expandedIcon);
      scene.add.existing(expandedIcon);
      _this.addSpace().add(expandedIcon, {
        proportion: 0,
        expand: false,
        padding: 1,
        fitRatio: 1
      });
      _this.addChildrenMap('expandedIcon', expandedIcon);
      return _this;
    }
    _createClass(FolderTitle, [{
      key: "setExpandedState",
      value: function setExpandedState(expanded) {
        if (expanded === undefined) {
          expanded = true;
        }
        var direction = expanded ? 'down' : 'right';
        var expandedIcon = this.childrenMap.expandedIcon;
        expandedIcon.setDirection(direction);
        return this;
      }
    }]);
    return FolderTitle;
  }(Title);

  var CreateTweaker = function CreateTweaker(scene, config) {
    var tweaker = new TweakerShell(scene, config);
    scene.add.existing(tweaker);
    return tweaker;
  };

  var CreateBackground = function CreateBackground(scene, config, style) {
    // TODO: Might create nine-slice as background
    return CreateBackground$2(scene, style);
  };

  var BindingTargetMethods$2 = {
    setBindingTarget: function setBindingTarget(target) {
      var child = this.childrenMap.child; // tweaker
      child.setBindingTarget(target);
      return this;
    }
  };

  var InputRowTitleWidthMethods$1 = {
    getMaxInputRowTitleWidth: function getMaxInputRowTitleWidth() {
      var child = this.childrenMap.child; // tweaker
      var titleWidth = child.getMaxInputRowTitleWidth();
      return titleWidth + this.getInnerPadding('left');
    },
    setInputRowTitleWidth: function setInputRowTitleWidth(width) {
      width -= this.getInnerPadding('left');
      var child = this.childrenMap.child; // tweaker
      child.setInputRowTitleWidth(width);
      return this;
    }
  };

  var Folder = /*#__PURE__*/function (_FolderBase) {
    _inherits(Folder, _FolderBase);
    function Folder(scene, config) {
      var _this;
      _classCallCheck(this, Folder);
      _this = _callSuper(this, Folder, [scene, config]);
      _this.type = 'rexTweaker.Folder';
      return _this;
    }
    _createClass(Folder, [{
      key: "setTitle",
      value: function setTitle(config) {
        var title = this.childrenMap.title;
        title.setTitle(config);
        return this;
      }
    }]);
    return Folder;
  }(Folder$1);
  Object.assign(Folder.prototype, BindingTargetMethods$2, InputRowTitleWidthMethods$1);

  var GetValue$j = Phaser.Utils.Objects.GetValue;
  var CreateFolder = function CreateFolder(scene, config, style) {
    // Create Folder-title
    var titleStyle = GetValue$j(style, 'title') || {};
    var title = new FolderTitle(scene, titleStyle);
    scene.add.existing(title);
    title.on('folder.expand', function () {
      title.setExpandedState(true);
    }).on('folder.collapse', function () {
      title.setExpandedState(false);
    });
    var tweakerConfig = {
      root: GetValue$j(style, 'root'),
      styles: GetValue$j(style, 'tweaker'),
      space: GetValue$j(style, 'space') || {}
    };
    var child = CreateTweaker(scene, tweakerConfig);
    var backgroundStyle = GetValue$j(style, 'background');
    var background = CreateBackground(scene, config, backgroundStyle);
    var folder = new Folder(scene, {
      orientation: 1,
      title: title,
      child: child,
      background: background,
      transition: {
        duration: GetValue$j(style, 'transition.duration', 200)
      }
    });
    scene.add.existing(folder);
    return folder;
  };

  var GetValue$i = Phaser.Utils.Objects.GetValue;
  var AddFolder = function AddFolder(config) {
    var scene = this.scene;

    // Create folder
    var folderStyle = GetValue$i(this.styles, 'folder') || {};
    folderStyle.tweaker = this.styles;
    folderStyle.root = this.root;
    var folder = CreateFolder(scene, config, folderStyle);
    delete folderStyle.tweaker;
    delete folderStyle.root;

    // Add folder
    this.add(folder, {
      expand: true
    });

    // Set content
    folder.setTitle(config);
    var expanded = GetValue$i(config, 'expanded', true);
    if (expanded !== undefined) {
      folder.setExpandedState(expanded);
    }
    var childTweaker = folder.getElement('child');
    if (config.key) {
      this.root.addChildrenMap(config.key, childTweaker);
    }
    return childTweaker;
  };

  var BindingTargetMethods$1 = {
    setBindingTarget: function setBindingTarget(target) {
      var children = this.childrenMap.pages.children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].setBindingTarget(target);
      }
      return this;
    }
  };

  var InputRowTitleWidthMethods = {
    getMaxInputRowTitleWidth: function getMaxInputRowTitleWidth() {
      var maxTitleWidth = 0;
      var children = this.childrenMap.pages.children; // tweaker array
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        maxTitleWidth = Math.max(maxTitleWidth, children[i].getMaxInputRowTitleWidth());
      }
      return maxTitleWidth + this.getInnerPadding('left');
    },
    setInputRowTitleWidth: function setInputRowTitleWidth(width) {
      width -= this.getInnerPadding('left');
      var children = this.childrenMap.pages.children; // tweaker array
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].setInputRowTitleWidth(width);
      }
      return this;
    }
  };

  var TabPages = /*#__PURE__*/function (_TabPagesBase) {
    _inherits(TabPages, _TabPagesBase);
    function TabPages(scene, config) {
      var _this;
      _classCallCheck(this, TabPages);
      _this = _callSuper(this, TabPages, [scene, config]);
      _this.type = 'rexTweaker.TabPages';
      return _this;
    }
    return _createClass(TabPages);
  }(TabPages$1);
  Object.assign(TabPages.prototype, BindingTargetMethods$1, InputRowTitleWidthMethods);

  var GetValue$h = Phaser.Utils.Objects.GetValue;
  var CreateTab = function CreateTab(scene, config, style) {
    var tabPages = new TabPages(scene, style);
    scene.add.existing(tabPages);
    var tabConfig = GetValue$h(style, 'tab');
    var tweakerConfig = {
      root: GetValue$h(style, 'root'),
      styles: GetValue$h(style, 'tweaker')
    };
    var pages = GetValue$h(config, 'pages') || [];
    for (var i = 0, cnt = pages.length; i < cnt; i++) {
      var page = pages[i];
      tabPages.addPage({
        key: page.title,
        tab: CreateLabel(scene, tabConfig).setActiveState(false).resetDisplayContent({
          text: page.title
        }),
        page: CreateTweaker(scene, tweakerConfig)
      });
    }
    tabPages.on('tab.focus', function (tab, key) {
      tab.setActiveState(true);
    }).on('tab.blur', function (tab, key) {
      tab.setActiveState(false);
    });
    return tabPages;
  };

  var GetValue$g = Phaser.Utils.Objects.GetValue;
  var AddTab = function AddTab(config) {
    var scene = this.scene;

    // Create tab
    var tabStyle = GetValue$g(this.styles, 'tab') || {};
    tabStyle.tweaker = this.styles;
    tabStyle.root = this.root;
    var tab = CreateTab(scene, config, tabStyle);
    delete tabStyle.tweaker;
    delete tabStyle.root;

    // Add tab
    this.add(tab, {
      expand: true
    });
    var pagesConfig = GetValue$g(config, 'pages') || [];
    var pages = [];
    var shownPageIndex = 0;
    for (var i = 0, cnt = pagesConfig.length; i < cnt; i++) {
      var childTweaker = tab.getPage(i);
      var isPageShown = pagesConfig[i].show;
      if (isPageShown) {
        shownPageIndex = i;
      }
      var key = pagesConfig[i].key;
      if (key) {
        this.root.addChildrenMap(key, childTweaker);
      }
      pages.push(childTweaker);
    }
    tab.swapPage(shownPageIndex, 0);
    return pages;
  };

  var GetValue$f = Phaser.Utils.Objects.GetValue;
  var BindingTargetMethods = {
    setupBinding: function setupBinding() {
      var inputField = this.childrenMap.inputField;
      inputField
      // Set text value to object when closing editor
      .on('valuechange', function (value) {
        if (!this.autoUpdateEnable) {
          return;
        }
        this.setTargetValue(value);
      }, this);
      return this;
    },
    setAutoUpdateEnable: function setAutoUpdateEnable(enable) {
      if (enable === undefined) {
        enable = true;
      }
      this.autoUpdateEnable = enable;
      return this;
    },
    setBindingTarget: function setBindingTarget(target, key) {
      this.bindingTarget = target;
      if (key !== undefined) {
        this.setBindingTargetKey(key);
      }
      this.syncTargetValue();
      return this;
    },
    setBindingTargetKey: function setBindingTargetKey(key) {
      this.bindTargetKey = key;
      return this;
    },
    setValueCallbacks: function setValueCallbacks(config) {
      this.onGetValue = GetValue$f(config, 'onGetValue');
      this.onSetValue = GetValue$f(config, 'onSetValue');
      return this;
    },
    getTargetValue: function getTargetValue() {
      if (!this.bindingTarget) {
        return undefined;
      }
      if (this.bindTargetKey != null) {
        return this.bindingTarget[this.bindTargetKey];
      }
      if (this.onGetValue) {
        return this.onGetValue(this.bindingTarget);
      }
      return undefined;
    },
    setTargetValue: function setTargetValue(value) {
      if (!this.bindingTarget) {
        return this;
      }
      if (this.bindTargetKey != null) {
        this.bindingTarget[this.bindTargetKey] = value;
        return this;
      }
      if (this.onSetValue) {
        this.onSetValue(this.bindingTarget, value);
      }
      return this;
    },
    syncTargetValue: function syncTargetValue() {
      if (!this.bindingTarget) {
        return this;
      }
      var inputField = this.childrenMap.inputField;
      if (inputField.syncValue) {
        inputField.syncValue(this.getTargetValue());
      }
      return this;
    }
  };

  var MonitorTargetMethods = {
    startMonitorTarget: function startMonitorTarget() {
      if (this.isMonitoring) {
        return this;
      }
      this.isMonitoring = true;
      this.scene.events.on('postupdate', this.onMonitorTarget, this);
      return this;
    },
    stopMonitorTarget: function stopMonitorTarget() {
      if (!this.isMonitoring) {
        return this;
      }
      this.isMonitoring = false;
      this.scene.events.off('postupdate', this.onMonitorTarget, this);
      return this;
    },
    onMonitorTarget: function onMonitorTarget() {
      if (!this.bindingTarget) {
        return;
      }
      var newValue = this.getTargetValue();
      var inputField = this.childrenMap.inputField;
      if (inputField.value === newValue) {
        return;
      }
      // Sync new value
      inputField.syncValue(newValue);
    }
  };

  var MinTitleWidthMethods = {
    getMinTitleWidth: function getMinTitleWidth() {
      var title = this.childrenMap.title;
      if (!title || title.orientation !== 0) {
        // Don't count vertical input row
        return 0;
      }
      var padding = title.rexSizer.padding;
      var titleWidth = this.getChildWidth(this.childrenMap.title) + padding.left + padding.right;
      return titleWidth + this.getInnerPadding('left');
    },
    setMinTitleWidth: function setMinTitleWidth(width) {
      var title = this.childrenMap.title;
      if (!title || title.orientation !== 0) {
        // Don't set vertical input row
        return this;
      }
      var padding = title.rexSizer.padding;
      width -= padding.left + padding.right;
      title.minWidth = width;
      return this;
    }
  };

  var GetValue$e = Phaser.Utils.Objects.GetValue;
  var InputRow = /*#__PURE__*/function (_Sizer) {
    _inherits(InputRow, _Sizer);
    function InputRow(scene, config) {
      var _this;
      _classCallCheck(this, InputRow);
      _this = _callSuper(this, InputRow, [scene, config]);
      _this.type = 'rexTweaker.InputRow';
      _this.bindingTarget = undefined;
      _this.bindTargetKey = undefined;
      _this.autoUpdateEnable = true;
      var inputTitle = config.inputTitle;
      var inputField = config.inputField;
      var background = config.background;
      var proportion = GetValue$e(config, 'proportion.title', 0);
      var titleSpace = GetValue$e(config, 'space.title', 0);
      var padding;
      if (_this.orientation === 0) {
        padding = {
          right: titleSpace
        };
      } else {
        padding = {
          bottom: titleSpace
        };
      }
      _this.add(inputTitle, {
        proportion: proportion,
        expand: true,
        padding: padding
      });
      var defaultProportion = inputField.defaultProportion;
      if (defaultProportion === undefined) {
        defaultProportion = config.parentOrientation === 1 ? 1 : 0;
      }
      var proportion = GetValue$e(config, 'proportion.inputField', defaultProportion);
      _this.add(inputField, {
        proportion: proportion,
        expand: true
      });
      if (background) {
        _this.addBackground(background);
      }
      _this.addChildrenMap('title', inputTitle);
      _this.addChildrenMap('inputField', inputField);
      _this.addChildrenMap('background', background);
      _this.setupBinding();
      return _this;
    }
    _createClass(InputRow, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene || this.ignoreDestroy) {
          return;
        }
        this.stopMonitorTarget();
        _get(_getPrototypeOf(InputRow.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setTitle",
      value: function setTitle(config) {
        var title = this.childrenMap.title;
        title.setTitle(config);
        return this;
      }
    }, {
      key: "preLayout",
      value: function preLayout() {
        var title = this.childrenMap.title;
        if (title) {
          title.minWidth = 0;
        }
        _get(_getPrototypeOf(InputRow.prototype), "preLayout", this).call(this);
      }
    }]);
    return InputRow;
  }(Sizer);
  Object.assign(InputRow.prototype, BindingTargetMethods, MonitorTargetMethods, MinTitleWidthMethods);

  var CreateTitleLabel = function CreateTitleLabel(scene, config, style) {
    var gameObject = new Title(scene, style);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var GenerateInputFieldClass = function GenerateInputFieldClass(BaseClass) {
    if (BaseClass === undefined) {
      BaseClass = Sizer;
    }
    var InputFiled = /*#__PURE__*/function (_BaseClass) {
      _inherits(InputFiled, _BaseClass);
      function InputFiled() {
        _classCallCheck(this, InputFiled);
        return _callSuper(this, InputFiled, arguments);
      }
      _createClass(InputFiled, [{
        key: "bindingTarget",
        get: function get() {
          return this.getParentSizer().bindingTarget;
        }
      }, {
        key: "bindingKey",
        get: function get() {
          return this.getParentSizer().bindTargetKey;
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          if (this._value === value) {
            return;
          }
          if (!this.validate(value)) {
            value = this._value; // Back to previous value
          }
          if (this.displayValueCallback) {
            this.displayValueCallback(this, value);
          }
          if (this._value === value) {
            return;
          }
          var oldValue = this._value;
          this._value = value;
          if (!this.syncValueFlag) {
            this.emit('valuechange', value, oldValue, this.bindingTarget, this.bindingKey);
          }
        }
      }, {
        key: "validate",
        value: function validate(newValue) {
          if (this.syncValueFlag || !this.validateCallback) {
            return true;
          }
          return this.validateCallback(newValue, this._value, this.bindingTarget, this.bindingKey);
        }
      }, {
        key: "getFotmatText",
        value: function getFotmatText(value) {
          if (this.textFormatCallback) {
            value = this.textFormatCallback(value);
          } else {
            value = value.toString();
          }
          return value;
        }
      }, {
        key: "getValue",
        value: function getValue() {
          return this.value;
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }

        /* 
        Internal method invoked when 
        - inputRow.setBindingTarget(target), or 
        - inputRow.syncTargetValue()
        */
      }, {
        key: "syncValue",
        value: function syncValue(value) {
          this.syncValueFlag = true;
          this.value = value;
          this.syncValueFlag = false;
          return this;
        }
      }, {
        key: "setup",
        value: function setup(config, setDefaults) {
          if (setDefaults === undefined) {
            setDefaults = false;
          }
          if (setDefaults || config.hasOwnProperty('format')) {
            this.setTextFormatCallback(config.format);
          }
          if (setDefaults || config.hasOwnProperty('onValidate')) {
            this.setValidateCallback(config.onValidate);
          }
          if (this.setupCallback) {
            this.setupCallback(this, config, setDefaults);
          }
          return this;
        }
      }, {
        key: "setSetupCallback",
        value: function setSetupCallback(callback) {
          this.setupCallback = callback;
          return this;
        }
      }, {
        key: "setDisplayValueCallback",
        value: function setDisplayValueCallback(callback) {
          this.displayValueCallback = callback;
          return this;
        }
      }, {
        key: "setTextFormatCallback",
        value: function setTextFormatCallback(callback) {
          this.textFormatCallback = callback;
          return this;
        }
      }, {
        key: "setValidateCallback",
        value: function setValidateCallback(callback) {
          this.validateCallback = callback;
          return this;
        }
      }]);
      return InputFiled;
    }(BaseClass);
    return InputFiled;
  };

  var CreateInputField = function CreateInputField(scene, config, style) {
    var inputField;
    var inputHandlers = this.inputHandlers;
    for (var i = 0, cnt = inputHandlers.length; i < cnt; i++) {
      var handler = inputHandlers[i];
      if (handler.accept(config)) {
        var InputFieldClass = GenerateInputFieldClass(handler.baseClass);
        inputField = new InputFieldClass(scene);
        scene.add.existing(inputField);
        inputField.setSetupCallback(handler.setup).setDisplayValueCallback(handler.displayValue);
        handler.build(inputField, style);
        break;
      }
    }
    if (inputField) {
      // Setup by config
      inputField.setup(config, true);
    }
    return inputField;
  };

  var GetValue$d = Phaser.Utils.Objects.GetValue;
  var CreateInputRow = function CreateInputRow(scene, config, style) {
    // InputField
    var inputField = CreateInputField.call(this, scene, config, style);
    if (!inputField) {
      // Can't create inputField
      return null;
    }

    // Title
    var titleStyle = GetValue$d(style, 'title') || {};
    var inputTitle = CreateTitleLabel(scene, config, titleStyle);

    // Background
    var backgroundStyle = GetValue$d(style, 'background') || {};
    var background = CreateBackground$2(scene, backgroundStyle);
    var inputRow = new InputRow(scene, _objectSpread2(_objectSpread2(_objectSpread2({}, style), config), {}, {
      // config can overwrite style

      inputTitle: inputTitle,
      inputField: inputField,
      background: background
    }));
    scene.add.existing(inputRow);
    inputRow.setTitle(config);
    inputRow.setValueCallbacks(config);
    return inputRow;
  };

  var AddInput = function AddInput(object, key, config) {
    if (arguments.length === 1) {
      config = object;
      object = config.bindingTarget;
      key = config.bindingKey;
    } else {
      if (config === undefined) {
        config = {};
      }
      config.bindingTarget = object;
      config.bindingKey = key;
    }
    if (!config.title) {
      config.title = key;
    }
    if (config.bindingTarget && config.bindingKey) {
      config.value = config.bindingTarget[config.bindingKey];
    } else {
      config.value = undefined;
    }

    // Create InputRow
    var inputRowStyle = this.styles.inputRow || {};
    inputRowStyle.parentOrientation = this.styles.orientation;
    var inputSizer = CreateInputRow.call(this, this.scene, config, inputRowStyle);
    if (!inputSizer) {
      // Can't create inputField
      console.error("[Tweaker] Can't add Input\n    title: ".concat(config.title, "\n    view: ").concat(config.view, "\n"));
      return this;
    }
    var inputField = inputSizer.childrenMap.inputField;
    var proportion;
    if (this.orientation === 1) {
      // y
      proportion = 0;
    } else {
      // x
      proportion = this.itemWidth > 0 ? 0 : 1;
      inputSizer.setMinWidth(this.itemWidth);
    }

    // Add InputRow to Tweaker
    this.add(inputSizer, {
      proportion: proportion,
      expand: true
    });
    if (config.onValueChange) {
      inputField.on('valuechange', config.onValueChange);
    }

    // Bind target
    inputSizer.setAutoUpdateEnable(config.autoUpdate);
    inputSizer.setBindingTarget(object, key);
    if (config.monitor) {
      inputSizer.startMonitorTarget();
    }
    if (config.key) {
      this.root.addChildrenMap(config.key, inputSizer);
    }
    return this;
  };

  var CreateRoundRectangle = function CreateRoundRectangle(scene, config) {
    var gameObject = new RoundRectangle$1(scene, config);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var GetValue$c = Phaser.Utils.Objects.GetValue;
  var CreateButtons$1 = function CreateButtons(scene, config) {
    var wrap = GetValue$c(config, 'wrap', false);
    var ButtonClass = wrap ? Buttons : Buttons$1;
    var gameObject = new ButtonClass(scene, config);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var GetValue$b = Phaser.Utils.Objects.GetValue;
  var CreateButtons = function CreateButtons(scene, config, style) {
    // Title
    var titleStyle = GetValue$b(style, 'title') || {};
    var title = CreateTitleLabel(scene, config, titleStyle);

    // Buttons
    var buttonsConfig = config.buttons;
    var buttonStyle = GetValue$b(style, 'button') || {};
    var buttons = [];
    for (var i = 0, cnt = buttonsConfig.length; i < cnt; i++) {
      var button = CreateLabel(scene, buttonStyle);
      buttons.push(button);
      var buttonConfig = buttonsConfig[i];
      button.resetDisplayContent(buttonConfig.label);
      button.callback = buttonConfig.callback;
    }
    var buttonsSizer = CreateButtons$1(scene, {
      buttons: buttons,
      expand: true,
      wrap: GetValue$b(config, 'wrap', false)
    });
    buttonsSizer.defaultProportion = 1;

    // Background
    var backgroundStyle = GetValue$b(style, 'background') || {};
    var background = CreateRoundRectangle(scene, backgroundStyle);

    // InputRow
    var inputRow = new InputRow(scene, _objectSpread2(_objectSpread2({}, style), {}, {
      inputTitle: title,
      inputField: buttonsSizer,
      background: background
    }));
    scene.add.existing(inputRow);
    inputRow.setTitle(config);
    buttonsSizer.on('button.click', function (button) {
      button.callback(inputRow.bindingTarget);
    });
    return inputRow;
  };

  var GetValue$a = Phaser.Utils.Objects.GetValue;
  var AddButtons = function AddButtons(config) {
    var scene = this.scene;
    if (config === undefined) {
      config = {};
    }
    var target = config.bindingTarget;
    delete config.bindingTarget;

    // Create buttons
    var buttonsStyle = GetValue$a(this.styles, 'inputRow') || {};
    var buttons = CreateButtons(scene, config, buttonsStyle);

    // Add buttons
    this.add(buttons, {
      expand: true
    });

    // Set binding target
    if (target) {
      buttons.setBindingTarget(target);
    }
    if (config.key) {
      this.root.addChildrenMap(config.key, buttons);
    }
    return this;
  };

  var AddButton = function AddButton(config) {
    if (config === undefined) {
      config = {};
    }
    config.buttons = [{
      label: config.label,
      callback: config.callback
    }];
    delete config.label;
    delete config.callback;
    this.addButtons(config);
    return this;
  };

  var GetValue$9 = Phaser.Utils.Objects.GetValue;
  var AddSeparator = function AddSeparator(config) {
    var scene = this.scene;

    // Create separator
    var separatorStyle = GetValue$9(this.styles, 'separator');
    var separator = CreateBackground(scene, config, separatorStyle);

    // Add separator
    this.add(separator, {
      expand: true
    });
    return this;
  };

  var SetBindingTarget = function SetBindingTarget(target) {
    var children = this.sizerChildren;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (!child.setBindingTarget) {
        continue;
      }
      child.setBindingTarget(target);
    }
    return this;
  };

  var GetMaxInputRowTitleWidth = function GetMaxInputRowTitleWidth() {
    var maxTitleWidth = 0;
    var children = this.sizerChildren;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (child.rexSizer.hidden) {
        continue;
      }
      if (child.getMinTitleWidth) {
        // InputRow
        maxTitleWidth = Math.max(maxTitleWidth, child.getMinTitleWidth());
      } else if (child.getMaxInputRowTitleWidth) {
        // Folder, TabPages
        maxTitleWidth = Math.max(maxTitleWidth, child.getMaxInputRowTitleWidth());
      }
    }
    return maxTitleWidth + this.getInnerPadding('left');
  };

  var SetInputRowTitleWidth = function SetInputRowTitleWidth(width) {
    width -= this.getInnerPadding('left');
    var children = this.sizerChildren;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (child.rexSizer.hidden) {
        continue;
      }
      if (child.setMinTitleWidth) {
        // InputRow
        child.setMinTitleWidth(width);
      } else if (child.setInputRowTitleWidth) {
        // Folder, TabPages
        child.setInputRowTitleWidth(width);
      }
    }
    return this;
  };

  var methods$1 = {
    registerInputHandler: RegisterInputHandler,
    removeInputHandler: RemoveInputHandler,
    addFolder: AddFolder,
    addTab: AddTab,
    addInput: AddInput,
    addButtons: AddButtons,
    addButton: AddButton,
    addSeparator: AddSeparator,
    setBindingTarget: SetBindingTarget,
    getMaxInputRowTitleWidth: GetMaxInputRowTitleWidth,
    setInputRowTitleWidth: SetInputRowTitleWidth
  };

  var GetValue$8 = Phaser.Utils.Objects.GetValue;
  var TweakerShell = /*#__PURE__*/function (_Sizer) {
    _inherits(TweakerShell, _Sizer);
    function TweakerShell(scene, config) {
      var _this;
      _classCallCheck(this, TweakerShell);
      if (config === undefined) {
        config = {};
      }
      if (config.orientation === undefined) {
        config.orientation = 1;
      }

      // Create sizer
      _this = _callSuper(this, TweakerShell, [scene, config]);
      _this.type = 'rexTweakerShell';
      _this.root = config.root || _assertThisInitialized(_this);
      _this.styles = GetValue$8(config, 'styles') || {};
      _this.styles.orientation = _this.orientation;
      _this.itemWidth = GetValue$8(_this.styles, 'itemWidth', 0);
      if (_this.root === _assertThisInitialized(_this) && _this.orientation === 1) {
        var alignTitle = GetValue$8(config, 'inputRow.alignTitle');
        if (alignTitle === undefined) {
          var titleProportion = GetValue$8(_this.styles, 'inputRow.proportion.title');
          alignTitle = !titleProportion;
        } else {
          if (alignTitle) {
            // Override title proportion to 0
            SetValue(_this.styles, 'inputRow.proportion.title', 0);
          }
        }
        _this.alignInputRowTitle = alignTitle;
      } else {
        _this.alignInputRowTitle = false;
        _this.inputHandlers = _this.root.inputHandlers;
      }
      var background = CreateBackground(scene, undefined, config.background);
      if (background) {
        _this.addBackground(background);
      }
      return _this;
    }
    _createClass(TweakerShell, [{
      key: "preLayout",
      value: function preLayout() {
        _get(_getPrototypeOf(TweakerShell.prototype), "preLayout", this).call(this);
        if (this.alignInputRowTitle) {
          this.setInputRowTitleWidth(this.getMaxInputRowTitleWidth());
        }
      }
    }]);
    return TweakerShell;
  }(Sizer);
  Object.assign(TweakerShell.prototype, methods$1);

  Phaser.Utils.Objects.GetValue;
  Phaser.Math.Linear;
  Phaser.Math.Snap.Floor;

  Phaser.Utils.Objects.GetValue;

  var GetShowCallback$1 = function GetShowCallback() {
    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.setChildVisible(child, true);
      }
    };
  };
  var GetHideCallback$1 = function GetHideCallback() {
    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.setChildVisible(child, false);
      }
    };
  };
  var VisibleCallbacks = {
    show: GetShowCallback$1,
    hide: GetHideCallback$1
  };

  var GetShowCallback = function GetShowCallback(duration, alpha) {
    if (alpha === undefined) {
      alpha = 1;
    }
    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.fadeChild(child, reset ? 0 : duration, alpha);
      }
    };
  };
  var GetHideCallback = function GetHideCallback(duration, alpha) {
    if (alpha === undefined) {
      alpha = 0;
    }
    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.fadeChild(child, reset ? 0 : duration, alpha);
      }
    };
  };
  var FadeCallbacks = {
    show: GetShowCallback,
    hide: GetHideCallback
  };

  var GetCallback$1 = function GetCallback(duration, ease) {
    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.moveChild(child, reset ? 0 : duration, ease);
      }
    };
  };
  var MoveCallbacks = {
    show: GetCallback$1,
    hide: GetCallback$1
  };

  var GetCallback = function GetCallback(duration, ease) {
    return function (child, key, sides, reset) {
      if (key === 'panel') {
        sides.moveChild(child, reset ? 0 : duration, ease);
      }
    };
  };
  var MovePanelCallbacks = {
    show: GetCallback,
    hide: GetCallback
  };

  var DefaultCallbacks = {
    visible: VisibleCallbacks,
    fade: FadeCallbacks,
    move: MoveCallbacks,
    'move-panel': MovePanelCallbacks
  };
  var GetDefaultCallbacks = function GetDefaultCallbacks(config) {
    var callbackType, callbackParams;
    var _ref = typeof config === 'string' ? [config] : config;
    var _ref2 = _toArray(_ref);
    callbackType = _ref2[0];
    callbackParams = _ref2.slice(1);
    var showCallback, hideCallback;
    if (DefaultCallbacks.hasOwnProperty(callbackType)) {
      showCallback = DefaultCallbacks[callbackType].show.apply(null, callbackParams);
      hideCallback = DefaultCallbacks[callbackType].hide.apply(null, callbackParams);
    } else {
      showCallback = NOOP;
      hideCallback = NOOP;
    }
    return {
      show: showCallback,
      hide: hideCallback
    };
  };

  var ShowChildMethods = {
    showChild: function showChild(key, reset) {
      var child = this.sizerChildren[key];
      if (child) {
        this.emit('showchild', child, key, this, reset);
        this.resetChildState(child);
      }
      return this;
    },
    hideChild: function hideChild(key, reset) {
      var child = this.sizerChildren[key];
      if (child) {
        this.emit('hidechild', child, key, this, reset);
        this.resetChildState(child);
      }
      return this;
    },
    swapChild: function swapChild(key, reset) {
      if (this.currentChildKey === key) ; else if (this.currentChildKey === 'panel' || key === 'panel') {
        this.previousChildKey = this.currentChildKey;
        this.currentChildKey = key;
        this.hideChild(this.previousChildKey, reset);
        this.showChild(this.currentChildKey, reset);
      } else {
        // Swap from current side to another side
        this.swapChild('panel', reset);
        this.swapChild(key, reset);
      }
      return this;
    },
    showPanel: function showPanel(reset) {
      this.swapChild('panel', reset);
      return this;
    },
    showLeftSide: function showLeftSide() {
      this.swapChild('leftSide');
      return this;
    },
    showRightSide: function showRightSide() {
      this.swapChild('rightSide');
      return this;
    },
    showTopSide: function showTopSide() {
      this.swapChild('topSide');
      return this;
    },
    showBottomSide: function showBottomSide() {
      this.swapChild('bottomSide');
      return this;
    },
    hideLeftSide: function hideLeftSide() {
      if (this.currentChildKey == 'leftSide') {
        this.showPanel();
      }
      return this;
    },
    hideRightSide: function hideRightSide() {
      if (this.currentChildKey == 'rightSide') {
        this.showPanel();
      }
      return this;
    },
    hideTopSide: function hideTopSide() {
      if (this.currentChildKey == 'topSide') {
        this.showPanel();
      }
      return this;
    },
    hideBottomSide: function hideBottomSide() {
      if (this.currentChildKey == 'bottomSide') {
        this.showPanel();
      }
      return this;
    },
    toggleLeftSide: function toggleLeftSide() {
      var key = this.currentChildKey !== 'panel' ? 'panel' : 'leftSide';
      this.swapChild(key);
      return this;
    },
    toggleRightSide: function toggleRightSide() {
      var key = this.currentChildKey !== 'panel' ? 'panel' : 'rightSide';
      this.swapChild(key);
      return this;
    },
    toggleTopSide: function toggleTopSide() {
      var key = this.currentChildKey !== 'panel' ? 'panel' : 'topSide';
      this.swapChild(key);
      return this;
    },
    toggleBottomSide: function toggleBottomSide() {
      var key = this.currentChildKey !== 'panel' ? 'panel' : 'bottomSide';
      this.swapChild(key);
      return this;
    }
  };

  var ContainerSetChildVisible = ContainerLite.prototype.setChildVisible;
  var Visible = {
    setChildVisible: function setChildVisible(child, visible) {
      var key;
      if (typeof child === 'string') {
        var key = child;
        child = this.sizerChildren[key];
      } else {
        key = IndexOf(this.sizerChildren, child);
      }
      if (visible === undefined) {
        visible = this.currentChildKey === key ? true : false;
      }
      ContainerSetChildVisible.call(this, child, visible);
      return this;
    }
  };

  var Fade = {
    fadeChild: function fadeChild(child, duration, alpha) {
      var key;
      if (typeof child === 'string') {
        key = child;
        child = this.sizerChildren[key];
      } else {
        key = IndexOf(this.sizerChildren, child);
      }
      if (duration === undefined) {
        duration = 500;
      }
      if (alpha === undefined) {
        alpha = this.currentChildKey === key ? 1 : 0;
      }
      child.fadeIn(duration, {
        start: child.alpha,
        end: alpha
      });
      return this;
    },
    fadeChildPromise: function fadeChildPromise(child, duration, alpha) {
      if (typeof child === 'string') {
        child = this.sizerChildren[key];
      }
      this.fadeChild(child, duration, alpha);
      if (child._fade) {
        return WaitComplete(child._fade);
      } else {
        return Promise.resolve();
      }
    }
  };

  var Move = {
    moveChild: function moveChild(child, duration, ease, distance) {
      var key;
      if (typeof child === 'string') {
        key = child;
        child = this.sizerChildren[key];
      } else {
        key = IndexOf(this.sizerChildren, child);
      }
      if (duration === undefined) {
        duration = 500;
      }
      var isShownChild = this.currentChildKey === key;
      if (distance === undefined) {
        switch (key) {
          case 'leftSide':
          case 'rightSide':
            distance = GetDisplayWidth(child);
            break;
          case 'topSide':
          case 'bottomSide':
            distance = GetDisplayHeight(child);
            break;
          default:
            // 'panel'
            if (isShownChild) {
              // Show panel
              switch (this.previousChildKey) {
                case 'leftSide':
                case 'rightSide':
                  distance = GetDisplayWidth(this.sizerChildren[this.previousChildKey]);
                  break;
                case 'topSide':
                case 'bottomSide':
                  distance = GetDisplayHeight(this.sizerChildren[this.previousChildKey]);
                  break;
                default:
                  distance = 0;
                  break;
              }
            } else {
              // Hide panel
              switch (this.currentChildKey) {
                case 'leftSide':
                case 'rightSide':
                  distance = GetDisplayWidth(this.sizerChildren[this.currentChildKey]);
                  break;
                case 'topSide':
                case 'bottomSide':
                  distance = GetDisplayHeight(this.sizerChildren[this.currentChildKey]);
                  break;
                default:
                  distance = 0;
                  break;
              }
            }
            break;
        }
      }
      var moveLeft, moveRight, moveUp, moveDown;
      if (isShownChild) {
        switch (key) {
          case 'panel':
            switch (this.previousChildKey) {
              case 'leftSide':
                moveLeft = true;
                break;
              case 'rightSide':
                moveRight = true;
                break;
              case 'topSide':
                moveUp = true;
                break;
              case 'bottomSide':
                moveDown = true;
                break;
            }
            break;
          case 'leftSide':
            moveRight = true;
            break;
          case 'rightSide':
            moveLeft = true;
            break;
          case 'topSide':
            moveDown = true;
            break;
          case 'bottomSide':
            moveUp = true;
            break;
        }
      } else {
        // Hide
        switch (key) {
          case 'panel':
            switch (this.currentChildKey) {
              case 'leftSide':
                moveRight = true;
                break;
              case 'rightSide':
                moveLeft = true;
                break;
              case 'topSide':
                moveDown = true;
                break;
              case 'bottomSide':
                moveUp = true;
                break;
            }
            break;
          case 'leftSide':
            moveLeft = true;
            break;
          case 'rightSide':
            moveRight = true;
            break;
          case 'topSide':
            moveUp = true;
            break;
          case 'bottomSide':
            moveDown = true;
            break;
        }
      }
      if (moveLeft) {
        child.moveTo(duration, "-=".concat(distance), undefined, ease);
      } else if (moveRight) {
        child.moveTo(duration, "+=".concat(distance), undefined, ease);
      } else if (moveUp) {
        child.moveTo(duration, undefined, "-=".concat(distance), ease);
      } else if (moveDown) {
        child.moveTo(duration, undefined, "+=".concat(distance), ease);
      } else {
        child.moveTo(0);
      }
      return this;
    },
    moveChildPromise: function moveChildPromise(child, duration, ease, distance) {
      if (typeof child === 'string') {
        child = this.sizerChildren[key];
      }
      this.moveChild(child, duration, ease, distance);
      if (child._easeMove) {
        return WaitComplete(child._easeMove);
      } else {
        return Promise.resolve();
      }
    }
  };

  var methods = {};
  Object.assign(methods, Visible, Fade, Move);

  var GetValue$7 = Phaser.Utils.Objects.GetValue;
  var Sides = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(Sides, _OverlapSizer);
    function Sides(scene, config) {
      var _this;
      _classCallCheck(this, Sides);
      _this = _callSuper(this, Sides, [scene, config]);
      _this.type = 'rexSides';
      _this.childrenMap = _this.sizerChildren;
      _this.previousChildKey = undefined;
      _this.currentChildKey = undefined;

      // Callbacks
      var showChildCallback = GetValue$7(config, 'showChildCallback', undefined);
      if (showChildCallback) {
        // Has showChildCallback, and hideChildCallback
        if (IsFunction(showChildCallback)) {
          // Custom callbacks
          var showChildCallbackScope = GetValue$7(config, 'showChildCallbackScope', undefined);
          _this.on('showchild', showChildCallback, showChildCallbackScope);
          var hideChildCallback = GetValue$7(config, 'hideChildCallback', undefined);
          var hideChildCallbackScope = GetValue$7(config, 'hideChildCallbackScope', undefined);
          _this.on('hidechild', hideChildCallback, hideChildCallbackScope);
        } else {
          // Default callbacks
          var defaultCallbacks = GetDefaultCallbacks(showChildCallback);
          _this.on('showchild', defaultCallbacks.show);
          _this.on('hidechild', defaultCallbacks.hide);
        }
      }

      // Add elements
      var background = GetValue$7(config, 'background', undefined);
      var panel = GetValue$7(config, 'panel', undefined);
      var leftSide = GetValue$7(config, 'leftSide', undefined);
      var rightSide = GetValue$7(config, 'rightSide', undefined);
      var topSide = GetValue$7(config, 'topSide', undefined);
      var bottomSide = GetValue$7(config, 'bottomSide', undefined);
      if (background) {
        _this.addBackground(background);
      }
      if (panel) {
        _this.add(panel, 'panel', 'center', 0, true);
      }
      if (leftSide) {
        var expand = GetValue$7(config, 'expand.left', true);
        _this.add(leftSide, 'leftSide', 'left-top', 0, {
          height: expand
        });
      }
      if (rightSide) {
        var expand = GetValue$7(config, 'expand.right', true);
        _this.add(rightSide, 'rightSide', 'right-top', 0, {
          height: expand
        });
      }
      if (topSide) {
        var expand = GetValue$7(config, 'expand.top', true);
        _this.add(topSide, 'topSide', 'left-top', 0, {
          width: expand
        });
      }
      if (bottomSide) {
        var expand = GetValue$7(config, 'expand.bottom', true);
        _this.add(bottomSide, 'bottomSide', 'left-bottom', 0, {
          width: expand
        });
      }
      return _this;
    }
    _createClass(Sides, [{
      key: "reset",
      value: function reset() {
        this.previousChildKey = undefined;
        this.currentChildKey = 'panel';
        this.showChild('panel', true);
        this.hideChild('leftSide', true);
        this.hideChild('rightSide', true);
        this.hideChild('topSide', true);
        this.hideChild('bottomSide', true);
        return this;
      }
    }]);
    return Sides;
  }(OverlapSizer);
  Object.assign(Sides.prototype, ShowChildMethods, methods);

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;

  Phaser.Utils.Objects.GetValue;
  Phaser.Utils.Objects.GetAdvancedValue;
  Phaser.Math.Linear;

  Phaser.Math.RotateAround;

  Phaser.Geom.Mesh.Vertex;
  Phaser.Geom.Mesh.Face;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;
  Phaser.Math.DegToRad;
  Phaser.Math.RadToDeg;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;

  var LastOpenedEditor = undefined;
  var SetLastOpenedEditor = function SetLastOpenedEditor(editor) {
    if (editor === LastOpenedEditor) {
      return;
    }
    if (LastOpenedEditor !== undefined) {
      LastOpenedEditor.close();
    }
    LastOpenedEditor = editor;
  };
  var CloseLastOpenEditor = function CloseLastOpenEditor(editor) {
    if (editor !== LastOpenedEditor) {
      return;
    }

    // Don't call `LastOpenedEditor.close()`
    LastOpenedEditor = undefined;
  };

  var GetValue$6 = Phaser.Utils.Objects.GetValue;
  var Clone = Phaser.Utils.Objects.Clone;
  var CreateInputText = function CreateInputText(text, config) {
    if (config === undefined) {
      config = {};
    }
    config = Clone(config);
    var scene = text.scene;
    var style = text.style;
    var backgroundColor = GetValue$6(config, 'backgroundColor', style.backgroundColor);
    if (backgroundColor === null) {
      backgroundColor = 'transparent';
    }
    config.text = GetValue$6(config, 'text', text.text);
    config.fontFamily = GetValue$6(config, 'fontFamily', style.fontFamily);
    config.fontSize = GetValue$6(config, 'fontSize', style.fontSize);
    config.color = GetValue$6(config, 'color', style.color);
    config.backgroundColor = backgroundColor;
    config.direction = GetValue$6(config, 'rtl', style.rtl) ? 'rtl' : 'ltr';
    config.align = GetValue$6(config, 'align', GetHAlign(style));

    // Built-in text game object with RTL only has 'right' align
    if (config.direction === 'rtl' && IsTextGameObject(text)) {
      config.align = 'right';
    }

    // config.paddingLeft = 0;
    // config.paddingRight = 0;
    // config.paddingTop = 0;
    // config.paddingBottom = 0;
    // var valign = GetVAlign(style);
    // switch (valign) {
    //     case 'top':
    //         break;
    //     case 'bottom':
    //         break;
    // }

    var inputText = new InputText(scene, text.x, text.y, GetValue$6(config, 'width', text.width), GetValue$6(config, 'height', text.height), config);
    inputText
    // Sync scale
    .setScale(text.scaleX, text.scaleY)
    // Sync origin
    .setOrigin(text.originX, text.originY)
    // Sync scrollFactor
    .setScrollFactor(text.scrollFactorX, text.scrollFactorY);
    var textParentContainer = text.parentContainer;
    if (!textParentContainer) {
      scene.add.existing(inputText);
    } else {
      textParentContainer.add(inputText);
    }
    return inputText;
  };
  var GetHAlign = function GetHAlign(style) {
    if (style.hasOwnProperty('align')) {
      return style.align;
    } else if (style.hasOwnProperty('halign')) {
      return style.halign;
    } else {
      return 'left';
    }
  };

  var NextTick = function NextTick(scene, callback, scope) {
    return scene.time.delayedCall(0, callback, [], scope);
  };

  var GetValue$5 = Phaser.Utils.Objects.GetValue;
  var Merge = Phaser.Utils.Objects.Merge;
  var Open = function Open(config, onCloseCallback) {
    if (config === undefined) {
      config = {};
    }
    config = Merge(config, this.openConfig);
    SetLastOpenedEditor(this);
    if (IsFunction(config)) {
      onCloseCallback = config;
      config = undefined;
    }
    var textType = GetValue$5(config, 'inputType', undefined);
    if (textType === undefined) {
      textType = GetValue$5(config, 'type', 'text');
    }
    if (onCloseCallback === undefined) {
      onCloseCallback = GetValue$5(config, 'onClose', undefined);
    }
    var onOpenCallback = GetValue$5(config, 'onOpen', undefined);
    var customOnTextChanged = GetValue$5(config, 'onTextChanged', undefined);
    this.inputText = CreateInputText(this.parent, config).on('textchange', function (inputText) {
      var text = inputText.text;
      if (customOnTextChanged) {
        // Custom on-text-changed callback
        customOnTextChanged(this.parent, text);
      } else {
        // Default on-text-changed callback
        this.parent.text = text;
      }
    }, this).setFocus();
    this.parent.setVisible(false); // Set parent text invisible

    // Attach close event
    this.onClose = onCloseCallback;
    if (GetValue$5(config, 'enterClose', textType !== 'textarea')) {
      this.scene.input.keyboard.once('keydown-ENTER', this.close, this);
    }
    // Attach pointerdown (outside of input-text) event, at next tick
    this.delayCall = NextTick(this.scene, function () {
      this.scene.input.once('pointerdown', this.close, this);

      // Open editor completly, invoke onOpenCallback
      if (onOpenCallback) {
        onOpenCallback(this.parent);
      }
      this.emit('open', this.parent);
    }, this);
    return this;
  };

  var Close = function Close() {
    CloseLastOpenEditor(this);
    this.parent.setVisible(true); // Set parent text visible

    if (this.inputText) {
      this.inputText.destroy();
      this.inputText = undefined;
    }
    if (this.delayCall) {
      this.delayCall.remove();
      this.delayCall = undefined;
    }

    // Remove close event
    this.scene.input.keyboard.off('keydown-ENTER', this.close, this);
    this.scene.input.off('pointerdown', this.close, this);
    if (this.onClose) {
      this.onClose(this.parent);
    }
    this.emit('close', this.parent);
    return this;
  };

  var Methods = {
    open: Open,
    close: Close
  };

  var GetValue$4 = Phaser.Utils.Objects.GetValue;
  var TextEdit = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TextEdit, _ComponentBase);
    function TextEdit(gameObject, config) {
      var _this;
      _classCallCheck(this, TextEdit);
      _this = _callSuper(this, TextEdit, [gameObject]);
      // this.parent = gameObject;

      _this.inputText = undefined;
      _this.onClose = undefined;
      _this.delayCall = undefined;
      _this.setOpenConfig(config);
      var clickEnable = GetValue$4(config, 'clickEnable', true);
      if (clickEnable) {
        gameObject.on('pointerdown', function () {
          this.open();
        }, _assertThisInitialized(_this)).setInteractive();
      }
      return _this;
    }
    _createClass(TextEdit, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }
        this.close();
        _get(_getPrototypeOf(TextEdit.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "setOpenConfig",
      value: function setOpenConfig(config) {
        if (config === undefined) {
          config = {};
        }
        this.openConfig = config;
        return this;
      }
    }, {
      key: "isOpened",
      get: function get() {
        return this.inputText !== undefined;
      }
    }, {
      key: "text",
      get: function get() {
        return this.isOpened ? this.inputText.text : this.parent.text;
      }
    }]);
    return TextEdit;
  }(ComponentBase);
  Object.assign(TextEdit.prototype, Methods);

  Phaser.Utils.Objects.GetValue;

  var GetValue$3 = Phaser.Utils.Objects.GetValue;
  var RegisterBackgroundType = function RegisterBackgroundType(commandExecutor, config) {
    var createGameObjectCallback = GetValue$3(config, "creators.".concat(BG), DefaultCreateGameObjectCallback$1);
    if (createGameObjectCallback === false) {
      return;
    }
    commandExecutor.addGameObjectManager({
      name: BG,
      createGameObject: createGameObjectCallback,
      fade: 0,
      // No fade-in when creating/destroying gameobject
      viewportCoordinate: true,
      defaultLayer: BGLayer,
      commands: {
        cross: function cross(gameObject) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            key = _ref.key,
            frame = _ref.frame,
            duration = _ref.duration,
            _ref$mode = _ref.mode,
            mode = _ref$mode === void 0 ? 'fade' : _ref$mode,
            _ref$wait = _ref.wait,
            wait = _ref$wait === void 0 ? true : _ref$wait;
          var commandExecutor = arguments.length > 2 ? arguments[2] : undefined;
          // Wait until transition complete
          if (wait) {
            commandExecutor.waitEvent(gameObject, 'complete');
          }
          var durationSave = gameObject.duration;
          if (duration !== undefined) {
            gameObject.setDuration(duration);
          }
          gameObject.transit(key, frame, mode);
          gameObject.setDuration(durationSave);
        }
      }
    });
  };
  var DefaultCreateGameObjectCallback$1 = function DefaultCreateGameObjectCallback(scene, config) {
    var gameObject = new TransitionImagePack(scene, config);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var GetValue$2 = Phaser.Utils.Objects.GetValue;
  var RegisterSpriteType = function RegisterSpriteType(commandExecutor, config) {
    var createGameObjectCallback = GetValue$2(config, "creators.".concat(SPRITE), DefaultCreateGameObjectCallback);
    if (createGameObjectCallback === false) {
      return;
    }
    commandExecutor.addGameObjectManager({
      name: SPRITE,
      createGameObject: createGameObjectCallback,
      fade: 0,
      // No fade-in when creating/destroying gameobject
      viewportCoordinate: true,
      defaultLayer: GOLayer,
      commands: {
        cross: function cross(gameObject) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            key = _ref.key,
            frame = _ref.frame;
          gameObject.setTexture(key, frame);
        }
      }
    });
  };
  var DefaultCreateGameObjectCallback = function DefaultCreateGameObjectCallback(scene) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      key = _ref2.key,
      frame = _ref2.frame;
    return scene.add.image(0, 0, key, frame);
  };

  var GetValue$1 = Phaser.Utils.Objects.GetValue;
  var RegisterTextboxType = function RegisterTextboxType(commandExecutor, config) {
    var createGameObjectCallback = GetValue$1(config, "creators.".concat(TEXT), undefined);
    if (createGameObjectCallback === false) {
      return;
    } else if (createGameObjectCallback === undefined) {
      var style = GetValue$1(config, "styles.".concat(TEXT));
      createGameObjectCallback = GenerateDefaultCreateGameObjectCallback$1(style);
    }
    commandExecutor.addGameObjectManager({
      name: TEXT,
      createGameObject: createGameObjectCallback,
      fade: 0,
      // No fade-in when creating/destroying gameobject
      viewportCoordinate: true,
      defaultLayer: UILayer,
      commands: {
        typing: function typing(gameObject) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            name = _ref.name,
            text = _ref.text,
            speed = _ref.speed;
          var commandExecutor = arguments.length > 2 ? arguments[2] : undefined;
          if (name) {
            var title = gameObject.getElement('title').setText(name);
            gameObject.setChildAlpha(title, 1);
          } else {
            var title = gameObject.getElement('title').setText('');
            gameObject.setChildAlpha(title, 0);
          }
          gameObject.layout();

          // Wait until typing complete
          commandExecutor.waitEvent(gameObject, 'complete');
          gameObject.start(text, speed);
        }
      }
    });
  };
  var GenerateDefaultCreateGameObjectCallback$1 = function GenerateDefaultCreateGameObjectCallback() {
    var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (scene) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$width = _ref2.width,
        width = _ref2$width === void 0 ? 0 : _ref2$width,
        _ref2$height = _ref2.height,
        height = _ref2$height === void 0 ? 0 : _ref2$height;
      var wrapWidth = Math.max(0, width - 20);
      SetValue(style, 'text.fixedWidth', width);
      SetValue(style, 'text.fixedHeight', height);
      SetValue(style, 'text.wordWrap.width', wrapWidth);
      var textBox = new SimpleTextBox(scene, style);
      textBox.setMinSize(width, height).setOrigin(0.5, 1).layout();
      scene.add.existing(textBox);
      textBox.setInteractive().on('pointerdown', function () {
        var icon = this.getElement('action');
        this.setChildAlpha(icon, 0);
        if (this.isTyping) {
          this.stop(true);
        } else {
          this.typeNextPage();
        }
      }, textBox).on('pageend', function () {
        if (this.isLastPage) {
          return;
        }
        var icon = this.getElement('action');
        this.setChildAlpha(icon, 1);
        icon.y -= 30;
        scene.tweens.add({
          targets: icon,
          y: '+=30',
          // '+=100'
          ease: 'Bounce',
          // 'Cubic', 'Elastic', 'Bounce', 'Back'
          duration: 500,
          repeat: 0,
          // -1: infinity
          yoyo: false
        });
      }, textBox);
      return textBox;
    };
  };

  var GetValue = Phaser.Utils.Objects.GetValue;
  var RegisterChoiceDialogType = function RegisterChoiceDialogType(commandExecutor, config) {
    var createGameObjectCallback = GetValue(config, "creators.".concat(CHOICE), undefined);
    if (createGameObjectCallback === false) {
      return;
    } else if (createGameObjectCallback === undefined) {
      var style = GetValue(config, "styles.".concat(CHOICE));
      createGameObjectCallback = GenerateDefaultCreateGameObjectCallback(style);
    }
    commandExecutor.addGameObjectManager({
      name: CHOICE,
      createGameObject: createGameObjectCallback,
      fade: 0,
      // No fade-in when creating/destroying gameobject
      viewportCoordinate: true,
      defaultLayer: UILayer,
      commands: {
        choice: function choice(gameObject) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$title = _ref.title,
            title = _ref$title === void 0 ? null : _ref$title,
            _ref$content = _ref.content,
            content = _ref$content === void 0 ? null : _ref$content,
            option1 = _ref.option1,
            option2 = _ref.option2,
            option3 = _ref.option3,
            _ref$resultKey = _ref.resultKey,
            resultKey = _ref$resultKey === void 0 ? 'choiceIndex' : _ref$resultKey;
          var commandExecutor = arguments.length > 2 ? arguments[2] : undefined;
          var eventSheetManager = arguments.length > 3 ? arguments[3] : undefined;
          var choices = [];
          if (option1) {
            choices.push({
              text: option1,
              value: 1
            });
          }
          if (option2) {
            choices.push({
              text: option2,
              value: 2
            });
          }
          if (option3) {
            choices.push({
              text: option3,
              value: 3
            });
          }
          var displayContent = {
            title: title,
            content: content,
            choices: choices
          };
          gameObject.setVisible(true).resetDisplayContent(displayContent).layout();
          commandExecutor.waitEvent(gameObject, 'complete');
          gameObject.modalPromise({
            destroy: false
          }).then(function (data) {
            eventSheetManager.setData(resultKey, data.value);
            gameObject.emit('complete');
          });
        }
      }
    });
  };
  var GenerateDefaultCreateGameObjectCallback = function GenerateDefaultCreateGameObjectCallback(style) {
    return function (scene) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$width = _ref2.width,
        width = _ref2$width === void 0 ? 0 : _ref2$width,
        _ref2$height = _ref2.height,
        height = _ref2$height === void 0 ? 0 : _ref2$height;
      var dialog = new ConfirmDialog(scene, style);
      dialog.setMinSize(width, height).setVisible(false);
      scene.add.existing(dialog);
      return dialog;
    };
  };

  var RegisterHandlers = [RegisterBackgroundType, RegisterSpriteType, RegisterTextboxType, RegisterChoiceDialogType];
  var CreateCommandExecutor = function CreateCommandExecutor(scene, config) {
    var layerDepth = config.layerDepth;
    var commandExecutor = new CommandExecutor(scene, {
      layers: LayerNames,
      layerDepth: layerDepth
    });
    for (var i = 0, cnt = RegisterHandlers.length; i < cnt; i++) {
      RegisterHandlers[i](commandExecutor, config);
    }
    return commandExecutor;
  };

  var MarkdownVisualNovel = /*#__PURE__*/function (_MarkedEventSheets) {
    _inherits(MarkdownVisualNovel, _MarkedEventSheets);
    function MarkdownVisualNovel(scene) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, MarkdownVisualNovel);
      config.commandExecutor = CreateCommandExecutor(scene, config);
      return _callSuper(this, MarkdownVisualNovel, [config]); // this.commandExecutor;
    }
    return _createClass(MarkdownVisualNovel);
  }(MarkedEventSheets);

  return MarkdownVisualNovel;

}));
