(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.rexmdscenario = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var eventemitter3 = {exports: {}};

	(function (module) {

		var has = Object.prototype.hasOwnProperty
		  , prefix = '~';

		/**
		 * Constructor to create a storage for our `EE` objects.
		 * An `Events` instance is a plain object whose properties are event names.
		 *
		 * @constructor
		 * @private
		 */
		function Events() {}

		//
		// We try to not inherit from `Object.prototype`. In some engines creating an
		// instance in this way is faster than calling `Object.create(null)` directly.
		// If `Object.create(null)` is not supported we prefix the event names with a
		// character to make sure that the built-in object properties are not
		// overridden or used as an attack vector.
		//
		if (Object.create) {
		  Events.prototype = Object.create(null);

		  //
		  // This hack is needed because the `__proto__` property is still inherited in
		  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
		  //
		  if (!new Events().__proto__) prefix = false;
		}

		/**
		 * Representation of a single event listener.
		 *
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
		 * @constructor
		 * @private
		 */
		function EE(fn, context, once) {
		  this.fn = fn;
		  this.context = context;
		  this.once = once || false;
		}

		/**
		 * Add a listener for a given event.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} once Specify if the listener is a one-time listener.
		 * @returns {EventEmitter}
		 * @private
		 */
		function addListener(emitter, event, fn, context, once) {
		  if (typeof fn !== 'function') {
		    throw new TypeError('The listener must be a function');
		  }

		  var listener = new EE(fn, context || emitter, once)
		    , evt = prefix ? prefix + event : event;

		  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		  else emitter._events[evt] = [emitter._events[evt], listener];

		  return emitter;
		}

		/**
		 * Clear event by name.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} evt The Event name.
		 * @private
		 */
		function clearEvent(emitter, evt) {
		  if (--emitter._eventsCount === 0) emitter._events = new Events();
		  else delete emitter._events[evt];
		}

		/**
		 * Minimal `EventEmitter` interface that is molded against the Node.js
		 * `EventEmitter` interface.
		 *
		 * @constructor
		 * @public
		 */
		function EventEmitter() {
		  this._events = new Events();
		  this._eventsCount = 0;
		}

		/**
		 * Return an array listing the events for which the emitter has registered
		 * listeners.
		 *
		 * @returns {Array}
		 * @public
		 */
		EventEmitter.prototype.eventNames = function eventNames() {
		  var names = []
		    , events
		    , name;

		  if (this._eventsCount === 0) return names;

		  for (name in (events = this._events)) {
		    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		  }

		  if (Object.getOwnPropertySymbols) {
		    return names.concat(Object.getOwnPropertySymbols(events));
		  }

		  return names;
		};

		/**
		 * Return the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Array} The registered listeners.
		 * @public
		 */
		EventEmitter.prototype.listeners = function listeners(event) {
		  var evt = prefix ? prefix + event : event
		    , handlers = this._events[evt];

		  if (!handlers) return [];
		  if (handlers.fn) return [handlers.fn];

		  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
		    ee[i] = handlers[i].fn;
		  }

		  return ee;
		};

		/**
		 * Return the number of listeners listening to a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Number} The number of listeners.
		 * @public
		 */
		EventEmitter.prototype.listenerCount = function listenerCount(event) {
		  var evt = prefix ? prefix + event : event
		    , listeners = this._events[evt];

		  if (!listeners) return 0;
		  if (listeners.fn) return 1;
		  return listeners.length;
		};

		/**
		 * Calls each of the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Boolean} `true` if the event had listeners, else `false`.
		 * @public
		 */
		EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return false;

		  var listeners = this._events[evt]
		    , len = arguments.length
		    , args
		    , i;

		  if (listeners.fn) {
		    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

		    switch (len) {
		      case 1: return listeners.fn.call(listeners.context), true;
		      case 2: return listeners.fn.call(listeners.context, a1), true;
		      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
		      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
		      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
		      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
		    }

		    for (i = 1, args = new Array(len -1); i < len; i++) {
		      args[i - 1] = arguments[i];
		    }

		    listeners.fn.apply(listeners.context, args);
		  } else {
		    var length = listeners.length
		      , j;

		    for (i = 0; i < length; i++) {
		      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

		      switch (len) {
		        case 1: listeners[i].fn.call(listeners[i].context); break;
		        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
		        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
		        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
		        default:
		          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
		            args[j - 1] = arguments[j];
		          }

		          listeners[i].fn.apply(listeners[i].context, args);
		      }
		    }
		  }

		  return true;
		};

		/**
		 * Add a listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.on = function on(event, fn, context) {
		  return addListener(this, event, fn, context, false);
		};

		/**
		 * Add a one-time listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.once = function once(event, fn, context) {
		  return addListener(this, event, fn, context, true);
		};

		/**
		 * Remove the listeners of a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn Only remove the listeners that match this function.
		 * @param {*} context Only remove the listeners that have this context.
		 * @param {Boolean} once Only remove one-time listeners.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return this;
		  if (!fn) {
		    clearEvent(this, evt);
		    return this;
		  }

		  var listeners = this._events[evt];

		  if (listeners.fn) {
		    if (
		      listeners.fn === fn &&
		      (!once || listeners.once) &&
		      (!context || listeners.context === context)
		    ) {
		      clearEvent(this, evt);
		    }
		  } else {
		    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
		      if (
		        listeners[i].fn !== fn ||
		        (once && !listeners[i].once) ||
		        (context && listeners[i].context !== context)
		      ) {
		        events.push(listeners[i]);
		      }
		    }

		    //
		    // Reset the array, or remove it completely if we have no more listeners.
		    //
		    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
		    else clearEvent(this, evt);
		  }

		  return this;
		};

		/**
		 * Remove all listeners, or those of the specified event.
		 *
		 * @param {(String|Symbol)} [event] The event name.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
		  var evt;

		  if (event) {
		    evt = prefix ? prefix + event : event;
		    if (this._events[evt]) clearEvent(this, evt);
		  } else {
		    this._events = new Events();
		    this._eventsCount = 0;
		  }

		  return this;
		};

		//
		// Alias methods names because people roll like that.
		//
		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
		EventEmitter.prototype.addListener = EventEmitter.prototype.on;

		//
		// Expose the prefix.
		//
		EventEmitter.prefixed = prefix;

		//
		// Allow `EventEmitter` to be imported as module namespace.
		//
		EventEmitter.EventEmitter = EventEmitter;

		//
		// Expose the module.
		//
		{
		  module.exports = EventEmitter;
		} 
	} (eventemitter3));

	var eventemitter3Exports = eventemitter3.exports;
	var EE = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

	let EventEmitter$2 = class EventEmitter extends EE {
	    shutdown() {
	        this.removeAllListeners();
	    }
	    destroy() {
	        this.removeAllListeners();
	    }
	};

	var IsPlainObject$B = function (obj)
	{
	    // Not plain objects:
	    // - Any object or value whose internal [[Class]] property is not "[object Object]"
	    // - DOM nodes
	    // - window
	    if (typeof(obj) !== 'object' || obj.nodeType || obj === obj.window)
	    {
	        return false;
	    }

	    // Support: Firefox <20
	    // The try/catch suppresses exceptions thrown when attempting to access
	    // the "constructor" property of certain host objects, ie. |window.location|
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
	    try
	    {
	        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))
	        {
	            return false;
	        }
	    }
	    catch (e)
	    {
	        return false;
	    }

	    // If the function hasn't returned already, we're confident that
	    // |obj| is a plain object, created by {} or constructed with new Object
	    return true;
	};

	const IDLE$7 = 0;
	const SUCCESS$1 = 1;
	const FAILURE = 2;
	const RUNNING$1 = 3;
	const ABORT = 5;
	const ERROR$1 = 9;

	const TREE = 'tree';
	const COMPOSITE = 'composite';
	const DECORATOR = 'decorator';
	const ACTION = 'action';
	const SERVICE = 'service';

	const TREE_STATE = '$state';

	/**
	 * @author       Richard Davey <rich@photonstorm.com>
	 * @copyright    2020 Photon Storm Ltd.
	 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
	 */

	/**
	 * Creates and returns an RFC4122 version 4 compliant UUID.
	 * 
	 * The string is in the form: `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx` where each `x` is replaced with a random
	 * hexadecimal digit from 0 to f, and `y` is replaced with a random hexadecimal digit from 8 to b.
	 *
	 * @function Phaser.Utils.String.UUID
	 * @since 3.12.0
	 *
	 * @return {string} The UUID string.
	 */
	const HasBuiltRandomUUID = (window.crypto && window.crypto.randomUUID);

	var UUID$3 = function () {
	    if (HasBuiltRandomUUID) {
	        return window.crypto.randomUUID();
	    }

	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	        var r = Math.random() * 16 | 0;
	        var v = (c === 'x') ? r : (r & 0x3 | 0x8);

	        return v.toString(16);
	    });
	};

	var sn = null;
	var snPrefix = '#';

	var SetSerialNumber = function (value) {
	    if (value === undefined) {
	        value = null;
	    }

	    sn = value;
	};

	var SetSerialNumberPrefix = function (prefix) {
	    snPrefix = prefix;
	};

	var GetSerialNumber = function () {
	    return sn;
	};

	var CreateID = function () {
	    if (sn === null) {
	        return UUID$3();
	    }

	    sn += 1;
	    return `${snPrefix}${sn}`;
	};

	var DataMethods$5 = {

	    getTreeMemory(blackboard) {
	        return blackboard.getTreeMemory(this.id);
	    },

	    getData(blackboard, key) {
	        return blackboard.get(key, this.id);
	    },

	    setData(blackboard, key, value) {
	        blackboard.set(key, value, this.id);
	        return this;
	    },

	    getState(blackboard) {
	        return this.getData(blackboard, TREE_STATE);
	    },

	    resetState(blackboard) {
	        this.setData(blackboard, TREE_STATE, IDLE$7);
	        return this;
	    },

	};

	var BreadthFirstSearch$1 = function (root, callback, scope) {
	    var queue = [root];
	    while (queue.length > 0) {
	        var current = queue.shift();
	        var skip = callback.call(scope, current);

	        if (skip) {
	            continue;
	        }

	        switch (current.category) {
	            case COMPOSITE:
	                queue.push(...current.children);

	                var services = current.services;
	                if (services) {
	                    queue.push(...services);
	                }
	                break;

	            case DECORATOR:
	                queue.push(current.child);
	                break;

	            case ACTION:
	                var services = current.services;
	                if (services) {
	                    queue.push(...services);
	                }
	                break;
	        }
	    }
	};

	function DeepClone(obj) {
	    if (obj === null || typeof obj !== 'object') {
	        // If obj is a primitive value or null, return it directly
	        return obj;
	    }

	    if (Array.isArray(obj)) {
	        // If obj is an array, create a new array and clone each element
	        return obj.map(item => DeepClone(item));
	    }

	    if (obj instanceof Date) {
	        // If obj is a Date object, create a new Date object with the same value
	        return new Date(obj);
	    }

	    if (obj instanceof RegExp) {
	        // If obj is a RegExp object, create a new RegExp object with the same pattern and flags
	        return new RegExp(obj);
	    }

	    if (Object.getPrototypeOf(obj) !== Object.prototype) {
	        // If obj is a custom object, return a reference to it
	        return obj;
	    }

	    // If obj is a plain object, create a new object and clone each property
	    const clonedObj = {};
	    for (let key in obj) {
	        if (obj.hasOwnProperty(key)) {
	            clonedObj[key] = DeepClone(obj[key]);
	        }
	    }
	    return clonedObj;
	}

	var Dump = function () {
	    var data = {
	        sn: GetSerialNumber(),
	        id: this.id,
	        title: this.title,
	        description: this.description,
	        root: (this.root) ? this.root.id : null,
	        properties: DeepClone(this.properties),
	        nodes: [],
	    };

	    if (!this.root) {
	        return data;
	    }

	    var nodes = [];
	    BreadthFirstSearch$1(this.root, function (child) {
	        nodes.push(child);
	    });

	    for (var i = 0, cnt = nodes.length; i < cnt; i++) {
	        var node = nodes[i];

	        var spec = {
	            id: node.id,
	            name: node.name,
	            title: node.title,
	            description: node.description,
	            properties: DeepClone(node.properties)
	        };

	        switch (node.category) {
	            case COMPOSITE:
	                spec.children = node.children.map((child) => child.id);

	                if (node.services) {
	                    spec.services = node.services.map((child) => child.id);
	                }

	                break;

	            case DECORATOR:
	                if (node.child) {
	                    spec.child = node.child.id;
	                }

	                break;

	            case ACTION:
	                if (node.services) {
	                    spec.services = node.services.map((child) => child.id);
	                }

	                break;
	        }

	        data.nodes.push(spec);
	    }

	    return data;
	};

	class BaseExpression {
	    setExpressionHandler(callback) {
	        this.expressionHandler = callback;
	        return this;
	    }

	    eval(context) {
	        return this.expressionHandler(context);
	    }
	}

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var parser$3 = {};

	/* parser generated by jison 0.4.18 */

	(function (exports) {
		/*
		  Returns a Parser object of the following structure:

		  Parser: {
		    yy: {}
		  }

		  Parser.prototype: {
		    yy: {},
		    trace: function(),
		    symbols_: {associative list: name ==> number},
		    terminals_: {associative list: number ==> name},
		    productions_: [...],
		    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
		    table: [...],
		    defaultActions: {...},
		    parseError: function(str, hash),
		    parse: function(input),

		    lexer: {
		        EOF: 1,
		        parseError: function(str, hash),
		        setInput: function(input),
		        input: function(),
		        unput: function(str),
		        more: function(),
		        less: function(n),
		        pastInput: function(),
		        upcomingInput: function(),
		        showPosition: function(),
		        test_match: function(regex_match_array, rule_index),
		        next: function(),
		        lex: function(),
		        begin: function(condition),
		        popState: function(),
		        _currentRules: function(),
		        topState: function(),
		        pushState: function(condition),

		        options: {
		            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
		            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
		            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
		        },

		        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
		        rules: [...],
		        conditions: {associative list: name ==> set},
		    }
		  }


		  token location info (@$, _$, etc.): {
		    first_line: n,
		    last_line: n,
		    first_column: n,
		    last_column: n,
		    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
		  }


		  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
		    text:        (matched text)
		    token:       (the produced terminal token, if any)
		    line:        (yylineno)
		  }
		  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
		    loc:         (yylloc)
		    expected:    (string describing the set of expected tokens)
		    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
		  }
		*/
		var parser = (function(){
		var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,11],$V1=[1,3],$V2=[1,4],$V3=[1,5],$V4=[1,6],$V5=[1,8],$V6=[1,9],$V7=[1,10],$V8=[1,13],$V9=[1,14],$Va=[1,15],$Vb=[1,16],$Vc=[1,17],$Vd=[1,18],$Ve=[1,19],$Vf=[1,20],$Vg=[1,21],$Vh=[1,22],$Vi=[1,23],$Vj=[1,24],$Vk=[1,25],$Vl=[1,26],$Vm=[5,7,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,28,30],$Vn=[5,7,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,30],$Vo=[5,7,12,13,14,19,20,21,22,23,24,25,26,28,30],$Vp=[5,7,12,13,14,15,16,17,19,20,21,22,23,24,25,26,28,30],$Vq=[5,7,12,19,20,21,22,23,24,25,26,28,30],$Vr=[5,7,12,25,26,28,30],$Vs=[7,28];
		var parser = {trace: function trace () { },
		yy: {},
		symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"expression_list":6,",":7,"dot_name":8,".":9,"NAME":10,"[":11,"]":12,"+":13,"-":14,"*":15,"/":16,"%":17,"^":18,">":19,"<":20,"==":21,"!=":22,">=":23,"<=":24,"||":25,"&&":26,"(":27,")":28,"?":29,":":30,"true":31,"false":32,"QUOTED_STRING":33,"NUMBER":34,"HEXNUMBER":35,"$accept":0,"$end":1},
		terminals_: {2:"error",5:"EOF",7:",",9:".",10:"NAME",11:"[",12:"]",13:"+",14:"-",15:"*",16:"/",17:"%",18:"^",19:">",20:"<",21:"==",22:"!=",23:">=",24:"<=",25:"||",26:"&&",27:"(",28:")",29:"?",30:":",31:"true",32:"false",33:"QUOTED_STRING",34:"NUMBER",35:"HEXNUMBER"},
		productions_: [0,[3,2],[6,3],[6,1],[8,3],[8,4],[8,1],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2],[4,3],[4,7],[4,1],[4,1],[4,1],[4,3],[4,4],[4,1],[4,1],[4,1]],
		performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
		/* this == yyval */

		var $0 = $$.length - 1;
		switch (yystate) {
		case 1:

		            var result = $$[$0-1];
		            if (typeof(result) === 'function') {
		                return result;
		            } else {
		                return function(ctx) { return result; }
		            }
		case 2: case 4:
		 this.$ = $$[$0-2].concat([$$[$0]]); 
		break;
		case 3: case 6:
		 this.$ = [$$[$0]]; 
		break;
		case 5:
		 this.$ = $$[$0-3].concat([$$[$0-1]]); 
		break;
		case 7:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_add', [$$[$0-2], $$[$0]]); };
		        
		break;
		case 8:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_subtract', [$$[$0-2], $$[$0]]); };
		        
		break;
		case 9:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_multiply', [$$[$0-2], $$[$0]]); };
		        
		break;
		case 10:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_divide', [$$[$0-2], $$[$0]]); };
		        
		break;
		case 11:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_mod', [$$[$0-2], $$[$0]]); };
		        
		break;
		case 12:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_pow', [$$[$0-2], $$[$0]]); };
		        
		break;
		case 13:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_greaterThen', [$$[$0-2], $$[$0]]) == true; };
		        
		break;
		case 14:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_lessThen', [$$[$0-2], $$[$0]]) == true; };
		        
		break;
		case 15:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_equalTo', [$$[$0-2], $$[$0]]) == true; };
		        
		break;
		case 16:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_equalTo', [$$[$0-2], $$[$0]]) == false; };
		        
		break;
		case 17:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_lessThen', [$$[$0-2], $$[$0]]) == false; };
		        
		break;
		case 18:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_greaterThen', [$$[$0-2], $$[$0]]) == false; };
		        
		break;
		case 19:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_or', [$$[$0-2], $$[$0]]) == true; };
		        
		break;
		case 20:

		            this.$ = function(ctx) { return runBuildInMethod(yy.parser, ctx, '_and', [$$[$0-2], $$[$0]]) == true; };
		        
		break;
		case 21:

		            this.$ = function(ctx) { return -runFn($$[$0], ctx); };
		        
		break;
		case 22:

		            this.$ = function(ctx) { return runFn($$[$0-1], ctx); };
		        
		break;
		case 23:

		            this.$ = function(ctx) { return runFn($$[$0-5], ctx)? runFn($$[$0-2], ctx) : runFn($$[$0], ctx); };
		        
		break;
		case 24:
		 this.$ = true; 
		break;
		case 25:
		 this.$ = false; 
		break;
		case 26:
		            
		            this.$ = function(ctx) {
		                return yy.parser.getDotProperty(ctx, mapArgs($$[$0], ctx), 0); 
		            };
		        
		break;
		case 27:

		            this.$ = function(ctx) { 
		                return runMethod(yy.parser, ctx, mapArgs($$[$0-2], ctx), undefined, true); 
		            };
		        
		break;
		case 28:

		            this.$ = function(ctx) { 
		                return runMethod(yy.parser, ctx, mapArgs($$[$0-3], ctx), $$[$0-1], true); 
		            };
		        
		break;
		case 29:
		 this.$ = yytext.slice(1,-1); 
		break;
		case 30:
		 this.$ = Number(yytext); 
		break;
		case 31:
		 this.$ = parseInt(yytext, 16); 
		break;
		}
		},
		table: [{3:1,4:2,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{1:[3]},{5:[1,12],13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj,25:$Vk,26:$Vl},{4:27,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:28,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},o($Vm,[2,24]),o($Vm,[2,25]),o($Vm,[2,26],{9:[1,30],11:[1,31],27:[1,29]}),o($Vm,[2,29]),o($Vm,[2,30]),o($Vm,[2,31]),o($Vn,[2,6]),{1:[2,1]},{4:32,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:33,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:34,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:35,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:36,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:37,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:38,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:39,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:40,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:41,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:42,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:43,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:44,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{4:45,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},o($Vm,[2,21]),{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj,25:$Vk,26:$Vl,28:[1,46]},{4:49,6:48,8:7,10:$V0,14:$V1,27:$V2,28:[1,47],31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},{10:[1,50]},{4:51,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},o($Vo,[2,7],{15:$Va,16:$Vb,17:$Vc,18:$Vd}),o($Vo,[2,8],{15:$Va,16:$Vb,17:$Vc,18:$Vd}),o($Vp,[2,9],{18:$Vd}),o($Vp,[2,10],{18:$Vd}),o([5,7,12,13,14,17,19,20,21,22,23,24,25,26,28,30],[2,11],{15:$Va,16:$Vb,18:$Vd}),o($Vm,[2,12]),o($Vq,[2,13],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd}),o($Vq,[2,14],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd}),o($Vq,[2,15],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd}),o($Vq,[2,16],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd}),o($Vq,[2,17],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd}),o($Vq,[2,18],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd}),o($Vr,[2,19],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj}),o($Vr,[2,20],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj}),o($Vm,[2,22],{29:[1,52]}),o($Vm,[2,27]),{7:[1,54],28:[1,53]},o($Vs,[2,3],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj,25:$Vk,26:$Vl}),o($Vn,[2,4]),{12:[1,55],13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj,25:$Vk,26:$Vl},{4:56,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},o($Vm,[2,28]),{4:57,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},o($Vn,[2,5]),{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj,25:$Vk,26:$Vl,30:[1,58]},o($Vs,[2,2],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj,25:$Vk,26:$Vl}),{4:59,8:7,10:$V0,14:$V1,27:$V2,31:$V3,32:$V4,33:$V5,34:$V6,35:$V7},o([5,7,12,28,30],[2,23],{13:$V8,14:$V9,15:$Va,16:$Vb,17:$Vc,18:$Vd,19:$Ve,20:$Vf,21:$Vg,22:$Vh,23:$Vi,24:$Vj,25:$Vk,26:$Vl})],
		defaultActions: {12:[2,1]},
		parseError: function parseError (str, hash) {
		    if (hash.recoverable) {
		        this.trace(str);
		    } else {
		        var error = new Error(str);
		        error.hash = hash;
		        throw error;
		    }
		},
		parse: function parse(input) {
		    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
		    var args = lstack.slice.call(arguments, 1);
		    var lexer = Object.create(this.lexer);
		    var sharedState = { yy: {} };
		    for (var k in this.yy) {
		        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
		            sharedState.yy[k] = this.yy[k];
		        }
		    }
		    lexer.setInput(input, sharedState.yy);
		    sharedState.yy.lexer = lexer;
		    sharedState.yy.parser = this;
		    if (typeof lexer.yylloc == 'undefined') {
		        lexer.yylloc = {};
		    }
		    var yyloc = lexer.yylloc;
		    lstack.push(yyloc);
		    var ranges = lexer.options && lexer.options.ranges;
		    if (typeof sharedState.yy.parseError === 'function') {
		        this.parseError = sharedState.yy.parseError;
		    } else {
		        this.parseError = Object.getPrototypeOf(this).parseError;
		    }
		    var lex = function () {
		            var token;
		            token = lexer.lex() || EOF;
		            if (typeof token !== 'number') {
		                token = self.symbols_[token] || token;
		            }
		            return token;
		        };
		    var symbol, state, action, r, yyval = {}, p, len, newState, expected;
		    while (true) {
		        state = stack[stack.length - 1];
		        if (this.defaultActions[state]) {
		            action = this.defaultActions[state];
		        } else {
		            if (symbol === null || typeof symbol == 'undefined') {
		                symbol = lex();
		            }
		            action = table[state] && table[state][symbol];
		        }
		                    if (typeof action === 'undefined' || !action.length || !action[0]) {
		                var errStr = '';
		                expected = [];
		                for (p in table[state]) {
		                    if (this.terminals_[p] && p > TERROR) {
		                        expected.push('\'' + this.terminals_[p] + '\'');
		                    }
		                }
		                if (lexer.showPosition) {
		                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
		                } else {
		                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
		                }
		                this.parseError(errStr, {
		                    text: lexer.match,
		                    token: this.terminals_[symbol] || symbol,
		                    line: lexer.yylineno,
		                    loc: yyloc,
		                    expected: expected
		                });
		            }
		        if (action[0] instanceof Array && action.length > 1) {
		            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
		        }
		        switch (action[0]) {
		        case 1:
		            stack.push(symbol);
		            vstack.push(lexer.yytext);
		            lstack.push(lexer.yylloc);
		            stack.push(action[1]);
		            symbol = null;
		            {
		                yyleng = lexer.yyleng;
		                yytext = lexer.yytext;
		                yylineno = lexer.yylineno;
		                yyloc = lexer.yylloc;
		            }
		            break;
		        case 2:
		            len = this.productions_[action[1]][1];
		            yyval.$ = vstack[vstack.length - len];
		            yyval._$ = {
		                first_line: lstack[lstack.length - (len || 1)].first_line,
		                last_line: lstack[lstack.length - 1].last_line,
		                first_column: lstack[lstack.length - (len || 1)].first_column,
		                last_column: lstack[lstack.length - 1].last_column
		            };
		            if (ranges) {
		                yyval._$.range = [
		                    lstack[lstack.length - (len || 1)].range[0],
		                    lstack[lstack.length - 1].range[1]
		                ];
		            }
		            r = this.performAction.apply(yyval, [
		                yytext,
		                yyleng,
		                yylineno,
		                sharedState.yy,
		                action[1],
		                vstack,
		                lstack
		            ].concat(args));
		            if (typeof r !== 'undefined') {
		                return r;
		            }
		            if (len) {
		                stack = stack.slice(0, -1 * len * 2);
		                vstack = vstack.slice(0, -1 * len);
		                lstack = lstack.slice(0, -1 * len);
		            }
		            stack.push(this.productions_[action[1]][0]);
		            vstack.push(yyval.$);
		            lstack.push(yyval._$);
		            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
		            stack.push(newState);
		            break;
		        case 3:
		            return true;
		        }
		    }
		    return true;
		}};

		    function runFn(arg, ctx) {
		        return (typeof(arg) === 'function')? arg(ctx) : arg;
		    }

		    function mapArgs(args, ctx) {
		        if (args) {
		            args = args.map(function(arg){ return runFn(arg, ctx); });
		        }
		        return args;
		    }

		    function runBuildInMethod(self, ctx, name, args) {
		        var callback = self[name];
		        return callback.apply(self, mapArgs(args, ctx));
		    }

		    function runMethod(self, ctx, name, args, dotMode) {
		        var names;
		        if (typeof(name) === 'string') {
		            if (dotMode) {
		                names = name.split('.');
		            } else {
		                names = [name];
		            }
		        } else {
		            names = name;
		        }

		        var callback, scope;
		        if (names.length > 1) {
		            var callbackName = names.pop();
		            scope = self.getDotProperty(ctx, names);
		            callback = scope[callbackName];
		        } else {
		            callback = self.getProperty(ctx, name);
		            scope = self;
		        }

		        if (callback == null) {
		            callback = self.getProperty(ctx, 'defaultHandler');
		            scope = self;
		        }

		        return callback.apply(scope, mapArgs(args, ctx));
		    }
		/* generated by jison-lex 0.3.4 */
		var lexer = (function(){
		var lexer = ({

		EOF:1,

		parseError:function parseError(str, hash) {
		        if (this.yy.parser) {
		            this.yy.parser.parseError(str, hash);
		        } else {
		            throw new Error(str);
		        }
		    },

		// resets the lexer, sets new input
		setInput:function (input, yy) {
		        this.yy = yy || this.yy || {};
		        this._input = input;
		        this._more = this._backtrack = this.done = false;
		        this.yylineno = this.yyleng = 0;
		        this.yytext = this.matched = this.match = '';
		        this.conditionStack = ['INITIAL'];
		        this.yylloc = {
		            first_line: 1,
		            first_column: 0,
		            last_line: 1,
		            last_column: 0
		        };
		        if (this.options.ranges) {
		            this.yylloc.range = [0,0];
		        }
		        this.offset = 0;
		        return this;
		    },

		// consumes and returns one char from the input
		input:function () {
		        var ch = this._input[0];
		        this.yytext += ch;
		        this.yyleng++;
		        this.offset++;
		        this.match += ch;
		        this.matched += ch;
		        var lines = ch.match(/(?:\r\n?|\n).*/g);
		        if (lines) {
		            this.yylineno++;
		            this.yylloc.last_line++;
		        } else {
		            this.yylloc.last_column++;
		        }
		        if (this.options.ranges) {
		            this.yylloc.range[1]++;
		        }

		        this._input = this._input.slice(1);
		        return ch;
		    },

		// unshifts one char (or a string) into the input
		unput:function (ch) {
		        var len = ch.length;
		        var lines = ch.split(/(?:\r\n?|\n)/g);

		        this._input = ch + this._input;
		        this.yytext = this.yytext.substr(0, this.yytext.length - len);
		        //this.yyleng -= len;
		        this.offset -= len;
		        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
		        this.match = this.match.substr(0, this.match.length - 1);
		        this.matched = this.matched.substr(0, this.matched.length - 1);

		        if (lines.length - 1) {
		            this.yylineno -= lines.length - 1;
		        }
		        var r = this.yylloc.range;

		        this.yylloc = {
		            first_line: this.yylloc.first_line,
		            last_line: this.yylineno + 1,
		            first_column: this.yylloc.first_column,
		            last_column: lines ?
		                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
		                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
		              this.yylloc.first_column - len
		        };

		        if (this.options.ranges) {
		            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
		        }
		        this.yyleng = this.yytext.length;
		        return this;
		    },

		// When called from action, caches matched text and appends it on next action
		more:function () {
		        this._more = true;
		        return this;
		    },

		// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
		reject:function () {
		        if (this.options.backtrack_lexer) {
		            this._backtrack = true;
		        } else {
		            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
		                text: "",
		                token: null,
		                line: this.yylineno
		            });

		        }
		        return this;
		    },

		// retain first n characters of the match
		less:function (n) {
		        this.unput(this.match.slice(n));
		    },

		// displays already matched input, i.e. for error messages
		pastInput:function () {
		        var past = this.matched.substr(0, this.matched.length - this.match.length);
		        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
		    },

		// displays upcoming input, i.e. for error messages
		upcomingInput:function () {
		        var next = this.match;
		        if (next.length < 20) {
		            next += this._input.substr(0, 20-next.length);
		        }
		        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
		    },

		// displays the character position where the lexing error occurred, i.e. for error messages
		showPosition:function () {
		        var pre = this.pastInput();
		        var c = new Array(pre.length + 1).join("-");
		        return pre + this.upcomingInput() + "\n" + c + "^";
		    },

		// test the lexed token: return FALSE when not a match, otherwise return token
		test_match:function(match, indexed_rule) {
		        var token,
		            lines,
		            backup;

		        if (this.options.backtrack_lexer) {
		            // save context
		            backup = {
		                yylineno: this.yylineno,
		                yylloc: {
		                    first_line: this.yylloc.first_line,
		                    last_line: this.last_line,
		                    first_column: this.yylloc.first_column,
		                    last_column: this.yylloc.last_column
		                },
		                yytext: this.yytext,
		                match: this.match,
		                matches: this.matches,
		                matched: this.matched,
		                yyleng: this.yyleng,
		                offset: this.offset,
		                _more: this._more,
		                _input: this._input,
		                yy: this.yy,
		                conditionStack: this.conditionStack.slice(0),
		                done: this.done
		            };
		            if (this.options.ranges) {
		                backup.yylloc.range = this.yylloc.range.slice(0);
		            }
		        }

		        lines = match[0].match(/(?:\r\n?|\n).*/g);
		        if (lines) {
		            this.yylineno += lines.length;
		        }
		        this.yylloc = {
		            first_line: this.yylloc.last_line,
		            last_line: this.yylineno + 1,
		            first_column: this.yylloc.last_column,
		            last_column: lines ?
		                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
		                         this.yylloc.last_column + match[0].length
		        };
		        this.yytext += match[0];
		        this.match += match[0];
		        this.matches = match;
		        this.yyleng = this.yytext.length;
		        if (this.options.ranges) {
		            this.yylloc.range = [this.offset, this.offset += this.yyleng];
		        }
		        this._more = false;
		        this._backtrack = false;
		        this._input = this._input.slice(match[0].length);
		        this.matched += match[0];
		        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
		        if (this.done && this._input) {
		            this.done = false;
		        }
		        if (token) {
		            return token;
		        } else if (this._backtrack) {
		            // recover context
		            for (var k in backup) {
		                this[k] = backup[k];
		            }
		            return false; // rule action called reject() implying the next rule should be tested instead.
		        }
		        return false;
		    },

		// return next match in input
		next:function () {
		        if (this.done) {
		            return this.EOF;
		        }
		        if (!this._input) {
		            this.done = true;
		        }

		        var token,
		            match,
		            tempMatch,
		            index;
		        if (!this._more) {
		            this.yytext = '';
		            this.match = '';
		        }
		        var rules = this._currentRules();
		        for (var i = 0; i < rules.length; i++) {
		            tempMatch = this._input.match(this.rules[rules[i]]);
		            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
		                match = tempMatch;
		                index = i;
		                if (this.options.backtrack_lexer) {
		                    token = this.test_match(tempMatch, rules[i]);
		                    if (token !== false) {
		                        return token;
		                    } else if (this._backtrack) {
		                        match = false;
		                        continue; // rule action called reject() implying a rule MISmatch.
		                    } else {
		                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
		                        return false;
		                    }
		                } else if (!this.options.flex) {
		                    break;
		                }
		            }
		        }
		        if (match) {
		            token = this.test_match(match, rules[index]);
		            if (token !== false) {
		                return token;
		            }
		            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
		            return false;
		        }
		        if (this._input === "") {
		            return this.EOF;
		        } else {
		            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
		                text: "",
		                token: null,
		                line: this.yylineno
		            });
		        }
		    },

		// return next match that has a token
		lex:function lex () {
		        var r = this.next();
		        if (r) {
		            return r;
		        } else {
		            return this.lex();
		        }
		    },

		// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
		begin:function begin (condition) {
		        this.conditionStack.push(condition);
		    },

		// pop the previously active lexer condition state off the condition stack
		popState:function popState () {
		        var n = this.conditionStack.length - 1;
		        if (n > 0) {
		            return this.conditionStack.pop();
		        } else {
		            return this.conditionStack[0];
		        }
		    },

		// produce the lexer rule set which is active for the currently active lexer condition state
		_currentRules:function _currentRules () {
		        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
		            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
		        } else {
		            return this.conditions["INITIAL"].rules;
		        }
		    },

		// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
		topState:function topState (n) {
		        n = this.conditionStack.length - 1 - Math.abs(n || 0);
		        if (n >= 0) {
		            return this.conditionStack[n];
		        } else {
		            return "INITIAL";
		        }
		    },

		// alias for begin(condition)
		pushState:function pushState (condition) {
		        this.begin(condition);
		    },

		// return the number of states currently on the stack
		stateStackSize:function stateStackSize() {
		        return this.conditionStack.length;
		    },
		options: {},
		performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
		switch($avoiding_name_collisions) {
		case 0:/* skip whitespace */
		break;
		case 1:return 34
		case 2:return 35
		case 3:return 15
		case 4:return 16
		case 5:return 14
		case 6:return 13
		case 7:return 18
		case 8:return 17
		case 9:return ">="
		case 10:return "<="
		case 11:return 19
		case 12:return 20
		case 13:return "=="
		case 14:return "!="
		case 15:return "||"
		case 16:return "&&"
		case 17:return "?"
		case 18:return ":"
		case 19:return 27
		case 20:return 28
		case 21:return 11
		case 22:return 12
		case 23:return 7
		case 24:return 9
		case 25:return 31
		case 26:return 32
		case 27:return 10
		case 28:return 33
		case 29:return 5
		case 30:return 'INVALID'
		}
		},
		rules: [/^(?:\s+)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:\b0x[0-9A-Fa-f]+\b)/,/^(?:\*)/,/^(?:\/)/,/^(?:-)/,/^(?:\+)/,/^(?:\^)/,/^(?:%)/,/^(?:>=)/,/^(?:<=)/,/^(?:>)/,/^(?:<)/,/^(?:==)/,/^(?:!=)/,/^(?:\|\|)/,/^(?:&&)/,/^(?:\?)/,/^(?::)/,/^(?:\()/,/^(?:\))/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?:\.)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:[^\s\*\/\-\+\^\%\>\=\<\!\|\&\?\:\(\)\[\]\,\.\"\']+)/,/^(?:"(\\.|[^\"\\])*"|'(\\.|[^\'\\])*')/,/^(?:$)/,/^(?:.)/],
		conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30],"inclusive":true}}
		});
		return lexer;
		})();
		parser.lexer = lexer;
		function Parser () {
		  this.yy = {};
		}
		Parser.prototype = parser;parser.Parser = Parser;
		return new Parser;
		})();


		if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
		exports.parser = parser;
		exports.Parser = parser.Parser;
		exports.parse = function () { return parser.parse.apply(parser, arguments); };
		} 
	} (parser$3));

	var parser$2 = /*@__PURE__*/getDefaultExportFromCjs(parser$3);

	var GetProperty$1 = function (context, key, defaultValue, dotMode) {
	    if (dotMode === undefined) {
	        dotMode = true;
	    }

	    if (!context || typeof (context) === 'number' || typeof (context) === 'string') {
	        return defaultValue;
	    } else if (key in context) {
	        return context[key];
	    } else if (dotMode &&
	        ((Array.isArray(key) || (key.indexOf('.') !== -1)))
	    ) {
	        var keys = (Array.isArray(key)) ? key : key.split('.');
	        var value = context;
	        //  Use for loop here so we can break early
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (key in value) {
	                value = value[key];
	            }
	            else {
	                value = defaultValue;
	                break;
	            }
	        }

	        return value;
	    } else {
	        return defaultValue;
	    }
	};

	class FormulaParser extends parser$2.Parser {
	    getProperty(context, name, defaultValue) {
	        var value = GetProperty$1(context, name, undefined, false);
	        if (value !== undefined) {
	            return value;
	        }
	        return GetProperty$1(this, name, defaultValue, false);
	    }

	    getDotProperty(context, name, defaultValue) {
	        var value = GetProperty$1(context, name, undefined, true);
	        if (value !== undefined) {
	            return value;
	        }
	        return GetProperty$1(this, name, defaultValue, true);
	    }

	    static GetProperty(context, key, defaultValue, dotMode) {
	        return GetProperty$1(context, key, defaultValue, dotMode);
	    }

	    _add(a, b) {
	        return a + b;
	    }

	    _subtract(a, b) {
	        return a - b;
	    }

	    _multiply(a, b) {
	        return a * b;
	    }

	    _divide(a, b) {
	        return a / b;
	    }

	    _mod(a, b) {
	        return a % b;
	    }

	    _pow(a, b) {
	        return Math.pow(a, b);
	    }

	    _greaterThen(a, b) {
	        return a > b;
	    }

	    _lessThen(a, b) {
	        return a < b;
	    }

	    _equalTo(a, b) {
	        return a == b;
	    }

	    _or(a, b) {
	        return a || b;
	    }

	    _and(a, b) {
	        return a && b;
	    }

	    defaultHandler(name, args) {
	        return 0;
	    }

	    compile(input) {
	        return this.parse(input);
	    }

	    exec(input, data) {
	        if (typeof (input) === 'string') {
	            input = this.compile(input);
	        }
	        return input(data);
	    }
	}

	var parser$1 = new FormulaParser();
	var Compile$1 = function(expression) {
	    return parser$1.compile(expression);
	};

	class Expression extends BaseExpression {
	    constructor(expression) {
	        super();

	        var callback;
	        if (typeof (expression) === 'number') {
	            callback = function () {
	                return expression;
	            };
	        } else {
	            callback = Compile$1(expression);
	        }

	        this.setExpressionHandler(callback);
	    }
	}

	class BooleanExpression extends Expression {
	    eval(context) {
	        return !!super.eval(context);
	    }
	}

	class StringTemplate {
	    constructor(config) {
	        if (config === undefined) {
	            config = {};
	        }
	        // Brackets and generate regex
	        var delimiters = config.delimiters;
	        if (delimiters === undefined) {
	            delimiters = ['{{', '}}'];
	        }
	        this.setDelimiters(delimiters[0], delimiters[1]);

	        var expressionParser = config.expressionParser;
	        if (expressionParser === undefined) {
	            expressionParser = new FormulaParser();
	        }
	        this.setExpressionParser(expressionParser);
	    }

	    setDelimiters(delimiterLeft, delimiterRight) {
	        if (delimiterRight === undefined) {
	            delimiterRight = delimiterLeft[1];
	            delimiterLeft = delimiterLeft[0];
	        }
	        this.delimiterLeft = delimiterLeft;
	        this.delimiterRight = delimiterRight;

	        this.reDelimiter = RegExp(`${delimiterLeft}|${delimiterRight}`, 'gi');
	        this.reSplit = RegExp(`${delimiterLeft}.*?${delimiterRight}`, 'gi');
	        return this;
	    }

	    setExpressionParser(expressionParser) {
	        this.expressionParser = expressionParser;
	        return this;
	    }

	    compile(content, config) {
	        // Store previous setting
	        // Override current setting        
	        var delimiterLeftSave, delimiterRightSave;
	        var expressionParserSave;
	        if (config) {
	            if (config instanceof (FormulaParser)) {
	                var expressionParser = config;
	                if (expressionParser) {
	                    expressionParserSave = this.expressionParser;
	                    this.setExpressionParser(expressionParser);
	                }

	            } else {
	                var delimiters = config.delimiters;
	                if (delimiters) {
	                    delimiterLeftSave = this.delimiterLeft;
	                    delimiterRightSave = this.delimiterRight;
	                    this.setDelimiters(delimiters[0], delimiters[1]);
	                }

	                var expressionParser = config.expressionParser;
	                if (expressionParser) {
	                    expressionParserSave = this.expressionParser;
	                    this.setExpressionParser(expressionParser);
	                }
	            }
	        }

	        // Parse context
	        var reDelimiter = this.reDelimiter;
	        var reSplit = this.reSplit;
	        var expressionParser = this.expressionParser;

	        var result = [];
	        var charIdx = 0;
	        while (true) {
	            var regexResult = reSplit.exec(content);
	            if (!regexResult) {
	                break;
	            }

	            var match = regexResult[0];
	            var matchEnd = reSplit.lastIndex;
	            var matchStart = matchEnd - match.length;

	            if (charIdx < matchStart) {
	                result.push(content.substring(charIdx, matchStart));
	            }

	            var s = content.substring(matchStart, matchEnd).replace(reDelimiter, '');
	            result.push(expressionParser.compile(s));

	            charIdx = matchEnd;
	        }

	        var totalLen = content.length;
	        if (charIdx < totalLen) { // Push remainder string
	            result.push(content.substring(charIdx, totalLen));
	        }

	        // Restore previous setting
	        if (delimiterLeftSave) {
	            this.setDelimiters(delimiterLeftSave, delimiterRightSave);
	        }

	        if (expressionParserSave) {
	            this.setExpressionParser(expressionParserSave);
	        }

	        // Return render callback
	        return function (view) {
	            return result.map(function (item) {
	                if (typeof (item) === 'function') {
	                    item = item(view);
	                }
	                return item;
	            }).join('');
	        };
	    }

	    render(content, view, config) {
	        var f;
	        if (typeof (content) === 'string') {
	            f = this.compile(content, config);
	        } else {
	            f = content;
	        }
	        return f(view);
	    }
	}

	var stringTemplate = new StringTemplate();
	var Compile = function (content, config) {
	    return stringTemplate.compile(content, config);
	};

	class StringTemplateExpression extends BaseExpression {
	    constructor(expression) {
	        super();

	        var callback = Compile(expression);
	        this.setExpressionHandler(callback);
	    }
	}

	class BaseNode {

	    constructor(
	        {
	            id,
	            category,
	            name,
	            title,
	            description,
	            properties
	        } = {}
	    ) {

	        if (id === undefined) {
	            id = CreateID();
	        }

	        this.parent = null;

	        this.id = id;

	        this.category = category || '';

	        this.name = name || '';

	        this.title = title || this.name;

	        this.description = description || '';

	        this.properties = properties || {};
	    }

	    destroy() {
	        this.parent = undefined;
	        this.properties = undefined;
	    }

	    setTitle(title) {
	        this.title = title;
	        return this;
	    }

	    setName(name) {
	        this.name = name;
	        return this;
	    }

	    setDescription(description) {
	        this.description = description;
	        return this;
	    }

	    setParent(parent) {
	        this.parent = parent;
	        return this;
	    }

	    getParent() {
	        return this.parent;
	    }

	    getTree(tick) {
	        if (tick) {
	            return tick.tree;
	        } else {
	            var parent = this.parent;
	            while (parent) {
	                if (parent.category === TREE) {
	                    return parent;
	                }
	                parent = parent.parent;
	            }
	            return null;
	        }
	    }

	    addExpression(expression) {
	        return new Expression(expression);
	    }

	    addBooleanExpression(expression) {
	        return new BooleanExpression(expression);
	    }

	    addStringTemplateExpression(expression) {
	        // TODO: Use mustache or handlebars ?
	        return new StringTemplateExpression(expression);
	    }

	    _execute(tick) {
	        // ENTER
	        this._enter(tick);

	        // OPEN
	        if (!this.getOpenState(tick)) {
	            this._open(tick);
	        }

	        // TICK
	        var status = this._tick(tick);

	        // CLOSE
	        if ((status === SUCCESS$1) || (status === FAILURE) ||
	            (status === ABORT) || (status === ERROR$1)) {
	            this._close(tick);
	        }

	        // EXIT
	        this._exit(tick);

	        return status;
	    }

	    _enter(tick) {
	        tick._enterNode(this);
	        this.enter(tick);
	    }

	    _open(tick) {
	        tick._openNode(this);
	        this.setOpenState(tick, true);
	        this.open(tick);
	    }

	    _tick(tick) {
	        tick._tickNode(this);
	        return this.tick(tick);
	    }

	    _close(tick) {
	        tick._closeNode(this);
	        this.setOpenState(tick, false);
	        this.close(tick);
	        // Children will be closed before parent, otherwise abort children
	        this.abortChildren(tick);
	    }

	    _exit(tick) {
	        tick._exitNode(this);
	        this.exit(tick);
	    }

	    _abort(tick) {
	        this._close(tick);
	        this.abort(tick);
	    }

	    enter(tick) { }

	    open(tick) { }

	    tick(tick) { }

	    close(tick) { }

	    exit(tick) { }

	    abortChildren(tick) { }

	    abort(tick) { }

	    // open state of this node
	    getNodeMemory(tick) {
	        return tick.getNodeMemory(this.id);
	    }

	    getOpenState(tick) {
	        return this.getNodeMemory(tick).$isOpen;
	    }

	    setOpenState(tick, state) {
	        if (state === undefined) {
	            state = true;
	        }
	        this.getNodeMemory(tick).$isOpen = state;
	        return this;
	    }

	    // Return state value
	    get SUCCESS() {
	        return SUCCESS$1;
	    }

	    get FAILURE() {
	        return FAILURE;
	    }

	    get RUNNING() {
	        return RUNNING$1;
	    }

	    get ERROR() {
	        return ERROR$1;
	    }
	}

	class Action extends BaseNode {

	    constructor(
	        {
	            name = 'Action',
	            title,
	            properties,
	            services,
	        } = {},
	        nodePool
	    ) {

	        super({
	            category: ACTION,
	            name,
	            title,
	            properties,
	        });

	        if (services) {
	            for (var i = 0, cnt = services.length; i < cnt; i++) {
	                this.addService(services[i], nodePool);
	            }
	        }
	    }

	    destroy() {
	        if (this.services) {
	            for (var i = 0, cnt = this.services.length; i < cnt; i++) {
	                this.services[i].destroy();
	            }
	        }
	        this.services = undefined;

	        super.destroy();
	    }

	    addService(node, nodePool) {
	        if (typeof (node) === 'string') {  // Node ID
	            node = nodePool[node];
	        }

	        if (this.services === undefined) {
	            this.services = [];
	        }

	        if (this.services.indexOf(node) === -1) {
	            this.services.push(node);
	            node.setParent(this);
	        }

	        return this;
	    }

	    _tick(tick) {
	        tick._tickNode(this);

	        if (this.services) {
	            for (var i = 0, cnt = this.services.length; i < cnt; i++) {
	                this.services[i]._tick(tick);
	            }
	        }

	        return this.tick(tick);
	    }

	}

	class Composite extends BaseNode {

	    constructor(
	        {
	            children = [],
	            name = 'Composite',
	            title,
	            properties,
	            services,
	        } = {},
	        nodePool
	    ) {

	        super({
	            category: COMPOSITE,
	            name,
	            title,
	            properties,
	        });

	        this.children = [];
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            this.addChild(children[i], nodePool);
	        }

	        if (services) {
	            for (var i = 0, cnt = services.length; i < cnt; i++) {
	                this.addService(services[i], nodePool);
	            }
	        }
	    }

	    destroy() {
	        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
	            this.children[i].destroy();
	        }

	        if (this.services) {
	            for (var i = 0, cnt = this.services.length; i < cnt; i++) {
	                this.services[i].destroy();
	            }
	        }

	        this.children = undefined;
	        this.services = undefined;

	        super.destroy();
	    }

	    insertChild(node, nodePool, index) {
	        if (typeof (node) === 'string') {  // Node ID
	            node = nodePool[node];
	        }

	        if (this.children.indexOf(node) === -1) {
	            if (index < 0) {
	                index = this.children.length + index;
	            }
	            if ((index === undefined) || (index >= this.children.length)) {
	                this.children.push(node);
	            } else {
	                this.children.splice(index, 0, node);
	            }

	            node.setParent(this);
	        }

	        return this;
	    }

	    addChild(node, nodePool,) {
	        this.insertChild(node, nodePool);
	        return this;
	    }

	    addService(node, nodePool) {
	        if (typeof (node) === 'string') {  // Node ID
	            node = nodePool[node];
	        }

	        if (this.services === undefined) {
	            this.services = [];
	        }

	        if (this.services.indexOf(node) === -1) {
	            this.services.push(node);
	            node.setParent(this);
	        }

	        return this;
	    }

	    _tick(tick) {
	        tick._tickNode(this);

	        if (this.services) {
	            for (var i = 0, cnt = this.services.length; i < cnt; i++) {
	                this.services[i]._tick(tick);
	            }
	        }

	        return this.tick(tick);
	    }

	    abortChildren(tick) {
	        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
	            var childNode = this.children[i];
	            if (childNode.getOpenState(tick)) {
	                childNode._abort(tick);
	            }
	        }
	    }

	}

	class Decorator extends BaseNode {

	    constructor(
	        {
	            child = null,
	            name = 'Decorator',
	            title,
	            properties
	        } = {},
	        nodePool
	    ) {

	        super({
	            category: DECORATOR,
	            name,
	            title,
	            properties,
	        });

	        this.child = null;
	        if (child) {
	            this.addChild(child, nodePool);
	        }
	    }

	    destroy() {
	        if (this.child) {
	            this.child.destroy();
	        }

	        this.child = undefined;

	        super.destroy();
	    }

	    addChild(node, nodePool) {
	        if (typeof (node) === 'string') {  // Node ID
	            node = nodePool[node];
	        }

	        this.child = node;
	        node.setParent(this);
	        return this;
	    }

	    isChildRunning(tick) {
	        return this.child.getOpenState(tick);
	    }

	    abortChildren(tick) {
	        if (this.isChildRunning(tick)) {
	            this.child._abort(tick);
	        }
	    }

	    openChild(tick) {
	        this.child.setOpenState(tick, true);
	        return this;
	    }
	}

	class Service extends BaseNode {

	    constructor(
	        {
	            interval = 0,
	            randomDeviation = 0,
	            name = 'Service',
	            title,
	            properties
	        } = {}
	    ) {

	        if (properties === undefined) {
	            properties = {};
	        }

	        properties.interval = interval;
	        properties.randomDeviation = randomDeviation;

	        super({
	            category: SERVICE,
	            name,
	            title,
	            properties,
	        });

	        this.intervalExpression = this.addExpression(interval);
	        this.randomDeviationExpression = this.addExpression(randomDeviation);

	    }

	    _tick(tick) {
	        if (this.canTick(tick)) {
	            this.tick(tick);
	        }
	    }

	    canTick(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var currTime = tick.currentTime;
	        var lastEndTime = nodeMemory.$lastEndTime;
	        var interval = nodeMemory.$interval;

	        var canTick = (lastEndTime === undefined) ||
	            ((currTime - lastEndTime) >= interval);

	        if (canTick) {
	            nodeMemory.$lastEndTime = currTime;

	            var interval = tick.evalExpression(this.intervalExpression);
	            var randomDeviation = tick.evalExpression(this.randomDeviationExpression);
	            if (randomDeviation > 0) {
	                interval += (0.5 - Math.random()) * randomDeviation;
	            }
	            nodeMemory.$interval = interval;
	        }

	        return canTick;
	    }

	}

	class Succeeder extends Action {

	    constructor({
	        services,
	        title,
	        name = 'Succeeder'
	    } = {}) {

	        super({
	            services,
	            title,
	            name,
	        });
	    }

	    tick(tick) {
	        return SUCCESS$1;
	    }
	}

	class Failer extends Action {

	    constructor({
	        services,
	        title,
	        name = 'Failer'
	    } = {}) {

	        super({
	            services,
	            title,
	            name,
	        });
	    }

	    tick(tick) {
	        return FAILURE;
	    }
	}

	class Runner extends Action {

	    constructor({
	        services,
	        title,
	        name = 'Runner'
	    } = {}) {

	        super({
	            services,
	            title,
	            name,
	        });
	    }

	    tick(tick) {
	        return RUNNING$1;
	    }
	}

	let Error$1 = class Error extends Action {

	    constructor({
	        services,
	        title,
	        name = 'Error',
	    } = {}) {

	        super({
	            services,
	            title,
	            name,
	        });
	    }

	    tick(tick) {
	        return ERROR$1;
	    }
	};

	class Wait extends Action {

	    constructor({
	        duration = 0,
	        services,
	        title,
	        name = 'Wait'
	    } = {}) {

	        super({
	            title,
	            name,
	            properties: {
	                duration
	            },
	            services,
	        });

	        this.durationExpression = this.addExpression(duration);
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);

	        nodeMemory.$startTime = tick.currentTime;
	        nodeMemory.$duration = tick.evalExpression(this.durationExpression);
	    }

	    tick(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var currTime = tick.currentTime;
	        var startTime = nodeMemory.$startTime;
	        var duration = nodeMemory.$duration;

	        if (duration > 0) {
	            if ((currTime - startTime) < duration) {
	                return RUNNING$1;
	            }

	        } else if (duration === 0) { // Wait 1 tick            
	            if (currTime === startTime) {
	                return RUNNING$1;
	            }
	        }

	        return SUCCESS$1;
	    }
	}

	class Abort extends Action {

	    constructor({
	        services,
	        title,
	        name = 'Abort',
	    } = {}) {

	        super({
	            services,
	            title,
	            name,
	        });
	    }

	    tick(tick) {
	        return ABORT;
	    }
	}

	class Selector extends Composite {
	    constructor(
	        {
	            children = [],
	            services,
	            title,
	            name = 'Selector'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                children,
	                services,
	                title,
	                name,
	            },
	            nodePool
	        );

	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$runningChild = -1;  // No running child
	    }

	    tick(tick) {
	        if (this.children.length === 0) {
	            return ERROR$1;
	        }

	        var nodeMemory = this.getNodeMemory(tick);
	        var childIndex = nodeMemory.$runningChild;
	        var status;
	        if (childIndex < 0) {
	            for (var i = 0, cnt = this.children.length; i < cnt; i++) {
	                status = this.children[i]._execute(tick);

	                if ((status === RUNNING$1) || (status === SUCCESS$1) || (status === ABORT)) {
	                    childIndex = i;
	                    break;
	                }
	            }
	        } else {
	            var child = this.children[childIndex];
	            status = child._execute(tick);
	        }

	        nodeMemory.$runningChild = (status === RUNNING$1) ? childIndex : -1;
	        return status;
	    }

	    abortChildren(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var child = this.children[nodeMemory.$runningChild];
	        if (child) {
	            child._abort(tick);
	            nodeMemory.$runningChild = -1;
	        }
	    }
	}

	class Sequence extends Composite {
	    constructor(
	        {
	            children = [],
	            services,
	            title,
	            name = 'Sequence'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                children,
	                services,
	                title,
	                name,
	            },
	            nodePool
	        );

	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$runningChild = 0;
	    }

	    tick(tick) {
	        if (this.children.length === 0) {
	            return ERROR$1;
	        }

	        var nodeMemory = this.getNodeMemory(tick);

	        var childIndex = nodeMemory.$runningChild;
	        var status;
	        for (var i = childIndex, cnt = this.children.length; i < cnt; i++) {
	            status = this.children[i]._execute(tick);

	            if ((status === RUNNING$1) || (status === FAILURE) || (status === ABORT)) {
	                break;
	            }
	        }

	        nodeMemory.$runningChild = (status === RUNNING$1) ? i : -1;
	        return status;
	    }

	    abortChildren(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var child = this.children[nodeMemory.$runningChild];
	        if (child) {
	            child._abort(tick);
	            nodeMemory.$runningChild = -1;
	        }
	    }
	}

	/**
	 * @author       Richard Davey <rich@photonstorm.com>
	 * @copyright    2018 Photon Storm Ltd.
	 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
	 */

	/**
	 * Removes a single item from an array and returns it without creating gc, like the native splice does.
	 * Based on code by Mike Reinstein.
	 *
	 * @function Phaser.Utils.Array.SpliceOne
	 * @since 3.0.0
	 *
	 * @param {array} array - The array to splice from.
	 * @param {integer} index - The index of the item which should be spliced.
	 *
	 * @return {*} The item which was spliced (removed).
	 */
	var SpliceOne$2 = function (array, index)
	{
	    if (index >= array.length)
	    {
	        return;
	    }

	    var len = array.length - 1;

	    var item = array[index];

	    for (var i = index; i < len; i++)
	    {
	        array[i] = array[i + 1];
	    }

	    array.length = len;

	    return item;
	};

	/**
	 * @author       Richard Davey <rich@photonstorm.com>
	 * @copyright    2019 Photon Storm Ltd.
	 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
	 */


	/**
	 * Removes the given item, or array of items, from the array.
	 * 
	 * The array is modified in-place.
	 * 
	 * You can optionally specify a callback to be invoked for each item successfully removed from the array.
	 *
	 * @function Phaser.Utils.Array.Remove
	 * @since 3.4.0
	 *
	 * @param {array} array - The array to be modified.
	 * @param {*|Array.<*>} item - The item, or array of items, to be removed from the array.
	 * @param {function} [callback] - A callback to be invoked for each item successfully removed from the array.
	 * @param {object} [context] - The context in which the callback is invoked.
	 *
	 * @return {*|Array.<*>} The item, or array of items, that were successfully removed from the array.
	 */
	var Remove$3 = function (array, item, callback, context)
	{
	    if (context === undefined) { context = array; }

	    var index;

	    //  Fast path to avoid array mutation and iteration
	    if (!Array.isArray(item))
	    {
	        index = array.indexOf(item);

	        if (index !== -1)
	        {
	            SpliceOne$2(array, index);

	            if (callback)
	            {
	                callback.call(context, item);
	            }

	            return item;
	        }
	        else
	        {
	            return null;
	        }
	    }

	    //  If we got this far, we have an array of items to remove

	    var itemLength = item.length - 1;

	    while (itemLength >= 0)
	    {
	        var entry = item[itemLength];

	        index = array.indexOf(entry);

	        if (index !== -1)
	        {
	            SpliceOne$2(array, index);

	            if (callback)
	            {
	                callback.call(context, entry);
	            }
	        }
	        else
	        {
	            //  Item wasn't found in the array, so remove it from our return results
	            item.pop();
	        }

	        itemLength--;
	    }

	    return item;
	};

	class Parallel extends Composite {
	    constructor(
	        {
	            finishMode = 0,
	            returnSuccess = true,
	            children = [],
	            services,
	            title,
	            name = 'Parallel'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                children,
	                services,
	                title,
	                name,
	                properties: {
	                    finishMode,
	                    returnSuccess
	                },
	            },
	            nodePool
	        );

	        this.finishMode = finishMode;
	        this.returnSuccess = returnSuccess;
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$runningChildren = this.children.map((child, index) => index);
	    }

	    tick(tick) {
	        if (this.children.length === 0) {
	            return ERROR$1;
	        }

	        var nodeMemory = this.getNodeMemory(tick);
	        var childIndexes = nodeMemory.$runningChildren;
	        var statusMap = {};
	        var hasAnyFinishStatus = false;
	        var hasAnyRunningStatus = false;
	        var hasAnyAbortStatus = false;
	        var hasAnyErrorStatus = false;
	        for (var i = 0, cnt = childIndexes.length; i < cnt; i++) {
	            var childIndex = childIndexes[i];
	            var status = this.children[childIndex]._execute(tick);
	            statusMap[childIndex] = status;

	            if (childIndex === 0) {
	                nodeMemory.$mainTaskStatus = status;
	            }

	            switch (status) {
	                case SUCCESS$1:
	                case FAILURE:
	                    hasAnyFinishStatus = true;
	                    break;

	                case RUNNING$1:
	                    hasAnyRunningStatus = true;
	                    break;

	                case ABORT:
	                    hasAnyAbortStatus = true;
	                    break;

	                case ERROR$1:
	                    hasAnyErrorStatus = true;
	                    break;
	            }
	        }

	        // Clear none-running child
	        if (hasAnyFinishStatus) {
	            for (var childIndex in statusMap) {
	                var status = statusMap[childIndex];
	                if ((status === SUCCESS$1) || (status === FAILURE)) {
	                    Remove$3(childIndexes, parseInt(childIndex));
	                }
	            }
	        }

	        if (this.finishMode === 0) {
	            return nodeMemory.$mainTaskStatus;
	        } else {
	            if (hasAnyErrorStatus) {
	                return ERROR$1;
	            } else if (hasAnyAbortStatus) {
	                return ABORT;
	            } else if (hasAnyRunningStatus) {
	                return RUNNING$1;
	            } else if (this.returnSuccess) {
	                return SUCCESS$1;
	            } else {
	                return nodeMemory.$mainTaskStatus;
	            }
	        }
	    }

	    abortChildren(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var childIndexes = nodeMemory.$runningChildren;
	        for (var i = 0, cnt = childIndexes.length; i < cnt; i++) {
	            var childIndex = childIndexes[i];
	            this.children[childIndex]._abort(tick);
	        }
	        nodeMemory.$runningChildren.length = 0;
	    }
	}

	class IfSelector extends Composite {
	    constructor(
	        {
	            expression = 'true',
	            conditionEvalBreak = false,
	            children = [],
	            services,
	            title,
	            name = 'IfSelector'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                children: children,
	                services,
	                title,
	                name,
	                properties: {
	                    expression,
	                    conditionEvalBreak,
	                },
	            },
	            nodePool
	        );

	        this.expression = this.addBooleanExpression(expression);
	        this.conditionEvalBreak = conditionEvalBreak;
	        this.forceSelectChildIndex = undefined;
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$runningChild = -1;  // No running child
	    }

	    setSelectChildIndex(index) {
	        this.forceSelectChildIndex = index;
	        return this;
	    }

	    evalCondition(tick) {
	        if (this.forceSelectChildIndex !== undefined) {
	            return this.forceSelectChildIndex;
	        }

	        return tick.evalExpression(this.expression) ? 0 : 1;
	    }

	    tick(tick) {
	        if (this.children.length === 0) {
	            return ERROR$1;
	        }

	        var nodeMemory = this.getNodeMemory(tick);
	        var childIndex = nodeMemory.$runningChild;
	        if (childIndex < 0) {
	            childIndex = this.evalCondition(tick);
	            if (this.conditionEvalBreak) {
	                // Resolve runningChild index, but not run child now
	                nodeMemory.$runningChild = childIndex;
	                return RUNNING$1;
	            }
	        }

	        var child = this.children[childIndex];
	        var status = child._execute(tick);
	        nodeMemory.$runningChild = (status === RUNNING$1) ? childIndex : -1;

	        return status;
	    }

	    abortChildren(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var child = this.children[nodeMemory.$runningChild];
	        if (child) {
	            child._abort(tick);
	            nodeMemory.$runningChild = -1;
	        }
	    }
	}

	class SwitchSelector extends Composite {
	    constructor(
	        {
	            expression = null,
	            keys = undefined, // Or [key, ...]
	            conditionEvalBreak = false,
	            children = {},    // Or [child, ...]
	            services,
	            title,
	            name = 'SwitchSelector'
	        } = {},
	        nodePool
	    ) {

	        if (keys === undefined) {
	            keys = Object.keys(children);
	            children = Object.values(children);
	        }

	        super(
	            {
	                children: children,
	                services,
	                title,
	                name,
	                properties: {
	                    expression,
	                    keys,
	                    conditionEvalBreak,
	                },
	            },
	            nodePool
	        );

	        this.expression = this.addExpression(expression);
	        this.keys = keys;  // Index of children
	        this.conditionEvalBreak = conditionEvalBreak;
	        this.forceSelectChildIndex = undefined;
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$runningChild = -1;  // No running child
	    }

	    setSelectChildIndex(index) {
	        this.forceSelectChildIndex = index;
	        return this;
	    }

	    evalCondition(tick) {
	        if (this.forceSelectChildIndex !== undefined) {
	            if (typeof (this.forceSelectChildIndex) === 'number') {
	                return this.forceSelectChildIndex;
	            } else {
	                return this.keys.indexOf(this.forceSelectChildIndex);
	            }
	        }

	        var key = tick.evalExpression(this.expression);
	        return this.keys.indexOf(key);
	    }

	    tick(tick) {
	        if (this.children.length === 0) {
	            return ERROR$1;
	        }

	        var nodeMemory = this.getNodeMemory(tick);
	        var childIndex = nodeMemory.$runningChild;
	        if (childIndex < 0) {
	            childIndex = this.evalCondition(tick);
	            if (childIndex === -1) {
	                childIndex = this.keys.indexOf('default');
	            }
	            if (childIndex === -1) {
	                return ERROR$1;
	            }
	            if (this.conditionEvalBreak) {
	                // Resolve runningChild index, but not run child now
	                nodeMemory.$runningChild = childIndex;
	                return RUNNING$1;
	            }
	        }

	        var child = this.children[childIndex];
	        var status = child._execute(tick);
	        nodeMemory.$runningChild = (status === RUNNING$1) ? childIndex : -1;
	        return status;
	    }

	    abortChildren(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var child = this.children[nodeMemory.$runningChild];
	        if (child) {
	            child._abort(tick);
	            nodeMemory.$runningChild = -1;
	        }
	    }
	}

	class WeightSelector extends Composite {
	    constructor(
	        {
	            expression = null,
	            weights = undefined,    // Or [weight, ...]
	            conditionEvalBreak = false,
	            children = [],          // [node, ...], or [{weight, node}, ...]
	            services,
	            title,
	            name = 'WeightSelector'
	        } = {},
	        nodePool
	    ) {

	        if (weights === undefined) {
	            weights = [];

	            var totalWeight = 0;
	            for (var i = 0, cnt = children.length; i < cnt; i++) {
	                var child = children[i];
	                var weight;
	                if ((child instanceof BaseNode) || (typeof (child) === 'string')) {
	                    weight = 1;
	                } else {
	                    weight = child.weight;
	                    children[i] = child.node;
	                }
	                weights.push(weight);
	                totalWeight += weight;
	            }
	            for (var i = 0, cnt = weights.length; i < cnt; i++) {
	                weights[i] /= totalWeight;
	            }
	        }

	        super(
	            {
	                children: children,
	                services,
	                title,
	                name,
	                properties: {
	                    expression,
	                    weights,
	                    conditionEvalBreak,
	                },
	            },
	            nodePool
	        );

	        this.expression = (expression) ? this.addExpression(expression) : null;
	        this.weights = weights;
	        this.conditionEvalBreak = conditionEvalBreak;
	        this.forceSelectChildIndex = undefined;
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$runningChild = -1;  // No running child
	    }

	    setSelectChildIndex(index) {
	        if (this.forceSelectChildIndex !== undefined) {
	            return this.forceSelectChildIndex;
	        }

	        this.forceSelectChildIndex = index;
	        return this;
	    }

	    evalCondition(tick) {
	        if (this.forceSelectChildIndex !== undefined) {
	            return this.forceSelectChildIndex;
	        }

	        var value = (this.expression) ? tick.evalExpression(this.expression) : Math.random();
	        for (var i = 0, cnt = this.weights.length; i < cnt; i++) {
	            value -= this.weights[i];
	            if (value < 0) {
	                return i;
	            }
	        }
	    }

	    tick(tick) {
	        if (this.children.length === 0) {
	            return ERROR$1;
	        }

	        var nodeMemory = this.getNodeMemory(tick);
	        var childIndex = nodeMemory.$runningChild;
	        if (childIndex < 0) {
	            childIndex = this.evalCondition(tick);
	            if (childIndex === undefined) {
	                childIndex = this.children.length - 1;
	            }
	            if (this.conditionEvalBreak) {
	                // Resolve runningChild index, but not run child now
	                nodeMemory.$runningChild = childIndex;
	                return RUNNING$1;
	            }
	        }

	        var child = this.children[childIndex];
	        var status = child._execute(tick);
	        nodeMemory.$runningChild = (status === RUNNING$1) ? childIndex : -1;
	        return status;
	    }

	    abortChildren(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var child = this.children[nodeMemory.$runningChild];
	        if (child) {
	            child._abort(tick);
	            nodeMemory.$runningChild = -1;
	        }
	    }
	}

	class RandomSelector extends Composite {
	    constructor(
	        {
	            children = [],
	            services,
	            title,
	            name = 'RandomSelector'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                children,
	                services,
	                title,
	                name,
	            },
	            nodePool
	        );

	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$runningChild = -1;  // No running child
	    }

	    tick(tick) {
	        if (this.children.length === 0) {
	            return ERROR;
	        }

	        var nodeMemory = this.getNodeMemory(tick);
	        var childIndex = nodeMemory.$runningChild;
	        if (childIndex < 0) {
	            childIndex = Math.floor(Math.random() * this.children.length);
	        }

	        var child = this.children[childIndex];
	        var status = child._execute(tick);
	        nodeMemory.$runningChild = (status === RUNNING) ? childIndex : -1;
	        return status;
	    }

	    abortChildren(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var child = this.children[nodeMemory.$runningChild];
	        if (child) {
	            child._abort(tick);
	            nodeMemory.$runningChild = -1;
	        }
	    }
	}

	/**
	 * @author       Richard Davey <rich@photonstorm.com>
	 * @copyright    2018 Photon Storm Ltd.
	 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
	 */

	/**
	 * Shuffles the contents of the given array using the Fisher-Yates implementation.
	 *
	 * The original array is modified directly and returned.
	 *
	 * @function Phaser.Utils.Array.Shuffle
	 * @since 3.0.0
	 *
	 * @param {array} array - The array to shuffle. This array is modified in place.
	 *
	 * @return {array} The shuffled array.
	 */
	var Shuffle = function (array) {
	    for (var i = array.length - 1; i > 0; i--) {
	        var j = Math.floor(Math.random() * (i + 1));
	        var temp = array[i];
	        array[i] = array[j];
	        array[j] = temp;
	    }

	    return array;
	};

	class ShuffleSelector extends Composite {
	    constructor(
	        {
	            children = [],
	            services,
	            title,
	            name = 'ShuffleSelector'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                children,
	                services,
	                title,
	                name,
	            },
	            nodePool
	        );

	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$runningChild = 0;

	        if (!nodeMemory.$children) {
	            nodeMemory.$children = this.children.map((child, index) => index);
	        }
	        Shuffle(nodeMemory.$children);
	    }

	    tick(tick) {
	        if (this.children.length === 0) {
	            return ERROR$1;
	        }

	        var nodeMemory = this.getNodeMemory(tick);

	        var childIndex = nodeMemory.$runningChild;
	        var children = nodeMemory.$children;
	        var status;
	        for (var i = childIndex, cnt = children.length; i < cnt; i++) {
	            status = this.children[children[i]]._execute(tick);

	            if ((status === RUNNING$1) || (status === SUCCESS$1) || (status === ABORT)) {
	                break;
	            }
	        }

	        nodeMemory.$runningChild = (status === RUNNING$1) ? i : -1;
	        return status;
	    }

	    abortChildren(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        var child = this.children[nodeMemory.$runningChild];
	        if (child) {
	            child._abort(tick);
	            nodeMemory.$runningChild = -1;
	        }
	    }
	}

	class Bypass extends Decorator {

	    constructor(
	        {
	            child = null,
	            title,
	            name = 'Bypass'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	            },
	            nodePool
	        );
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // Won't abort child
	        var status = this.child._execute(tick);

	        return status;
	    }
	}

	class ForceSuccess extends Decorator {

	    constructor(
	        {
	            child = null,
	            title,
	            name = 'ForceSuccess'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                },
	            },
	            nodePool
	        );
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        var status = this.child._execute(tick);

	        if (status === FAILURE) {
	            return SUCCESS$1;
	        }

	        return status;
	    }
	}

	class ForceFailure extends Decorator {

	    constructor(
	        {
	            child = null,
	            title,
	            name = 'ForceFailure'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                },
	            },
	            nodePool
	        );

	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        var status = this.child._execute(tick);

	        if (status === SUCCESS$1) {
	            return FAILURE;
	        }

	        return status;
	    }
	}

	class Invert extends Decorator {
	    constructor(
	        {
	            child = null,
	            title,
	            name = 'Invert'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	            },
	            nodePool
	        );
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        var status = this.child._execute(tick);

	        if (status === SUCCESS$1) {
	            status = FAILURE;
	        } else if (status === FAILURE) {
	            status = SUCCESS$1;
	        }

	        return status;
	    }
	}

	class TimeLimit extends Decorator {
	    constructor(
	        {
	            duration = 0,
	            returnSuccess = true,
	            child = null,
	            title,
	            name = 'TimeLimit'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    duration,
	                    returnSuccess
	                },
	            },
	            nodePool
	        );

	        this.durationExpression = this.addExpression(duration);
	        this.returnSuccess = returnSuccess;
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$startTime = tick.currentTime;
	        nodeMemory.$duration = tick.evalExpression(this.durationExpression);
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // Abort child when timeout
	        var nodeMemory = this.getNodeMemory(tick);
	        var currTime = tick.currentTime;
	        var startTime = nodeMemory.$startTime;
	        var duration = nodeMemory.$duration;

	        if ((currTime - startTime) >= duration) {
	            return (this.returnSuccess) ? SUCCESS : FAILURE;
	        }

	        var status = this.child._execute(tick);

	        return status;
	    }
	}

	let Cooldown$1 = class Cooldown extends Decorator {
	    constructor(
	        {
	            duration = 0,
	            child = null,
	            title,
	            name = 'Cooldown'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    duration
	                },
	            },
	            nodePool
	        );

	        this.durationExpression = this.addExpression(duration);
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$cooldownTime = tick.evalExpression(this.durationExpression);
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // Won't abort child
	        var nodeMemory = this.getNodeMemory(tick);
	        var currTime = tick.currentTime;
	        var lastEndTime = nodeMemory.$lastEndTime;
	        var cooldownTime = nodeMemory.$cooldownTime;

	        // Open child after cooldown timeout
	        if (
	            (lastEndTime !== undefined) &&
	            ((currTime - lastEndTime) < cooldownTime)
	        ) {
	            return FAILURE;
	        }

	        var status = this.child._execute(tick);

	        if ((status === SUCCESS$1) || (status === FAILURE) || (status === ABORT)) {
	            nodeMemory.$lastEndTime = currTime;
	        }

	        return status;
	    }
	};

	class Repeat extends Decorator {

	    constructor(
	        {
	            maxLoop = -1,
	            child = null,
	            title,
	            name = 'Repeat'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    maxLoop
	                },
	            },
	            nodePool
	        );

	        this.maxLoopExpression = this.addExpression(maxLoop);
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$maxLoop = tick.evalExpression(this.maxLoopExpression);
	        nodeMemory.$i = 0;
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        var nodeMemory = this.getNodeMemory(tick);
	        var maxLoop = nodeMemory.$maxLoop;
	        var i = nodeMemory.$i;
	        var status = SUCCESS$1;

	        // Open child before exceed maxLoop
	        // Execute child many times in a tick
	        while (maxLoop < 0 || i < maxLoop) {
	            status = this.child._execute(tick);

	            if ((status === SUCCESS$1) || (status === FAILURE)) {
	                i++;
	            } else {
	                break;
	            }
	        }

	        nodeMemory.$i = i;
	        return status;
	    }
	}

	class RepeatUntilFailure extends Decorator {

	    constructor(
	        {
	            maxLoop = -1,
	            returnSuccess = false,
	            child = null,
	            title,
	            name = 'RepeatUntilFailure',
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    returnSuccess,
	                    maxLoop
	                },
	            },
	            nodePool
	        );

	        this.maxLoopExpression = this.addExpression(maxLoop);
	        this.returnSuccess = returnSuccess;
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$maxLoop = tick.evalExpression(this.maxLoopExpression);
	        nodeMemory.$i = 0;
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // Won't abort child
	        var nodeMemory = this.getNodeMemory(tick);
	        var maxLoop = nodeMemory.$maxLoop;
	        var i = nodeMemory.$i;
	        var status = ERROR$1;

	        // Open child before exceed maxLoop
	        // Execute child many times in a tick
	        while ((maxLoop < 0) || (i < maxLoop)) {
	            status = this.child._execute(tick);

	            if (status === SUCCESS$1) {
	                i++;
	            } else {
	                break;
	            }
	        }

	        nodeMemory.$i = i;

	        if ((status === this.FAILURE) && this.returnSuccess) {
	            status = SUCCESS$1;
	        }

	        return status;
	    }
	}

	class RepeatUntilSuccess extends Decorator {

	    constructor(
	        {
	            maxLoop = -1,
	            child = null,
	            title,
	            name = 'RepeatUntilSuccess'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    maxLoop
	                },
	            },
	            nodePool
	        );

	        this.maxLoopExpression = this.addExpression(maxLoop);
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$maxLoop = tick.evalExpression(this.maxLoopExpression);
	        nodeMemory.$i = 0;
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // Won't abort child
	        var nodeMemory = this.getNodeMemory(tick);
	        var maxLoop = nodeMemory.$maxLoop;
	        var i = nodeMemory.$i;
	        var status = ERROR$1;

	        // Open child before exceed maxLoop
	        // Execute child many times in a tick
	        while (maxLoop < 0 || i < maxLoop) {
	            status = this.child._execute(tick);

	            if (status === FAILURE) {
	                i++;
	            } else {
	                break;
	            }
	        }

	        nodeMemory.$i = i;
	        return status;
	    }
	}

	class Limiter extends Decorator {

	    constructor(
	        {
	            maxLoop = 1,
	            child = null,
	            title,
	            name = 'Limiter'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    maxLoop
	                },
	            },
	            nodePool
	        );

	        this.maxLoopExpression = this.addExpression(maxLoop);
	    }

	    open(tick) {
	        var nodeMemory = this.getNodeMemory(tick);
	        nodeMemory.$maxLoop = tick.evalExpression(this.maxLoopExpression);
	        nodeMemory.$i = 0;
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // Won't abort child
	        var nodeMemory = this.getNodeMemory(tick);
	        var maxLoop = nodeMemory.$maxLoop;
	        var i = nodeMemory.$i;

	        // Open child before exceed maxLoop
	        // Execute child 1 time in a tick
	        if (i >= maxLoop) {
	            return FAILURE;
	        }

	        var status = this.child._execute(tick);
	        if ((status === SUCCESS$1) || (status === FAILURE)) {
	            nodeMemory.$i = i + 1;
	        }

	        return status;
	    }
	}

	class If extends Decorator {

	    constructor(
	        {
	            expression = 'true',
	            conditionEvalBreak = false,
	            child = null,
	            title,
	            name = 'If'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    expression,
	                    conditionEvalBreak
	                },
	            },
	            nodePool
	        );

	        this.expression = this.addBooleanExpression(expression);
	        this.conditionEvalBreak = conditionEvalBreak;
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // child is not running
	        if (!this.isChildRunning(tick)) {
	            // Return FAILURE to run next node
	            if (!tick.evalExpression(this.expression)) {
	                return FAILURE;
	            } else if (this.conditionEvalBreak) {
	                // Open child but not run it now
	                this.openChild();
	                return RUNNING;
	            }
	        }

	        var status = this.child._execute(tick);

	        return status;
	    }
	}

	class ContinueIf extends Decorator {

	    constructor(
	        {
	            expression = 'true',
	            returnSuccess = true,
	            child = null,
	            title,
	            name = 'ContinueIf'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    expression,
	                    returnSuccess,
	                },
	            },
	            nodePool
	        );

	        this.expression = this.addBooleanExpression(expression);
	        this.returnSuccess = returnSuccess;
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // child is running
	        if (this.isChildRunning(tick)) {
	            // Abort child if eval result is false
	            if (!tick.evalExpression(this.expression)) {
	                return (this.returnSuccess) ? SUCCESS$1 : FAILURE;
	            }
	        }

	        var status = this.child._execute(tick);

	        return status;
	    }
	}

	class AbortIf extends Decorator {

	    constructor(
	        {
	            expression = 'true',
	            returnSuccess = true,
	            child = null,
	            title,
	            name = 'AbortIf'
	        } = {},
	        nodePool
	    ) {

	        super(
	            {
	                child,
	                title,
	                name,
	                properties: {
	                    expression,
	                    returnSuccess,
	                },
	            },
	            nodePool
	        );

	        this.expression = this.addBooleanExpression(expression);
	        this.returnSuccess = returnSuccess;
	    }

	    tick(tick) {
	        if (!this.child) {
	            return ERROR$1;
	        }

	        // child is running
	        if (this.isChildRunning(tick)) {
	            // Abort child if eval result is true
	            if (tick.evalExpression(this.expression)) {
	                return (this.returnSuccess) ? SUCCESS$1 : FAILURE;
	            }
	        }

	        var status = this.child._execute(tick);

	        return status;
	    }
	}

	var Nodes = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Abort: Abort,
		AbortIf: AbortIf,
		Action: Action,
		BaseNode: BaseNode,
		Bypass: Bypass,
		Composite: Composite,
		ContinueIf: ContinueIf,
		Cooldown: Cooldown$1,
		Decorator: Decorator,
		Error: Error$1,
		Failer: Failer,
		ForceFailure: ForceFailure,
		ForceSuccess: ForceSuccess,
		If: If,
		IfSelector: IfSelector,
		Invert: Invert,
		Limiter: Limiter,
		Parallel: Parallel,
		RandomSelector: RandomSelector,
		Repeat: Repeat,
		RepeatUntilFailure: RepeatUntilFailure,
		RepeatUntilSuccess: RepeatUntilSuccess,
		Runner: Runner,
		Selector: Selector,
		Sequence: Sequence,
		Service: Service,
		ShuffleSelector: ShuffleSelector,
		Succeeder: Succeeder,
		SwitchSelector: SwitchSelector,
		TimeLimit: TimeLimit,
		Wait: Wait,
		WeightSelector: WeightSelector
	});

	var Load = function (data, names) {
	    var sn = data.sn;
	    if (sn != null) {
	        SetSerialNumber(Math.max(GetSerialNumber(), sn));
	    }

	    names = names || {};

	    this.title = data.title || this.title;
	    this.description = data.description || this.description;
	    this.properties = data.properties || this.properties;

	    var nodeData = data.nodes;
	    var nodes = {};
	    for (var i = nodeData.length - 1; i >= 0; i--) {
	        // Create nodes from bottom to top
	        var spec = nodeData[i],
	            className = spec.name;

	        var Cls;
	        if (className in names) {
	            // Look for the name in custom nodes
	            Cls = names[className];
	        } else if (className in Nodes) {
	            // Look for the name in default nodes
	            Cls = Nodes[className];
	        } else {
	            // Invalid node name
	            throw new EvalError(`BehaviorTree.load: Invalid node name "${className}".`);
	        }

	        var config = {};
	        if (spec.hasOwnProperty('children')) {
	            config.children = spec.children;
	        }
	        if (spec.hasOwnProperty('child')) {
	            config.child = spec.child;
	        }
	        if (spec.hasOwnProperty('services')) {
	            config.services = spec.services;
	        }

	        config = Object.assign(
	            config,
	            spec.properties,
	        );

	        var node = new Cls(config, nodes);
	        node.id = spec.id || node.id;
	        node.title = spec.title || node.title;
	        node.description = spec.description || node.description;
	        node.properties = spec.properties || node.properties;

	        nodes[node.id] = node;
	    }

	    this.root = nodes[data.root];

	    return this;
	};

	class Tick {

	    constructor() {
	        // set by BehaviorTree

	        this.tree = null;

	        this.blackboard = null;

	        this.target = null;

	        // updated during the tick signal

	        this._openNodes = [];  // Open nodes of current tick

	        this._nodeCount = 0;

	        this._currentNode = null;

	        this._currentTime = undefined;
	    }

	    destroy() {
	        this.tree = null;
	        this.blackboard = null;
	        this.target = null;
	        this._openNodes.length = 0;
	    }

	    // Set members
	    setTree(tree) {
	        this.tree = tree;
	        return this;
	    }

	    setBlackBoard(blackboard) {
	        this.blackboard = blackboard;
	        return this;
	    }

	    setTarget(target) {
	        this.target = target;
	        return this;
	    }

	    reset() {
	        this._openNodes.length = 0;
	        this._nodeCount = 0;
	        this._currentTime = undefined;
	        return this;
	    }

	    getGlobalMemory() {
	        return this.blackboard.getGlobalMemory();
	    }

	    getTreeMemory() {
	        return this.blackboard.getTreeMemory(this.tree.id);
	    }

	    getNodeMemory(nodeID) {
	        return this.blackboard.getNodeMemory(this.tree.id, nodeID);
	    }

	    get currentTime() {
	        if (this.blackboard.hasValidCurrentTime()) {
	            // Inject current-time through blackboard
	            return this.blackboard.getCurrentTime();
	        } else {
	            if (this._currentTime === undefined) {
	                this._currentTime = (new Date()).getTime();
	            }
	            return this._currentTime;
	        }
	    }

	    evalExpression(expression) {
	        return expression.eval(this.blackboard.getGlobalMemory());
	    }

	    _enterNode(node) {
	        this._nodeCount++;
	        this._openNodes.push(node);
	        this._currentNode = node;
	    }

	    _openNode(node) {
	        this._currentNode = node;
	    }

	    _tickNode(node) {
	        this._currentNode = node;
	    }

	    _closeNode(node) {
	        Remove$3(this._openNodes, node);
	        this._currentNode = node;
	    }

	    _exitNode(node) {
	        this._currentNode = node;
	    }
	}

	class BehaviorTree {

	    constructor(
	        {
	            id,
	            title,
	            description,
	            properties,
	            root = null
	        } = {}
	    ) {

	        if (id === undefined) {
	            id = CreateID();
	        }

	        this.id = id;

	        this.category = TREE;

	        this.title = title || '';

	        this.description = description || '';

	        this.properties = properties || {};

	        this._root = root;

	        this.ticker = (new Tick()).setTree(this);
	    }

	    destroy() {
	        this._root.destroy();
	        this.ticker.destroy();

	        this._root = undefined;
	        this.ticker = undefined;
	    }

	    setTitle(title) {
	        this.title = title;
	        return this;
	    }

	    setName(name) {
	        this.name = name;
	        return this;
	    }

	    setDescription(description) {
	        this.description = description;
	        return this;
	    }

	    setRoot(node) {
	        this.root = node;
	        return this;
	    }

	    getRoot() {
	        return this.root;
	    }

	    get root() {
	        return this._root;
	    }

	    set root(node) {
	        if (node) {
	            this._root = node;
	            node.setParent(this);
	        } else {
	            if (this._root) {
	                this._root.setParent(null);
	            }
	            this._root = null;
	        }
	    }

	    forEachNode(callback, scope) {
	        BreadthFirstSearch$1(this.root, callback, scope);
	        return this;
	    }

	    getAllNodes(out) {
	        if (out === undefined) {
	            out = [];
	        }
	        this.forEachNode(function (node) {
	            out.push(node);
	        });
	        return out;
	    }

	    getChildrenNodes(parent, out) {
	        if (parent === undefined) {
	            parent = this.root;
	        }
	        if (out === undefined) {
	            out = [];
	        }

	        BreadthFirstSearch$1(parent, function (node) {
	            out.push(node);
	        });

	        return out;
	    }

	    tick(blackboard, target) {
	        if (!blackboard) {
	            throw 'The blackboard parameter is obligatory and must be an instance of Blackboard';
	        }

	        var ticker = this.ticker;
	        ticker
	            .setBlackBoard(blackboard)
	            .setTarget(target)
	            .reset();

	        /* TICK NODE */
	        var state = this.root._execute(ticker);

	        /* POPULATE BLACKBOARD */
	        // blackboard.set('$openNodes', ticker._openNodes.slice(0), this.id);
	        // blackboard.set('$nodeCount', ticker._nodeCount, this.id);
	        blackboard.set(TREE_STATE, state, this.id);

	        return state;
	    }

	    abort(blackboard, target) {
	        if (!blackboard) {
	            throw 'The blackboard parameter is obligatory and must be an instance of Blackboard';
	        }

	        var ticker = this.ticker;
	        ticker
	            .setBlackBoard(blackboard)
	            .setTarget(target)
	            .reset();

	        /* ABORT NODE */
	        this.root.abortChildren(ticker);

	        /* POPULATE BLACKBOARD */
	        blackboard.set(TREE_STATE, IDLE$7, this.id);

	        return IDLE$7;
	    }

	    static setStartIDValue(value) {
	        SetSerialNumber(value);
	    }

	    static getSerialNumber() {
	        return GetSerialNumber();
	    }

	    static setSerialIDPrefix(prefix) {
	        SetSerialNumberPrefix(prefix);
	    }
	}
	var Methods$h = {
	    dump: Dump,
	    load: Load,
	};
	Object.assign(
	    BehaviorTree.prototype,
	    Methods$h,
	    DataMethods$5,
	);

	var IsInValidKey$1 = function (keys) {
	    return (keys == null) || (keys === '') || (keys.length === 0);
	};

	var GetEntry$1 = function (target, keys, defaultEntry) {
	    var entry = target;
	    if (IsInValidKey$1(keys)) ; else {
	        if (typeof (keys) === 'string') {
	            keys = keys.split('.');
	        }

	        var key;
	        for (var i = 0, cnt = keys.length; i < cnt; i++) {
	            key = keys[i];
	            if ((entry[key] == null) || (typeof (entry[key]) !== 'object')) {
	                var newEntry;
	                if (i === cnt - 1) {
	                    if (defaultEntry === undefined) {
	                        newEntry = {};
	                    } else {
	                        newEntry = defaultEntry;
	                    }
	                } else {
	                    newEntry = {};
	                }

	                entry[key] = newEntry;
	            }

	            entry = entry[key];
	        }
	    }

	    return entry;
	};

	var SetValue = function (target, keys, value, delimiter) {
	    if (delimiter === undefined) {
	        delimiter = '.';
	    }

	    // no object
	    if (typeof (target) !== 'object') {
	        return;
	    }

	    // invalid key
	    else if (IsInValidKey$1(keys)) {
	        // don't erase target
	        if (value == null) {
	            return;
	        }
	        // set target to another object
	        else if (typeof (value) === 'object') {
	            target = value;
	        }
	    } else {
	        if (typeof (keys) === 'string') {
	            keys = keys.split(delimiter);
	        }

	        var lastKey = keys.pop();
	        var entry = GetEntry$1(target, keys);
	        entry[lastKey] = value;
	    }

	    return target;
	};

	var GetValue$2b = function (source, key, defaultValue) {
	    if (!source || typeof source === 'number') {
	        return defaultValue;
	    }

	    if (typeof (key) === 'string') {
	        if (source.hasOwnProperty(key)) {
	            return source[key];
	        }
	        if (key.indexOf('.') !== -1) {
	            key = key.split('.');
	        } else {
	            return defaultValue;
	        }
	    }

	    var keys = key;
	    var parent = source;
	    var value = defaultValue;

	    //  Use for loop here so we can break early
	    for (var i = 0; i < keys.length; i++) {
	        key = keys[i];
	        if (parent.hasOwnProperty(key)) {
	            //  Yes it has a key property, let's carry on down
	            value = parent[key];

	            parent = value;
	        }
	        else {
	            //  Can't go any further, so reset to default
	            value = defaultValue;
	            break;
	        }
	    }

	    return value;
	};

	var HasValue = function (source, key) {
	    if (!source || typeof source === 'number') {
	        return false;
	    }
	    else if (source.hasOwnProperty(key)) {
	        return true;
	    }
	    else if (key.indexOf('.') !== -1) {
	        var keys = key.split('.');
	        var parent = source;

	        //  Use for loop here so we can break early
	        for (var i = 0; i < keys.length; i++) {
	            if (parent.hasOwnProperty(keys[i])) {
	                parent = parent[keys[i]];
	            }
	            else {
	                //  Can't go any further
	                return false;
	            }
	        }

	        return true;
	    }
	    else {
	        return false;
	    }
	};

	var IsInValidKey = function (keys) {
	    return (keys == null) || (keys === '') || (keys.length === 0);
	};

	var GetEntry = function (target, keys, defaultEntry) {
	    var entry = target;
	    if (IsInValidKey(keys)) ; else {
	        if (typeof (keys) === 'string') {
	            keys = keys.split('.');
	        }

	        var key;
	        for (var i = 0, cnt = keys.length; i < cnt; i++) {
	            key = keys[i];
	            if ((entry[key] == null) || (typeof (entry[key]) !== 'object')) {
	                return;
	            }

	            entry = entry[key];
	        }
	    }

	    return entry;
	};

	var RemoveKey = function (target, keys, delimiter) {
	    if (delimiter === undefined) {
	        delimiter = '.';
	    }

	    // no object
	    if (typeof (target) !== 'object') {
	        return;
	    }

	    // invalid key
	    else if (IsInValidKey(keys)) ; else {
	        if (typeof (keys) === 'string') {
	            keys = keys.split(delimiter);
	        }

	        var lastKey = keys.pop();
	        var entry = GetEntry(target, keys);
	        if (entry) {
	            delete entry[lastKey];
	        }
	    }

	    return target;
	};

	let Blackboard$1 = class Blackboard {

	    constructor() {
	        this._baseMemory = {};
	        this._treeMemory = {};

	        // Global memory : this._baseMemory
	        // Tree memory : this._treeMemory[treeID]
	        // Node memory : this._treeMemory[treeID].nodeMemory[nodeID]
	    }

	    destroy() {
	        this._baseMemory = undefined;
	        this._treeMemory = undefined;
	    }

	    _getTreeMemory(treeID) {
	        if (!this._treeMemory[treeID]) {
	            this._treeMemory[treeID] = {
	                'nodeMemory': {},
	            };
	        }
	        return this._treeMemory[treeID];
	    }

	    _getNodeMemory(treeMemory, nodeID) {
	        var memory = treeMemory.nodeMemory;
	        if (!memory[nodeID]) {
	            memory[nodeID] = {};
	        }

	        return memory[nodeID];
	    }

	    _getMemory(treeID, nodeID) {
	        var memory;

	        if (treeID !== undefined) {
	            memory = this._getTreeMemory(treeID);

	            if (nodeID !== undefined) {
	                memory = this._getNodeMemory(memory, nodeID);
	            }
	        } else {
	            memory = this._baseMemory;
	        }

	        return memory;
	    }

	    set(key, value, treeID, nodeID) {
	        var memory = this._getMemory(treeID, nodeID);
	        SetValue(memory, key, value);
	        return this;
	    }

	    setData(key, value, treeID, nodeID) {
	        return this.set(key, value, treeID, nodeID);
	    }

	    get(key, treeID, nodeID) {
	        var memory = this._getMemory(treeID, nodeID);
	        return GetValue$2b(memory, key);
	    }

	    getData(key, treeID, nodeID) {
	        return this.get(key, treeID, nodeID);
	    }

	    has(key, treeID, nodeID) {
	        var memory;
	        if (treeID !== undefined) {
	            memory = this._treeMemory[treeID];
	            if (memory && (nodeID !== undefined)) {
	                memory = treeMemory.nodeMemory[nodeID];
	            }
	        } else {
	            memory = this._baseMemory;
	        }

	        if (memory) {
	            return HasValue(memory, key);
	        } else {
	            return false;
	        }
	    }

	    hasData(key, treeID, nodeID) {
	        return this.has(key, treeID, nodeID);
	    }

	    inc(key, inc, treeID, nodeID, startValue) {
	        var newValue;
	        if (!this.has(key, treeID, nodeID)) {
	            if (startValue === undefined) {
	                startValue = 0;
	            }
	            newValue = startValue;
	        } else {
	            newValue = this.get(key, treeID, nodeID) + inc;
	        }
	        this.set(key, newValue, treeID, nodeID);
	        return this;
	    }

	    incData(key, inc, treeID, nodeID, startValue) {
	        return this.inc(key, inc, treeID, nodeID, startValue);
	    }

	    toggle(key, treeID, nodeID, startValue) {
	        var newValue;
	        if (!this.has(key, treeID, nodeID)) {
	            if (startValue === undefined) {
	                startValue = false;
	            }
	            newValue = startValue;
	        } else {
	            newValue = !this.get(key, treeID, nodeID);
	        }
	        this.set(key, newValue, treeID, nodeID);
	        return this;
	    }

	    toggleData(key, treeID, nodeID, startValue) {
	        return this.toggle(key, treeID, nodeID, startValue);
	    }

	    removeData(key, treeID, nodeID) {
	        var memory = this._getMemory(treeID, nodeID);
	        RemoveKey(memory, key);
	    }

	    removeTree(treeID) {
	        if (this._treeMemory[treeID]) {
	            delete this._treeMemory[treeID];
	        }
	        return this;
	    }

	    removeTreeData(treeID) {
	        return this.removeTree(treeID);
	    }

	    removeNode(treeID, nodeID) {
	        var treeMemory = this._treeMemory[treeID];

	        if (treeMemory && treeMemory.nodeMemory[nodeID]) {
	            delete treeMemory.nodeMemory[nodeID];
	        }
	        return this;
	    }

	    removeNodeData(treeID, nodeID) {
	        return this.removeNode(treeID, nodeID);
	    }

	    getGlobalMemory() {
	        return this._baseMemory;
	    }

	    getTreeMemory(treeID) {
	        return this._getTreeMemory(treeID);
	    }

	    getNodeMemory(treeID, nodeID) {
	        return this._getNodeMemory(this._getTreeMemory(treeID), nodeID);
	    }

	    dump() {
	        return {
	            base: DeepClone(this._baseMemory),
	            tree: DeepClone(this._treeMemory),
	        }
	    }

	    load(data) {
	        this._baseMemory = DeepClone(data.base);
	        this._treeMemory = DeepClone(data.tree);
	        return this;
	    }
	};

	class Blackboard extends Blackboard$1 {
	    constructor({
	        currentTimeKey = '$currentTime'
	    } = {}) {
	        super();

	        this.currentTimeKey = currentTimeKey;
	    }

	    getTreeState(treeID) {
	        return this.get(TREE_STATE, treeID);
	    }

	    setTreeState(treeID, state) {
	        this.set(TREE_STATE, state, treeID);
	        return this;
	    }

	    hasValidCurrentTime() {
	        return this.has(this.currentTimeKey)
	    }

	    setCurrentTime(time) {
	        this.set(this.currentTimeKey, time);
	        return this;
	    }

	    getCurrentTime() {
	        return this.get(this.currentTimeKey);
	    }

	    incCurrentTime(time) {
	        this.inc(this.currentTimeKey, time);
	        return this;
	    }


	}

	var PauseEventSheetMethods$1 = {
	    // Internal method
	    bindTaskActionNode(tick, node) {
	        if (!this.__bindTick) {
	            this.__bindTick = [];
	            this.__bindNode = [];
	        }

	        this.__bindTick.push(tick);
	        this.__bindNode.push(node);
	    },

	    // Internal method
	    unBindTaskAction() {
	        if (!this.__bindTick) {
	            return;
	        }

	        this.__bindTick.pop();
	        this.__bindNode.pop();
	    },

	    pauseEventSheet() {
	        var node = this.__bindNode[this.__bindNode.length - 1];
	        if (!node) {
	            return null;
	        }

	        var tick = this.__bindTick[this.__bindTick.length - 1];
	        return node.pauseEventSheet(tick);
	    },

	    pauseEventSheetUnitlEvent(eventEmitter, eventName) {
	        var node = this.__bindNode[this.__bindNode.length - 1];
	        if (!node) {
	            return null;
	        }

	        var tick = this.__bindTick[this.__bindTick.length - 1];
	        node.pauseEventSheetUnitlEvent(tick, eventEmitter, eventName);

	        return this;
	    }
	};

	var TreeMethods$1 = {
	    getTree(title) {
	        var trees = this.trees;
	        for (var i = 0, cnt = trees.length; i < cnt; i++) {
	            var eventsheet = trees[i];
	            if (eventsheet.title === title) {
	                return eventsheet;
	            }
	        }
	    },

	    getTreeState(eventsheet) {
	        var treeID = (typeof (eventsheet) === 'string') ? eventsheet : eventsheet.id;
	        return this.blackboard.getTreeState(treeID);
	    },

	    getEventSheetTitleList(out) {
	        if (out === undefined) {
	            out = [];
	        }
	        this.trees.forEach(function (eventsheet) {
	            out.push(eventsheet.title);
	        });
	        return out;
	    },
	};

	var AddTreeMethods$1 = {
	    addTree(eventsheet) {
	        this.trees.push(eventsheet);
	        return this;
	    },
	};

	var RemoveTreeMethods$1 = {
	    removeAllEventSheets() {
	        this.trees.forEach(function (eventsheet) {
	            this.blackboard.removeTreeData(eventsheet.id);
	        }, this);
	        this.trees.length = 0;
	        this.pendingTrees.length = 0;
	        return this;
	    },

	    removeEventSheet(title) {
	        var removedTrees = [];
	        this.trees.forEach(function (eventsheet) {
	            if (!eventsheet.title === title) {
	                return;
	            }
	            var status = this.getTreeState(eventsheet);
	            if (status === RUNNING) {
	                // Can't remove RUNNING eventsheet
	                return;
	            }

	            removedTrees.push(eventsheet);
	            this.blackboard.removeTreeData(eventsheet.id);
	        }, this);

	        if (removedTrees.length > 0) {
	            Remove$3(this.trees, removedTrees);
	            Remove$3(this.pendingTrees, removedTrees);
	        }

	        return this;
	    },
	};

	var TreeActiveStateMethods$1 = {
	    getTreeActiveState(title) {
	        var eventsheet = this.getTree(title);
	        if (!eventsheet) {
	            return null;
	        }

	        return eventsheet.active;
	    },

	    setTreeActiveState(title, active) {
	        var eventsheet = this.getTree(title);
	        if (eventsheet) {
	            eventsheet.setActive(active);
	        }

	        return this;
	    },
	};

	class TaskSequence extends Sequence {
	    open(tick) {
	        super.open(tick);

	        var blackboard = tick.blackboard;
	        var eventSheetManager = blackboard.eventSheetManager;
	        var eventsheet = tick.tree;
	        var eventSheetGroup = eventsheet.eventSheetGroup;
	        eventSheetManager.emit('label.enter', this.title, eventsheet.title, eventSheetGroup.name, eventSheetManager);

	    }

	    tick(tick) {
	        var status = super.tick(tick);
	        // Turn FAILURE by SUCCESS
	        if (status === FAILURE) {
	            status = SUCCESS$1;
	        }
	        return status;
	    }

	    close(tick) {
	        super.close(tick);

	        var blackboard = tick.blackboard;
	        var eventSheetManager = blackboard.eventSheetManager;
	        var eventsheet = tick.tree;
	        var eventSheetGroup = eventsheet.eventSheetGroup;
	        eventSheetManager.emit('label.exit', this.title, eventsheet.title, eventSheetGroup.name, eventSheetManager);
	    }
	}

	var PauseEventSheetMethods = {
	    // Called by commandExecutor -> eventSheetManager
	    pauseEventSheet(tick) {
	        // Pause eventSheetGroup, wait until eventEmitter fires resumeEventName
	        var eventSheetGroup = tick.tree.eventSheetGroup;

	        // Pause eventSheetGroup
	        this.isRunning = true;

	        var self = this;
	        var waitId = this.waitId;
	        var taskCompleteCallback = function () {
	            // Expired
	            if (waitId < self.waitId) {
	                return;
	            }
	            self.waitId++;

	            // Resume event sheet group
	            self.isRunning = false;
	            eventSheetGroup.continue();
	        };

	        return taskCompleteCallback;
	    },

	    pauseEventSheetUnitlEvent(tick, eventEmitter, eventName = 'complete') {
	        var resumeCallback = this.pauseEventSheet(tick);

	        var self = this;
	        var wrapResumeCallback = function () {
	            self.removeTaskCompleteCallback = undefined;
	            resumeCallback();
	        };

	        // Remove task-complete callback when aborting this node            
	        this.removeTaskCompleteCallback = function () {
	            eventEmitter.off(eventName, wrapResumeCallback);
	            self.removeTaskCompleteCallback = undefined;
	        };

	        eventEmitter.once(eventName, wrapResumeCallback);

	        return this;
	    }
	};

	var IsEventEmitter = function (obj) {
	    if (obj && typeof obj === 'object') {
	        return !!obj.on;
	    }
	    return false;
	};

	/*!
	 * mustache.js - Logic-less {{mustache}} templates with JavaScript
	 * http://github.com/janl/mustache.js
	 */

	var objectToString = Object.prototype.toString;
	var isArray$1 = Array.isArray || function isArrayPolyfill (object) {
	  return objectToString.call(object) === '[object Array]';
	};

	function isFunction$1 (object) {
	  return typeof object === 'function';
	}

	/**
	 * More correct typeof string handling array
	 * which normally returns typeof 'object'
	 */
	function typeStr (obj) {
	  return isArray$1(obj) ? 'array' : typeof obj;
	}

	function escapeRegExp (string) {
	  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
	}

	/**
	 * Null safe way of checking whether or not an object,
	 * including its prototype, has a given property
	 */
	function hasProperty (obj, propName) {
	  return obj != null && typeof obj === 'object' && (propName in obj);
	}

	/**
	 * Safe way of detecting whether or not the given thing is a primitive and
	 * whether it has the given property
	 */
	function primitiveHasOwnProperty (primitive, propName) {
	  return (
	    primitive != null
	    && typeof primitive !== 'object'
	    && primitive.hasOwnProperty
	    && primitive.hasOwnProperty(propName)
	  );
	}

	// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
	// See https://github.com/janl/mustache.js/issues/189
	var regExpTest = RegExp.prototype.test;
	function testRegExp (re, string) {
	  return regExpTest.call(re, string);
	}

	var nonSpaceRe = /\S/;
	function isWhitespace (string) {
	  return !testRegExp(nonSpaceRe, string);
	}

	var entityMap = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;',
	  '/': '&#x2F;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	function escapeHtml (string) {
	  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
	    return entityMap[s];
	  });
	}

	var whiteRe = /\s*/;
	var spaceRe = /\s+/;
	var equalsRe = /\s*=/;
	var curlyRe = /\s*\}/;
	var tagRe = /#|\^|\/|>|\{|&|=|!/;

	/**
	 * Breaks up the given `template` string into a tree of tokens. If the `tags`
	 * argument is given here it must be an array with two string values: the
	 * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
	 * course, the default is to use mustaches (i.e. mustache.tags).
	 *
	 * A token is an array with at least 4 elements. The first element is the
	 * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
	 * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
	 * all text that appears outside a symbol this element is "text".
	 *
	 * The second element of a token is its "value". For mustache tags this is
	 * whatever else was inside the tag besides the opening symbol. For text tokens
	 * this is the text itself.
	 *
	 * The third and fourth elements of the token are the start and end indices,
	 * respectively, of the token in the original template.
	 *
	 * Tokens that are the root node of a subtree contain two more elements: 1) an
	 * array of tokens in the subtree and 2) the index in the original template at
	 * which the closing tag for that section begins.
	 *
	 * Tokens for partials also contain two more elements: 1) a string value of
	 * indendation prior to that tag and 2) the index of that tag on that line -
	 * eg a value of 2 indicates the partial is the third tag on this line.
	 */
	function parseTemplate (template, tags) {
	  if (!template)
	    return [];
	  var lineHasNonSpace = false;
	  var sections = [];     // Stack to hold section tokens
	  var tokens = [];       // Buffer to hold the tokens
	  var spaces = [];       // Indices of whitespace tokens on the current line
	  var hasTag = false;    // Is there a {{tag}} on the current line?
	  var nonSpace = false;  // Is there a non-space char on the current line?
	  var indentation = '';  // Tracks indentation for tags that use it
	  var tagIndex = 0;      // Stores a count of number of tags encountered on a line

	  // Strips all whitespace tokens array for the current line
	  // if there was a {{#tag}} on it and otherwise only space.
	  function stripSpace () {
	    if (hasTag && !nonSpace) {
	      while (spaces.length)
	        delete tokens[spaces.pop()];
	    } else {
	      spaces = [];
	    }

	    hasTag = false;
	    nonSpace = false;
	  }

	  var openingTagRe, closingTagRe, closingCurlyRe;
	  function compileTags (tagsToCompile) {
	    if (typeof tagsToCompile === 'string')
	      tagsToCompile = tagsToCompile.split(spaceRe, 2);

	    if (!isArray$1(tagsToCompile) || tagsToCompile.length !== 2)
	      throw new Error('Invalid tags: ' + tagsToCompile);

	    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
	    closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
	    closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
	  }

	  compileTags(tags || mustache.tags);

	  var scanner = new Scanner(template);

	  var start, type, value, chr, token, openSection;
	  while (!scanner.eos()) {
	    start = scanner.pos;

	    // Match any text between tags.
	    value = scanner.scanUntil(openingTagRe);

	    if (value) {
	      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
	        chr = value.charAt(i);

	        if (isWhitespace(chr)) {
	          spaces.push(tokens.length);
	          indentation += chr;
	        } else {
	          nonSpace = true;
	          lineHasNonSpace = true;
	          indentation += ' ';
	        }

	        tokens.push([ 'text', chr, start, start + 1 ]);
	        start += 1;

	        // Check for whitespace on the current line.
	        if (chr === '\n') {
	          stripSpace();
	          indentation = '';
	          tagIndex = 0;
	          lineHasNonSpace = false;
	        }
	      }
	    }

	    // Match the opening tag.
	    if (!scanner.scan(openingTagRe))
	      break;

	    hasTag = true;

	    // Get the tag type.
	    type = scanner.scan(tagRe) || 'name';
	    scanner.scan(whiteRe);

	    // Get the tag value.
	    if (type === '=') {
	      value = scanner.scanUntil(equalsRe);
	      scanner.scan(equalsRe);
	      scanner.scanUntil(closingTagRe);
	    } else if (type === '{') {
	      value = scanner.scanUntil(closingCurlyRe);
	      scanner.scan(curlyRe);
	      scanner.scanUntil(closingTagRe);
	      type = '&';
	    } else {
	      value = scanner.scanUntil(closingTagRe);
	    }

	    // Match the closing tag.
	    if (!scanner.scan(closingTagRe))
	      throw new Error('Unclosed tag at ' + scanner.pos);

	    if (type == '>') {
	      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];
	    } else {
	      token = [ type, value, start, scanner.pos ];
	    }
	    tagIndex++;
	    tokens.push(token);

	    if (type === '#' || type === '^') {
	      sections.push(token);
	    } else if (type === '/') {
	      // Check section nesting.
	      openSection = sections.pop();

	      if (!openSection)
	        throw new Error('Unopened section "' + value + '" at ' + start);

	      if (openSection[1] !== value)
	        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
	    } else if (type === 'name' || type === '{' || type === '&') {
	      nonSpace = true;
	    } else if (type === '=') {
	      // Set the tags for the next time around.
	      compileTags(value);
	    }
	  }

	  stripSpace();

	  // Make sure there are no open sections when we're done.
	  openSection = sections.pop();

	  if (openSection)
	    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

	  return nestTokens(squashTokens(tokens));
	}

	/**
	 * Combines the values of consecutive text tokens in the given `tokens` array
	 * to a single token.
	 */
	function squashTokens (tokens) {
	  var squashedTokens = [];

	  var token, lastToken;
	  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	    token = tokens[i];

	    if (token) {
	      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
	        lastToken[1] += token[1];
	        lastToken[3] = token[3];
	      } else {
	        squashedTokens.push(token);
	        lastToken = token;
	      }
	    }
	  }

	  return squashedTokens;
	}

	/**
	 * Forms the given array of `tokens` into a nested tree structure where
	 * tokens that represent a section have two additional items: 1) an array of
	 * all tokens that appear in that section and 2) the index in the original
	 * template that represents the end of that section.
	 */
	function nestTokens (tokens) {
	  var nestedTokens = [];
	  var collector = nestedTokens;
	  var sections = [];

	  var token, section;
	  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	    token = tokens[i];

	    switch (token[0]) {
	      case '#':
	      case '^':
	        collector.push(token);
	        sections.push(token);
	        collector = token[4] = [];
	        break;
	      case '/':
	        section = sections.pop();
	        section[5] = token[2];
	        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
	        break;
	      default:
	        collector.push(token);
	    }
	  }

	  return nestedTokens;
	}

	/**
	 * A simple string scanner that is used by the template parser to find
	 * tokens in template strings.
	 */
	function Scanner (string) {
	  this.string = string;
	  this.tail = string;
	  this.pos = 0;
	}

	/**
	 * Returns `true` if the tail is empty (end of string).
	 */
	Scanner.prototype.eos = function eos () {
	  return this.tail === '';
	};

	/**
	 * Tries to match the given regular expression at the current position.
	 * Returns the matched text if it can match, the empty string otherwise.
	 */
	Scanner.prototype.scan = function scan (re) {
	  var match = this.tail.match(re);

	  if (!match || match.index !== 0)
	    return '';

	  var string = match[0];

	  this.tail = this.tail.substring(string.length);
	  this.pos += string.length;

	  return string;
	};

	/**
	 * Skips all text until the given regular expression can be matched. Returns
	 * the skipped string, which is the entire tail if no match can be made.
	 */
	Scanner.prototype.scanUntil = function scanUntil (re) {
	  var index = this.tail.search(re), match;

	  switch (index) {
	    case -1:
	      match = this.tail;
	      this.tail = '';
	      break;
	    case 0:
	      match = '';
	      break;
	    default:
	      match = this.tail.substring(0, index);
	      this.tail = this.tail.substring(index);
	  }

	  this.pos += match.length;

	  return match;
	};

	/**
	 * Represents a rendering context by wrapping a view object and
	 * maintaining a reference to the parent context.
	 */
	function Context (view, parentContext) {
	  this.view = view;
	  this.cache = { '.': this.view };
	  this.parent = parentContext;
	}

	/**
	 * Creates a new context using the given view with this context
	 * as the parent.
	 */
	Context.prototype.push = function push (view) {
	  return new Context(view, this);
	};

	/**
	 * Returns the value of the given name in this context, traversing
	 * up the context hierarchy if the value is absent in this context's view.
	 */
	Context.prototype.lookup = function lookup (name) {
	  var cache = this.cache;

	  var value;
	  if (cache.hasOwnProperty(name)) {
	    value = cache[name];
	  } else {
	    var context = this, intermediateValue, names, index, lookupHit = false;

	    while (context) {
	      if (name.indexOf('.') > 0) {
	        intermediateValue = context.view;
	        names = name.split('.');
	        index = 0;

	        /**
	         * Using the dot notion path in `name`, we descend through the
	         * nested objects.
	         *
	         * To be certain that the lookup has been successful, we have to
	         * check if the last object in the path actually has the property
	         * we are looking for. We store the result in `lookupHit`.
	         *
	         * This is specially necessary for when the value has been set to
	         * `undefined` and we want to avoid looking up parent contexts.
	         *
	         * In the case where dot notation is used, we consider the lookup
	         * to be successful even if the last "object" in the path is
	         * not actually an object but a primitive (e.g., a string, or an
	         * integer), because it is sometimes useful to access a property
	         * of an autoboxed primitive, such as the length of a string.
	         **/
	        while (intermediateValue != null && index < names.length) {
	          if (index === names.length - 1)
	            lookupHit = (
	              hasProperty(intermediateValue, names[index])
	              || primitiveHasOwnProperty(intermediateValue, names[index])
	            );

	          intermediateValue = intermediateValue[names[index++]];
	        }
	      } else {
	        intermediateValue = context.view[name];

	        /**
	         * Only checking against `hasProperty`, which always returns `false` if
	         * `context.view` is not an object. Deliberately omitting the check
	         * against `primitiveHasOwnProperty` if dot notation is not used.
	         *
	         * Consider this example:
	         * ```
	         * Mustache.render("The length of a football field is {{#length}}{{length}}{{/length}}.", {length: "100 yards"})
	         * ```
	         *
	         * If we were to check also against `primitiveHasOwnProperty`, as we do
	         * in the dot notation case, then render call would return:
	         *
	         * "The length of a football field is 9."
	         *
	         * rather than the expected:
	         *
	         * "The length of a football field is 100 yards."
	         **/
	        lookupHit = hasProperty(context.view, name);
	      }

	      if (lookupHit) {
	        value = intermediateValue;
	        break;
	      }

	      context = context.parent;
	    }

	    cache[name] = value;
	  }

	  if (isFunction$1(value))
	    value = value.call(this.view);

	  return value;
	};

	/**
	 * A Writer knows how to take a stream of tokens and render them to a
	 * string, given a context. It also maintains a cache of templates to
	 * avoid the need to parse the same template twice.
	 */
	function Writer () {
	  this.templateCache = {
	    _cache: {},
	    set: function set (key, value) {
	      this._cache[key] = value;
	    },
	    get: function get (key) {
	      return this._cache[key];
	    },
	    clear: function clear () {
	      this._cache = {};
	    }
	  };
	}

	/**
	 * Clears all cached templates in this writer.
	 */
	Writer.prototype.clearCache = function clearCache () {
	  if (typeof this.templateCache !== 'undefined') {
	    this.templateCache.clear();
	  }
	};

	/**
	 * Parses and caches the given `template` according to the given `tags` or
	 * `mustache.tags` if `tags` is omitted,  and returns the array of tokens
	 * that is generated from the parse.
	 */
	Writer.prototype.parse = function parse (template, tags) {
	  var cache = this.templateCache;
	  var cacheKey = template + ':' + (tags || mustache.tags).join(':');
	  var isCacheEnabled = typeof cache !== 'undefined';
	  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;

	  if (tokens == undefined) {
	    tokens = parseTemplate(template, tags);
	    isCacheEnabled && cache.set(cacheKey, tokens);
	  }
	  return tokens;
	};

	/**
	 * High-level method that is used to render the given `template` with
	 * the given `view`.
	 *
	 * The optional `partials` argument may be an object that contains the
	 * names and templates of partials that are used in the template. It may
	 * also be a function that is used to load partial templates on the fly
	 * that takes a single argument: the name of the partial.
	 *
	 * If the optional `config` argument is given here, then it should be an
	 * object with a `tags` attribute or an `escape` attribute or both.
	 * If an array is passed, then it will be interpreted the same way as
	 * a `tags` attribute on a `config` object.
	 *
	 * The `tags` attribute of a `config` object must be an array with two
	 * string values: the opening and closing tags used in the template (e.g.
	 * [ "<%", "%>" ]). The default is to mustache.tags.
	 *
	 * The `escape` attribute of a `config` object must be a function which
	 * accepts a string as input and outputs a safely escaped string.
	 * If an `escape` function is not provided, then an HTML-safe string
	 * escaping function is used as the default.
	 */
	Writer.prototype.render = function render (template, view, partials, config) {
	  var tags = this.getConfigTags(config);
	  var tokens = this.parse(template, tags);
	  var context = (view instanceof Context) ? view : new Context(view, undefined);
	  return this.renderTokens(tokens, context, partials, template, config);
	};

	/**
	 * Low-level method that renders the given array of `tokens` using
	 * the given `context` and `partials`.
	 *
	 * Note: The `originalTemplate` is only ever used to extract the portion
	 * of the original template that was contained in a higher-order section.
	 * If the template doesn't use higher-order sections, this argument may
	 * be omitted.
	 */
	Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {
	  var buffer = '';

	  var token, symbol, value;
	  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	    value = undefined;
	    token = tokens[i];
	    symbol = token[0];

	    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);
	    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);
	    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);
	    else if (symbol === '&') value = this.unescapedValue(token, context);
	    else if (symbol === 'name') value = this.escapedValue(token, context, config);
	    else if (symbol === 'text') value = this.rawValue(token);

	    if (value !== undefined)
	      buffer += value;
	  }

	  return buffer;
	};

	Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {
	  var self = this;
	  var buffer = '';
	  var value = context.lookup(token[1]);

	  // This function is used to render an arbitrary template
	  // in the current context by higher-order sections.
	  function subRender (template) {
	    return self.render(template, context, partials, config);
	  }

	  if (!value) return;

	  if (isArray$1(value)) {
	    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
	      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
	    }
	  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
	    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
	  } else if (isFunction$1(value)) {
	    if (typeof originalTemplate !== 'string')
	      throw new Error('Cannot use higher-order sections without the original template');

	    // Extract the portion of the original template that the section contains.
	    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

	    if (value != null)
	      buffer += value;
	  } else {
	    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
	  }
	  return buffer;
	};

	Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {
	  var value = context.lookup(token[1]);

	  // Use JavaScript's definition of falsy. Include empty arrays.
	  // See https://github.com/janl/mustache.js/issues/186
	  if (!value || (isArray$1(value) && value.length === 0))
	    return this.renderTokens(token[4], context, partials, originalTemplate, config);
	};

	Writer.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {
	  var filteredIndentation = indentation.replace(/[^ \t]/g, '');
	  var partialByNl = partial.split('\n');
	  for (var i = 0; i < partialByNl.length; i++) {
	    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
	      partialByNl[i] = filteredIndentation + partialByNl[i];
	    }
	  }
	  return partialByNl.join('\n');
	};

	Writer.prototype.renderPartial = function renderPartial (token, context, partials, config) {
	  if (!partials) return;
	  var tags = this.getConfigTags(config);

	  var value = isFunction$1(partials) ? partials(token[1]) : partials[token[1]];
	  if (value != null) {
	    var lineHasNonSpace = token[6];
	    var tagIndex = token[5];
	    var indentation = token[4];
	    var indentedValue = value;
	    if (tagIndex == 0 && indentation) {
	      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
	    }
	    var tokens = this.parse(indentedValue, tags);
	    return this.renderTokens(tokens, context, partials, indentedValue, config);
	  }
	};

	Writer.prototype.unescapedValue = function unescapedValue (token, context) {
	  var value = context.lookup(token[1]);
	  if (value != null)
	    return value;
	};

	Writer.prototype.escapedValue = function escapedValue (token, context, config) {
	  var escape = this.getConfigEscape(config) || mustache.escape;
	  var value = context.lookup(token[1]);
	  if (value != null)
	    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);
	};

	Writer.prototype.rawValue = function rawValue (token) {
	  return token[1];
	};

	Writer.prototype.getConfigTags = function getConfigTags (config) {
	  if (isArray$1(config)) {
	    return config;
	  }
	  else if (config && typeof config === 'object') {
	    return config.tags;
	  }
	  else {
	    return undefined;
	  }
	};

	Writer.prototype.getConfigEscape = function getConfigEscape (config) {
	  if (config && typeof config === 'object' && !isArray$1(config)) {
	    return config.escape;
	  }
	  else {
	    return undefined;
	  }
	};

	var mustache = {
	  name: 'mustache.js',
	  version: '4.2.0',
	  tags: [ '{{', '}}' ],
	  clearCache: undefined,
	  escape: undefined,
	  parse: undefined,
	  render: undefined,
	  Scanner: undefined,
	  Context: undefined,
	  Writer: undefined,
	  /**
	   * Allows a user to override the default caching strategy, by providing an
	   * object with set, get and clear methods. This can also be used to disable
	   * the cache by setting it to the literal `undefined`.
	   */
	  set templateCache (cache) {
	    defaultWriter.templateCache = cache;
	  },
	  /**
	   * Gets the default or overridden caching object from the default writer.
	   */
	  get templateCache () {
	    return defaultWriter.templateCache;
	  }
	};

	// All high-level mustache.* functions use this writer.
	var defaultWriter = new Writer();

	/**
	 * Clears all cached templates in the default writer.
	 */
	mustache.clearCache = function clearCache () {
	  return defaultWriter.clearCache();
	};

	/**
	 * Parses and caches the given template in the default writer and returns the
	 * array of tokens it contains. Doing this ahead of time avoids the need to
	 * parse templates on the fly as they are rendered.
	 */
	mustache.parse = function parse (template, tags) {
	  return defaultWriter.parse(template, tags);
	};

	/**
	 * Renders the `template` with the given `view`, `partials`, and `config`
	 * using the default writer.
	 */
	mustache.render = function render (template, view, partials, config) {
	  if (typeof template !== 'string') {
	    throw new TypeError('Invalid template! Template should be a "string" ' +
	                        'but "' + typeStr(template) + '" was given as the first ' +
	                        'argument for mustache#render(template, view, partials)');
	  }

	  return defaultWriter.render(template, view, partials, config);
	};

	// Export the escaping function so that the user may override it.
	// See https://github.com/janl/mustache.js/issues/244
	mustache.escape = escapeHtml;

	// Export these mainly for testing, but also for advanced usage.
	mustache.Scanner = Scanner;
	mustache.Context = Context;
	mustache.Writer = Writer;

	class TaskAction extends Action {
	    constructor(config) {
	        // config: {name, parameters:{...} }        
	        super({
	            name: 'TaskAction',
	            title: config.name,
	            properties: config,
	        });

	        var sourceParameters = config.parameters;
	        var taskParameters = {};
	        for (var name in sourceParameters) {
	            taskParameters[name] = CompileExpression(sourceParameters[name]);
	        }
	        this.taskParameters = taskParameters;

	        this.isRunning = false;
	        this.waitId = 0;
	    }

	    open(tick) {
	        this.isRunning = false;

	        var taskData = this.properties;

	        var taskName = taskData.name;
	        if (!taskName) {
	            return;
	        }

	        var blackboard = tick.blackboard;
	        var eventSheetManager = blackboard.eventSheetManager;
	        var eventSheet = tick.tree;
	        var memory = eventSheetManager.memory;

	        var taskParameters = this.taskParameters;
	        var parametersCopy = {};
	        for (var name in taskParameters) {
	            var value = taskParameters[name];
	            if (typeof (value) === 'function') {
	                value = value(memory);
	            }
	            parametersCopy[name] = value;
	        }

	        eventSheetManager.bindTaskActionNode(tick, this);
	        // Invoke eventSheetManager.pauseEventSheet() to generate new resumeEventName

	        var commandExecutor = tick.target;
	        var eventEmitter;
	        var handler = commandExecutor[taskName];
	        if (handler) {
	            eventEmitter = handler.call(commandExecutor, parametersCopy, eventSheetManager, eventSheet);
	        } else {
	            handler = commandExecutor.defaultHandler;
	            if (handler) {
	                eventEmitter = handler.call(commandExecutor, taskName, parametersCopy, eventSheetManager, eventSheet);
	            }
	        }

	        eventSheetManager.unBindTaskAction(tick, this);

	        // Event-emitter mode
	        if (!this.isRunning && IsEventEmitter(eventEmitter)) {
	            this.pauseEventSheetUnitlEvent(tick, eventEmitter);
	        }
	    }

	    tick(tick) {
	        return (this.isRunning) ? this.RUNNING : this.SUCCESS;
	    }

	    close(tick) {
	    }

	    abort(tick) {
	        if (this.removeTaskCompleteCallback) {
	            this.removeTaskCompleteCallback();
	        }
	    }
	}

	var CompileExpression = function (s) {
	    if (typeof (s) === 'string') {
	        if (s.startsWith('#(') && s.endsWith(')')) {
	            // Eval string to get number/boolean
	            s = Compile$1(s.substring(2, s.length - 1));
	        } else if ((s.indexOf('{{') > -1) && (s.indexOf('}}') > -1)) {
	            // Might be a string template
	            var template = s;
	            s = function (data) {
	                return mustache.render(template, data);
	            };
	        }
	    }
	    return s;
	};

	Object.assign(
	    TaskAction.prototype,
	    PauseEventSheetMethods,
	);

	class ActivateAction extends Action {
	    constructor({
	        activateTreeTitle,
	        services,
	        title,
	        name = 'ActivateTree'
	    } = {}) {

	        super({
	            name,
	            title,
	            properties: {
	                activateTreeTitle
	            },
	            services,
	        });

	        this.activateTreeTitle = activateTreeTitle;
	    }

	    tick(tick) {
	        var eventsheet = this.getTree(tick);
	        if (!this.activateTreeTitle || (this.activateTreeTitle === '')) {
	            eventsheet.setActive(true);
	        } else {
	            eventsheet.eventSheetManager.setEventSheetActiveState(this.activateTreeTitle, eventsheet.groupName, true);
	        }
	        return this.SUCCESS;
	    }
	}

	class DeactivateAction extends Action {
	    constructor({
	        deactivateTreeTitle,
	        services,
	        title,
	        name = 'DeactivateTree'
	    } = {}) {

	        super({
	            name,
	            title,
	            properties: {
	                deactivateTreeTitle
	            },
	            services,
	        });

	        this.deactivateTreeTitle = deactivateTreeTitle;
	    }

	    tick(tick) {
	        var eventsheet = this.getTree(tick);
	        if (!this.deactivateTreeTitle || (this.deactivateTreeTitle === '')) {
	            eventsheet.setActive(false);
	        } else {
	            eventsheet.eventSheetManager.setEventSheetActiveState(this.deactivateTreeTitle, eventsheet.groupName, false);
	        }
	        return this.SUCCESS;
	    }
	}

	var CustomNodeMapping = {
	    TaskSequence: TaskSequence,
	    TaskAction: TaskAction,
	    ActivateAction: ActivateAction,
	    DeactivateAction: DeactivateAction,
	};

	var SaveLoadTreeMethods = {
	    dumpEventSheetGroup() {
	        return this.trees.map(function (eventsheet) {
	            return eventsheet.dump()
	        })
	    },

	    loadEventSheetGroup(data) {
	        data.forEach(function (treeData) {
	            var eventsheet = new BehaviorTree({
	                id: treeData.id,
	                title: treeData.title,
	                properties: DeepClone(treeData.properties),
	            });
	            eventsheet.load(treeData, CustomNodeMapping);
	            this.trees.push(eventsheet);
	        }, this);
	        return this;
	    },
	};

	var StateMethods$1 = {
	    dumpState(includeTree = false) {
	        var state = {
	            isRunning: this.isRunning,
	            pendingTrees: this.pendingTrees
	                .filter(function (eventsheet) {
	                    // roundComplete eventsheet will be removed from pendingTrees
	                    return !eventsheet.roundComplete;
	                })
	                .map(function (eventsheet) {
	                    return eventsheet.id;
	                })
	        };

	        if (includeTree) {
	            state.trees = this.dumpEventSheetGroup();
	        }

	        return state;
	    },

	    loadState(state) {
	        this.stop();

	        if (state.trees) {
	            this.trees.length = 0;
	            this.loadEventSheetGroup(state.trees);
	        }

	        this.isRunning = state.isRunning;

	        var pendingTrees = this.pendingTrees;
	        pendingTrees.length = 0;
	        this.trees.forEach(function (eventsheet) {
	            if (state.pendingTrees.indexOf(eventsheet.id) > -1) {
	                pendingTrees.push(eventsheet);
	            }
	        });

	        return this;
	    },
	};

	var OpenEventSheet = function (eventSheetManager, eventsheet) {
	    var blackboard = eventSheetManager.blackboard;
	    var commandExecutor = eventSheetManager.commandExecutor;
	    var result = eventsheet.start(blackboard, commandExecutor);

	    if (!result) {
	        return;
	    }

	    if (eventsheet.conditionPassed) {
	        eventSheetManager.emit('eventsheet.enter', eventsheet.title, this.name, eventSheetManager);
	    } else {
	        eventSheetManager.emit('eventsheet.catch', eventsheet.title, this.name, eventSheetManager);
	    }
	};

	var TickEventSheet = function (eventSheetManager, eventsheet) {
	    var blackboard = eventSheetManager.blackboard;
	    var commandExecutor = eventSheetManager.commandExecutor;
	    var status = eventsheet.tick(blackboard, commandExecutor);
	    return status;
	};

	var CloseEventSheet = function (eventSheetManager, eventsheet) {
	    if (eventsheet.conditionPassed) {
	        eventSheetManager.emit('eventsheet.exit', eventsheet.title, this.name, eventSheetManager);
	    }
	};

	var RunMethods$1 = {

	    /*
	    A round : 
	    
	    - Normal case : 
	        - Start from condition-eval, 
	        - End to eventsheet.roundComplete (SUCCESS/FAILURE/ERROR state)
	    - Cross rounds : 
	        - Start from condition-eval or RUNNING state, 
	        - End to eventsheet.roundComplete (RUNNING/SUCCESS/FAILURE/ERROR state)
	    */

	    start() {
	        /*
	        Start a round :
	        
	        - sequence : Add all trees to pendingTrees
	        - parallel : Open all event sheets(eventsheet), add them to pendingTrees

	        Then, invoke continue()
	        */

	        if (this.isRunning) {
	            return this;
	        }

	        this.isRunning = true;

	        var eventSheetManager = this.parent;
	        var trees = this.trees;
	        var pendingTrees = this.pendingTrees;
	        var blackboard = eventSheetManager.blackboard;

	        eventSheetManager.emit('start', this.name, eventSheetManager);

	        // pendingTrees.length = 0;

	        // Run parallel eventsheet, will return running, or failure
	        for (var i = 0, cnt = trees.length; i < cnt; i++) {
	            var eventsheet = trees[i];

	            if (!eventsheet.active) {
	                continue;
	            }

	            eventsheet.resetState(blackboard);
	            if (eventsheet.parallel) {
	                // Open all event sheets
	                OpenEventSheet.call(this, eventSheetManager, eventsheet);
	            }

	            pendingTrees.push(eventsheet);
	        }

	        this.continue();

	        return this;
	    },

	    continue() {
	        /*
	        Tick event sheets(eventsheet) until all trees are at SUCCESS/FAILURE/ERROR state

	        - Open (if not opened) and tick event sheet(eventsheet)        
	        - TaskAction's complete event will invoke this method to run remainder nodes
	        - Close(remove from pendingTrees) SUCCESS/FAILURE/ERROR event sheets(eventsheet)
	        - Complete this round if pendingTrees is empty. i.e. all trees are return SUCCESS/FAILURE/ERROR.
	        */

	        if (!this.isRunning) {
	            return this;
	        }

	        var eventSheetManager = this.parent;
	        var trees = this.pendingTrees;
	        var closedTrees = this.closedTrees;
	        var blackboard = eventSheetManager.blackboard;

	        closedTrees.length = 0;

	        for (var i = 0, cnt = trees.length; i < cnt; i++) {
	            var eventsheet = trees[i];

	            // Do nothing if event sheet has been opened
	            OpenEventSheet.call(this, eventSheetManager, eventsheet);

	            if (!this.isRunning) {
	                // Can break here
	                break;
	            }

	            // Will goto RUNNING, or SUCCESS/FAILURE/ERROR state
	            var status = TickEventSheet(eventSheetManager, eventsheet);

	            if (eventsheet.roundComplete) {
	                closedTrees.push(eventsheet);
	                CloseEventSheet.call(this, eventSheetManager, eventsheet);
	            } else if (status === RUNNING$1) {
	                // Stall command execution here
	                break;
	            }

	            if (!this.isRunning) {
	                // Can break here
	                break;
	            }

	        }

	        blackboard.eventSheetGroup = undefined;

	        if (closedTrees.length > 0) {
	            Remove$3(trees, closedTrees);
	        }

	        if (trees.length === 0) {
	            this.isRunning = false;
	            eventSheetManager.emit('complete', this.name, eventSheetManager);
	        }

	        return this;
	    },

	    startTree(title, ignoreCondition = true) {
	        // Run a single event sheet(eventsheet)

	        if (this.isRunning) {
	            return this;
	        }

	        var eventsheet = this.getTree(title);
	        if (!eventsheet) {
	            return this;
	        }

	        this.isRunning = true;

	        var eventSheetManager = this.parent;
	        var pendingTrees = this.pendingTrees;
	        var blackboard = eventSheetManager.blackboard;

	        pendingTrees.length = 0;

	        eventsheet.resetState(blackboard);

	        eventsheet.setConditionEnable(!ignoreCondition);

	        OpenEventSheet.call(this, eventSheetManager, eventsheet);

	        eventsheet.setConditionEnable(true);

	        pendingTrees.push(eventsheet);

	        this.continue();

	        return this;
	    }
	};

	var StopMethods$1 = {
	    stop() {
	        var eventSheetManager = this.parent;
	        var blackboard = eventSheetManager.blackboard;
	        var commandExecutor = eventSheetManager.commandExecutor;

	        var trees = this.pendingTrees;
	        for (var i = 0, cnt = trees.length; i < cnt; i++) {
	            var eventsheet = trees[i];
	            eventsheet.abort(blackboard, commandExecutor);
	            CloseEventSheet.call(this, eventSheetManager, eventsheet);
	        }
	        trees.length = 0;

	        this.isRunning = false;

	        return this;
	    },
	};

	var Methods$g = {};

	Object.assign(
	    Methods$g,
	    TreeMethods$1,
	    AddTreeMethods$1,
	    RemoveTreeMethods$1,
	    TreeActiveStateMethods$1,
	    SaveLoadTreeMethods,
	    StateMethods$1,
	    RunMethods$1,
	    StopMethods$1,
	);

	class EventBehaviorTreeGroup {
	    constructor(parent, {
	        name = ''
	    } = {}) {
	        this.parent = parent;
	        this.name = name;

	        this.trees = [];
	        this.pendingTrees = [];
	        this.closedTrees = [];  // Temporary eventsheet array

	        this.isRunning = false;
	        this._threadKey = null;
	    }

	    destroy() {
	        this.stop();

	        this.pendingTrees.length = 0;
	        this.closedTrees.length = 0;
	        this.isRunning = false;

	        for (var i = 0, cnt = this.trees.length; i < cnt; i++) {
	            this.trees[i].destroy();
	        }
	    }
	}

	Object.assign(
	    EventBehaviorTreeGroup.prototype,
	    Methods$g,
	);

	var TreeMethods = {
	    hasTreeGroup(name) {
	        return this.treeGroups.hasOwnProperty(name);
	    },

	    getTreeGroup(name) {
	        if (!this.hasTreeGroup(name)) {
	            this.treeGroups[name] = new EventBehaviorTreeGroup(this, { name });
	        }
	        return this.treeGroups[name];
	    },

	    getTree(eventsheet, groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        return this.getTreeGroup(groupName).getTree(eventsheet);
	    },

	    getTreeState(eventsheet, groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        return this.getTreeGroup(groupName).getTreeState(eventsheet);
	    },

	    getEventSheetTitleList(out, groupName) {
	        if (out === undefined) {
	            out = [];
	        }
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        this.getTreeGroup(groupName).getEventSheetTitleList(out);
	        return out;
	    },
	};

	var AddTreeMethods = {
	    // Override it
	    addEventSheet(s, groupName, config) {
	        return this;
	    },

	    addTree(eventsheet, groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        this.getTreeGroup(groupName).addTree(eventsheet);
	        return this;
	    },

	};

	var RemoveTreeMethods = {
	    removeAllEventSheets(groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        this.getTreeGroup(groupName).removeAllEventSheets();
	        return this;
	    },

	    removeEventSheet(title, groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        this.getTreeGroup(groupName).removeEventSheet(title);
	        return this;
	    },
	};

	var TreeActiveStateMethods = {
	    getEventSheetActiveState(title, groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        return this.getTreeGroup(groupName).getTreeActiveState(title);
	    },

	    setEventSheetActiveState(title, groupName, active) {
	        if (typeof (groupName) === 'boolean') {
	            active = groupName;
	            groupName = undefined;
	        }
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        return this.getTreeGroup(groupName).setTreeActiveState(title, active);
	    },
	};

	var SaveLoadTreesMethods = {
	    dumpEventSheetGroup(groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        return this.getTreeGroup(groupName).dumpEventSheetGroup();
	    },

	    loadEventSheetGroup(data, groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        this.getTreeGroup(groupName).loadEventSheetGroup(data);
	        return this;
	    },
	};

	var DataMethods$4 = {
	    setData(key, value) {
	        var blackboard = this.blackboard;

	        if (typeof (key) === 'string') {
	            blackboard.setData(key, value);
	        } else {
	            var data = key;
	            for (key in data) {
	                value = data[key];
	                blackboard.setData(key, value);
	            }
	        }

	        return this;
	    },

	    incData(key, inc) {
	        var value;
	        if (this.hasData(key)) {
	            value = this.getData(key);
	        } else {
	            value = 0;
	        }
	        this.setData(value + inc);
	        return this;
	    },

	    toggleData(key) {
	        var value;
	        if (this.hasData(key)) {
	            value = this.getData(key);
	        } else {
	            value = false;
	        }
	        this.setData(!value);
	        return this;
	    },

	    hasData(key) {
	        return this.blackboard.hasData(key);
	    },

	    getData(key) {
	        return this.blackboard.getData(key);
	    },

	    removeData(key) {
	        this.blackboard.removeData(key);
	        return this;
	    },

	    addExpression(name, callback) {
	        this.setData(name, callback);
	        return this;
	    },

	    addExpressions(data) {
	        this.setData(data);
	        return this;
	    },
	};

	var StateMethods = {
	    dumpState(includeTree = false) {
	        var state = {
	            blackboard: this.blackboard.dump(),
	            treeGroups: {},
	        };
	        var treeGroups = state.treeGroups;
	        for (var name in this.treeGroups) {
	            treeGroups[name] = this.treeGroups[name].dumpState(includeTree);
	        }

	        return state;
	    },

	    loadState(state) {
	        if (!state) {
	            return this;
	        }

	        this.blackboard.load(state.blackboard);
	        var treeGroups = state.treeGroups;
	        for (var name in treeGroups) {
	            this.getTreeGroup(name).loadState(treeGroups[name]);
	        }

	        for (var name in treeGroups) {
	            this.getTreeGroup(name).continue();
	        }

	        return this;
	    },
	};

	var handlebars$1 = {exports: {}};

	var handlebars_runtime = {exports: {}};

	var base$1 = {};

	var utils = {};

	utils.__esModule = true;
	utils.extend = extend;
	utils.indexOf = indexOf;
	utils.escapeExpression = escapeExpression;
	utils.isEmpty = isEmpty;
	utils.createFrame = createFrame;
	utils.blockParams = blockParams;
	utils.appendContextPath = appendContextPath;
	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	var badChars = /[&<>"'`=]/g,
	    possible = /[&<>"'`=]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	utils.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  utils.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	utils.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};

	utils.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

	var exception = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];

		function Exception(message, node) {
		  var loc = node && node.loc,
		      line = undefined,
		      endLineNumber = undefined,
		      column = undefined,
		      endColumn = undefined;

		  if (loc) {
		    line = loc.start.line;
		    endLineNumber = loc.end.line;
		    column = loc.start.column;
		    endColumn = loc.end.column;

		    message += ' - ' + line + ':' + column;
		  }

		  var tmp = Error.prototype.constructor.call(this, message);

		  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
		  for (var idx = 0; idx < errorProps.length; idx++) {
		    this[errorProps[idx]] = tmp[errorProps[idx]];
		  }

		  /* istanbul ignore else */
		  if (Error.captureStackTrace) {
		    Error.captureStackTrace(this, Exception);
		  }

		  try {
		    if (loc) {
		      this.lineNumber = line;
		      this.endLineNumber = endLineNumber;

		      // Work around issue under safari where we can't directly set the column value
		      /* istanbul ignore next */
		      if (Object.defineProperty) {
		        Object.defineProperty(this, 'column', {
		          value: column,
		          enumerable: true
		        });
		        Object.defineProperty(this, 'endColumn', {
		          value: endColumn,
		          enumerable: true
		        });
		      } else {
		        this.column = column;
		        this.endColumn = endColumn;
		      }
		    }
		  } catch (nop) {
		    /* Ignore if the browser is very particular */
		  }
		}

		Exception.prototype = new Error();

		exports['default'] = Exception;
		module.exports = exports['default'];
		
	} (exception, exception.exports));

	var exceptionExports = exception.exports;

	var helpers$1 = {};

	var blockHelperMissing = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;

		var _utils = utils;

		exports['default'] = function (instance) {
		  instance.registerHelper('blockHelperMissing', function (context, options) {
		    var inverse = options.inverse,
		        fn = options.fn;

		    if (context === true) {
		      return fn(this);
		    } else if (context === false || context == null) {
		      return inverse(this);
		    } else if (_utils.isArray(context)) {
		      if (context.length > 0) {
		        if (options.ids) {
		          options.ids = [options.name];
		        }

		        return instance.helpers.each(context, options);
		      } else {
		        return inverse(this);
		      }
		    } else {
		      if (options.data && options.ids) {
		        var data = _utils.createFrame(options.data);
		        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
		        options = { data: data };
		      }

		      return fn(context, options);
		    }
		  });
		};

		module.exports = exports['default'];
		
	} (blockHelperMissing, blockHelperMissing.exports));

	var blockHelperMissingExports = blockHelperMissing.exports;

	var each = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _utils = utils;

		var _exception = exceptionExports;

		var _exception2 = _interopRequireDefault(_exception);

		exports['default'] = function (instance) {
		  instance.registerHelper('each', function (context, options) {
		    if (!options) {
		      throw new _exception2['default']('Must pass iterator to #each');
		    }

		    var fn = options.fn,
		        inverse = options.inverse,
		        i = 0,
		        ret = '',
		        data = undefined,
		        contextPath = undefined;

		    if (options.data && options.ids) {
		      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
		    }

		    if (_utils.isFunction(context)) {
		      context = context.call(this);
		    }

		    if (options.data) {
		      data = _utils.createFrame(options.data);
		    }

		    function execIteration(field, index, last) {
		      if (data) {
		        data.key = field;
		        data.index = index;
		        data.first = index === 0;
		        data.last = !!last;

		        if (contextPath) {
		          data.contextPath = contextPath + field;
		        }
		      }

		      ret = ret + fn(context[field], {
		        data: data,
		        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
		      });
		    }

		    if (context && typeof context === 'object') {
		      if (_utils.isArray(context)) {
		        for (var j = context.length; i < j; i++) {
		          if (i in context) {
		            execIteration(i, i, i === context.length - 1);
		          }
		        }
		      } else if (typeof Symbol === 'function' && context[Symbol.iterator]) {
		        var newContext = [];
		        var iterator = context[Symbol.iterator]();
		        for (var it = iterator.next(); !it.done; it = iterator.next()) {
		          newContext.push(it.value);
		        }
		        context = newContext;
		        for (var j = context.length; i < j; i++) {
		          execIteration(i, i, i === context.length - 1);
		        }
		      } else {
		        (function () {
		          var priorKey = undefined;

		          Object.keys(context).forEach(function (key) {
		            // We're running the iterations one step out of sync so we can detect
		            // the last iteration without have to scan the object twice and create
		            // an itermediate keys array.
		            if (priorKey !== undefined) {
		              execIteration(priorKey, i - 1);
		            }
		            priorKey = key;
		            i++;
		          });
		          if (priorKey !== undefined) {
		            execIteration(priorKey, i - 1, true);
		          }
		        })();
		      }
		    }

		    if (i === 0) {
		      ret = inverse(this);
		    }

		    return ret;
		  });
		};

		module.exports = exports['default'];
		
	} (each, each.exports));

	var eachExports = each.exports;

	var helperMissing = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _exception = exceptionExports;

		var _exception2 = _interopRequireDefault(_exception);

		exports['default'] = function (instance) {
		  instance.registerHelper('helperMissing', function () /* [args, ]options */{
		    if (arguments.length === 1) {
		      // A missing field in a {{foo}} construct.
		      return undefined;
		    } else {
		      // Someone is actually trying to call something, blow up.
		      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
		    }
		  });
		};

		module.exports = exports['default'];
		
	} (helperMissing, helperMissing.exports));

	var helperMissingExports = helperMissing.exports;

	var _if = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _utils = utils;

		var _exception = exceptionExports;

		var _exception2 = _interopRequireDefault(_exception);

		exports['default'] = function (instance) {
		  instance.registerHelper('if', function (conditional, options) {
		    if (arguments.length != 2) {
		      throw new _exception2['default']('#if requires exactly one argument');
		    }
		    if (_utils.isFunction(conditional)) {
		      conditional = conditional.call(this);
		    }

		    // Default behavior is to render the positive path if the value is truthy and not empty.
		    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
		    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
		    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
		      return options.inverse(this);
		    } else {
		      return options.fn(this);
		    }
		  });

		  instance.registerHelper('unless', function (conditional, options) {
		    if (arguments.length != 2) {
		      throw new _exception2['default']('#unless requires exactly one argument');
		    }
		    return instance.helpers['if'].call(this, conditional, {
		      fn: options.inverse,
		      inverse: options.fn,
		      hash: options.hash
		    });
		  });
		};

		module.exports = exports['default'];
		
	} (_if, _if.exports));

	var _ifExports = _if.exports;

	var log$1 = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;

		exports['default'] = function (instance) {
		  instance.registerHelper('log', function () /* message, options */{
		    var args = [undefined],
		        options = arguments[arguments.length - 1];
		    for (var i = 0; i < arguments.length - 1; i++) {
		      args.push(arguments[i]);
		    }

		    var level = 1;
		    if (options.hash.level != null) {
		      level = options.hash.level;
		    } else if (options.data && options.data.level != null) {
		      level = options.data.level;
		    }
		    args[0] = level;

		    instance.log.apply(instance, args);
		  });
		};

		module.exports = exports['default'];
		
	} (log$1, log$1.exports));

	var logExports = log$1.exports;

	var lookup = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;

		exports['default'] = function (instance) {
		  instance.registerHelper('lookup', function (obj, field, options) {
		    if (!obj) {
		      // Note for 5.0: Change to "obj == null" in 5.0
		      return obj;
		    }
		    return options.lookupProperty(obj, field);
		  });
		};

		module.exports = exports['default'];
		
	} (lookup, lookup.exports));

	var lookupExports = lookup.exports;

	var _with = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _utils = utils;

		var _exception = exceptionExports;

		var _exception2 = _interopRequireDefault(_exception);

		exports['default'] = function (instance) {
		  instance.registerHelper('with', function (context, options) {
		    if (arguments.length != 2) {
		      throw new _exception2['default']('#with requires exactly one argument');
		    }
		    if (_utils.isFunction(context)) {
		      context = context.call(this);
		    }

		    var fn = options.fn;

		    if (!_utils.isEmpty(context)) {
		      var data = options.data;
		      if (options.data && options.ids) {
		        data = _utils.createFrame(options.data);
		        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
		      }

		      return fn(context, {
		        data: data,
		        blockParams: _utils.blockParams([context], [data && data.contextPath])
		      });
		    } else {
		      return options.inverse(this);
		    }
		  });
		};

		module.exports = exports['default'];
		
	} (_with, _with.exports));

	var _withExports = _with.exports;

	helpers$1.__esModule = true;
	helpers$1.registerDefaultHelpers = registerDefaultHelpers;
	helpers$1.moveHelperToHooks = moveHelperToHooks;
	// istanbul ignore next

	function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _helpersBlockHelperMissing = blockHelperMissingExports;

	var _helpersBlockHelperMissing2 = _interopRequireDefault$7(_helpersBlockHelperMissing);

	var _helpersEach = eachExports;

	var _helpersEach2 = _interopRequireDefault$7(_helpersEach);

	var _helpersHelperMissing = helperMissingExports;

	var _helpersHelperMissing2 = _interopRequireDefault$7(_helpersHelperMissing);

	var _helpersIf = _ifExports;

	var _helpersIf2 = _interopRequireDefault$7(_helpersIf);

	var _helpersLog = logExports;

	var _helpersLog2 = _interopRequireDefault$7(_helpersLog);

	var _helpersLookup = lookupExports;

	var _helpersLookup2 = _interopRequireDefault$7(_helpersLookup);

	var _helpersWith = _withExports;

	var _helpersWith2 = _interopRequireDefault$7(_helpersWith);

	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

	function moveHelperToHooks(instance, helperName, keepHelper) {
	  if (instance.helpers[helperName]) {
	    instance.hooks[helperName] = instance.helpers[helperName];
	    if (!keepHelper) {
	      delete instance.helpers[helperName];
	    }
	  }
	}

	var decorators = {};

	var inline = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;

		var _utils = utils;

		exports['default'] = function (instance) {
		  instance.registerDecorator('inline', function (fn, props, container, options) {
		    var ret = fn;
		    if (!props.partials) {
		      props.partials = {};
		      ret = function (context, options) {
		        // Create a new partials stack frame prior to exec.
		        var original = container.partials;
		        container.partials = _utils.extend({}, original, props.partials);
		        var ret = fn(context, options);
		        container.partials = original;
		        return ret;
		      };
		    }

		    props.partials[options.args[0]] = options.fn;

		    return ret;
		  });
		};

		module.exports = exports['default'];
		
	} (inline, inline.exports));

	var inlineExports = inline.exports;

	decorators.__esModule = true;
	decorators.registerDefaultDecorators = registerDefaultDecorators;
	// istanbul ignore next

	function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _decoratorsInline = inlineExports;

	var _decoratorsInline2 = _interopRequireDefault$6(_decoratorsInline);

	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

	var logger = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;

		var _utils = utils;

		var logger = {
		  methodMap: ['debug', 'info', 'warn', 'error'],
		  level: 'info',

		  // Maps a given level value to the `methodMap` indexes above.
		  lookupLevel: function lookupLevel(level) {
		    if (typeof level === 'string') {
		      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
		      if (levelMap >= 0) {
		        level = levelMap;
		      } else {
		        level = parseInt(level, 10);
		      }
		    }

		    return level;
		  },

		  // Can be overridden in the host environment
		  log: function log(level) {
		    level = logger.lookupLevel(level);

		    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
		      var method = logger.methodMap[level];
		      // eslint-disable-next-line no-console
		      if (!console[method]) {
		        method = 'log';
		      }

		      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		        message[_key - 1] = arguments[_key];
		      }

		      console[method].apply(console, message); // eslint-disable-line no-console
		    }
		  }
		};

		exports['default'] = logger;
		module.exports = exports['default'];
		
	} (logger, logger.exports));

	var loggerExports = logger.exports;

	var protoAccess = {};

	var createNewLookupObject$1 = {};

	createNewLookupObject$1.__esModule = true;
	createNewLookupObject$1.createNewLookupObject = createNewLookupObject;

	var _utils$4 = utils;

	/**
	 * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
	 * The resulting object can be used with "object[property]" to check if a property exists
	 * @param {...object} sources a varargs parameter of source objects that will be merged
	 * @returns {object}
	 */

	function createNewLookupObject() {
	  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
	    sources[_key] = arguments[_key];
	  }

	  return _utils$4.extend.apply(undefined, [Object.create(null)].concat(sources));
	}

	protoAccess.__esModule = true;
	protoAccess.createProtoAccessControl = createProtoAccessControl;
	protoAccess.resultIsAllowed = resultIsAllowed;
	protoAccess.resetLoggedProperties = resetLoggedProperties;
	// istanbul ignore next

	function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _createNewLookupObject = createNewLookupObject$1;

	var _logger$1 = loggerExports;

	var _logger2$1 = _interopRequireDefault$5(_logger$1);

	var loggedProperties = Object.create(null);

	function createProtoAccessControl(runtimeOptions) {
	  var defaultMethodWhiteList = Object.create(null);
	  defaultMethodWhiteList['constructor'] = false;
	  defaultMethodWhiteList['__defineGetter__'] = false;
	  defaultMethodWhiteList['__defineSetter__'] = false;
	  defaultMethodWhiteList['__lookupGetter__'] = false;

	  var defaultPropertyWhiteList = Object.create(null);
	  // eslint-disable-next-line no-proto
	  defaultPropertyWhiteList['__proto__'] = false;

	  return {
	    properties: {
	      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
	      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
	    },
	    methods: {
	      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
	      defaultValue: runtimeOptions.allowProtoMethodsByDefault
	    }
	  };
	}

	function resultIsAllowed(result, protoAccessControl, propertyName) {
	  if (typeof result === 'function') {
	    return checkWhiteList(protoAccessControl.methods, propertyName);
	  } else {
	    return checkWhiteList(protoAccessControl.properties, propertyName);
	  }
	}

	function checkWhiteList(protoAccessControlForType, propertyName) {
	  if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
	    return protoAccessControlForType.whitelist[propertyName] === true;
	  }
	  if (protoAccessControlForType.defaultValue !== undefined) {
	    return protoAccessControlForType.defaultValue;
	  }
	  logUnexpecedPropertyAccessOnce(propertyName);
	  return false;
	}

	function logUnexpecedPropertyAccessOnce(propertyName) {
	  if (loggedProperties[propertyName] !== true) {
	    loggedProperties[propertyName] = true;
	    _logger2$1['default'].log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
	  }
	}

	function resetLoggedProperties() {
	  Object.keys(loggedProperties).forEach(function (propertyName) {
	    delete loggedProperties[propertyName];
	  });
	}

	base$1.__esModule = true;
	base$1.HandlebarsEnvironment = HandlebarsEnvironment;
	// istanbul ignore next

	function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils$3 = utils;

	var _exception$3 = exceptionExports;

	var _exception2$3 = _interopRequireDefault$4(_exception$3);

	var _helpers$2 = helpers$1;

	var _decorators = decorators;

	var _logger = loggerExports;

	var _logger2 = _interopRequireDefault$4(_logger);

	var _internalProtoAccess$1 = protoAccess;

	var VERSION = '4.7.8';
	base$1.VERSION = VERSION;
	var COMPILER_REVISION = 8;
	base$1.COMPILER_REVISION = COMPILER_REVISION;
	var LAST_COMPATIBLE_COMPILER_REVISION = 7;

	base$1.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0 <4.3.0',
	  8: '>= 4.3.0'
	};

	base$1.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';

	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};

	  _helpers$2.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: _logger2['default'],
	  log: _logger2['default'].log,

	  registerHelper: function registerHelper(name, fn) {
	    if (_utils$3.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2$3['default']('Arg not supported with multiple helpers');
	      }
	      _utils$3.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (_utils$3.toString.call(name) === objectType) {
	      _utils$3.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2$3['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },

	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils$3.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2$3['default']('Arg not supported with multiple decorators');
	      }
	      _utils$3.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  },
	  /**
	   * Reset the memory of illegal property accesses that have already been logged.
	   * @deprecated should only be used in handlebars test-cases
	   */
	  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
	    _internalProtoAccess$1.resetLoggedProperties();
	  }
	};

	var log = _logger2['default'].log;

	base$1.log = log;
	base$1.createFrame = _utils$3.createFrame;
	base$1.logger = _logger2['default'];

	var safeString = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		function SafeString(string) {
		  this.string = string;
		}

		SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
		  return '' + this.string;
		};

		exports['default'] = SafeString;
		module.exports = exports['default'];
		
	} (safeString, safeString.exports));

	var safeStringExports = safeString.exports;

	var runtime = {};

	var wrapHelper$1 = {};

	wrapHelper$1.__esModule = true;
	wrapHelper$1.wrapHelper = wrapHelper;

	function wrapHelper(helper, transformOptionsFn) {
	  if (typeof helper !== 'function') {
	    // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
	    // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
	    return helper;
	  }
	  var wrapper = function wrapper() /* dynamic arguments */{
	    var options = arguments[arguments.length - 1];
	    arguments[arguments.length - 1] = transformOptionsFn(options);
	    return helper.apply(this, arguments);
	  };
	  return wrapper;
	}

	runtime.__esModule = true;
	runtime.checkRevision = checkRevision;
	runtime.template = template;
	runtime.wrapProgram = wrapProgram;
	runtime.resolvePartial = resolvePartial;
	runtime.invokePartial = invokePartial;
	runtime.noop = noop;
	// istanbul ignore next

	function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	// istanbul ignore next

	function _interopRequireWildcard$1(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _utils$2 = utils;

	var Utils$4 = _interopRequireWildcard$1(_utils$2);

	var _exception$2 = exceptionExports;

	var _exception2$2 = _interopRequireDefault$3(_exception$2);

	var _base = base$1;

	var _helpers$1 = helpers$1;

	var _internalWrapHelper = wrapHelper$1;

	var _internalProtoAccess = protoAccess;

	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _base.COMPILER_REVISION;

	  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
	    return;
	  }

	  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
	    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	        compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	    throw new _exception2$2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	  } else {
	    // Use the embedded version info since the runtime doesn't know about this revision yet
	    throw new _exception2$2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	  }
	}

	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2$2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2$2['default']('Unknown template object: ' + typeof templateSpec);
	  }

	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as pseudo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
	  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils$4.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }
	    partial = env.VM.resolvePartial.call(this, partial, context, options);

	    var extendedOptions = Utils$4.extend({}, options, {
	      hooks: this.hooks,
	      protoAccessControl: this.protoAccessControl
	    });

	    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, extendedOptions);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2$2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name, loc) {
	      if (!obj || !(name in obj)) {
	        throw new _exception2$2['default']('"' + name + '" not defined in ' + obj, {
	          loc: loc
	        });
	      }
	      return container.lookupProperty(obj, name);
	    },
	    lookupProperty: function lookupProperty(parent, propertyName) {
	      var result = parent[propertyName];
	      if (result == null) {
	        return result;
	      }
	      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
	        return result;
	      }

	      if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
	        return result;
	      }
	      return undefined;
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        var result = depths[i] && container.lookupProperty(depths[i], name);
	        if (result != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils$4.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    mergeIfNeeded: function mergeIfNeeded(param, common) {
	      var obj = param || common;

	      if (param && common && param !== common) {
	        obj = Utils$4.extend({}, common, param);
	      }

	      return obj;
	    },
	    // An empty object to use as replacement for null-contexts
	    nullContext: Object.seal({}),

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }

	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }

	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }

	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      var mergedHelpers = Utils$4.extend({}, env.helpers, options.helpers);
	      wrapHelpersToPassLookupProperty(mergedHelpers, container);
	      container.helpers = mergedHelpers;

	      if (templateSpec.usePartial) {
	        // Use mergeIfNeeded here to prevent compiling global partials multiple times
	        container.partials = container.mergeIfNeeded(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = Utils$4.extend({}, env.decorators, options.decorators);
	      }

	      container.hooks = {};
	      container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);

	      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
	      _helpers$1.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
	      _helpers$1.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
	    } else {
	      container.protoAccessControl = options.protoAccessControl; // internal option
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	      container.hooks = options.hooks;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2$2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2$2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var currentDepths = depths;
	    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
	      currentDepths = [context].concat(depths);
	    }

	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }

	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	/**
	 * This is currently part of the official API, therefore implementation details should not be changed.
	 */

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  // Use the current closure context to save the partial-block if this partial
	  var currentPartialBlock = options.data && options.data['partial-block'];
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }

	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    (function () {
	      options.data = _base.createFrame(options.data);
	      // Wrapper function to get access to currentPartialBlock from the closure
	      var fn = options.fn;
	      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        // Restore the partial-block from the closure for the execution of the block
	        // i.e. the part inside the block of the partial call.
	        options.data = _base.createFrame(options.data);
	        options.data['partial-block'] = currentPartialBlock;
	        return fn(context, options);
	      };
	      if (fn.partials) {
	        options.partials = Utils$4.extend({}, options.partials, fn.partials);
	      }
	    })();
	  }

	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }

	  if (partial === undefined) {
	    throw new _exception2$2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils$4.extend(prog, props);
	  }
	  return prog;
	}

	function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
	  Object.keys(mergedHelpers).forEach(function (helperName) {
	    var helper = mergedHelpers[helperName];
	    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
	  });
	}

	function passLookupPropertyOption(helper, container) {
	  var lookupProperty = container.lookupProperty;
	  return _internalWrapHelper.wrapHelper(helper, function (options) {
	    return Utils$4.extend({ lookupProperty: lookupProperty }, options);
	  });
	}

	var noConflict = {exports: {}};

	/* global globalThis */

	(function (module, exports) {

		exports.__esModule = true;

		exports['default'] = function (Handlebars) {
		  /* istanbul ignore next */
		  // https://mathiasbynens.be/notes/globalthis
		  (function () {
		    if (typeof globalThis === 'object') return;
		    Object.prototype.__defineGetter__('__magic__', function () {
		      return this;
		    });
		    __magic__.globalThis = __magic__; // eslint-disable-line no-undef
		    delete Object.prototype.__magic__;
		  })();

		  var $Handlebars = globalThis.Handlebars;

		  /* istanbul ignore next */
		  Handlebars.noConflict = function () {
		    if (globalThis.Handlebars === Handlebars) {
		      globalThis.Handlebars = $Handlebars;
		    }
		    return Handlebars;
		  };
		};

		module.exports = exports['default'];
		
	} (noConflict, noConflict.exports));

	var noConflictExports = noConflict.exports;

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		// istanbul ignore next

		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

		var _handlebarsBase = base$1;

		var base = _interopRequireWildcard(_handlebarsBase);

		// Each of these augment the Handlebars object. No need to setup here.
		// (This is done to easily share code between commonjs and browse envs)

		var _handlebarsSafeString = safeStringExports;

		var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

		var _handlebarsException = exceptionExports;

		var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

		var _handlebarsUtils = utils;

		var Utils = _interopRequireWildcard(_handlebarsUtils);

		var _handlebarsRuntime = runtime;

		var runtime$1 = _interopRequireWildcard(_handlebarsRuntime);

		var _handlebarsNoConflict = noConflictExports;

		var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

		// For compatibility and usage outside of module systems, make the Handlebars object a namespace
		function create() {
		  var hb = new base.HandlebarsEnvironment();

		  Utils.extend(hb, base);
		  hb.SafeString = _handlebarsSafeString2['default'];
		  hb.Exception = _handlebarsException2['default'];
		  hb.Utils = Utils;
		  hb.escapeExpression = Utils.escapeExpression;

		  hb.VM = runtime$1;
		  hb.template = function (spec) {
		    return runtime$1.template(spec, hb);
		  };

		  return hb;
		}

		var inst = create();
		inst.create = create;

		_handlebarsNoConflict2['default'](inst);

		inst['default'] = inst;

		exports['default'] = inst;
		module.exports = exports['default'];
		
	} (handlebars_runtime, handlebars_runtime.exports));

	var handlebars_runtimeExports = handlebars_runtime.exports;

	var ast = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		var AST = {
		  // Public API used to evaluate derived attributes regarding AST nodes
		  helpers: {
		    // a mustache is definitely a helper if:
		    // * it is an eligible helper, and
		    // * it has at least one parameter or hash segment
		    helperExpression: function helperExpression(node) {
		      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
		    },

		    scopedId: function scopedId(path) {
		      return (/^\.|this\b/.test(path.original)
		      );
		    },

		    // an ID is simple if it only has one part, and that part is not
		    // `..` or `this`.
		    simpleId: function simpleId(path) {
		      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
		    }
		  }
		};

		// Must be exported as an object rather than the root of the module as the jison lexer
		// must modify the object to operate properly.
		exports['default'] = AST;
		module.exports = exports['default'];
		
	} (ast, ast.exports));

	var astExports = ast.exports;

	var base = {};

	var parser = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		var handlebars = (function () {
		    var parser = { trace: function trace() {},
		        yy: {},
		        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
		        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
		        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
		        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

		            var $0 = $$.length - 1;
		            switch (yystate) {
		                case 1:
		                    return $$[$0 - 1];
		                case 2:
		                    this.$ = yy.prepareProgram($$[$0]);
		                    break;
		                case 3:
		                    this.$ = $$[$0];
		                    break;
		                case 4:
		                    this.$ = $$[$0];
		                    break;
		                case 5:
		                    this.$ = $$[$0];
		                    break;
		                case 6:
		                    this.$ = $$[$0];
		                    break;
		                case 7:
		                    this.$ = $$[$0];
		                    break;
		                case 8:
		                    this.$ = $$[$0];
		                    break;
		                case 9:
		                    this.$ = {
		                        type: 'CommentStatement',
		                        value: yy.stripComment($$[$0]),
		                        strip: yy.stripFlags($$[$0], $$[$0]),
		                        loc: yy.locInfo(this._$)
		                    };

		                    break;
		                case 10:
		                    this.$ = {
		                        type: 'ContentStatement',
		                        original: $$[$0],
		                        value: $$[$0],
		                        loc: yy.locInfo(this._$)
		                    };

		                    break;
		                case 11:
		                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
		                    break;
		                case 12:
		                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
		                    break;
		                case 13:
		                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
		                    break;
		                case 14:
		                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
		                    break;
		                case 15:
		                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 16:
		                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 17:
		                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 18:
		                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
		                    break;
		                case 19:
		                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
		                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
		                    program.chained = true;

		                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

		                    break;
		                case 20:
		                    this.$ = $$[$0];
		                    break;
		                case 21:
		                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
		                    break;
		                case 22:
		                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
		                    break;
		                case 23:
		                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
		                    break;
		                case 24:
		                    this.$ = {
		                        type: 'PartialStatement',
		                        name: $$[$0 - 3],
		                        params: $$[$0 - 2],
		                        hash: $$[$0 - 1],
		                        indent: '',
		                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
		                        loc: yy.locInfo(this._$)
		                    };

		                    break;
		                case 25:
		                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
		                    break;
		                case 26:
		                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
		                    break;
		                case 27:
		                    this.$ = $$[$0];
		                    break;
		                case 28:
		                    this.$ = $$[$0];
		                    break;
		                case 29:
		                    this.$ = {
		                        type: 'SubExpression',
		                        path: $$[$0 - 3],
		                        params: $$[$0 - 2],
		                        hash: $$[$0 - 1],
		                        loc: yy.locInfo(this._$)
		                    };

		                    break;
		                case 30:
		                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
		                    break;
		                case 31:
		                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
		                    break;
		                case 32:
		                    this.$ = yy.id($$[$0 - 1]);
		                    break;
		                case 33:
		                    this.$ = $$[$0];
		                    break;
		                case 34:
		                    this.$ = $$[$0];
		                    break;
		                case 35:
		                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
		                    break;
		                case 36:
		                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
		                    break;
		                case 37:
		                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
		                    break;
		                case 38:
		                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
		                    break;
		                case 39:
		                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
		                    break;
		                case 40:
		                    this.$ = $$[$0];
		                    break;
		                case 41:
		                    this.$ = $$[$0];
		                    break;
		                case 42:
		                    this.$ = yy.preparePath(true, $$[$0], this._$);
		                    break;
		                case 43:
		                    this.$ = yy.preparePath(false, $$[$0], this._$);
		                    break;
		                case 44:
		                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
		                    break;
		                case 45:
		                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
		                    break;
		                case 46:
		                    this.$ = [];
		                    break;
		                case 47:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 48:
		                    this.$ = [];
		                    break;
		                case 49:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 50:
		                    this.$ = [];
		                    break;
		                case 51:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 58:
		                    this.$ = [];
		                    break;
		                case 59:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 64:
		                    this.$ = [];
		                    break;
		                case 65:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 70:
		                    this.$ = [];
		                    break;
		                case 71:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 78:
		                    this.$ = [];
		                    break;
		                case 79:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 82:
		                    this.$ = [];
		                    break;
		                case 83:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 86:
		                    this.$ = [];
		                    break;
		                case 87:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 90:
		                    this.$ = [];
		                    break;
		                case 91:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 94:
		                    this.$ = [];
		                    break;
		                case 95:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 98:
		                    this.$ = [$$[$0]];
		                    break;
		                case 99:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 100:
		                    this.$ = [$$[$0]];
		                    break;
		                case 101:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		            }
		        },
		        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
		        defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
		        parseError: function parseError(str, hash) {
		            throw new Error(str);
		        },
		        parse: function parse(input) {
		            var self = this,
		                stack = [0],
		                vstack = [null],
		                lstack = [],
		                table = this.table,
		                yytext = "",
		                yylineno = 0,
		                yyleng = 0;
		            this.lexer.setInput(input);
		            this.lexer.yy = this.yy;
		            this.yy.lexer = this.lexer;
		            this.yy.parser = this;
		            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
		            var yyloc = this.lexer.yylloc;
		            lstack.push(yyloc);
		            var ranges = this.lexer.options && this.lexer.options.ranges;
		            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
		            function lex() {
		                var token;
		                token = self.lexer.lex() || 1;
		                if (typeof token !== "number") {
		                    token = self.symbols_[token] || token;
		                }
		                return token;
		            }
		            var symbol,
		                state,
		                action,
		                r,
		                yyval = {},
		                p,
		                len,
		                newState,
		                expected;
		            while (true) {
		                state = stack[stack.length - 1];
		                if (this.defaultActions[state]) {
		                    action = this.defaultActions[state];
		                } else {
		                    if (symbol === null || typeof symbol == "undefined") {
		                        symbol = lex();
		                    }
		                    action = table[state] && table[state][symbol];
		                }
		                if (typeof action === "undefined" || !action.length || !action[0]) {
		                    var errStr = "";
		                    {
		                        expected = [];
		                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
		                            expected.push("'" + this.terminals_[p] + "'");
		                        }
		                        if (this.lexer.showPosition) {
		                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
		                        } else {
		                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
		                        }
		                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
		                    }
		                }
		                if (action[0] instanceof Array && action.length > 1) {
		                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
		                }
		                switch (action[0]) {
		                    case 1:
		                        stack.push(symbol);
		                        vstack.push(this.lexer.yytext);
		                        lstack.push(this.lexer.yylloc);
		                        stack.push(action[1]);
		                        symbol = null;
		                        {
		                            yyleng = this.lexer.yyleng;
		                            yytext = this.lexer.yytext;
		                            yylineno = this.lexer.yylineno;
		                            yyloc = this.lexer.yylloc;
		                        }
		                        break;
		                    case 2:
		                        len = this.productions_[action[1]][1];
		                        yyval.$ = vstack[vstack.length - len];
		                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
		                        if (ranges) {
		                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
		                        }
		                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
		                        if (typeof r !== "undefined") {
		                            return r;
		                        }
		                        if (len) {
		                            stack = stack.slice(0, -1 * len * 2);
		                            vstack = vstack.slice(0, -1 * len);
		                            lstack = lstack.slice(0, -1 * len);
		                        }
		                        stack.push(this.productions_[action[1]][0]);
		                        vstack.push(yyval.$);
		                        lstack.push(yyval._$);
		                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
		                        stack.push(newState);
		                        break;
		                    case 3:
		                        return true;
		                }
		            }
		            return true;
		        }
		    };
		    /* Jison generated lexer */
		    var lexer = (function () {
		        var lexer = { EOF: 1,
		            parseError: function parseError(str, hash) {
		                if (this.yy.parser) {
		                    this.yy.parser.parseError(str, hash);
		                } else {
		                    throw new Error(str);
		                }
		            },
		            setInput: function setInput(input) {
		                this._input = input;
		                this._more = this._less = this.done = false;
		                this.yylineno = this.yyleng = 0;
		                this.yytext = this.matched = this.match = '';
		                this.conditionStack = ['INITIAL'];
		                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
		                if (this.options.ranges) this.yylloc.range = [0, 0];
		                this.offset = 0;
		                return this;
		            },
		            input: function input() {
		                var ch = this._input[0];
		                this.yytext += ch;
		                this.yyleng++;
		                this.offset++;
		                this.match += ch;
		                this.matched += ch;
		                var lines = ch.match(/(?:\r\n?|\n).*/g);
		                if (lines) {
		                    this.yylineno++;
		                    this.yylloc.last_line++;
		                } else {
		                    this.yylloc.last_column++;
		                }
		                if (this.options.ranges) this.yylloc.range[1]++;

		                this._input = this._input.slice(1);
		                return ch;
		            },
		            unput: function unput(ch) {
		                var len = ch.length;
		                var lines = ch.split(/(?:\r\n?|\n)/g);

		                this._input = ch + this._input;
		                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
		                //this.yyleng -= len;
		                this.offset -= len;
		                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
		                this.match = this.match.substr(0, this.match.length - 1);
		                this.matched = this.matched.substr(0, this.matched.length - 1);

		                if (lines.length - 1) this.yylineno -= lines.length - 1;
		                var r = this.yylloc.range;

		                this.yylloc = { first_line: this.yylloc.first_line,
		                    last_line: this.yylineno + 1,
		                    first_column: this.yylloc.first_column,
		                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
		                };

		                if (this.options.ranges) {
		                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
		                }
		                return this;
		            },
		            more: function more() {
		                this._more = true;
		                return this;
		            },
		            less: function less(n) {
		                this.unput(this.match.slice(n));
		            },
		            pastInput: function pastInput() {
		                var past = this.matched.substr(0, this.matched.length - this.match.length);
		                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
		            },
		            upcomingInput: function upcomingInput() {
		                var next = this.match;
		                if (next.length < 20) {
		                    next += this._input.substr(0, 20 - next.length);
		                }
		                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
		            },
		            showPosition: function showPosition() {
		                var pre = this.pastInput();
		                var c = new Array(pre.length + 1).join("-");
		                return pre + this.upcomingInput() + "\n" + c + "^";
		            },
		            next: function next() {
		                if (this.done) {
		                    return this.EOF;
		                }
		                if (!this._input) this.done = true;

		                var token, match, tempMatch, index, lines;
		                if (!this._more) {
		                    this.yytext = '';
		                    this.match = '';
		                }
		                var rules = this._currentRules();
		                for (var i = 0; i < rules.length; i++) {
		                    tempMatch = this._input.match(this.rules[rules[i]]);
		                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
		                        match = tempMatch;
		                        index = i;
		                        if (!this.options.flex) break;
		                    }
		                }
		                if (match) {
		                    lines = match[0].match(/(?:\r\n?|\n).*/g);
		                    if (lines) this.yylineno += lines.length;
		                    this.yylloc = { first_line: this.yylloc.last_line,
		                        last_line: this.yylineno + 1,
		                        first_column: this.yylloc.last_column,
		                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
		                    this.yytext += match[0];
		                    this.match += match[0];
		                    this.matches = match;
		                    this.yyleng = this.yytext.length;
		                    if (this.options.ranges) {
		                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
		                    }
		                    this._more = false;
		                    this._input = this._input.slice(match[0].length);
		                    this.matched += match[0];
		                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
		                    if (this.done && this._input) this.done = false;
		                    if (token) return token;else return;
		                }
		                if (this._input === "") {
		                    return this.EOF;
		                } else {
		                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
		                }
		            },
		            lex: function lex() {
		                var r = this.next();
		                if (typeof r !== 'undefined') {
		                    return r;
		                } else {
		                    return this.lex();
		                }
		            },
		            begin: function begin(condition) {
		                this.conditionStack.push(condition);
		            },
		            popState: function popState() {
		                return this.conditionStack.pop();
		            },
		            _currentRules: function _currentRules() {
		                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
		            },
		            topState: function topState() {
		                return this.conditionStack[this.conditionStack.length - 2];
		            },
		            pushState: function begin(condition) {
		                this.begin(condition);
		            } };
		        lexer.options = {};
		        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

		            function strip(start, end) {
		                return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
		            }
		            switch ($avoiding_name_collisions) {
		                case 0:
		                    if (yy_.yytext.slice(-2) === "\\\\") {
		                        strip(0, 1);
		                        this.begin("mu");
		                    } else if (yy_.yytext.slice(-1) === "\\") {
		                        strip(0, 1);
		                        this.begin("emu");
		                    } else {
		                        this.begin("mu");
		                    }
		                    if (yy_.yytext) return 15;

		                    break;
		                case 1:
		                    return 15;
		                case 2:
		                    this.popState();
		                    return 15;
		                case 3:
		                    this.begin('raw');return 15;
		                case 4:
		                    this.popState();
		                    // Should be using `this.topState()` below, but it currently
		                    // returns the second top instead of the first top. Opened an
		                    // issue about it at https://github.com/zaach/jison/issues/291
		                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
		                        return 15;
		                    } else {
		                        strip(5, 9);
		                        return 'END_RAW_BLOCK';
		                    }
		                case 5:
		                    return 15;
		                case 6:
		                    this.popState();
		                    return 14;
		                case 7:
		                    return 65;
		                case 8:
		                    return 68;
		                case 9:
		                    return 19;
		                case 10:
		                    this.popState();
		                    this.begin('raw');
		                    return 23;
		                case 11:
		                    return 55;
		                case 12:
		                    return 60;
		                case 13:
		                    return 29;
		                case 14:
		                    return 47;
		                case 15:
		                    this.popState();return 44;
		                case 16:
		                    this.popState();return 44;
		                case 17:
		                    return 34;
		                case 18:
		                    return 39;
		                case 19:
		                    return 51;
		                case 20:
		                    return 48;
		                case 21:
		                    this.unput(yy_.yytext);
		                    this.popState();
		                    this.begin('com');

		                    break;
		                case 22:
		                    this.popState();
		                    return 14;
		                case 23:
		                    return 48;
		                case 24:
		                    return 73;
		                case 25:
		                    return 72;
		                case 26:
		                    return 72;
		                case 27:
		                    return 87;
		                case 28:
		                    // ignore whitespace
		                    break;
		                case 29:
		                    this.popState();return 54;
		                case 30:
		                    this.popState();return 33;
		                case 31:
		                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
		                case 32:
		                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
		                case 33:
		                    return 85;
		                case 34:
		                    return 82;
		                case 35:
		                    return 82;
		                case 36:
		                    return 83;
		                case 37:
		                    return 84;
		                case 38:
		                    return 81;
		                case 39:
		                    return 75;
		                case 40:
		                    return 77;
		                case 41:
		                    return 72;
		                case 42:
		                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
		                case 43:
		                    return 'INVALID';
		                case 44:
		                    return 5;
		            }
		        };
		        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
		        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
		        return lexer;
		    })();
		    parser.lexer = lexer;
		    function Parser() {
		        this.yy = {};
		    }Parser.prototype = parser;parser.Parser = Parser;
		    return new Parser();
		})();exports["default"] = handlebars;
		module.exports = exports["default"];
		
	} (parser, parser.exports));

	var parserExports = parser.exports;

	var whitespaceControl = {exports: {}};

	var visitor = {exports: {}};

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _exception = exceptionExports;

		var _exception2 = _interopRequireDefault(_exception);

		function Visitor() {
		  this.parents = [];
		}

		Visitor.prototype = {
		  constructor: Visitor,
		  mutating: false,

		  // Visits a given value. If mutating, will replace the value if necessary.
		  acceptKey: function acceptKey(node, name) {
		    var value = this.accept(node[name]);
		    if (this.mutating) {
		      // Hacky sanity check: This may have a few false positives for type for the helper
		      // methods but will generally do the right thing without a lot of overhead.
		      if (value && !Visitor.prototype[value.type]) {
		        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
		      }
		      node[name] = value;
		    }
		  },

		  // Performs an accept operation with added sanity check to ensure
		  // required keys are not removed.
		  acceptRequired: function acceptRequired(node, name) {
		    this.acceptKey(node, name);

		    if (!node[name]) {
		      throw new _exception2['default'](node.type + ' requires ' + name);
		    }
		  },

		  // Traverses a given array. If mutating, empty respnses will be removed
		  // for child elements.
		  acceptArray: function acceptArray(array) {
		    for (var i = 0, l = array.length; i < l; i++) {
		      this.acceptKey(array, i);

		      if (!array[i]) {
		        array.splice(i, 1);
		        i--;
		        l--;
		      }
		    }
		  },

		  accept: function accept(object) {
		    if (!object) {
		      return;
		    }

		    /* istanbul ignore next: Sanity code */
		    if (!this[object.type]) {
		      throw new _exception2['default']('Unknown type: ' + object.type, object);
		    }

		    if (this.current) {
		      this.parents.unshift(this.current);
		    }
		    this.current = object;

		    var ret = this[object.type](object);

		    this.current = this.parents.shift();

		    if (!this.mutating || ret) {
		      return ret;
		    } else if (ret !== false) {
		      return object;
		    }
		  },

		  Program: function Program(program) {
		    this.acceptArray(program.body);
		  },

		  MustacheStatement: visitSubExpression,
		  Decorator: visitSubExpression,

		  BlockStatement: visitBlock,
		  DecoratorBlock: visitBlock,

		  PartialStatement: visitPartial,
		  PartialBlockStatement: function PartialBlockStatement(partial) {
		    visitPartial.call(this, partial);

		    this.acceptKey(partial, 'program');
		  },

		  ContentStatement: function ContentStatement() /* content */{},
		  CommentStatement: function CommentStatement() /* comment */{},

		  SubExpression: visitSubExpression,

		  PathExpression: function PathExpression() /* path */{},

		  StringLiteral: function StringLiteral() /* string */{},
		  NumberLiteral: function NumberLiteral() /* number */{},
		  BooleanLiteral: function BooleanLiteral() /* bool */{},
		  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
		  NullLiteral: function NullLiteral() /* literal */{},

		  Hash: function Hash(hash) {
		    this.acceptArray(hash.pairs);
		  },
		  HashPair: function HashPair(pair) {
		    this.acceptRequired(pair, 'value');
		  }
		};

		function visitSubExpression(mustache) {
		  this.acceptRequired(mustache, 'path');
		  this.acceptArray(mustache.params);
		  this.acceptKey(mustache, 'hash');
		}
		function visitBlock(block) {
		  visitSubExpression.call(this, block);

		  this.acceptKey(block, 'program');
		  this.acceptKey(block, 'inverse');
		}
		function visitPartial(partial) {
		  this.acceptRequired(partial, 'name');
		  this.acceptArray(partial.params);
		  this.acceptKey(partial, 'hash');
		}

		exports['default'] = Visitor;
		module.exports = exports['default'];
		
	} (visitor, visitor.exports));

	var visitorExports = visitor.exports;

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _visitor = visitorExports;

		var _visitor2 = _interopRequireDefault(_visitor);

		function WhitespaceControl() {
		  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		  this.options = options;
		}
		WhitespaceControl.prototype = new _visitor2['default']();

		WhitespaceControl.prototype.Program = function (program) {
		  var doStandalone = !this.options.ignoreStandalone;

		  var isRoot = !this.isRootSeen;
		  this.isRootSeen = true;

		  var body = program.body;
		  for (var i = 0, l = body.length; i < l; i++) {
		    var current = body[i],
		        strip = this.accept(current);

		    if (!strip) {
		      continue;
		    }

		    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
		        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
		        openStandalone = strip.openStandalone && _isPrevWhitespace,
		        closeStandalone = strip.closeStandalone && _isNextWhitespace,
		        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

		    if (strip.close) {
		      omitRight(body, i, true);
		    }
		    if (strip.open) {
		      omitLeft(body, i, true);
		    }

		    if (doStandalone && inlineStandalone) {
		      omitRight(body, i);

		      if (omitLeft(body, i)) {
		        // If we are on a standalone node, save the indent info for partials
		        if (current.type === 'PartialStatement') {
		          // Pull out the whitespace from the final line
		          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
		        }
		      }
		    }
		    if (doStandalone && openStandalone) {
		      omitRight((current.program || current.inverse).body);

		      // Strip out the previous content node if it's whitespace only
		      omitLeft(body, i);
		    }
		    if (doStandalone && closeStandalone) {
		      // Always strip the next node
		      omitRight(body, i);

		      omitLeft((current.inverse || current.program).body);
		    }
		  }

		  return program;
		};

		WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
		  this.accept(block.program);
		  this.accept(block.inverse);

		  // Find the inverse program that is involed with whitespace stripping.
		  var program = block.program || block.inverse,
		      inverse = block.program && block.inverse,
		      firstInverse = inverse,
		      lastInverse = inverse;

		  if (inverse && inverse.chained) {
		    firstInverse = inverse.body[0].program;

		    // Walk the inverse chain to find the last inverse that is actually in the chain.
		    while (lastInverse.chained) {
		      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
		    }
		  }

		  var strip = {
		    open: block.openStrip.open,
		    close: block.closeStrip.close,

		    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
		    // so our parent can determine if we actually are standalone
		    openStandalone: isNextWhitespace(program.body),
		    closeStandalone: isPrevWhitespace((firstInverse || program).body)
		  };

		  if (block.openStrip.close) {
		    omitRight(program.body, null, true);
		  }

		  if (inverse) {
		    var inverseStrip = block.inverseStrip;

		    if (inverseStrip.open) {
		      omitLeft(program.body, null, true);
		    }

		    if (inverseStrip.close) {
		      omitRight(firstInverse.body, null, true);
		    }
		    if (block.closeStrip.open) {
		      omitLeft(lastInverse.body, null, true);
		    }

		    // Find standalone else statments
		    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
		      omitLeft(program.body);
		      omitRight(firstInverse.body);
		    }
		  } else if (block.closeStrip.open) {
		    omitLeft(program.body, null, true);
		  }

		  return strip;
		};

		WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
		  return mustache.strip;
		};

		WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
		  /* istanbul ignore next */
		  var strip = node.strip || {};
		  return {
		    inlineStandalone: true,
		    open: strip.open,
		    close: strip.close
		  };
		};

		function isPrevWhitespace(body, i, isRoot) {
		  if (i === undefined) {
		    i = body.length;
		  }

		  // Nodes that end with newlines are considered whitespace (but are special
		  // cased for strip operations)
		  var prev = body[i - 1],
		      sibling = body[i - 2];
		  if (!prev) {
		    return isRoot;
		  }

		  if (prev.type === 'ContentStatement') {
		    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
		  }
		}
		function isNextWhitespace(body, i, isRoot) {
		  if (i === undefined) {
		    i = -1;
		  }

		  var next = body[i + 1],
		      sibling = body[i + 2];
		  if (!next) {
		    return isRoot;
		  }

		  if (next.type === 'ContentStatement') {
		    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
		  }
		}

		// Marks the node to the right of the position as omitted.
		// I.e. {{foo}}' ' will mark the ' ' node as omitted.
		//
		// If i is undefined, then the first child will be marked as such.
		//
		// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
		// content is met.
		function omitRight(body, i, multiple) {
		  var current = body[i == null ? 0 : i + 1];
		  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
		    return;
		  }

		  var original = current.value;
		  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
		  current.rightStripped = current.value !== original;
		}

		// Marks the node to the left of the position as omitted.
		// I.e. ' '{{foo}} will mark the ' ' node as omitted.
		//
		// If i is undefined then the last child will be marked as such.
		//
		// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
		// content is met.
		function omitLeft(body, i, multiple) {
		  var current = body[i == null ? body.length - 1 : i - 1];
		  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
		    return;
		  }

		  // We omit the last node if it's whitespace only and not preceded by a non-content node.
		  var original = current.value;
		  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
		  current.leftStripped = current.value !== original;
		  return current.leftStripped;
		}

		exports['default'] = WhitespaceControl;
		module.exports = exports['default'];
		
	} (whitespaceControl, whitespaceControl.exports));

	var whitespaceControlExports = whitespaceControl.exports;

	var helpers = {};

	helpers.__esModule = true;
	helpers.SourceLocation = SourceLocation;
	helpers.id = id;
	helpers.stripFlags = stripFlags;
	helpers.stripComment = stripComment;
	helpers.preparePath = preparePath;
	helpers.prepareMustache = prepareMustache;
	helpers.prepareRawBlock = prepareRawBlock;
	helpers.prepareBlock = prepareBlock;
	helpers.prepareProgram = prepareProgram;
	helpers.preparePartialBlock = preparePartialBlock;
	// istanbul ignore next

	function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _exception$1 = exceptionExports;

	var _exception2$1 = _interopRequireDefault$2(_exception$1);

	function validateClose(open, close) {
	  close = close.path ? close.path.original : close;

	  if (open.path.original !== close) {
	    var errorNode = { loc: open.path.loc };

	    throw new _exception2$1['default'](open.path.original + " doesn't match " + close, errorNode);
	  }
	}

	function SourceLocation(source, locInfo) {
	  this.source = source;
	  this.start = {
	    line: locInfo.first_line,
	    column: locInfo.first_column
	  };
	  this.end = {
	    line: locInfo.last_line,
	    column: locInfo.last_column
	  };
	}

	function id(token) {
	  if (/^\[.*\]$/.test(token)) {
	    return token.substring(1, token.length - 1);
	  } else {
	    return token;
	  }
	}

	function stripFlags(open, close) {
	  return {
	    open: open.charAt(2) === '~',
	    close: close.charAt(close.length - 3) === '~'
	  };
	}

	function stripComment(comment) {
	  return comment.replace(/^\{\{~?!-?-?/, '').replace(/-?-?~?\}\}$/, '');
	}

	function preparePath(data, parts, loc) {
	  loc = this.locInfo(loc);

	  var original = data ? '@' : '',
	      dig = [],
	      depth = 0;

	  for (var i = 0, l = parts.length; i < l; i++) {
	    var part = parts[i].part,

	    // If we have [] syntax then we do not treat path references as operators,
	    // i.e. foo.[this] resolves to approximately context.foo['this']
	    isLiteral = parts[i].original !== part;
	    original += (parts[i].separator || '') + part;

	    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
	      if (dig.length > 0) {
	        throw new _exception2$1['default']('Invalid path: ' + original, { loc: loc });
	      } else if (part === '..') {
	        depth++;
	      }
	    } else {
	      dig.push(part);
	    }
	  }

	  return {
	    type: 'PathExpression',
	    data: data,
	    depth: depth,
	    parts: dig,
	    original: original,
	    loc: loc
	  };
	}

	function prepareMustache(path, params, hash, open, strip, locInfo) {
	  // Must use charAt to support IE pre-10
	  var escapeFlag = open.charAt(3) || open.charAt(2),
	      escaped = escapeFlag !== '{' && escapeFlag !== '&';

	  var decorator = /\*/.test(open);
	  return {
	    type: decorator ? 'Decorator' : 'MustacheStatement',
	    path: path,
	    params: params,
	    hash: hash,
	    escaped: escaped,
	    strip: strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareRawBlock(openRawBlock, contents, close, locInfo) {
	  validateClose(openRawBlock, close);

	  locInfo = this.locInfo(locInfo);
	  var program = {
	    type: 'Program',
	    body: contents,
	    strip: {},
	    loc: locInfo
	  };

	  return {
	    type: 'BlockStatement',
	    path: openRawBlock.path,
	    params: openRawBlock.params,
	    hash: openRawBlock.hash,
	    program: program,
	    openStrip: {},
	    inverseStrip: {},
	    closeStrip: {},
	    loc: locInfo
	  };
	}

	function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
	  if (close && close.path) {
	    validateClose(openBlock, close);
	  }

	  var decorator = /\*/.test(openBlock.open);

	  program.blockParams = openBlock.blockParams;

	  var inverse = undefined,
	      inverseStrip = undefined;

	  if (inverseAndProgram) {
	    if (decorator) {
	      throw new _exception2$1['default']('Unexpected inverse block on decorator', inverseAndProgram);
	    }

	    if (inverseAndProgram.chain) {
	      inverseAndProgram.program.body[0].closeStrip = close.strip;
	    }

	    inverseStrip = inverseAndProgram.strip;
	    inverse = inverseAndProgram.program;
	  }

	  if (inverted) {
	    inverted = inverse;
	    inverse = program;
	    program = inverted;
	  }

	  return {
	    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
	    path: openBlock.path,
	    params: openBlock.params,
	    hash: openBlock.hash,
	    program: program,
	    inverse: inverse,
	    openStrip: openBlock.strip,
	    inverseStrip: inverseStrip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareProgram(statements, loc) {
	  if (!loc && statements.length) {
	    var firstLoc = statements[0].loc,
	        lastLoc = statements[statements.length - 1].loc;

	    /* istanbul ignore else */
	    if (firstLoc && lastLoc) {
	      loc = {
	        source: firstLoc.source,
	        start: {
	          line: firstLoc.start.line,
	          column: firstLoc.start.column
	        },
	        end: {
	          line: lastLoc.end.line,
	          column: lastLoc.end.column
	        }
	      };
	    }
	  }

	  return {
	    type: 'Program',
	    body: statements,
	    strip: {},
	    loc: loc
	  };
	}

	function preparePartialBlock(open, program, close, locInfo) {
	  validateClose(open, close);

	  return {
	    type: 'PartialBlockStatement',
	    name: open.path,
	    params: open.params,
	    hash: open.hash,
	    program: program,
	    openStrip: open.strip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	base.__esModule = true;
	base.parseWithoutProcessing = parseWithoutProcessing;
	base.parse = parse;
	// istanbul ignore next

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	// istanbul ignore next

	function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parser = parserExports;

	var _parser2 = _interopRequireDefault$1(_parser);

	var _whitespaceControl = whitespaceControlExports;

	var _whitespaceControl2 = _interopRequireDefault$1(_whitespaceControl);

	var _helpers = helpers;

	var Helpers = _interopRequireWildcard(_helpers);

	var _utils$1 = utils;

	base.parser = _parser2['default'];

	var yy = {};
	_utils$1.extend(yy, Helpers);

	function parseWithoutProcessing(input, options) {
	  // Just return if an already-compiled AST was passed in.
	  if (input.type === 'Program') {
	    return input;
	  }

	  _parser2['default'].yy = yy;

	  // Altering the shared object here, but this is ok as parser is a sync operation
	  yy.locInfo = function (locInfo) {
	    return new yy.SourceLocation(options && options.srcName, locInfo);
	  };

	  var ast = _parser2['default'].parse(input);

	  return ast;
	}

	function parse(input, options) {
	  var ast = parseWithoutProcessing(input, options);
	  var strip = new _whitespaceControl2['default'](options);

	  return strip.accept(ast);
	}

	var compiler = {};

	/* eslint-disable new-cap */

	compiler.__esModule = true;
	compiler.Compiler = Compiler;
	compiler.precompile = precompile;
	compiler.compile = compile;
	// istanbul ignore next

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _exception = exceptionExports;

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = utils;

	var _ast = astExports;

	var _ast2 = _interopRequireDefault(_ast);

	var slice = [].slice;

	function Compiler() {}

	// the foundHelper register will disambiguate helper lookup from finding a
	// function in a context. This is necessary for mustache compatibility, which
	// requires that context functions in blocks are evaluated by blockHelperMissing,
	// and then proceed as if the resulting value was provided to blockHelperMissing.

	Compiler.prototype = {
	  compiler: Compiler,

	  equals: function equals(other) {
	    var len = this.opcodes.length;
	    if (other.opcodes.length !== len) {
	      return false;
	    }

	    for (var i = 0; i < len; i++) {
	      var opcode = this.opcodes[i],
	          otherOpcode = other.opcodes[i];
	      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
	        return false;
	      }
	    }

	    // We know that length is the same between the two arrays because they are directly tied
	    // to the opcode behavior above.
	    len = this.children.length;
	    for (var i = 0; i < len; i++) {
	      if (!this.children[i].equals(other.children[i])) {
	        return false;
	      }
	    }

	    return true;
	  },

	  guid: 0,

	  compile: function compile(program, options) {
	    this.sourceNode = [];
	    this.opcodes = [];
	    this.children = [];
	    this.options = options;
	    this.stringParams = options.stringParams;
	    this.trackIds = options.trackIds;

	    options.blockParams = options.blockParams || [];

	    options.knownHelpers = _utils.extend(Object.create(null), {
	      helperMissing: true,
	      blockHelperMissing: true,
	      each: true,
	      'if': true,
	      unless: true,
	      'with': true,
	      log: true,
	      lookup: true
	    }, options.knownHelpers);

	    return this.accept(program);
	  },

	  compileProgram: function compileProgram(program) {
	    var childCompiler = new this.compiler(),
	        // eslint-disable-line new-cap
	    result = childCompiler.compile(program, this.options),
	        guid = this.guid++;

	    this.usePartial = this.usePartial || result.usePartial;

	    this.children[guid] = result;
	    this.useDepths = this.useDepths || result.useDepths;

	    return guid;
	  },

	  accept: function accept(node) {
	    /* istanbul ignore next: Sanity code */
	    if (!this[node.type]) {
	      throw new _exception2['default']('Unknown type: ' + node.type, node);
	    }

	    this.sourceNode.unshift(node);
	    var ret = this[node.type](node);
	    this.sourceNode.shift();
	    return ret;
	  },

	  Program: function Program(program) {
	    this.options.blockParams.unshift(program.blockParams);

	    var body = program.body,
	        bodyLength = body.length;
	    for (var i = 0; i < bodyLength; i++) {
	      this.accept(body[i]);
	    }

	    this.options.blockParams.shift();

	    this.isSimple = bodyLength === 1;
	    this.blockParams = program.blockParams ? program.blockParams.length : 0;

	    return this;
	  },

	  BlockStatement: function BlockStatement(block) {
	    transformLiteralToPath(block);

	    var program = block.program,
	        inverse = block.inverse;

	    program = program && this.compileProgram(program);
	    inverse = inverse && this.compileProgram(inverse);

	    var type = this.classifySexpr(block);

	    if (type === 'helper') {
	      this.helperSexpr(block, program, inverse);
	    } else if (type === 'simple') {
	      this.simpleSexpr(block);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('blockValue', block.path.original);
	    } else {
	      this.ambiguousSexpr(block, program, inverse);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('ambiguousBlockValue');
	    }

	    this.opcode('append');
	  },

	  DecoratorBlock: function DecoratorBlock(decorator) {
	    var program = decorator.program && this.compileProgram(decorator.program);
	    var params = this.setupFullMustacheParams(decorator, program, undefined),
	        path = decorator.path;

	    this.useDecorators = true;
	    this.opcode('registerDecorator', params.length, path.original);
	  },

	  PartialStatement: function PartialStatement(partial) {
	    this.usePartial = true;

	    var program = partial.program;
	    if (program) {
	      program = this.compileProgram(partial.program);
	    }

	    var params = partial.params;
	    if (params.length > 1) {
	      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
	    } else if (!params.length) {
	      if (this.options.explicitPartialContext) {
	        this.opcode('pushLiteral', 'undefined');
	      } else {
	        params.push({ type: 'PathExpression', parts: [], depth: 0 });
	      }
	    }

	    var partialName = partial.name.original,
	        isDynamic = partial.name.type === 'SubExpression';
	    if (isDynamic) {
	      this.accept(partial.name);
	    }

	    this.setupFullMustacheParams(partial, program, undefined, true);

	    var indent = partial.indent || '';
	    if (this.options.preventIndent && indent) {
	      this.opcode('appendContent', indent);
	      indent = '';
	    }

	    this.opcode('invokePartial', isDynamic, partialName, indent);
	    this.opcode('append');
	  },
	  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
	    this.PartialStatement(partialBlock);
	  },

	  MustacheStatement: function MustacheStatement(mustache) {
	    this.SubExpression(mustache);

	    if (mustache.escaped && !this.options.noEscape) {
	      this.opcode('appendEscaped');
	    } else {
	      this.opcode('append');
	    }
	  },
	  Decorator: function Decorator(decorator) {
	    this.DecoratorBlock(decorator);
	  },

	  ContentStatement: function ContentStatement(content) {
	    if (content.value) {
	      this.opcode('appendContent', content.value);
	    }
	  },

	  CommentStatement: function CommentStatement() {},

	  SubExpression: function SubExpression(sexpr) {
	    transformLiteralToPath(sexpr);
	    var type = this.classifySexpr(sexpr);

	    if (type === 'simple') {
	      this.simpleSexpr(sexpr);
	    } else if (type === 'helper') {
	      this.helperSexpr(sexpr);
	    } else {
	      this.ambiguousSexpr(sexpr);
	    }
	  },
	  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
	    var path = sexpr.path,
	        name = path.parts[0],
	        isBlock = program != null || inverse != null;

	    this.opcode('getContext', path.depth);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    path.strict = true;
	    this.accept(path);

	    this.opcode('invokeAmbiguous', name, isBlock);
	  },

	  simpleSexpr: function simpleSexpr(sexpr) {
	    var path = sexpr.path;
	    path.strict = true;
	    this.accept(path);
	    this.opcode('resolvePossibleLambda');
	  },

	  helperSexpr: function helperSexpr(sexpr, program, inverse) {
	    var params = this.setupFullMustacheParams(sexpr, program, inverse),
	        path = sexpr.path,
	        name = path.parts[0];

	    if (this.options.knownHelpers[name]) {
	      this.opcode('invokeKnownHelper', params.length, name);
	    } else if (this.options.knownHelpersOnly) {
	      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
	    } else {
	      path.strict = true;
	      path.falsy = true;

	      this.accept(path);
	      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
	    }
	  },

	  PathExpression: function PathExpression(path) {
	    this.addDepth(path.depth);
	    this.opcode('getContext', path.depth);

	    var name = path.parts[0],
	        scoped = _ast2['default'].helpers.scopedId(path),
	        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

	    if (blockParamId) {
	      this.opcode('lookupBlockParam', blockParamId, path.parts);
	    } else if (!name) {
	      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
	      this.opcode('pushContext');
	    } else if (path.data) {
	      this.options.data = true;
	      this.opcode('lookupData', path.depth, path.parts, path.strict);
	    } else {
	      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
	    }
	  },

	  StringLiteral: function StringLiteral(string) {
	    this.opcode('pushString', string.value);
	  },

	  NumberLiteral: function NumberLiteral(number) {
	    this.opcode('pushLiteral', number.value);
	  },

	  BooleanLiteral: function BooleanLiteral(bool) {
	    this.opcode('pushLiteral', bool.value);
	  },

	  UndefinedLiteral: function UndefinedLiteral() {
	    this.opcode('pushLiteral', 'undefined');
	  },

	  NullLiteral: function NullLiteral() {
	    this.opcode('pushLiteral', 'null');
	  },

	  Hash: function Hash(hash) {
	    var pairs = hash.pairs,
	        i = 0,
	        l = pairs.length;

	    this.opcode('pushHash');

	    for (; i < l; i++) {
	      this.pushParam(pairs[i].value);
	    }
	    while (i--) {
	      this.opcode('assignToHash', pairs[i].key);
	    }
	    this.opcode('popHash');
	  },

	  // HELPERS
	  opcode: function opcode(name) {
	    this.opcodes.push({
	      opcode: name,
	      args: slice.call(arguments, 1),
	      loc: this.sourceNode[0].loc
	    });
	  },

	  addDepth: function addDepth(depth) {
	    if (!depth) {
	      return;
	    }

	    this.useDepths = true;
	  },

	  classifySexpr: function classifySexpr(sexpr) {
	    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

	    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

	    // a mustache is an eligible helper if:
	    // * its id is simple (a single part, not `this` or `..`)
	    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

	    // if a mustache is an eligible helper but not a definite
	    // helper, it is ambiguous, and will be resolved in a later
	    // pass or at runtime.
	    var isEligible = !isBlockParam && (isHelper || isSimple);

	    // if ambiguous, we can possibly resolve the ambiguity now
	    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
	    if (isEligible && !isHelper) {
	      var _name = sexpr.path.parts[0],
	          options = this.options;
	      if (options.knownHelpers[_name]) {
	        isHelper = true;
	      } else if (options.knownHelpersOnly) {
	        isEligible = false;
	      }
	    }

	    if (isHelper) {
	      return 'helper';
	    } else if (isEligible) {
	      return 'ambiguous';
	    } else {
	      return 'simple';
	    }
	  },

	  pushParams: function pushParams(params) {
	    for (var i = 0, l = params.length; i < l; i++) {
	      this.pushParam(params[i]);
	    }
	  },

	  pushParam: function pushParam(val) {
	    var value = val.value != null ? val.value : val.original || '';

	    if (this.stringParams) {
	      if (value.replace) {
	        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
	      }

	      if (val.depth) {
	        this.addDepth(val.depth);
	      }
	      this.opcode('getContext', val.depth || 0);
	      this.opcode('pushStringParam', value, val.type);

	      if (val.type === 'SubExpression') {
	        // SubExpressions get evaluated and passed in
	        // in string params mode.
	        this.accept(val);
	      }
	    } else {
	      if (this.trackIds) {
	        var blockParamIndex = undefined;
	        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
	          blockParamIndex = this.blockParamIndex(val.parts[0]);
	        }
	        if (blockParamIndex) {
	          var blockParamChild = val.parts.slice(1).join('.');
	          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
	        } else {
	          value = val.original || value;
	          if (value.replace) {
	            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
	          }

	          this.opcode('pushId', val.type, value);
	        }
	      }
	      this.accept(val);
	    }
	  },

	  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
	    var params = sexpr.params;
	    this.pushParams(params);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    if (sexpr.hash) {
	      this.accept(sexpr.hash);
	    } else {
	      this.opcode('emptyHash', omitEmpty);
	    }

	    return params;
	  },

	  blockParamIndex: function blockParamIndex(name) {
	    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
	      var blockParams = this.options.blockParams[depth],
	          param = blockParams && _utils.indexOf(blockParams, name);
	      if (blockParams && param >= 0) {
	        return [depth, param];
	      }
	    }
	  }
	};

	function precompile(input, options, env) {
	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
	  }

	  options = options || {};
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var ast = env.parse(input, options),
	      environment = new env.Compiler().compile(ast, options);
	  return new env.JavaScriptCompiler().compile(environment, options);
	}

	function compile(input, options, env) {
	  if (options === undefined) options = {};

	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
	  }

	  options = _utils.extend({}, options);
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var compiled = undefined;

	  function compileInput() {
	    var ast = env.parse(input, options),
	        environment = new env.Compiler().compile(ast, options),
	        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
	    return env.template(templateSpec);
	  }

	  // Template is only compiled on first use and cached after that point.
	  function ret(context, execOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled.call(this, context, execOptions);
	  }
	  ret._setup = function (setupOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._setup(setupOptions);
	  };
	  ret._child = function (i, data, blockParams, depths) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._child(i, data, blockParams, depths);
	  };
	  return ret;
	}

	function argEquals(a, b) {
	  if (a === b) {
	    return true;
	  }

	  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
	    for (var i = 0; i < a.length; i++) {
	      if (!argEquals(a[i], b[i])) {
	        return false;
	      }
	    }
	    return true;
	  }
	}

	function transformLiteralToPath(sexpr) {
	  if (!sexpr.path.parts) {
	    var literal = sexpr.path;
	    // Casting to string here to make false and 0 literal values play nicely with the rest
	    // of the system.
	    sexpr.path = {
	      type: 'PathExpression',
	      data: false,
	      depth: 0,
	      parts: [literal.original + ''],
	      original: literal.original + '',
	      loc: literal.loc
	    };
	  }
	}

	var javascriptCompiler = {exports: {}};

	var codeGen = {exports: {}};

	var sourceMap = {};

	var sourceMapGenerator = {};

	var base64Vlq = {};

	var base64 = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredBase64;

	function requireBase64 () {
		if (hasRequiredBase64) return base64;
		hasRequiredBase64 = 1;
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

		/**
		 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
		 */
		base64.encode = function (number) {
		  if (0 <= number && number < intToCharMap.length) {
		    return intToCharMap[number];
		  }
		  throw new TypeError("Must be between 0 and 63: " + number);
		};

		/**
		 * Decode a single base 64 character code digit to an integer. Returns -1 on
		 * failure.
		 */
		base64.decode = function (charCode) {
		  var bigA = 65;     // 'A'
		  var bigZ = 90;     // 'Z'

		  var littleA = 97;  // 'a'
		  var littleZ = 122; // 'z'

		  var zero = 48;     // '0'
		  var nine = 57;     // '9'

		  var plus = 43;     // '+'
		  var slash = 47;    // '/'

		  var littleOffset = 26;
		  var numberOffset = 52;

		  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
		  if (bigA <= charCode && charCode <= bigZ) {
		    return (charCode - bigA);
		  }

		  // 26 - 51: abcdefghijklmnopqrstuvwxyz
		  if (littleA <= charCode && charCode <= littleZ) {
		    return (charCode - littleA + littleOffset);
		  }

		  // 52 - 61: 0123456789
		  if (zero <= charCode && charCode <= nine) {
		    return (charCode - zero + numberOffset);
		  }

		  // 62: +
		  if (charCode == plus) {
		    return 62;
		  }

		  // 63: /
		  if (charCode == slash) {
		    return 63;
		  }

		  // Invalid base64 digit.
		  return -1;
		};
		return base64;
	}

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredBase64Vlq;

	function requireBase64Vlq () {
		if (hasRequiredBase64Vlq) return base64Vlq;
		hasRequiredBase64Vlq = 1;
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 *
		 * Based on the Base 64 VLQ implementation in Closure Compiler:
		 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
		 *
		 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 *  * Redistributions of source code must retain the above copyright
		 *    notice, this list of conditions and the following disclaimer.
		 *  * Redistributions in binary form must reproduce the above
		 *    copyright notice, this list of conditions and the following
		 *    disclaimer in the documentation and/or other materials provided
		 *    with the distribution.
		 *  * Neither the name of Google Inc. nor the names of its
		 *    contributors may be used to endorse or promote products derived
		 *    from this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
		 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
		 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		var base64 = requireBase64();

		// A single base 64 digit can contain 6 bits of data. For the base 64 variable
		// length quantities we use in the source map spec, the first bit is the sign,
		// the next four bits are the actual value, and the 6th bit is the
		// continuation bit. The continuation bit tells us whether there are more
		// digits in this value following this digit.
		//
		//   Continuation
		//   |    Sign
		//   |    |
		//   V    V
		//   101011

		var VLQ_BASE_SHIFT = 5;

		// binary: 100000
		var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

		// binary: 011111
		var VLQ_BASE_MASK = VLQ_BASE - 1;

		// binary: 100000
		var VLQ_CONTINUATION_BIT = VLQ_BASE;

		/**
		 * Converts from a two-complement value to a value where the sign bit is
		 * placed in the least significant bit.  For example, as decimals:
		 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
		 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
		 */
		function toVLQSigned(aValue) {
		  return aValue < 0
		    ? ((-aValue) << 1) + 1
		    : (aValue << 1) + 0;
		}

		/**
		 * Converts to a two-complement value from a value where the sign bit is
		 * placed in the least significant bit.  For example, as decimals:
		 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
		 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
		 */
		function fromVLQSigned(aValue) {
		  var isNegative = (aValue & 1) === 1;
		  var shifted = aValue >> 1;
		  return isNegative
		    ? -shifted
		    : shifted;
		}

		/**
		 * Returns the base 64 VLQ encoded value.
		 */
		base64Vlq.encode = function base64VLQ_encode(aValue) {
		  var encoded = "";
		  var digit;

		  var vlq = toVLQSigned(aValue);

		  do {
		    digit = vlq & VLQ_BASE_MASK;
		    vlq >>>= VLQ_BASE_SHIFT;
		    if (vlq > 0) {
		      // There are still more digits in this value, so we must make sure the
		      // continuation bit is marked.
		      digit |= VLQ_CONTINUATION_BIT;
		    }
		    encoded += base64.encode(digit);
		  } while (vlq > 0);

		  return encoded;
		};

		/**
		 * Decodes the next base 64 VLQ value from the given string and returns the
		 * value and the rest of the string via the out parameter.
		 */
		base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
		  var strLen = aStr.length;
		  var result = 0;
		  var shift = 0;
		  var continuation, digit;

		  do {
		    if (aIndex >= strLen) {
		      throw new Error("Expected more digits in base 64 VLQ value.");
		    }

		    digit = base64.decode(aStr.charCodeAt(aIndex++));
		    if (digit === -1) {
		      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
		    }

		    continuation = !!(digit & VLQ_CONTINUATION_BIT);
		    digit &= VLQ_BASE_MASK;
		    result = result + (digit << shift);
		    shift += VLQ_BASE_SHIFT;
		  } while (continuation);

		  aOutParam.value = fromVLQSigned(result);
		  aOutParam.rest = aIndex;
		};
		return base64Vlq;
	}

	var util = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredUtil;

	function requireUtil () {
		if (hasRequiredUtil) return util;
		hasRequiredUtil = 1;
		(function (exports) {
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			/**
			 * This is a helper function for getting values from parameter/options
			 * objects.
			 *
			 * @param args The object we are extracting values from
			 * @param name The name of the property we are getting.
			 * @param defaultValue An optional value to return if the property is missing
			 * from the object. If this is not specified and the property is missing, an
			 * error will be thrown.
			 */
			function getArg(aArgs, aName, aDefaultValue) {
			  if (aName in aArgs) {
			    return aArgs[aName];
			  } else if (arguments.length === 3) {
			    return aDefaultValue;
			  } else {
			    throw new Error('"' + aName + '" is a required argument.');
			  }
			}
			exports.getArg = getArg;

			var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
			var dataUrlRegexp = /^data:.+\,.+$/;

			function urlParse(aUrl) {
			  var match = aUrl.match(urlRegexp);
			  if (!match) {
			    return null;
			  }
			  return {
			    scheme: match[1],
			    auth: match[2],
			    host: match[3],
			    port: match[4],
			    path: match[5]
			  };
			}
			exports.urlParse = urlParse;

			function urlGenerate(aParsedUrl) {
			  var url = '';
			  if (aParsedUrl.scheme) {
			    url += aParsedUrl.scheme + ':';
			  }
			  url += '//';
			  if (aParsedUrl.auth) {
			    url += aParsedUrl.auth + '@';
			  }
			  if (aParsedUrl.host) {
			    url += aParsedUrl.host;
			  }
			  if (aParsedUrl.port) {
			    url += ":" + aParsedUrl.port;
			  }
			  if (aParsedUrl.path) {
			    url += aParsedUrl.path;
			  }
			  return url;
			}
			exports.urlGenerate = urlGenerate;

			/**
			 * Normalizes a path, or the path portion of a URL:
			 *
			 * - Replaces consecutive slashes with one slash.
			 * - Removes unnecessary '.' parts.
			 * - Removes unnecessary '<dir>/..' parts.
			 *
			 * Based on code in the Node.js 'path' core module.
			 *
			 * @param aPath The path or url to normalize.
			 */
			function normalize(aPath) {
			  var path = aPath;
			  var url = urlParse(aPath);
			  if (url) {
			    if (!url.path) {
			      return aPath;
			    }
			    path = url.path;
			  }
			  var isAbsolute = exports.isAbsolute(path);

			  var parts = path.split(/\/+/);
			  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
			    part = parts[i];
			    if (part === '.') {
			      parts.splice(i, 1);
			    } else if (part === '..') {
			      up++;
			    } else if (up > 0) {
			      if (part === '') {
			        // The first part is blank if the path is absolute. Trying to go
			        // above the root is a no-op. Therefore we can remove all '..' parts
			        // directly after the root.
			        parts.splice(i + 1, up);
			        up = 0;
			      } else {
			        parts.splice(i, 2);
			        up--;
			      }
			    }
			  }
			  path = parts.join('/');

			  if (path === '') {
			    path = isAbsolute ? '/' : '.';
			  }

			  if (url) {
			    url.path = path;
			    return urlGenerate(url);
			  }
			  return path;
			}
			exports.normalize = normalize;

			/**
			 * Joins two paths/URLs.
			 *
			 * @param aRoot The root path or URL.
			 * @param aPath The path or URL to be joined with the root.
			 *
			 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
			 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
			 *   first.
			 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
			 *   is updated with the result and aRoot is returned. Otherwise the result
			 *   is returned.
			 *   - If aPath is absolute, the result is aPath.
			 *   - Otherwise the two paths are joined with a slash.
			 * - Joining for example 'http://' and 'www.example.com' is also supported.
			 */
			function join(aRoot, aPath) {
			  if (aRoot === "") {
			    aRoot = ".";
			  }
			  if (aPath === "") {
			    aPath = ".";
			  }
			  var aPathUrl = urlParse(aPath);
			  var aRootUrl = urlParse(aRoot);
			  if (aRootUrl) {
			    aRoot = aRootUrl.path || '/';
			  }

			  // `join(foo, '//www.example.org')`
			  if (aPathUrl && !aPathUrl.scheme) {
			    if (aRootUrl) {
			      aPathUrl.scheme = aRootUrl.scheme;
			    }
			    return urlGenerate(aPathUrl);
			  }

			  if (aPathUrl || aPath.match(dataUrlRegexp)) {
			    return aPath;
			  }

			  // `join('http://', 'www.example.com')`
			  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
			    aRootUrl.host = aPath;
			    return urlGenerate(aRootUrl);
			  }

			  var joined = aPath.charAt(0) === '/'
			    ? aPath
			    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

			  if (aRootUrl) {
			    aRootUrl.path = joined;
			    return urlGenerate(aRootUrl);
			  }
			  return joined;
			}
			exports.join = join;

			exports.isAbsolute = function (aPath) {
			  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
			};

			/**
			 * Make a path relative to a URL or another path.
			 *
			 * @param aRoot The root path or URL.
			 * @param aPath The path or URL to be made relative to aRoot.
			 */
			function relative(aRoot, aPath) {
			  if (aRoot === "") {
			    aRoot = ".";
			  }

			  aRoot = aRoot.replace(/\/$/, '');

			  // It is possible for the path to be above the root. In this case, simply
			  // checking whether the root is a prefix of the path won't work. Instead, we
			  // need to remove components from the root one by one, until either we find
			  // a prefix that fits, or we run out of components to remove.
			  var level = 0;
			  while (aPath.indexOf(aRoot + '/') !== 0) {
			    var index = aRoot.lastIndexOf("/");
			    if (index < 0) {
			      return aPath;
			    }

			    // If the only part of the root that is left is the scheme (i.e. http://,
			    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
			    // have exhausted all components, so the path is not relative to the root.
			    aRoot = aRoot.slice(0, index);
			    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
			      return aPath;
			    }

			    ++level;
			  }

			  // Make sure we add a "../" for each component we removed from the root.
			  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
			}
			exports.relative = relative;

			var supportsNullProto = (function () {
			  var obj = Object.create(null);
			  return !('__proto__' in obj);
			}());

			function identity (s) {
			  return s;
			}

			/**
			 * Because behavior goes wacky when you set `__proto__` on objects, we
			 * have to prefix all the strings in our set with an arbitrary character.
			 *
			 * See https://github.com/mozilla/source-map/pull/31 and
			 * https://github.com/mozilla/source-map/issues/30
			 *
			 * @param String aStr
			 */
			function toSetString(aStr) {
			  if (isProtoString(aStr)) {
			    return '$' + aStr;
			  }

			  return aStr;
			}
			exports.toSetString = supportsNullProto ? identity : toSetString;

			function fromSetString(aStr) {
			  if (isProtoString(aStr)) {
			    return aStr.slice(1);
			  }

			  return aStr;
			}
			exports.fromSetString = supportsNullProto ? identity : fromSetString;

			function isProtoString(s) {
			  if (!s) {
			    return false;
			  }

			  var length = s.length;

			  if (length < 9 /* "__proto__".length */) {
			    return false;
			  }

			  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
			      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
			      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
			      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
			      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
			      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
			      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
			      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
			      s.charCodeAt(length - 9) !== 95  /* '_' */) {
			    return false;
			  }

			  for (var i = length - 10; i >= 0; i--) {
			    if (s.charCodeAt(i) !== 36 /* '$' */) {
			      return false;
			    }
			  }

			  return true;
			}

			/**
			 * Comparator between two mappings where the original positions are compared.
			 *
			 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
			 * mappings with the same original source/line/column, but different generated
			 * line and column the same. Useful when searching for a mapping with a
			 * stubbed out mapping.
			 */
			function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
			  var cmp = strcmp(mappingA.source, mappingB.source);
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.originalLine - mappingB.originalLine;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.originalColumn - mappingB.originalColumn;
			  if (cmp !== 0 || onlyCompareOriginal) {
			    return cmp;
			  }

			  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.generatedLine - mappingB.generatedLine;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  return strcmp(mappingA.name, mappingB.name);
			}
			exports.compareByOriginalPositions = compareByOriginalPositions;

			/**
			 * Comparator between two mappings with deflated source and name indices where
			 * the generated positions are compared.
			 *
			 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
			 * mappings with the same generated line and column, but different
			 * source/name/original line and column the same. Useful when searching for a
			 * mapping with a stubbed out mapping.
			 */
			function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
			  var cmp = mappingA.generatedLine - mappingB.generatedLine;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			  if (cmp !== 0 || onlyCompareGenerated) {
			    return cmp;
			  }

			  cmp = strcmp(mappingA.source, mappingB.source);
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.originalLine - mappingB.originalLine;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.originalColumn - mappingB.originalColumn;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  return strcmp(mappingA.name, mappingB.name);
			}
			exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

			function strcmp(aStr1, aStr2) {
			  if (aStr1 === aStr2) {
			    return 0;
			  }

			  if (aStr1 === null) {
			    return 1; // aStr2 !== null
			  }

			  if (aStr2 === null) {
			    return -1; // aStr1 !== null
			  }

			  if (aStr1 > aStr2) {
			    return 1;
			  }

			  return -1;
			}

			/**
			 * Comparator between two mappings with inflated source and name strings where
			 * the generated positions are compared.
			 */
			function compareByGeneratedPositionsInflated(mappingA, mappingB) {
			  var cmp = mappingA.generatedLine - mappingB.generatedLine;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = strcmp(mappingA.source, mappingB.source);
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.originalLine - mappingB.originalLine;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  cmp = mappingA.originalColumn - mappingB.originalColumn;
			  if (cmp !== 0) {
			    return cmp;
			  }

			  return strcmp(mappingA.name, mappingB.name);
			}
			exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

			/**
			 * Strip any JSON XSSI avoidance prefix from the string (as documented
			 * in the source maps specification), and then parse the string as
			 * JSON.
			 */
			function parseSourceMapInput(str) {
			  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
			}
			exports.parseSourceMapInput = parseSourceMapInput;

			/**
			 * Compute the URL of a source given the the source root, the source's
			 * URL, and the source map's URL.
			 */
			function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
			  sourceURL = sourceURL || '';

			  if (sourceRoot) {
			    // This follows what Chrome does.
			    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
			      sourceRoot += '/';
			    }
			    // The spec says:
			    //   Line 4: An optional source root, useful for relocating source
			    //   files on a server or removing repeated values in the
			    //   “sources” entry.  This value is prepended to the individual
			    //   entries in the “source” field.
			    sourceURL = sourceRoot + sourceURL;
			  }

			  // Historically, SourceMapConsumer did not take the sourceMapURL as
			  // a parameter.  This mode is still somewhat supported, which is why
			  // this code block is conditional.  However, it's preferable to pass
			  // the source map URL to SourceMapConsumer, so that this function
			  // can implement the source URL resolution algorithm as outlined in
			  // the spec.  This block is basically the equivalent of:
			  //    new URL(sourceURL, sourceMapURL).toString()
			  // ... except it avoids using URL, which wasn't available in the
			  // older releases of node still supported by this library.
			  //
			  // The spec says:
			  //   If the sources are not absolute URLs after prepending of the
			  //   “sourceRoot”, the sources are resolved relative to the
			  //   SourceMap (like resolving script src in a html document).
			  if (sourceMapURL) {
			    var parsed = urlParse(sourceMapURL);
			    if (!parsed) {
			      throw new Error("sourceMapURL could not be parsed");
			    }
			    if (parsed.path) {
			      // Strip the last path component, but keep the "/".
			      var index = parsed.path.lastIndexOf('/');
			      if (index >= 0) {
			        parsed.path = parsed.path.substring(0, index + 1);
			      }
			    }
			    sourceURL = join(urlGenerate(parsed), sourceURL);
			  }

			  return normalize(sourceURL);
			}
			exports.computeSourceURL = computeSourceURL; 
		} (util));
		return util;
	}

	var arraySet = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredArraySet;

	function requireArraySet () {
		if (hasRequiredArraySet) return arraySet;
		hasRequiredArraySet = 1;
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		var util = requireUtil();
		var has = Object.prototype.hasOwnProperty;
		var hasNativeMap = typeof Map !== "undefined";

		/**
		 * A data structure which is a combination of an array and a set. Adding a new
		 * member is O(1), testing for membership is O(1), and finding the index of an
		 * element is O(1). Removing elements from the set is not supported. Only
		 * strings are supported for membership.
		 */
		function ArraySet() {
		  this._array = [];
		  this._set = hasNativeMap ? new Map() : Object.create(null);
		}

		/**
		 * Static method for creating ArraySet instances from an existing array.
		 */
		ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
		  var set = new ArraySet();
		  for (var i = 0, len = aArray.length; i < len; i++) {
		    set.add(aArray[i], aAllowDuplicates);
		  }
		  return set;
		};

		/**
		 * Return how many unique items are in this ArraySet. If duplicates have been
		 * added, than those do not count towards the size.
		 *
		 * @returns Number
		 */
		ArraySet.prototype.size = function ArraySet_size() {
		  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
		};

		/**
		 * Add the given string to this set.
		 *
		 * @param String aStr
		 */
		ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
		  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
		  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
		  var idx = this._array.length;
		  if (!isDuplicate || aAllowDuplicates) {
		    this._array.push(aStr);
		  }
		  if (!isDuplicate) {
		    if (hasNativeMap) {
		      this._set.set(aStr, idx);
		    } else {
		      this._set[sStr] = idx;
		    }
		  }
		};

		/**
		 * Is the given string a member of this set?
		 *
		 * @param String aStr
		 */
		ArraySet.prototype.has = function ArraySet_has(aStr) {
		  if (hasNativeMap) {
		    return this._set.has(aStr);
		  } else {
		    var sStr = util.toSetString(aStr);
		    return has.call(this._set, sStr);
		  }
		};

		/**
		 * What is the index of the given string in the array?
		 *
		 * @param String aStr
		 */
		ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
		  if (hasNativeMap) {
		    var idx = this._set.get(aStr);
		    if (idx >= 0) {
		        return idx;
		    }
		  } else {
		    var sStr = util.toSetString(aStr);
		    if (has.call(this._set, sStr)) {
		      return this._set[sStr];
		    }
		  }

		  throw new Error('"' + aStr + '" is not in the set.');
		};

		/**
		 * What is the element at the given index?
		 *
		 * @param Number aIdx
		 */
		ArraySet.prototype.at = function ArraySet_at(aIdx) {
		  if (aIdx >= 0 && aIdx < this._array.length) {
		    return this._array[aIdx];
		  }
		  throw new Error('No element indexed by ' + aIdx);
		};

		/**
		 * Returns the array representation of this set (which has the proper indices
		 * indicated by indexOf). Note that this is a copy of the internal array used
		 * for storing the members so that no one can mess with internal state.
		 */
		ArraySet.prototype.toArray = function ArraySet_toArray() {
		  return this._array.slice();
		};

		arraySet.ArraySet = ArraySet;
		return arraySet;
	}

	var mappingList = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredMappingList;

	function requireMappingList () {
		if (hasRequiredMappingList) return mappingList;
		hasRequiredMappingList = 1;
		/*
		 * Copyright 2014 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		var util = requireUtil();

		/**
		 * Determine whether mappingB is after mappingA with respect to generated
		 * position.
		 */
		function generatedPositionAfter(mappingA, mappingB) {
		  // Optimized for most common case
		  var lineA = mappingA.generatedLine;
		  var lineB = mappingB.generatedLine;
		  var columnA = mappingA.generatedColumn;
		  var columnB = mappingB.generatedColumn;
		  return lineB > lineA || lineB == lineA && columnB >= columnA ||
		         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
		}

		/**
		 * A data structure to provide a sorted view of accumulated mappings in a
		 * performance conscious manner. It trades a neglibable overhead in general
		 * case for a large speedup in case of mappings being added in order.
		 */
		function MappingList() {
		  this._array = [];
		  this._sorted = true;
		  // Serves as infimum
		  this._last = {generatedLine: -1, generatedColumn: 0};
		}

		/**
		 * Iterate through internal items. This method takes the same arguments that
		 * `Array.prototype.forEach` takes.
		 *
		 * NOTE: The order of the mappings is NOT guaranteed.
		 */
		MappingList.prototype.unsortedForEach =
		  function MappingList_forEach(aCallback, aThisArg) {
		    this._array.forEach(aCallback, aThisArg);
		  };

		/**
		 * Add the given source mapping.
		 *
		 * @param Object aMapping
		 */
		MappingList.prototype.add = function MappingList_add(aMapping) {
		  if (generatedPositionAfter(this._last, aMapping)) {
		    this._last = aMapping;
		    this._array.push(aMapping);
		  } else {
		    this._sorted = false;
		    this._array.push(aMapping);
		  }
		};

		/**
		 * Returns the flat, sorted array of mappings. The mappings are sorted by
		 * generated position.
		 *
		 * WARNING: This method returns internal data without copying, for
		 * performance. The return value must NOT be mutated, and should be treated as
		 * an immutable borrow. If you want to take ownership, you must make your own
		 * copy.
		 */
		MappingList.prototype.toArray = function MappingList_toArray() {
		  if (!this._sorted) {
		    this._array.sort(util.compareByGeneratedPositionsInflated);
		    this._sorted = true;
		  }
		  return this._array;
		};

		mappingList.MappingList = MappingList;
		return mappingList;
	}

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredSourceMapGenerator;

	function requireSourceMapGenerator () {
		if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
		hasRequiredSourceMapGenerator = 1;
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		var base64VLQ = requireBase64Vlq();
		var util = requireUtil();
		var ArraySet = requireArraySet().ArraySet;
		var MappingList = requireMappingList().MappingList;

		/**
		 * An instance of the SourceMapGenerator represents a source map which is
		 * being built incrementally. You may pass an object with the following
		 * properties:
		 *
		 *   - file: The filename of the generated source.
		 *   - sourceRoot: A root for all relative URLs in this source map.
		 */
		function SourceMapGenerator(aArgs) {
		  if (!aArgs) {
		    aArgs = {};
		  }
		  this._file = util.getArg(aArgs, 'file', null);
		  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
		  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
		  this._sources = new ArraySet();
		  this._names = new ArraySet();
		  this._mappings = new MappingList();
		  this._sourcesContents = null;
		}

		SourceMapGenerator.prototype._version = 3;

		/**
		 * Creates a new SourceMapGenerator based on a SourceMapConsumer
		 *
		 * @param aSourceMapConsumer The SourceMap.
		 */
		SourceMapGenerator.fromSourceMap =
		  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
		    var sourceRoot = aSourceMapConsumer.sourceRoot;
		    var generator = new SourceMapGenerator({
		      file: aSourceMapConsumer.file,
		      sourceRoot: sourceRoot
		    });
		    aSourceMapConsumer.eachMapping(function (mapping) {
		      var newMapping = {
		        generated: {
		          line: mapping.generatedLine,
		          column: mapping.generatedColumn
		        }
		      };

		      if (mapping.source != null) {
		        newMapping.source = mapping.source;
		        if (sourceRoot != null) {
		          newMapping.source = util.relative(sourceRoot, newMapping.source);
		        }

		        newMapping.original = {
		          line: mapping.originalLine,
		          column: mapping.originalColumn
		        };

		        if (mapping.name != null) {
		          newMapping.name = mapping.name;
		        }
		      }

		      generator.addMapping(newMapping);
		    });
		    aSourceMapConsumer.sources.forEach(function (sourceFile) {
		      var sourceRelative = sourceFile;
		      if (sourceRoot !== null) {
		        sourceRelative = util.relative(sourceRoot, sourceFile);
		      }

		      if (!generator._sources.has(sourceRelative)) {
		        generator._sources.add(sourceRelative);
		      }

		      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
		      if (content != null) {
		        generator.setSourceContent(sourceFile, content);
		      }
		    });
		    return generator;
		  };

		/**
		 * Add a single mapping from original source line and column to the generated
		 * source's line and column for this source map being created. The mapping
		 * object should have the following properties:
		 *
		 *   - generated: An object with the generated line and column positions.
		 *   - original: An object with the original line and column positions.
		 *   - source: The original source file (relative to the sourceRoot).
		 *   - name: An optional original token name for this mapping.
		 */
		SourceMapGenerator.prototype.addMapping =
		  function SourceMapGenerator_addMapping(aArgs) {
		    var generated = util.getArg(aArgs, 'generated');
		    var original = util.getArg(aArgs, 'original', null);
		    var source = util.getArg(aArgs, 'source', null);
		    var name = util.getArg(aArgs, 'name', null);

		    if (!this._skipValidation) {
		      this._validateMapping(generated, original, source, name);
		    }

		    if (source != null) {
		      source = String(source);
		      if (!this._sources.has(source)) {
		        this._sources.add(source);
		      }
		    }

		    if (name != null) {
		      name = String(name);
		      if (!this._names.has(name)) {
		        this._names.add(name);
		      }
		    }

		    this._mappings.add({
		      generatedLine: generated.line,
		      generatedColumn: generated.column,
		      originalLine: original != null && original.line,
		      originalColumn: original != null && original.column,
		      source: source,
		      name: name
		    });
		  };

		/**
		 * Set the source content for a source file.
		 */
		SourceMapGenerator.prototype.setSourceContent =
		  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
		    var source = aSourceFile;
		    if (this._sourceRoot != null) {
		      source = util.relative(this._sourceRoot, source);
		    }

		    if (aSourceContent != null) {
		      // Add the source content to the _sourcesContents map.
		      // Create a new _sourcesContents map if the property is null.
		      if (!this._sourcesContents) {
		        this._sourcesContents = Object.create(null);
		      }
		      this._sourcesContents[util.toSetString(source)] = aSourceContent;
		    } else if (this._sourcesContents) {
		      // Remove the source file from the _sourcesContents map.
		      // If the _sourcesContents map is empty, set the property to null.
		      delete this._sourcesContents[util.toSetString(source)];
		      if (Object.keys(this._sourcesContents).length === 0) {
		        this._sourcesContents = null;
		      }
		    }
		  };

		/**
		 * Applies the mappings of a sub-source-map for a specific source file to the
		 * source map being generated. Each mapping to the supplied source file is
		 * rewritten using the supplied source map. Note: The resolution for the
		 * resulting mappings is the minimium of this map and the supplied map.
		 *
		 * @param aSourceMapConsumer The source map to be applied.
		 * @param aSourceFile Optional. The filename of the source file.
		 *        If omitted, SourceMapConsumer's file property will be used.
		 * @param aSourceMapPath Optional. The dirname of the path to the source map
		 *        to be applied. If relative, it is relative to the SourceMapConsumer.
		 *        This parameter is needed when the two source maps aren't in the same
		 *        directory, and the source map to be applied contains relative source
		 *        paths. If so, those relative source paths need to be rewritten
		 *        relative to the SourceMapGenerator.
		 */
		SourceMapGenerator.prototype.applySourceMap =
		  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
		    var sourceFile = aSourceFile;
		    // If aSourceFile is omitted, we will use the file property of the SourceMap
		    if (aSourceFile == null) {
		      if (aSourceMapConsumer.file == null) {
		        throw new Error(
		          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
		          'or the source map\'s "file" property. Both were omitted.'
		        );
		      }
		      sourceFile = aSourceMapConsumer.file;
		    }
		    var sourceRoot = this._sourceRoot;
		    // Make "sourceFile" relative if an absolute Url is passed.
		    if (sourceRoot != null) {
		      sourceFile = util.relative(sourceRoot, sourceFile);
		    }
		    // Applying the SourceMap can add and remove items from the sources and
		    // the names array.
		    var newSources = new ArraySet();
		    var newNames = new ArraySet();

		    // Find mappings for the "sourceFile"
		    this._mappings.unsortedForEach(function (mapping) {
		      if (mapping.source === sourceFile && mapping.originalLine != null) {
		        // Check if it can be mapped by the source map, then update the mapping.
		        var original = aSourceMapConsumer.originalPositionFor({
		          line: mapping.originalLine,
		          column: mapping.originalColumn
		        });
		        if (original.source != null) {
		          // Copy mapping
		          mapping.source = original.source;
		          if (aSourceMapPath != null) {
		            mapping.source = util.join(aSourceMapPath, mapping.source);
		          }
		          if (sourceRoot != null) {
		            mapping.source = util.relative(sourceRoot, mapping.source);
		          }
		          mapping.originalLine = original.line;
		          mapping.originalColumn = original.column;
		          if (original.name != null) {
		            mapping.name = original.name;
		          }
		        }
		      }

		      var source = mapping.source;
		      if (source != null && !newSources.has(source)) {
		        newSources.add(source);
		      }

		      var name = mapping.name;
		      if (name != null && !newNames.has(name)) {
		        newNames.add(name);
		      }

		    }, this);
		    this._sources = newSources;
		    this._names = newNames;

		    // Copy sourcesContents of applied map.
		    aSourceMapConsumer.sources.forEach(function (sourceFile) {
		      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
		      if (content != null) {
		        if (aSourceMapPath != null) {
		          sourceFile = util.join(aSourceMapPath, sourceFile);
		        }
		        if (sourceRoot != null) {
		          sourceFile = util.relative(sourceRoot, sourceFile);
		        }
		        this.setSourceContent(sourceFile, content);
		      }
		    }, this);
		  };

		/**
		 * A mapping can have one of the three levels of data:
		 *
		 *   1. Just the generated position.
		 *   2. The Generated position, original position, and original source.
		 *   3. Generated and original position, original source, as well as a name
		 *      token.
		 *
		 * To maintain consistency, we validate that any new mapping being added falls
		 * in to one of these categories.
		 */
		SourceMapGenerator.prototype._validateMapping =
		  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
		                                              aName) {
		    // When aOriginal is truthy but has empty values for .line and .column,
		    // it is most likely a programmer error. In this case we throw a very
		    // specific error message to try to guide them the right way.
		    // For example: https://github.com/Polymer/polymer-bundler/pull/519
		    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
		        throw new Error(
		            'original.line and original.column are not numbers -- you probably meant to omit ' +
		            'the original mapping entirely and only map the generated position. If so, pass ' +
		            'null for the original mapping instead of an object with empty or null values.'
		        );
		    }

		    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
		        && aGenerated.line > 0 && aGenerated.column >= 0
		        && !aOriginal && !aSource && !aName) {
		      // Case 1.
		      return;
		    }
		    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
		             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
		             && aGenerated.line > 0 && aGenerated.column >= 0
		             && aOriginal.line > 0 && aOriginal.column >= 0
		             && aSource) {
		      // Cases 2 and 3.
		      return;
		    }
		    else {
		      throw new Error('Invalid mapping: ' + JSON.stringify({
		        generated: aGenerated,
		        source: aSource,
		        original: aOriginal,
		        name: aName
		      }));
		    }
		  };

		/**
		 * Serialize the accumulated mappings in to the stream of base 64 VLQs
		 * specified by the source map format.
		 */
		SourceMapGenerator.prototype._serializeMappings =
		  function SourceMapGenerator_serializeMappings() {
		    var previousGeneratedColumn = 0;
		    var previousGeneratedLine = 1;
		    var previousOriginalColumn = 0;
		    var previousOriginalLine = 0;
		    var previousName = 0;
		    var previousSource = 0;
		    var result = '';
		    var next;
		    var mapping;
		    var nameIdx;
		    var sourceIdx;

		    var mappings = this._mappings.toArray();
		    for (var i = 0, len = mappings.length; i < len; i++) {
		      mapping = mappings[i];
		      next = '';

		      if (mapping.generatedLine !== previousGeneratedLine) {
		        previousGeneratedColumn = 0;
		        while (mapping.generatedLine !== previousGeneratedLine) {
		          next += ';';
		          previousGeneratedLine++;
		        }
		      }
		      else {
		        if (i > 0) {
		          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
		            continue;
		          }
		          next += ',';
		        }
		      }

		      next += base64VLQ.encode(mapping.generatedColumn
		                                 - previousGeneratedColumn);
		      previousGeneratedColumn = mapping.generatedColumn;

		      if (mapping.source != null) {
		        sourceIdx = this._sources.indexOf(mapping.source);
		        next += base64VLQ.encode(sourceIdx - previousSource);
		        previousSource = sourceIdx;

		        // lines are stored 0-based in SourceMap spec version 3
		        next += base64VLQ.encode(mapping.originalLine - 1
		                                   - previousOriginalLine);
		        previousOriginalLine = mapping.originalLine - 1;

		        next += base64VLQ.encode(mapping.originalColumn
		                                   - previousOriginalColumn);
		        previousOriginalColumn = mapping.originalColumn;

		        if (mapping.name != null) {
		          nameIdx = this._names.indexOf(mapping.name);
		          next += base64VLQ.encode(nameIdx - previousName);
		          previousName = nameIdx;
		        }
		      }

		      result += next;
		    }

		    return result;
		  };

		SourceMapGenerator.prototype._generateSourcesContent =
		  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
		    return aSources.map(function (source) {
		      if (!this._sourcesContents) {
		        return null;
		      }
		      if (aSourceRoot != null) {
		        source = util.relative(aSourceRoot, source);
		      }
		      var key = util.toSetString(source);
		      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
		        ? this._sourcesContents[key]
		        : null;
		    }, this);
		  };

		/**
		 * Externalize the source map.
		 */
		SourceMapGenerator.prototype.toJSON =
		  function SourceMapGenerator_toJSON() {
		    var map = {
		      version: this._version,
		      sources: this._sources.toArray(),
		      names: this._names.toArray(),
		      mappings: this._serializeMappings()
		    };
		    if (this._file != null) {
		      map.file = this._file;
		    }
		    if (this._sourceRoot != null) {
		      map.sourceRoot = this._sourceRoot;
		    }
		    if (this._sourcesContents) {
		      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
		    }

		    return map;
		  };

		/**
		 * Render the source map being generated to a string.
		 */
		SourceMapGenerator.prototype.toString =
		  function SourceMapGenerator_toString() {
		    return JSON.stringify(this.toJSON());
		  };

		sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
		return sourceMapGenerator;
	}

	var sourceMapConsumer = {};

	var binarySearch = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredBinarySearch;

	function requireBinarySearch () {
		if (hasRequiredBinarySearch) return binarySearch;
		hasRequiredBinarySearch = 1;
		(function (exports) {
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			exports.GREATEST_LOWER_BOUND = 1;
			exports.LEAST_UPPER_BOUND = 2;

			/**
			 * Recursive implementation of binary search.
			 *
			 * @param aLow Indices here and lower do not contain the needle.
			 * @param aHigh Indices here and higher do not contain the needle.
			 * @param aNeedle The element being searched for.
			 * @param aHaystack The non-empty array being searched.
			 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
			 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
			 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
			 *     closest element that is smaller than or greater than the one we are
			 *     searching for, respectively, if the exact element cannot be found.
			 */
			function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
			  // This function terminates when one of the following is true:
			  //
			  //   1. We find the exact element we are looking for.
			  //
			  //   2. We did not find the exact element, but we can return the index of
			  //      the next-closest element.
			  //
			  //   3. We did not find the exact element, and there is no next-closest
			  //      element than the one we are searching for, so we return -1.
			  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
			  var cmp = aCompare(aNeedle, aHaystack[mid], true);
			  if (cmp === 0) {
			    // Found the element we are looking for.
			    return mid;
			  }
			  else if (cmp > 0) {
			    // Our needle is greater than aHaystack[mid].
			    if (aHigh - mid > 1) {
			      // The element is in the upper half.
			      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
			    }

			    // The exact needle element was not found in this haystack. Determine if
			    // we are in termination case (3) or (2) and return the appropriate thing.
			    if (aBias == exports.LEAST_UPPER_BOUND) {
			      return aHigh < aHaystack.length ? aHigh : -1;
			    } else {
			      return mid;
			    }
			  }
			  else {
			    // Our needle is less than aHaystack[mid].
			    if (mid - aLow > 1) {
			      // The element is in the lower half.
			      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
			    }

			    // we are in termination case (3) or (2) and return the appropriate thing.
			    if (aBias == exports.LEAST_UPPER_BOUND) {
			      return mid;
			    } else {
			      return aLow < 0 ? -1 : aLow;
			    }
			  }
			}

			/**
			 * This is an implementation of binary search which will always try and return
			 * the index of the closest element if there is no exact hit. This is because
			 * mappings between original and generated line/col pairs are single points,
			 * and there is an implicit region between each of them, so a miss just means
			 * that you aren't on the very start of a region.
			 *
			 * @param aNeedle The element you are looking for.
			 * @param aHaystack The array that is being searched.
			 * @param aCompare A function which takes the needle and an element in the
			 *     array and returns -1, 0, or 1 depending on whether the needle is less
			 *     than, equal to, or greater than the element, respectively.
			 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
			 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
			 *     closest element that is smaller than or greater than the one we are
			 *     searching for, respectively, if the exact element cannot be found.
			 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
			 */
			exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
			  if (aHaystack.length === 0) {
			    return -1;
			  }

			  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
			                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
			  if (index < 0) {
			    return -1;
			  }

			  // We have found either the exact element, or the next-closest element than
			  // the one we are searching for. However, there may be more than one such
			  // element. Make sure we always return the smallest of these.
			  while (index - 1 >= 0) {
			    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
			      break;
			    }
			    --index;
			  }

			  return index;
			}; 
		} (binarySearch));
		return binarySearch;
	}

	var quickSort = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredQuickSort;

	function requireQuickSort () {
		if (hasRequiredQuickSort) return quickSort;
		hasRequiredQuickSort = 1;
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		// It turns out that some (most?) JavaScript engines don't self-host
		// `Array.prototype.sort`. This makes sense because C++ will likely remain
		// faster than JS when doing raw CPU-intensive sorting. However, when using a
		// custom comparator function, calling back and forth between the VM's C++ and
		// JIT'd JS is rather slow *and* loses JIT type information, resulting in
		// worse generated code for the comparator function than would be optimal. In
		// fact, when sorting with a comparator, these costs outweigh the benefits of
		// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
		// a ~3500ms mean speed-up in `bench/bench.html`.

		/**
		 * Swap the elements indexed by `x` and `y` in the array `ary`.
		 *
		 * @param {Array} ary
		 *        The array.
		 * @param {Number} x
		 *        The index of the first item.
		 * @param {Number} y
		 *        The index of the second item.
		 */
		function swap(ary, x, y) {
		  var temp = ary[x];
		  ary[x] = ary[y];
		  ary[y] = temp;
		}

		/**
		 * Returns a random integer within the range `low .. high` inclusive.
		 *
		 * @param {Number} low
		 *        The lower bound on the range.
		 * @param {Number} high
		 *        The upper bound on the range.
		 */
		function randomIntInRange(low, high) {
		  return Math.round(low + (Math.random() * (high - low)));
		}

		/**
		 * The Quick Sort algorithm.
		 *
		 * @param {Array} ary
		 *        An array to sort.
		 * @param {function} comparator
		 *        Function to use to compare two items.
		 * @param {Number} p
		 *        Start index of the array
		 * @param {Number} r
		 *        End index of the array
		 */
		function doQuickSort(ary, comparator, p, r) {
		  // If our lower bound is less than our upper bound, we (1) partition the
		  // array into two pieces and (2) recurse on each half. If it is not, this is
		  // the empty array and our base case.

		  if (p < r) {
		    // (1) Partitioning.
		    //
		    // The partitioning chooses a pivot between `p` and `r` and moves all
		    // elements that are less than or equal to the pivot to the before it, and
		    // all the elements that are greater than it after it. The effect is that
		    // once partition is done, the pivot is in the exact place it will be when
		    // the array is put in sorted order, and it will not need to be moved
		    // again. This runs in O(n) time.

		    // Always choose a random pivot so that an input array which is reverse
		    // sorted does not cause O(n^2) running time.
		    var pivotIndex = randomIntInRange(p, r);
		    var i = p - 1;

		    swap(ary, pivotIndex, r);
		    var pivot = ary[r];

		    // Immediately after `j` is incremented in this loop, the following hold
		    // true:
		    //
		    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
		    //
		    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
		    for (var j = p; j < r; j++) {
		      if (comparator(ary[j], pivot) <= 0) {
		        i += 1;
		        swap(ary, i, j);
		      }
		    }

		    swap(ary, i + 1, j);
		    var q = i + 1;

		    // (2) Recurse on each half.

		    doQuickSort(ary, comparator, p, q - 1);
		    doQuickSort(ary, comparator, q + 1, r);
		  }
		}

		/**
		 * Sort the given array in-place with the given comparator function.
		 *
		 * @param {Array} ary
		 *        An array to sort.
		 * @param {function} comparator
		 *        Function to use to compare two items.
		 */
		quickSort.quickSort = function (ary, comparator) {
		  doQuickSort(ary, comparator, 0, ary.length - 1);
		};
		return quickSort;
	}

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredSourceMapConsumer;

	function requireSourceMapConsumer () {
		if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
		hasRequiredSourceMapConsumer = 1;
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		var util = requireUtil();
		var binarySearch = requireBinarySearch();
		var ArraySet = requireArraySet().ArraySet;
		var base64VLQ = requireBase64Vlq();
		var quickSort = requireQuickSort().quickSort;

		function SourceMapConsumer(aSourceMap, aSourceMapURL) {
		  var sourceMap = aSourceMap;
		  if (typeof aSourceMap === 'string') {
		    sourceMap = util.parseSourceMapInput(aSourceMap);
		  }

		  return sourceMap.sections != null
		    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
		    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
		}

		SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
		  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
		};

		/**
		 * The version of the source mapping spec that we are consuming.
		 */
		SourceMapConsumer.prototype._version = 3;

		// `__generatedMappings` and `__originalMappings` are arrays that hold the
		// parsed mapping coordinates from the source map's "mappings" attribute. They
		// are lazily instantiated, accessed via the `_generatedMappings` and
		// `_originalMappings` getters respectively, and we only parse the mappings
		// and create these arrays once queried for a source location. We jump through
		// these hoops because there can be many thousands of mappings, and parsing
		// them is expensive, so we only want to do it if we must.
		//
		// Each object in the arrays is of the form:
		//
		//     {
		//       generatedLine: The line number in the generated code,
		//       generatedColumn: The column number in the generated code,
		//       source: The path to the original source file that generated this
		//               chunk of code,
		//       originalLine: The line number in the original source that
		//                     corresponds to this chunk of generated code,
		//       originalColumn: The column number in the original source that
		//                       corresponds to this chunk of generated code,
		//       name: The name of the original symbol which generated this chunk of
		//             code.
		//     }
		//
		// All properties except for `generatedLine` and `generatedColumn` can be
		// `null`.
		//
		// `_generatedMappings` is ordered by the generated positions.
		//
		// `_originalMappings` is ordered by the original positions.

		SourceMapConsumer.prototype.__generatedMappings = null;
		Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
		  configurable: true,
		  enumerable: true,
		  get: function () {
		    if (!this.__generatedMappings) {
		      this._parseMappings(this._mappings, this.sourceRoot);
		    }

		    return this.__generatedMappings;
		  }
		});

		SourceMapConsumer.prototype.__originalMappings = null;
		Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
		  configurable: true,
		  enumerable: true,
		  get: function () {
		    if (!this.__originalMappings) {
		      this._parseMappings(this._mappings, this.sourceRoot);
		    }

		    return this.__originalMappings;
		  }
		});

		SourceMapConsumer.prototype._charIsMappingSeparator =
		  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
		    var c = aStr.charAt(index);
		    return c === ";" || c === ",";
		  };

		/**
		 * Parse the mappings in a string in to a data structure which we can easily
		 * query (the ordered arrays in the `this.__generatedMappings` and
		 * `this.__originalMappings` properties).
		 */
		SourceMapConsumer.prototype._parseMappings =
		  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		    throw new Error("Subclasses must implement _parseMappings");
		  };

		SourceMapConsumer.GENERATED_ORDER = 1;
		SourceMapConsumer.ORIGINAL_ORDER = 2;

		SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
		SourceMapConsumer.LEAST_UPPER_BOUND = 2;

		/**
		 * Iterate over each mapping between an original source/line/column and a
		 * generated line/column in this source map.
		 *
		 * @param Function aCallback
		 *        The function that is called with each mapping.
		 * @param Object aContext
		 *        Optional. If specified, this object will be the value of `this` every
		 *        time that `aCallback` is called.
		 * @param aOrder
		 *        Either `SourceMapConsumer.GENERATED_ORDER` or
		 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
		 *        iterate over the mappings sorted by the generated file's line/column
		 *        order or the original's source/line/column order, respectively. Defaults to
		 *        `SourceMapConsumer.GENERATED_ORDER`.
		 */
		SourceMapConsumer.prototype.eachMapping =
		  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
		    var context = aContext || null;
		    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

		    var mappings;
		    switch (order) {
		    case SourceMapConsumer.GENERATED_ORDER:
		      mappings = this._generatedMappings;
		      break;
		    case SourceMapConsumer.ORIGINAL_ORDER:
		      mappings = this._originalMappings;
		      break;
		    default:
		      throw new Error("Unknown order of iteration.");
		    }

		    var sourceRoot = this.sourceRoot;
		    mappings.map(function (mapping) {
		      var source = mapping.source === null ? null : this._sources.at(mapping.source);
		      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
		      return {
		        source: source,
		        generatedLine: mapping.generatedLine,
		        generatedColumn: mapping.generatedColumn,
		        originalLine: mapping.originalLine,
		        originalColumn: mapping.originalColumn,
		        name: mapping.name === null ? null : this._names.at(mapping.name)
		      };
		    }, this).forEach(aCallback, context);
		  };

		/**
		 * Returns all generated line and column information for the original source,
		 * line, and column provided. If no column is provided, returns all mappings
		 * corresponding to a either the line we are searching for or the next
		 * closest line that has any mappings. Otherwise, returns all mappings
		 * corresponding to the given line and either the column we are searching for
		 * or the next closest column that has any offsets.
		 *
		 * The only argument is an object with the following properties:
		 *
		 *   - source: The filename of the original source.
		 *   - line: The line number in the original source.  The line number is 1-based.
		 *   - column: Optional. the column number in the original source.
		 *    The column number is 0-based.
		 *
		 * and an array of objects is returned, each with the following properties:
		 *
		 *   - line: The line number in the generated source, or null.  The
		 *    line number is 1-based.
		 *   - column: The column number in the generated source, or null.
		 *    The column number is 0-based.
		 */
		SourceMapConsumer.prototype.allGeneratedPositionsFor =
		  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
		    var line = util.getArg(aArgs, 'line');

		    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
		    // returns the index of the closest mapping less than the needle. By
		    // setting needle.originalColumn to 0, we thus find the last mapping for
		    // the given line, provided such a mapping exists.
		    var needle = {
		      source: util.getArg(aArgs, 'source'),
		      originalLine: line,
		      originalColumn: util.getArg(aArgs, 'column', 0)
		    };

		    needle.source = this._findSourceIndex(needle.source);
		    if (needle.source < 0) {
		      return [];
		    }

		    var mappings = [];

		    var index = this._findMapping(needle,
		                                  this._originalMappings,
		                                  "originalLine",
		                                  "originalColumn",
		                                  util.compareByOriginalPositions,
		                                  binarySearch.LEAST_UPPER_BOUND);
		    if (index >= 0) {
		      var mapping = this._originalMappings[index];

		      if (aArgs.column === undefined) {
		        var originalLine = mapping.originalLine;

		        // Iterate until either we run out of mappings, or we run into
		        // a mapping for a different line than the one we found. Since
		        // mappings are sorted, this is guaranteed to find all mappings for
		        // the line we found.
		        while (mapping && mapping.originalLine === originalLine) {
		          mappings.push({
		            line: util.getArg(mapping, 'generatedLine', null),
		            column: util.getArg(mapping, 'generatedColumn', null),
		            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
		          });

		          mapping = this._originalMappings[++index];
		        }
		      } else {
		        var originalColumn = mapping.originalColumn;

		        // Iterate until either we run out of mappings, or we run into
		        // a mapping for a different line than the one we were searching for.
		        // Since mappings are sorted, this is guaranteed to find all mappings for
		        // the line we are searching for.
		        while (mapping &&
		               mapping.originalLine === line &&
		               mapping.originalColumn == originalColumn) {
		          mappings.push({
		            line: util.getArg(mapping, 'generatedLine', null),
		            column: util.getArg(mapping, 'generatedColumn', null),
		            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
		          });

		          mapping = this._originalMappings[++index];
		        }
		      }
		    }

		    return mappings;
		  };

		sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

		/**
		 * A BasicSourceMapConsumer instance represents a parsed source map which we can
		 * query for information about the original file positions by giving it a file
		 * position in the generated source.
		 *
		 * The first parameter is the raw source map (either as a JSON string, or
		 * already parsed to an object). According to the spec, source maps have the
		 * following attributes:
		 *
		 *   - version: Which version of the source map spec this map is following.
		 *   - sources: An array of URLs to the original source files.
		 *   - names: An array of identifiers which can be referrenced by individual mappings.
		 *   - sourceRoot: Optional. The URL root from which all sources are relative.
		 *   - sourcesContent: Optional. An array of contents of the original source files.
		 *   - mappings: A string of base64 VLQs which contain the actual mappings.
		 *   - file: Optional. The generated file this source map is associated with.
		 *
		 * Here is an example source map, taken from the source map spec[0]:
		 *
		 *     {
		 *       version : 3,
		 *       file: "out.js",
		 *       sourceRoot : "",
		 *       sources: ["foo.js", "bar.js"],
		 *       names: ["src", "maps", "are", "fun"],
		 *       mappings: "AA,AB;;ABCDE;"
		 *     }
		 *
		 * The second parameter, if given, is a string whose value is the URL
		 * at which the source map was found.  This URL is used to compute the
		 * sources array.
		 *
		 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
		 */
		function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
		  var sourceMap = aSourceMap;
		  if (typeof aSourceMap === 'string') {
		    sourceMap = util.parseSourceMapInput(aSourceMap);
		  }

		  var version = util.getArg(sourceMap, 'version');
		  var sources = util.getArg(sourceMap, 'sources');
		  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
		  // requires the array) to play nice here.
		  var names = util.getArg(sourceMap, 'names', []);
		  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
		  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
		  var mappings = util.getArg(sourceMap, 'mappings');
		  var file = util.getArg(sourceMap, 'file', null);

		  // Once again, Sass deviates from the spec and supplies the version as a
		  // string rather than a number, so we use loose equality checking here.
		  if (version != this._version) {
		    throw new Error('Unsupported version: ' + version);
		  }

		  if (sourceRoot) {
		    sourceRoot = util.normalize(sourceRoot);
		  }

		  sources = sources
		    .map(String)
		    // Some source maps produce relative source paths like "./foo.js" instead of
		    // "foo.js".  Normalize these first so that future comparisons will succeed.
		    // See bugzil.la/1090768.
		    .map(util.normalize)
		    // Always ensure that absolute sources are internally stored relative to
		    // the source root, if the source root is absolute. Not doing this would
		    // be particularly problematic when the source root is a prefix of the
		    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
		    .map(function (source) {
		      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
		        ? util.relative(sourceRoot, source)
		        : source;
		    });

		  // Pass `true` below to allow duplicate names and sources. While source maps
		  // are intended to be compressed and deduplicated, the TypeScript compiler
		  // sometimes generates source maps with duplicates in them. See Github issue
		  // #72 and bugzil.la/889492.
		  this._names = ArraySet.fromArray(names.map(String), true);
		  this._sources = ArraySet.fromArray(sources, true);

		  this._absoluteSources = this._sources.toArray().map(function (s) {
		    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
		  });

		  this.sourceRoot = sourceRoot;
		  this.sourcesContent = sourcesContent;
		  this._mappings = mappings;
		  this._sourceMapURL = aSourceMapURL;
		  this.file = file;
		}

		BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
		BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

		/**
		 * Utility function to find the index of a source.  Returns -1 if not
		 * found.
		 */
		BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
		  var relativeSource = aSource;
		  if (this.sourceRoot != null) {
		    relativeSource = util.relative(this.sourceRoot, relativeSource);
		  }

		  if (this._sources.has(relativeSource)) {
		    return this._sources.indexOf(relativeSource);
		  }

		  // Maybe aSource is an absolute URL as returned by |sources|.  In
		  // this case we can't simply undo the transform.
		  var i;
		  for (i = 0; i < this._absoluteSources.length; ++i) {
		    if (this._absoluteSources[i] == aSource) {
		      return i;
		    }
		  }

		  return -1;
		};

		/**
		 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
		 *
		 * @param SourceMapGenerator aSourceMap
		 *        The source map that will be consumed.
		 * @param String aSourceMapURL
		 *        The URL at which the source map can be found (optional)
		 * @returns BasicSourceMapConsumer
		 */
		BasicSourceMapConsumer.fromSourceMap =
		  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
		    var smc = Object.create(BasicSourceMapConsumer.prototype);

		    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
		    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
		    smc.sourceRoot = aSourceMap._sourceRoot;
		    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
		                                                            smc.sourceRoot);
		    smc.file = aSourceMap._file;
		    smc._sourceMapURL = aSourceMapURL;
		    smc._absoluteSources = smc._sources.toArray().map(function (s) {
		      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
		    });

		    // Because we are modifying the entries (by converting string sources and
		    // names to indices into the sources and names ArraySets), we have to make
		    // a copy of the entry or else bad things happen. Shared mutable state
		    // strikes again! See github issue #191.

		    var generatedMappings = aSourceMap._mappings.toArray().slice();
		    var destGeneratedMappings = smc.__generatedMappings = [];
		    var destOriginalMappings = smc.__originalMappings = [];

		    for (var i = 0, length = generatedMappings.length; i < length; i++) {
		      var srcMapping = generatedMappings[i];
		      var destMapping = new Mapping;
		      destMapping.generatedLine = srcMapping.generatedLine;
		      destMapping.generatedColumn = srcMapping.generatedColumn;

		      if (srcMapping.source) {
		        destMapping.source = sources.indexOf(srcMapping.source);
		        destMapping.originalLine = srcMapping.originalLine;
		        destMapping.originalColumn = srcMapping.originalColumn;

		        if (srcMapping.name) {
		          destMapping.name = names.indexOf(srcMapping.name);
		        }

		        destOriginalMappings.push(destMapping);
		      }

		      destGeneratedMappings.push(destMapping);
		    }

		    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

		    return smc;
		  };

		/**
		 * The version of the source mapping spec that we are consuming.
		 */
		BasicSourceMapConsumer.prototype._version = 3;

		/**
		 * The list of original sources.
		 */
		Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
		  get: function () {
		    return this._absoluteSources.slice();
		  }
		});

		/**
		 * Provide the JIT with a nice shape / hidden class.
		 */
		function Mapping() {
		  this.generatedLine = 0;
		  this.generatedColumn = 0;
		  this.source = null;
		  this.originalLine = null;
		  this.originalColumn = null;
		  this.name = null;
		}

		/**
		 * Parse the mappings in a string in to a data structure which we can easily
		 * query (the ordered arrays in the `this.__generatedMappings` and
		 * `this.__originalMappings` properties).
		 */
		BasicSourceMapConsumer.prototype._parseMappings =
		  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		    var generatedLine = 1;
		    var previousGeneratedColumn = 0;
		    var previousOriginalLine = 0;
		    var previousOriginalColumn = 0;
		    var previousSource = 0;
		    var previousName = 0;
		    var length = aStr.length;
		    var index = 0;
		    var cachedSegments = {};
		    var temp = {};
		    var originalMappings = [];
		    var generatedMappings = [];
		    var mapping, str, segment, end, value;

		    while (index < length) {
		      if (aStr.charAt(index) === ';') {
		        generatedLine++;
		        index++;
		        previousGeneratedColumn = 0;
		      }
		      else if (aStr.charAt(index) === ',') {
		        index++;
		      }
		      else {
		        mapping = new Mapping();
		        mapping.generatedLine = generatedLine;

		        // Because each offset is encoded relative to the previous one,
		        // many segments often have the same encoding. We can exploit this
		        // fact by caching the parsed variable length fields of each segment,
		        // allowing us to avoid a second parse if we encounter the same
		        // segment again.
		        for (end = index; end < length; end++) {
		          if (this._charIsMappingSeparator(aStr, end)) {
		            break;
		          }
		        }
		        str = aStr.slice(index, end);

		        segment = cachedSegments[str];
		        if (segment) {
		          index += str.length;
		        } else {
		          segment = [];
		          while (index < end) {
		            base64VLQ.decode(aStr, index, temp);
		            value = temp.value;
		            index = temp.rest;
		            segment.push(value);
		          }

		          if (segment.length === 2) {
		            throw new Error('Found a source, but no line and column');
		          }

		          if (segment.length === 3) {
		            throw new Error('Found a source and line, but no column');
		          }

		          cachedSegments[str] = segment;
		        }

		        // Generated column.
		        mapping.generatedColumn = previousGeneratedColumn + segment[0];
		        previousGeneratedColumn = mapping.generatedColumn;

		        if (segment.length > 1) {
		          // Original source.
		          mapping.source = previousSource + segment[1];
		          previousSource += segment[1];

		          // Original line.
		          mapping.originalLine = previousOriginalLine + segment[2];
		          previousOriginalLine = mapping.originalLine;
		          // Lines are stored 0-based
		          mapping.originalLine += 1;

		          // Original column.
		          mapping.originalColumn = previousOriginalColumn + segment[3];
		          previousOriginalColumn = mapping.originalColumn;

		          if (segment.length > 4) {
		            // Original name.
		            mapping.name = previousName + segment[4];
		            previousName += segment[4];
		          }
		        }

		        generatedMappings.push(mapping);
		        if (typeof mapping.originalLine === 'number') {
		          originalMappings.push(mapping);
		        }
		      }
		    }

		    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
		    this.__generatedMappings = generatedMappings;

		    quickSort(originalMappings, util.compareByOriginalPositions);
		    this.__originalMappings = originalMappings;
		  };

		/**
		 * Find the mapping that best matches the hypothetical "needle" mapping that
		 * we are searching for in the given "haystack" of mappings.
		 */
		BasicSourceMapConsumer.prototype._findMapping =
		  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
		                                         aColumnName, aComparator, aBias) {
		    // To return the position we are searching for, we must first find the
		    // mapping for the given position and then return the opposite position it
		    // points to. Because the mappings are sorted, we can use binary search to
		    // find the best mapping.

		    if (aNeedle[aLineName] <= 0) {
		      throw new TypeError('Line must be greater than or equal to 1, got '
		                          + aNeedle[aLineName]);
		    }
		    if (aNeedle[aColumnName] < 0) {
		      throw new TypeError('Column must be greater than or equal to 0, got '
		                          + aNeedle[aColumnName]);
		    }

		    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
		  };

		/**
		 * Compute the last column for each generated mapping. The last column is
		 * inclusive.
		 */
		BasicSourceMapConsumer.prototype.computeColumnSpans =
		  function SourceMapConsumer_computeColumnSpans() {
		    for (var index = 0; index < this._generatedMappings.length; ++index) {
		      var mapping = this._generatedMappings[index];

		      // Mappings do not contain a field for the last generated columnt. We
		      // can come up with an optimistic estimate, however, by assuming that
		      // mappings are contiguous (i.e. given two consecutive mappings, the
		      // first mapping ends where the second one starts).
		      if (index + 1 < this._generatedMappings.length) {
		        var nextMapping = this._generatedMappings[index + 1];

		        if (mapping.generatedLine === nextMapping.generatedLine) {
		          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
		          continue;
		        }
		      }

		      // The last mapping for each line spans the entire line.
		      mapping.lastGeneratedColumn = Infinity;
		    }
		  };

		/**
		 * Returns the original source, line, and column information for the generated
		 * source's line and column positions provided. The only argument is an object
		 * with the following properties:
		 *
		 *   - line: The line number in the generated source.  The line number
		 *     is 1-based.
		 *   - column: The column number in the generated source.  The column
		 *     number is 0-based.
		 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
		 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
		 *
		 * and an object is returned with the following properties:
		 *
		 *   - source: The original source file, or null.
		 *   - line: The line number in the original source, or null.  The
		 *     line number is 1-based.
		 *   - column: The column number in the original source, or null.  The
		 *     column number is 0-based.
		 *   - name: The original identifier, or null.
		 */
		BasicSourceMapConsumer.prototype.originalPositionFor =
		  function SourceMapConsumer_originalPositionFor(aArgs) {
		    var needle = {
		      generatedLine: util.getArg(aArgs, 'line'),
		      generatedColumn: util.getArg(aArgs, 'column')
		    };

		    var index = this._findMapping(
		      needle,
		      this._generatedMappings,
		      "generatedLine",
		      "generatedColumn",
		      util.compareByGeneratedPositionsDeflated,
		      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
		    );

		    if (index >= 0) {
		      var mapping = this._generatedMappings[index];

		      if (mapping.generatedLine === needle.generatedLine) {
		        var source = util.getArg(mapping, 'source', null);
		        if (source !== null) {
		          source = this._sources.at(source);
		          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
		        }
		        var name = util.getArg(mapping, 'name', null);
		        if (name !== null) {
		          name = this._names.at(name);
		        }
		        return {
		          source: source,
		          line: util.getArg(mapping, 'originalLine', null),
		          column: util.getArg(mapping, 'originalColumn', null),
		          name: name
		        };
		      }
		    }

		    return {
		      source: null,
		      line: null,
		      column: null,
		      name: null
		    };
		  };

		/**
		 * Return true if we have the source content for every source in the source
		 * map, false otherwise.
		 */
		BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
		  function BasicSourceMapConsumer_hasContentsOfAllSources() {
		    if (!this.sourcesContent) {
		      return false;
		    }
		    return this.sourcesContent.length >= this._sources.size() &&
		      !this.sourcesContent.some(function (sc) { return sc == null; });
		  };

		/**
		 * Returns the original source content. The only argument is the url of the
		 * original source file. Returns null if no original source content is
		 * available.
		 */
		BasicSourceMapConsumer.prototype.sourceContentFor =
		  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		    if (!this.sourcesContent) {
		      return null;
		    }

		    var index = this._findSourceIndex(aSource);
		    if (index >= 0) {
		      return this.sourcesContent[index];
		    }

		    var relativeSource = aSource;
		    if (this.sourceRoot != null) {
		      relativeSource = util.relative(this.sourceRoot, relativeSource);
		    }

		    var url;
		    if (this.sourceRoot != null
		        && (url = util.urlParse(this.sourceRoot))) {
		      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
		      // many users. We can help them out when they expect file:// URIs to
		      // behave like it would if they were running a local HTTP server. See
		      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
		      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
		      if (url.scheme == "file"
		          && this._sources.has(fileUriAbsPath)) {
		        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
		      }

		      if ((!url.path || url.path == "/")
		          && this._sources.has("/" + relativeSource)) {
		        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
		      }
		    }

		    // This function is used recursively from
		    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
		    // don't want to throw if we can't find the source - we just want to
		    // return null, so we provide a flag to exit gracefully.
		    if (nullOnMissing) {
		      return null;
		    }
		    else {
		      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
		    }
		  };

		/**
		 * Returns the generated line and column information for the original source,
		 * line, and column positions provided. The only argument is an object with
		 * the following properties:
		 *
		 *   - source: The filename of the original source.
		 *   - line: The line number in the original source.  The line number
		 *     is 1-based.
		 *   - column: The column number in the original source.  The column
		 *     number is 0-based.
		 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
		 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
		 *
		 * and an object is returned with the following properties:
		 *
		 *   - line: The line number in the generated source, or null.  The
		 *     line number is 1-based.
		 *   - column: The column number in the generated source, or null.
		 *     The column number is 0-based.
		 */
		BasicSourceMapConsumer.prototype.generatedPositionFor =
		  function SourceMapConsumer_generatedPositionFor(aArgs) {
		    var source = util.getArg(aArgs, 'source');
		    source = this._findSourceIndex(source);
		    if (source < 0) {
		      return {
		        line: null,
		        column: null,
		        lastColumn: null
		      };
		    }

		    var needle = {
		      source: source,
		      originalLine: util.getArg(aArgs, 'line'),
		      originalColumn: util.getArg(aArgs, 'column')
		    };

		    var index = this._findMapping(
		      needle,
		      this._originalMappings,
		      "originalLine",
		      "originalColumn",
		      util.compareByOriginalPositions,
		      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
		    );

		    if (index >= 0) {
		      var mapping = this._originalMappings[index];

		      if (mapping.source === needle.source) {
		        return {
		          line: util.getArg(mapping, 'generatedLine', null),
		          column: util.getArg(mapping, 'generatedColumn', null),
		          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
		        };
		      }
		    }

		    return {
		      line: null,
		      column: null,
		      lastColumn: null
		    };
		  };

		sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

		/**
		 * An IndexedSourceMapConsumer instance represents a parsed source map which
		 * we can query for information. It differs from BasicSourceMapConsumer in
		 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
		 * input.
		 *
		 * The first parameter is a raw source map (either as a JSON string, or already
		 * parsed to an object). According to the spec for indexed source maps, they
		 * have the following attributes:
		 *
		 *   - version: Which version of the source map spec this map is following.
		 *   - file: Optional. The generated file this source map is associated with.
		 *   - sections: A list of section definitions.
		 *
		 * Each value under the "sections" field has two fields:
		 *   - offset: The offset into the original specified at which this section
		 *       begins to apply, defined as an object with a "line" and "column"
		 *       field.
		 *   - map: A source map definition. This source map could also be indexed,
		 *       but doesn't have to be.
		 *
		 * Instead of the "map" field, it's also possible to have a "url" field
		 * specifying a URL to retrieve a source map from, but that's currently
		 * unsupported.
		 *
		 * Here's an example source map, taken from the source map spec[0], but
		 * modified to omit a section which uses the "url" field.
		 *
		 *  {
		 *    version : 3,
		 *    file: "app.js",
		 *    sections: [{
		 *      offset: {line:100, column:10},
		 *      map: {
		 *        version : 3,
		 *        file: "section.js",
		 *        sources: ["foo.js", "bar.js"],
		 *        names: ["src", "maps", "are", "fun"],
		 *        mappings: "AAAA,E;;ABCDE;"
		 *      }
		 *    }],
		 *  }
		 *
		 * The second parameter, if given, is a string whose value is the URL
		 * at which the source map was found.  This URL is used to compute the
		 * sources array.
		 *
		 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
		 */
		function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
		  var sourceMap = aSourceMap;
		  if (typeof aSourceMap === 'string') {
		    sourceMap = util.parseSourceMapInput(aSourceMap);
		  }

		  var version = util.getArg(sourceMap, 'version');
		  var sections = util.getArg(sourceMap, 'sections');

		  if (version != this._version) {
		    throw new Error('Unsupported version: ' + version);
		  }

		  this._sources = new ArraySet();
		  this._names = new ArraySet();

		  var lastOffset = {
		    line: -1,
		    column: 0
		  };
		  this._sections = sections.map(function (s) {
		    if (s.url) {
		      // The url field will require support for asynchronicity.
		      // See https://github.com/mozilla/source-map/issues/16
		      throw new Error('Support for url field in sections not implemented.');
		    }
		    var offset = util.getArg(s, 'offset');
		    var offsetLine = util.getArg(offset, 'line');
		    var offsetColumn = util.getArg(offset, 'column');

		    if (offsetLine < lastOffset.line ||
		        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
		      throw new Error('Section offsets must be ordered and non-overlapping.');
		    }
		    lastOffset = offset;

		    return {
		      generatedOffset: {
		        // The offset fields are 0-based, but we use 1-based indices when
		        // encoding/decoding from VLQ.
		        generatedLine: offsetLine + 1,
		        generatedColumn: offsetColumn + 1
		      },
		      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
		    }
		  });
		}

		IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
		IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

		/**
		 * The version of the source mapping spec that we are consuming.
		 */
		IndexedSourceMapConsumer.prototype._version = 3;

		/**
		 * The list of original sources.
		 */
		Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
		  get: function () {
		    var sources = [];
		    for (var i = 0; i < this._sections.length; i++) {
		      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
		        sources.push(this._sections[i].consumer.sources[j]);
		      }
		    }
		    return sources;
		  }
		});

		/**
		 * Returns the original source, line, and column information for the generated
		 * source's line and column positions provided. The only argument is an object
		 * with the following properties:
		 *
		 *   - line: The line number in the generated source.  The line number
		 *     is 1-based.
		 *   - column: The column number in the generated source.  The column
		 *     number is 0-based.
		 *
		 * and an object is returned with the following properties:
		 *
		 *   - source: The original source file, or null.
		 *   - line: The line number in the original source, or null.  The
		 *     line number is 1-based.
		 *   - column: The column number in the original source, or null.  The
		 *     column number is 0-based.
		 *   - name: The original identifier, or null.
		 */
		IndexedSourceMapConsumer.prototype.originalPositionFor =
		  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
		    var needle = {
		      generatedLine: util.getArg(aArgs, 'line'),
		      generatedColumn: util.getArg(aArgs, 'column')
		    };

		    // Find the section containing the generated position we're trying to map
		    // to an original position.
		    var sectionIndex = binarySearch.search(needle, this._sections,
		      function(needle, section) {
		        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
		        if (cmp) {
		          return cmp;
		        }

		        return (needle.generatedColumn -
		                section.generatedOffset.generatedColumn);
		      });
		    var section = this._sections[sectionIndex];

		    if (!section) {
		      return {
		        source: null,
		        line: null,
		        column: null,
		        name: null
		      };
		    }

		    return section.consumer.originalPositionFor({
		      line: needle.generatedLine -
		        (section.generatedOffset.generatedLine - 1),
		      column: needle.generatedColumn -
		        (section.generatedOffset.generatedLine === needle.generatedLine
		         ? section.generatedOffset.generatedColumn - 1
		         : 0),
		      bias: aArgs.bias
		    });
		  };

		/**
		 * Return true if we have the source content for every source in the source
		 * map, false otherwise.
		 */
		IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
		  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
		    return this._sections.every(function (s) {
		      return s.consumer.hasContentsOfAllSources();
		    });
		  };

		/**
		 * Returns the original source content. The only argument is the url of the
		 * original source file. Returns null if no original source content is
		 * available.
		 */
		IndexedSourceMapConsumer.prototype.sourceContentFor =
		  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		    for (var i = 0; i < this._sections.length; i++) {
		      var section = this._sections[i];

		      var content = section.consumer.sourceContentFor(aSource, true);
		      if (content) {
		        return content;
		      }
		    }
		    if (nullOnMissing) {
		      return null;
		    }
		    else {
		      throw new Error('"' + aSource + '" is not in the SourceMap.');
		    }
		  };

		/**
		 * Returns the generated line and column information for the original source,
		 * line, and column positions provided. The only argument is an object with
		 * the following properties:
		 *
		 *   - source: The filename of the original source.
		 *   - line: The line number in the original source.  The line number
		 *     is 1-based.
		 *   - column: The column number in the original source.  The column
		 *     number is 0-based.
		 *
		 * and an object is returned with the following properties:
		 *
		 *   - line: The line number in the generated source, or null.  The
		 *     line number is 1-based. 
		 *   - column: The column number in the generated source, or null.
		 *     The column number is 0-based.
		 */
		IndexedSourceMapConsumer.prototype.generatedPositionFor =
		  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
		    for (var i = 0; i < this._sections.length; i++) {
		      var section = this._sections[i];

		      // Only consider this section if the requested source is in the list of
		      // sources of the consumer.
		      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
		        continue;
		      }
		      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
		      if (generatedPosition) {
		        var ret = {
		          line: generatedPosition.line +
		            (section.generatedOffset.generatedLine - 1),
		          column: generatedPosition.column +
		            (section.generatedOffset.generatedLine === generatedPosition.line
		             ? section.generatedOffset.generatedColumn - 1
		             : 0)
		        };
		        return ret;
		      }
		    }

		    return {
		      line: null,
		      column: null
		    };
		  };

		/**
		 * Parse the mappings in a string in to a data structure which we can easily
		 * query (the ordered arrays in the `this.__generatedMappings` and
		 * `this.__originalMappings` properties).
		 */
		IndexedSourceMapConsumer.prototype._parseMappings =
		  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		    this.__generatedMappings = [];
		    this.__originalMappings = [];
		    for (var i = 0; i < this._sections.length; i++) {
		      var section = this._sections[i];
		      var sectionMappings = section.consumer._generatedMappings;
		      for (var j = 0; j < sectionMappings.length; j++) {
		        var mapping = sectionMappings[j];

		        var source = section.consumer._sources.at(mapping.source);
		        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
		        this._sources.add(source);
		        source = this._sources.indexOf(source);

		        var name = null;
		        if (mapping.name) {
		          name = section.consumer._names.at(mapping.name);
		          this._names.add(name);
		          name = this._names.indexOf(name);
		        }

		        // The mappings coming from the consumer for the section have
		        // generated positions relative to the start of the section, so we
		        // need to offset them to be relative to the start of the concatenated
		        // generated file.
		        var adjustedMapping = {
		          source: source,
		          generatedLine: mapping.generatedLine +
		            (section.generatedOffset.generatedLine - 1),
		          generatedColumn: mapping.generatedColumn +
		            (section.generatedOffset.generatedLine === mapping.generatedLine
		            ? section.generatedOffset.generatedColumn - 1
		            : 0),
		          originalLine: mapping.originalLine,
		          originalColumn: mapping.originalColumn,
		          name: name
		        };

		        this.__generatedMappings.push(adjustedMapping);
		        if (typeof adjustedMapping.originalLine === 'number') {
		          this.__originalMappings.push(adjustedMapping);
		        }
		      }
		    }

		    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
		    quickSort(this.__originalMappings, util.compareByOriginalPositions);
		  };

		sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
		return sourceMapConsumer;
	}

	var sourceNode = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */

	var hasRequiredSourceNode;

	function requireSourceNode () {
		if (hasRequiredSourceNode) return sourceNode;
		hasRequiredSourceNode = 1;
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
		var util = requireUtil();

		// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
		// operating systems these days (capturing the result).
		var REGEX_NEWLINE = /(\r?\n)/;

		// Newline character code for charCodeAt() comparisons
		var NEWLINE_CODE = 10;

		// Private symbol for identifying `SourceNode`s when multiple versions of
		// the source-map library are loaded. This MUST NOT CHANGE across
		// versions!
		var isSourceNode = "$$$isSourceNode$$$";

		/**
		 * SourceNodes provide a way to abstract over interpolating/concatenating
		 * snippets of generated JavaScript source code while maintaining the line and
		 * column information associated with the original source code.
		 *
		 * @param aLine The original line number.
		 * @param aColumn The original column number.
		 * @param aSource The original source's filename.
		 * @param aChunks Optional. An array of strings which are snippets of
		 *        generated JS, or other SourceNodes.
		 * @param aName The original identifier.
		 */
		function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
		  this.children = [];
		  this.sourceContents = {};
		  this.line = aLine == null ? null : aLine;
		  this.column = aColumn == null ? null : aColumn;
		  this.source = aSource == null ? null : aSource;
		  this.name = aName == null ? null : aName;
		  this[isSourceNode] = true;
		  if (aChunks != null) this.add(aChunks);
		}

		/**
		 * Creates a SourceNode from generated code and a SourceMapConsumer.
		 *
		 * @param aGeneratedCode The generated code
		 * @param aSourceMapConsumer The SourceMap for the generated code
		 * @param aRelativePath Optional. The path that relative sources in the
		 *        SourceMapConsumer should be relative to.
		 */
		SourceNode.fromStringWithSourceMap =
		  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
		    // The SourceNode we want to fill with the generated code
		    // and the SourceMap
		    var node = new SourceNode();

		    // All even indices of this array are one line of the generated code,
		    // while all odd indices are the newlines between two adjacent lines
		    // (since `REGEX_NEWLINE` captures its match).
		    // Processed fragments are accessed by calling `shiftNextLine`.
		    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
		    var remainingLinesIndex = 0;
		    var shiftNextLine = function() {
		      var lineContents = getNextLine();
		      // The last line of a file might not have a newline.
		      var newLine = getNextLine() || "";
		      return lineContents + newLine;

		      function getNextLine() {
		        return remainingLinesIndex < remainingLines.length ?
		            remainingLines[remainingLinesIndex++] : undefined;
		      }
		    };

		    // We need to remember the position of "remainingLines"
		    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

		    // The generate SourceNodes we need a code range.
		    // To extract it current and last mapping is used.
		    // Here we store the last mapping.
		    var lastMapping = null;

		    aSourceMapConsumer.eachMapping(function (mapping) {
		      if (lastMapping !== null) {
		        // We add the code from "lastMapping" to "mapping":
		        // First check if there is a new line in between.
		        if (lastGeneratedLine < mapping.generatedLine) {
		          // Associate first line with "lastMapping"
		          addMappingWithCode(lastMapping, shiftNextLine());
		          lastGeneratedLine++;
		          lastGeneratedColumn = 0;
		          // The remaining code is added without mapping
		        } else {
		          // There is no new line in between.
		          // Associate the code between "lastGeneratedColumn" and
		          // "mapping.generatedColumn" with "lastMapping"
		          var nextLine = remainingLines[remainingLinesIndex] || '';
		          var code = nextLine.substr(0, mapping.generatedColumn -
		                                        lastGeneratedColumn);
		          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
		                                              lastGeneratedColumn);
		          lastGeneratedColumn = mapping.generatedColumn;
		          addMappingWithCode(lastMapping, code);
		          // No more remaining code, continue
		          lastMapping = mapping;
		          return;
		        }
		      }
		      // We add the generated code until the first mapping
		      // to the SourceNode without any mapping.
		      // Each line is added as separate string.
		      while (lastGeneratedLine < mapping.generatedLine) {
		        node.add(shiftNextLine());
		        lastGeneratedLine++;
		      }
		      if (lastGeneratedColumn < mapping.generatedColumn) {
		        var nextLine = remainingLines[remainingLinesIndex] || '';
		        node.add(nextLine.substr(0, mapping.generatedColumn));
		        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
		        lastGeneratedColumn = mapping.generatedColumn;
		      }
		      lastMapping = mapping;
		    }, this);
		    // We have processed all mappings.
		    if (remainingLinesIndex < remainingLines.length) {
		      if (lastMapping) {
		        // Associate the remaining code in the current line with "lastMapping"
		        addMappingWithCode(lastMapping, shiftNextLine());
		      }
		      // and add the remaining lines without any mapping
		      node.add(remainingLines.splice(remainingLinesIndex).join(""));
		    }

		    // Copy sourcesContent into SourceNode
		    aSourceMapConsumer.sources.forEach(function (sourceFile) {
		      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
		      if (content != null) {
		        if (aRelativePath != null) {
		          sourceFile = util.join(aRelativePath, sourceFile);
		        }
		        node.setSourceContent(sourceFile, content);
		      }
		    });

		    return node;

		    function addMappingWithCode(mapping, code) {
		      if (mapping === null || mapping.source === undefined) {
		        node.add(code);
		      } else {
		        var source = aRelativePath
		          ? util.join(aRelativePath, mapping.source)
		          : mapping.source;
		        node.add(new SourceNode(mapping.originalLine,
		                                mapping.originalColumn,
		                                source,
		                                code,
		                                mapping.name));
		      }
		    }
		  };

		/**
		 * Add a chunk of generated JS to this source node.
		 *
		 * @param aChunk A string snippet of generated JS code, another instance of
		 *        SourceNode, or an array where each member is one of those things.
		 */
		SourceNode.prototype.add = function SourceNode_add(aChunk) {
		  if (Array.isArray(aChunk)) {
		    aChunk.forEach(function (chunk) {
		      this.add(chunk);
		    }, this);
		  }
		  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
		    if (aChunk) {
		      this.children.push(aChunk);
		    }
		  }
		  else {
		    throw new TypeError(
		      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
		    );
		  }
		  return this;
		};

		/**
		 * Add a chunk of generated JS to the beginning of this source node.
		 *
		 * @param aChunk A string snippet of generated JS code, another instance of
		 *        SourceNode, or an array where each member is one of those things.
		 */
		SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
		  if (Array.isArray(aChunk)) {
		    for (var i = aChunk.length-1; i >= 0; i--) {
		      this.prepend(aChunk[i]);
		    }
		  }
		  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
		    this.children.unshift(aChunk);
		  }
		  else {
		    throw new TypeError(
		      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
		    );
		  }
		  return this;
		};

		/**
		 * Walk over the tree of JS snippets in this node and its children. The
		 * walking function is called once for each snippet of JS and is passed that
		 * snippet and the its original associated source's line/column location.
		 *
		 * @param aFn The traversal function.
		 */
		SourceNode.prototype.walk = function SourceNode_walk(aFn) {
		  var chunk;
		  for (var i = 0, len = this.children.length; i < len; i++) {
		    chunk = this.children[i];
		    if (chunk[isSourceNode]) {
		      chunk.walk(aFn);
		    }
		    else {
		      if (chunk !== '') {
		        aFn(chunk, { source: this.source,
		                     line: this.line,
		                     column: this.column,
		                     name: this.name });
		      }
		    }
		  }
		};

		/**
		 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
		 * each of `this.children`.
		 *
		 * @param aSep The separator.
		 */
		SourceNode.prototype.join = function SourceNode_join(aSep) {
		  var newChildren;
		  var i;
		  var len = this.children.length;
		  if (len > 0) {
		    newChildren = [];
		    for (i = 0; i < len-1; i++) {
		      newChildren.push(this.children[i]);
		      newChildren.push(aSep);
		    }
		    newChildren.push(this.children[i]);
		    this.children = newChildren;
		  }
		  return this;
		};

		/**
		 * Call String.prototype.replace on the very right-most source snippet. Useful
		 * for trimming whitespace from the end of a source node, etc.
		 *
		 * @param aPattern The pattern to replace.
		 * @param aReplacement The thing to replace the pattern with.
		 */
		SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
		  var lastChild = this.children[this.children.length - 1];
		  if (lastChild[isSourceNode]) {
		    lastChild.replaceRight(aPattern, aReplacement);
		  }
		  else if (typeof lastChild === 'string') {
		    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
		  }
		  else {
		    this.children.push(''.replace(aPattern, aReplacement));
		  }
		  return this;
		};

		/**
		 * Set the source content for a source file. This will be added to the SourceMapGenerator
		 * in the sourcesContent field.
		 *
		 * @param aSourceFile The filename of the source file
		 * @param aSourceContent The content of the source file
		 */
		SourceNode.prototype.setSourceContent =
		  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
		    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
		  };

		/**
		 * Walk over the tree of SourceNodes. The walking function is called for each
		 * source file content and is passed the filename and source content.
		 *
		 * @param aFn The traversal function.
		 */
		SourceNode.prototype.walkSourceContents =
		  function SourceNode_walkSourceContents(aFn) {
		    for (var i = 0, len = this.children.length; i < len; i++) {
		      if (this.children[i][isSourceNode]) {
		        this.children[i].walkSourceContents(aFn);
		      }
		    }

		    var sources = Object.keys(this.sourceContents);
		    for (var i = 0, len = sources.length; i < len; i++) {
		      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
		    }
		  };

		/**
		 * Return the string representation of this source node. Walks over the tree
		 * and concatenates all the various snippets together to one string.
		 */
		SourceNode.prototype.toString = function SourceNode_toString() {
		  var str = "";
		  this.walk(function (chunk) {
		    str += chunk;
		  });
		  return str;
		};

		/**
		 * Returns the string representation of this source node along with a source
		 * map.
		 */
		SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
		  var generated = {
		    code: "",
		    line: 1,
		    column: 0
		  };
		  var map = new SourceMapGenerator(aArgs);
		  var sourceMappingActive = false;
		  var lastOriginalSource = null;
		  var lastOriginalLine = null;
		  var lastOriginalColumn = null;
		  var lastOriginalName = null;
		  this.walk(function (chunk, original) {
		    generated.code += chunk;
		    if (original.source !== null
		        && original.line !== null
		        && original.column !== null) {
		      if(lastOriginalSource !== original.source
		         || lastOriginalLine !== original.line
		         || lastOriginalColumn !== original.column
		         || lastOriginalName !== original.name) {
		        map.addMapping({
		          source: original.source,
		          original: {
		            line: original.line,
		            column: original.column
		          },
		          generated: {
		            line: generated.line,
		            column: generated.column
		          },
		          name: original.name
		        });
		      }
		      lastOriginalSource = original.source;
		      lastOriginalLine = original.line;
		      lastOriginalColumn = original.column;
		      lastOriginalName = original.name;
		      sourceMappingActive = true;
		    } else if (sourceMappingActive) {
		      map.addMapping({
		        generated: {
		          line: generated.line,
		          column: generated.column
		        }
		      });
		      lastOriginalSource = null;
		      sourceMappingActive = false;
		    }
		    for (var idx = 0, length = chunk.length; idx < length; idx++) {
		      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
		        generated.line++;
		        generated.column = 0;
		        // Mappings end at eol
		        if (idx + 1 === length) {
		          lastOriginalSource = null;
		          sourceMappingActive = false;
		        } else if (sourceMappingActive) {
		          map.addMapping({
		            source: original.source,
		            original: {
		              line: original.line,
		              column: original.column
		            },
		            generated: {
		              line: generated.line,
		              column: generated.column
		            },
		            name: original.name
		          });
		        }
		      } else {
		        generated.column++;
		      }
		    }
		  });
		  this.walkSourceContents(function (sourceFile, sourceContent) {
		    map.setSourceContent(sourceFile, sourceContent);
		  });

		  return { code: generated.code, map: map };
		};

		sourceNode.SourceNode = SourceNode;
		return sourceNode;
	}

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var hasRequiredSourceMap;

	function requireSourceMap () {
		if (hasRequiredSourceMap) return sourceMap;
		hasRequiredSourceMap = 1;
		sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
		sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
		sourceMap.SourceNode = requireSourceNode().SourceNode;
		return sourceMap;
	}

	/* global define, require */

	(function (module, exports) {

		exports.__esModule = true;

		var _utils = utils;

		var SourceNode = undefined;

		try {
		  /* istanbul ignore next */
		  if (typeof undefined !== 'function' || !undefined.amd) {
		    // We don't support this in AMD environments. For these environments, we assume that
		    // they are running on the browser and thus have no need for the source-map library.
		    var SourceMap = requireSourceMap();
		    SourceNode = SourceMap.SourceNode;
		  }
		} catch (err) {}
		/* NOP */

		/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
		if (!SourceNode) {
		  SourceNode = function (line, column, srcFile, chunks) {
		    this.src = '';
		    if (chunks) {
		      this.add(chunks);
		    }
		  };
		  /* istanbul ignore next */
		  SourceNode.prototype = {
		    add: function add(chunks) {
		      if (_utils.isArray(chunks)) {
		        chunks = chunks.join('');
		      }
		      this.src += chunks;
		    },
		    prepend: function prepend(chunks) {
		      if (_utils.isArray(chunks)) {
		        chunks = chunks.join('');
		      }
		      this.src = chunks + this.src;
		    },
		    toStringWithSourceMap: function toStringWithSourceMap() {
		      return { code: this.toString() };
		    },
		    toString: function toString() {
		      return this.src;
		    }
		  };
		}

		function castChunk(chunk, codeGen, loc) {
		  if (_utils.isArray(chunk)) {
		    var ret = [];

		    for (var i = 0, len = chunk.length; i < len; i++) {
		      ret.push(codeGen.wrap(chunk[i], loc));
		    }
		    return ret;
		  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
		    // Handle primitives that the SourceNode will throw up on
		    return chunk + '';
		  }
		  return chunk;
		}

		function CodeGen(srcFile) {
		  this.srcFile = srcFile;
		  this.source = [];
		}

		CodeGen.prototype = {
		  isEmpty: function isEmpty() {
		    return !this.source.length;
		  },
		  prepend: function prepend(source, loc) {
		    this.source.unshift(this.wrap(source, loc));
		  },
		  push: function push(source, loc) {
		    this.source.push(this.wrap(source, loc));
		  },

		  merge: function merge() {
		    var source = this.empty();
		    this.each(function (line) {
		      source.add(['  ', line, '\n']);
		    });
		    return source;
		  },

		  each: function each(iter) {
		    for (var i = 0, len = this.source.length; i < len; i++) {
		      iter(this.source[i]);
		    }
		  },

		  empty: function empty() {
		    var loc = this.currentLocation || { start: {} };
		    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
		  },
		  wrap: function wrap(chunk) {
		    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

		    if (chunk instanceof SourceNode) {
		      return chunk;
		    }

		    chunk = castChunk(chunk, this, loc);

		    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
		  },

		  functionCall: function functionCall(fn, type, params) {
		    params = this.generateList(params);
		    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
		  },

		  quotedString: function quotedString(str) {
		    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
		    .replace(/\u2029/g, '\\u2029') + '"';
		  },

		  objectLiteral: function objectLiteral(obj) {
		    // istanbul ignore next

		    var _this = this;

		    var pairs = [];

		    Object.keys(obj).forEach(function (key) {
		      var value = castChunk(obj[key], _this);
		      if (value !== 'undefined') {
		        pairs.push([_this.quotedString(key), ':', value]);
		      }
		    });

		    var ret = this.generateList(pairs);
		    ret.prepend('{');
		    ret.add('}');
		    return ret;
		  },

		  generateList: function generateList(entries) {
		    var ret = this.empty();

		    for (var i = 0, len = entries.length; i < len; i++) {
		      if (i) {
		        ret.add(',');
		      }

		      ret.add(castChunk(entries[i], this));
		    }

		    return ret;
		  },

		  generateArray: function generateArray(entries) {
		    var ret = this.generateList(entries);
		    ret.prepend('[');
		    ret.add(']');

		    return ret;
		  }
		};

		exports['default'] = CodeGen;
		module.exports = exports['default'];
		
	} (codeGen, codeGen.exports));

	var codeGenExports = codeGen.exports;

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _base = base$1;

		var _exception = exceptionExports;

		var _exception2 = _interopRequireDefault(_exception);

		var _utils = utils;

		var _codeGen = codeGenExports;

		var _codeGen2 = _interopRequireDefault(_codeGen);

		function Literal(value) {
		  this.value = value;
		}

		function JavaScriptCompiler() {}

		JavaScriptCompiler.prototype = {
		  // PUBLIC API: You can override these methods in a subclass to provide
		  // alternative compiled forms for name lookup and buffering semantics
		  nameLookup: function nameLookup(parent, name /*,  type */) {
		    return this.internalNameLookup(parent, name);
		  },
		  depthedLookup: function depthedLookup(name) {
		    return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];
		  },

		  compilerInfo: function compilerInfo() {
		    var revision = _base.COMPILER_REVISION,
		        versions = _base.REVISION_CHANGES[revision];
		    return [revision, versions];
		  },

		  appendToBuffer: function appendToBuffer(source, location, explicit) {
		    // Force a source as this simplifies the merge logic.
		    if (!_utils.isArray(source)) {
		      source = [source];
		    }
		    source = this.source.wrap(source, location);

		    if (this.environment.isSimple) {
		      return ['return ', source, ';'];
		    } else if (explicit) {
		      // This is a case where the buffer operation occurs as a child of another
		      // construct, generally braces. We have to explicitly output these buffer
		      // operations to ensure that the emitted code goes in the correct location.
		      return ['buffer += ', source, ';'];
		    } else {
		      source.appendToBuffer = true;
		      return source;
		    }
		  },

		  initializeBuffer: function initializeBuffer() {
		    return this.quotedString('');
		  },
		  // END PUBLIC API
		  internalNameLookup: function internalNameLookup(parent, name) {
		    this.lookupPropertyFunctionIsUsed = true;
		    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];
		  },

		  lookupPropertyFunctionIsUsed: false,

		  compile: function compile(environment, options, context, asObject) {
		    this.environment = environment;
		    this.options = options;
		    this.stringParams = this.options.stringParams;
		    this.trackIds = this.options.trackIds;
		    this.precompile = !asObject;

		    this.name = this.environment.name;
		    this.isChild = !!context;
		    this.context = context || {
		      decorators: [],
		      programs: [],
		      environments: []
		    };

		    this.preamble();

		    this.stackSlot = 0;
		    this.stackVars = [];
		    this.aliases = {};
		    this.registers = { list: [] };
		    this.hashes = [];
		    this.compileStack = [];
		    this.inlineStack = [];
		    this.blockParams = [];

		    this.compileChildren(environment, options);

		    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
		    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

		    var opcodes = environment.opcodes,
		        opcode = undefined,
		        firstLoc = undefined,
		        i = undefined,
		        l = undefined;

		    for (i = 0, l = opcodes.length; i < l; i++) {
		      opcode = opcodes[i];

		      this.source.currentLocation = opcode.loc;
		      firstLoc = firstLoc || opcode.loc;
		      this[opcode.opcode].apply(this, opcode.args);
		    }

		    // Flush any trailing content that might be pending.
		    this.source.currentLocation = firstLoc;
		    this.pushSource('');

		    /* istanbul ignore next */
		    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
		      throw new _exception2['default']('Compile completed with content left on stack');
		    }

		    if (!this.decorators.isEmpty()) {
		      this.useDecorators = true;

		      this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\n']);
		      this.decorators.push('return fn;');

		      if (asObject) {
		        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
		      } else {
		        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
		        this.decorators.push('}\n');
		        this.decorators = this.decorators.merge();
		      }
		    } else {
		      this.decorators = undefined;
		    }

		    var fn = this.createFunctionContext(asObject);
		    if (!this.isChild) {
		      var ret = {
		        compiler: this.compilerInfo(),
		        main: fn
		      };

		      if (this.decorators) {
		        ret.main_d = this.decorators; // eslint-disable-line camelcase
		        ret.useDecorators = true;
		      }

		      var _context = this.context;
		      var programs = _context.programs;
		      var decorators = _context.decorators;

		      for (i = 0, l = programs.length; i < l; i++) {
		        if (programs[i]) {
		          ret[i] = programs[i];
		          if (decorators[i]) {
		            ret[i + '_d'] = decorators[i];
		            ret.useDecorators = true;
		          }
		        }
		      }

		      if (this.environment.usePartial) {
		        ret.usePartial = true;
		      }
		      if (this.options.data) {
		        ret.useData = true;
		      }
		      if (this.useDepths) {
		        ret.useDepths = true;
		      }
		      if (this.useBlockParams) {
		        ret.useBlockParams = true;
		      }
		      if (this.options.compat) {
		        ret.compat = true;
		      }

		      if (!asObject) {
		        ret.compiler = JSON.stringify(ret.compiler);

		        this.source.currentLocation = { start: { line: 1, column: 0 } };
		        ret = this.objectLiteral(ret);

		        if (options.srcName) {
		          ret = ret.toStringWithSourceMap({ file: options.destName });
		          ret.map = ret.map && ret.map.toString();
		        } else {
		          ret = ret.toString();
		        }
		      } else {
		        ret.compilerOptions = this.options;
		      }

		      return ret;
		    } else {
		      return fn;
		    }
		  },

		  preamble: function preamble() {
		    // track the last context pushed into place to allow skipping the
		    // getContext opcode when it would be a noop
		    this.lastContext = 0;
		    this.source = new _codeGen2['default'](this.options.srcName);
		    this.decorators = new _codeGen2['default'](this.options.srcName);
		  },

		  createFunctionContext: function createFunctionContext(asObject) {
		    // istanbul ignore next

		    var _this = this;

		    var varDeclarations = '';

		    var locals = this.stackVars.concat(this.registers.list);
		    if (locals.length > 0) {
		      varDeclarations += ', ' + locals.join(', ');
		    }

		    // Generate minimizer alias mappings
		    //
		    // When using true SourceNodes, this will update all references to the given alias
		    // as the source nodes are reused in situ. For the non-source node compilation mode,
		    // aliases will not be used, but this case is already being run on the client and
		    // we aren't concern about minimizing the template size.
		    var aliasCount = 0;
		    Object.keys(this.aliases).forEach(function (alias) {
		      var node = _this.aliases[alias];
		      if (node.children && node.referenceCount > 1) {
		        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
		        node.children[0] = 'alias' + aliasCount;
		      }
		    });

		    if (this.lookupPropertyFunctionIsUsed) {
		      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();
		    }

		    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

		    if (this.useBlockParams || this.useDepths) {
		      params.push('blockParams');
		    }
		    if (this.useDepths) {
		      params.push('depths');
		    }

		    // Perform a second pass over the output to merge content when possible
		    var source = this.mergeSource(varDeclarations);

		    if (asObject) {
		      params.push(source);

		      return Function.apply(this, params);
		    } else {
		      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
		    }
		  },
		  mergeSource: function mergeSource(varDeclarations) {
		    var isSimple = this.environment.isSimple,
		        appendOnly = !this.forceBuffer,
		        appendFirst = undefined,
		        sourceSeen = undefined,
		        bufferStart = undefined,
		        bufferEnd = undefined;
		    this.source.each(function (line) {
		      if (line.appendToBuffer) {
		        if (bufferStart) {
		          line.prepend('  + ');
		        } else {
		          bufferStart = line;
		        }
		        bufferEnd = line;
		      } else {
		        if (bufferStart) {
		          if (!sourceSeen) {
		            appendFirst = true;
		          } else {
		            bufferStart.prepend('buffer += ');
		          }
		          bufferEnd.add(';');
		          bufferStart = bufferEnd = undefined;
		        }

		        sourceSeen = true;
		        if (!isSimple) {
		          appendOnly = false;
		        }
		      }
		    });

		    if (appendOnly) {
		      if (bufferStart) {
		        bufferStart.prepend('return ');
		        bufferEnd.add(';');
		      } else if (!sourceSeen) {
		        this.source.push('return "";');
		      }
		    } else {
		      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

		      if (bufferStart) {
		        bufferStart.prepend('return buffer + ');
		        bufferEnd.add(';');
		      } else {
		        this.source.push('return buffer;');
		      }
		    }

		    if (varDeclarations) {
		      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
		    }

		    return this.source.merge();
		  },

		  lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
		    return '\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    '.trim();
		  },

		  // [blockValue]
		  //
		  // On stack, before: hash, inverse, program, value
		  // On stack, after: return value of blockHelperMissing
		  //
		  // The purpose of this opcode is to take a block of the form
		  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
		  // replace it on the stack with the result of properly
		  // invoking blockHelperMissing.
		  blockValue: function blockValue(name) {
		    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
		        params = [this.contextName(0)];
		    this.setupHelperArgs(name, 0, params);

		    var blockName = this.popStack();
		    params.splice(1, 0, blockName);

		    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
		  },

		  // [ambiguousBlockValue]
		  //
		  // On stack, before: hash, inverse, program, value
		  // Compiler value, before: lastHelper=value of last found helper, if any
		  // On stack, after, if no lastHelper: same as [blockValue]
		  // On stack, after, if lastHelper: value
		  ambiguousBlockValue: function ambiguousBlockValue() {
		    // We're being a bit cheeky and reusing the options value from the prior exec
		    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
		        params = [this.contextName(0)];
		    this.setupHelperArgs('', 0, params, true);

		    this.flushInline();

		    var current = this.topStack();
		    params.splice(1, 0, current);

		    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
		  },

		  // [appendContent]
		  //
		  // On stack, before: ...
		  // On stack, after: ...
		  //
		  // Appends the string value of `content` to the current buffer
		  appendContent: function appendContent(content) {
		    if (this.pendingContent) {
		      content = this.pendingContent + content;
		    } else {
		      this.pendingLocation = this.source.currentLocation;
		    }

		    this.pendingContent = content;
		  },

		  // [append]
		  //
		  // On stack, before: value, ...
		  // On stack, after: ...
		  //
		  // Coerces `value` to a String and appends it to the current buffer.
		  //
		  // If `value` is truthy, or 0, it is coerced into a string and appended
		  // Otherwise, the empty string is appended
		  append: function append() {
		    if (this.isInline()) {
		      this.replaceStack(function (current) {
		        return [' != null ? ', current, ' : ""'];
		      });

		      this.pushSource(this.appendToBuffer(this.popStack()));
		    } else {
		      var local = this.popStack();
		      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
		      if (this.environment.isSimple) {
		        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
		      }
		    }
		  },

		  // [appendEscaped]
		  //
		  // On stack, before: value, ...
		  // On stack, after: ...
		  //
		  // Escape `value` and append it to the buffer
		  appendEscaped: function appendEscaped() {
		    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
		  },

		  // [getContext]
		  //
		  // On stack, before: ...
		  // On stack, after: ...
		  // Compiler value, after: lastContext=depth
		  //
		  // Set the value of the `lastContext` compiler value to the depth
		  getContext: function getContext(depth) {
		    this.lastContext = depth;
		  },

		  // [pushContext]
		  //
		  // On stack, before: ...
		  // On stack, after: currentContext, ...
		  //
		  // Pushes the value of the current context onto the stack.
		  pushContext: function pushContext() {
		    this.pushStackLiteral(this.contextName(this.lastContext));
		  },

		  // [lookupOnContext]
		  //
		  // On stack, before: ...
		  // On stack, after: currentContext[name], ...
		  //
		  // Looks up the value of `name` on the current context and pushes
		  // it onto the stack.
		  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
		    var i = 0;

		    if (!scoped && this.options.compat && !this.lastContext) {
		      // The depthed query is expected to handle the undefined logic for the root level that
		      // is implemented below, so we evaluate that directly in compat mode
		      this.push(this.depthedLookup(parts[i++]));
		    } else {
		      this.pushContext();
		    }

		    this.resolvePath('context', parts, i, falsy, strict);
		  },

		  // [lookupBlockParam]
		  //
		  // On stack, before: ...
		  // On stack, after: blockParam[name], ...
		  //
		  // Looks up the value of `parts` on the given block param and pushes
		  // it onto the stack.
		  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
		    this.useBlockParams = true;

		    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
		    this.resolvePath('context', parts, 1);
		  },

		  // [lookupData]
		  //
		  // On stack, before: ...
		  // On stack, after: data, ...
		  //
		  // Push the data lookup operator
		  lookupData: function lookupData(depth, parts, strict) {
		    if (!depth) {
		      this.pushStackLiteral('data');
		    } else {
		      this.pushStackLiteral('container.data(data, ' + depth + ')');
		    }

		    this.resolvePath('data', parts, 0, true, strict);
		  },

		  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
		    // istanbul ignore next

		    var _this2 = this;

		    if (this.options.strict || this.options.assumeObjects) {
		      this.push(strictLookup(this.options.strict && strict, this, parts, i, type));
		      return;
		    }

		    var len = parts.length;
		    for (; i < len; i++) {
		      /* eslint-disable no-loop-func */
		      this.replaceStack(function (current) {
		        var lookup = _this2.nameLookup(current, parts[i], type);
		        // We want to ensure that zero and false are handled properly if the context (falsy flag)
		        // needs to have the special handling for these values.
		        if (!falsy) {
		          return [' != null ? ', lookup, ' : ', current];
		        } else {
		          // Otherwise we can use generic falsy handling
		          return [' && ', lookup];
		        }
		      });
		      /* eslint-enable no-loop-func */
		    }
		  },

		  // [resolvePossibleLambda]
		  //
		  // On stack, before: value, ...
		  // On stack, after: resolved value, ...
		  //
		  // If the `value` is a lambda, replace it on the stack by
		  // the return value of the lambda
		  resolvePossibleLambda: function resolvePossibleLambda() {
		    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
		  },

		  // [pushStringParam]
		  //
		  // On stack, before: ...
		  // On stack, after: string, currentContext, ...
		  //
		  // This opcode is designed for use in string mode, which
		  // provides the string value of a parameter along with its
		  // depth rather than resolving it immediately.
		  pushStringParam: function pushStringParam(string, type) {
		    this.pushContext();
		    this.pushString(type);

		    // If it's a subexpression, the string result
		    // will be pushed after this opcode.
		    if (type !== 'SubExpression') {
		      if (typeof string === 'string') {
		        this.pushString(string);
		      } else {
		        this.pushStackLiteral(string);
		      }
		    }
		  },

		  emptyHash: function emptyHash(omitEmpty) {
		    if (this.trackIds) {
		      this.push('{}'); // hashIds
		    }
		    if (this.stringParams) {
		      this.push('{}'); // hashContexts
		      this.push('{}'); // hashTypes
		    }
		    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
		  },
		  pushHash: function pushHash() {
		    if (this.hash) {
		      this.hashes.push(this.hash);
		    }
		    this.hash = { values: {}, types: [], contexts: [], ids: [] };
		  },
		  popHash: function popHash() {
		    var hash = this.hash;
		    this.hash = this.hashes.pop();

		    if (this.trackIds) {
		      this.push(this.objectLiteral(hash.ids));
		    }
		    if (this.stringParams) {
		      this.push(this.objectLiteral(hash.contexts));
		      this.push(this.objectLiteral(hash.types));
		    }

		    this.push(this.objectLiteral(hash.values));
		  },

		  // [pushString]
		  //
		  // On stack, before: ...
		  // On stack, after: quotedString(string), ...
		  //
		  // Push a quoted version of `string` onto the stack
		  pushString: function pushString(string) {
		    this.pushStackLiteral(this.quotedString(string));
		  },

		  // [pushLiteral]
		  //
		  // On stack, before: ...
		  // On stack, after: value, ...
		  //
		  // Pushes a value onto the stack. This operation prevents
		  // the compiler from creating a temporary variable to hold
		  // it.
		  pushLiteral: function pushLiteral(value) {
		    this.pushStackLiteral(value);
		  },

		  // [pushProgram]
		  //
		  // On stack, before: ...
		  // On stack, after: program(guid), ...
		  //
		  // Push a program expression onto the stack. This takes
		  // a compile-time guid and converts it into a runtime-accessible
		  // expression.
		  pushProgram: function pushProgram(guid) {
		    if (guid != null) {
		      this.pushStackLiteral(this.programExpression(guid));
		    } else {
		      this.pushStackLiteral(null);
		    }
		  },

		  // [registerDecorator]
		  //
		  // On stack, before: hash, program, params..., ...
		  // On stack, after: ...
		  //
		  // Pops off the decorator's parameters, invokes the decorator,
		  // and inserts the decorator into the decorators list.
		  registerDecorator: function registerDecorator(paramSize, name) {
		    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
		        options = this.setupHelperArgs(name, paramSize);

		    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
		  },

		  // [invokeHelper]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of helper invocation
		  //
		  // Pops off the helper's parameters, invokes the helper,
		  // and pushes the helper's return value onto the stack.
		  //
		  // If the helper is not found, `helperMissing` is called.
		  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
		    var nonHelper = this.popStack(),
		        helper = this.setupHelper(paramSize, name);

		    var possibleFunctionCalls = [];

		    if (isSimple) {
		      // direct call to helper
		      possibleFunctionCalls.push(helper.name);
		    }
		    // call a function from the input object
		    possibleFunctionCalls.push(nonHelper);
		    if (!this.options.strict) {
		      possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));
		    }

		    var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];
		    var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);
		    this.push(functionCall);
		  },

		  itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
		    var result = [];
		    result.push(items[0]);
		    for (var i = 1; i < items.length; i++) {
		      result.push(separator, items[i]);
		    }
		    return result;
		  },
		  // [invokeKnownHelper]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of helper invocation
		  //
		  // This operation is used when the helper is known to exist,
		  // so a `helperMissing` fallback is not required.
		  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
		    var helper = this.setupHelper(paramSize, name);
		    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
		  },

		  // [invokeAmbiguous]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of disambiguation
		  //
		  // This operation is used when an expression like `{{foo}}`
		  // is provided, but we don't know at compile-time whether it
		  // is a helper or a path.
		  //
		  // This operation emits more code than the other options,
		  // and can be avoided by passing the `knownHelpers` and
		  // `knownHelpersOnly` flags at compile-time.
		  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
		    this.useRegister('helper');

		    var nonHelper = this.popStack();

		    this.emptyHash();
		    var helper = this.setupHelper(0, name, helperCall);

		    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

		    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
		    if (!this.options.strict) {
		      lookup[0] = '(helper = ';
		      lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));
		    }

		    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
		  },

		  // [invokePartial]
		  //
		  // On stack, before: context, ...
		  // On stack after: result of partial invocation
		  //
		  // This operation pops off a context, invokes a partial with that context,
		  // and pushes the result of the invocation back.
		  invokePartial: function invokePartial(isDynamic, name, indent) {
		    var params = [],
		        options = this.setupParams(name, 1, params);

		    if (isDynamic) {
		      name = this.popStack();
		      delete options.name;
		    }

		    if (indent) {
		      options.indent = JSON.stringify(indent);
		    }
		    options.helpers = 'helpers';
		    options.partials = 'partials';
		    options.decorators = 'container.decorators';

		    if (!isDynamic) {
		      params.unshift(this.nameLookup('partials', name, 'partial'));
		    } else {
		      params.unshift(name);
		    }

		    if (this.options.compat) {
		      options.depths = 'depths';
		    }
		    options = this.objectLiteral(options);
		    params.push(options);

		    this.push(this.source.functionCall('container.invokePartial', '', params));
		  },

		  // [assignToHash]
		  //
		  // On stack, before: value, ..., hash, ...
		  // On stack, after: ..., hash, ...
		  //
		  // Pops a value off the stack and assigns it to the current hash
		  assignToHash: function assignToHash(key) {
		    var value = this.popStack(),
		        context = undefined,
		        type = undefined,
		        id = undefined;

		    if (this.trackIds) {
		      id = this.popStack();
		    }
		    if (this.stringParams) {
		      type = this.popStack();
		      context = this.popStack();
		    }

		    var hash = this.hash;
		    if (context) {
		      hash.contexts[key] = context;
		    }
		    if (type) {
		      hash.types[key] = type;
		    }
		    if (id) {
		      hash.ids[key] = id;
		    }
		    hash.values[key] = value;
		  },

		  pushId: function pushId(type, name, child) {
		    if (type === 'BlockParam') {
		      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
		    } else if (type === 'PathExpression') {
		      this.pushString(name);
		    } else if (type === 'SubExpression') {
		      this.pushStackLiteral('true');
		    } else {
		      this.pushStackLiteral('null');
		    }
		  },

		  // HELPERS

		  compiler: JavaScriptCompiler,

		  compileChildren: function compileChildren(environment, options) {
		    var children = environment.children,
		        child = undefined,
		        compiler = undefined;

		    for (var i = 0, l = children.length; i < l; i++) {
		      child = children[i];
		      compiler = new this.compiler(); // eslint-disable-line new-cap

		      var existing = this.matchExistingProgram(child);

		      if (existing == null) {
		        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
		        var index = this.context.programs.length;
		        child.index = index;
		        child.name = 'program' + index;
		        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
		        this.context.decorators[index] = compiler.decorators;
		        this.context.environments[index] = child;

		        this.useDepths = this.useDepths || compiler.useDepths;
		        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
		        child.useDepths = this.useDepths;
		        child.useBlockParams = this.useBlockParams;
		      } else {
		        child.index = existing.index;
		        child.name = 'program' + existing.index;

		        this.useDepths = this.useDepths || existing.useDepths;
		        this.useBlockParams = this.useBlockParams || existing.useBlockParams;
		      }
		    }
		  },
		  matchExistingProgram: function matchExistingProgram(child) {
		    for (var i = 0, len = this.context.environments.length; i < len; i++) {
		      var environment = this.context.environments[i];
		      if (environment && environment.equals(child)) {
		        return environment;
		      }
		    }
		  },

		  programExpression: function programExpression(guid) {
		    var child = this.environment.children[guid],
		        programParams = [child.index, 'data', child.blockParams];

		    if (this.useBlockParams || this.useDepths) {
		      programParams.push('blockParams');
		    }
		    if (this.useDepths) {
		      programParams.push('depths');
		    }

		    return 'container.program(' + programParams.join(', ') + ')';
		  },

		  useRegister: function useRegister(name) {
		    if (!this.registers[name]) {
		      this.registers[name] = true;
		      this.registers.list.push(name);
		    }
		  },

		  push: function push(expr) {
		    if (!(expr instanceof Literal)) {
		      expr = this.source.wrap(expr);
		    }

		    this.inlineStack.push(expr);
		    return expr;
		  },

		  pushStackLiteral: function pushStackLiteral(item) {
		    this.push(new Literal(item));
		  },

		  pushSource: function pushSource(source) {
		    if (this.pendingContent) {
		      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
		      this.pendingContent = undefined;
		    }

		    if (source) {
		      this.source.push(source);
		    }
		  },

		  replaceStack: function replaceStack(callback) {
		    var prefix = ['('],
		        stack = undefined,
		        createdStack = undefined,
		        usedLiteral = undefined;

		    /* istanbul ignore next */
		    if (!this.isInline()) {
		      throw new _exception2['default']('replaceStack on non-inline');
		    }

		    // We want to merge the inline statement into the replacement statement via ','
		    var top = this.popStack(true);

		    if (top instanceof Literal) {
		      // Literals do not need to be inlined
		      stack = [top.value];
		      prefix = ['(', stack];
		      usedLiteral = true;
		    } else {
		      // Get or create the current stack name for use by the inline
		      createdStack = true;
		      var _name = this.incrStack();

		      prefix = ['((', this.push(_name), ' = ', top, ')'];
		      stack = this.topStack();
		    }

		    var item = callback.call(this, stack);

		    if (!usedLiteral) {
		      this.popStack();
		    }
		    if (createdStack) {
		      this.stackSlot--;
		    }
		    this.push(prefix.concat(item, ')'));
		  },

		  incrStack: function incrStack() {
		    this.stackSlot++;
		    if (this.stackSlot > this.stackVars.length) {
		      this.stackVars.push('stack' + this.stackSlot);
		    }
		    return this.topStackName();
		  },
		  topStackName: function topStackName() {
		    return 'stack' + this.stackSlot;
		  },
		  flushInline: function flushInline() {
		    var inlineStack = this.inlineStack;
		    this.inlineStack = [];
		    for (var i = 0, len = inlineStack.length; i < len; i++) {
		      var entry = inlineStack[i];
		      /* istanbul ignore if */
		      if (entry instanceof Literal) {
		        this.compileStack.push(entry);
		      } else {
		        var stack = this.incrStack();
		        this.pushSource([stack, ' = ', entry, ';']);
		        this.compileStack.push(stack);
		      }
		    }
		  },
		  isInline: function isInline() {
		    return this.inlineStack.length;
		  },

		  popStack: function popStack(wrapped) {
		    var inline = this.isInline(),
		        item = (inline ? this.inlineStack : this.compileStack).pop();

		    if (!wrapped && item instanceof Literal) {
		      return item.value;
		    } else {
		      if (!inline) {
		        /* istanbul ignore next */
		        if (!this.stackSlot) {
		          throw new _exception2['default']('Invalid stack pop');
		        }
		        this.stackSlot--;
		      }
		      return item;
		    }
		  },

		  topStack: function topStack() {
		    var stack = this.isInline() ? this.inlineStack : this.compileStack,
		        item = stack[stack.length - 1];

		    /* istanbul ignore if */
		    if (item instanceof Literal) {
		      return item.value;
		    } else {
		      return item;
		    }
		  },

		  contextName: function contextName(context) {
		    if (this.useDepths && context) {
		      return 'depths[' + context + ']';
		    } else {
		      return 'depth' + context;
		    }
		  },

		  quotedString: function quotedString(str) {
		    return this.source.quotedString(str);
		  },

		  objectLiteral: function objectLiteral(obj) {
		    return this.source.objectLiteral(obj);
		  },

		  aliasable: function aliasable(name) {
		    var ret = this.aliases[name];
		    if (ret) {
		      ret.referenceCount++;
		      return ret;
		    }

		    ret = this.aliases[name] = this.source.wrap(name);
		    ret.aliasable = true;
		    ret.referenceCount = 1;

		    return ret;
		  },

		  setupHelper: function setupHelper(paramSize, name, blockHelper) {
		    var params = [],
		        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
		    var foundHelper = this.nameLookup('helpers', name, 'helper'),
		        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

		    return {
		      params: params,
		      paramsInit: paramsInit,
		      name: foundHelper,
		      callParams: [callContext].concat(params)
		    };
		  },

		  setupParams: function setupParams(helper, paramSize, params) {
		    var options = {},
		        contexts = [],
		        types = [],
		        ids = [],
		        objectArgs = !params,
		        param = undefined;

		    if (objectArgs) {
		      params = [];
		    }

		    options.name = this.quotedString(helper);
		    options.hash = this.popStack();

		    if (this.trackIds) {
		      options.hashIds = this.popStack();
		    }
		    if (this.stringParams) {
		      options.hashTypes = this.popStack();
		      options.hashContexts = this.popStack();
		    }

		    var inverse = this.popStack(),
		        program = this.popStack();

		    // Avoid setting fn and inverse if neither are set. This allows
		    // helpers to do a check for `if (options.fn)`
		    if (program || inverse) {
		      options.fn = program || 'container.noop';
		      options.inverse = inverse || 'container.noop';
		    }

		    // The parameters go on to the stack in order (making sure that they are evaluated in order)
		    // so we need to pop them off the stack in reverse order
		    var i = paramSize;
		    while (i--) {
		      param = this.popStack();
		      params[i] = param;

		      if (this.trackIds) {
		        ids[i] = this.popStack();
		      }
		      if (this.stringParams) {
		        types[i] = this.popStack();
		        contexts[i] = this.popStack();
		      }
		    }

		    if (objectArgs) {
		      options.args = this.source.generateArray(params);
		    }

		    if (this.trackIds) {
		      options.ids = this.source.generateArray(ids);
		    }
		    if (this.stringParams) {
		      options.types = this.source.generateArray(types);
		      options.contexts = this.source.generateArray(contexts);
		    }

		    if (this.options.data) {
		      options.data = 'data';
		    }
		    if (this.useBlockParams) {
		      options.blockParams = 'blockParams';
		    }
		    return options;
		  },

		  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
		    var options = this.setupParams(helper, paramSize, params);
		    options.loc = JSON.stringify(this.source.currentLocation);
		    options = this.objectLiteral(options);
		    if (useRegister) {
		      this.useRegister('options');
		      params.push('options');
		      return ['options=', options];
		    } else if (params) {
		      params.push(options);
		      return '';
		    } else {
		      return options;
		    }
		  }
		};

		(function () {
		  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

		  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

		  for (var i = 0, l = reservedWords.length; i < l; i++) {
		    compilerWords[reservedWords[i]] = true;
		  }
		})();

		/**
		 * @deprecated May be removed in the next major version
		 */
		JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
		  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
		};

		function strictLookup(requireTerminal, compiler, parts, i, type) {
		  var stack = compiler.popStack(),
		      len = parts.length;
		  if (requireTerminal) {
		    len--;
		  }

		  for (; i < len; i++) {
		    stack = compiler.nameLookup(stack, parts[i], type);
		  }

		  if (requireTerminal) {
		    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];
		  } else {
		    return stack;
		  }
		}

		exports['default'] = JavaScriptCompiler;
		module.exports = exports['default'];
		
	} (javascriptCompiler, javascriptCompiler.exports));

	var javascriptCompilerExports = javascriptCompiler.exports;

	(function (module, exports) {

		exports.__esModule = true;
		// istanbul ignore next

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var _handlebarsRuntime = handlebars_runtimeExports;

		var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

		// Compiler imports

		var _handlebarsCompilerAst = astExports;

		var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

		var _handlebarsCompilerBase = base;

		var _handlebarsCompilerCompiler = compiler;

		var _handlebarsCompilerJavascriptCompiler = javascriptCompilerExports;

		var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

		var _handlebarsCompilerVisitor = visitorExports;

		var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

		var _handlebarsNoConflict = noConflictExports;

		var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

		var _create = _handlebarsRuntime2['default'].create;
		function create() {
		  var hb = _create();

		  hb.compile = function (input, options) {
		    return _handlebarsCompilerCompiler.compile(input, options, hb);
		  };
		  hb.precompile = function (input, options) {
		    return _handlebarsCompilerCompiler.precompile(input, options, hb);
		  };

		  hb.AST = _handlebarsCompilerAst2['default'];
		  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
		  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
		  hb.Parser = _handlebarsCompilerBase.parser;
		  hb.parse = _handlebarsCompilerBase.parse;
		  hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;

		  return hb;
		}

		var inst = create();
		inst.create = create;

		_handlebarsNoConflict2['default'](inst);

		inst.Visitor = _handlebarsCompilerVisitor2['default'];

		inst['default'] = inst;

		exports['default'] = inst;
		module.exports = exports['default'];
		
	} (handlebars$1, handlebars$1.exports));

	var handlebarsExports = handlebars$1.exports;
	var handlebars = /*@__PURE__*/getDefaultExportFromCjs(handlebarsExports);

	var ValueConvertMethods = {
	    evalExpression(s) {
	        if (typeof (s) !== 'string') {
	            return s;
	        }

	        return Compile$1(s)(this.memory);
	    },

	    renderString(s) {
	        if (typeof (s) !== 'string') {
	            return '';
	        }
	        return handlebars.render(s, this.memory);
	    },
	};

	var RunMethods = {
	    startGroup(groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        this.getTreeGroup(groupName).start();
	        return this;
	    },

	    start() {
	        var argumentsCount = arguments.length;
	        switch (argumentsCount) {
	            case 0:
	                // Run all event sheets in default group
	                this.getTreeGroup(this.defaultTreeGroupName).start();
	                break;

	            case 1:
	                // Start an event sheet by name (arg[0]), 
	                // in default group,
	                // will check condition
	                var name = arguments[0];
	                if (this.hasTreeGroup(name)) {
	                    this.getTreeGroup(name).start();
	                } else {
	                    this.getTreeGroup(this.defaultTreeGroupName).startTree(name);
	                }
	                break;

	            case 2:
	                // Start an event sheet by name (arg[0]),
	                // in a group by name (arg[1]), will check condition, or
	                // in default group, ignore condition checking (arg[1])
	                var title = arguments[0];
	                var ignoreCondition, groupName;
	                if (typeof (arguments[1]) === 'string') {
	                    ignoreCondition = true;
	                    groupName = arguments[1];
	                } else {
	                    ignoreCondition = arguments[1];
	                    groupName = this.defaultTreeGroupName;
	                }
	                this.getTreeGroup(groupName).startTree(title, ignoreCondition);
	                break;

	            default:
	                // Start an event sheet by name (arg[0]), 
	                // in a group by name (arg[1]), 
	                // can ignore condition checking (arg[2])
	                var title = arguments[0];
	                var groupName = arguments[1];
	                var ignoreCondition = arguments[2];
	                this.getTreeGroup(groupName).startTree(title, ignoreCondition);
	                break;
	        }
	        return this;
	    },

	    continue(groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        this.getTreeGroup(groupName).continue();
	        return this;
	    },
	};

	var StopMethods = {
	    stopGroup(groupName) {
	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }
	        this.getTreeGroup(groupName).stop();
	        return this;
	    },

	    stop(groupName) {
	        this.stopGroup(groupName);
	        return this;
	    },

	    stopAllGroups() {
	        for (var name in this.treeGroups) {
	            this.treeGroups[name].stop();
	        }
	        return this;
	    },

	    stopAll() {
	        this.stopAllGroups();
	        return this;
	    }
	};

	var BindEventMethods$1 = {
	    startGroupByEvent(eventName, groupName, once) {
	        if (IsPlainObject$B(eventName)) {
	            var config = eventName;
	            eventName = config.eventName;
	            groupName = config.groupName;
	            once = config.once;
	        }

	        if (once === undefined) {
	            once = false;
	        }
	        var callback = function () {
	            this.startGroup(groupName);
	        };

	        if (!once) {
	            this.on(eventName, callback, this);
	        } else {
	            this.once(eventName, callback, this);
	        }

	        return this;
	    },


	};

	var RoundCounterMethods = {
	    getRoundCounter() {
	        return this.blackboard.getCurrentTime();
	    },

	    setRoundCounter(value) {
	        this.blackboard.setCurrentTime(value);
	        return this;
	    },

	    updateRoundCounter(value) {
	        if (value === undefined) {
	            this.blackboard.incCurrentTime(1);
	        } else {
	            this.blackboard.setCurrentTime(value);
	        }

	        return this;
	    }
	};

	var Methods$f = {};

	Object.assign(
	    Methods$f,
	    PauseEventSheetMethods$1,
	    TreeMethods,
	    AddTreeMethods,
	    RemoveTreeMethods,
	    TreeActiveStateMethods,
	    SaveLoadTreesMethods,
	    DataMethods$4,
	    StateMethods,
	    ValueConvertMethods,
	    RunMethods,
	    StopMethods,
	    BindEventMethods$1,
	    RoundCounterMethods,
	);

	BehaviorTree.setStartIDValue(0);

	class EventSheetManager extends EventEmitter$2 {
	    constructor(scene, config) {
	        if (IsPlainObject$B(scene) && (config === undefined)) {
	            config = scene;
	            scene = undefined;
	        }

	        if (config === undefined) {
	            config = {};
	        }

	        super();

	        this.isShutdown = false;
	        this.scene = scene;

	        var {
	            commandExecutor,
	            parallel = false,
	        } = config;

	        this.defaultTreeGroupName = '_';

	        this.setCommandExecutor(commandExecutor);
	        this.parallel = parallel;

	        this.blackboard = new Blackboard({
	            currentTimeKey: '$roundCounter'
	        });
	        this.blackboard.eventSheetManager = this; // For TaskAction

	        this.treeGroups = {};

	        this.setRoundCounter(0);

	        this.boot();
	    }

	    boot() {
	    }

	    shutdown(fromScene) {
	        if (this.isShutdown) {
	            return;
	        }

	        if (this.commandExecutor && this.commandExecutor.destroy) {
	            this.commandExecutor.destroy(fromScene);
	        }

	        for (var name in this.treeGroups) {
	            this.treeGroups[name].destroy();
	        }

	        this.blackboard.destroy();

	        super.shutdown();

	        this.scene = undefined;
	        this.commandExecutor = undefined;
	        this.blackboard = undefined;
	        this.isShutdown = true;

	        return this;
	    }

	    destroy(fromScene) {
	        if (this.isShutdown) {
	            return;
	        }
	        this.emit('destroy', this, fromScene);
	        this.shutdown(fromScene);
	    }


	    get memory() {
	        return this.blackboard.getGlobalMemory();
	    }

	    get $roundCounter() {
	        return this.getRoundCounter();
	    }

	    set $roundCounter(value) {
	        this.setRoundCounter(value);
	    }

	    setCommandExecutor(commandExecutor) {
	        this.commandExecutor = commandExecutor;
	        return this;
	    }

	}

	Object.assign(
	    EventSheetManager.prototype,
	    Methods$f
	);

	const RoundIdle = 0;
	const RoundRun = 1;
	const RoundComplete = 2;

	const PropertyTable = {
	    'groupName': { defaultValue: '_', rewritable: true },
	    'parallel': { defaultValue: false, rewritable: true },
	    'active': { defaultValue: true, rewritable: true },
	    'once': { defaultValue: false, rewritable: true },
	    'roundState': { defaultValue: RoundIdle, rewritable: false },
	    'conditionPassed': { defaultValue: undefined, rewritable: false },
	};

	class EventSheet extends BehaviorTree {
	    constructor(eventSheetManager, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var { condition = true } = config;
	        delete config.condition;

	        var properties = config.properties;
	        delete config.properties;

	        super(config);

	        // Store default properties
	        for (var propertyKey in PropertyTable) {
	            var { defaultValue, rewritable } = PropertyTable[propertyKey];

	            this.wrapProperty(propertyKey);

	            if (rewritable) {
	                if (propertyKey in properties) {
	                    this[propertyKey] = properties[propertyKey];
	                    delete properties[propertyKey];
	                } else {
	                    this[propertyKey] = defaultValue;
	                }
	            } else {
	                this[propertyKey] = defaultValue;
	            }

	        }

	        // Store custom properties
	        for (var propertyKey in properties) {
	            this.wrapProperty(propertyKey);
	            this[propertyKey] = properties[propertyKey];
	        }

	        // Store references
	        var groupName = this.groupName;
	        this.eventSheetManager = eventSheetManager;
	        this.blackboard = eventSheetManager.blackboard;
	        this.setTreeGroup(groupName);

	        var root = new IfSelector({
	            title: this.title,
	            expression: condition,
	            conditionEvalBreak: true   // Return RUNNING instead of SUCCESS for condition eval
	        });
	        this.setRoot(root);
	    }

	    wrapProperty(key) {
	        var treeProperties = this.properties;
	        Object.defineProperty(this, key, {
	            get() {
	                return treeProperties[key];
	            },
	            set(newValue) {
	                treeProperties[key] = newValue;
	            },
	            enumerable: true,
	            configurable: true,
	        });

	        return this;
	    }

	    setTreeGroup(groupName) {
	        this.groupName = groupName;
	        this.eventSheetGroup = this.eventSheetManager.getTreeGroup(groupName);
	        return this;
	    }

	    setActive(active) {
	        if (active === undefined) {
	            active = true;
	        }
	        this.active = active;
	        return this;
	    }

	    get roundComplete() {
	        return this.roundState === RoundComplete;
	    }

	    set roundComplete(value) {
	        this.roundState = (value) ? RoundComplete : RoundRun;
	    }

	    setConditionEnable(enable = true) {
	        var selectChildIndex = (enable) ? undefined : 0;
	        this.root.setSelectChildIndex(selectChildIndex);
	        return this;
	    }

	    start(blackboard, target) {
	        if (this.roundState === RoundRun) {
	            return false;
	        }

	        var startFromTop = (this.getState(blackboard) !== RUNNING$1);
	        if (startFromTop) {
	            this.resetState(blackboard);
	        }

	        this.roundState = RoundRun;

	        // First tick, condition-eval
	        super.tick(blackboard, target);

	        if (startFromTop) {
	            var nodeMemory = this.root.getNodeMemory(this.ticker);
	            this.conditionPassed = (nodeMemory.$runningChild === 0);
	        }

	        return true;
	    }

	    tick(blackboard, target) {
	        var state = super.tick(blackboard, target);

	        if (state !== RUNNING$1) {
	            // Will remove from pendingTrees
	            this.roundState = RoundComplete;

	            if (this.conditionPassed && this.properties.once) {
	                this.setActive(false);
	            }
	        }

	        return state;
	    }

	    abort(blackboard, target) {
	        this.roundState = RoundIdle;

	        super.abort(blackboard, target);
	    }
	}

	var marked_min = {exports: {}};

	/**
	 * marked v5.0.2 - a markdown parser
	 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/markedjs/marked
	 */

	(function (module, exports) {
		!function(e,t){t(exports);}(commonjsGlobal,function(r){function i(e,t){for(var u=0;u<t.length;u++){var n=t[u];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,function(e){e=function(e,t){if("object"!=typeof e||null===e)return e;var u=e[Symbol.toPrimitive];if(void 0===u)return ("string"===t?String:Number)(e);u=u.call(e,t||"default");if("object"!=typeof u)return u;throw new TypeError("@@toPrimitive must return a primitive value.")}(e,"string");return "symbol"==typeof e?e:String(e)}(n.key),n);}}function d(){return (d=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var u,n=arguments[t];for(u in n)Object.prototype.hasOwnProperty.call(n,u)&&(e[u]=n[u]);}return e}).apply(this,arguments)}function s(e,t){(null==t||t>e.length)&&(t=e.length);for(var u=0,n=new Array(t);u<t;u++)n[u]=e[u];return n}function D(e,t){var u,n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(n)return (n=n.call(e)).next.bind(n);if(Array.isArray(e)||(n=function(e,t){var u;if(e)return "string"==typeof e?s(e,t):"Map"===(u="Object"===(u=Object.prototype.toString.call(e).slice(8,-1))&&e.constructor?e.constructor.name:u)||"Set"===u?Array.from(e):"Arguments"===u||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u)?s(e,t):void 0}(e))||t&&e&&"number"==typeof e.length)return n&&(e=n),u=0,function(){return u>=e.length?{done:!0}:{done:!1,value:e[u++]}};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function e(){return {async:!1,baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,hooks:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}r.defaults=e();function u(e){return t[e]}var n=/[&<>"']/,a=new RegExp(n.source,"g"),o=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,l=new RegExp(o.source,"g"),t={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"};function A(e,t){if(t){if(n.test(e))return e.replace(a,u)}else if(o.test(e))return e.replace(l,u);return e}var c=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;function m(e){return e.replace(c,function(e,t){return "colon"===(t=t.toLowerCase())?":":"#"===t.charAt(0)?"x"===t.charAt(1)?String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring(1)):""})}var p=/(^|[^\[])\^/g;function h(u,e){u="string"==typeof u?u:u.source,e=e||"";var n={replace:function(e,t){return t=(t=t.source||t).replace(p,"$1"),u=u.replace(e,t),n},getRegex:function(){return new RegExp(u,e)}};return n}var j=/[^\w:]/g,Z=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;function f(e,t,u){if(e){try{n=decodeURIComponent(m(u)).replace(j,"").toLowerCase();}catch(e){return null}if(0===n.indexOf("javascript:")||0===n.indexOf("vbscript:")||0===n.indexOf("data:"))return null}var n;t&&!Z.test(u)&&(e=u,g[" "+(n=t)]||(O.test(n)?g[" "+n]=n+"/":g[" "+n]=C(n,"/",!0)),t=-1===(n=g[" "+n]).indexOf(":"),u="//"===e.substring(0,2)?t?e:n.replace(q,"$1")+e:"/"===e.charAt(0)?t?e:n.replace(P,"$1")+e:n+e);try{u=encodeURI(u).replace(/%25/g,"%");}catch(e){return null}return u}var g={},O=/^[^:]+:\/*[^/]*$/,q=/^([^:]+:)[\s\S]*$/,P=/^([^:]+:\/*[^/]*)[\s\S]*$/;var F={exec:function(){}};function k(e,t){var u=e.replace(/\|/g,function(e,t,u){for(var n=!1,r=t;0<=--r&&"\\"===u[r];)n=!n;return n?"|":" |"}).split(/ \|/),n=0;if(u[0].trim()||u.shift(),0<u.length&&!u[u.length-1].trim()&&u.pop(),u.length>t)u.splice(t);else for(;u.length<t;)u.push("");for(;n<u.length;n++)u[n]=u[n].trim().replace(/\\\|/g,"|");return u}function C(e,t,u){var n=e.length;if(0===n)return "";for(var r=0;r<n;){var i=e.charAt(n-r-1);if((i!==t||u)&&(i===t||!u))break;r++;}return e.slice(0,n-r)}function E(e,t){if(t<1)return "";for(var u="";1<t;)1&t&&(u+=e),t>>=1,e+=e;return u+e}function x(e,t,u,n){var r=t.href,t=t.title?A(t.title):null,i=e[1].replace(/\\([\[\]])/g,"$1");return "!"!==e[0].charAt(0)?(n.state.inLink=!0,e={type:"link",raw:u,href:r,title:t,text:i,tokens:n.inlineTokens(i)},n.state.inLink=!1,e):{type:"image",raw:u,href:r,title:t,text:A(i)}}var b=function(){function e(e){this.options=e||r.defaults;}var t=e.prototype;return t.space=function(e){e=this.rules.block.newline.exec(e);if(e&&0<e[0].length)return {type:"space",raw:e[0]}},t.code=function(e){var t,e=this.rules.block.code.exec(e);if(e)return t=e[0].replace(/^ {1,4}/gm,""),{type:"code",raw:e[0],codeBlockStyle:"indented",text:this.options.pedantic?t:C(t,"\n")}},t.fences=function(e){var t,u,n,r,e=this.rules.block.fences.exec(e);if(e)return t=e[0],u=t,n=e[3]||"",u=null===(u=t.match(/^(\s+)(?:```)/))?n:(r=u[1],n.split("\n").map(function(e){var t=e.match(/^\s+/);return null!==t&&t[0].length>=r.length?e.slice(r.length):e}).join("\n")),{type:"code",raw:t,lang:e[2]&&e[2].trim().replace(this.rules.inline._escapes,"$1"),text:u}},t.heading=function(e){var t,u,e=this.rules.block.heading.exec(e);if(e)return t=e[2].trim(),/#$/.test(t)&&(u=C(t,"#"),!this.options.pedantic&&u&&!/ $/.test(u)||(t=u.trim())),{type:"heading",raw:e[0],depth:e[1].length,text:t,tokens:this.lexer.inline(t)}},t.hr=function(e){e=this.rules.block.hr.exec(e);if(e)return {type:"hr",raw:e[0]}},t.blockquote=function(e){var t,u,n,e=this.rules.block.blockquote.exec(e);if(e)return t=e[0].replace(/^ *>[ \t]?/gm,""),u=this.lexer.state.top,this.lexer.state.top=!0,n=this.lexer.blockTokens(t),this.lexer.state.top=u,{type:"blockquote",raw:e[0],tokens:n,text:t}},t.list=function(e){var t=this.rules.block.list.exec(e);if(t){var u,n,r,i,s,a,o,l,D,c,p,h=1<(g=t[1].trim()).length,f={type:"list",raw:"",ordered:h,start:h?+g.slice(0,-1):"",loose:!1,items:[]},g=h?"\\d{1,9}\\"+g.slice(-1):"\\"+g;this.options.pedantic&&(g=h?g:"[*+-]");for(var F=new RegExp("^( {0,3}"+g+")((?:[\t ][^\\n]*)?(?:\\n|$))");e&&(p=!1,t=F.exec(e))&&!this.rules.block.hr.test(e);){if(u=t[0],e=e.substring(u.length),o=t[2].split("\n",1)[0].replace(/^\t+/,function(e){return " ".repeat(3*e.length)}),l=e.split("\n",1)[0],this.options.pedantic?(i=2,c=o.trimLeft()):(i=t[2].search(/[^ ]/),c=o.slice(i=4<i?1:i),i+=t[1].length),s=!1,!o&&/^ *$/.test(l)&&(u+=l+"\n",e=e.substring(l.length+1),p=!0),!p)for(var d=new RegExp("^ {0,"+Math.min(3,i-1)+"}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))"),A=new RegExp("^ {0,"+Math.min(3,i-1)+"}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"),k=new RegExp("^ {0,"+Math.min(3,i-1)+"}(?:```|~~~)"),C=new RegExp("^ {0,"+Math.min(3,i-1)+"}#");e&&(l=D=e.split("\n",1)[0],this.options.pedantic&&(l=l.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!k.test(l))&&!C.test(l)&&!d.test(l)&&!A.test(e);){if(l.search(/[^ ]/)>=i||!l.trim())c+="\n"+l.slice(i);else {if(s)break;if(4<=o.search(/[^ ]/))break;if(k.test(o))break;if(C.test(o))break;if(A.test(o))break;c+="\n"+l;}s||l.trim()||(s=!0),u+=D+"\n",e=e.substring(D.length+1),o=l.slice(i);}f.loose||(a?f.loose=!0:/\n *\n *$/.test(u)&&(a=!0)),this.options.gfm&&(n=/^\[[ xX]\] /.exec(c))&&(r="[ ] "!==n[0],c=c.replace(/^\[[ xX]\] +/,"")),f.items.push({type:"list_item",raw:u,task:!!n,checked:r,loose:!1,text:c}),f.raw+=u;}f.items[f.items.length-1].raw=u.trimRight(),f.items[f.items.length-1].text=c.trimRight(),f.raw=f.raw.trimRight();for(var E,m=f.items.length,x=0;x<m;x++)this.lexer.state.top=!1,f.items[x].tokens=this.lexer.blockTokens(f.items[x].text,[]),f.loose||(E=0<(E=f.items[x].tokens.filter(function(e){return "space"===e.type})).length&&E.some(function(e){return /\n.*\n/.test(e.raw)}),f.loose=E);if(f.loose)for(x=0;x<m;x++)f.items[x].loose=!0;return f}},t.html=function(e){var t,e=this.rules.block.html.exec(e);if(e)return t={type:"html",block:!0,raw:e[0],pre:!this.options.sanitizer&&("pre"===e[1]||"script"===e[1]||"style"===e[1]),text:e[0]},this.options.sanitize&&(e=this.options.sanitizer?this.options.sanitizer(e[0]):A(e[0]),t.type="paragraph",t.text=e,t.tokens=this.lexer.inline(e)),t},t.def=function(e){var t,u,n,e=this.rules.block.def.exec(e);if(e)return t=e[1].toLowerCase().replace(/\s+/g," "),u=e[2]?e[2].replace(/^<(.*)>$/,"$1").replace(this.rules.inline._escapes,"$1"):"",n=e[3]&&e[3].substring(1,e[3].length-1).replace(this.rules.inline._escapes,"$1"),{type:"def",tag:t,raw:e[0],href:u,title:n}},t.table=function(e){e=this.rules.block.table.exec(e);if(e){var t={type:"table",header:k(e[1]).map(function(e){return {text:e}}),align:e[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:e[3]&&e[3].trim()?e[3].replace(/\n[ \t]*$/,"").split("\n"):[]};if(t.header.length===t.align.length){t.raw=e[0];for(var u,n,r,i=t.align.length,s=0;s<i;s++)/^ *-+: *$/.test(t.align[s])?t.align[s]="right":/^ *:-+: *$/.test(t.align[s])?t.align[s]="center":/^ *:-+ *$/.test(t.align[s])?t.align[s]="left":t.align[s]=null;for(i=t.rows.length,s=0;s<i;s++)t.rows[s]=k(t.rows[s],t.header.length).map(function(e){return {text:e}});for(i=t.header.length,u=0;u<i;u++)t.header[u].tokens=this.lexer.inline(t.header[u].text);for(i=t.rows.length,u=0;u<i;u++)for(r=t.rows[u],n=0;n<r.length;n++)r[n].tokens=this.lexer.inline(r[n].text);return t}}},t.lheading=function(e){e=this.rules.block.lheading.exec(e);if(e)return {type:"heading",raw:e[0],depth:"="===e[2].charAt(0)?1:2,text:e[1],tokens:this.lexer.inline(e[1])}},t.paragraph=function(e){var t,e=this.rules.block.paragraph.exec(e);if(e)return t="\n"===e[1].charAt(e[1].length-1)?e[1].slice(0,-1):e[1],{type:"paragraph",raw:e[0],text:t,tokens:this.lexer.inline(t)}},t.text=function(e){e=this.rules.block.text.exec(e);if(e)return {type:"text",raw:e[0],text:e[0],tokens:this.lexer.inline(e[0])}},t.escape=function(e){e=this.rules.inline.escape.exec(e);if(e)return {type:"escape",raw:e[0],text:A(e[1])}},t.tag=function(e){e=this.rules.inline.tag.exec(e);if(e)return !this.lexer.state.inLink&&/^<a /i.test(e[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(e[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(e[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:e[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:!1,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):A(e[0]):e[0]}},t.link=function(e){e=this.rules.inline.link.exec(e);if(e){var t=e[2].trim();if(!this.options.pedantic&&/^</.test(t)){if(!/>$/.test(t))return;var u=C(t.slice(0,-1),"\\");if((t.length-u.length)%2==0)return}else {u=function(e,t){if(-1!==e.indexOf(t[1]))for(var u=e.length,n=0,r=0;r<u;r++)if("\\"===e[r])r++;else if(e[r]===t[0])n++;else if(e[r]===t[1]&&--n<0)return r;return -1}(e[2],"()");-1<u&&(r=(0===e[0].indexOf("!")?5:4)+e[1].length+u,e[2]=e[2].substring(0,u),e[0]=e[0].substring(0,r).trim(),e[3]="");}var n,u=e[2],r="";return this.options.pedantic?(n=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(u))&&(u=n[1],r=n[3]):r=e[3]?e[3].slice(1,-1):"",u=u.trim(),x(e,{href:(u=/^</.test(u)?this.options.pedantic&&!/>$/.test(t)?u.slice(1):u.slice(1,-1):u)&&u.replace(this.rules.inline._escapes,"$1"),title:r&&r.replace(this.rules.inline._escapes,"$1")},e[0],this.lexer)}},t.reflink=function(e,t){var u;if(u=(u=this.rules.inline.reflink.exec(e))||this.rules.inline.nolink.exec(e))return (e=t[(e=(u[2]||u[1]).replace(/\s+/g," ")).toLowerCase()])?x(u,e,u[0],this.lexer):{type:"text",raw:t=u[0].charAt(0),text:t}},t.emStrong=function(e,t,u){void 0===u&&(u="");var n=this.rules.inline.emStrong.lDelim.exec(e);if(n&&(!n[3]||!u.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDF50-\uDF59\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEC0-\uDED3\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDCD0-\uDCEB\uDCF0-\uDCF9\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])/))){var r=n[1]||n[2]||"";if(!r||""===u||this.rules.inline.punctuation.exec(u)){var i=n[0].length-1,s=i,a=0,o="*"===n[0][0]?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(o.lastIndex=0,t=t.slice(-1*e.length+i);null!=(n=o.exec(t));){var l,D=n[1]||n[2]||n[3]||n[4]||n[5]||n[6];if(D)if(l=D.length,n[3]||n[4])s+=l;else if((n[5]||n[6])&&i%3&&!((i+l)%3))a+=l;else if(!(0<(s-=l)))return l=Math.min(l,l+s+a),D=e.slice(0,i+n.index+(n[0].length-D.length)+l),Math.min(i,l)%2?(l=D.slice(1,-1),{type:"em",raw:D,text:l,tokens:this.lexer.inlineTokens(l)}):(l=D.slice(2,-2),{type:"strong",raw:D,text:l,tokens:this.lexer.inlineTokens(l)})}}}},t.codespan=function(e){var t,u,n,e=this.rules.inline.code.exec(e);if(e)return n=e[2].replace(/\n/g," "),t=/[^ ]/.test(n),u=/^ /.test(n)&&/ $/.test(n),n=A(n=t&&u?n.substring(1,n.length-1):n,!0),{type:"codespan",raw:e[0],text:n}},t.br=function(e){e=this.rules.inline.br.exec(e);if(e)return {type:"br",raw:e[0]}},t.del=function(e){e=this.rules.inline.del.exec(e);if(e)return {type:"del",raw:e[0],text:e[2],tokens:this.lexer.inlineTokens(e[2])}},t.autolink=function(e,t){var u,e=this.rules.inline.autolink.exec(e);if(e)return t="@"===e[2]?"mailto:"+(u=A(this.options.mangle?t(e[1]):e[1])):u=A(e[1]),{type:"link",raw:e[0],text:u,href:t,tokens:[{type:"text",raw:u,text:u}]}},t.url=function(e,t){var u,n,r,i;if(u=this.rules.inline.url.exec(e)){if("@"===u[2])r="mailto:"+(n=A(this.options.mangle?t(u[0]):u[0]));else {for(;i=u[0],u[0]=this.rules.inline._backpedal.exec(u[0])[0],i!==u[0];);n=A(u[0]),r="www."===u[1]?"http://"+u[0]:u[0];}return {type:"link",raw:u[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}},t.inlineText=function(e,t){e=this.rules.inline.text.exec(e);if(e)return t=this.lexer.state.inRawBlock?this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):A(e[0]):e[0]:A(this.options.smartypants?t(e[0]):e[0]),{type:"text",raw:e[0],text:t}},e}(),B={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:F,lheading:/^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\.|[^\[\]\\])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/},w=(B.def=h(B.def).replace("label",B._label).replace("title",B._title).getRegex(),B.bullet=/(?:[*+-]|\d{1,9}[.)])/,B.listItemStart=h(/^( *)(bull) */).replace("bull",B.bullet).getRegex(),B.list=h(B.list).replace(/bull/g,B.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+B.def.source+")").getRegex(),B._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",B._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/,B.html=h(B.html,"i").replace("comment",B._comment).replace("tag",B._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),B.paragraph=h(B._paragraph).replace("hr",B.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",B._tag).getRegex(),B.blockquote=h(B.blockquote).replace("paragraph",B.paragraph).getRegex(),B.normal=d({},B),B.gfm=d({},B.normal,{table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"}),B.gfm.table=h(B.gfm.table).replace("hr",B.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",B._tag).getRegex(),B.gfm.paragraph=h(B._paragraph).replace("hr",B.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",B.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",B._tag).getRegex(),B.pedantic=d({},B.normal,{html:h("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",B._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:F,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:h(B.normal._paragraph).replace("hr",B.hr).replace("heading"," *#{1,6} *[^\n]").replace("lheading",B.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()}),{escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:F,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,rDelimUnd:/^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:F,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/});function L(e){return e.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…")}function v(e){for(var t,u="",n=e.length,r=0;r<n;r++)t=e.charCodeAt(r),u+="&#"+(t=.5<Math.random()?"x"+t.toString(16):t)+";";return u}w._punctuation="!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~",w.punctuation=h(w.punctuation).replace(/punctuation/g,w._punctuation).getRegex(),w.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g,w.escapedEmSt=/(?:^|[^\\])(?:\\\\)*\\[*_]/g,w._comment=h(B._comment).replace("(?:--\x3e|$)","--\x3e").getRegex(),w.emStrong.lDelim=h(w.emStrong.lDelim).replace(/punct/g,w._punctuation).getRegex(),w.emStrong.rDelimAst=h(w.emStrong.rDelimAst,"g").replace(/punct/g,w._punctuation).getRegex(),w.emStrong.rDelimUnd=h(w.emStrong.rDelimUnd,"g").replace(/punct/g,w._punctuation).getRegex(),w._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g,w._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,w._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,w.autolink=h(w.autolink).replace("scheme",w._scheme).replace("email",w._email).getRegex(),w._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,w.tag=h(w.tag).replace("comment",w._comment).replace("attribute",w._attribute).getRegex(),w._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,w._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/,w._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,w.link=h(w.link).replace("label",w._label).replace("href",w._href).replace("title",w._title).getRegex(),w.reflink=h(w.reflink).replace("label",w._label).replace("ref",B._label).getRegex(),w.nolink=h(w.nolink).replace("ref",B._label).getRegex(),w.reflinkSearch=h(w.reflinkSearch,"g").replace("reflink",w.reflink).replace("nolink",w.nolink).getRegex(),w.normal=d({},w),w.pedantic=d({},w.normal,{strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:h(/^!?\[(label)\]\((.*?)\)/).replace("label",w._label).getRegex(),reflink:h(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",w._label).getRegex()}),w.gfm=d({},w.normal,{escape:h(w.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/}),w.gfm.url=h(w.gfm.url,"i").replace("email",w.gfm._extended_email).getRegex(),w.breaks=d({},w.gfm,{br:h(w.br).replace("{2,}","*").getRegex(),text:h(w.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()});var y=function(){function u(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||r.defaults,this.options.tokenizer=this.options.tokenizer||new b,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,(this.tokenizer.lexer=this).inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};e={block:B.normal,inline:w.normal};this.options.pedantic?(e.block=B.pedantic,e.inline=w.pedantic):this.options.gfm&&(e.block=B.gfm,this.options.breaks?e.inline=w.breaks:e.inline=w.gfm),this.tokenizer.rules=e;}u.lex=function(e,t){return new u(t).lex(e)},u.lexInline=function(e,t){return new u(t).inlineTokens(e)};var e,t,n=u.prototype;return n.lex=function(e){var t;for(e=e.replace(/\r\n|\r/g,"\n"),this.blockTokens(e,this.tokens);t=this.inlineQueue.shift();)this.inlineTokens(t.src,t.tokens);return this.tokens},n.blockTokens=function(r,i){var s,a,o,l,D=this;for(void 0===i&&(i=[]),r=this.options.pedantic?r.replace(/\t/g,"    ").replace(/^ +$/gm,""):r.replace(/^( *)(\t+)/gm,function(e,t,u){return t+"    ".repeat(u.length)});r;){var e=function(){if(D.options.extensions&&D.options.extensions.block&&D.options.extensions.block.some(function(e){return !!(s=e.call({lexer:D},r,i))&&(r=r.substring(s.raw.length),i.push(s),!0)}))return "continue";if(s=D.tokenizer.space(r))return r=r.substring(s.raw.length),1===s.raw.length&&0<i.length?i[i.length-1].raw+="\n":i.push(s),"continue";if(s=D.tokenizer.code(r))return r=r.substring(s.raw.length),!(a=i[i.length-1])||"paragraph"!==a.type&&"text"!==a.type?i.push(s):(a.raw+="\n"+s.raw,a.text+="\n"+s.text,D.inlineQueue[D.inlineQueue.length-1].src=a.text),"continue";if(s=D.tokenizer.fences(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=D.tokenizer.heading(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=D.tokenizer.hr(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=D.tokenizer.blockquote(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=D.tokenizer.list(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=D.tokenizer.html(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=D.tokenizer.def(r))return r=r.substring(s.raw.length),!(a=i[i.length-1])||"paragraph"!==a.type&&"text"!==a.type?D.tokens.links[s.tag]||(D.tokens.links[s.tag]={href:s.href,title:s.title}):(a.raw+="\n"+s.raw,a.text+="\n"+s.raw,D.inlineQueue[D.inlineQueue.length-1].src=a.text),"continue";if(s=D.tokenizer.table(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=D.tokenizer.lheading(r))return r=r.substring(s.raw.length),i.push(s),"continue";var t,u,n;if(o=r,D.options.extensions&&D.options.extensions.startBlock&&(t=1/0,u=r.slice(1),D.options.extensions.startBlock.forEach(function(e){"number"==typeof(n=e.call({lexer:this},u))&&0<=n&&(t=Math.min(t,n));}),t<1/0)&&0<=t&&(o=r.substring(0,t+1)),D.state.top&&(s=D.tokenizer.paragraph(o)))return a=i[i.length-1],l&&"paragraph"===a.type?(a.raw+="\n"+s.raw,a.text+="\n"+s.text,D.inlineQueue.pop(),D.inlineQueue[D.inlineQueue.length-1].src=a.text):i.push(s),l=o.length!==r.length,r=r.substring(s.raw.length),"continue";if(s=D.tokenizer.text(r))return r=r.substring(s.raw.length),(a=i[i.length-1])&&"text"===a.type?(a.raw+="\n"+s.raw,a.text+="\n"+s.text,D.inlineQueue.pop(),D.inlineQueue[D.inlineQueue.length-1].src=a.text):i.push(s),"continue";if(r){var e="Infinite loop on byte: "+r.charCodeAt(0);if(D.options.silent)return console.error(e),"break";throw new Error(e)}}();if("continue"!==e&&"break"===e)break}return this.state.top=!0,i},n.inline=function(e,t){return this.inlineQueue.push({src:e,tokens:t=void 0===t?[]:t}),t},n.inlineTokens=function(r,i){var s,a,o,e,l,D,c=this,p=(void 0===i&&(i=[]),r);if(this.tokens.links){var t=Object.keys(this.tokens.links);if(0<t.length)for(;null!=(e=this.tokenizer.rules.inline.reflinkSearch.exec(p));)t.includes(e[0].slice(e[0].lastIndexOf("[")+1,-1))&&(p=p.slice(0,e.index)+"["+E("a",e[0].length-2)+"]"+p.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));}for(;null!=(e=this.tokenizer.rules.inline.blockSkip.exec(p));)p=p.slice(0,e.index)+"["+E("a",e[0].length-2)+"]"+p.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;null!=(e=this.tokenizer.rules.inline.escapedEmSt.exec(p));)p=p.slice(0,e.index+e[0].length-2)+"++"+p.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex),this.tokenizer.rules.inline.escapedEmSt.lastIndex--;for(;r;){var u=function(){if(l||(D=""),l=!1,c.options.extensions&&c.options.extensions.inline&&c.options.extensions.inline.some(function(e){return !!(s=e.call({lexer:c},r,i))&&(r=r.substring(s.raw.length),i.push(s),!0)}))return "continue";if(s=c.tokenizer.escape(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=c.tokenizer.tag(r))return r=r.substring(s.raw.length),(a=i[i.length-1])&&"text"===s.type&&"text"===a.type?(a.raw+=s.raw,a.text+=s.text):i.push(s),"continue";if(s=c.tokenizer.link(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=c.tokenizer.reflink(r,c.tokens.links))return r=r.substring(s.raw.length),(a=i[i.length-1])&&"text"===s.type&&"text"===a.type?(a.raw+=s.raw,a.text+=s.text):i.push(s),"continue";if(s=c.tokenizer.emStrong(r,p,D))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=c.tokenizer.codespan(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=c.tokenizer.br(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=c.tokenizer.del(r))return r=r.substring(s.raw.length),i.push(s),"continue";if(s=c.tokenizer.autolink(r,v))return r=r.substring(s.raw.length),i.push(s),"continue";if(!c.state.inLink&&(s=c.tokenizer.url(r,v)))return r=r.substring(s.raw.length),i.push(s),"continue";var t,u,n;if(o=r,c.options.extensions&&c.options.extensions.startInline&&(t=1/0,u=r.slice(1),c.options.extensions.startInline.forEach(function(e){"number"==typeof(n=e.call({lexer:this},u))&&0<=n&&(t=Math.min(t,n));}),t<1/0)&&0<=t&&(o=r.substring(0,t+1)),s=c.tokenizer.inlineText(o,L))return r=r.substring(s.raw.length),"_"!==s.raw.slice(-1)&&(D=s.raw.slice(-1)),l=!0,(a=i[i.length-1])&&"text"===a.type?(a.raw+=s.raw,a.text+=s.text):i.push(s),"continue";if(r){var e="Infinite loop on byte: "+r.charCodeAt(0);if(c.options.silent)return console.error(e),"break";throw new Error(e)}}();if("continue"!==u&&"break"===u)break}return i},n=u,t=[{key:"rules",get:function(){return {block:B,inline:w}}}],(e=null)&&i(n.prototype,e),t&&i(n,t),Object.defineProperty(n,"prototype",{writable:!1}),u}(),_=function(){function e(e){this.options=e||r.defaults;}var t=e.prototype;return t.code=function(e,t,u){var n,t=(t||"").match(/\S*/)[0];return this.options.highlight&&null!=(n=this.options.highlight(e,t))&&n!==e&&(u=!0,e=n),e=e.replace(/\n$/,"")+"\n",t?'<pre><code class="'+this.options.langPrefix+A(t)+'">'+(u?e:A(e,!0))+"</code></pre>\n":"<pre><code>"+(u?e:A(e,!0))+"</code></pre>\n"},t.blockquote=function(e){return "<blockquote>\n"+e+"</blockquote>\n"},t.html=function(e,t){return e},t.heading=function(e,t,u,n){return this.options.headerIds?"<h"+t+' id="'+(this.options.headerPrefix+n.slug(u))+'">'+e+"</h"+t+">\n":"<h"+t+">"+e+"</h"+t+">\n"},t.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},t.list=function(e,t,u){var n=t?"ol":"ul";return "<"+n+(t&&1!==u?' start="'+u+'"':"")+">\n"+e+"</"+n+">\n"},t.listitem=function(e){return "<li>"+e+"</li>\n"},t.checkbox=function(e){return "<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},t.paragraph=function(e){return "<p>"+e+"</p>\n"},t.table=function(e,t){return "<table>\n<thead>\n"+e+"</thead>\n"+(t=t&&"<tbody>"+t+"</tbody>")+"</table>\n"},t.tablerow=function(e){return "<tr>\n"+e+"</tr>\n"},t.tablecell=function(e,t){var u=t.header?"th":"td";return (t.align?"<"+u+' align="'+t.align+'">':"<"+u+">")+e+"</"+u+">\n"},t.strong=function(e){return "<strong>"+e+"</strong>"},t.em=function(e){return "<em>"+e+"</em>"},t.codespan=function(e){return "<code>"+e+"</code>"},t.br=function(){return this.options.xhtml?"<br/>":"<br>"},t.del=function(e){return "<del>"+e+"</del>"},t.link=function(e,t,u){return null===(e=f(this.options.sanitize,this.options.baseUrl,e))?u:(e='<a href="'+e+'"',t&&(e+=' title="'+t+'"'),e+">"+u+"</a>")},t.image=function(e,t,u){return null===(e=f(this.options.sanitize,this.options.baseUrl,e))?u:(e='<img src="'+e+'" alt="'+u+'"',t&&(e+=' title="'+t+'"'),e+(this.options.xhtml?"/>":">"))},t.text=function(e){return e},e}(),z=function(){function e(){}var t=e.prototype;return t.strong=function(e){return e},t.em=function(e){return e},t.codespan=function(e){return e},t.del=function(e){return e},t.html=function(e){return e},t.text=function(e){return e},t.link=function(e,t,u){return ""+u},t.image=function(e,t,u){return ""+u},t.br=function(){return ""},e}(),$=function(){function e(){this.seen={};}var t=e.prototype;return t.serialize=function(e){return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")},t.getNextSafeSlug=function(e,t){var u=e,n=0;if(this.seen.hasOwnProperty(u))for(n=this.seen[e];u=e+"-"+ ++n,this.seen.hasOwnProperty(u););return t||(this.seen[e]=n,this.seen[u]=0),u},t.slug=function(e,t){void 0===t&&(t={});e=this.serialize(e);return this.getNextSafeSlug(e,t.dryrun)},e}(),S=function(){function u(e){this.options=e||r.defaults,this.options.renderer=this.options.renderer||new _,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new z,this.slugger=new $;}u.parse=function(e,t){return new u(t).parse(e)},u.parseInline=function(e,t){return new u(t).parseInline(e)};var e=u.prototype;return e.parse=function(e,t){void 0===t&&(t=!0);for(var u,n,r,i,s,a,o,l,D,c,p,h,f,g,F,d,A="",k=e.length,C=0;C<k;C++)if(l=e[C],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[l.type]&&(!1!==(d=this.options.extensions.renderers[l.type].call({parser:this},l))||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(l.type)))A+=d||"";else switch(l.type){case"space":continue;case"hr":A+=this.renderer.hr();continue;case"heading":A+=this.renderer.heading(this.parseInline(l.tokens),l.depth,m(this.parseInline(l.tokens,this.textRenderer)),this.slugger);continue;case"code":A+=this.renderer.code(l.text,l.lang,l.escaped);continue;case"table":for(a=D="",r=l.header.length,u=0;u<r;u++)a+=this.renderer.tablecell(this.parseInline(l.header[u].tokens),{header:!0,align:l.align[u]});for(D+=this.renderer.tablerow(a),o="",r=l.rows.length,u=0;u<r;u++){for(a="",i=(s=l.rows[u]).length,n=0;n<i;n++)a+=this.renderer.tablecell(this.parseInline(s[n].tokens),{header:!1,align:l.align[n]});o+=this.renderer.tablerow(a);}A+=this.renderer.table(D,o);continue;case"blockquote":o=this.parse(l.tokens),A+=this.renderer.blockquote(o);continue;case"list":for(D=l.ordered,E=l.start,c=l.loose,r=l.items.length,o="",u=0;u<r;u++)f=(h=l.items[u]).checked,g=h.task,p="",h.task&&(F=this.renderer.checkbox(f),c?0<h.tokens.length&&"paragraph"===h.tokens[0].type?(h.tokens[0].text=F+" "+h.tokens[0].text,h.tokens[0].tokens&&0<h.tokens[0].tokens.length&&"text"===h.tokens[0].tokens[0].type&&(h.tokens[0].tokens[0].text=F+" "+h.tokens[0].tokens[0].text)):h.tokens.unshift({type:"text",text:F}):p+=F),p+=this.parse(h.tokens,c),o+=this.renderer.listitem(p,g,f);A+=this.renderer.list(o,D,E);continue;case"html":A+=this.renderer.html(l.text,l.block);continue;case"paragraph":A+=this.renderer.paragraph(this.parseInline(l.tokens));continue;case"text":for(o=l.tokens?this.parseInline(l.tokens):l.text;C+1<k&&"text"===e[C+1].type;)o+="\n"+((l=e[++C]).tokens?this.parseInline(l.tokens):l.text);A+=t?this.renderer.paragraph(o):o;continue;default:var E='Token with "'+l.type+'" type was not found.';if(this.options.silent)return void console.error(E);throw new Error(E)}return A},e.parseInline=function(e,t){t=t||this.renderer;for(var u,n,r="",i=e.length,s=0;s<i;s++)if(u=e[s],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[u.type]&&(!1!==(n=this.options.extensions.renderers[u.type].call({parser:this},u))||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(u.type)))r+=n||"";else switch(u.type){case"escape":r+=t.text(u.text);break;case"html":r+=t.html(u.text);break;case"link":r+=t.link(u.href,u.title,this.parseInline(u.tokens,t));break;case"image":r+=t.image(u.href,u.title,u.text);break;case"strong":r+=t.strong(this.parseInline(u.tokens,t));break;case"em":r+=t.em(this.parseInline(u.tokens,t));break;case"codespan":r+=t.codespan(u.text);break;case"br":r+=t.br();break;case"del":r+=t.del(this.parseInline(u.tokens,t));break;case"text":r+=t.text(u.text);break;default:var a='Token with "'+u.type+'" type was not found.';if(this.options.silent)return void console.error(a);throw new Error(a)}return r},u}(),T=function(){function e(e){this.options=e||r.defaults;}var t=e.prototype;return t.preprocess=function(e){return e},t.postprocess=function(e){return e},e}();function R(g,F){return function(e,u,n){"function"==typeof u&&(n=u,u=null);var r,i,s,t,a=d({},u),o=(u=d({},I.defaults,a),r=u.silent,i=u.async,s=n,function(e){var t;if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",r)return t="<p>An error occurred:</p><pre>"+A(e.message+"",!0)+"</pre>",i?Promise.resolve(t):s?void s(null,t):t;if(i)return Promise.reject(e);if(!s)throw e;s(e);});if(null==e)return o(new Error("marked(): input parameter is undefined or null"));if("string"!=typeof e)return o(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected"));if(a=n,(t=u)&&!t.silent&&(a&&console.warn("marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async"),(t.sanitize||t.sanitizer)&&console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options"),!t.highlight&&"language-"===t.langPrefix||console.warn("marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight."),t.mangle&&console.warn("marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`."),t.baseUrl&&console.warn("marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url."),t.smartypants&&console.warn("marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants."),t.xhtml&&console.warn("marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml."),t.headerIds||t.headerPrefix)&&console.warn("marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`."),u.hooks&&(u.hooks.options=u),n){var l,D=u.highlight;try{u.hooks&&(e=u.hooks.preprocess(e)),l=g(e,u);}catch(e){return o(e)}var c,p=function(t){var e;if(!t)try{u.walkTokens&&I.walkTokens(l,u.walkTokens),e=F(l,u),u.hooks&&(e=u.hooks.postprocess(e));}catch(e){t=e;}return u.highlight=D,t?o(t):n(null,e)};return !D||D.length<3?p():(delete u.highlight,l.length?(c=0,I.walkTokens(l,function(u){"code"===u.type&&(c++,setTimeout(function(){D(u.text,u.lang,function(e,t){if(e)return p(e);null!=t&&t!==u.text&&(u.text=t,u.escaped=!0),0===--c&&p();});},0));}),void(0===c&&p())):p())}if(u.async)return Promise.resolve(u.hooks?u.hooks.preprocess(e):e).then(function(e){return g(e,u)}).then(function(e){return u.walkTokens?Promise.all(I.walkTokens(e,u.walkTokens)).then(function(){return e}):e}).then(function(e){return F(e,u)}).then(function(e){return u.hooks?u.hooks.postprocess(e):e}).catch(o);try{u.hooks&&(e=u.hooks.preprocess(e));var h=g(e,u),f=(u.walkTokens&&I.walkTokens(h,u.walkTokens),F(h,u));return f=u.hooks?u.hooks.postprocess(f):f}catch(e){return o(e)}}}function I(e,t,u){return R(y.lex,S.parse)(e,t,u)}T.passThroughHooks=new Set(["preprocess","postprocess"]),I.options=I.setOptions=function(e){return I.defaults=d({},I.defaults,e),e=I.defaults,r.defaults=e,I},I.getDefaults=e,I.defaults=r.defaults,I.use=function(){for(var D=I.defaults.extensions||{renderers:{},childTokens:{}},e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];t.forEach(function(s){var u,e=d({},s);if(e.async=I.defaults.async||e.async||!1,s.extensions&&(s.extensions.forEach(function(r){if(!r.name)throw new Error("extension name required");var i;if(r.renderer&&(i=D.renderers[r.name],D.renderers[r.name]=i?function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=r.renderer.apply(this,t);return n=!1===n?i.apply(this,t):n}:r.renderer),r.tokenizer){if(!r.level||"block"!==r.level&&"inline"!==r.level)throw new Error("extension level must be 'block' or 'inline'");D[r.level]?D[r.level].unshift(r.tokenizer):D[r.level]=[r.tokenizer],r.start&&("block"===r.level?D.startBlock?D.startBlock.push(r.start):D.startBlock=[r.start]:"inline"===r.level&&(D.startInline?D.startInline.push(r.start):D.startInline=[r.start]));}r.childTokens&&(D.childTokens[r.name]=r.childTokens);}),e.extensions=D),s.renderer){var t,a=I.defaults.renderer||new _;for(t in s.renderer)!function(r){var i=a[r];a[r]=function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=s.renderer[r].apply(a,t);return n=!1===n?i.apply(a,t):n};}(t);e.renderer=a;}if(s.tokenizer){var n,o=I.defaults.tokenizer||new b;for(n in s.tokenizer)!function(r){var i=o[r];o[r]=function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=s.tokenizer[r].apply(o,t);return n=!1===n?i.apply(o,t):n};}(n);e.tokenizer=o;}if(s.hooks){var r,l=I.defaults.hooks||new T;for(r in s.hooks)!function(r){var i=l[r];T.passThroughHooks.has(r)?l[r]=function(e){return I.defaults.async?Promise.resolve(s.hooks[r].call(l,e)).then(function(e){return i.call(l,e)}):(e=s.hooks[r].call(l,e),i.call(l,e))}:l[r]=function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=s.hooks[r].apply(l,t);return n=!1===n?i.apply(l,t):n};}(r);e.hooks=l;}s.walkTokens&&(u=I.defaults.walkTokens,e.walkTokens=function(e){var t=[];return t.push(s.walkTokens.call(this,e)),t=u?t.concat(u.call(this,e)):t}),I.setOptions(e);});},I.walkTokens=function(e,a){for(var o,l=[],t=D(e);!(o=t()).done;)!function(){var t=o.value;switch(l=l.concat(a.call(I,t)),t.type){case"table":for(var e=D(t.header);!(u=e()).done;){var u=u.value;l=l.concat(I.walkTokens(u.tokens,a));}for(var n,r=D(t.rows);!(n=r()).done;)for(var i=D(n.value);!(s=i()).done;){var s=s.value;l=l.concat(I.walkTokens(s.tokens,a));}break;case"list":l=l.concat(I.walkTokens(t.items,a));break;default:I.defaults.extensions&&I.defaults.extensions.childTokens&&I.defaults.extensions.childTokens[t.type]?I.defaults.extensions.childTokens[t.type].forEach(function(e){l=l.concat(I.walkTokens(t[e],a));}):t.tokens&&(l=l.concat(I.walkTokens(t.tokens,a)));}}();return l},I.parseInline=R(y.lexInline,S.parseInline),I.Parser=S,I.parser=S.parse,I.Renderer=_,I.TextRenderer=z,I.Lexer=y,I.lexer=y.lex,I.Tokenizer=b,I.Slugger=$,I.Hooks=T;var F=(I.parse=I).options,U=I.setOptions,Q=I.use,M=I.walkTokens,N=I.parseInline,H=I,X=S.parse,G=y.lex;r.Hooks=T,r.Lexer=y,r.Parser=S,r.Renderer=_,r.Slugger=$,r.TextRenderer=z,r.Tokenizer=b,r.getDefaults=e,r.lexer=G,r.marked=I,r.options=F,r.parse=H,r.parseInline=N,r.parser=X,r.setOptions=U,r.use=Q,r.walkTokens=M;}); 
	} (marked_min, marked_min.exports));

	var marked_minExports = marked_min.exports;
	var marked = /*@__PURE__*/getDefaultExportFromCjs(marked_minExports);

	var GetHeadingTree = function (text) {
	    var items = marked.lexer(text);

	    var eventsheet = null;
	    var parents = [];
	    for (var i = 0; i < items.length; i++) {
	        var item = items[i];
	        switch (item.type) {
	            case 'heading':
	                var level = item.depth - 1;
	                // First node
	                if (eventsheet === null) {
	                    if (level === 0) {
	                        var node = CreateNewNode(item.text);
	                        parents.push(node);
	                        eventsheet = node;
	                    }
	                    // Ignore items if eventsheet is null
	                } else {
	                    if (level <= parents.length) {
	                        var node = CreateNewNode(item.text);
	                        parents.length = level;
	                        var lastNode = parents[parents.length - 1];
	                        lastNode.children.push(node);
	                        parents.push(node);
	                    }
	                    // Ignore items if out of parents
	                }
	                break;

	            case 'paragraph':
	            case 'code':
	                if (parents.length === 0) {
	                    continue;
	                }
	                // Append raw to last-node
	                var lastNode = parents[parents.length - 1];
	                var node = { text: item.text };
	                if (item.lang) {
	                    node.block = item.lang;
	                }
	                lastNode.paragraphs.push(node);
	                break;

	            // Ignore other kinds of items
	        }
	    }

	    return eventsheet;
	};

	var CreateNewNode = function (title) {
	    return {
	        title: title,
	        paragraphs: [],
	        children: [],
	    }
	};

	var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
	var HEX = /^0x[0-9A-F]+$/i;

	var TypeConvert = function (s) {
	    if (typeof (s) !== 'string') {
	        return s;
	    }

	    if (s === '') {
	        s = null;

	    } else if (FLOAT.test(s)) {
	        s = parseFloat(s);

	    } else if (HEX.test(s)) {
	        s = parseInt(s, 16);

	    } else {
	        switch (s) {
	            case 'false': s = false; break;
	            case 'true': s = true; break;
	            case 'null': s = null; break;
	            case 'undefined': s = undefined; break;
	        }
	    }

	    return s;
	};

	var ParseProperty = function (s, out) {
	    var index = s.indexOf('=');
	    if (index === -1) {
	        out[s] = true;
	    } else {
	        var name = s.substring(0, index).trimRight();
	        var expression = s.substring(index + 1);
	        var value = TypeConvert(expression);

	        // String post-processor
	        // Replace '\n' (2 characters) by '\n' (newline character, 1 character)
	        if (typeof (value) === 'string') {
	            value = value.replace(/\\n/g, '\n');
	        }

	        out[name] = value;
	    }

	    return out;
	};

	var GetTreeConfig = function (paragraphs, commentLineStart) {
	    // TODO: YAML format? 
	    var config = {};
	    paragraphs.forEach(function (paragraph) {
	        var lines = paragraph.text.split('\n');
	        lines.forEach(function (line) {
	            if (line.startsWith(commentLineStart)) {
	                return;
	            }
	            ParseProperty(line, config);
	        });
	    });

	    return config;
	};

	const TopLevelCommandTypes = [
	    { name: 'condition' },
	    { name: 'catch' },
	];

	const HeadingCommand = [
	    {
	        name: 'if',
	        pattern: new RegExp('^if\\s*(.*)', 'i')
	    },
	    { name: 'else' },
	    {
	        name: 'else if',
	        pattern: new RegExp('^else if\\s*(.*)', 'i')
	    },
	    {
	        name: 'while',
	        pattern: new RegExp('^while\\s*(.*)', 'i')
	    },
	    {
	        name: 'repeat',
	        pattern: new RegExp('^repeat\\s*(.*)', 'i')
	    },
	];

	const ActionCommandTypes = [
	    { name: 'exit' },
	    { name: 'break' },
	    {
	        name: 'activate',
	        pattern: new RegExp('^activate\\s*(.*)', 'i')
	    },
	    {
	        name: 'deactivate',
	        pattern: new RegExp('^deactivate\\s*(.*)', 'i')
	    },
	];

	var ParseType = function (s, patterns) {
	    s = s.trim();

	    if ((s[0] === '[') && (s[s.length - 1] === ']')) {
	        s = s.substring(1, s.length - 1);
	        var lowCaseString = s.toLowerCase();

	        for (var i = 0, cnt = patterns.length; i < cnt; i++) {
	            var pattern = patterns[i];
	            var patternName = pattern.name;
	            var testPattern = pattern.pattern;

	            if (testPattern) {
	                var result = s.match(testPattern);
	                if (result) {
	                    return { type: patternName, match: result };
	                }
	            } else if (patternName === lowCaseString) {
	                return { type: patternName };
	            }
	        }
	    }

	    return null;
	};

	const STATE_CONDITION = 1;
	const STATE_TASK = 2;
	const STATE_CATCH = 3;

	var ParseTopLevelNodes = function (nodes) {
	    var conditionNodes = [];
	    var mainTaskNodes = [];
	    var catchNodes = [];

	    var state = STATE_CONDITION;
	    var result = ParseType(nodes[0].title, TopLevelCommandTypes);
	    var nextNodeType = (result) ? result.type : '';
	    for (var i = 0, cnt = nodes.length; i < cnt; i++) {
	        var node = nodes[i];
	        if (state === STATE_CONDITION) {
	            if (nextNodeType === '') {
	                state = STATE_TASK;
	            } else if (nextNodeType === 'catch') {
	                state = STATE_CATCH;
	            }
	        } else if (state === STATE_TASK) {
	            if (nextNodeType === 'catch') {
	                state = STATE_CATCH;
	            }
	        }

	        switch (state) {
	            case STATE_CONDITION:
	                conditionNodes.push(node);
	                break;

	            case STATE_TASK:
	                mainTaskNodes.push(node);
	                break;

	            case STATE_CATCH:
	                catchNodes.push(node);
	                break;
	        }

	        if ((i + 1) < cnt) {
	            result = ParseType(nodes[i + 1].title, TopLevelCommandTypes);
	            nextNodeType = (result) ? result.type : '';
	        }
	    }

	    return {
	        conditionNodes: conditionNodes,
	        mainTaskNodes: mainTaskNodes,
	        catchNodes: catchNodes,
	    }
	};

	var GetConditionExpression$1 = function (nodes) {
	    if (!Array.isArray(nodes)) {
	        return GetANDExpression(nodes);
	    }

	    var expression;
	    switch (nodes.length) {
	        case 0:
	            expression = 'true';
	            break;

	        case 1:
	            expression = GetANDExpression(nodes[0]);
	            break;

	        default:
	            expression = nodes.map(function (node) {
	                return `(${GetANDExpression(node)})`
	            }).join(' || ');
	            break;
	    }

	    return expression;
	};

	var GetANDExpression = function (node) {
	    var paragraphs = node.paragraphs;
	    var lines = [];
	    for (var i = 0, cnt = paragraphs.length; i < cnt; i++) {
	        var paragraph = paragraphs[i];
	        if (paragraph.hasOwnProperty('block')) {
	            continue;
	        }

	        lines.push(...paragraph.text.split('\n'));
	    }

	    var expression;
	    switch (lines.length) {
	        case 0:
	            expression = 'true';
	            break;

	        case 1:
	            expression = lines[0];
	            break;

	        default:
	            expression = lines.map(function (line) { return `(${line})` }).join(' && ');
	            break;

	    }
	    return expression;
	};

	var CreateActionNode = function (paragraph, config) {
	    var commandData = GetCommandData(paragraph, config);
	    if (!commandData) {
	        return;
	    }

	    var actionNode;
	    switch (commandData.type) {
	        case 'exit':
	            actionNode = new Abort({ title: '[exit]' });
	            break;

	        case 'break':
	            actionNode = new Failer({ title: '[break]' });
	            break;

	        case 'activate':
	            var activateTreeTitle = commandData.match[1].trim();
	            actionNode = new ActivateAction({
	                title: '[activate]',
	                activateTreeTitle: activateTreeTitle,
	            });
	            break;

	        case 'deactivate':
	            var deactivateTreeTitle = commandData.match[1].trim();
	            actionNode = new DeactivateAction({
	                title: '[deactivate]',
	                deactivateTreeTitle: deactivateTreeTitle,
	            });
	            break;

	        default:
	            delete commandData.type;
	            actionNode = new TaskAction(commandData);
	            break;
	    }

	    return actionNode;
	};

	var GetCommandData = function (paragraph, config) {
	    var commandData;
	    if (paragraph.hasOwnProperty('block')) {
	        commandData = ParseCommandString(paragraph.block, ',', config);
	        commandData.parameters.text = paragraph.text;
	    } else {
	        commandData = ParseCommandString(paragraph.text, '\n', config);
	    }

	    return commandData;
	};


	var ParseCommandString = function (commandString, delimiter, {
	    lineBreak = '\\',
	    commentLineStart = '\/\/',
	} = {}) {
	    var lines = commandString.split(delimiter);

	    if (delimiter === '\n') {
	        // Discard comment lines
	        lines = lines.filter(function (line) {
	            return !line.trimLeft().startsWith(commentLineStart);
	        });

	        if (lines.length === 0) {
	            return null;
	        } else if (lines.length === 1) {
	            var line = lines[0];

	            var result = ParseType(line, ActionCommandTypes);
	            if (result) {
	                return result;
	            }

	            if (line.indexOf(',') !== -1) {
	                lines = commandString.split(',');
	            }
	        }
	    }

	    var commandData = {
	        type: 'task',
	        name: TrimString(lines[0], lineBreak),
	        parameters: {}
	    };

	    var parameters = commandData.parameters;
	    for (var i = 1, cnt = lines.length; i < cnt; i++) {
	        ParseProperty(TrimString(lines[i], lineBreak), parameters);
	    }
	    return commandData;
	};

	var TrimString = function (s, lineBreak) {
	    if (lineBreak && (s.at(-1) === lineBreak)) {
	        s = s.substring(0, s.length - 1);
	    }
	    return s.trim();
	};

	var CreateActionSequence = function (node, config) {
	    var sequence = new TaskSequence({ title: node.title });
	    var paragraphs = node.paragraphs;  // paragraphs -> TaskAction[]
	    var actionNode;
	    for (var i = 0, cnt = paragraphs.length; i < cnt; i++) {
	        actionNode = CreateActionNode(paragraphs[i], config);
	        if (!actionNode) {
	            continue;
	        }
	        sequence.addChild(actionNode);
	    }
	    return sequence;
	};

	var ExtraNumberExpression = function (s) {
	    if (s.startsWith('#(') && s.endsWith(')')) {
	        return s.substring(2, s.length - 1);
	    }

	    return s;
	};

	var CreateParentNode = function (node, config, output) {
	    if (Array.isArray(node)) {
	        var nodes = node;
	        if (nodes.length === 1) {
	            return CreateParentNode(nodes[0], config);

	        } else {
	            // Create sequence from node.children
	            var sequence = (output) ? output : new Sequence();
	            var lastIfSelector;
	            for (var i = 0, cnt = nodes.length; i < cnt; i++) {
	                var node = nodes[i];
	                var child = CreateParentNode(node, config);
	                if (!child) {
	                    continue;
	                }

	                // Construct if-branch selector
	                switch (child.title) {
	                    case '[if]':
	                        sequence.addChild(child);
	                        lastIfSelector = child;
	                        break;

	                    case '[else]':
	                    case '[else if]':
	                        if (lastIfSelector) {
	                            lastIfSelector.insertChild(child, null, -1);
	                        } else {
	                            // No [If] heading before this [else] heading
	                            console.warn(`Can't find [If] heading before '${node.title}'`);
	                        }
	                        break;

	                    default:  // Normal tasks
	                        sequence.addChild(child);
	                        lastIfSelector = null;
	                        break;
	                }

	            }
	            return sequence;

	        }
	    }

	    var result = ParseType(node.title, HeadingCommand);
	    if (result) {
	        switch (result.type) {
	            case 'if':
	                var selector = new Selector({
	                    title: '[if]'
	                });

	                var ifDecorator;
	                var expression = GetConditionExpression(result.match[1], node);
	                try {
	                    ifDecorator = new If({
	                        expression: expression
	                    });
	                } catch (e) {
	                    console.error(`[EventSheet] Parse expression '${expression}' at Heading ${node.title} failed, replace expression by 'false'`);
	                    console.error(e);

	                    ifDecorator = new If({
	                        expression: 'false'
	                    });
	                }

	                if (node.children.length > 0) {
	                    ifDecorator.addChild(CreateParentNode(node.children, config));
	                } else {
	                    ifDecorator.addChild(CreateActionSequence(node, config));
	                }
	                selector.addChild(ifDecorator);

	                var succeeder = new Succeeder();
	                selector.addChild(succeeder);

	                return selector;

	            case 'else':
	            case 'else if':
	                var nodeTypeName = result.type;
	                var ifDecorator;
	                var expression = (nodeTypeName === 'else') ? 'true' : GetConditionExpression(result.match[1], node);
	                try {
	                    ifDecorator = new If({
	                        title: `[${nodeTypeName}]`,
	                        expression: expression
	                    });
	                } catch (e) {
	                    console.error(`[EventSheet] Parse expression '${expression}' at Heading ${node.title} failed, replace expression by 'false'`);
	                    console.error(e);

	                    ifDecorator = new If({
	                        title: `[${nodeTypeName}]`,
	                        expression: 'false'
	                    });
	                }

	                if (node.children.length > 0) {
	                    ifDecorator.addChild(CreateParentNode(node.children, config));
	                } else {
	                    ifDecorator.addChild(CreateActionSequence(node, config));
	                }
	                return ifDecorator;

	            case 'while':
	                var whileDecorator = new RepeatUntilFailure({
	                    title: '[while]',
	                    returnSuccess: true,
	                });

	                var ifDecorator;
	                var expression = GetConditionExpression(result.match[1], node);
	                try {
	                    ifDecorator = new If({
	                        title: '[while-IF]',
	                        expression: expression
	                    });
	                } catch (e) {
	                    console.error(`[EventSheet] Parse expression '${expression}' at Heading ${node.title} failed, replace expression by 'false'`);
	                    console.error(e);

	                    ifDecorator = new If({
	                        title: '[while-IF]',
	                        expression: 'false'
	                    });
	                }

	                if (node.children.length > 0) {
	                    ifDecorator.addChild(CreateParentNode(node.children, config));
	                } else {
	                    ifDecorator.addChild(CreateActionSequence(node, config));
	                }

	                whileDecorator.addChild(ifDecorator);
	                return whileDecorator;

	            case 'repeat':
	                var repeatCount = ExtraNumberExpression(result.match[1]);
	                var repeatDecorator = new Repeat({
	                    title: '[repeat]',
	                    maxLoop: repeatCount,
	                });
	                if (node.children.length > 0) {
	                    repeatDecorator.addChild(CreateParentNode(node.children, config));
	                } else {
	                    repeatDecorator.addChild(CreateActionSequence(node, config));
	                }
	                return repeatDecorator;

	            default:
	                // Error
	                console.error(`Missing ${result.type}'s handler`);
	                break;
	        }

	    } else {
	        var sequence;
	        if (node.children.length > 0) {
	            // A node has paragraphs and children
	            sequence = new Sequence();

	            if (node.paragraphs.length > 0) {
	                // Create ActionSequence from paragraphs
	                sequence.addChild(CreateActionSequence(node, config));
	            }

	            // Append nodes from node.children
	            CreateParentNode(node.children, config, sequence);

	        } else {
	            // A node has paragraphs only
	            sequence = CreateActionSequence(node, config);
	            // Always create a sequence no matter has paragraphs or not

	        }
	        return sequence;

	    }
	};

	var GetConditionExpression = function (payloadExpression, node) {
	    var expression = payloadExpression.trim();
	    if (expression === '') {
	        expression = GetConditionExpression$1(node);
	    }
	    return expression;
	};

	var Marked2Tree = function (
	    eventSheetManager,
	    markedString,
	    {
	        groupName,
	        lineBreak = '\\',
	        commentLineStart = '\/\/',
	        parallel = false,
	        active = true,
	        once = false,
	    } = {}
	) {

	    var headingTree = GetHeadingTree(markedString);
	    var { conditionNodes, mainTaskNodes, catchNodes } = ParseTopLevelNodes(headingTree.children);

	    var treeConfig = Object.assign(
	        { groupName, parallel, active, once },
	        GetTreeConfig(headingTree.paragraphs, commentLineStart)
	    );

	    var taskSequenceConfig = { lineBreak, commentLineStart };

	    var eventsheet = new EventSheet(
	        eventSheetManager,
	        {
	            title: headingTree.title,
	            condition: GetConditionExpression$1(conditionNodes),
	            properties: treeConfig
	        }
	    );

	    var rootNode = eventsheet.root;
	    rootNode.addChild(CreateParentNode(mainTaskNodes, taskSequenceConfig));

	    var forceFailure = new ForceFailure();
	    if (catchNodes.length > 0) {
	        forceFailure.addChild(CreateParentNode(catchNodes[0], taskSequenceConfig));
	    } else {
	        forceFailure.addChild(new Succeeder());
	    }
	    rootNode.addChild(forceFailure);

	    return eventsheet;
	};

	class MarkedEventSheets extends EventSheetManager {
	    boot() {
	        super.boot();

	        if (this.scene) {
	            this.scene.sys.events.once('shutdown', this.destroy, this);
	        }
	    }

	    shutdown(fromScene) {
	        if (this.isShutdown) {
	            return;
	        }

	        if (this.scene) {
	            this.scene.sys.events.off('shutdown', this.destroy, this);
	        }

	        super.shutdown(fromScene);

	        return this;
	    }
	    addEventSheet(markedString, groupName, config) {
	        if (typeof (groupName) !== 'string') {
	            config = groupName;
	            groupName = undefined;
	        }

	        if (groupName === undefined) {
	            groupName = this.defaultTreeGroupName;
	        }

	        if (config === undefined) {
	            config = {};
	        }

	        var {
	            lineBreak = '\\',
	            commentLineStart = '\/\/',
	            parallel = this.parallel,
	            groupName = groupName
	        } = config;

	        var eventsheet = Marked2Tree(
	            this,
	            markedString,
	            {
	                groupName,
	                lineBreak,
	                commentLineStart,
	                parallel
	            }
	        );

	        this.addTree(eventsheet, eventsheet.groupName);

	        return this;
	    }
	}

	var papaparse_min = {exports: {}};

	/* @license
	Papa Parse
	v5.4.1
	https://github.com/mholt/PapaParse
	License: MIT
	*/

	(function (module, exports) {
		!function(e,t){module.exports=t();}(commonjsGlobal,function s(){var f="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=f.IS_PAPA_WORKER||!1,a={},u=0,b={parse:function(e,t){var r=(t=t||{}).dynamicTyping||!1;J(r)&&(t.dynamicTypingFunction=r,r={});if(t.dynamicTyping=r,t.transform=!!J(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var i=function(){if(!b.WORKERS_SUPPORTED)return !1;var e=(r=f.URL||f.webkitURL||null,i=s.toString(),b.BLOB_URL||(b.BLOB_URL=r.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ","(",i,")();"],{type:"text/javascript"})))),t=new f.Worker(e);var r,i;return t.onmessage=_,t.id=u++,a[t.id]=t}();return i.userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=J(t.step),t.chunk=J(t.chunk),t.complete=J(t.complete),t.error=J(t.error),delete t.worker,void i.postMessage({input:e,config:t,workerId:i.id})}var n=null;b.NODE_STREAM_INPUT,"string"==typeof e?(e=function(e){if(65279===e.charCodeAt(0))return e.slice(1);return e}(e),n=t.download?new l(t):new p(t)):!0===e.readable&&J(e.read)&&J(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=",",y="\r\n",s='"',a=s+s,r=!1,i=null,o=!1;!function(){if("object"!=typeof t)return;"string"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return -1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);("boolean"==typeof t.quotes||"function"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(r=t.skipEmptyLines);"string"==typeof t.newline&&(y=t.newline);"string"==typeof t.quoteChar&&(s=t.quoteChar);"boolean"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");i=t.columns;}void 0!==t.escapeChar&&(a=t.escapeChar+s);("boolean"==typeof t.escapeFormulae||t.escapeFormulae instanceof RegExp)&&(o=t.escapeFormulae instanceof RegExp?t.escapeFormulae:/^[=+\-@\t\r].*$/);}();var u=new RegExp(Q(s),"g");"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return h(null,e,r);if("object"==typeof e[0])return h(i||Object.keys(e[0]),e,r)}else if("object"==typeof e)return "string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||i),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:"object"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),h(e.fields||[],e.data||[],r);throw new Error("Unable to serialize unrecognized input");function h(e,t,r){var i="";"string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(i+=m),i+=v(e[a],a);0<t.length&&(i+=y);}for(var o=0;o<t.length;o++){var u=n?e.length:t[o].length,h=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(r&&!n&&(h="greedy"===r?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===r&&n){for(var d=[],l=0;l<u;l++){var c=s?e[l]:l;d.push(t[o][c]);}h=""===d.join("").trim();}if(!h){for(var p=0;p<u;p++){0<p&&!f&&(i+=m);var g=n&&s?e[p]:p;i+=v(t[o][g],p);}o<t.length-1&&(!r||0<u&&!f)&&(i+=y);}}return i}function v(e,t){if(null==e)return "";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var r=!1;o&&"string"==typeof e&&o.test(e)&&(e="'"+e,r=!0);var i=e.toString().replace(u,a);return (r=r||!0===n||"function"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var r=0;r<t.length;r++)if(-1<e.indexOf(t[r]))return !0;return !1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||" "===i.charAt(0)||" "===i.charAt(i.length-1))?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK="\ufeff",b.BAD_DELIMITERS=["\r","\n",'"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=",",b.Parser=E,b.ParserHandle=r,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var r=o.config||{},u=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return !0;for(var t=0;t<this.files.length;t++)u.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},r)});}),e(),this;function e(){if(0!==u.length){var e,t,r,i,n=u[0];if(J(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,r=n.inputElem,i=s.reason,void(J(o.error)&&o.error({name:e},t,r,i));if("skip"===s.action)return void h();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config));}else if("skip"===s)return void h()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){J(a)&&a(e,n.file,n.inputElem),h();},b.parse(n.file,n.instanceConfig);}else J(o.complete)&&o.complete();}function h(){u.splice(0,1),e();}};}function h(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=w(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new r(t),(this._handle.streamer=this)._config=t;}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&J(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(e);void 0!==r&&(e=r);}this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+e;this._partialLine="";var n=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=i.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(J(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0;}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!J(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0;},this._sendError=function(e){J(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1});};}function l(e){var i;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),h.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded();}:function(){this._readChunk();},this.stream=function(e){this._input=e,this._nextChunk();},this._readChunk=function(){if(this._finished)this._chunkLoaded();else {if(i=new XMLHttpRequest,this._config.withCredentials&&(i.withCredentials=this._config.withCredentials),n||(i.onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)),i.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)i.setRequestHeader(t,e[t]);}if(this._config.chunkSize){var r=this._start+this._config.chunkSize-1;i.setRequestHeader("Range","bytes="+this._start+"-"+r);}try{i.send(this._config.downloadRequestBody);}catch(e){this._chunkError(e.message);}n&&0===i.status&&this._chunkError();}},this._chunkLoaded=function(){4===i.readyState&&(i.status<200||400<=i.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:i.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader("Content-Range");if(null===t)return -1;return parseInt(t.substring(t.lastIndexOf("/")+1))}(i),this.parseChunk(i.responseText)));},this._chunkError=function(e){var t=i.statusText||e;this._sendError(new Error(t));};}function c(e){var i,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),h.call(this,e);var s="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((i=new FileReader).onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)):i=new FileReaderSync,this._nextChunk();},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk();},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t);}var r=i.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:r}});},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result);},this._chunkError=function(){this._sendError(i.error);};}function p(e){var r;h.call(this,e=e||{}),this.stream=function(e){return r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=r.substring(0,t),r=r.substring(t)):(e=r,r=""),this._finished=!r,this.parseChunk(e)}};}function g(e){h.call(this,e=e||{});var t=[],r=!0,i=!1;this.pause=function(){h.prototype.pause.apply(this,arguments),this._input.pause();},this.resume=function(){h.prototype.resume.apply(this,arguments),this._input.resume();},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError);},this._checkIsFinished=function(){i&&1===t.length&&(this._finished=!0);},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):r=!0;},this._streamData=v(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(t.shift()));}catch(e){this._streamError(e);}},this),this._streamError=v(function(e){this._streamCleanUp(),this._sendError(e);},this),this._streamEnd=v(function(){this._streamCleanUp(),i=!0,this._streamData("");},this),this._streamCleanUp=v(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError);},this);}function r(m){var a,o,u,i=Math.pow(2,53),n=-i,s=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,h=/^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,t=this,r=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(J(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else {if(g(),0===c.data.length)return;r+=e.data.length,m.preview&&r>m.preview?o.abort():(c.data=c.data[0],p(c,t));}};}function y(e){return "greedy"===m.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function g(){return c&&u&&(k("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+b.DefaultDelimiter+"'"),u=!1),m.skipEmptyLines&&(c.data=c.data.filter(function(e){return !y(e)})),_()&&function(){if(!c)return;function e(e,t){J(m.transformHeader)&&(e=m.transformHeader(e,t)),l.push(e);}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1);}else c.data.forEach(e);}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var r,i=m.header?{}:[];for(r=0;r<e.length;r++){var n=r,s=e[r];m.header&&(n=r>=l.length?"__parsed_extra":l[r]),m.transform&&(s=m.transform(s,n)),s=v(n,s),"__parsed_extra"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s;}return m.header&&(r>l.length?k("FieldMismatch","TooManyFields","Too many fields: expected "+l.length+" fields but parsed "+r,f+t):r<l.length&&k("FieldMismatch","TooFewFields","Too few fields: expected "+l.length+" fields but parsed "+r,f+t)),i}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function v(e,t){return r=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[r]&&(m.dynamicTyping[r]=m.dynamicTypingFunction(r)),!0===(m.dynamicTyping[r]||m.dynamicTyping)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<i)return !0}return !1}(t)?parseFloat(t):h.test(t)?new Date(t):""===t?null:t):t;var r;}function k(e,t,r,i){var n={type:e,code:t,message:r};void 0!==i&&(n.row=i),c.errors.push(n);}this.parse=function(e,t,r){var i=m.quoteChar||'"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var r=new RegExp(Q(t)+"([^]*?)"+Q(t),"gm"),i=(e=e.replace(r,"")).split("\r"),n=e.split("\n"),s=1<n.length&&n[0].length<i[0].length;if(1===i.length||s)return "\n";for(var a=0,o=0;o<i.length;o++)"\n"===i[o][0]&&a++;return a>=i.length/2?"\r\n":"\r"}(e,i)),u=!1,m.delimiter)J(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else {var n=function(e,t,r,i,n){var s,a,o,u;n=n||[",","\t","|",";",b.RECORD_SEP,b.UNIT_SEP];for(var h=0;h<n.length;h++){var f=n[h],d=0,l=0,c=0;o=void 0;for(var p=new E({comments:i,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(r&&y(p.data[g]))c++;else {var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_;}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===u||u<l)&&1.99<l&&(a=d,s=f,u=l);}return {successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(u=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter;}var s=w(m);return m.preview&&m.header&&s.preview++,a=e,o=new E(s),c=o.parse(a,t,r),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=J(m.chunk)?"":a.substring(o.getCharIndex());},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3);},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,J(m.complete)&&m.complete(c),a="";};}function Q(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(j){var z,M=(j=j||{}).delimiter,P=j.newline,U=j.comments,q=j.step,N=j.preview,B=j.fastMode,K=z=void 0===j.quoteChar||null===j.quoteChar?'"':j.quoteChar;if(void 0!==j.escapeChar&&(K=j.escapeChar),("string"!=typeof M||-1<b.BAD_DELIMITERS.indexOf(M))&&(M=","),U===M)throw new Error("Comment character same as delimiter");!0===U?U="#":("string"!=typeof U||-1<b.BAD_DELIMITERS.indexOf(U))&&(U=!1),"\n"!==P&&"\r"!==P&&"\r\n"!==P&&(P="\n");var W=0,H=!1;this.parse=function(i,t,r){if("string"!=typeof i)throw new Error("Input must be a string");var n=i.length,e=M.length,s=P.length,a=U.length,o=J(q),u=[],h=[],f=[],d=W=0;if(!i)return L();if(j.header&&!t){var l=i.split(P)[0].split(M),c=[],p={},g=!1;for(var _ in l){var m=l[_];J(j.transformHeader)&&(m=j.transformHeader(m,_));var y=m,v=p[m]||0;for(0<v&&(g=!0,y=m+"_"+v),p[m]=v+1;c.includes(y);)y=y+"_"+v;c.push(y);}if(g){var k=i.split(P);k[0]=c.join(M),i=k.join(P);}}if(B||!1!==B&&-1===i.indexOf(z)){for(var b=i.split(P),E=0;E<b.length;E++){if(f=b[E],W+=f.length,E!==b.length-1)W+=P.length;else if(r)return L();if(!U||f.substring(0,a)!==U){if(o){if(u=[],I(f.split(M)),F(),H)return L()}else I(f.split(M));if(N&&N<=E)return u=u.slice(0,N),L(!0)}}return L()}for(var w=i.indexOf(M,W),R=i.indexOf(P,W),C=new RegExp(Q(K)+Q(z),"g"),S=i.indexOf(z,W);;)if(i[W]!==z)if(U&&0===f.length&&i.substring(W,W+a)===U){if(-1===R)return L();W=R+s,R=i.indexOf(P,W),w=i.indexOf(M,W);}else if(-1!==w&&(w<R||-1===R))f.push(i.substring(W,w)),W=w+e,w=i.indexOf(M,W);else {if(-1===R)break;if(f.push(i.substring(W,R)),D(R+s),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0)}else for(S=W,W++;;){if(-1===(S=i.indexOf(z,S+1)))return r||h.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:u.length,index:W}),T();if(S===n-1)return T(i.substring(W,S).replace(C,z));if(z!==K||i[S+1]!==K){if(z===K||0===S||i[S-1]!==K){-1!==w&&w<S+1&&(w=i.indexOf(M,S+1)),-1!==R&&R<S+1&&(R=i.indexOf(P,S+1));var O=A(-1===R?w:Math.min(w,R));if(i.substr(S+1+O,e)===M){f.push(i.substring(W,S).replace(C,z)),i[W=S+1+O+e]!==z&&(S=i.indexOf(z,W)),w=i.indexOf(M,W),R=i.indexOf(P,W);break}var x=A(R);if(i.substring(S+1+x,S+1+x+s)===P){if(f.push(i.substring(W,S).replace(C,z)),D(S+1+x+s),w=i.indexOf(M,W),S=i.indexOf(z,W),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0);break}h.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:u.length,index:W}),S++;}}else S++;}return T();function I(e){u.push(e),d=W;}function A(e){var t=0;if(-1!==e){var r=i.substring(S+1,e);r&&""===r.trim()&&(t=r.length);}return t}function T(e){return r||(void 0===e&&(e=i.substring(W)),f.push(e),W=n,I(f),o&&F()),L()}function D(e){W=e,I(f),f=[],R=i.indexOf(P,W);}function L(e){return {data:u,errors:h,meta:{delimiter:M,linebreak:P,aborted:H,truncated:!!e,cursor:d+(t||0)}}}function F(){q(L()),u=[],h=[];}},this.abort=function(){H=!0;},this.getCharIndex=function(){return W};}function _(e){var t=e.data,r=a[t.workerId],i=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){i=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}});},pause:y,resume:y};if(J(r.userStep)){for(var s=0;s<t.results.data.length&&(r.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!i);s++);delete t.results;}else J(r.userChunk)&&(r.userChunk(t.results,n,t.file),delete t.results);}t.finished&&!i&&m(t.workerId,t.results);}function m(e,t){var r=a[e];J(r.userComplete)&&r.userComplete(t),r.terminate(),delete a[e];}function y(){throw new Error("Not implemented.")}function w(e){if("object"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var r in e)t[r]=w(e[r]);return t}function v(e,t){return function(){e.apply(t,arguments);}}function J(e){return "function"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if("string"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var r=b.parse(t.input,t.config);r&&f.postMessage({workerId:b.WORKER_ID,results:r,finished:!0});}}),(l.prototype=Object.create(h.prototype)).constructor=l,(c.prototype=Object.create(h.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(h.prototype)).constructor=g,b}); 
	} (papaparse_min));

	var EventEmitterMethods$1 = {
	    setEventEmitter(eventEmitter, EventEmitterClass) {
	        if (EventEmitterClass === undefined) {
	            EventEmitterClass = Phaser.Events.EventEmitter; // Use built-in EventEmitter class by default
	        }
	        this._privateEE = (eventEmitter === true) || (eventEmitter === undefined);
	        this._eventEmitter = (this._privateEE) ? (new EventEmitterClass()) : eventEmitter;
	        return this;
	    },

	    destroyEventEmitter() {
	        if (this._eventEmitter && this._privateEE) {
	            this._eventEmitter.shutdown();
	        }
	        return this;
	    },

	    getEventEmitter() {
	        return this._eventEmitter;
	    },

	    on() {
	        if (this._eventEmitter) {
	            this._eventEmitter.on.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    once() {
	        if (this._eventEmitter) {
	            this._eventEmitter.once.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    off() {
	        if (this._eventEmitter) {
	            this._eventEmitter.off.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    emit(event) {
	        if (this._eventEmitter && event) {
	            this._eventEmitter.emit.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    addListener() {
	        if (this._eventEmitter) {
	            this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    removeListener() {
	        if (this._eventEmitter) {
	            this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    removeAllListeners() {
	        if (this._eventEmitter) {
	            this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    listenerCount() {
	        if (this._eventEmitter) {
	            return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
	        }
	        return 0;
	    },

	    listeners() {
	        if (this._eventEmitter) {
	            return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
	        }
	        return [];
	    },

	    eventNames() {
	        if (this._eventEmitter) {
	            return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
	        }
	        return [];
	    },
	};

	var PropertyMethods$1 = {
	    hasProperty(property) {
	        var gameObject = this.gameObject;
	        if (gameObject.hasOwnProperty(property)) {
	            return true;
	        } else {
	            var value = gameObject[property];
	            return (value !== undefined);
	        }
	    },

	    getProperty(property) {
	        return this.gameObject[property];
	    },

	    setProperty(property, value) {
	        this.gameObject[property] = value;
	        return this;
	    },

	    easeProperty(config) {
	        var property = config.property;
	        var value = config.value;
	        var duration = config.duration;
	        var delay = config.delay;
	        var ease = config.ease;
	        var repeat = config.repeat;
	        var isYoyo = config.yoyo;
	        var isFrom = config.from;
	        var onComplete = config.complete;
	        var target = config.target;

	        if (duration === undefined) {
	            duration = 1000;
	        }
	        if (delay === undefined) {
	            delay = 0;
	        }
	        if (ease === undefined) {
	            ease = 'Linear';
	        }
	        if (repeat === undefined) {
	            repeat = 0;
	        }
	        if (isYoyo === undefined) {
	            isYoyo = false;
	        }
	        if (target === undefined) {
	            target = this.gameObject;
	        }
	        if (isFrom) {
	            var startValue = value;
	            value = target[property];
	            target[property] = startValue;
	        }

	        var config = {
	            targets: target,
	            duration: duration,
	            delay: delay,
	            ease: ease,
	            repeat: repeat,
	            yoyo: isYoyo,
	            onComplete: onComplete,
	        };
	        config[property] = value;

	        this.addTweenTask(property, config);

	        return this;
	    },

	    addTweenTask(name, config) {
	        var tweenTasks = this.tweens;
	        var tweenTask = tweenTasks[name];
	        if (tweenTask) {
	            tweenTask.remove();
	        }

	        var onComplete = config.onComplete;
	        config.onComplete = function () {
	            tweenTasks[name].remove();
	            tweenTasks[name] = null;
	            if (onComplete) {
	                onComplete(config.targets, name);
	            }
	        };

	        tweenTask = this.scene.tweens.add(config);
	        tweenTask.timeScale = this.timeScale;
	        tweenTasks[name] = tweenTask;
	        return this;
	    },

	    getTweenTask(property) {
	        return this.tweens[property];
	    },

	    freeTweens() {
	        var tweenTasks = this.tweens,
	            tweenTask;
	        for (var propName in tweenTasks) {
	            tweenTask = tweenTasks[propName];
	            if (tweenTask) {
	                tweenTask.remove();
	            }
	            tweenTasks[propName] = null;
	        }
	        return this;
	    }

	};

	var CallMethods$1 = {
	    hasMethod(methodName) {
	        return typeof (this.gameObject[methodName]) === 'function';
	    },

	    call(methodName, ...parameters) {
	        if (!this.hasMethod(methodName)) {
	            console.warn(`[GameObjectManager] Game object '${this.name}' does not have method '${methodName}'`);
	            return this;
	        }

	        var gameObject = this.gameObject;
	        gameObject[methodName].apply(gameObject, parameters);

	        return this;
	    }
	};

	var DataMethods$3 = {
	    hasData(dataKey) {
	        var gameObject = this.gameObject;
	        return (gameObject.data) ? gameObject.data.has(dataKey) : false;
	    },

	    getData(dataKey) {
	        return this.gameObject.getData(dataKey);
	    },

	    setData(dataKey, value) {
	        this.gameObject.setData(dataKey, value);
	        return this;
	    },
	};

	class BobBase {
	    constructor(GOManager, gameObject, name) {
	        this.GOManager = GOManager;
	        this.tweens = {};
	        this.effects = {};
	        this.setGO(gameObject, name);
	    }

	    get scene() {
	        return this.GOManager.scene;
	    }

	    get timeScale() {
	        return this.GOManager.timeScale;
	    }

	    destroy() {
	        this.freeGO();
	        this.GOManager = undefined;
	    }

	    freeGO() {
	        this.freeTweens();
	        this.gameObject.bob = undefined;
	        this.gameObject.destroy();
	        this.gameObject = undefined;
	        return this;
	    }

	    setGO(gameObject, name) {
	        gameObject.goName = name;
	        gameObject.goType = this.GOManager.name;
	        gameObject.bob = this;
	        this.gameObject = gameObject;
	        this.name = name;
	        this.freeTweens();
	        return this;
	    }

	    setTimeScale(timeScale) {
	        var tweenTasks = this.tweens;
	        for (var key in tweenTasks) {
	            var tweenTask = tweenTasks[key];
	            if (tweenTask) {
	                tweenTask.timeScale = timeScale;
	            }
	        }

	        return this;
	    }

	}

	Object.assign(
	    BobBase.prototype,
	    PropertyMethods$1,
	    CallMethods$1,
	    DataMethods$3,
	);

	var IsEmpty = function (source) {
	    for (var k in source) {
	        return false;
	    }
	    return true;
	};

	var IsSingleBob = function (name) {
	    return name && (name.charAt(0) !== '!');
	};

	var GetMethods = {
	    has(name) {
	        return this.bobs.hasOwnProperty(name);
	    },

	    exists(name) {
	        return this.bobs.hasOwnProperty(name);
	    },

	    get(name, out) {
	        if (IsSingleBob(name)) {
	            return this.bobs[name];

	        } else {
	            if (out === undefined) {
	                out = [];
	            }

	            if (name) {
	                name = name.substring(1);
	            }

	            for (var key in this.bobs) {
	                if (name && (key === name)) {
	                    continue;
	                }

	                out.push(this.bobs[key]);
	            }

	            return out;
	        }
	    },

	    getFitst(excluded) {
	        if (excluded && (excluded.charAt(0) === '!')) {
	            excluded = excluded.substring(1);
	        }

	        for (var name in this.bobs) {
	            if (excluded && (excluded === name)) {
	                continue;
	            }

	            return this.bobs[name];
	        }
	        return null;
	    },

	    getGO(name, out) {
	        var bob = this.get(name);
	        if (!bob) {
	            return null;

	        } else if (!Array.isArray(bob)) {
	            return bob.gameObject;

	        } else {
	            if (out === undefined) {
	                out = [];
	            }
	            var bobs = bob;
	            bobs.forEach(function (bob) {
	                out.push(bob.gameObject);
	            });

	            return out;

	        }
	    },

	    forEachGO(callback, scope) {
	        for (var name in this.bobs) {
	            var gameObject = this.bobs[name].gameObject;
	            var stopLoop;
	            if (scope) {
	                stopLoop = callback.call(scope, gameObject, name, this);
	            } else {
	                stopLoop = callback(gameObject, name, this);
	            }

	            if (stopLoop) {
	                break;
	            }
	        }
	        return this;
	    },

	    getAllGO(out) {
	        if (out === undefined) {
	            out = [];
	        }

	        for (var name in this.bobs) {
	            var gameObject = this.bobs[name].gameObject;
	            out.push(gameObject);
	        }

	        return out;
	    }
	};

	var GetR = function (colorInt) {
	    return (colorInt >> 16) & 0xff;
	};

	var GetG = function (colorInt) {
	    return (colorInt >> 8) & 0xff;
	};

	var GetB = function (colorInt) {
	    return (colorInt) & 0xff;
	};

	const MaskR = (~(0xff << 16) & 0xffffff);
	const MaskG = (~(0xff << 8) & 0xffffff);
	const MaskB = (~(0xff) & 0xffffff);

	var SetR = function (colorInt, r) {
	    return ((r & 0xff) << 16) | (colorInt & MaskR);
	};

	var SetG = function (colorInt, g) {
	    return ((g & 0xff) << 8) | (colorInt & MaskG);
	};

	var SetB = function (colorInt, b) {
	    return (b & 0xff) | (colorInt & MaskB);
	};

	var SetRGB = function (colorInt, r, g, b) {
	    return ((r & 0xff) << 16) | ((g & 0xff) << 8) | ((b & 0xff));
	};

	var AddTintRGBProperties = function (gameObject, tintRGB) {
	    // Don't attach properties again
	    if (gameObject.hasOwnProperty('tintR')) {
	        return gameObject;
	    }

	    if (tintRGB === undefined) {
	        tintRGB = 0xffffff;
	    }

	    var tintR = GetR(tintRGB);
	    var tintG = GetG(tintRGB);
	    var tintB = GetB(tintRGB);

	    // Override tint property
	    Object.defineProperty(gameObject, 'tint', {
	        get: function () {
	            return tintRGB;
	        },
	        set: function (value) {
	            value = Math.floor(value) & 0xffffff;
	            if (gameObject.setTint) {
	                gameObject.setTint(value);
	            }
	            if (tintRGB !== value) {
	                tintRGB = value;
	                tintR = GetR(tintRGB);
	                tintG = GetG(tintRGB);
	                tintB = GetB(tintRGB);
	                // gameObject.emit('_tintchange', value, tintR, tintG, tintB);
	            }
	        }
	    });

	    Object.defineProperty(gameObject, 'tintR', {
	        get: function () {
	            return tintR;
	        },
	        set: function (value) {
	            value = Math.floor(value) & 0xff;
	            if (tintR !== value) {
	                tintR = value;
	                gameObject.tint = SetR(tintRGB, value);
	            }
	        },
	    });
	    Object.defineProperty(gameObject, 'tintG', {
	        get: function () {
	            return tintG;
	        },
	        set: function (value) {
	            value = Math.floor(value) & 0xff;
	            if (tintG !== value) {
	                tintG = value;
	                gameObject.tint = SetG(tintRGB, value);
	            }
	        },
	    });
	    Object.defineProperty(gameObject, 'tintB', {
	        get: function () {
	            return tintB;
	        },
	        set: function (value) {
	            value = Math.floor(value) & 0xff;
	            if (tintB !== value) {
	                tintB = value;
	                gameObject.tint = SetB(tintRGB, value);
	            }
	        },
	    });
	    Object.defineProperty(gameObject, 'tintGray', {
	        get: function () {
	            return Math.floor((tintR + tintG + tintB) / 3);
	        },
	        set: function (value) {
	            value = Math.floor(value) & 0xff;
	            if ((tintR !== value) || (tintG !== value) || (tintB !== value)) {
	                tintR = value;
	                tintG = value;
	                tintB = value;
	                gameObject.tint = SetRGB(tintRGB, value, value, value);
	            }
	        },
	    });

	    gameObject.tint = tintRGB;

	    return gameObject;
	};

	const EventEmitter$1 = Phaser.Events.EventEmitter;

	var MonitorViewport = function (viewport) {
	    // Don't monitor properties again
	    if (viewport.events) {
	        return viewport;
	    }

	    var events = new EventEmitter$1();

	    var x = viewport.x;
	    Object.defineProperty(viewport, 'x', {
	        get: function () {
	            return x;
	        },

	        set: function (value) {
	            if (x !== value) {
	                x = value;
	                events.emit('update', viewport);
	            }
	        },
	    });

	    var y = viewport.y;
	    Object.defineProperty(viewport, 'y', {
	        get: function () {
	            return y;
	        },

	        set: function (value) {
	            if (y !== value) {
	                y = value;
	                events.emit('update', viewport);
	            }
	        },
	    });

	    var width = viewport.width;
	    Object.defineProperty(viewport, 'width', {
	        get: function () {
	            return width;
	        },

	        set: function (value) {
	            if (width !== value) {
	                width = value;
	                events.emit('update', viewport);
	            }
	        },
	    });

	    var height = viewport.height;
	    Object.defineProperty(viewport, 'height', {
	        get: function () {
	            return height;
	        },

	        set: function (value) {
	            if (height !== value) {
	                height = value;
	                events.emit('update', viewport);
	            }
	        },
	    });

	    viewport.events = events;

	    return viewport;
	};

	var VPXYToXY = function (vpx, vpy, vpxOffset, vpyOffset, viewport, out) {
	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        out = GlobXY;
	    }

	    if (typeof (vpxOffset) !== 'number') {
	        vpxOffset = 0;
	        vpyOffset = 0;
	    }

	    out.x = viewport.x + (viewport.width * vpx) + vpxOffset;
	    out.y = viewport.y + (viewport.height * vpy) + vpyOffset;
	    return out;
	};

	var GlobXY = {};

	var AddViewportCoordinateProperties = function (gameObject, viewport, vpx, vpy, vpxOffset, vpyOffset, transformCallback) {
	    // Don't attach properties again
	    if (gameObject.hasOwnProperty('vp')) {
	        return gameObject;
	    }

	    if (typeof (vpx) === 'function') {
	        transformCallback = vpx;
	        vpx = undefined;
	    }

	    if (typeof (vpxOffset) === 'function') {
	        transformCallback = vpxOffset;
	        vpxOffset = undefined;
	    }


	    if (vpx === undefined) { vpx = 0.5; }
	    if (vpy === undefined) { vpy = 0.5; }
	    if (vpxOffset === undefined) { vpxOffset = 0; }
	    if (vpyOffset === undefined) { vpyOffset = 0; }

	    if (transformCallback === undefined) {
	        transformCallback = VPXYToXY;
	    }

	    MonitorViewport(viewport);
	    var events = viewport.events;

	    gameObject.vp = viewport;

	    // Set position of game object when view-port changed.
	    var Transform = function () {
	        transformCallback(vpx, vpy, vpxOffset, vpyOffset, viewport, gameObject);
	    };

	    events.on('update', Transform);
	    gameObject.once('destroy', function () {
	        events.off('update', Transform);
	        gameObject.vp = undefined;
	    });

	    Object.defineProperty(gameObject, 'vpx', {
	        get: function () {
	            return vpx;
	        },
	        set: function (value) {
	            if (vpx !== value) {
	                vpx = value;
	                Transform();
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'vpy', {
	        get: function () {
	            return vpy;
	        },
	        set: function (value) {
	            if (vpy !== value) {
	                vpy = value;
	                Transform();
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'vpxOffset', {
	        get: function () {
	            return vpxOffset;
	        },
	        set: function (value) {
	            if (vpxOffset !== value) {
	                vpxOffset = value;
	                Transform();
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'vpyOffset', {
	        get: function () {
	            return vpyOffset;
	        },
	        set: function (value) {
	            if (vpyOffset !== value) {
	                vpyOffset = value;
	                Transform();
	            }
	        },
	    });

	    Transform();
	};

	var HasProperty = function (obj, prop) {
	    if (!obj) {
	        return false;
	    }

	    if (obj.hasOwnProperty(prop)) {
	        return true;
	    }

	    while (obj) {
	        if (Object.getOwnPropertyDescriptor(obj, prop)) {
	            return true;
	        }
	        obj = obj.__proto__;
	    }

	    return false;
	};

	var GetFXFactory = function (gameObject) {
	    if (gameObject.preFX) {
	        return gameObject.preFX;
	    }
	    if (gameObject.postFX) {
	        return gameObject.postFX;
	    }
	    return null;
	};

	var AddClearEffectCallback = function (gameObject, effectSwitchName) {
	    if (!gameObject._effectSwitchNames) {
	        gameObject._effectSwitchNames = [];

	        gameObject.clearAllEffects = function () {
	            var effectSwitchNames = gameObject._effectSwitchNames;
	            for (var i = 0, cnt = effectSwitchNames.length; i < cnt; i++) {
	                gameObject[effectSwitchNames[i]] = null;
	            }

	            return gameObject;
	        };
	        gameObject.on('destroy', gameObject.clearAllEffects, gameObject);
	    }

	    gameObject._effectSwitchNames.push(effectSwitchName);
	};

	var AddBarrelProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'barrel')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var barrel;
	    Object.defineProperty(gameObject, 'barrel', {
	        get: function () {
	            return barrel;
	        },
	        set: function (value) {
	            if (barrel === value) {
	                return;
	            }

	            barrel = value;

	            if ((barrel === null) || (barrel === false)) {
	                if (gameObject._barrelEffect) {
	                    fxFactory.remove(gameObject._barrelEffect);
	                    gameObject._barrelEffect = undefined;
	                }
	            } else {
	                if (!gameObject._barrelEffect) {
	                    gameObject._barrelEffect = fxFactory.addBarrel();
	                }
	                gameObject._barrelEffect.amount = barrel;
	            }

	        },
	    });

	    gameObject.barrel = null;

	    AddClearEffectCallback(gameObject, 'barrel');

	    return gameObject;
	};

	var AddColorMatrixEffectPropertiesBase = function (gameObject, effectName, inputMode) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, effectName)) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var EffectInstancePropertyName = `_${effectName}Effect`;

	    var currentValue;
	    Object.defineProperty(gameObject, effectName, {
	        get: function () {
	            return currentValue;
	        },
	        set: function (value) {
	            if (currentValue === value) {
	                return;
	            }

	            currentValue = value;

	            if ((currentValue === null) || (currentValue === false)) {
	                if (gameObject[EffectInstancePropertyName]) {
	                    fxFactory.remove(gameObject[EffectInstancePropertyName]);
	                    gameObject[EffectInstancePropertyName] = undefined;
	                }
	            } else {
	                if (!gameObject[EffectInstancePropertyName]) {
	                    gameObject[EffectInstancePropertyName] = fxFactory.addColorMatrix();
	                }
	                var effectInstance = gameObject[EffectInstancePropertyName];
	                effectInstance[effectName]((inputMode === 1) ? value : undefined);
	            }

	        },
	    });

	    gameObject[effectName] = null;

	    AddClearEffectCallback(gameObject, effectName);

	    return gameObject;
	};

	var AddBlackWhiteProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'blackWhite');
	    return gameObject;
	};

	var AddBloomProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'bloomColor')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var bloomColor,
	        bloomOffsetX = 1,
	        bloomOffsetY = 1,
	        bloomBlurStrength = 1,
	        bloomStrength = 1,
	        bloomSteps = 4;
	    Object.defineProperty(gameObject, 'bloomColor', {
	        get: function () {
	            return bloomColor;
	        },
	        set: function (value) {
	            if (bloomColor === value) {
	                return;
	            }

	            bloomColor = value;

	            if ((bloomColor === null) || (bloomColor === false)) {
	                if (gameObject._bloom) {
	                    fxFactory.remove(gameObject._bloom);
	                    gameObject._bloom = undefined;
	                    fxFactory.setPadding(0);
	                }
	            } else {
	                if (!gameObject._bloom) {
	                    gameObject._bloom = fxFactory.addBloom(bloomColor, bloomOffsetX, bloomOffsetY, bloomBlurStrength, bloomStrength, bloomSteps);
	                    fxFactory.setPadding(Math.max(bloomOffsetX, bloomOffsetY) + 1);
	                }

	                gameObject._bloom.color = bloomColor;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'bloomOffsetX', {
	        get: function () {
	            return bloomOffsetX;
	        },
	        set: function (value) {
	            if (bloomOffsetX === value) {
	                return;
	            }

	            bloomOffsetX = value;

	            if (gameObject._bloom) {
	                var offset = Math.max(bloomOffsetX, bloomOffsetY);
	                fxFactory.setPadding(offset + 1);
	                gameObject._bloom.offsetX = bloomOffsetX;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'bloomOffsetY', {
	        get: function () {
	            return bloomOffsetY;
	        },
	        set: function (value) {
	            if (bloomOffsetY === value) {
	                return;
	            }

	            bloomOffsetY = value;

	            if (gameObject._bloom) {
	                var offset = Math.max(bloomOffsetX, bloomOffsetY);
	                fxFactory.setPadding(offset + 1);
	                gameObject._bloom.offsetY = bloomOffsetY;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'bloomBlurStrength', {
	        get: function () {
	            return bloomBlurStrength;
	        },
	        set: function (value) {
	            if (bloomBlurStrength === value) {
	                return;
	            }

	            bloomBlurStrength = value;

	            if (gameObject._bloom) {
	                gameObject._bloom.blurStrength = bloomBlurStrength;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'bloomStrength', {
	        get: function () {
	            return bloomStrength;
	        },
	        set: function (value) {
	            if (bloomStrength === value) {
	                return;
	            }

	            bloomStrength = value;

	            if (gameObject._bloom) {
	                gameObject._bloom.strength = bloomStrength;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'bloomSteps', {
	        get: function () {
	            return bloomSteps;
	        },
	        set: function (value) {
	            if (bloomSteps === value) {
	                return;
	            }

	            bloomSteps = value;

	            if (gameObject._bloom) {
	                gameObject._bloom.steps = bloomSteps;
	            }
	        },
	    });

	    gameObject.bloomColor = null;

	    AddClearEffectCallback(gameObject, 'bloomColor');

	    return gameObject;
	};

	var AddBlurProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'blurColor')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var blurColor,
	        blurQuality = 0,
	        blurX = 1,
	        blurY = 1,
	        blurStrength = 1,
	        blurSteps = 4;
	    Object.defineProperty(gameObject, 'blurColor', {
	        get: function () {
	            return blurColor;
	        },
	        set: function (value) {
	            if (blurColor === value) {
	                return;
	            }

	            blurColor = value;

	            if ((blurColor === null) || (blurColor === false)) {
	                if (gameObject._blur) {
	                    fxFactory.remove(gameObject._blur);
	                    gameObject._blur = undefined;
	                    fxFactory.setPadding(0);
	                }
	            } else {
	                if (!gameObject._blur) {
	                    gameObject._blur = fxFactory.addBlur(blurQuality, blurX, blurY, blurStrength, blurColor, blurSteps);
	                    fxFactory.setPadding(Math.max(blurX, blurY) + 1);
	                }

	                gameObject._blur.color = blurColor;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'blurQuality', {
	        get: function () {
	            return blurQuality;
	        },
	        set: function (value) {
	            if (blurQuality === value) {
	                return;
	            }

	            blurQuality = value;

	            if (gameObject._blur) {
	                gameObject._blur.quality = blurQuality;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'blurX', {
	        get: function () {
	            return blurX;
	        },
	        set: function (value) {
	            if (blurX === value) {
	                return;
	            }

	            blurX = value;

	            if (gameObject._blur) {
	                var offset = Math.max(blurX, blurY);
	                fxFactory.setPadding(offset + 1);
	                gameObject._blur.x = blurX;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'blurY', {
	        get: function () {
	            return blurY;
	        },
	        set: function (value) {
	            if (blurY === value) {
	                return;
	            }

	            blurY = value;

	            if (gameObject._blur) {
	                var offset = Math.max(blurX, blurY);
	                fxFactory.setPadding(offset + 1);
	                gameObject._blur.y = blurY;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'blurStrength', {
	        get: function () {
	            return blurStrength;
	        },
	        set: function (value) {
	            if (blurStrength === value) {
	                return;
	            }

	            blurStrength = value;

	            if (gameObject._blur) {
	                gameObject._blur.strength = blurStrength;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'blurSteps', {
	        get: function () {
	            return blurSteps;
	        },
	        set: function (value) {
	            if (blurSteps === value) {
	                return;
	            }

	            blurSteps = value;

	            if (gameObject._blur) {
	                gameObject._blur.steps = blurSteps;
	            }
	        },
	    });

	    gameObject.blurColor = null;

	    AddClearEffectCallback(gameObject, 'blurColor');

	    return gameObject;
	};

	var AddBokehProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'bokehRadius')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var bokehRadius,
	        bokehAmount = 1,
	        bokehContrast = 0.2;
	    Object.defineProperty(gameObject, 'bokehRadius', {
	        get: function () {
	            return bokehRadius;
	        },
	        set: function (value) {
	            if (bokehRadius === value) {
	                return;
	            }

	            bokehRadius = value;

	            if ((bokehRadius === null) || (bokehRadius === false)) {
	                if (gameObject._bokeh) {
	                    fxFactory.remove(gameObject._bokeh);
	                    gameObject._bokeh = undefined;
	                }
	            } else {
	                if (!gameObject._bokeh) {
	                    gameObject._bokeh = fxFactory.addBokeh(bokehRadius, bokehAmount, bokehContrast);
	                }

	                gameObject._bokeh.radius = bokehRadius;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'bokehAmount', {
	        get: function () {
	            return bokehAmount;
	        },
	        set: function (value) {
	            if (bokehAmount === value) {
	                return;
	            }

	            bokehAmount = value;

	            if (gameObject._bokeh) {
	                gameObject._bokeh.amount = bokehAmount;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'bokehContrast', {
	        get: function () {
	            return bokehContrast;
	        },
	        set: function (value) {
	            if (bokehContrast === value) {
	                return;
	            }

	            bokehContrast = value;

	            if (gameObject._bokeh) {
	                gameObject._bokeh.contrast = bokehContrast;
	            }
	        },
	    });

	    gameObject.bokehRadius = null;

	    AddClearEffectCallback(gameObject, 'bokehRadius');

	    return gameObject;
	};

	var AddBrightnessProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'brightness', 1);
	    return gameObject;
	};

	var AddBrownProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'brown');
	    return gameObject;
	};

	var AddCircleProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'circleColor')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var circleColor,
	        circleThickness = 8,
	        circleBackgroundColor = 0x000000,
	        circleBackgroundAlpha = 0.4,
	        circleScale = 1,
	        circleFeather = 0.005;
	    Object.defineProperty(gameObject, 'circleColor', {
	        get: function () {
	            return circleColor;
	        },
	        set: function (value) {
	            if (circleColor === value) {
	                return;
	            }

	            circleColor = value;

	            if ((circleColor === null) || (circleColor === false)) {
	                if (gameObject._circle) {
	                    fxFactory.remove(gameObject._circle);
	                    gameObject._circle = undefined;
	                }
	            } else {
	                if (!gameObject._circle) {
	                    gameObject._circle = fxFactory.addCircle(circleThickness, circleColor, circleBackgroundColor, circleScale, circleFeather);
	                    gameObject.circleBackgroundAlpha = circleBackgroundAlpha;
	                }

	                gameObject._circle.color = circleColor;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'circleThickness', {
	        get: function () {
	            return circleThickness;
	        },
	        set: function (value) {
	            if (circleThickness === value) {
	                return;
	            }

	            circleThickness = value;

	            if (gameObject._circle) {
	                gameObject._circle.thickness = circleThickness;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'circleBackgroundColor', {
	        get: function () {
	            return circleBackgroundColor;
	        },
	        set: function (value) {
	            if (circleBackgroundColor === value) {
	                return;
	            }

	            circleBackgroundColor = value;

	            if (gameObject._circle) {
	                gameObject._circle.backgroundColor = circleBackgroundColor;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'circleBackgroundAlpha', {
	        get: function () {
	            return circleBackgroundAlpha;
	        },
	        set: function (value) {
	            if (circleBackgroundAlpha === value) {
	                return;
	            }

	            circleBackgroundAlpha = value;

	            if (gameObject._circle) {
	                gameObject._circle.glcolor2[3] = circleBackgroundAlpha;
	            }
	        },
	    });


	    Object.defineProperty(gameObject, 'circleScale', {
	        get: function () {
	            return circleScale;
	        },
	        set: function (value) {
	            if (circleScale === value) {
	                return;
	            }

	            circleScale = value;

	            if (gameObject._circle) {
	                gameObject._circle.scale = circleScale;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'circleFeather', {
	        get: function () {
	            return circleFeather;
	        },
	        set: function (value) {
	            if (circleFeather === value) {
	                return;
	            }

	            circleFeather = value;

	            if (gameObject._circle) {
	                gameObject._circle.feather = circleFeather;
	            }
	        },
	    });

	    gameObject.circleColor = null;

	    AddClearEffectCallback(gameObject, 'circleColor');

	    return gameObject;
	};

	var AddContrastProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'contrast', 1);
	    return gameObject;
	};

	var AddDesaturateProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'desaturate', 1);
	    return gameObject;
	};

	var AddDesaturateLuminanceProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'desaturateLuminance');
	    return gameObject;
	};

	var AddDisplacementProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'displacementKey')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var displacementKey,
	        displacementX = 0.005,
	        displacementY = 0.005;
	    Object.defineProperty(gameObject, 'displacementKey', {
	        get: function () {
	            return displacementKey;
	        },
	        set: function (value) {
	            if (displacementKey === value) {
	                return;
	            }

	            displacementKey = value;

	            if ((displacementKey === null) || (displacementKey === false)) {
	                if (gameObject._displacement) {
	                    fxFactory.remove(gameObject._displacement);
	                    gameObject._displacement = undefined;
	                }
	            } else {
	                if (!gameObject._displacement) {
	                    gameObject._displacement = fxFactory.addDisplacement(displacementKey, displacementX, displacementY);
	                }

	                gameObject._displacement.setTexture(displacementKey);
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'displacementX', {
	        get: function () {
	            return displacementX;
	        },
	        set: function (value) {
	            if (displacementX === value) {
	                return;
	            }

	            displacementX = value;

	            if (gameObject._displacement) {
	                gameObject._displacement.x = displacementX;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'displacementY', {
	        get: function () {
	            return displacementY;
	        },
	        set: function (value) {
	            if (displacementY === value) {
	                return;
	            }

	            displacementY = value;

	            if (gameObject._displacement) {
	                gameObject._displacement.y = displacementY;
	            }
	        },
	    });

	    gameObject.displacementKey = null;

	    AddClearEffectCallback(gameObject, 'displacementKey');

	    return gameObject;
	};

	var AddGlowProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'glowColor')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var glowColor,
	        glowOuterStrength = 4,
	        glowInnerStrength = 0;
	    Object.defineProperty(gameObject, 'glowColor', {
	        get: function () {
	            return glowColor;
	        },
	        set: function (value) {
	            if (glowColor === value) {
	                return;
	            }

	            glowColor = value;

	            if ((glowColor === null) || (glowColor === false)) {
	                if (gameObject._glow) {
	                    fxFactory.remove(gameObject._glow);
	                    gameObject._glow = undefined;
	                    fxFactory.setPadding(0);
	                }
	            } else {
	                if (!gameObject._glow) {
	                    gameObject._glow = fxFactory.addGlow(glowColor, glowOuterStrength, glowInnerStrength);
	                    fxFactory.setPadding(glowOuterStrength + 1);
	                }

	                gameObject._glow.color = glowColor;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'glowOuterStrength', {
	        get: function () {
	            return glowOuterStrength;
	        },
	        set: function (value) {
	            if (glowOuterStrength === value) {
	                return;
	            }

	            glowOuterStrength = value;

	            if (gameObject._glow) {
	                fxFactory.setPadding(glowOuterStrength + 1);
	                gameObject._glow.outerStrength = glowOuterStrength;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'glowInnerStrength', {
	        get: function () {
	            return glowInnerStrength;
	        },
	        set: function (value) {
	            if (glowInnerStrength === value) {
	                return;
	            }

	            glowInnerStrength = value;

	            if (gameObject._glow) {
	                gameObject._glow.innerStrength = glowInnerStrength;
	            }
	        },
	    });

	    gameObject.glowColor = null;

	    AddClearEffectCallback(gameObject, 'glowColor');

	    return gameObject;
	};

	var AddGradientProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'gradientColor')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var gradientColor1,
	        gradientColor2,
	        gradientAlpha = 0.5,
	        gradientFromX = 0,
	        gradientFromY = 0,
	        gradientToX = 0,
	        gradientToY = 1,
	        gradientSize = 0;
	    Object.defineProperty(gameObject, 'gradientColor', {
	        get: function () {
	            return [gradientColor1, gradientColor2];
	        },

	        set: function (value) {
	            var color1, color2;
	            if ((value === null) || (value === false)) {
	                color1 = null;
	                color2 = null;
	            } else {
	                color1 = value[0];
	                color2 = value[1];
	            }

	            if ((gradientColor1 === color1) && (gradientColor2 === color2)) {
	                return;
	            }

	            gradientColor1 = color1;
	            gradientColor2 = color2;

	            if ((gradientColor1 === null) || (gradientColor1 === false)) {
	                if (gameObject._gradient) {
	                    fxFactory.remove(gameObject._gradient);
	                    gameObject._gradient = undefined;
	                }
	            } else {
	                if (!gameObject._gradient) {
	                    gameObject._gradient = fxFactory.addGradient(gradientColor1, gradientColor2, gradientAlpha, gradientFromX, gradientFromY, gradientToX, gradientToY, gradientSize);
	                }

	                gameObject._gradient.color1 = gradientColor1;
	                gameObject._gradient.color2 = gradientColor2;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'gradientColor1', {
	        get: function () {
	            return gradientColor1;
	        },
	        set: function (value) {
	            if ((value === null) || (value === false)) {
	                gameObject.gradientColor = value;
	                return;
	            }

	            if (gradientColor1 === value) {
	                return;
	            }

	            gradientColor1 = value;

	            if (gameObject._gradient) {
	                gameObject._gradient.color1 = gradientColor1;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'gradientColor2', {
	        get: function () {
	            return gradientColor2;
	        },
	        set: function (value) {
	            if ((value === null) || (value === false)) {
	                gameObject.gradientColor = value;
	                return;
	            }

	            if (gradientColor2 === value) {
	                return;
	            }

	            gradientColor2 = value;

	            if (gameObject._gradient) {
	                gameObject._gradient.color2 = gradientColor2;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'gradientAlpha', {
	        get: function () {
	            return gradientAlpha;
	        },
	        set: function (value) {
	            if (gradientAlpha === value) {
	                return;
	            }

	            gradientAlpha = value;

	            if (gameObject._gradient) {
	                gameObject._gradient.alpha = gradientAlpha;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'gradientFromX', {
	        get: function () {
	            return gradientFromX;
	        },
	        set: function (value) {
	            if (gradientFromX === value) {
	                return;
	            }

	            gradientFromX = value;

	            if (gameObject._gradient) {
	                gameObject._gradient.fromX = gradientFromX;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'gradientFromY', {
	        get: function () {
	            return gradientFromY;
	        },
	        set: function (value) {
	            if (gradientFromY === value) {
	                return;
	            }

	            gradientFromY = value;

	            if (gameObject._gradient) {
	                gameObject._gradient.fromY = gradientFromY;
	            }
	        },
	    });


	    Object.defineProperty(gameObject, 'gradientToX', {
	        get: function () {
	            return gradientToX;
	        },
	        set: function (value) {
	            if (gradientToX === value) {
	                return;
	            }

	            gradientToX = value;

	            if (gameObject._gradient) {
	                gameObject._gradient.toX = gradientToX;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'gradientToY', {
	        get: function () {
	            return gradientToY;
	        },
	        set: function (value) {
	            if (gradientToY === value) {
	                return;
	            }

	            gradientToY = value;

	            if (gameObject._gradient) {
	                gameObject._gradient.toY = gradientToY;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'gradientSize', {
	        get: function () {
	            return gradientSize;
	        },
	        set: function (value) {
	            if (gradientSize === value) {
	                return;
	            }

	            gradientSize = value;

	            if (gameObject._gradient) {
	                gameObject._gradient.size = gradientSize;
	            }
	        },
	    });

	    gameObject.gradientColor = null;

	    AddClearEffectCallback(gameObject, 'gradientColor');

	    return gameObject;
	};

	var AddGrayscaleProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'grayscale', 1);
	    return gameObject;
	};

	var AddHueProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'hue', 1);
	    return gameObject;
	};

	var AddKodachromeProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'kodachrome');
	    return gameObject;
	};

	var AddLSDProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'lsd');
	    return gameObject;
	};

	var AddNegativeProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'negative');
	    return gameObject;
	};

	var AddPixelateProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'pixelate')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var pixelate;
	    Object.defineProperty(gameObject, 'pixelate', {
	        get: function () {
	            return pixelate;
	        },
	        set: function (value) {
	            if (pixelate === value) {
	                return;
	            }

	            pixelate = value;

	            if ((pixelate === null) || (pixelate === false)) {
	                if (gameObject._pixelateEffect) {
	                    fxFactory.remove(gameObject._pixelateEffect);
	                    gameObject._pixelateEffect = undefined;
	                }
	            } else {
	                if (!gameObject._pixelateEffect) {
	                    gameObject._pixelateEffect = fxFactory.addPixelate();
	                }
	                gameObject._pixelateEffect.amount = pixelate;
	            }

	        },
	    });

	    gameObject.pixelate = null;

	    AddClearEffectCallback(gameObject, 'pixelate');

	    return gameObject;
	};

	var AddPolaroidProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'polaroid');
	    return gameObject;
	};

	var AddRevealProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'revealLeft')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var revealLeft,
	        revealRight,
	        revealUp,
	        revealDown,
	        revealWidth = 0.1;

	    var ClearRevealFlags = function () {
	        revealLeft = null;
	        revealRight = null;
	        revealUp = null;
	        revealDown = null;
	    };

	    var RemoveEffect = function (gameObject) {
	        if (gameObject._revealEffect) {
	            fxFactory.remove(gameObject._revealEffect);
	            gameObject._revealEffect = undefined;
	        }
	    };

	    Object.defineProperty(gameObject, 'revealLeft', {
	        get: function () {
	            return revealLeft;
	        },
	        set: function (value) {
	            if (revealLeft === value) {
	                return;
	            }

	            ClearRevealFlags();

	            revealLeft = value;

	            if ((revealLeft === null) || (revealLeft === false)) {
	                RemoveEffect(gameObject);
	            } else {
	                if (!gameObject._revealEffect) {
	                    gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
	                }

	                gameObject._revealEffect.direction = 1;
	                gameObject._revealEffect.axis = 0;
	                gameObject._revealEffect.progress = revealLeft;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'revealRight', {
	        get: function () {
	            return revealRight;
	        },
	        set: function (value) {
	            if (revealRight === value) {
	                return;
	            }

	            ClearRevealFlags();

	            revealRight = value;

	            if ((revealRight === null) || (revealRight === false)) {
	                RemoveEffect(gameObject);
	            } else {
	                if (!gameObject._revealEffect) {
	                    gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
	                }
	                gameObject._revealEffect.direction = 0;
	                gameObject._revealEffect.axis = 0;
	                gameObject._revealEffect.progress = revealRight;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'revealUp', {
	        get: function () {
	            return revealUp;
	        },
	        set: function (value) {
	            if (revealUp === value) {
	                return;
	            }

	            ClearRevealFlags();

	            revealUp = value;

	            if ((revealUp === null) || (revealUp === false)) {
	                RemoveEffect(gameObject);
	            } else {
	                if (!gameObject._revealEffect) {
	                    gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
	                }
	                gameObject._revealEffect.direction = 1;
	                gameObject._revealEffect.axis = 1;
	                gameObject._revealEffect.progress = revealUp;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'revealDown', {
	        get: function () {
	            return revealDown;
	        },
	        set: function (value) {
	            if (revealDown === value) {
	                return;
	            }

	            ClearRevealFlags();

	            revealDown = value;

	            if ((revealDown === null) || (revealDown === false)) {
	                RemoveEffect(gameObject);
	            } else {
	                if (!gameObject._revealEffect) {
	                    gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
	                }
	                gameObject._revealEffect.direction = 0;
	                gameObject._revealEffect.axis = 1;
	                gameObject._revealEffect.progress = revealDown;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'revealWidth', {
	        get: function () {
	            return revealWidth;
	        },
	        set: function (value) {
	            if (revealWidth === value) {
	                return;
	            }

	            revealWidth = value;

	            if (gameObject._revealEffect) {
	                gameObject._revealEffect.wipeWidth = revealWidth;
	            }
	        },
	    });

	    gameObject.revealLeft = null;

	    AddClearEffectCallback(gameObject, 'revealLeft');
	    AddClearEffectCallback(gameObject, 'revealRight');
	    AddClearEffectCallback(gameObject, 'revealUp');
	    AddClearEffectCallback(gameObject, 'revealDown');

	    return gameObject;
	};

	var AddSaturateProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'saturate', 1);
	    return gameObject;
	};

	var AddSepiaProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'sepia');
	    return gameObject;
	};

	var AddShadowProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'shadowColor')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var shadowColor,
	        shadowX = 0,
	        shadowY = 0,
	        shadowDecay = 0.1,
	        shadowPower = 1,
	        shadowSamples = 6,
	        shadowIntensity = 1;
	    Object.defineProperty(gameObject, 'shadowColor', {
	        get: function () {
	            return shadowColor;
	        },
	        set: function (value) {
	            if (shadowColor === value) {
	                return;
	            }

	            shadowColor = value;

	            if ((shadowColor === null) || (shadowColor === false)) {
	                if (gameObject._shadow) {
	                    fxFactory.remove(gameObject._shadow);
	                    gameObject._shadow = undefined;
	                }
	            } else {
	                if (!gameObject._shadow) {
	                    gameObject._shadow = fxFactory.addShadow(shadowX, shadowY, shadowDecay, shadowPower, shadowColor, shadowSamples, shadowIntensity);
	                }

	                gameObject._shadow.color = shadowColor;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'shadowX', {
	        get: function () {
	            return shadowX;
	        },
	        set: function (value) {
	            if (shadowX === value) {
	                return;
	            }

	            shadowX = value;

	            if (gameObject._shadow) {
	                gameObject._shadow.x = shadowX;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'shadowY', {
	        get: function () {
	            return shadowY;
	        },
	        set: function (value) {
	            if (shadowY === value) {
	                return;
	            }

	            shadowY = value;

	            if (gameObject._shadow) {
	                gameObject._shadow.y = shadowY;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'decay', {
	        get: function () {
	            return shadowDecay;
	        },
	        set: function (value) {
	            if (shadowDecay === value) {
	                return;
	            }

	            shadowDecay = value;

	            if (gameObject._shadow) {
	                gameObject._shadow.decay = shadowDecay;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'shadowPower', {
	        get: function () {
	            return shadowPower;
	        },
	        set: function (value) {
	            if (shadowPower === value) {
	                return;
	            }

	            shadowPower = value;

	            if (gameObject._shadow) {
	                gameObject._shadow.power = shadowPower;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'shadowSamples', {
	        get: function () {
	            return shadowSamples;
	        },
	        set: function (value) {
	            if (shadowSamples === value) {
	                return;
	            }

	            shadowSamples = value;

	            if (gameObject._shadow) {
	                gameObject._shadow.samples = shadowSamples;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'shadowIntensity', {
	        get: function () {
	            return shadowIntensity;
	        },
	        set: function (value) {
	            if (shadowIntensity === value) {
	                return;
	            }

	            shadowIntensity = value;

	            if (gameObject._shadow) {
	                gameObject._shadow.intensity = shadowIntensity;
	            }
	        },
	    });

	    gameObject.shadowColor = null;

	    AddClearEffectCallback(gameObject, 'shadowColor');

	    return gameObject;
	};

	var AddShiftToBGRProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'shiftToBGR');
	    return gameObject;
	};

	var AddShineProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'shineSpeed')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var shineSpeed,
	        shineLineWidth = 0.5,
	        shineGradient = 3;
	    Object.defineProperty(gameObject, 'shineSpeed', {
	        get: function () {
	            return shineSpeed;
	        },
	        set: function (value) {
	            if (shineSpeed === value) {
	                return;
	            }

	            shineSpeed = value;

	            if ((shineSpeed === null) || (shineSpeed === false)) {
	                if (gameObject._shine) {
	                    fxFactory.remove(gameObject._shine);
	                    gameObject._shine = undefined;
	                }
	            } else {
	                if (!gameObject._shine) {
	                    gameObject._shine = fxFactory.addShine(shineSpeed, shineLineWidth, shineGradient);
	                }

	                gameObject._shine.speed = shineSpeed;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'shineLineWidth', {
	        get: function () {
	            return shineLineWidth;
	        },
	        set: function (value) {
	            if (shineLineWidth === value) {
	                return;
	            }

	            shineLineWidth = value;

	            if (gameObject._shine) {
	                gameObject._shine.lineWidth = shineLineWidth;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'shineGradient', {
	        get: function () {
	            return shineGradient;
	        },
	        set: function (value) {
	            if (shineGradient === value) {
	                return;
	            }

	            shineGradient = value;

	            if (gameObject._shine) {
	                gameObject._shine.gradient = shineGradient;
	            }
	        },
	    });

	    gameObject.shineSpeed = null;

	    AddClearEffectCallback(gameObject, 'shineSpeed');

	    return gameObject;
	};

	var AddTechnicolorProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'technicolor');
	    return gameObject;
	};

	var AddTiltShiftProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'tiltShiftRadius')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var tiltShiftRadius,
	        tiltShiftAmount = 1,
	        tiltShiftContrast = 0.2,
	        tiltShiftBlurX = 1,
	        tiltShiftBlurY = 1,
	        tiltShiftStrength = 1;
	    Object.defineProperty(gameObject, 'tiltShiftRadius', {
	        get: function () {
	            return tiltShiftRadius;
	        },
	        set: function (value) {
	            if (tiltShiftRadius === value) {
	                return;
	            }

	            tiltShiftRadius = value;

	            if ((tiltShiftRadius === null) || (tiltShiftRadius === false)) {
	                if (gameObject._tiltShift) {
	                    fxFactory.remove(gameObject._tiltShift);
	                    gameObject._tiltShift = undefined;
	                }
	            } else {
	                if (!gameObject._tiltShift) {
	                    gameObject._tiltShift = fxFactory.addTiltShift(tiltShiftRadius, tiltShiftAmount, tiltShiftContrast, tiltShiftBlurX, tiltShiftBlurY, tiltShiftStrength);
	                }

	                gameObject._tiltShift.radius = tiltShiftRadius;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'tiltShiftAmount', {
	        get: function () {
	            return tiltShiftAmount;
	        },
	        set: function (value) {
	            if (tiltShiftAmount === value) {
	                return;
	            }

	            tiltShiftAmount = value;

	            if (gameObject._tiltShift) {
	                gameObject._tiltShift.amount = tiltShiftAmount;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'tiltShiftContrast', {
	        get: function () {
	            return tiltShiftContrast;
	        },
	        set: function (value) {
	            if (tiltShiftContrast === value) {
	                return;
	            }

	            tiltShiftContrast = value;

	            if (gameObject._tiltShift) {
	                gameObject._tiltShift.contrast = tiltShiftContrast;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'tiltShiftBlurX', {
	        get: function () {
	            return tiltShiftBlurX;
	        },
	        set: function (value) {
	            if (tiltShiftBlurX === value) {
	                return;
	            }

	            tiltShiftBlurX = value;

	            if (gameObject._tiltShift) {
	                gameObject._tiltShift.blurX = tiltShiftBlurX;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'tiltShiftBlurY', {
	        get: function () {
	            return tiltShiftBlurY;
	        },
	        set: function (value) {
	            if (tiltShiftBlurY === value) {
	                return;
	            }

	            tiltShiftBlurY = value;

	            if (gameObject._tiltShift) {
	                gameObject._tiltShift.blurY = tiltShiftBlurY;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'tiltShiftStrength', {
	        get: function () {
	            return tiltShiftStrength;
	        },
	        set: function (value) {
	            if (tiltShiftStrength === value) {
	                return;
	            }

	            tiltShiftStrength = value;

	            if (gameObject._tiltShift) {
	                gameObject._tiltShift.strength = tiltShiftStrength;
	            }
	        },
	    });

	    gameObject.tiltShiftRadius = null;

	    AddClearEffectCallback(gameObject, 'tiltShiftRadius');

	    return gameObject;
	};

	var AddVignetteProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'vignetteRadius')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var vignetteRadius,
	        vignetteX = 0.5,
	        vignetteY = 0.5,
	        vignetteStrength = 0.5;
	    Object.defineProperty(gameObject, 'vignetteRadius', {
	        get: function () {
	            return vignetteRadius;
	        },
	        set: function (value) {
	            if (vignetteRadius === value) {
	                return;
	            }

	            vignetteRadius = value;

	            if ((vignetteRadius === null) || (vignetteRadius === false)) {
	                if (gameObject._vignette) {
	                    fxFactory.remove(gameObject._vignette);
	                    gameObject._vignette = undefined;
	                }
	            } else {
	                if (!gameObject._vignette) {
	                    gameObject._vignette = fxFactory.addVignette(vignetteX, vignetteY, vignetteRadius, vignetteStrength);
	                }

	                gameObject._vignette.radius = vignetteRadius;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'vignetteX', {
	        get: function () {
	            return vignetteX;
	        },
	        set: function (value) {
	            if (vignetteX === value) {
	                return;
	            }

	            vignetteX = value;

	            if (gameObject._vignette) {
	                gameObject._vignette.x = vignetteX;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'vignetteY', {
	        get: function () {
	            return vignetteY;
	        },
	        set: function (value) {
	            if (vignetteY === value) {
	                return;
	            }

	            vignetteY = value;

	            if (gameObject._vignette) {
	                gameObject._vignette.y = vignetteY;
	            }
	        },
	    });

	    Object.defineProperty(gameObject, 'vignetteStrength', {
	        get: function () {
	            return vignetteStrength;
	        },
	        set: function (value) {
	            if (vignetteStrength === value) {
	                return;
	            }

	            vignetteStrength = value;

	            if (gameObject._vignette) {
	                gameObject._vignette.strength = vignetteStrength;
	            }
	        },
	    });

	    gameObject.vignetteRadius = null;

	    AddClearEffectCallback(gameObject, 'vignetteRadius');

	    return gameObject;
	};

	var AddVintagePinholeProperties = function (gameObject) {
	    AddColorMatrixEffectPropertiesBase(gameObject, 'vintagePinhole');
	    return gameObject;
	};

	var AddWipeProperties = function (gameObject) {
	    // Don't attach properties again
	    if (HasProperty(gameObject, 'wipeLeft')) {
	        return gameObject;
	    }

	    var fxFactory = GetFXFactory(gameObject);
	    if (!fxFactory) {
	        return gameObject;
	    }

	    var wipeLeft,
	        wipeRight,
	        wipeUp,
	        wipeDown,
	        wipeWidth = 0.1;

	    var ClearWipeFlags = function () {
	        wipeLeft = null;
	        wipeRight = null;
	        wipeUp = null;
	        wipeDown = null;
	    };

	    var RemoveEffect = function (gameObject) {
	        if (gameObject._wipeEffect) {
	            fxFactory.remove(gameObject._wipeEffect);
	            gameObject._wipeEffect = undefined;
	        }
	    };

	    Object.defineProperty(gameObject, 'wipeLeft', {
	        get: function () {
	            return wipeLeft;
	        },
	        set: function (value) {
	            if (wipeLeft === value) {
	                return;
	            }

	            ClearWipeFlags();

	            wipeLeft = value;

	            if ((wipeLeft === null) || (wipeLeft === false)) {
	                RemoveEffect(gameObject);
	            } else {
	                if (!gameObject._wipeEffect) {
	                    gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
	                }

	                gameObject._wipeEffect.direction = 1;
	                gameObject._wipeEffect.axis = 0;
	                gameObject._wipeEffect.progress = wipeLeft;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'wipeRight', {
	        get: function () {
	            return wipeRight;
	        },
	        set: function (value) {
	            if (wipeRight === value) {
	                return;
	            }

	            ClearWipeFlags();

	            wipeRight = value;

	            if ((wipeRight === null) || (wipeRight === false)) {
	                RemoveEffect(gameObject);
	            } else {
	                if (!gameObject._wipeEffect) {
	                    gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
	                }
	                gameObject._wipeEffect.direction = 0;
	                gameObject._wipeEffect.axis = 0;
	                gameObject._wipeEffect.progress = wipeRight;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'wipeUp', {
	        get: function () {
	            return wipeUp;
	        },
	        set: function (value) {
	            if (wipeUp === value) {
	                return;
	            }

	            ClearWipeFlags();

	            wipeUp = value;

	            if ((wipeUp === null) || (wipeUp === false)) {
	                RemoveEffect(gameObject);
	            } else {
	                if (!gameObject._wipeEffect) {
	                    gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
	                }
	                gameObject._wipeEffect.direction = 1;
	                gameObject._wipeEffect.axis = 1;
	                gameObject._wipeEffect.progress = wipeUp;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'wipeDown', {
	        get: function () {
	            return wipeDown;
	        },
	        set: function (value) {
	            if (wipeDown === value) {
	                return;
	            }

	            ClearWipeFlags();

	            wipeDown = value;

	            if ((wipeDown === null) || (wipeDown === false)) {
	                RemoveEffect(gameObject);
	            } else {
	                if (!gameObject._wipeEffect) {
	                    gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
	                }
	                gameObject._wipeEffect.direction = 0;
	                gameObject._wipeEffect.axis = 1;
	                gameObject._wipeEffect.progress = wipeDown;
	            }

	        },
	    });

	    Object.defineProperty(gameObject, 'wipeWidth', {
	        get: function () {
	            return wipeWidth;
	        },
	        set: function (value) {
	            if (wipeWidth === value) {
	                return;
	            }

	            wipeWidth = value;

	            if (gameObject._wipeEffect) {
	                gameObject._wipeEffect.wipeWidth = wipeWidth;
	            }
	        },
	    });

	    gameObject.wipeLeft = null;

	    AddClearEffectCallback(gameObject, 'wipeLeft');
	    AddClearEffectCallback(gameObject, 'wipeRight');
	    AddClearEffectCallback(gameObject, 'wipeUp');
	    AddClearEffectCallback(gameObject, 'wipeDown');

	    return gameObject;
	};

	const EffectMap = {
	    barrel: AddBarrelProperties,
	    blackWhite: AddBlackWhiteProperties,
	    bloom: AddBloomProperties,
	    blur: AddBlurProperties,
	    bokeh: AddBokehProperties,
	    brightness: AddBrightnessProperties,
	    brown: AddBrownProperties,
	    circle: AddCircleProperties,
	    contrast: AddContrastProperties,
	    desaturate: AddDesaturateProperties,
	    desaturateLuminance: AddDesaturateLuminanceProperties,
	    displacement: AddDisplacementProperties,
	    glow: AddGlowProperties,
	    gradient: AddGradientProperties,
	    grayscale: AddGrayscaleProperties,
	    hue: AddHueProperties,
	    kodachrome: AddKodachromeProperties,
	    lsd: AddLSDProperties,
	    negative: AddNegativeProperties,
	    pixelate: AddPixelateProperties,
	    polaroid: AddPolaroidProperties,
	    reveal: AddRevealProperties,
	    saturate: AddSaturateProperties,
	    sepia: AddSepiaProperties,
	    shadow: AddShadowProperties,
	    shiftToBGR: AddShiftToBGRProperties,
	    shine: AddShineProperties,
	    technicolor: AddTechnicolorProperties,
	    tiltShift: AddTiltShiftProperties,
	    vignette: AddVignetteProperties,
	    vintagePinhole: AddVintagePinholeProperties,
	    wipe: AddWipeProperties
	};

	var AddEffectProperties = function (gameObject, config) {
	    if (config === undefined) {
	        config = true;
	    } else if (typeof (config) === 'string') {
	        config = { config: true };
	    } else if (Array.isArray(config)) {
	        var nameList = config;
	        var config = {};
	        for (var i = 0, cnt = nameList.length; i < cnt; i++) {
	            config[nameList[i]] = true;
	        }
	    }

	    if (config === true) {
	        // Enable all effect properties
	        for (var name in EffectMap) {
	            EffectMap[name](gameObject);
	        }
	    } else {
	        for (var name in config) {
	            if (config[name] && EffectMap[name]) {
	                EffectMap[name](gameObject);
	            }
	        }
	    }

	    return gameObject;
	};

	const RemoveItem$d = Phaser.Utils.Array.Remove;

	var AddMethods$1 = {
	    addGO(name, gameObject) {
	        this.remove(name, true);

	        if (this.useTintFadeEffect(gameObject)) {
	            AddTintRGBProperties(gameObject);
	        }

	        if (this.viewportCoordinateEnable) {
	            AddViewportCoordinateProperties(gameObject, this.viewport);
	        }

	        if (this.effectPropertiesConfig) {
	            AddEffectProperties(gameObject, this.effectPropertiesConfig);
	        }

	        gameObject
	            .setName(name)
	            .once('destroy', function () {
	                RemoveItem$d(this.removedGOs, gameObject);
	                if (this.isEmpty) {
	                    this.emit('empty');
	                }
	            }, this);

	        var bob = new this.BobClass(this, gameObject, name);
	        this.bobs[name] = bob;

	        return this;
	    },

	    add(name, ...args) {
	        var callback = this.createGameObjectCallback;
	        var scope = this.createGameObjectScope;
	        var gameObject = callback.call(scope, this.scene, ...args);
	        this.addGO(name, gameObject);

	        if (this.gameObjectDepth != null) { // Not undefined, null
	            gameObject.setDepth(this.gameObjectDepth);
	        }

	        var bob = this.get(name);
	        this.fadeBob(bob, 0, 1);

	        return this;
	    },
	};

	var RemoveMethods$1 = {
	    remove(name, ignoreFade) {
	        var bobs = this.get(name);
	        if (!bobs) {
	            return this;
	        } else if (!Array.isArray(bobs)) {
	            bobs = [bobs];
	        }

	        var self = this;
	        bobs.forEach(function (bob) {
	            delete self.bobs[bob.name];

	            var gameObject = bob.gameObject;
	            self.removedGOs.push(gameObject);
	            gameObject.setName();

	            if (!ignoreFade) {
	                self.fadeBob(
	                    bob,                  // bob
	                    undefined,            // fromValue
	                    0,                    // toValue
	                    function () {         // onComplete
	                        bob.destroy();
	                    }
	                );
	            } else {
	                bob.destroy();
	            }
	        });

	        return this;
	    },

	    removeAll() {
	        var bobs = this.bobs;
	        for (var name in bobs) {
	            this.remove(name);
	        }
	        return this;
	    },

	    clear(destroyChild) {
	        if (destroyChild === undefined) {
	            destroyChild = true;
	        }
	        var bobs = this.bobs;
	        for (var name in bobs) {
	            if (destroyChild) {
	                bobs[name].destroy();
	            }
	            delete bobs[name];
	        }
	        this.removedGOs.length = 0;
	        return this;
	    }
	};

	var PropertyMethods = {
	    hasProperty(name, property) {
	        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
	        if (!bob) {
	            return false;
	        }

	        return bob.hasProperty(property);
	    },

	    getProperty(name, property) {
	        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
	        if (!bob) {
	            return undefined;
	        }

	        return bob.getProperty(property);
	    },

	    isNumberProperty(name, property) {
	        var value = this.getProperty(name, property);
	        return typeof (value) === 'number';
	    },

	    setProperty(name, property, value) {
	        var bobs = this.get(name);
	        if (!bobs) {
	            return this;
	        } else if (!Array.isArray(bobs)) {
	            bobs = [bobs];
	        }

	        if (this.symbols &&
	            (typeof (value) === 'string') &&
	            this.isNumberProperty(name, property)
	        ) {
	            if (value in this.symbols) {
	                value = this.symbols[value];
	            } else {
	                console.warn(`Can't find symbol ${value}`);
	            }
	        }

	        bobs.forEach(function (bob) {
	            bob.setProperty(property, value);
	        });

	        return this;
	    },

	    easeProperty(name, config) {
	        var bobs = this.get(name);
	        if (!bobs) {
	            return this;
	        } else if (!Array.isArray(bobs)) {
	            bobs = [bobs];
	        }

	        var value = config.value;
	        var property = config.property;

	        if (this.symbols &&
	            (typeof (value) === 'string') &&
	            this.isNumberProperty(name, property) &&
	            (value in this.symbols)
	        ) {
	            config.value = this.symbols[value];
	        }

	        bobs.forEach(function (bob) {
	            bob.easeProperty(config);
	        });

	        return this;
	    },

	    hasTweenTask(name, property) {
	        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
	        if (!bob) {
	            return false;
	        }

	        return bob.tweens.hasOwnProperty(property);
	    },

	    getTweenTask(name, property) {
	        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
	        if (!bob) {
	            return null;
	        }

	        return bob.tweens[property] || null;
	    }
	};

	var CallMethods = {
	    hasMethod(name, methodName) {
	        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
	        if (!bob) {
	            return false;
	        }

	        return bob.hasMethod(methodName);
	    },


	    call(name, methodName, ...parameters) {
	        var bobs = this.get(name);
	        if (!bobs) {
	            return this;
	        } else if (!Array.isArray(bobs)) {
	            bobs = [bobs];
	        }

	        bobs.forEach(function (bob) {
	            bob.call(methodName, ...parameters);
	        });

	        return this;
	    },
	};

	var DataMethods$2 = {
	    hasData(name, dataKey) {
	        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
	        if (!bob) {
	            return false;
	        }

	        return bob.hasData(dataKey);
	    },

	    getData(name, dataKey) {
	        if (!this.has(name)) {
	            return undefined;
	        }
	        return this.get(name).getData(dataKey);
	    },

	    setData(name, dataKey, value) {
	        var bobs = this.get(name);
	        if (!bobs) {
	            return this;
	        } else if (!Array.isArray(bobs)) {
	            bobs = [bobs];
	        }

	        bobs.forEach(function (bob) {
	            bob.setData(dataKey, value);
	        });

	        return this;
	    },
	};

	const FadeTint = 0;
	const FadeAlpha = 1;
	const FadeRevealUp = 2;
	const FadeRevealDown = 3;
	const FadeRevealLeft = 4;
	const FadeRevealRight = 5;

	const FadeMode = {
	    tint: FadeTint,
	    alpha: FadeAlpha,
	    revealUp: FadeRevealUp,
	    revealDown: FadeRevealDown,
	    revealLeft: FadeRevealLeft,
	    revealRight: FadeRevealRight,
	};

	var FadeMethods$1 = {
	    setGOFadeMode(fadeMode) {
	        if (typeof (fadeMode) === 'string') {
	            fadeMode = FadeMode[fadeMode];
	        }

	        this.fadeMode = fadeMode;
	        return this;
	    },

	    setGOFadeTime(time) {
	        this.fadeTime = time;
	        return this;
	    },

	    useTintFadeEffect(gameObject) {
	        return ((this.fadeMode === undefined) || (this.fadeMode === FadeTint)) &&
	            (this.fadeTime > 0) && (gameObject.setTint !== undefined);
	    },

	    useAlphaFadeEffect(gameObject) {
	        return ((this.fadeMode === undefined) || (this.fadeMode === FadeAlpha)) &&
	            (this.fadeTime > 0) && (gameObject.setAlpha !== undefined);
	    },

	    useRevealEffect(gameObject) {
	        return ((this.fadeMode >= FadeRevealUp) && (this.fadeMode <= FadeRevealRight)) &&
	            (this.fadeTime > 0) && (gameObject.preFX || gameObject.postFX);
	    },

	    fadeBob(bob, fromValue, toValue, onComplete) {
	        var gameObject = bob.gameObject;
	        if (this.useTintFadeEffect(gameObject)) {
	            if (fromValue !== undefined) {
	                bob.setProperty('tintGray', 255 * fromValue);
	            }
	            bob.easeProperty({
	                property: 'tintGray',
	                value: Math.floor(255 * toValue),
	                duration: this.fadeTime,
	                delay: 0,
	                ease: 'Linear',
	                repeat: 0,
	                yoyo: false,
	                from: false,
	                complete: onComplete
	            });

	        } else if (this.useAlphaFadeEffect(gameObject)) {
	            if (fromValue !== undefined) {
	                bob.setProperty('alpha', fromValue);
	            }
	            bob.easeProperty({
	                property: 'alpha',
	                value: toValue,
	                duration: this.fadeTime,
	                delay: 0,
	                ease: 'Linear',
	                repeat: 0,
	                yoyo: false,
	                from: false,
	                complete: onComplete
	            });

	        } else if (this.useRevealEffect(gameObject)) {
	            AddEffectProperties(gameObject, 'reveal');
	            var propertyName;
	            switch (this.fadeMode) {
	                case FadeRevealUp: propertyName = 'revealUp'; break;
	                case FadeRevealDown: propertyName = 'revealDown'; break;
	                case FadeRevealLeft: propertyName = 'revealLeft'; break;
	                case FadeRevealRight: propertyName = 'revealRight'; break;
	            }

	            if (fromValue === undefined) {
	                fromValue = 0;
	            }
	            gameObject[propertyName] = fromValue;
	            bob.easeProperty({
	                property: propertyName,
	                value: toValue,
	                duration: this.fadeTime,
	                delay: 0,
	                ease: 'Linear',
	                repeat: 0,
	                yoyo: false,
	                from: false,
	                complete: onComplete
	            });

	            bob.getTweenTask(propertyName).once('complete', function () {
	                gameObject[propertyName] = null;
	            });

	        } else {
	            if (onComplete) {
	                onComplete(gameObject);
	            }

	        }

	        return this;
	    }

	};

	var GetDisplayWidth = function (gameObject) {
	    if (gameObject.displayWidth !== undefined) {
	        return gameObject.displayWidth;
	    } else {
	        return gameObject.width;
	    }
	};

	var GetDisplayHeight = function (gameObject) {
	    if (gameObject.displayHeight !== undefined) {
	        return gameObject.displayHeight;
	    } else {
	        return gameObject.height;
	    }
	};

	const Rectangle$6 = Phaser.Geom.Rectangle;
	const Vector2 = Phaser.Math.Vector2;
	const RotateAround$6 = Phaser.Math.RotateAround;
	const P3Container$2 = Phaser.GameObjects.Container;

	var GetBounds = function (gameObject, output) {
	    if (output === undefined) {
	        output = new Rectangle$6();
	    } else if (output === true) {
	        if (GlobRect$2 === undefined) {
	            GlobRect$2 = new Rectangle$6();
	        }
	        output = GlobRect$2;
	    }

	    if (gameObject.getBounds && !(gameObject instanceof P3Container$2)) {
	        return gameObject.getBounds(output);
	    }

	    //  We can use the output object to temporarily store the x/y coords in:

	    var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;

	    // Instead of doing a check if parent container is
	    // defined per corner we only do it once.
	    if (gameObject.parentContainer) {
	        var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();

	        GetTopLeft(gameObject, output);
	        parentMatrix.transformPoint(output.x, output.y, output);

	        TLx = output.x;
	        TLy = output.y;

	        GetTopRight(gameObject, output);
	        parentMatrix.transformPoint(output.x, output.y, output);

	        TRx = output.x;
	        TRy = output.y;

	        GetBottomLeft(gameObject, output);        parentMatrix.transformPoint(output.x, output.y, output);

	        BLx = output.x;
	        BLy = output.y;

	        GetBottomRight(gameObject, output);
	        parentMatrix.transformPoint(output.x, output.y, output);

	        BRx = output.x;
	        BRy = output.y;
	    }
	    else {
	        GetTopLeft(gameObject, output);

	        TLx = output.x;
	        TLy = output.y;

	        GetTopRight(gameObject, output);
	        TRx = output.x;
	        TRy = output.y;

	        GetBottomLeft(gameObject, output);
	        BLx = output.x;
	        BLy = output.y;

	        GetBottomRight(gameObject, output);

	        BRx = output.x;
	        BRy = output.y;
	    }

	    output.x = Math.min(TLx, TRx, BLx, BRx);
	    output.y = Math.min(TLy, TRy, BLy, BRy);
	    output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
	    output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;

	    return output;
	};

	var GlobRect$2 = undefined;

	var GetTopLeft = function (gameObject, output, includeParent) {
	    if (output === undefined) {
	        output = new Vector2();
	    } else if (output === true) {
	        if (GlobVector === undefined) {
	            GlobVector = new Vector2();
	        }
	        output = GlobVector;
	    }

	    if (gameObject.getTopLeft) {
	        return gameObject.getTopLeft(output);
	    }

	    output.x = gameObject.x - (GetDisplayWidth(gameObject) * gameObject.originX);
	    output.y = gameObject.y - (GetDisplayHeight(gameObject) * gameObject.originY);

	    return PrepareBoundsOutput(gameObject, output, includeParent);
	};

	var GetTopRight = function (gameObject, output, includeParent) {
	    if (output === undefined) {
	        output = new Vector2();
	    } else if (output === true) {
	        if (GlobVector === undefined) {
	            GlobVector = new Vector2();
	        }
	        output = GlobVector;
	    }

	    if (gameObject.getTopRight) {
	        return gameObject.getTopRight(output);
	    }

	    output.x = (gameObject.x - (GetDisplayWidth(gameObject) * gameObject.originX)) + GetDisplayWidth(gameObject);
	    output.y = gameObject.y - (GetDisplayHeight(gameObject) * gameObject.originY);

	    return PrepareBoundsOutput(gameObject, output, includeParent);
	};

	var GetBottomLeft = function (gameObject, output, includeParent) {
	    if (output === undefined) {
	        output = new Vector2();
	    } else if (output === true) {
	        if (GlobVector === undefined) {
	            GlobVector = new Vector2();
	        }
	        output = GlobVector;
	    }

	    if (gameObject.getBottomLeft) {
	        return gameObject.getBottomLeft(output);
	    }

	    output.x = gameObject.x - (GetDisplayWidth(gameObject) * gameObject.originX);
	    output.y = (gameObject.y - (GetDisplayHeight(gameObject) * gameObject.originY)) + GetDisplayHeight(gameObject);

	    return PrepareBoundsOutput(gameObject, output, includeParent);
	};

	var GetBottomRight = function (gameObject, output, includeParent) {
	    if (output === undefined) {
	        output = new Vector2();
	    } else if (output === true) {
	        if (GlobVector === undefined) {
	            GlobVector = new Vector2();
	        }
	        output = GlobVector;
	    }

	    if (gameObject.getBottomRight) {
	        return gameObject.getBottomRight(output);
	    }

	    output.x = (gameObject.x - (GetDisplayWidth(gameObject) * gameObject.originX)) + GetDisplayWidth(gameObject);
	    output.y = (gameObject.y - (GetDisplayHeight(gameObject) * gameObject.originY)) + GetDisplayHeight(gameObject);

	    return PrepareBoundsOutput(gameObject, output, includeParent);
	};

	var GlobVector = undefined;

	var PrepareBoundsOutput = function (gameObject, output, includeParent) {
	    if (includeParent === undefined) { includeParent = false; }

	    if (gameObject.rotation !== 0) {
	        RotateAround$6(output, gameObject.x, gameObject.y, gameObject.rotation);
	    }

	    if (includeParent && gameObject.parentContainer) {
	        var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();

	        parentMatrix.transformPoint(output.x, output.y, output);
	    }

	    return output;
	};

	const GetValue$2a = Phaser.Utils.Objects.GetValue;

	var DrawBounds$2 = function (gameObjects, graphics, config) {
	    var strokeColor, lineWidth, fillColor, fillAlpha, padding;
	    if (typeof (config) === 'number') {
	        strokeColor = config;
	    } else {
	        strokeColor = GetValue$2a(config, 'color');
	        lineWidth = GetValue$2a(config, 'lineWidth');
	        fillColor = GetValue$2a(config, 'fillColor');
	        fillAlpha = GetValue$2a(config, 'fillAlpha', 1);
	        padding = GetValue$2a(config, 'padding', 0);
	    }

	    if (Array.isArray(gameObjects)) {
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            Draw(gameObjects[i], graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
	        }
	    } else {
	        Draw(gameObjects, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
	    }
	};

	var Draw = function (gameObject, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding) {
	    var canDrawBound = gameObject.getBounds ||
	        ((gameObject.width !== undefined) && (gameObject.height !== undefined));
	    if (!canDrawBound) {
	        return;
	    }

	    if (strokeColor === undefined) { strokeColor = 0xffffff; }
	    if (lineWidth === undefined) { lineWidth = 1; }
	    if (fillColor === undefined) { fillColor = null; }    if (fillAlpha === undefined) { fillAlpha = 1; }    if (padding === undefined) { padding = 0; }

	    var p0 = GetTopLeft(gameObject, Points[0]);
	    p0.x -= padding;
	    p0.y -= padding;

	    var p1 = GetTopRight(gameObject, Points[1]);
	    p1.x += padding;
	    p1.y -= padding;

	    var p2 = GetBottomRight(gameObject, Points[2]);
	    p2.x += padding;
	    p2.y += padding;

	    var p3 = GetBottomLeft(gameObject, Points[3]);
	    p3.x -= padding;
	    p3.y += padding;

	    if (fillColor !== null) {
	        graphics
	            .fillStyle(fillColor, fillAlpha)
	            .fillPoints(Points, true, true);
	    }
	    if (strokeColor !== null) {
	        graphics
	            .lineStyle(lineWidth, strokeColor)
	            .strokePoints(Points, true, true);
	    }

	};

	var Points = [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }];

	var DrawGameObjectsBounds = function (graphics, config) {
	    this.forEachGO(function (gameObject) {
	        if (gameObject.drawBounds) {
	            gameObject.drawBounds(graphics, config);
	        } else {
	            DrawBounds$2(gameObject, graphics, config);
	        }
	    });
	    return this;
	};

	var GetCameraByName = function (scene, name) {
	    var cameraManager = scene.cameras;
	    var camera;
	    if (name === undefined) {
	        camera = cameraManager.main;
	    } else {
	        var cameraNameType = typeof (name);
	        switch (cameraNameType) {
	            case 'string':
	                camera = cameraManager.getCamera(name);
	                break;

	            case 'number':
	                camera = cameraManager.cameras[name];
	                break;

	            default:
	                camera = name;
	                break;
	        }
	    }

	    return camera;
	};

	var CameraMethods$2 = {
	    setCamera(goName, cameraName) {
	        var bob = this.get(goName);
	        if (!bob) {
	            return this;
	        }

	        var camera = GetCameraByName(this.scene, cameraName);
	        if (!camera) {
	            return this;
	        }

	        bob.gameObject.cameraFilter = 0xffffffff ^ camera.id;
	        bob.camera = camera;

	        return this;
	    },

	    getCamera(goName) {
	        var bob = this.get(goName);
	        if (!bob) {
	            return null;
	        }

	        return bob.camera;
	    }
	};

	var Methods$e = {
	    drawGameObjectsBounds: DrawGameObjectsBounds,
	};

	Object.assign(
	    Methods$e,
	    GetMethods,
	    AddMethods$1,
	    RemoveMethods$1,
	    PropertyMethods,
	    CallMethods,
	    DataMethods$2,
	    FadeMethods$1,
	    CameraMethods$2,
	);

	const CameraClass = Phaser.Cameras.Scene2D.BaseCamera;

	var IsCameraObject = function (object) {
	    return (object instanceof CameraClass);
	};

	const Rectangle$5 = Phaser.Geom.Rectangle;

	var GetViewport = function (scene, camera, out) {
	    if (!IsCameraObject(camera)) {
	        out = camera;
	        camera = undefined;
	    }

	    if (out === undefined) {
	        out = new Rectangle$5();
	    } else if (out === true) {
	        out = globRect;
	    }

	    if (camera) {
	        return scene.scale.getViewPort(camera, out);
	    } else {
	        return scene.scale.getViewPort(out);
	    }
	};

	var globRect = new Rectangle$5();

	const GetValue$29 = Phaser.Utils.Objects.GetValue;

	class GOManager {
	    constructor(scene, config) {
	        this.scene = scene;

	        this.BobClass = GetValue$29(config, 'BobClass', BobBase);
	        this.setCreateGameObjectCallback(
	            GetValue$29(config, 'createGameObject'),
	            GetValue$29(config, 'createGameObjectScope')
	        );
	        this.setEventEmitter(GetValue$29(config, 'eventEmitter', undefined));

	        this.setGameObjectDepth(GetValue$29(config, 'depth', undefined));

	        var fadeConfig = GetValue$29(config, 'fade', 500);
	        if (typeof (fadeConfig) === 'number') {
	            this.setGOFadeMode();
	            this.setGOFadeTime(fadeConfig);
	        } else {
	            this.setGOFadeMode(GetValue$29(fadeConfig, 'mode'));
	            this.setGOFadeTime(GetValue$29(fadeConfig, 'time', 500));
	        }

	        var viewportCoordinateConfig = GetValue$29(config, 'viewportCoordinate', false);
	        if (viewportCoordinateConfig !== false) {
	            this.setViewportCoordinateEnable(GetValue$29(config, 'enable', true));
	            this.setViewport(GetValue$29(viewportCoordinateConfig, 'viewport'));
	        } else {
	            this.setViewportCoordinateEnable(false);
	        }

	        var effectPropertiesConfig = GetValue$29(config, 'effectProperties', false);
	        this.setEffectPropertiesConfig(effectPropertiesConfig);

	        this.setSymbols(GetValue$29(config, 'symbols'));

	        this.bobs = {};
	        this.removedGOs = [];
	        this._timeScale = 1;

	        this.name = GetValue$29(config, 'name');
	    }

	    destroy(fromScene) {
	        this.clear(!fromScene);
	        this.createGameObjectCallback = undefined;
	        this.viewport = undefined;
	        this.scene = undefined;
	    }

	    set timeScale(timeScale) {
	        if (this._timeScale === timeScale) {
	            return;
	        }

	        this._timeScale = timeScale;

	        var bobs = this.bobs;
	        for (var name in bobs) {
	            bobs[name].setTimeScale(timeScale);
	        }
	    }

	    get timeScale() {
	        return this._timeScale;
	    }

	    setTimeScale(timeScale) {
	        this.timeScale = timeScale;
	        return this;
	    }

	    setCreateGameObjectCallback(callback, scope) {
	        this.createGameObjectCallback = callback;
	        this.createGameObjectScope = scope;
	        return this;
	    }

	    setGameObjectDepth(depth) {
	        this.gameObjectDepth = depth;
	        return this;
	    }

	    setViewportCoordinateEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }

	        this.viewportCoordinateEnable = enable;
	        return this;
	    }

	    setEffectPropertiesConfig(config) {
	        if (config === undefined) {
	            config = true;
	        }

	        this.effectPropertiesConfig = config;
	        return this;
	    }

	    setViewport(viewport) {
	        if (viewport === undefined) {
	            viewport = GetViewport(this.scene, this.scene.cameras.main);
	        }

	        this.viewport = viewport;
	        return this;
	    }

	    setSymbols(symbols) {
	        this.symbols = symbols;
	        return this;
	    }

	    get isEmpty() {
	        return IsEmpty(this.bobs) && (this.removedGOs.length === 0);
	    }

	}

	Object.assign(
	    GOManager.prototype,
	    EventEmitterMethods$1,
	    Methods$e
	);

	const GameObjectClass = Phaser.GameObjects.GameObject;
	var IsGameObject = function (object) {
	    return (object instanceof GameObjectClass);
	};

	const LayerClass = Phaser.GameObjects.Layer;

	var IsLayerGameObject = function (gameObject) {
	    return (gameObject instanceof LayerClass);
	};

	var GetLayer = function (gameObject) {
	    var layer = gameObject.displayList;
	    if (!IsLayerGameObject(layer)) {
	        return null;
	    }

	    return layer;

	};

	var SortGameObjectsByDepth = function (gameObjects, descending) {
	    if (gameObjects.length <= 1) {
	        return gameObjects;
	    }

	    if (descending === undefined) {
	        descending = false;
	    }

	    var itemList;
	    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	        var gameObject = gameObjects[i];
	        if (gameObject.displayList) {
	            // Inside a scene or a layer
	            itemList = gameObject.displayList; // displayList
	        } else if (gameObject.parentContainer) {
	            // Inside a container
	            itemList = gameObject.parentContainer.list; // array
	        }

	        if (itemList) {
	            break;
	        }
	    }

	    if (!itemList) {
	        itemList = gameObject.scene.sys.displayList;  // displayList
	        // ??
	    }

	    if (itemList.depthSort) {
	        // Is a displayList object
	        itemList.depthSort();
	        itemList = itemList.list;
	        // itemList is an array now
	    }

	    // itemList is an array
	    if (descending) {
	        gameObjects.sort(function (childA, childB) {
	            return itemList.indexOf(childB) - itemList.indexOf(childA);
	        });

	    } else {
	        gameObjects.sort(function (childA, childB) {
	            return itemList.indexOf(childA) - itemList.indexOf(childB);
	        });

	    }

	    return gameObjects;
	};

	var LayerMethods = {
	    getLayer(name) {
	        return this.getGO(name);
	    },

	    getLayers(out) {
	        if (out === undefined) {
	            out = [];
	        }
	        this.forEachGO(function (gameObject) {
	            out.push(gameObject);
	        });
	        SortGameObjectsByDepth(out, false);
	        return out;
	    },

	    addToLayer(name, gameObjects) {
	        var layer = this.getGO(name);
	        if (!layer) {
	            console.warn(`[LayerManager] Can't get layer "${name}"`);
	            return;
	        }

	        if (!Array.isArray(gameObjects)) {
	            gameObjects = [gameObjects];
	        }

	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            var gameObject = gameObjects[i];
	            if (gameObject.isRexContainerLite) {
	                gameObject.addToLayer(layer);
	            } else {
	                layer.add(gameObject);
	            }
	        }

	        if (layer.scrollFactorX !== undefined) {
	            gameObject.setScrollFactor(layer.scrollFactorX, layer.scrollFactorY);
	        }

	        return this;
	    },

	    addToBottomLayer(gameObjects) {
	        var bottomLayer = this.getLayers()[0];
	        this.addToLayer(bottomLayer.goName, gameObjects);
	        return this;
	    },

	    addToTopLayer(gameObjects) {
	        var layers = this.getLayers();
	        var topLayer = layers[layers.length - 1];
	        this.addToLayer(topLayer.goName, gameObjects);
	        return this;
	    },

	    removeFromLayer(name, gameObject, addToScene) {
	        var layer = this.getGO(name);
	        if (!layer) {
	            console.warn(`[LayerManager] Can't get layer "${name}"`);
	            return;
	        }

	        if (addToScene === undefined) {
	            addToScene = true;
	        }

	        if (gameObject.isRexContainerLite) {
	            gameObject.removeFromLayer(layer, addToScene);
	        } else {
	            layer.remove(gameObject);
	            if (addToScene) {
	                gameObject.addToDisplayList();
	            }
	        }

	        return this;
	    },

	    clearLayer(name, destroyChildren) {
	        if (destroyChildren === undefined) {
	            destroyChildren = true;
	        }

	        var layer = this.getGO(name);
	        if (!layer) {
	            console.warn(`Can't get layer "${name}"`);
	            return;
	        }

	        if (destroyChildren) {
	            var children = layer.getAll();
	            for (var i = 0, cnt = children.length; i < cnt; i++) {
	                children[i].destroy();
	            }
	        } else {
	            layer.removeAll();
	        }

	        return this;
	    },

	};

	var ScrollFactorMethods = {
	    setScrollFactor(name, scrollFactorX, scrollFactorY) {
	        if (scrollFactorY === undefined) {
	            scrollFactorY = scrollFactorX;
	        }

	        var layer = this.getLayer(name);
	        if (!layer) {
	            return this;
	        }
	        layer.scrollFactorX = scrollFactorX;
	        layer.scrollFactorY = scrollFactorY;
	        var children = layer.getAll();
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            children[i].setScrollFactor(scrollFactorX, scrollFactorY);
	        }

	        return this;
	    }
	};

	const ArrayUtils$1 = Phaser.Utils.Array;

	const BringMeToTop = function () {
	    var list;
	    if (this.parentContainer) {
	        list = this.parentContainer.list;
	    } else if (this.displayList) {
	        list = this.displayList.list;
	    }
	    if (!list) {
	        return this;
	    }

	    ArrayUtils$1.BringToTop(list, this);

	    return this;
	};

	const SendMeToBack = function () {
	    var list;
	    if (this.parentContainer) {
	        list = this.parentContainer.list;
	    } else if (this.displayList) {
	        list = this.displayList.list;
	    }
	    if (!list) {
	        return this;
	    }

	    ArrayUtils$1.SendToBack(list, this);

	    return this;
	};

	const MoveMyDepthBelow = function (gameObject) {
	    var list;
	    if (gameObject.parentContainer) {
	        list = gameObject.parentContainer.list;
	        if (list.indexOf(this) === -1) {
	            gameObject.parentContainer.add(this);
	        }
	    } else if (gameObject.displayList) {
	        list = gameObject.displayList.list;
	        if (list.indexOf(this) === -1) {
	            gameObject.displayList.add(this);
	        }
	    }
	    if (!list) {
	        return this;
	    }

	    ArrayUtils$1.MoveBelow(list, this, gameObject);

	    return this;
	};

	const MoveMyDepthAbove = function (gameObject) {
	    var list;
	    if (gameObject.parentContainer) {
	        list = gameObject.parentContainer.list;
	        if (list.indexOf(this) === -1) {
	            if (gameObject.isRexContainerLite) {
	                gameObject.addToContainer(gameObject.parentContainer);
	            } else {
	                gameObject.parentContainer.add(gameObject);
	            }
	        }
	    } else if (gameObject.displayList) {
	        list = gameObject.displayList.list;
	        if (list.indexOf(this) === -1) {
	            if (gameObject.isRexContainerLite) {
	                gameObject.addToLayer(gameObject.displayList);
	            } else {
	                gameObject.displayList.add(gameObject);
	            }
	        }
	    }
	    if (!list) {
	        return this;
	    }

	    ArrayUtils$1.MoveAbove(list, this, gameObject);

	    return this;
	};

	var DisplayListMethods = {
	    bringMeToTop: BringMeToTop,

	    sendMeToBack: SendMeToBack,

	    moveMyDepthBelow: MoveMyDepthBelow,

	    moveMyDepthAbove: MoveMyDepthAbove,
	};

	var DepthMethods = {

	    bringLayerToTop(layerName) {
	        var layer = this.getLayer(layerName);
	        if(!layer) {
	            return this;
	        }

	        DisplayListMethods.bringMeToTop.call(layer);

	        return this;
	    },

	    sendLayerToBack(layerName) {
	        var layer = this.getLayer(layerName);
	        if(!layer) {
	            return this;
	        }

	        DisplayListMethods.sendMeToBack.call(layer);

	        return this;
	    },

	    moveLayerBelow(layerName, baseLayerName) {
	        if (layerName === baseLayerName) {
	            return this;
	        }

	        var layer = this.getLayer(layerName);
	        var baseLayer = this.getLayer(baseLayerName);
	        if (!layer || !baseLayer) {
	            return this;
	        }

	        DisplayListMethods.moveMyDepthBelow.call(layer, baseLayer);

	        return this;
	    },

	    moveLayerAbove(layerName, baseLayerName) {
	        if (layerName === baseLayerName) {
	            return this;
	        }

	        var layer = this.getLayer(layerName);
	        var baseLayer = this.getLayer(baseLayerName);
	        if (!layer || !baseLayer) {
	            return this;
	        }

	        DisplayListMethods.moveMyDepthAbove.call(layer, baseLayer);

	        return this;
	    },

	};

	const SetCamera = GOManager.prototype.setCamera;
	var CameraMethods$1 = {
	    setCamera(layerName, cameraName) {
	        // Add a new camera if target camera is not existing
	        var camera = GetCameraByName(this.scene, cameraName);
	        if (!camera) {
	            camera = this.scene.cameras.add(undefined, undefined, undefined, undefined, false, cameraName);
	        }
	        SetCamera.call(this, layerName, camera);
	        return this;
	    },
	};

	var methods$m = {

	};

	Object.assign(
	    methods$m,
	    LayerMethods,
	    ScrollFactorMethods,
	    DepthMethods,
	    CameraMethods$1,
	);

	const GetValue$28 = Phaser.Utils.Objects.GetValue;

	class LayerManager extends GOManager {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        } else if (Array.isArray(config)) {
	            config = {
	                layers: config
	            };
	        }

	        if (!config.hasOwnProperty('fade')) {
	            config.fade = 0;
	        }

	        config.viewportCoordinate = false;

	        super(scene, config);

	        var rootLayer = GetValue$28(config, 'rootLayer');
	        this.setRootLayer(rootLayer);

	        var initLayers = GetValue$28(config, 'layers');
	        if (initLayers) {
	            for (var i = 0, cnt = initLayers.length; i < cnt; i++) {
	                var layerConfig = initLayers[i];
	                if (typeof (layerConfig) === 'string') {
	                    this.add(layerConfig);
	                } else {
	                    var layerName = layerConfig.name;

	                    this.add(layerName);

	                    var scrollFactor = layerConfig.scrollFactor;
	                    var scrollFactorX = GetValue$28(layerConfig, 'scrollFactorX', scrollFactor);
	                    var scrollFactorY = GetValue$28(layerConfig, 'scrollFactorY', scrollFactor);
	                    if (scrollFactorX !== undefined) {
	                        this.setScrollFactor(layerName, scrollFactorX, scrollFactorY);
	                    }

	                    this.setCamera(layerName, layerConfig.cameraName);

	                }
	            }
	        }
	    }

	    setCreateGameObjectCallback(callback, scope) {
	        if (!callback) {
	            callback = CreateLayer;
	        }
	        super.setCreateGameObjectCallback(callback, scope);
	        return this;
	    }

	    setRootLayer(rootLayer) {
	        if (rootLayer === this.rootLayer) {
	            return this;
	        }

	        var currentLayers = this.getAllGO();
	        if (rootLayer) {
	            rootLayer.add(currentLayers);
	        } else {
	            this.scene.displayList.add(currentLayers);
	        }

	        this.rootLayer = rootLayer;

	        return this;
	    }

	    // Override
	    addGO(name, gameObject) {
	        super.addGO(name, gameObject);
	        gameObject.name = name;

	        if (this.rootLayer) {
	            this.rootLayer.add(gameObject);
	        }

	        return this;
	    }

	    // Override
	    get(name, out) {
	        if (IsGameObject(name)) {
	            var layer = GetLayer(name);
	            if (!layer) {
	                return undefined;
	            }
	            name = layer.name;
	            if (!name) {
	                return undefined;
	            }
	        }

	        return super.get(name, out);
	    }

	}

	var CreateLayer = function (scene, depth) {
	    var layer = scene.add.layer();
	    if (depth !== undefined) {
	        layer.setDepth(depth);
	    }
	    return layer;
	};

	Object.assign(
	    LayerManager.prototype,
	    methods$m
	);

	const SceneClass = Phaser.Scene;
	var IsSceneObject = function (object) {
	    return (object instanceof SceneClass);
	};

	var GetSoundManager = function (game) {
	    if (IsSceneObject(game)) {
	        return game.sys.sound;
	    }
	    return game.sound;
	};

	var HasaAudio = function (key) {
	    return this.sound.game.cache.audio.has(key);
	};

	var GetSceneObject = function (object) {
	    if ((object == null) || (typeof (object) !== 'object')) {
	        return null;
	    } else if (IsSceneObject(object)) { // object = scene
	        return object;
	    } else if (object.scene && IsSceneObject(object.scene)) { // object = game object
	        return object.scene;
	    } else if (object.parent && object.parent.scene && IsSceneObject(object.parent.scene)) { // parent = bob object
	        return object.parent.scene;
	    } else {
	        return null;
	    }
	};

	const GameClass = Phaser.Game;
	var IsGame = function (object) {
	    return (object instanceof GameClass);
	};

	var GetGame = function (object) {
	    if ((object == null) || (typeof (object) !== 'object')) {
	        return null;
	    } else if (IsGame(object)) {
	        return object;
	    } else if (IsGame(object.game)) {
	        return object.game;
	    } else if (IsSceneObject(object)) { // object = scene object
	        return object.sys.game;
	    } else if (IsSceneObject(object.scene)) { // object = game object
	        return object.scene.sys.game;
	    }
	};

	const GetValue$27 = Phaser.Utils.Objects.GetValue;

	class ComponentBase {
	    constructor(parent, config) {
	        this.setParent(parent);  // gameObject, scene, or game

	        this.isShutdown = false;

	        // Event emitter, default is private event emitter
	        this.setEventEmitter(GetValue$27(config, 'eventEmitter', true));

	        // Register callback of parent destroy event, also see `shutdown` method
	        if (this.parent) {
	            if (this.parent === this.scene) { // parent is a scene
	                this.scene.sys.events.once('shutdown', this.onEnvDestroy, this);

	            } else if (this.parent === this.game) { // parent is game
	                this.game.events.once('shutdown', this.onEnvDestroy, this);

	            } else if (this.parent.once) { // parent is game object or something else
	                this.parent.once('destroy', this.onParentDestroy, this);
	            }

	            // bob object does not have event emitter
	        }

	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        // parent might not be shutdown yet
	        if (this.parent) {
	            if (this.parent === this.scene) { // parent is a scene
	                this.scene.sys.events.off('shutdown', this.onEnvDestroy, this);

	            } else if (this.parent === this.game) { // parent is game
	                this.game.events.off('shutdown', this.onEnvDestroy, this);

	            } else if (this.parent.once) { // parent is game object or something else
	                this.parent.off('destroy', this.onParentDestroy, this);
	            }

	            // bob object does not have event emitter
	        }


	        this.destroyEventEmitter();

	        this.parent = undefined;
	        this.scene = undefined;
	        this.game = undefined;

	        this.isShutdown = true;
	    }

	    destroy(fromScene) {
	        this.shutdown(fromScene);
	    }

	    onEnvDestroy() {
	        this.destroy(true);
	    }

	    onParentDestroy(parent, fromScene) {
	        this.destroy(fromScene);
	    }

	    setParent(parent) {
	        this.parent = parent;  // gameObject, scene, or game

	        this.scene = GetSceneObject(parent);
	        this.game = GetGame(parent);

	        return this;
	    }

	}
	Object.assign(
	    ComponentBase.prototype,
	    EventEmitterMethods$1
	);

	const GetValue$26 = Phaser.Utils.Objects.GetValue;

	class TickTask extends ComponentBase {
	    constructor(parent, config) {
	        super(parent, config);

	        this._isRunning = false;
	        this.isPaused = false;
	        this.tickingState = false;
	        this.setTickingMode(GetValue$26(config, 'tickingMode', 1));
	        // boot() later
	    }

	    // override
	    boot() {
	        if ((this.tickingMode === 2) && (!this.tickingState)) {
	            this.startTicking();
	        }
	    }

	    // override
	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        this.stop();
	        if (this.tickingState) {
	            this.stopTicking();
	        }
	        super.shutdown(fromScene);
	    }

	    setTickingMode(mode) {
	        if (typeof (mode) === 'string') {
	            mode = TICKINGMODE[mode];
	        }
	        this.tickingMode = mode;
	    }

	    // override
	    startTicking() {
	        this.tickingState = true;
	    }

	    // override
	    stopTicking() {
	        this.tickingState = false;
	    }

	    get isRunning() {
	        return this._isRunning;
	    }

	    set isRunning(value) {
	        if (this._isRunning === value) {
	            return;
	        }

	        this._isRunning = value;
	        if ((this.tickingMode === 1) && (value != this.tickingState)) {
	            if (value) {
	                this.startTicking();
	            } else {
	                this.stopTicking();
	            }
	        }
	    }

	    start() {
	        this.isPaused = false;
	        this.isRunning = true;
	        return this;
	    }

	    pause() {
	        // Only can ba paused in running state
	        if (this.isRunning) {
	            this.isPaused = true;
	            this.isRunning = false;
	        }
	        return this;
	    }

	    resume() {
	        // Only can ba resumed in paused state (paused from running state)
	        if (this.isPaused) {
	            this.isPaused = false;
	            this.isRunning = true;
	        }
	        return this;
	    }

	    stop() {
	        this.isPaused = false;
	        this.isRunning = false;
	        return this;
	    }

	    complete() {
	        this.isPaused = false;
	        this.isRunning = false;
	        this.emit('complete', this.parent, this);
	    }
	}

	const TICKINGMODE = {
	    'no': 0,
	    'lazy': 1,
	    'always': 2
	};

	const GetValue$25 = Phaser.Utils.Objects.GetValue;

	class SceneUpdateTickTask extends TickTask {
	    constructor(parent, config) {
	        super(parent, config);

	        // scene update : update, preupdate, postupdate, prerender, render
	        // game update : step, poststep, 

	        // If this.scene is not available, use game's 'step' event
	        var defaultEventName = (this.scene) ? 'update' : 'step';
	        this.tickEventName = GetValue$25(config, 'tickEventName', defaultEventName);
	        this.isSceneTicker = !IsGameUpdateEvent(this.tickEventName);

	    }

	    startTicking() {
	        super.startTicking();

	        if (this.isSceneTicker) {
	            this.scene.sys.events.on(this.tickEventName, this.update, this);
	        } else {
	            this.game.events.on(this.tickEventName, this.update, this);
	        }

	    }

	    stopTicking() {
	        super.stopTicking();

	        if (this.isSceneTicker && this.scene) { // Scene might be destoryed
	            this.scene.sys.events.off(this.tickEventName, this.update, this);
	        } else if (this.game) {
	            this.game.events.off(this.tickEventName, this.update, this);
	        }
	    }

	    // update(time, delta) {
	    //     
	    // }

	}

	var IsGameUpdateEvent = function (eventName) {
	    return (eventName === 'step') || (eventName === 'poststep');
	};

	const GetValue$24 = Phaser.Utils.Objects.GetValue;
	const Clamp$9 = Phaser.Math.Clamp;

	let Timer$1 = class Timer {
	    constructor(config) {
	        this.resetFromJSON(config);
	    }

	    resetFromJSON(o) {
	        this.state = GetValue$24(o, 'state', IDLE$6);
	        this.timeScale = GetValue$24(o, 'timeScale', 1);
	        this.delay = GetValue$24(o, 'delay', 0);
	        this.repeat = GetValue$24(o, 'repeat', 0);
	        this.repeatCounter = GetValue$24(o, 'repeatCounter', 0);
	        this.repeatDelay = GetValue$24(o, 'repeatDelay', 0);
	        this.duration = GetValue$24(o, 'duration', 0);
	        this.nowTime = GetValue$24(o, 'nowTime', 0);
	        this.justRestart = GetValue$24(o, 'justRestart', false);
	    }

	    toJSON() {
	        return {
	            state: this.state,
	            timeScale: this.timeScale,
	            delay: this.delay,
	            repeat: this.repeat,
	            repeatCounter: this.repeatCounter,
	            repeatDelay: this.repeatDelay,
	            duration: this.duration,
	            nowTime: this.nowTime,
	            justRestart: this.justRestart,
	        }
	    }

	    destroy() {

	    }

	    setTimeScale(timeScale) {
	        this.timeScale = timeScale;
	        return this;
	    }

	    setDelay(delay) {
	        if (delay === undefined) {
	            delay = 0;
	        }
	        this.delay = delay;
	        return this;
	    }

	    setDuration(duration) {
	        this.duration = duration;
	        return this;
	    }

	    setRepeat(repeat) {
	        this.repeat = repeat;
	        return this;
	    }

	    setRepeatInfinity() {
	        this.repeat = -1;
	        return this;
	    }

	    setRepeatDelay(repeatDelay) {
	        this.repeatDelay = repeatDelay;
	        return this;
	    }

	    start() {
	        this.nowTime = (this.delay > 0) ? -this.delay : 0;
	        this.state = (this.nowTime >= 0) ? COUNTDOWN : DELAY;
	        this.repeatCounter = 0;
	        return this;
	    }

	    stop() {
	        this.state = IDLE$6;
	        return this;
	    }

	    update(time, delta) {
	        if (this.state === IDLE$6 || this.state === DONE ||
	            delta === 0 || this.timeScale === 0
	        ) {
	            return;
	        }

	        this.nowTime += (delta * this.timeScale);
	        this.justRestart = false;
	        if (this.nowTime >= this.duration) {
	            if ((this.repeat === -1) || (this.repeatCounter < this.repeat)) {
	                this.repeatCounter++;
	                this.justRestart = true;
	                this.nowTime -= this.duration;
	                if (this.repeatDelay > 0) {
	                    this.nowTime -= this.repeatDelay;
	                    this.state = REPEATDELAY;
	                }
	            } else {
	                this.nowTime = this.duration;
	                this.state = DONE;
	            }
	        } else if (this.nowTime >= 0) {
	            this.state = COUNTDOWN;
	        }
	    }

	    get t() {
	        var t;
	        switch (this.state) {
	            case IDLE$6:
	            case DELAY:
	            case REPEATDELAY:
	                t = 0;
	                break;

	            case COUNTDOWN:
	                t = this.nowTime / this.duration;
	                break;

	            case DONE:
	                t = 1;
	                break;
	        }
	        return Clamp$9(t, 0, 1);
	    }

	    set t(value) {
	        value = Clamp$9(value, -1, 1);
	        if (value < 0) {
	            this.state = DELAY;
	            this.nowTime = -this.delay * value;
	        } else {
	            this.state = COUNTDOWN;
	            this.nowTime = this.duration * value;

	            if ((value === 1) && (this.repeat !== 0)) {
	                this.repeatCounter++;
	            }
	        }
	    }

	    setT(t) {
	        this.t = t;
	        return this;
	    }

	    get isIdle() {
	        return this.state === IDLE$6;
	    }

	    get isDelay() {
	        return this.state === DELAY;
	    }

	    get isCountDown() {
	        return this.state === COUNTDOWN;
	    }

	    get isRunning() {
	        return this.state === DELAY || this.state === COUNTDOWN;
	    }

	    get isDone() {
	        return this.state === DONE;
	    }

	    get isOddIteration() {
	        return (this.repeatCounter & 1) === 1;
	    }

	    get isEvenIteration() {
	        return (this.repeatCounter & 1) === 0;
	    }

	};

	const IDLE$6 = 0;
	const DELAY = 1;
	const COUNTDOWN = 2;
	const REPEATDELAY = 3;
	const DONE = -1;

	class TimerTickTask extends SceneUpdateTickTask {
	    constructor(parent, config) {
	        super(parent, config);
	        this.timer = new Timer$1();
	        // boot() later 
	    }

	    // override
	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        super.shutdown(fromScene);
	        this.timer.destroy();
	        this.timer = undefined;
	    }

	    start() {
	        this.timer.start();
	        super.start();
	        return this;
	    }

	    stop() {
	        this.timer.stop();
	        super.stop();
	        return this;
	    }

	    complete() {
	        this.timer.stop();
	        super.complete();
	        return this;
	    }

	}

	const GetValue$23 = Phaser.Utils.Objects.GetValue;
	const GetAdvancedValue$5 = Phaser.Utils.Objects.GetAdvancedValue;
	const GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;

	class EaseValueTaskBase extends TimerTickTask {
	    resetFromJSON(o) {
	        this.timer.resetFromJSON(GetValue$23(o, 'timer'));
	        this.setEnable(GetValue$23(o, 'enable', true));
	        this.setTarget(GetValue$23(o, 'target', this.parent));
	        this.setDelay(GetAdvancedValue$5(o, 'delay', 0));
	        this.setDuration(GetAdvancedValue$5(o, 'duration', 1000));
	        this.setEase(GetValue$23(o, 'ease', 'Linear'));
	        this.setRepeat(GetValue$23(o, 'repeat', 0));

	        return this;
	    }

	    setEnable(e) {
	        if (e == undefined) {
	            e = true;
	        }
	        this.enable = e;
	        return this;
	    }

	    setTarget(target) {
	        if (target === undefined) {
	            target = this.parent;
	        }
	        this.target = target;
	        return this;
	    }

	    setDelay(time) {
	        this.delay = time;
	        // Assign `this.timer.setRepeat(repeat)` manually
	        return this;
	    }

	    setDuration(time) {
	        this.duration = time;
	        return this;
	    }

	    setRepeat(repeat) {
	        this.repeat = repeat;
	        // Assign `this.timer.setRepeat(repeat)` manually
	        return this;
	    }

	    setRepeatDelay(repeatDelay) {
	        this.repeatDelay = repeatDelay;
	        // Assign `this.timer.setRepeatDelay(repeatDelay)` manually
	        return this;
	    }

	    setEase(ease) {
	        if (ease === undefined) {
	            ease = 'Linear';
	        }
	        this.ease = ease;
	        this.easeFn = GetEaseFunction(ease);
	        return this;
	    }

	    // Override
	    start() {
	        // Ignore start if timer is running, i.e. in DELAY, o RUN state
	        if (this.timer.isRunning) {
	            return this;
	        }

	        super.start();
	        return this;
	    }

	    restart() {
	        this.timer.stop();
	        this.start.apply(this, arguments);
	        return this;
	    }

	    stop(toEnd) {
	        if (toEnd === undefined) {
	            toEnd = false;
	        }

	        super.stop();

	        if (toEnd) {
	            this.timer.setT(1);
	            this.updateTarget(this.target, this.timer);
	            this.complete();
	        }

	        return this;
	    }

	    update(time, delta) {
	        if (
	            (!this.isRunning) ||
	            (!this.enable) ||
	            (this.parent.hasOwnProperty('active') && !this.parent.active)
	        ) {
	            return this;
	        }

	        var target = this.target,
	            timer = this.timer;

	        timer.update(time, delta);

	        // isDelay, isCountDown, isDone
	        if (!timer.isDelay) {
	            this.updateTarget(target, timer);
	        }

	        this.emit('update', target, this);

	        if (timer.isDone) {
	            this.complete();
	        }

	        return this;
	    }

	    // Override
	    updateTarget(target, timer) {

	    }
	}

	const SoundObjectClass = Phaser.Sound.BaseSound;
	var IsSoundObject = function (object) {
	    return (object instanceof SoundObjectClass);
	};

	const GetValue$22 = Phaser.Utils.Objects.GetValue;
	const GetAdvancedValue$4 = Phaser.Utils.Objects.GetAdvancedValue;
	const Linear$i = Phaser.Math.Linear;

	let Fade$2 = class Fade extends EaseValueTaskBase {
	    constructor(scene, sound, config) {
	        if (IsSoundObject(scene)) {
	            config = sound;
	            sound = scene;
	            scene = undefined;
	        }

	        sound.active = true;
	        sound.scene = scene;
	        sound.game = sound.manager.game;

	        super(sound, config);
	        // this.parent = parent
	        // this.timer

	        this.volume = {};
	        this.resetFromJSON(config);
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);
	        this.setMode(GetValue$22(o, 'mode', 0));
	        this.setEnable(GetValue$22(o, 'enable', true));
	        this.setVolumeRange(
	            GetAdvancedValue$4(o, 'volume.start', this.parent.volume),
	            GetAdvancedValue$4(o, 'volume.end', 0)
	        );
	        return this;
	    }

	    setMode(m) {
	        if (typeof (m) === 'string') {
	            m = MODE$4[m];
	        }
	        this.mode = m;
	        return this;
	    }

	    setVolumeRange(start, end) {
	        this.volume.start = start;
	        this.volume.end = end;
	        return this;
	    }

	    start() {
	        if (this.timer.isRunning) {
	            return this;
	        }

	        this.parent.setVolume(this.volume.start);

	        this.timer
	            .setDelay(this.delay)
	            .setDuration(this.duration);

	        super.start();
	        return this;
	    }

	    updateTarget(parent, timer) {
	        parent.volume = Linear$i(this.volume.start, this.volume.end, timer.t);
	    }

	    complete() {
	        super.complete();

	        switch (this.mode) {
	            case 1:
	                this.parent.stop();
	                break;
	            case 2:
	                this.parent.stop();
	                this.parent.destroy();
	                break;
	        }

	        return this;
	    }
	};

	const MODE$4 = {
	    stop: 1,
	    destroy: 2
	};

	var FadeIn$1 = function (scene, sound, duration, endVolume, startVolume) {
	    if (IsSoundObject(scene)) {
	        startVolume = endVolume;
	        endVolume = duration;
	        duration = sound;
	        sound = scene;
	        scene = undefined;
	    }

	    if (endVolume === undefined) {
	        endVolume = 1;
	    }
	    if (startVolume === undefined) {
	        startVolume = 0;
	    }

	    var config = {
	        mode: 0,
	        volume: {
	            start: startVolume,
	            end: endVolume
	        },
	        duration: duration
	    };

	    // create sound instance by key
	    if (typeof (sound) === 'string') {
	        sound = scene.sys.sound.add(sound);
	    }

	    var fade;
	    if (sound.hasOwnProperty('_fade')) {
	        fade = sound._fade;
	        fade.stop().resetFromJSON(config);
	    } else {
	        fade = new Fade$2(scene, sound, config);
	        sound._fade = fade;
	    }

	    fade.start();
	    if (!sound.isPlaying) {
	        sound.setVolume(startVolume).play();
	    }
	    return sound;
	};

	var FadeOut = function (scene, sound, duration, destroy) {
	    if (IsSoundObject(scene)) {
	        destroy = duration;
	        duration = sound;
	        sound = scene;
	        scene = undefined;
	    }

	    if (destroy === undefined) {
	        destroy = true;
	    }

	    var config = {
	        mode: ((destroy) ? 2 : 1), // 1: stop, 2: destroy
	        volume: {
	            start: sound.volume,
	            end: 0
	        },
	        duration: duration
	    };

	    var fade;
	    if (sound.hasOwnProperty('_fade')) {
	        fade = sound._fade;
	        fade.stop().resetFromJSON(config);
	    } else {
	        fade = new Fade$2(scene, sound, config);
	        sound._fade = fade;
	    }

	    fade.start();
	    if (!sound.isPlaying) {
	        sound.play();
	    }
	    return sound;
	};

	const GetValue$21 = Phaser.Utils.Objects.GetValue;

	var BackgroundMusicMethods$1 = {
	    setBackgroundMusicLoop(value) {
	        if (value === undefined) {
	            value = true;
	        }

	        this.backgroundMusicLoop = value;
	        return this;
	    },

	    setBackgroundMusicFadeTime(time) {
	        this.backgroundMusicFadeTime = time;
	        return this;
	    },

	    getBackgroundMusic() {
	        return this.backgroundMusic;
	    },

	    // Internal method
	    setCurrentBackgroundMusic(music) {
	        this.backgroundMusic = music;

	        if (music) {
	            music
	                .once('complete', function () {
	                    if (this.backgroundMusic === music) {
	                        this.backgroundMusic.destroy();
	                        this.backgroundMusic = undefined;
	                    }
	                }, this)
	                .once('destroy', function () {
	                    if (this.backgroundMusic === music) {
	                        this.backgroundMusic = undefined;
	                    }
	                }, this);

	            if (!music.isPlaying) {
	                music.play();
	            }
	        }
	        return this;
	    },

	    playBackgroundMusic(key, config) {
	        if (!this.hasAudio(key)) {
	            console.error(`[Sound manager] Audio key'${key}' is not existed`);
	            return this;
	        }

	        // Don't re-play the same background music
	        if (this.backgroundMusic && (this.backgroundMusic.key === key)) {
	            return this;
	        }

	        this.stopBackgroundMusic(); // Stop previous background music

	        var music = this.sound.add(key, {
	            loop: GetValue$21(config, 'loop', this.backgroundMusicLoop),
	            mute: GetValue$21(config, 'mute', this.backgroundMusicMute),
	            volume: GetValue$21(config, 'volume', this.backgroundMusicVolume),
	            detune: GetValue$21(config, 'detune', 0),
	            rate: GetValue$21(config, 'rate', 1),
	        });

	        this.setCurrentBackgroundMusic(music);

	        // Fade volume
	        if (this.backgroundMusicFadeTime > 0) {
	            this.fadeInBackgroundMusic(this.backgroundMusicFadeTime);
	        }
	        return this;
	    },

	    pauseBackgroundMusic() {
	        if (this.backgroundMusic) {
	            this.backgroundMusic.pause();
	        }
	        return this;
	    },

	    resumeBackgroundMusic() {
	        if (this.backgroundMusic) {
	            this.backgroundMusic.resume();
	        }
	        return this;
	    },

	    stopBackgroundMusic() {
	        if (this.backgroundMusic) {
	            if (this.backgroundMusicFadeTime > 0) {
	                this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, true);

	            } else {
	                this.backgroundMusic.stop();
	                this.backgroundMusic.destroy();
	                this.backgroundMusic = undefined;
	            }
	        }
	        return this;
	    },

	    fadeInBackgroundMusic(time) {
	        if (this.backgroundMusic) {
	            FadeIn$1(this.backgroundMusic, time, this.backgroundMusicVolume, 0);
	        }

	        return this;
	    },

	    fadeOutBackgroundMusic(time, isStopped) {
	        if (this.backgroundMusic) {
	            FadeOut(this.backgroundMusic, time, isStopped);
	        }

	        return this;
	    },

	    crossFadeBackgroundMusic(key, time) {
	        if (!this.hasAudio(key)) {
	            console.error(`[Sound manager] Audio key'${key}' is not existed`);
	            return this;
	        }

	        var backgroundMusicFadeTimeSave = this.backgroundMusicFadeTime;
	        this.backgroundMusicFadeTime = 0;

	        this
	            .fadeOutBackgroundMusic(time, true)
	            .playBackgroundMusic(key)
	            .fadeInBackgroundMusic(time);

	        this.backgroundMusicFadeTime = backgroundMusicFadeTimeSave;

	        return this;
	    },

	    setBackgroundMusicMute(mute) {
	        if (mute === undefined) {
	            mute = true;
	        }

	        this.backgroundMusicMute = mute;
	        return this;
	    },


	    setBackgroundMusicVolume(volume) {
	        this.backgroundMusicVolume = volume;
	        return this;
	    },

	    setBackgroundMusicRate(rate) {
	        if (this.backgroundMusic) {
	            this.backgroundMusic.setRate(rate);
	        }
	        return this;
	    },

	    setBackgroundMusicDetune(detune) {
	        if (this.backgroundMusic) {
	            this.backgroundMusic.setDetune(detune);
	        }
	        return this;
	    },



	};

	const GetValue$20 = Phaser.Utils.Objects.GetValue;

	var BackgroundMusic2Methods$1 = {
	    setBackgroundMusic2Loop(value) {
	        if (value === undefined) {
	            value = true;
	        }

	        this.backgroundMusic2Loop = value;
	        return this;
	    },

	    setBackgroundMusic2FadeTime(time) {
	        this.backgroundMusic2FadeTime = time;
	        return this;
	    },

	    getBackgroundMusic2() {
	        return this.backgroundMusic2;
	    },

	    // Internal method
	    setCurrentBackgroundMusic2(music) {
	        this.backgroundMusic2 = music;

	        if (music) {
	            music
	                .once('complete', function () {
	                    if (this.backgroundMusic2 === music) {
	                        this.backgroundMusic2.destroy();
	                        this.backgroundMusic2 = undefined;
	                    }
	                }, this)
	                .once('destroy', function () {
	                    if (this.backgroundMusic2 === music) {
	                        this.backgroundMusic2 = undefined;
	                    }
	                }, this);

	            if (!music.isPlaying) {
	                music.play();
	            }
	        }
	        return this;
	    },

	    playBackgroundMusic2(key, config) {
	        if (!this.hasAudio(key)) {
	            console.error(`[Sound manager] Audio key'${key}' is not existed`);
	            return this;
	        }

	        // Don't re-play the same background music
	        if (this.backgroundMusic2 && (this.backgroundMusic2.key === key)) {
	            return this;
	        }

	        this.stopBackgroundMusic2(); // Stop previous background music

	        var music = this.sound.add(key, {
	            loop: GetValue$20(config, 'loop', this.backgroundMusicLoop),
	            mute: GetValue$20(config, 'mute', this.backgroundMusic2Mute),
	            volume: GetValue$20(config, 'volume', this.backgroundMusic2Volume),
	            detune: GetValue$20(config, 'detune', 0),
	            rate: GetValue$20(config, 'rate', 1),
	        });

	        this.setCurrentBackgroundMusic2(music);

	        // Fade volume
	        if (this.backgroundMusic2FadeTime > 0) {
	            this.fadeInBackgroundMusic2(this.backgroundMusic2FadeTime);
	        }
	        return this;
	    },

	    pauseBackgroundMusic2() {
	        if (this.backgroundMusic2) {
	            this.backgroundMusic2.pause();
	        }
	        return this;
	    },

	    resumeBackgroundMusic2() {
	        if (this.backgroundMusic2) {
	            this.backgroundMusic2.resume();
	        }
	        return this;
	    },

	    stopBackgroundMusic2() {
	        if (this.backgroundMusic2) {
	            if (this.backgroundMusic2FadeTime > 0) {
	                this.fadeOutBackgroundMusic2(this.backgroundMusic2FadeTime, true);

	            } else {
	                this.backgroundMusic2.stop();
	                this.backgroundMusic2.destroy();
	                this.backgroundMusic2 = undefined;
	            }
	        }
	        return this;
	    },

	    fadeInBackgroundMusic2(time) {
	        if (this.backgroundMusic2) {
	            FadeIn$1(this.backgroundMusic2, time, this.backgroundMusic2Volume, 0);
	        }

	        return this;
	    },

	    fadeOutBackgroundMusic2(time, isStopped) {
	        if (this.backgroundMusic2) {
	            FadeOut(this.backgroundMusic2, time, isStopped);
	        }

	        return this;
	    },

	    crossFadeBackgroundMusic2(key, time) {
	        if (!this.hasAudio(key)) {
	            console.error(`[Sound manager] Audio key'${key}' is not existed`);
	            return this;
	        }

	        var backgroundMusic2FadeTimeSave = this.backgroundMusic2FadeTime;
	        this.backgroundMusic2FadeTime = 0;

	        this
	            .fadeOutBackgroundMusic2(time, true)
	            .playBackgroundMusic2(key)
	            .fadeInBackgroundMusic2(time);

	        this.backgroundMusic2FadeTime = backgroundMusic2FadeTimeSave;

	        return this;
	    },

	    setBackgroundMusic2Mute(mute) {
	        if (mute === undefined) {
	            mute = true;
	        }

	        this.backgroundMusic2Mute = mute;
	        return this;
	    },

	    setBackgroundMusic2Volume(volume) {
	        this.backgroundMusic2Volume = volume;
	        return this;
	    },

	    setBackgroundMusic2Rate(rate) {
	        if (this.backgroundMusic2) {
	            this.backgroundMusic2.setRate(rate);
	        }
	        return this;
	    },

	    setBackgroundMusic2Detune(detune) {
	        if (this.backgroundMusic2) {
	            this.backgroundMusic2.setDetune(detune);
	        }
	        return this;
	    },

	};

	const RemoveItem$c = Phaser.Utils.Array.Remove;
	const GetValue$1$ = Phaser.Utils.Objects.GetValue;

	var SoundEffectsMethods$1 = {

	    getSoundEffects() {
	        return this.soundEffects;
	    },

	    getLastSoundEffect() {
	        return this.soundEffects[this.soundEffects.length - 1];
	    },

	    playSoundEffect(key, config) {
	        if (!this.hasAudio(key)) {
	            console.error(`[Sound manager] Audio key'${key}' is not existed`);
	            return this;
	        }

	        var music = this.sound.add(key, {
	            mute: GetValue$1$(config, 'mute', this.soundEffectsMute),
	            volume: GetValue$1$(config, 'volume', this.soundEffectsVolume),
	            detune: GetValue$1$(config, 'detune', 0),
	            rate: GetValue$1$(config, 'rate', 1),
	        });


	        this.soundEffects.push(music);

	        music
	            .once('complete', function () {
	                music.destroy();

	                // SoundManager has been destroyed
	                if (!this.sound) {
	                    return;
	                }
	                RemoveItem$c(this.soundEffects, music);
	            }, this)
	            .once('destroy', function () {
	                // SoundManager has been destroyed
	                if (!this.sound) {
	                    return;
	                }
	                RemoveItem$c(this.soundEffects, music);
	            }, this)
	            .play();

	        return this;
	    },

	    stopAllSoundEffects() {
	        for (var i = this.soundEffects.length - 1; i >= 0; i--) {
	            var soundEffect = this.soundEffects[i];
	            soundEffect.stop();
	            soundEffect.destroy();
	        }

	        return this;
	    },

	    fadeInSoundEffect(time) {
	        var soundEffect = this.getLastSoundEffect();
	        if (soundEffect) {
	            FadeIn$1(soundEffect, time, this.soundEffectsVolume, 0);
	        }

	        return this;
	    },

	    fadeOutSoundEffect(time, isStopped) {
	        var soundEffect = this.getLastSoundEffect();
	        if (soundEffect) {
	            FadeOut(soundEffect, time, isStopped);
	        }

	        return this;
	    },

	    fadeOutAllSoundEffects(time, isStopped) {
	        for (var i = this.soundEffects.length - 1; i >= 0; i--) {
	            FadeOut(this.soundEffects[i], time, isStopped);
	        }

	        return this;
	    },

	    setSoundEffectMute(mute, lastSoundEffect) {
	        if (mute === undefined) {
	            mute = true;
	        }
	        if (lastSoundEffect === undefined) {
	            lastSoundEffect = false;
	        }

	        if (lastSoundEffect) {
	            // Set volume of last sound effect
	            var soundEffect = this.getLastSoundEffect();
	            if (soundEffect) {
	                soundEffect.setMute(mute);
	            }

	        } else {
	            // Set volume of all sound effects
	            this.soundEffectsMute = mute;
	        }

	        return this;
	    },

	    setSoundEffectVolume(volume, lastSoundEffect) {
	        if (lastSoundEffect === undefined) {
	            lastSoundEffect = false;
	        }

	        if (lastSoundEffect) {
	            // Set volume of last sound effect
	            var soundEffect = this.getLastSoundEffect();
	            if (soundEffect) {
	                soundEffect.setVolume(volume);
	            }

	        } else {
	            // Set volume of all sound effects
	            this.soundEffectsVolume = volume;
	        }

	        return this;
	    },

	    setSoundEffectDetune(detune, lastSoundEffect) {
	        if (lastSoundEffect === undefined) {
	            lastSoundEffect = false;
	        }

	        var soundEffects;
	        if (lastSoundEffect) {
	            soundEffects = [this.getLastSoundEffect()];
	        } else {
	            soundEffects = this.soundEffects;
	        }

	        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
	            soundEffects[i].setDetune(detune);
	        }

	        return this;
	    },

	    setSoundEffectRate(rate, lastSoundEffect) {
	        if (lastSoundEffect === undefined) {
	            lastSoundEffect = false;
	        }

	        var soundEffects;
	        if (lastSoundEffect) {
	            soundEffects = [this.getLastSoundEffect()];
	        } else {
	            soundEffects = this.soundEffects;
	        }

	        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
	            soundEffects[i].setRate(rate);
	        }

	        return this;
	    },
	};

	const RemoveItem$b = Phaser.Utils.Array.Remove;
	const GetValue$1_ = Phaser.Utils.Objects.GetValue;

	var SoundEffects2Methods$1 = {

	    getSoundEffects2() {
	        return this.soundEffects2;
	    },

	    getLastSoundEffect2() {
	        return this.soundEffects2[this.soundEffects2.length - 1];
	    },

	    playSoundEffect2(key, config) {
	        if (!this.hasAudio(key)) {
	            console.error(`[Sound manager] Audio key'${key}' is not existed`);
	            return this;
	        }

	        var music = this.sound.add(key, {
	            mute: GetValue$1_(config, 'mute', this.soundEffects2Mute),
	            volume: GetValue$1_(config, 'volume', this.soundEffects2Volume),
	            detune: GetValue$1_(config, 'detune', 0),
	            rate: GetValue$1_(config, 'rate', 1),
	        });

	        this.soundEffects2.push(music);

	        music
	            .once('complete', function () {
	                music.destroy();

	                // SoundManager has been destroyed
	                if (!this.sound) {
	                    return;
	                }
	                RemoveItem$b(this.soundEffects2, music);
	            }, this)
	            .once('destroy', function () {
	                // SoundManager has been destroyed
	                if (!this.sound) {
	                    return;
	                }
	                RemoveItem$b(this.soundEffects2, music);
	            }, this)
	            .play();

	        return this;
	    },

	    stopAllSoundEffects2() {
	        for (var i = this.soundEffects.length - 1; i >= 0; i--) {
	            var soundEffect = this.soundEffects[i];
	            soundEffect.stop();
	            soundEffect.destroy();
	        }

	        return this;
	    },

	    fadeInSoundEffect2(time) {
	        var soundEffect = this.getLastSoundEffect2();
	        if (soundEffect) {
	            FadeIn$1(soundEffect, time, this.soundEffects2Volume, 0);
	        }

	        return this;
	    },

	    fadeOutSoundEffect2(time, isStopped) {
	        var soundEffect = this.getLastSoundEffect2();
	        if (soundEffect) {
	            FadeOut(soundEffect, time, isStopped);
	        }

	        return this;
	    },

	    fadeOutAllSoundEffects2(time, isStopped) {
	        for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
	            FadeOut(this.soundEffects2[i], time, isStopped);
	        }

	        return this;
	    },

	    setSoundEffect2Mute(mute, lastSoundEffect) {
	        if (mute === undefined) {
	            mute = true;
	        }
	        if (lastSoundEffect === undefined) {
	            lastSoundEffect = false;
	        }

	        if (lastSoundEffect) {
	            // Set volume of last sound effect
	            var soundEffect = this.getLastSoundEffect2();
	            if (soundEffect) {
	                soundEffect.setMute(mute);
	            }

	        } else {
	            // Set volume of all sound effects
	            this.soundEffects2Mute = mute;
	        }

	        return this;
	    },

	    setSoundEffect2Volume(volume, lastSoundEffect) {
	        if (lastSoundEffect === undefined) {
	            lastSoundEffect = false;
	        }

	        if (lastSoundEffect) {
	            // Set volume of last sound effect
	            var soundEffect = this.getLastSoundEffect2();
	            if (soundEffect) {
	                soundEffect.setVolume(volume);
	            }

	        } else {
	            // Set volume of all sound effects
	            this.soundEffects2Volume = volume;
	        }

	        return this;
	    },

	    setSoundEffect2Detune(detune, lastSoundEffect) {
	        if (lastSoundEffect === undefined) {
	            lastSoundEffect = false;
	        }

	        var soundEffects;
	        if (lastSoundEffect) {
	            soundEffects = [this.getLastSoundEffect2()];
	        } else {
	            soundEffects = this.soundEffects2;
	        }

	        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
	            soundEffects[i].setDetune(detune);
	        }

	        return this;
	    },

	    setSoundEffect2Rate(rate, lastSoundEffect) {
	        if (lastSoundEffect === undefined) {
	            lastSoundEffect = false;
	        }

	        var soundEffects;
	        if (lastSoundEffect) {
	            soundEffects = [this.getLastSoundEffect2()];
	        } else {
	            soundEffects = this.soundEffects2;
	        }

	        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
	            soundEffects[i].setRate(rate);
	        }

	        return this;
	    },
	};

	var Methods$d = {
	    hasAudio: HasaAudio
	};

	Object.assign(
	    Methods$d,
	    BackgroundMusicMethods$1,
	    BackgroundMusic2Methods$1,
	    SoundEffectsMethods$1,
	    SoundEffects2Methods$1,
	);

	const GetValue$1Z = Phaser.Utils.Objects.GetValue;

	class SoundManager {
	    constructor(game, config) {
	        this.sound = GetSoundManager(game);

	        // Background music will be (fade out)destroyed when play next one.
	        this.backgroundMusic = undefined;
	        this._backgroundMusicVolume = GetValue$1Z(config, 'bgm.volume', 1);
	        this._backgroundMusicMute = GetValue$1Z(config, 'bgm.mute', false);

	        this.setBackgroundMusicLoop(GetValue$1Z(config, 'bgm.loop', true));
	        this.setBackgroundMusicFadeTime(GetValue$1Z(config, 'bgm.fade', 500));

	        this.backgroundMusic2 = undefined;
	        this._backgroundMusic2Volume = GetValue$1Z(config, 'bgm2.volume', 1);
	        this._backgroundMusic2Mute = GetValue$1Z(config, 'bgm2.mute', false);

	        this.setBackgroundMusic2Loop(GetValue$1Z(config, 'bgm2.loop', true));
	        this.setBackgroundMusic2FadeTime(GetValue$1Z(config, 'bgm2.fade', 500));

	        // Sound effect will be destroyed when completed
	        this.soundEffects = [];
	        this._soundEffectsVolume = GetValue$1Z(config, 'soundEffect.volume', 1);

	        this.soundEffects2 = [];
	        this._soundEffects2Volume = GetValue$1Z(config, 'soundEffect2.volume', 1);


	        var initialBackgroundMusic = GetValue$1Z(config, 'bgm.initial', undefined);
	        if (initialBackgroundMusic) {
	            this.setCurrentBackgroundMusic(initialBackgroundMusic);
	        }

	        var initialBackgroundMusic2 = GetValue$1Z(config, 'bgm2.initial', undefined);
	        if (initialBackgroundMusic2) {
	            this.setCurrentBackgroundMusic2(initialBackgroundMusic2);
	        }
	    }

	    destroy() {
	        if (this.backgroundMusic) {
	            this.backgroundMusic.destroy();
	        }
	        this.backgroundMusic = undefined;

	        if (this.backgroundMusic2) {
	            this.backgroundMusic2.destroy();
	        }
	        this.backgroundMusic2 = undefined;

	        if (this.soundEffects.length) {
	            for (var i = this.soundEffects.length - 1; i >= 0; i--) {
	                this.soundEffects[i].destroy();
	            }
	        }
	        this.soundEffects.length = 0;

	        if (this.soundEffects2.length) {
	            for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
	                this.soundEffects2[i].destroy();
	            }
	        }
	        this.soundEffects2.length = 0;

	        this.sound = undefined;

	        return this;
	    }

	    // backgroundMusic
	    // mute
	    get backgroundMusicMute() {
	        return this._backgroundMusicMute;
	    }

	    set backgroundMusicMute(value) {
	        this._backgroundMusicMute = value;
	        if (this.backgroundMusic) {
	            this.backgroundMusic.setMute(mute);
	        }
	    }

	    // volume
	    get backgroundMusicVolume() {
	        return this._backgroundMusicVolume;
	    }

	    set backgroundMusicVolume(value) {
	        this._backgroundMusicVolume = value;
	        if (this.backgroundMusic) {
	            this.backgroundMusic.setVolume(value);
	        }
	    }

	    // backgroundMusic2
	    // mute
	    get backgroundMusic2Mute() {
	        return this._backgroundMusic2Mute;
	    }

	    set backgroundMusic2Mute(value) {
	        this._backgroundMusic2Mute = value;
	        if (this.backgroundMusic2) {
	            this.backgroundMusic2.setMute(mute);
	        }
	    }

	    // volume
	    get backgroundMusic2Volume() {
	        return this._backgroundMusic2Volume;
	    }

	    set backgroundMusic2Volume(value) {
	        this._backgroundMusic2Volume = value;
	        if (this.backgroundMusic2) {
	            this.backgroundMusic2.setVolume(value);
	        }
	    }

	    // soundEffects
	    // mute
	    get soundEffectsMute() {
	        return this._soundEffectsMute;
	    }

	    set soundEffectsMute(value) {
	        this._soundEffectsMute = value;
	        var soundEffects = this.soundEffects;
	        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
	            soundEffects[i].setMute(value);
	        }
	    }

	    // volume
	    get soundEffectsVolume() {
	        return this._soundEffectsVolume;
	    }

	    set soundEffectsVolume(value) {
	        this._soundEffectsVolume = value;
	        var soundEffects = this.soundEffects;
	        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
	            soundEffects[i].setVolume(value);
	        }
	    }

	    // soundEffects2
	    // mute
	    get soundEffects2Mute() {
	        return this._soundEffects2Mute;
	    }

	    set soundEffects2Mute(value) {
	        this._soundEffects2Mute = value;
	        var soundEffects = this.soundEffects;
	        for (var i = 0, cnt = soundEffects2.length; i < cnt; i++) {
	            soundEffects[i].setMute(value);
	        }
	    }

	    // volume
	    get soundEffects2Volume() {
	        return this._soundEffects2Volume;
	    }

	    set soundEffects2Volume(value) {
	        this._soundEffects2Volume = value;
	        var soundEffects = this.soundEffects2;
	        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
	            soundEffects[i].setVolume(value);
	        }
	    }

	}

	Object.assign(
	    SoundManager.prototype,
	    Methods$d
	);

	const GetValue$1Y = Phaser.Utils.Objects.GetValue;

	class BaseClock extends TickTask {
	    constructor(parent, config) {
	        super(parent, config);

	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.isRunning = GetValue$1Y(o, 'isRunning', false);
	        this.timeScale = GetValue$1Y(o, 'timeScale', 1);
	        this.now = GetValue$1Y(o, 'now', 0);
	        return this;
	    }

	    toJSON() {
	        return {
	            isRunning: this.isRunning,
	            timeScale: this.timeScale,
	            now: this.now,
	            tickingMode: this.tickingMode
	        };
	    }

	    // Override
	    // startTicking() { }

	    // Override
	    // stopTicking() {}

	    start(startAt) {
	        if (startAt === undefined) {
	            startAt = 0;
	        }
	        this.delta = 0;
	        this.now = startAt;
	        super.start();
	        return this;
	    }

	    seek(time) {
	        this.now = time;
	        return this;
	    }

	    setTimeScale(value) {
	        this.timeScale = value;
	        return this;
	    }

	    tick(delta) {
	        delta *= this.timeScale;
	        this.now += delta;
	        this.delta = delta;
	        this.emit('update', this.now, this.delta);
	        return this;
	    }
	}

	class Clock extends BaseClock {
	    startTicking() {
	        super.startTicking();
	        this.scene.sys.events.on('update', this.update, this);
	    }

	    stopTicking() {
	        super.stopTicking();
	        if (this.scene) { // Scene might be destoryed
	            this.scene.sys.events.off('update', this.update, this);
	        }
	    }

	    update(time, delta) {
	        if ((!this.isRunning) || (this.timeScale === 0)) {
	            return this;
	        }
	        this.tick(delta);
	        return this;
	    }
	}

	var Yoyo$1 = function (t, threshold) {
	    if (threshold === undefined) {
	        threshold = 0.5;
	    }
	    if (t <= threshold) {
	        t = t / threshold;
	    } else {
	        t = 1 - ((t - threshold) / (1 - threshold));
	    }

	    return t;
	};

	const Clamp$8 = Phaser.Math.Clamp;

	class Timer {
	    constructor(timeline, config) {
	        this
	            .setTimeline(timeline)
	            .reset(config);
	    }

	    setTimeline(timeline) {
	        this.timeline = timeline;
	        return this;
	    }

	    setName(name) {
	        this.name = name;
	        return this;
	    }

	    setCallbacks(target, onStart, onProgress, onComplete) {
	        this.target = target;
	        this.onStart = onStart;
	        this.onProgress = onProgress;
	        this.onComplete = onComplete;
	        return this;
	    }

	    setDuration(duration, yoyo) {
	        if (yoyo === undefined) {
	            yoyo = false;
	        }
	        this.duration = duration;
	        this.remainder = duration;
	        this.t = 0;
	        this.yoyo = yoyo;
	        return this;
	    }

	    setPaused(state) {
	        this.isPaused = state;
	        return this;
	    }

	    pause() {
	        this.isPaused = true;
	        return this;
	    }

	    resume() {
	        this.isPaused = false;
	        return this;
	    }

	    setRemoved(state) {
	        this.removed = state;
	        return this;
	    }

	    remove() {
	        this.removed = true;
	        return this;
	    }

	    seek(t) {
	        this.remainder = this.duration * (1 - t);
	        return this;
	    }

	    reset(o) {
	        this
	            .setName(o.name)
	            .setDuration(o.duration, o.yoyo)
	            .setCallbacks(o.target, o.onStart, o.onProgress, o.onComplete)
	            .setPaused(false)
	            .setRemoved(false);
	        return this;
	    }

	    onFree() {
	        this
	            .setTimeline()
	            .setCallbacks();
	    }

	    getProgress() {
	        var value = 1 - (this.remainder / this.duration);
	        value = Clamp$8(value, 0, 1);
	        if (this.yoyo) {
	            value = Yoyo$1(value);
	        }
	        return value;
	    }

	    setProgress(value) {
	        value = Clamp$8(value, 0, 1);
	        this.remainder = this.duration * (1 - value);
	    }

	    runCallback(callback) {
	        if (!callback) {
	            return;
	        }
	        callback(this.target, this.t, this);
	    }

	    update(time, delta) {
	        if (this.removed) {
	            return true;
	        } else if (this.isPaused) {
	            return false;
	        }

	        this.remainder -= delta;
	        this.t = this.getProgress();
	        this.runCallback(this.onProgress);

	        var isCompleted = (this.remainder <= 0);
	        if (isCompleted) {
	            this.runCallback(this.onComplete);
	        }
	        return isCompleted;
	    }
	}

	class Stack {
	    constructor() {
	        this.items = [];
	    }

	    destroy() {
	        this.clear();
	        this.items = undefined;
	    }

	    pop() {
	        return (this.items.length > 0) ? this.items.pop() : null;
	    }

	    push(l) {
	        this.items.push(l);
	        return this;
	    }

	    pushMultiple(arr) {
	        this.items.push.apply(this.items, arr);
	        arr.length = 0;
	        return this;
	    }

	    clear() {
	        this.items.length = 0;
	        return this;
	    }
	}

	let TimerPool$1 = class TimerPool extends Stack {
	    allocate() {
	        return this.pop();
	    }

	    free(timer) {
	        timer.onFree();
	        this.push(timer);
	    }

	    freeMultiple(arr) {
	        for (var i = 0, cnt = arr.length; i < cnt; i++) {
	            this.free(arr[i]);
	        }
	        return this;
	    }
	};

	const GetValue$1X = Phaser.Utils.Objects.GetValue;
	const TimerPool = new TimerPool$1();

	class Timeline extends Clock {
	    constructor(parent, config) {
	        super(parent, config);

	        this.addedTimers = [];
	        this.timers = [];
	        this.timerPool = GetValue$1X(config, 'pool', TimerPool);
	    }

	    shutdown() {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        this.timerPool
	            .freeMultiple(this.addedTimers)
	            .freeMultiple(this.timers);

	        this.timerPool = undefined;
	        this.addedTimers = undefined;
	        this.timers = undefined;

	        super.shutdown();
	    }

	    addTimer(config) {
	        var timer = this.timerPool.allocate();
	        if (!timer) {
	            timer = new Timer(this, config);
	        } else {
	            timer
	                .setTimeline(this)
	                .reset(config);
	        }
	        this.addedTimers.push(timer);
	        timer.runCallback(timer.onStart);

	        if (!this.isRunning) {
	            this.start();
	        }
	        return timer;
	    }

	    delayCall(delay, callback, args, scope) {
	        var timer = this.addTimer({
	            duration: delay,
	            onComplete: function (target, t, timer) {
	                if (args === undefined) {
	                    args = [];
	                }
	                args.push(timer);
	                callback.apply(scope, args);
	            }
	        });
	        return timer;
	    }

	    delayEvent(delay, eventName) {       
	        this.removeDelayEvent(eventName);
	        // Clear existed event

	        var timer = this.delayCall(delay, function () {
	            this.removeDelayEvent(eventName);  // Clear this timer
	            this.emit(eventName);           
	        }, [], this);

	        this.once(`_remove.${eventName}`, function () {
	            timer.remove();
	            timer = undefined;
	        });
	        return this;
	    }

	    removeDelayEvent(eventName) {
	        this.emit(`_remove.${eventName}`);
	        return this;
	    }

	    getTimers(name) {
	        var timers = [];

	        var timerQueues = [this.addedTimers, this.timers];
	        for (var ti = 0, tcnt = timerQueues.length; ti < tcnt; ti++) {
	            var timerQueue = timerQueues[ti];
	            for (var i = 0, cnt = timerQueue.length; i < cnt; i++) {
	                var timer = timerQueue[i];
	                if (timer.name === name) {
	                    timers.push(timer);
	                }
	            }
	        }
	        return timers;
	    }

	    update(time, delta) {
	        super.update(time, delta);

	        if (!this.isRunning) {
	            return;
	        }

	        this.timers.push(...this.addedTimers);
	        this.addedTimers.length = 0;
	        var pendingTimers = [];
	        for (var i = 0, cnt = this.timers.length; i < cnt; i++) {
	            var timer = this.timers[i];
	            var isStopped = timer.update(this.now, this.delta);
	            if (isStopped) {
	                this.timerPool.free(timer);  // Free timer
	            } else {
	                pendingTimers.push(timer);  // Add to timer queue
	            }
	        }
	        this.timers = pendingTimers;

	        if ((this.timers.length === 0) && (this.addedTimers.length === 0)) {
	            this.complete(); // Emit 'complete' event
	        }
	    }
	}

	const WaitCompleteEvent = '_wait.complete';
	const RemoveWaitEvents = '_remove.wait';

	var PreUpdateDelayCall = function (gameObject, delay, callback, scope, args) {
	    // Invoke callback under scene's 'preupdate' event
	    var scene = GetSceneObject(gameObject);
	    var timer = scene.time.delayedCall(delay, function () {
	        scene.sys.events.once('preupdate', function () {
	            callback.call(scope, args);
	        });
	    });
	    return timer;
	};

	let WaitEvent$1 = class WaitEvent {
	    constructor(parent) {
	        if (!parent) {
	            this.setEventEmitter(true);
	            parent = this;
	        }
	        this.parent = parent;

	        this.waitId = 0;

	        // Override it
	        this.waitCompleteEventName = WaitCompleteEvent;
	        this.removeWaitEventsEventName = RemoveWaitEvents;
	    }

	    destroy() {
	        this.removeWaitEvents();
	        this.clearWaitCompleteCallbacks();
	        this.parent = null;
	    }

	    // Emit completeEvent (default value is 'complete') when eventEmitter firing eventName
	    waitEvent(eventEmitter, eventName, completeNextTick) {
	        var callback = this.getWaitCompleteTriggerCallback(completeNextTick);
	        eventEmitter.once(eventName, callback, this);
	        // Once completeEvent firing, remove pending eventName from eventEmitter
	        this.parent.once(this.removeWaitEventsEventName, function () {
	            eventEmitter.off(eventName, callback, this);
	        });
	        // All pending eventName from eventEmitter will be removed at last
	        return this.parent;
	    }

	    getWaitCompleteTriggerCallback(completeNextTick) {
	        if (completeNextTick === undefined) {
	            completeNextTick = true;
	        }

	        var waitId = this.waitId;
	        var self = this;
	        var completeCallback = function () {
	            if (waitId < self.waitId) {
	                return;
	            }
	            self.waitId++;
	            self.removeWaitEvents();
	            self.parent.emit(self.waitCompleteEventName);
	        };

	        if (completeNextTick) {
	            var completeCallbackNextTick = function () {
	                PreUpdateDelayCall(self.parent, 0, completeCallback);
	            };
	            return completeCallbackNextTick;
	        } else {
	            return completeCallback;
	        }
	    }

	    removeWaitEvents() {
	        this.parent.emit(this.removeWaitEventsEventName);
	        return this;
	    }

	    addWaitCompleteCallback(callback, scope) {
	        this.parent.on(this.waitCompleteEventName, callback, scope);
	        return this;
	    }

	    clearWaitCompleteCallbacks() {
	        this.parent.off(this.waitCompleteEventName);
	        return this;
	    }
	};

	Object.assign(
	    WaitEvent$1.prototype,
	    EventEmitterMethods$1
	);

	var WaitTimeMethods = {
	    waitTime(duration) {
	        var timeline = this.parent.timeline;
	        timeline.delayEvent(duration, 'delay');

	        // Clear delay event on timeline manually
	        this.parent.once(this.removeWaitEventsEventName, function () {
	            timeline.removeDelayEvent('delay');
	        });
	        return this.waitEvent(timeline, 'delay');
	    },
	};

	var Split = function (s, delimiter) {
	    var regexString = `(?<!\\\\)\\${delimiter}`;
	    var escapeString = `\\${delimiter}`;
	    return s.split(new RegExp(regexString, 'g')).map(function (s) {
	        return s.replace(escapeString, delimiter);
	    })
	};

	var WaitInputMethods = {
	    setClickTarget(target) {
	        this.clickTarget = target;

	        if (!target) {
	            this.touchEE = null;
	        } else if (IsSceneObject(target)) {
	            this.touchEE = target.input;
	        } else {  // Assume that target is a gameObject
	            this.touchEE = target.setInteractive();
	        }
	        return this;
	    },

	    clearClickTarget() {
	        this.setClickTarget();
	        return this;
	    },

	    setClickShortcutKeys(keys) {
	        this.clickShortcutKeys = keys;
	        return this;
	    },

	    clearClickShortcutKeys() {
	        this.setClickShortcutKeys();
	        return this;
	    },

	    waitClick() {
	        var touchEE = this.touchEE;
	        var clickShortcutKeys = this.clickShortcutKeys;
	        if (touchEE || clickShortcutKeys) {
	            if (touchEE) {
	                this.waitEvent(touchEE, 'pointerdown');
	            }
	            if (clickShortcutKeys) {
	                this.waitKeyDown(clickShortcutKeys);
	            }
	        } else {
	            this.waitTime(0);
	        }

	        return this;
	    },

	    waitKeyDown(key) {
	        var eventEmitter = this.scene.input.keyboard;
	        if (typeof (key) === 'string') {
	            if (key.indexOf('|') === -1) {
	                return this.waitEvent(eventEmitter, `keydown-${key.toUpperCase()}`)
	            } else {
	                var keys = Split(key, '|');
	                for (var i = 0, cnt = keys.length; i < cnt; i++) {
	                    this.waitEvent(eventEmitter, `keydown-${keys[i].toUpperCase()}`);
	                }
	                return this.parent;
	            }
	        } else {
	            return this.waitEvent(eventEmitter, 'keydown');
	        }
	    }
	};

	var WaitGameObjectMethods = {
	    waitGameObjectTweenComplete(goType, name, property) {
	        var tweenTask = this.parent.getGameObjectTweenTask(goType, name, property);
	        if (tweenTask) {
	            return this.waitEvent(tweenTask, 'complete');
	        }
	        return this.waitTime(0);
	    },

	    waitGameObjectDataFlag(goType, name, dataKey, trueFlag) {
	        var gameObject = this.parent.getGameObject(goType, name);
	        if (!gameObject) {
	            return this.waitTime(0);
	        }

	        if (gameObject.getData(dataKey) === trueFlag) {
	            return this.waitTime(0);
	        }

	        var eventName = `changedata-${dataKey}`;
	        var callback = function (gameObject, value, previousValue) {
	            value = !!value;
	            if (value === trueFlag) {
	                gameObject.emit('_dataFlagMatch');
	            }
	        };
	        gameObject.on(eventName, callback);
	        // Clear changedata event on gameobject manually
	        this.parent.once(this.removeWaitEventsEventName, function () {
	            gameObject.off(eventName, callback);
	        });

	        return this.waitEvent(gameObject, '_dataFlagMatch');
	    },

	    waitGameObjectDestroy(goType, name) {
	        var gameObject = this.parent.getGameObject(goType, name);
	        if (!gameObject) {
	            return this.waitTime(0);
	        }
	        return this.waitEvent(gameObject, 'destroy');
	    },

	    waitGameObjectManagerEmpty(goType) {
	        if (goType) {
	            var gameObjectManager = this.parent.getGameObjectManager(goType);
	            if (!gameObjectManager) {
	                return this.waitTime(0);
	            }
	            return this.waitEvent(gameObjectManager, 'empty');

	        } else {
	            var gameObjectManagers = this.parent.gameObjectManagers;
	            var hasAnyWaitEvent = false;
	            for (var name in gameObjectManagers) {
	                hasAnyWaitEvent = true;
	                this.waitEvent(gameObjectManagers[name], 'empty');
	            }
	            if (!hasAnyWaitEvent) {
	                return this.waitTime(0);
	            }
	            return this.parent;
	        }
	    }
	};

	var WaitCameraMethods = {
	    setCameraTarget(camera) {
	        this.cameraTarget = camera;
	        return this;
	    },

	    clearCameraTarget() {
	        this.setCameraTarget();
	        return this;
	    },

	    waitCameraEffectComplete(effectName, cameraName) {
	        var camera;
	        if (cameraName) {
	            camera = this.scene.cameras.getCamera(cameraName);
	        } else {
	            camera = this.cameraTarget;
	        }

	        if (!camera) {
	            return this.waitTime(0);
	        }

	        var effect, completeEventName;
	        switch (effectName) {
	            case 'camera.fadein':
	                effect = camera.fadeEffect;
	                completeEventName = 'camerafadeincomplete';
	                break;

	            case 'camera.fadeout':
	                effect = camera.fadeEffect;
	                completeEventName = 'camerafadeoutcomplete';
	                break;

	            case 'camera.flash':
	                effect = camera.flashEffect;
	                completeEventName = 'cameraflashcomplete';
	                break;

	            case 'camera.shake':
	                effect = camera.shakeEffect;
	                completeEventName = 'camerashakecomplete';
	                break;

	            case 'camera.zoom':
	                effect = camera.zoomEffect;
	                completeEventName = 'camerazoomcomplete';
	                break;

	            case 'camera.rotate':
	                effect = camera.rotateToEffect;
	                completeEventName = 'camerarotatecomplete';
	                break;

	            case 'camera.scroll':
	                effect = camera.panEffect;
	                completeEventName = 'camerapancomplete';
	                break;
	        }

	        if (!effect.isRunning) {
	            return this.waitTime(0);
	        }

	        return this.waitEvent(camera, completeEventName);
	    },
	};

	var WaitMusicMethods = {
	    waitSoundEffectComplete() {
	        if (!this.parent.soundManager) {
	            return this.waitTime(0);
	        }
	        var music = this.parent.soundManager.getLastSoundEffect();
	        if (!music) {
	            return this.waitTime(0);
	        }
	        return this.waitEvent(music, 'complete');
	    },

	    waitSoundEffect2Complete() {
	        if (!this.parent.soundManager) {
	            return this.waitTime(0);
	        }
	        var music = this.parent.soundManager.getLastSoundEffect2();
	        if (!music) {
	            return this.waitTime(0);
	        }
	        return this.waitEvent(music, 'complete');
	    },

	    waitBackgroundMusicComplete() {
	        if (!this.parent.soundManager) {
	            return this.waitTime(0);
	        }
	        var music = this.parent.soundManager.getBackgroundMusic();
	        if (!music) {
	            return this.waitTime(0);
	        }
	        return this.waitEvent(music, 'complete');
	    },

	    waitBackgroundMusic2Complete() {
	        if (!this.parent.soundManager) {
	            return this.waitTime(0);
	        }
	        var music = this.parent.soundManager.getBackgroundMusic2();
	        if (!music) {
	            return this.waitTime(0);
	        }
	        return this.waitEvent(music, 'complete');
	    },
	};

	var WaitAny = function (config) {
	    if (!config) {
	        return this.waitTime(0);
	    }

	    var hasAnyWaitEvent = false;
	    for (var name in config) {
	        switch (name) {
	            case 'time':
	                hasAnyWaitEvent = true;
	                this.waitTime(config.time);
	                break;

	            case 'click':
	                hasAnyWaitEvent = true;
	                this.waitClick();
	                break;


	            case 'key':
	                hasAnyWaitEvent = true;
	                this.waitKeyDown(config.key);
	                break;

	            case 'bgm':
	                hasAnyWaitEvent = true;
	                this.waitBackgroundMusicComplete();
	                break;

	            case 'bgm2':
	                hasAnyWaitEvent = true;
	                this.waitBackgroundMusic2Complete();
	                break;

	            case 'se':
	                hasAnyWaitEvent = true;
	                this.waitSoundEffectComplete();
	                break;

	            case 'se2':
	                hasAnyWaitEvent = true;
	                this.waitSoundEffect2Complete();
	                break;

	            case 'camera':
	                hasAnyWaitEvent = true;
	                this.waitCameraEffectComplete(`camera.${config.camera.toLowerCase()}`, config.cameraName);
	                break;

	            default:
	                var names = name.split('.');
	                if (names.length === 2) {
	                    // GONAME.destroy, GONAME.PROPNAME, GONAME.DATAKEY, GONAME.EVTNAME

	                    var gameObjectName = names[0];
	                    var propName = names[1];
	                    var gameObjectManager = this.parent.getGameObjectManager(undefined, gameObjectName);
	                    if (!gameObjectManager) {
	                        continue;
	                    }

	                    // GONAME.destroy
	                    if (propName === 'destroy') {
	                        return this.waitGameObjectDestroy(undefined, gameObjectName);
	                    }

	                    // GONAME.PROPNAME (tween.complete)
	                    var value = gameObjectManager.getProperty(gameObjectName, propName);
	                    if (typeof (value) === 'number') {
	                        hasAnyWaitEvent = true;
	                        this.waitGameObjectTweenComplete(undefined, gameObjectName, propName);
	                        continue;

	                    }

	                    // GONAME.DATAKEY (boolean)
	                    var dataKey = propName;
	                    var matchFalseFlag = dataKey.startsWith('!');
	                    if (matchFalseFlag) {
	                        dataKey = dataKey.substring(1);
	                    }
	                    if (gameObjectManager.hasData(gameObjectName, propName)) {
	                        hasAnyWaitEvent = true;
	                        this.waitGameObjectDataFlag(undefined, gameObjectName, dataKey, !matchFalseFlag);
	                        continue;
	                    }

	                    // GONAME.EVTNAME
	                    this.waitEvent(gameObject, propName);
	                    continue;

	                } else if (names.length === 1) ;

	                break;

	        }
	    }

	    if (!hasAnyWaitEvent) {
	        this.waitTime(0);
	    }

	    return this.parent;
	};

	var methods$l = {
	    waitAny: WaitAny,
	};
	Object.assign(
	    methods$l,
	    WaitTimeMethods,
	    WaitInputMethods,
	    WaitGameObjectMethods,
	    WaitCameraMethods,
	    WaitMusicMethods,
	);

	class WaitEventManager extends WaitEvent$1 {
	    constructor(parent, config) {
	        super(parent);

	        this.waitCompleteEventName = GetValue$2b(config, 'completeEventName', this.waitCompleteEventName);

	        this.setClickTarget(GetValue$2b(config, 'clickTarget', this.scene));
	        this.setClickShortcutKeys(GetValue$2b(config, 'clickShortcutKeys', undefined));
	        this.setCameraTarget(GetValue$2b(config, 'camera', this.scene.cameras.main));
	    }

	    get clickTarget() {
	        return this.parent.clickTarget;
	    }

	    set clickTarget(value) {
	        this.parent.clickTarget = value;
	    }

	    get clickShortcutKeys() {
	        return this.parent.clickShortcutKeys;
	    }

	    set clickShortcutKeys(value) {
	        this.parent.clickShortcutKeys = value;
	    }

	    get cameraTarget() {
	        return this.parent.cameraTarget;
	    }

	    set cameraTarget(value) {
	        this.parent.cameraTarget = value;
	    }

	    destroy() {
	        this.clearClickTarget();
	        this.clearClickShortcutKeys();
	        this.clearCameraTarget();
	        super.destroy();
	    }

	    get scene() {
	        return this.parent.managersScene;
	    }
	}

	Object.assign(
	    WaitEventManager.prototype,
	    methods$l,
	);

	const GetValue$1W = Phaser.Utils.Objects.GetValue;

	var InitManagers = function (scene, config) {
	    this.clickTarget = undefined;
	    this.clickShortcutKeys = undefined;
	    this.cameraTarget = undefined;

	    this.managersScene = scene;

	    this.gameObjectManagers = {};

	    var layerNames = GetValue$1W(config, 'layers', false);
	    if (layerNames !== false) {
	        var layerManager = new LayerManager(scene, {
	            name: 'LAYER',
	            layers: layerNames,
	            rootLayer: GetValue$1W(config, 'rootLayer', undefined),
	            depth: GetValue$1W(config, 'layerDepth', undefined)
	        });
	        this.addGameObjectManager(layerManager);
	        this.layerManager = layerManager;
	    }

	    var soundManagerConfig = GetValue$1W(config, 'sounds');
	    if (soundManagerConfig !== false) {
	        this.soundManager = new SoundManager(scene, soundManagerConfig);
	    }

	    this.timeline = new Timeline(this);

	    this.waitEventManager = new WaitEventManager(this, config);

	    return this;
	};

	var SetTimeScale = function (value) {
	    this.timeline.timeScale = value;
	    for (var name in this.gameObjectManagers) {
	        this.gameObjectManagers[name].setTimeScale(value);
	    }
	    return this;
	};

	var GetTimeScale = function () {
	    return this.timeline.timeScale;
	};

	var DestroyManagers = function (fromScene) {
	    this.waitEventManager.destroy();
	    this.waitEventManager = undefined;

	    // Destroy layerManager at last
	    delete this.gameObjectManagers.layer;

	    for (var name in this.gameObjectManagers) {
	        this.gameObjectManagers[name].destroy(fromScene);
	        delete this.gameObjectManagers[name];
	    }

	    if (this.layerManager) {
	        this.layerManager.destroy(fromScene);
	        this.layerManager = undefined;
	    }

	    if (this.soundManager) {
	        this.soundManager.destroy();
	        this.soundManager = undefined;
	    }

	    if (this.timeline) {
	        this.timeline.destroy();
	        this.timeline = undefined;
	    }

	    this.clickTarget = undefined;
	    this.clickShortcutKeys = undefined;
	    this.cameraTarget = undefined;
	    this.managersScene = undefined;
	};

	var GameObjectManagerMethods$1 = {
	    addGameObjectManager(config, GameObjectManagerClass) {
	        var gameobjectManager;

	        if (config instanceof (GOManager)) {
	            gameobjectManager = config;

	        } else if (typeof (config) === 'string') {
	            gameobjectManager = GameObjectManagerClass;
	            gameobjectManager.name = config;

	        } else {
	            if (config === undefined) {
	                config = {};
	            }
	            if (GameObjectManagerClass === undefined) {
	                GameObjectManagerClass = GOManager;
	            }

	            if (!config.createGameObjectScope) {
	                config.createGameObjectScope = this;
	            }

	            gameobjectManager = new GameObjectManagerClass(this.managersScene, config);
	        }


	        this.gameObjectManagers[gameobjectManager.name] = gameobjectManager;

	        return this;
	    },

	    getGameObjectManager(managerName, gameObjectName) {
	        if (managerName) {
	            var manager = this.gameObjectManagers[managerName];
	            return manager;
	        } else {
	            if (gameObjectName && (gameObjectName.charAt(0) === '!')) {
	                gameObjectName = gameObjectName.substring(1);
	            }

	            for (var managerName in this.gameObjectManagers) {
	                var manager = this.gameObjectManagers[managerName];
	                if (manager.has(gameObjectName)) {
	                    return manager;
	                }
	            }
	        }
	    },

	    getGameObjectManagerNames() {
	        var names = [];
	        for (var name in this.gameObjectManagers) {
	            names.push(name);
	        }
	        return names;
	    },

	    getGameObjectManagerName(gameObjectName) {
	        var gameObjectManager = this.getGameObjectManager(undefined, gameObjectName);
	        if (!gameObjectManager) {
	            return undefined;
	        }
	        return gameObjectManager.name;
	    },

	    hasGameObjectMananger(managerName) {
	        return managerName in this.gameObjectManagers;
	    }
	};

	var GameObjectMethods$1 = {
	    createGameObject(goType, name, ...params) {
	        this.getGameObjectManager(goType, name).add(name, ...params);
	        return this;
	    },

	    destroyGameObject(goType, name) {
	        var gameObjectManager = this.getGameObjectManager(goType, name);
	        if (name === undefined) {
	            gameObjectManager.removeAll();
	        } else {
	            gameObjectManager.remove(name);
	        }
	        return this;
	    },

	    hasGameObject(goType, name) {
	        return !!this.getGameObjectManager(goType, name);
	    },

	    callGameObjectMethod(goType, name, methodName, ...params) {
	        this.getGameObjectManager(goType, name).call(name, methodName, ...params);
	        return this;
	    },

	    setGameObjectProperty(goType, name, prop, value) {
	        this.getGameObjectManager(goType, name).setProperty(name, prop, value);
	        return this;
	    },

	    easeGameObjectProperty(goType, name, config) {
	        this.getGameObjectManager(goType, name).easeProperty(name, config);
	        return this;
	    },

	    getGameObjectTweenTask(goType, name, property) {
	        return this.getGameObjectManager(goType, name).getTweenTask(name, property);
	    },

	    getGameObject(goType, name, out) {
	        var gameobjectManager = this.getGameObjectManager(goType, name);
	        if (!gameobjectManager) {
	            return out;
	        }
	        if (typeof (name) === 'string') {
	            return gameobjectManager.getGO(name);
	        } else {
	            if (out === undefined) {
	                out = [];
	            }

	            var names = name;
	            if (names === undefined) {
	                names = Object.keys(gameobjectManager.bobs);
	            }

	            var isArrayOutput = Array.isArray(out);
	            for (var i = 0, cnt = names.length; i < cnt; i++) {
	                name = names[i];
	                var gameObject = gameobjectManager.getGO(name);
	                if (!gameObject) {
	                    continue;
	                }

	                if (isArrayOutput) {
	                    out.push(gameObject);
	                } else {
	                    out[name] = gameObject;
	                }

	            }

	            return out;
	        }
	    },

	    addGameObject(goType, name, gameObject) {
	        var gameobjectManager = this.getGameObjectManager(goType, name);
	        if (typeof (name) === 'string') {
	            gameobjectManager.addGO(name, gameObject);
	        } else {
	            var names = name;
	            for (name in names) {
	                gameobjectManager.addGO(name, names[name]);
	            }
	        }
	        return this;
	    },

	    drawGameObjectsBounds(goTypes, graphics, config) {
	        if (goTypes instanceof Phaser.GameObjects.Graphics) {
	            config = graphics;
	            graphics = goTypes;
	            goTypes = undefined;
	        }

	        if (goTypes === undefined) {
	            goTypes = this.getGameObjectManagerNames();
	        }

	        if (!Array.isArray(goTypes)) {
	            goTypes = [goTypes];
	        }
	        for (var i = 0, cnt = goTypes.length; i < cnt; i++) {
	            this.getGameObjectManager(goTypes[i]).drawGameObjectsBounds(graphics, config);
	        }

	        return this;
	    }

	};

	var Extend = function (BaseClass) {
	    class Managers extends BaseClass { }

	    var Methods = {
	        initManagers: InitManagers,
	        setTimeScale: SetTimeScale,
	        getTimeScale: GetTimeScale,
	        destroyManagers: DestroyManagers,
	    };

	    Object.assign(
	        Managers.prototype,
	        Methods,
	        GameObjectManagerMethods$1,
	        GameObjectMethods$1,
	    );

	    return Managers;
	};

	const EventEmitter = Phaser.Events.EventEmitter;

	class Managers extends Extend(EventEmitter) {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        // Fire 'complete' event to resume running of eventSheetGroup
	        config.completeEventName = 'complete';  

	        if (!config.hasOwnProperty('layers')) {
	            config.layers = undefined;
	        }

	        super();

	        this.scene = scene;

	        this.initManagers(scene, config);
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene) {
	            return;
	        }

	        this.destroyManagers(fromScene);

	        this.scene = undefined;

	        super.destroy();
	    }
	}

	var EventEmitterMethods = {
	    setEventEmitter(eventEmitter, EventEmitterClass) {
	        if (EventEmitterClass === undefined) {
	            EventEmitterClass = EventEmitter$2;
	        }
	        this._privateEE = (eventEmitter === true) || (eventEmitter === undefined);
	        this._eventEmitter = (this._privateEE) ? (new EventEmitterClass()) : eventEmitter;
	        return this;
	    },

	    destroyEventEmitter() {
	        if (this._eventEmitter && this._privateEE) {
	            this._eventEmitter.shutdown();
	        }
	        return this;
	    },

	    getEventEmitter() {
	        return this._eventEmitter;
	    },

	    on: function () {
	        if (this._eventEmitter) {
	            this._eventEmitter.on.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    once: function () {
	        if (this._eventEmitter) {
	            this._eventEmitter.once.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    off: function () {
	        if (this._eventEmitter) {
	            this._eventEmitter.off.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    emit: function (event) {
	        if (this._eventEmitter && event) {
	            this._eventEmitter.emit.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    addListener: function () {
	        if (this._eventEmitter) {
	            this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    removeListener: function () {
	        if (this._eventEmitter) {
	            this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    removeAllListeners: function () {
	        if (this._eventEmitter) {
	            this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
	        }
	        return this;
	    },

	    listenerCount: function () {
	        if (this._eventEmitter) {
	            return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
	        }
	        return 0;
	    },

	    listeners: function () {
	        if (this._eventEmitter) {
	            return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
	        }
	        return [];
	    },

	    eventNames: function () {
	        if (this._eventEmitter) {
	            return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
	        }
	        return [];
	    },
	};

	// https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js

	var EscapeRegex = function (s) {
	    return s
	        .replace(re0, '\\$&')
	        .replace(re1, '\\x2d');
	};

	var re0 = /[|\\{}()[\]^$+*?.]/g;
	var re1 = /-/g;

	// This class might be used standalone

	let BracketParser$1 = class BracketParser {
	    constructor(config) {
	        // Event emitter
	        this.setEventEmitter(GetValue$2b(config, 'eventEmitter', undefined));

	        // Value convert
	        this.setValueConverter(GetValue$2b(config, 'valueConvert', true));
	        // Loop
	        this.setLoopEnable(GetValue$2b(config, 'loop', false));

	        // Brackets and generate regex
	        this.setMultipleLinesTagEnable(GetValue$2b(config, 'multipleLinesTag', false));
	        var delimiters = GetValue$2b(config, 'delimiters', '<>');
	        this.setDelimiters(delimiters[0], delimiters[1]);

	        // Translate tagName callback
	        this.setTranslateTagNameCallback(GetValue$2b(config, 'translateTagNameCallback'));

	        this.isRunning = false;
	        this.isPaused = false;
	        this.skipEventFlag = false;
	        this.justCompleted = false;
	        this.lastTagStart = null;
	        this.lastTagEnd = null;
	        this.lastContent = null;
	    }

	    shutdown() {
	        this.destroyEventEmitter();
	    }

	    destroy() {
	        this.shutdown();
	    }

	    setMultipleLinesTagEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.multipleLinesTagEnable = enable;
	        return this;
	    }

	    // Override
	    setDelimiters(delimiterLeft, delimiterRight) {
	        if (delimiterRight === undefined) {
	            delimiterRight = delimiterLeft[1];
	            delimiterLeft = delimiterLeft[0];
	        }
	        this.delimiterLeft = delimiterLeft;
	        this.delimiterRight = delimiterRight;

	        delimiterLeft = EscapeRegex(this.delimiterLeft);
	        delimiterRight = EscapeRegex(this.delimiterRight);

	        var flag = (this.multipleLinesTagEnable) ? 'gs' : 'gi';
	        this.reSplit = RegExp(`${delimiterLeft}(.+?)${delimiterRight}`, flag);

	        return this;
	    }

	    setTranslateTagNameCallback(callback) {
	        this.translateTagNameCallback = callback;
	        return this;
	    }

	    setValueConverter(converter) {
	        if (converter === true) {
	            converter = TypeConvert;
	        } else if (!converter) {
	            converter = BypassValueConverter;
	        }
	        this.valueConverter = converter;
	        return this;
	    }

	    setLoopEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.loopEnable = enable;
	        return this;
	    }

	    setSource(source) {
	        this.source = source;
	        return this;
	    }

	    resetIndex(index) {
	        if (index === undefined) {
	            index = 0;
	        }
	        this.progressIndex = index;
	        this.reSplit.lastIndex = index;
	        this.lastTagStart = null;
	        this.lastTagEnd = null;
	        this.lastContent = null;
	        this.justCompleted = false;
	        this.isRunning = false;
	        return this;
	    }

	    start(source) {
	        this
	            .setSource(source)
	            .restart();
	        return this;
	    }

	    restart() {
	        this
	            .resetIndex()
	            .next();
	    }

	    next() {
	        if (this.isPaused) {
	            this.onResume();
	        }

	        // Don't re-enter this method
	        if (this.isRunning) {
	            return this;
	        }

	        this.isRunning = true;

	        if (this.justCompleted) {
	            this.isRunning = false;
	            return this;
	        }

	        if (this.reSplit.lastIndex === 0) {
	            this.onStart();
	        }

	        var text = this.source,
	            lastIndex = text.length;

	        this.reSplit.lastIndex = this.progressIndex;
	        while (true) {
	            var regexResult = this.reSplit.exec(text);
	            // No tag found, complete
	            if (!regexResult) {
	                if (this.progressIndex < lastIndex) {
	                    this.onContent(text.substring(this.progressIndex, lastIndex));
	                    // Might pause here
	                    if (this.isPaused) {
	                        this.progressIndex = lastIndex;
	                        break;
	                    }
	                }
	                this.onComplete();
	                this.isRunning = false;
	                return;
	            }

	            var matchEnd = this.reSplit.lastIndex;
	            var matchStart = matchEnd - regexResult[0].length;

	            // Process content between previous tag and current tag            
	            if (this.progressIndex < matchStart) {
	                this.onContent(text.substring(this.progressIndex, matchStart));
	                // Might pause here
	                if (this.isPaused) {
	                    this.progressIndex = matchStart;
	                    break;
	                }
	            }

	            // Process current tag
	            this.lastTagSource = regexResult[0];
	            this.onTag(regexResult[1]);
	            this.lastTagSource = undefined;

	            this.progressIndex = matchEnd;
	            // Might pause here
	            if (this.isPaused) {
	                break;
	            }

	        }

	        this.isRunning = false;
	        return this;
	    }

	    skipEvent() {
	        this.skipEventFlag = true;
	        return this;
	    }

	    pause() {
	        if (!this.isPaused) {
	            this.onPause();
	        }
	        return this;
	    }

	    pauseUntilEvent(eventEmitter, eventName) {
	        if (this.isPaused) {
	            return this;
	        }

	        this.pause();
	        eventEmitter.once(eventName, function () {
	            this.next();
	        }, this);
	        return this;
	    }

	    onContent(content) {
	        this.skipEventFlag = false;
	        this.emit('content', content);
	        this.lastContent = content;
	    }

	    // Override
	    onTag(tagContent) {

	    }

	    onStart() {
	        this.isRunning = true;
	        this.emit('start', this);
	    }

	    onComplete() {
	        this.isRunning = false;
	        this.justCompleted = true;
	        this.emit('complete', this);
	        if (this.loopEnable) {
	            this.resetIndex();
	        }
	    }

	    onPause() {
	        this.isPaused = true;
	        this.emit('pause', this);
	    }

	    onResume() {
	        this.isPaused = false;
	        this.emit('resume', this);
	    }

	};

	const BypassValueConverter = function (s) { return s; };

	Object.assign(
	    BracketParser$1.prototype,
	    EventEmitterMethods,
	);

	var StringToValues = function (text, valueConverter, delimiter) {
	    if (text == null) {
	        return [];
	    }
	    if (valueConverter === undefined) {
	        valueConverter = TypeConvert;
	    }
	    if (delimiter === undefined) {
	        delimiter = ',';
	    }

	    var values = text.split(delimiter);
	    for (var i = 0, cnt = values.length; i < cnt; i++) {
	        values[i] = valueConverter(values[i]);
	    }
	    return values;
	};

	class BracketParser extends BracketParser$1 {
	    constructor(config) {
	        if (config === undefined) {
	            config = {};
	        }

	        if (!config.hasOwnProperty('multipleLinesTag')) {
	            config.multipleLinesTag = false;
	        }

	        super(config);

	        // Parameters for regex
	        this.setTagExpression(GetValue$2b(config, 'regex.tag', undefined));
	        this.setValueExpression(GetValue$2b(config, 'regex.value', undefined));
	        // Brackets and generate regex
	        var delimiters = GetValue$2b(config, 'delimiters', '<>');
	        this.setDelimiters(delimiters[0], delimiters[1]);
	    }

	    setTagExpression(express) {
	        if (!express) {
	            express = DefaultTokenExpression;
	        }
	        this.tagExpression = express;
	        return this;
	    }

	    setValueExpression(express) {
	        if (!express) {
	            express = DefaultTokenExpression;
	        }
	        this.valueExpression = express;
	        return this;
	    }

	    setDelimiters(delimiterLeft, delimiterRight) {
	        super.setDelimiters(delimiterLeft, delimiterRight);

	        var tag = `(${this.tagExpression})(=(${this.valueExpression}))?`;
	        this.reTag = RegExp(tag, 'i');

	        if ((this.tagExpression !== DefaultTokenExpression) || (this.valueExpression !== DefaultTokenExpression)) {
	            var startTagExpression = `${this.tagExpression}(=${this.valueExpression})?`;
	            var endTagExpression = `/${this.tagExpression}`;

	            delimiterLeft = EscapeRegex(this.delimiterLeft);
	            delimiterRight = EscapeRegex(this.delimiterRight);

	            var flag = (this.multipleLinesTagEnable) ? 'gs' : 'gi';
	            this.reSplit = RegExp(`${delimiterLeft}((${startTagExpression})|(${endTagExpression}))${delimiterRight}`, flag);
	        }

	        return this;
	    }

	    onTag(tagContent) {
	        var regexResult = tagContent.match(this.reTag);
	        var tagName = regexResult[1];
	       
	        var isEndTag = (tagName.charAt(0) === '/');
	        if (isEndTag) {
	            tagName = tagName.substring(1, tagName.length);
	        }

	        if (this.translateTagNameCallback) {
	            tagName = this.translateTagNameCallback(tagName);
	        }

	        this.skipEventFlag = false;
	        if (!isEndTag) {
	            var values = StringToValues(regexResult[3], this.valueConverter);
	            this.emit(`+${tagName}`, ...values);
	            if (!this.skipEventFlag) {
	                this.emit('+', tagName, ...values);
	            }
	            this.lastTagStart = tagName;
	        } else {
	            this.emit(`-${tagName}`);
	            if (!this.skipEventFlag) {
	                this.emit('-', tagName);
	            }
	            this.lastTagEnd = tagName;
	        }
	    }
	}

	const DefaultTokenExpression = `[^=]+`;

	var OnParseColorTag = function (parser) {
	    parser
	        .on('+color', function (color) {
	            parser.addStyle('color', color);
	            parser.skipEvent();
	        })
	        .on('-color', function () {
	            parser.removeStyle('color');
	            parser.skipEvent();
	        });
	};

	var OnParseBackgroundColorTag = function (parser) {
	    parser
	        .on('+bgcolor', function (color) {
	            parser.addStyle('background-color', color);
	            parser.skipEvent();
	        })
	        .on('-bgcolor', function () {
	            parser.removeStyle('background-color');
	            parser.skipEvent();
	        });
	};

	var ParseBoldTag = function (parser) {
	    parser
	        .on('+b', function () {
	            parser.addStyle('font-weight', 'bold');
	            parser.skipEvent();
	        })
	        .on('-b', function () {
	            parser.removeStyle('font-weight');
	            parser.skipEvent();
	        });
	};

	var OnParseItalicTag = function (parser) {
	    parser
	        .on('+i', function () {
	            parser.addStyle('font-style', 'italic');
	            parser.skipEvent();
	        })
	        .on('-i', function () {
	            parser.removeStyle('font-style');
	            parser.skipEvent();
	        });
	};

	var OnParseSizeTag = function (parser) {
	    parser
	        .on('+size', function (size) {
	            if (typeof (size) === 'number') {
	                size = `${size}px`;
	            }
	            parser.addStyle('font-size', size);
	            parser.skipEvent();
	        })
	        .on('-size', function () {
	            parser.removeStyle('font-size');
	            parser.skipEvent();
	        });
	};

	var OnParseUnderlineTag = function (parser) {
	    parser
	        .on('+u', function () {
	            parser.addStyle('text-decoration', 'underline');
	            parser.skipEvent();
	        })
	        .on('-u', function () {
	            parser.removeStyle('text-decoration');
	            parser.skipEvent();
	        });
	};

	var OnParseShadowTag = function (parser) {
	    parser
	        .on('+shadow', function (color) {
	            parser.addStyle('text-shadow', `1px 1px 3px ${color}`);
	            parser.skipEvent();
	        })
	        .on('-shadow', function () {
	            parser.removeStyle('text-shadow');
	            parser.skipEvent();
	        });
	};

	var OnParseRoundBlockTag = function (parser) {
	    parser
	        .on('+round', function (radius, padding) {
	            if (radius === undefined) {
	                radius = 3;
	            }
	            if (padding === undefined) {
	                padding = radius;
	            }

	            if (typeof (radius) === 'number') {
	                radius = `${radius}px`;
	            }
	            if (typeof (padding) === 'number') {
	                padding = `${padding}px`;
	            }

	            parser.addStyle('display', 'inline-block');
	            parser.addStyle('border-radius', radius);
	            parser.addStyle('padding', padding);
	            parser.skipEvent();
	        })
	        .on('-round', function () {
	            parser.removeStyle('display');
	            parser.removeStyle('border-radius');
	            parser.removeStyle('padding');
	            parser.skipEvent();
	        });
	};

	var OnParseFontFamilyTag = function (parser) {
	    parser
	        .on('+family', function (family) {
	            parser.addStyle('font-family', family);
	            parser.skipEvent();
	        })
	        .on('-family', function () {
	            parser.removeStyle('font-family');
	            parser.skipEvent();
	        });
	};

	var ParseContent = function (parser) {
	    parser
	        .on('content', function (content) {
	            parser.addContent(content);
	            parser.skipEvent();
	        })
	        .on('+', function () {
	            parser.addContent(parser.lastTagSource);
	            parser.skipEvent();
	        })
	        .on('-', function () {
	            parser.addContent(parser.lastTagSource);
	            parser.skipEvent();
	        });
	};

	var ParseHandlers = [
	    OnParseColorTag,
	    OnParseBackgroundColorTag,
	    ParseBoldTag,
	    OnParseItalicTag,
	    OnParseSizeTag,
	    OnParseUnderlineTag,
	    OnParseShadowTag,
	    OnParseRoundBlockTag,
	    OnParseFontFamilyTag,
	    ParseContent
	];

	var Clear = function (obj) {
	    if ((typeof (obj) !== 'object') || (obj === null)) {
	        return obj;
	    }

	    if (Array.isArray(obj)) {
	        obj.length = 0;
	    } else {
	        for (var key in obj) {
	            delete obj[key];
	        }
	    }

	    return obj;
	};

	/**
	 * Shallow Object Clone. Will not out nested objects.
	 * @param {object} obj JSON object
	 * @param {object} ret JSON object to return, set null to return a new object
	 * @returns {object} this object
	 */
	var Clone = function (obj, out) {
	    var objIsArray = Array.isArray(obj);

	    if (out === undefined) {
	        out = (objIsArray) ? [] : {};
	    } else {
	        Clear(out);
	    }

	    if (objIsArray) {
	        out.length = obj.length;
	        for (var i = 0, cnt = obj.length; i < cnt; i++) {
	            out[i] = obj[i];
	        }
	    } else {
	        for (var key in obj) {
	            out[key] = obj[key];
	        }
	    }

	    return out;
	};

	let Parser$1 = class Parser extends BracketParser {
	    constructor(config) {
	        super(config);

	        this.segments = [];
	        this.lastPropFlags = {};

	        for (var i = 0, cnt = ParseHandlers.length; i < cnt; i++) {
	            ParseHandlers[i](this);
	        }
	    }

	    clearBuffers() {
	        this.segments.length = 0;
	        this.lastPropFlags = {};
	        return this;
	    }

	    addStyle(name, value) {
	        this.lastPropFlags[name] = value;
	        return this;
	    }

	    removeStyle(name) {
	        delete this.lastPropFlags[name];
	        return this;
	    }

	    addContent(content) {
	        this.segments.push(Clone(this.lastPropFlags));
	        this.segments.push(content);
	        return this;
	    }

	    parse(s) {
	        this.start(s);

	        var result = [];
	        for (var i = 0, cnt = this.segments.length; i < cnt; i++) {
	            var text = this.segments[i];
	            if (typeof (text) !== 'string') {
	                continue;
	            }

	            var propFlags = this.segments[i - 1];
	            if (typeof (propFlags) === 'object') {
	                result.push({
	                    value: text,
	                    css: PropToStyle(propFlags)
	                });
	            } else {
	                result.push({
	                    value: text,
	                    css: null
	                });
	            }
	        }

	        this.clearBuffers();

	        return result;
	    }
	};

	var PropToStyle = function (propFlags) {
	    var styles = [];
	    for (var propName in propFlags) {
	        styles.push(`${propName}:${propFlags[propName]}`);
	    }

	    return styles.join(';');
	};

	class BBCodeLog {
	    constructor({
	        delimiters = '[]',
	        enable = true
	    } = {}) {

	        this.parser = new Parser$1({
	            delimiters: delimiters
	        });

	        this.enable = enable;
	    }

	    setEnable(enable = true) {
	        this.enable = enable;
	        return this;
	    }

	    log(s, logType = 'log') {
	        if (!this.enable) {
	            return this;
	        }

	        if (typeof (s) == 'string') {
	            var inputs = [];
	            var modifiers = [];
	            this.parser.parse(s).forEach(function (item) {
	                inputs.push(`%c${item.value}`);
	                modifiers.push(item.css);
	            });

	            console[logType].call(console, inputs.join(''), ...modifiers);

	        } else {
	            console[logType](s);

	        }

	        return this;
	    }
	}

	var AddCommand = function (name, callback, scope) {
	    if (scope === undefined) {
	        scope = this;
	    }
	    if (scope) {
	        callback = callback.bind(scope);
	    }

	    if (this[name]) {
	        console.warn(`CommandExecutor: method '${name} is existed.`);
	    }

	    this[name] = callback;
	    return this;
	};

	var DataMethods$1 = {
	    setData(config, eventSheetManager, eventsheet) {
	        for (var name in config) {
	            eventSheetManager.setData(name, config[name]);
	        }
	    },

	    incData(config, eventSheetManager, eventsheet) {
	        for (var name in config) {
	            eventSheetManager.incData(name, config[name]);
	        }
	    },

	    toggleData(config, eventSheetManager, eventsheet) {
	        for (var name in config) {
	            eventSheetManager.toggleData(name, config[name]);
	        }
	    },
	};

	var WaitMethods = {

	    wait(config, eventSheetManager, eventsheet) {
	        var { click, key, event } = config;

	        if (click) {
	            eventSheetManager.emit('pause.click');
	        }

	        if (key) {
	            eventSheetManager.emit('pause.key', config.key);
	        }

	        if (click | key) {
	            eventSheetManager.emit('pause.input');
	            this.sys.once('complete', function () {
	                eventSheetManager.emit('resume.input');
	            });
	        }

	        if (event) {
	            this.sys.waitEventManager.waitEvent(eventSheetManager, event);
	        }

	        this.sys.waitEventManager.waitAny(config);
	        eventSheetManager.pauseEventSheetUnitlEvent(this.sys, 'complete');
	        return this;
	    },

	    click(config, eventSheetManager, eventsheet) {
	        this.wait({ click: true }, eventSheetManager);
	        return this;
	    },

	    // Internal method
	    bindEventSheetManager(eventSheetManager) {
	        this.__eventSheetManager = eventSheetManager;
	    },

	    unBindEventSheetManager() {
	        this.__eventSheetManager = undefined;
	    },

	    _waitComplete() {
	        this.__eventSheetManager.pauseEventSheetUnitlEvent(this.sys, 'complete');
	    },

	    waitEvent(eventEmitter, eventName) {
	        this.sys.waitEventManager.waitEvent(eventEmitter, eventName);
	        this._waitComplete();
	        return this;
	    },

	};

	var BindEventWithGameObject = function (gameObject, eventEmitter, eventName, callback, scope, once) {
	    if (once === undefined) {
	        once = false;
	    }

	    eventEmitter[(once) ? 'once' : 'on'](eventName, callback, scope);

	    gameObject.once('destroy', function () {
	        eventEmitter.off(eventName, callback, scope);
	    });

	    return gameObject;
	};

	var BindEventWidthScene = function (scene, eventEmitter, eventName, callback, scope, once) {
	    if (once === undefined) {
	        once = false;
	    }

	    eventEmitter[(once) ? 'once' : 'on'](eventName, callback, scope);

	    scene.sys.events.once('shutdown', function () {
	        eventEmitter.off(eventName, callback, scope);
	    });

	    return scene;
	};

	var AddEvent = function (bindingTarget, eventEmitter, eventName, callback, scope, once) {
	    if (!IsSceneObject(bindingTarget)) {
	        BindEventWithGameObject(bindingTarget, eventEmitter, eventName, callback, scope, once);
	    } else {
	        BindEventWidthScene(bindingTarget, eventEmitter, eventName, callback, scope, once);
	    }

	    return bindingTarget;
	};

	var GameObjectManagerMethods = {
	    addGameObjectManager(config) {
	        // Register GameObjectManager
	        var sys = this.sys;
	        sys.addGameObjectManager(config);

	        var {
	            name, defaultLayer,
	            commands = {},
	            autoClear = true
	        } = config;

	        // Add custom commands
	        var gameObjectManager = sys.getGameObjectManager(name);
	        gameObjectManager.commands = commands;

	        var defaultAutoClear = autoClear;

	        // Add createGameObject command
	        var createGameObjectCallback = function (config, eventSheetManager, eventsheet) {
	            var {
	                id,
	                layer = defaultLayer,
	                autoClear = defaultAutoClear
	            } = config;

	            config.commandExecutor = this;
	            config.eventSheetManager = eventSheetManager;
	            config.eventsheet = eventsheet;

	            sys.createGameObject(name, id, config);
	            // Execute next command

	            delete config.commandExecutor;
	            delete config.eventSheetManager;
	            delete config.eventsheet;

	            if (layer) {
	                var layerManager = sys.layerManager;
	                if (layerManager) {
	                    var gameObject = sys.getGameObject(name, id);
	                    layerManager.addToLayer(layer, gameObject);
	                }
	            }

	            // Put reference of game object into memory
	            var memoryKey = `@${id}`;
	            if (eventSheetManager.hasData(memoryKey)) {
	                console.warn(`CommandExecutor: Duplicated GameObject ID=${id}`);
	            }
	            eventSheetManager.setData(memoryKey, gameObject);
	            gameObject.once('destroy', function () {
	                eventSheetManager.removeData(memoryKey);
	            });

	            if (autoClear) {
	                var gameObject = sys.getGameObject(name, id);

	                // When exit this eventsheet, destroy this game object (remove from gameObjectManager)
	                AddEvent(
	                    gameObject,
	                    eventSheetManager, 'eventsheet.exit',
	                    function (title, groupName, eventSheetManager) {
	                        if ((eventsheet.title === title) && (eventsheet.groupName === groupName)) {
	                            gameObjectManager.remove(id, true);
	                        }
	                    }
	                );
	            }
	        };
	        this.addCommand(name, createGameObjectCallback, null);

	        return this;
	    },

	    addGameObjectCommand(goType, commandName, callback) {
	        this.sys.getGameObjectManager(goType).commands[commandName] = callback;
	        return this;
	    },

	};

	var GameObjectMethods = {
	    setGOProperty(
	        config,
	        eventSheetManager, eventSheet
	    ) {

	        var { id, goType } = config;
	        delete config.id;
	        delete config.goType;

	        if (!goType) {
	            goType = this.sys.getGameObjectManagerName(id);
	        }
	        if (!goType) {
	            return this;
	        }

	        for (var prop in config) {
	            var value = eventSheetManager.evalExpression(config[prop]);
	            this.sys.setGameObjectProperty(goType, id, prop, value);
	        }
	        return this;
	    },

	    easeGOProperty(
	        config,
	        eventSheetManager, eventSheet
	    ) {

	        var { id, goType, duration, delay, ease, repeat, yoyo, from = false, wait = true } = config;
	        delete config.id;
	        delete config.goType;
	        delete config.duration;
	        delete config.delay;
	        delete config.ease;
	        delete config.repeat;
	        delete config.yoyo;
	        delete config.from;
	        delete config.wait;

	        if (!goType) {
	            goType = this.sys.getGameObjectManagerName(id);
	        }
	        if (!goType) {
	            return this;
	        }

	        var waitProperty;
	        for (var property in config) {
	            var value = eventSheetManager.evalExpression(config[property]);
	            this.sys.easeGameObjectProperty(goType, id, {
	                property, value,
	                duration, delay,
	                ease,
	                repeat, yoyo, from
	            });

	            if (!waitProperty) {
	                waitProperty = property;
	            }
	        }
	        if (wait && waitProperty) {
	            this.sys.waitEventManager.waitGameObjectTweenComplete(goType, id, waitProperty);
	            this._waitComplete();
	        }
	        return this;
	    },

	    destroyGO(
	        config,
	        eventSheetManager, eventSheet
	    ) {

	        var { id, goType, wait = false } = config;

	        if (!goType) {
	            goType = this.sys.getGameObjectManagerName(id);
	        }
	        if (!goType) {
	            return this;
	        }

	        this.sys.destroyGameObject(goType, id);
	        if (wait) {
	            this.sys.waitEventManager.waitGameObjectDestroy(goType, id);
	            this._waitComplete();
	        }
	        return this;
	    },

	    runGOMethod(
	        config,
	        eventSheetManager, eventSheet
	    ) {

	        var { id, goType, methodName, parameters } = config;

	        if (!goType) {
	            goType = this.sys.getGameObjectManagerName(id);
	        }
	        if (!goType) {
	            return this;
	        }

	        this.sys.callGameObjectMethod(goType, config.id, methodName, ...parameters);
	        return this;
	    },

	    getGameObject(name, out) {
	        if (this.sys.hasGameObjectMananger(name)) {
	            return this.sys.getGameObject(name, undefined, out);
	        } else {
	            return this.sys.getGameObject(undefined, name, out);
	        }
	    },
	};

	var BackgroundMusicMethods = {
	    'bgm.set'(
	        {
	            volume, mute, unmute
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        if (volume !== undefined) {
	            soundManager.setBackgroundMusicVolume(volume);
	        }

	        if (mute !== undefined) {
	            soundManager.setBackgroundMusicMute(mute);
	        } else if (unmute !== undefined) {
	            soundManager.setBackgroundMusicMute(!unmute);
	        }
	    },

	    'bgm.play'(
	        {
	            key,
	            volume, detune, rate, fadeIn = 0, loop,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        if (!key) {
	            return this;
	        }

	        if (loop !== undefined) {
	            soundManager.setBackgroundMusicLoopValue(loop);
	        }

	        soundManager.playBackgroundMusic(key);

	        if (volume !== undefined) {
	            soundManager.setBackgroundMusicVolume(volume);
	        }

	        if (detune !== undefined) {
	            soundManager.setBackgroundMusicDetune(detune);
	        }

	        if (rate !== undefined) {
	            soundManager.setBackgroundMusicRate(rate);
	        }

	        if (fadeIn > 0) {
	            soundManager.fadeInBackgroundMusic(fadeIn);
	        }

	        if (wait) {
	            this.wait({ bgm: true }, eventSheetManager);
	        }
	        return this;
	    },

	    'bgm.cross'(
	        {
	            key,
	            duration = 500,
	            wait = false
	        },
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        if (!key) {
	            return this;
	        }

	        soundManager.crossFadeBackgroundMusic(key, duration);

	        if (wait) {
	            this.wait({ bgm: true }, eventSheetManager);
	        }
	        return this;
	    },

	    'bgm.stop'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.stopBackgroundMusic();
	        return this;
	    },

	    'bgm.fadeOut'(
	        {
	            duration = 500, stop = true,
	            wait = false
	        },
	        eventSheetManager
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.fadeOutBackgroundMusic2(duration, stop);

	        if (wait) {
	            this.wait({ bgm: true }, eventSheetManager);
	        }
	        return this;
	    },

	    'bgm.fadeIn'(
	        {
	            duration = 500
	        },
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.fadeInBackgroundMusic(duration);
	        return this;
	    },

	    'bgm.pause'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.pauseBackgroundMusic();
	        return this;
	    },

	    'bgm.resume'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.resumeBackgroundMusic();
	        return this;
	    },

	    'bgm.mute'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        soundManager.setBackgroundMusicMute(true);
	        return this;
	    },

	    'bgm.unmute'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        soundManager.setBackgroundMusicMute(false);
	        return this;
	    },
	};

	var BackgroundMusic2Methods = {
	    'bgm2.set'(
	        {
	            volume, mute, unmute
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        if (volume !== undefined) {
	            soundManager.setBackgroundMusic2Volume(volume);
	        }

	        if (mute !== undefined) {
	            soundManager.setBackgroundMusic2Mute(mute);
	        } else if (unmute !== undefined) {
	            soundManager.setBackgroundMusic2Mute(!unmute);
	        }
	        return this;
	    },

	    'bgm2.play'(
	        {
	            key,
	            volume, detune, rate, fadeIn = 0, loop,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        if (!key) {
	            return this;
	        }

	        if (loop !== undefined) {
	            soundManager.setBackgroundMusic2LoopValue(loop);
	        }

	        soundManager.playBackgroundMusic2(key);

	        if (volume !== undefined) {
	            soundManager.setBackgroundMusic2Volume(volume);
	        }

	        if (detune !== undefined) {
	            soundManager.setBackgroundMusic2Detune(detune);
	        }

	        if (rate !== undefined) {
	            soundManager.setBackgroundMusic2Rate(rate);
	        }

	        if (fadeIn > 0) {
	            soundManager.fadeInBackgroundMusic2(fadeIn);
	        }

	        if (wait) {
	            this.wait({ bgm: true }, eventSheetManager);
	        }

	        return this;
	    },

	    'bgm2.cross'(
	        {
	            key,
	            duration = 500,
	            wait = false
	        },
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        if (!key) {
	            return this;
	        }

	        soundManager.crossFadeBackgroundMusic2(key, duration);

	        if (wait) {
	            this.wait({ bgm: true }, eventSheetManager);
	        }

	        return this;
	    },

	    'bgm2.stop'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.stopBackgroundMusic2();
	        return this;
	    },

	    'bgm2.fadeOut'(
	        {
	            duration = 500, stop = true,
	            wait = false
	        },
	        eventSheetManager
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.fadeOutBackgroundMusic2(duration, stop);

	        if (wait) {
	            this.wait({ bgm: true }, eventSheetManager);
	        }
	        return this;
	    },

	    'bgm2.fadeIn'(
	        {
	            duration = 500
	        },
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.fadeInBackgroundMusic2(duration);
	        return this;
	    },

	    'bgm2.pause'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.pauseBackgroundMusic2();
	        return this;
	    },

	    'bgm2.resume'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.resumeBackgroundMusic2();
	        return this;
	    },

	    'bgm2.mute'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        soundManager.setBackgroundMusic2Mute(true);
	        return this;
	    },

	    'bgm2.unmute'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        soundManager.setBackgroundMusic2Mute(false);
	        return this;
	    },
	};

	var SoundEffectsMethods = {
	    'se.set'(
	        {
	            volume, mute, unmute
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        if (volume !== undefined) {
	            soundManager.setSoundEffectVolume(volume);
	        }

	        if (mute !== undefined) {
	            soundManager.setSoundEffectMute(mute);
	        } else if (unmute !== undefined) {
	            soundManager.setSoundEffectMute(!unmute);
	        }
	        return this;
	    },

	    'se.play'(
	        {
	            key,
	            volume, detune, rate, fadeIn = 0,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        if (!key) {
	            return this;
	        }

	        soundManager.playSoundEffect(key);

	        if (volume !== undefined) {
	            soundManager.setSoundEffectVolume(volume, true);
	        }

	        if (detune !== undefined) {
	            soundManager.setSoundEffectDetune(detune, true);
	        }

	        if (rate !== undefined) {
	            soundManager.setSoundEffectRate(rate, true);
	        }

	        if (fadeIn > 0) {
	            soundManager.fadeInSoundEffect(fadeIn);
	        }

	        if (wait) {
	            this.wait({ se: true }, eventSheetManager);
	        }
	        return this;
	    },

	    'se.stop'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.stopAllSoundEffects();
	        return this;
	    },

	    'se.fadeOut'(
	        {
	            duration = 500, stop = true,
	            wait = false
	        },
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.fadeOutSoundEffect(duration, stop);

	        if (wait) {
	            this.wait({ bgm: true }, eventSheetManager);
	        }
	        return this;
	    },

	    'se.mute'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        soundManager.setSoundEffectMute(true);
	        return this;
	    },

	    'se.unmute'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        soundManager.setSoundEffectMute(false);
	        return this;
	    },
	};

	var SoundEffects2Methods = {
	    'se2.set'(
	        {
	            volume, mute, unmute
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        if (volume !== undefined) {
	            soundManager.setSoundEffect2Volume(volume);
	        }

	        if (mute !== undefined) {
	            soundManager.setSoundEffect2Mute(mute);
	        } else if (unmute !== undefined) {
	            soundManager.setSoundEffect2Mute(!unmute);
	        }
	        return this;
	    },

	    'se2.play'(
	        {
	            key,
	            volume, detune, rate, fadeIn = 0,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        if (!key) {
	            return this;
	        }

	        soundManager.playSoundEffect2(key);

	        if (volume !== undefined) {
	            soundManager.setSoundEffect2Volume(volume, true);
	        }

	        if (detune !== undefined) {
	            soundManager.setSoundEffect2Detune(detune, true);
	        }

	        if (rate !== undefined) {
	            soundManager.setSoundEffect2Rate(rate, true);
	        }

	        if (fadeIn > 0) {
	            soundManager.fadeInSoundEffect2(fadeIn);
	        }

	        if (wait) {
	            this.wait({ se: true }, eventSheetManager);
	        }
	        return this;
	    },

	    'se2.stop'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.stopAllSoundEffects2();
	        return this;
	    },

	    'se2.fadeOut'(
	        {
	            duration = 500,
	            stop = true,
	            wait = false
	        },
	        eventSheetManager, eventsheet
	    ) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }
	        soundManager.fadeOutSoundEffect2(duration, stop);

	        if (wait) {
	            this.wait({ bgm: true }, eventSheetManager);
	        }
	        return this;
	    },

	    'se2.mute'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        soundManager.setSoundEffect2Mute(true);
	        return this;
	    },

	    'se2.unmute'(config, eventSheetManager, eventsheet) {

	        var soundManager = this.sys.soundManager;
	        if (!soundManager) {
	            return this;
	        }

	        soundManager.setSoundEffect2Mute(false);
	        return this;
	    },
	};

	var CameraMethods = {
	    'camera.set'(
	        {
	            x, y, rotate, zoom,
	            name
	        } = {},
	        eventSheetManager, eventsheet
	    ) {
	        var camera;
	        if (name) {
	            camera = this.sys.scene.cameras.getCamera(name);
	        } else {
	            camera = this.sys.cameraTarget;
	        }

	        if (!camera) {
	            return this;
	        }

	        if ((x !== undefined) || (y !== undefined)) {
	            camera.setScroll(x, y);
	        }
	        if (rotate !== undefined) {
	            camera.setRotation(rotate);
	        }
	        if (zoom !== undefined) {
	            camera.setZoom(zoom);
	        }
	        return this;
	    },

	    'camera.fadeIn'
	        (
	            {
	                duration = 1000,
	                red, green, blue,
	                name,
	                wait = false
	            } = {},
	            eventSheetManager, eventsheet
	        ) {

	        var camera;
	        if (name) {
	            camera = this.sys.scene.cameras.getCamera(name);
	        } else {
	            camera = this.sys.cameraTarget;
	        }

	        if (!camera) {
	            return this;
	        }

	        camera.fadeIn(duration, red, green, blue);
	        if (wait) {
	            this.wait({ camera: 'fadeIn', cameraName: name }, eventSheetManager);
	        }
	        return this;
	    },

	    'camera.fadeOut'(
	        {
	            duration = 1000,
	            red, green, blue,
	            name,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var camera;
	        if (name) {
	            camera = this.sys.scene.cameras.getCamera(name);
	        } else {
	            camera = this.sys.cameraTarget;
	        }

	        if (!camera) {
	            return this;
	        }

	        camera.fadeOut(duration, red, green, blue);
	        if (wait) {
	            this.wait({ camera: 'fadeOut', cameraName: name }, eventSheetManager);
	        }
	        return this;
	    },

	    'camera.flash'(
	        {
	            duration = 1000,
	            red, green, blue,
	            name,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var camera;
	        if (name) {
	            camera = this.sys.scene.cameras.getCamera(name);
	        } else {
	            camera = this.sys.cameraTarget;
	        }

	        if (!camera) {
	            return this;
	        }

	        camera.flash(duration, red, green, blue);
	        if (wait) {
	            this.wait({ camera: 'flash', cameraName: name }, eventSheetManager);
	        }
	        return this;
	    },

	    'camera.shake'(
	        {
	            duration = 1000,
	            intensity,
	            name,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var camera;
	        if (name) {
	            camera = this.sys.scene.cameras.getCamera(name);
	        } else {
	            camera = this.sys.cameraTarget;
	        }

	        if (!camera) {
	            return this;
	        }

	        camera.shake(duration, intensity);
	        if (wait) {
	            this.wait({ camera: 'shake', cameraName: name }, eventSheetManager);
	        }
	        return this;
	    },

	    'camera.zoomTo'(
	        {
	            duration = 1000,
	            zoom,
	            name,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var camera;
	        if (name) {
	            camera = this.sys.scene.cameras.getCamera(name);
	        } else {
	            camera = this.sys.cameraTarget;
	        }

	        if (!camera) {
	            return this;
	        }

	        camera.zoomTo(zoom, duration);
	        if (wait) {
	            this.wait({ camera: 'zoom', cameraName: name }, eventSheetManager);
	        }
	        return this;
	    },

	    'camera.rotateTo'(
	        {
	            duration = 1000,
	            rotate, ease,
	            name,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var camera;
	        if (name) {
	            camera = this.sys.scene.cameras.getCamera(name);
	        } else {
	            camera = this.sys.cameraTarget;
	        }

	        if (!camera) {
	            return this;
	        }

	        camera.rotateTo(rotate, false, duration, ease);
	        if (wait) {
	            this.wait({ camera: 'rotate', cameraName: name }, eventSheetManager);
	        }
	        return this;
	    },

	    'camera.scrollTo'(
	        {
	            duration = 1000,
	            x, y, ease,
	            name,
	            wait = false
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        var camera;
	        if (name) {
	            camera = this.sys.scene.cameras.getCamera(name);
	        } else {
	            camera = this.sys.cameraTarget;
	        }

	        if (!camera) {
	            return this;
	        }

	        var xSave = camera.scrollX;
	        var ySave = camera.scrollY;
	        camera.setScroll(x, y);
	        x += camera.centerX;
	        y += camera.centerY;
	        camera.setScroll(xSave, ySave);

	        // x,y in pan() is the centerX, centerY
	        camera.pan(x, y, duration, ease);

	        if (wait) {
	            this.wait({ camera: 'scroll', cameraName: name }, eventSheetManager);
	        }
	        return this;
	    },

	};

	var CanLog = function (eventsheet) {
	    return !eventsheet.hasOwnProperty('logEnable') || eventsheet.logEnable;
	};

	var LogMethods = {
	    log({
	        text = '',
	        logType = 'log',
	        showTitle = true,
	        title = undefined,
	        titleColor = 'green'
	    } = {},
	        eventSheetManager, eventsheet
	    ) {
	        if (!CanLog(eventsheet)) {
	            return this;
	        }

	        if (showTitle) {
	            if (title === undefined) {
	                title = eventsheet.title;
	            }
	            text = `[round][bgcolor=${titleColor}]${title}[/bgcolor][/round] ${text}`;
	        }
	        this.sys.logger.log(text, logType);
	        return this;
	    },

	    'log.disable'(
	        {
	            title
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        if (title) {
	            eventsheet = eventSheetManager.getTree(title, eventsheet.groupName);
	        }

	        if (!eventsheet.hasOwnProperty('logEnable')) {
	            eventsheet.wrapProperty('logEnable');
	        }

	        eventsheet.logEnable = false;
	        return this;
	    },

	    'log.enable'(
	        {
	            title
	        } = {},
	        eventSheetManager, eventsheet
	    ) {

	        if (title) {
	            eventsheet = eventSheetManager.getTree(title, eventsheet.groupName);
	        }

	        if (!eventsheet.hasOwnProperty('logEnable')) {
	            return this;
	        }

	        eventsheet.logEnable = true;
	        return this;
	    },

	    'log.memory'(config, eventSheetManager, eventsheet) {
	        if (!CanLog(eventsheet)) {
	            return this;
	        }

	        this.log(config, eventSheetManager, eventsheet);

	        var memory = eventSheetManager.memory;

	        var table;
	        var { keys } = config;
	        if (keys) {
	            table = {};
	            keys.split(',').forEach(function (key) {
	                table[key] = memory[key];
	            });
	        } else {
	            table = memory;
	        }

	        this.sys.logger.log(table);
	        return this;
	    },
	};

	var DefaultHandler = function (name, config, eventSheetManager, eventSheet) {
	    var tokens = name.split('.');

	    var gameObjectID = tokens[0];
	    if (this.sys.hasGameObjectMananger(gameObjectID)) {
	        config.goType = gameObjectID;
	        config.id = null;
	    } else if (this.sys.hasGameObject(undefined, gameObjectID)) {
	        config.goType = undefined;
	        config.id = gameObjectID;
	    } else {
	        // TODO
	        console.warn(`CommandExecutor: '${gameObjectID}' does not exist`);
	        return this;
	    }

	    this.bindEventSheetManager(eventSheetManager); // For _waitComplete() / waitEvent()

	    var commandName = tokens[1];

	    var isDone = false;
	    // Try to run custom command first
	    var gameObjectManager = this.sys.getGameObjectManager(config.goType, config.id);
	    if (gameObjectManager) {
	        // Command registered in gameObjectManager
	        var command = gameObjectManager.commands[commandName];
	        if (command) {
	            var gameObjects = gameObjectManager.getGO(config.id);
	            if (!Array.isArray(gameObjects)) {
	                gameObjects = [gameObjects];
	            }
	            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	                command(gameObjects[i], config, this, eventSheetManager, eventSheet);
	            }
	            isDone = true;
	        }
	    }

	    if (!isDone) {
	        // Try run default command
	        switch (commandName) {
	            case 'set':
	                this.setGOProperty(config, eventSheetManager, eventSheet);
	                break;

	            case 'to':
	                this.easeGOProperty(config, eventSheetManager, eventSheet);
	                break;

	            case 'yoyo':
	                config.yoyo = true;
	                this.easeGOProperty(config, eventSheetManager, eventSheet);
	                break;

	            case 'from':
	                config.from = true;
	                this.easeGOProperty(config, eventSheetManager, eventSheet);
	                break;

	            case 'destroy':
	                this.destroyGO(config, eventSheetManager, eventSheet);
	                break;

	            default:
	                // TODO
	                var parameters;
	                for (var key in config) {
	                    parameters = config[key];
	                    break;
	                }
	                config.methodName = commandName;
	                config.parameters = (parameters) ? StringToValues(parameters) : [];
	                this.runGOMethod(config, eventSheetManager, eventSheet);
	                break;
	        }

	    }

	    this.unBindEventSheetManager();

	    return this;
	};

	var Methods$c = {
	    addCommand: AddCommand,
	    defaultHandler: DefaultHandler,
	};

	Object.assign(
	    Methods$c,
	    DataMethods$1,
	    WaitMethods,
	    GameObjectManagerMethods,
	    GameObjectMethods,
	    BackgroundMusicMethods,
	    BackgroundMusic2Methods,
	    SoundEffectsMethods,
	    SoundEffects2Methods,
	    CameraMethods,
	    LogMethods,
	);

	class CommandExecutor {
	    constructor(scene, config = {}) {
	        this.sys = new Managers(scene, config);

	        var { log = {} } = config;
	        this.sys.logger = new BBCodeLog(log);
	    }

	    destroy(fromScene) {
	        this.sys.destroy(fromScene);
	    }
	}

	Object.assign(
	    CommandExecutor.prototype,
	    Methods$c,
	);

	// Layer name
	const BGLayer = 'bgLayer';
	const GOLayer = 'gameObjectLayer';
	const UILayer = 'uiLayer';

	const BGBottomLayer = `${BGLayer}Bottom`;
	const BGTopLayer = `${BGLayer}Top`;
	const GOBottomLayer = `${GOLayer}Bottom`;
	const GOTopLayer = `${GOLayer}Top`;
	const UIBottomLayer = `${UILayer}Bottom`;
	const UITopLayer = `${UILayer}Top`;

	const BGCamera = 'bg';
	const GOCamera = 'go';
	const UICamera = 'ui';

	const LayerConfigMultipleCamras = [
	    { name: BGBottomLayer, cameraName: BGCamera },
	    { name: BGLayer, cameraName: BGCamera },
	    { name: BGTopLayer, cameraName: BGCamera },

	    { name: GOBottomLayer, cameraName: GOCamera },
	    { name: GOLayer, cameraName: GOCamera },
	    { name: GOTopLayer, cameraName: GOCamera },

	    { name: UIBottomLayer, cameraName: UICamera },
	    { name: UILayer, cameraName: UICamera },
	    { name: UITopLayer, cameraName: UICamera },
	];

	const LayerConfigSingleCamera = [
	    BGBottomLayer,
	    BGLayer,
	    BGTopLayer,

	    GOBottomLayer,
	    GOLayer,
	    GOTopLayer,

	    UIBottomLayer,
	    UILayer,
	    UITopLayer
	];

	var GetRootGameObject = function (gameObject) {
	    if (gameObject.parentContainer) {  // At a container
	        return GetRootGameObject(gameObject.parentContainer);
	    }

	    var layer = GetLayer(gameObject);
	    if (layer) {  // At a layer
	        return GetRootGameObject(layer);
	    }

	    return gameObject;
	};

	var GetFirstRenderCamera = function (gameObject) {
	    var cameraFilter = GetRootGameObject(gameObject).cameraFilter;
	    var cameras = gameObject.scene.sys.cameras.cameras;
	    var camera, isCameraIgnore;
	    for (var i = 0, cnt = cameras.length; i < cnt; i++) {
	        camera = cameras[i];

	        isCameraIgnore = (cameraFilter & camera.id) > 0;
	        if (!isCameraIgnore) {
	            return camera;
	        }
	    }

	    return null;
	};

	class FullWindow extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject);
	        // this.parent = gameObject;

	        this.targetCamera = undefined;
	        this.boot();
	    }

	    boot() {
	        this.scene.sys.events.on('prerender', this.resize, this);
	    }

	    destroy() {
	        if (!this.scene) {
	            return;
	        }

	        this.scene.sys.events.off('prerender', this.resize, this);

	        super.destroy();
	    }


	    resize() {
	        var scene = this.scene;
	        var gameObject = this.parent;

	        var camera = GetFirstRenderCamera(gameObject);
	        if (!camera) {
	            return;
	        }

	        gameObject
	            .setScrollFactor(0)
	            .setOrigin(0.5);

	        var gameSize = scene.sys.scale.gameSize;
	        var gameWidth = gameSize.width,
	            gameHeight = gameSize.height,
	            scale = 1 / camera.zoom;

	        // Origin is fixed to (0.5,0.5)
	        var x = gameWidth / 2,
	            y = gameHeight / 2;

	        var width = gameWidth * scale,
	            height = gameHeight * scale;

	        if ((gameObject.x !== x) || (gameObject.y !== y)) {
	            gameObject.setPosition(x, y);
	        }

	        if ((gameObject.width !== width) || (gameObject.height !== height)) {
	            gameObject.setSize(width, height);
	        }

	    }


	}

	const Zone$2 = Phaser.GameObjects.Zone;

	let FullWindowRectangle$1 = class FullWindowRectangle extends Zone$2 {
	    constructor(scene) {
	        super(scene, 0, 0, 2, 2);

	        this.fullWindow = new FullWindow(this);
	    }
	};

	// Game object type name
	const BG = 'BG';                 // layer: BGLayer
	const SPRITE = 'SPRITE';         // layer: GOLayer
	const TEXTBOX = 'TEXTBOX';       // layer: UILayer
	const TITLE = 'TITLE';           // layer: UILayer
	const CHOICE = 'CHOICE';         // layer: UILayer
	const NAMEINPUT = 'NAMEINPUT';   // layer: UILayer
	  // layer: UILayer

	const MinVersion = 60;

	var IsChecked = false;

	var CheckP3Version = function (minVersion) {
	    if (IsChecked) {
	        return;
	    }

	    if (minVersion === undefined) {
	        minVersion = MinVersion;
	    }
	    var version = Phaser.VERSION.split('.');
	    var mainVersion = parseInt(version[0]);
	    if (mainVersion === 3) {
	        var currentVersion = parseInt(version[1]);
	        if (currentVersion < minVersion) {
	            console.error(`Minimum supported version : ${mainVersion}.${currentVersion}`);
	        }
	    } else {
	        console.error(`Can't supported version : ${mainVersion}`);
	    }

	    IsChecked = true;
	};

	CheckP3Version();

	const Zone$1 = Phaser.GameObjects.Zone;
	const AddItem = Phaser.Utils.Array.Add;
	const RemoveItem$a = Phaser.Utils.Array.Remove;

	let Base$3 = class Base extends Zone$1 {
	    constructor(scene, x, y, width, height) {
	        if (x === undefined) {
	            x = 0;
	        }
	        if (y === undefined) {
	            y = 0;
	        }
	        if (width === undefined) {
	            width = 1;
	        }
	        if (height === undefined) {
	            height = 1;
	        }
	        super(scene, x, y, width, height);
	        this.children = [];
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        if (fromScene) {
	            // Stop scene
	            var child;
	            for (var i = this.children.length - 1; i >= 0; i--) {
	                child = this.children[i];
	                if (!child.parentContainer &&  // Not in container
	                    !child.displayList         // Not in scene, neither in layer
	                ) {
	                    // Destroy child which is not in scene, container, or layer manually
	                    child.destroy(fromScene);
	                }
	            }
	        }

	        // Destroy/remove children
	        this.clear(!fromScene);
	        super.destroy(fromScene);
	    }

	    contains(gameObject) {
	        return (this.children.indexOf(gameObject) !== -1);
	    }

	    add(gameObjects) {
	        var parent = this;
	        AddItem(this.children, gameObjects, 0,
	            // Callback of item added
	            function (gameObject) {
	                gameObject.once('destroy', parent.onChildDestroy, parent);
	            }, this);
	        return this;
	    }

	    remove(gameObjects, destroyChild) {
	        var parent = this;
	        RemoveItem$a(this.children, gameObjects,
	            // Callback of item removed
	            function (gameObject) {
	                gameObject.off('destroy', parent.onChildDestroy, parent);
	                if (destroyChild) {
	                    gameObject.destroy();
	                }
	            }
	        );
	        return this;
	    }

	    onChildDestroy(child, fromScene) {
	        // Only remove reference
	        this.remove(child, false);
	    }

	    clear(destroyChild) {
	        var parent = this;
	        var gameObject;
	        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
	            gameObject = this.children[i];
	            gameObject.off('destroy', parent.onChildDestroy, parent);
	            if (destroyChild) {
	                gameObject.destroy();
	            }
	        }
	        this.children.length = 0;
	        return this;
	    }
	};

	const Components$3 = Phaser.GameObjects.Components;
	Phaser.Class.mixin(Base$3,
	    [
	        Components$3.Alpha,
	        Components$3.Flip
	    ]
	);

	var GetParent$1 = function (gameObject, name) {
	    var parent;
	    if (name === undefined) {
	        if (gameObject.hasOwnProperty('rexContainer')) {
	            parent = gameObject.rexContainer.parent;
	        }
	    } else {
	        parent = GetParent$1(gameObject);
	        while (parent) {
	            if (parent.name === name) {
	                break;
	            }
	            parent = GetParent$1(parent);
	        }
	    }
	    return parent;
	};

	var GetTopmostParent$1 = function (gameObject) {
	    var parent = GetParent$1(gameObject);
	    while (parent) {
	        gameObject = parent;
	        parent = GetParent$1(parent);
	    }
	    return gameObject;
	};

	const DegToRad$9 = Phaser.Math.DegToRad;
	const RadToDeg$4 = Phaser.Math.RadToDeg;

	var GetLocalState = function (gameObject) {
	    if (!gameObject.hasOwnProperty('rexContainer')) {
	        var rexContainer = {
	            parent: null, self: null, layer: null,
	            x: 0, y: 0, syncPosition: true,
	            rotation: 0, syncRotation: true,
	            scaleX: 0, scaleY: 0, syncScale: true,
	            alpha: 0, syncAlpha: true,
	            syncScrollFactor: true,
	            syncCameraFilter: true,
	            syncDisplayList: true,
	            visible: true,
	            active: true,
	        };

	        Object.defineProperty(rexContainer, 'angle', {
	            get: function () {
	                return RadToDeg$4(this.rotation);
	            },
	            set: function (value) {
	                this.rotation = DegToRad$9(value);
	            }
	        });
	        Object.defineProperty(rexContainer, 'displayWidth', {
	            get: function () {
	                return gameObject.width * this.scaleX;
	            },
	            set: function (width) {
	                this.scaleX = width / gameObject.width;
	            }
	        });
	        Object.defineProperty(rexContainer, 'displayHeight', {
	            get: function () {
	                return gameObject.height * this.scaleY;
	            },
	            set: function (height) {
	                this.scaleY = height / gameObject.height;
	            }
	        });

	        gameObject.rexContainer = rexContainer;
	    }
	    return gameObject.rexContainer;
	};

	var Parent = {
	    setParent(gameObject, parent) {
	        if (parent === undefined) {
	            parent = this;
	        }
	        var localState = GetLocalState(gameObject);
	        if (parent) { // Add to parent
	            localState.parent = parent;
	            localState.self = gameObject;
	        } else { // Remove from parent
	            localState.parent = null;
	            localState.self = null;
	        }
	        return this;
	    },

	    getParent(gameObject, name) {
	        if (typeof (gameObject) === 'string') {
	            name = gameObject;
	            gameObject = undefined;
	        }
	        if (gameObject === undefined) {
	            gameObject = this;
	        }
	        return GetParent$1(gameObject, name);
	    },

	    getTopmostParent(gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }
	        return GetTopmostParent$1(gameObject);
	    }
	};

	const GetValue$1V = Phaser.Utils.Objects.GetValue;
	const BaseAdd = Base$3.prototype.add;

	var Add$7 = function (gameObject, config) {
	    this.setParent(gameObject);

	    var state = GetLocalState(gameObject);
	    SetupSyncFlags(state, config);

	    this
	        .resetChildState(gameObject)           // Reset local state of child
	        .updateChildVisible(gameObject)        // Apply parent's visible to child
	        .updateChildActive(gameObject)         // Apply parent's active to child
	        .updateChildScrollFactor(gameObject)   // Apply parent's scroll factor to child
	        .updateChildMask(gameObject)           // Apply parent's mask to child
	        .updateCameraFilter(gameObject);       // Apply parent's cameraFilter to child

	    BaseAdd.call(this, gameObject);

	    SyncDisplayList.call(this, gameObject, state);

	    return this;
	};

	var AddLocal = function (gameObject, config) {
	    this.setParent(gameObject);

	    // Set local state from child directly
	    var state = GetLocalState(gameObject);
	    SetupSyncFlags(state, config);
	    // Position
	    state.x = gameObject.x;
	    state.y = gameObject.y;
	    state.rotation = gameObject.rotation;
	    state.scaleX = gameObject.scaleX;
	    state.scaleY = gameObject.scaleY;
	    // Alpha
	    state.alpha = gameObject.alpha;
	    // Visible
	    state.visible = gameObject.visible;
	    // Active
	    state.active = gameObject.active;

	    this
	        .updateChildPosition(gameObject)
	        .updateChildAlpha(gameObject)
	        .updateChildVisible(gameObject)        // Apply parent's visible to child
	        .updateChildActive(gameObject)         // Apply parent's active to child
	        .updateChildScrollFactor(gameObject)   // Apply parent's scroll factor to child
	        .updateChildMask(gameObject);          // Apply parent's mask to child

	    BaseAdd.call(this, gameObject);

	    SyncDisplayList.call(this, gameObject, state);

	    return this;
	};

	var SetupSyncFlags = function (state, config) {
	    if (config === undefined) {
	        config = true;
	    }

	    if (typeof (config) === 'boolean') {
	        state.syncPosition = config;
	        state.syncRotation = config;
	        state.syncScale = config;
	        state.syncAlpha = config;
	        state.syncScrollFactor = config;
	        state.syncCameraFilter = config;
	        state.syncDisplayList = config;
	    } else {
	        state.syncPosition = GetValue$1V(config, 'syncPosition', true);
	        state.syncRotation = GetValue$1V(config, 'syncRotation', true);
	        state.syncScale = GetValue$1V(config, 'syncScale', true);
	        state.syncAlpha = GetValue$1V(config, 'syncAlpha', true);
	        state.syncScrollFactor = GetValue$1V(config, 'syncScrollFactor', true);
	        state.syncCameraFilter = GetValue$1V(config, 'syncCameraFilter', true);
	        state.syncDisplayList = GetValue$1V(config, 'syncDisplayList', true);
	    }

	};

	var SyncDisplayList = function (gameObject, state) {
	    this.addToParentContainer(gameObject);     // Sync parent's container to child

	    if (state.syncDisplayList) {
	        this.addToPatentLayer(gameObject);     // Sync parent's layer to child
	    }

	    this.addToRenderLayer(gameObject);         // Sync parent's render-layer
	};

	var AddChild$3 = {
	    // Can override this method
	    add(gameObject) {
	        if (Array.isArray(gameObject)) {
	            this.addMultiple(gameObject);
	        } else {
	            Add$7.call(this, gameObject);
	        }
	        return this;
	    },

	    // Don't override this method
	    pin(gameObject, config) {
	        if (Array.isArray(gameObject)) {
	            this.addMultiple(gameObject, config);
	        } else {
	            Add$7.call(this, gameObject, config);
	        }
	        return this;
	    },

	    // Can override this method
	    addMultiple(gameObjects) {
	        var args = Array.from(arguments);
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            args[0] = gameObjects[i];
	            this.add.apply(this, args);
	        }
	        return this;
	    },

	    addLocal(gameObject) {
	        if (Array.isArray(gameObject)) {
	            this.addMultiple(gameObject);
	        } else {
	            AddLocal.call(this, gameObject);
	        }
	        return this;
	    },

	    // Don't override this method
	    pinLocal(gameObject, config) {
	        if (Array.isArray(gameObject)) {
	            this.addMultiple(gameObject, config);
	        } else {
	            AddLocal.call(this, gameObject, config);
	        }
	        return this;
	    },

	    addLocalMultiple(gameObjects) {
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            AddLocal.call(this, gameObjects[i]);
	        }
	        return this;
	    }
	};

	const BaseRemove = Base$3.prototype.remove;
	const BaseClear = Base$3.prototype.clear;

	var RemoveChild$2 = {
	    // Can override this method
	    remove(gameObject, destroyChild) {
	        if (GetParent$1(gameObject) !== this) {
	            return this;
	        }
	        this.setParent(gameObject, null);

	        if (!destroyChild) {
	            this.removeFromRenderLayer(gameObject);
	        }

	        BaseRemove.call(this, gameObject, destroyChild);
	        return this;
	    },

	    // Don't override this method
	    unpin(gameObject, destroyChild) {
	        if (GetParent$1(gameObject) !== this) {
	            return this;
	        }
	        this.setParent(gameObject, null);

	        if (!destroyChild) {
	            this.removeFromRenderLayer(gameObject);
	        }

	        BaseRemove.call(this, gameObject, destroyChild);
	        return this;
	    },

	    clear(destroyChild) {
	        var children = this.children;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            var child = children[i];
	            this.setParent(child, null);

	            if (!destroyChild) {
	                this.removeFromRenderLayer(child);
	            }
	        }
	        BaseClear.call(this, destroyChild);
	        return this;
	    },
	};

	var ChildState = {
	    getLocalState(gameObject) {
	        return GetLocalState(gameObject);
	    },

	    resetChildState(gameObject) {
	        this
	            .resetChildPositionState(gameObject)
	            .resetChildVisibleState(gameObject)
	            .resetChildAlphaState(gameObject)
	            .resetChildActiveState(gameObject);
	        return this;
	    },

	    resetChildrenState(gameObjects) {
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            this.resetChildState(gameObjects[i]);
	        }
	        return this;
	    },

	    syncProperties() {
	        this
	            .syncPosition()
	            .syncVisible()
	            .syncAlpha()
	            .syncActive()
	            .syncScrollFactor()
	            .syncMask();
	        return this;
	    }
	};

	var Transform$1 = {
	    worldToLocal(point) {
	        // Transform
	        point.x -= this.x;
	        point.y -= this.y;

	        // Rotate
	        var c = Math.cos(-this.rotation);
	        var s = Math.sin(-this.rotation);
	        var tx = point.x;
	        var ty = point.y;
	        point.x = tx * c - ty * s;
	        point.y = tx * s + ty * c;

	        // Scale
	        point.x /= this.scaleX;
	        point.y /= this.scaleY;
	        return point;
	    },

	    localToWorld(point) {
	        // Scale
	        point.x *= this.scaleX;
	        point.y *= this.scaleY;

	        // Rotate
	        var c = Math.cos(this.rotation);
	        var s = Math.sin(this.rotation);
	        var tx = point.x;
	        var ty = point.y;
	        point.x = tx * c - ty * s;
	        point.y = tx * s + ty * c;

	        // Transform
	        point.x += this.x;
	        point.y += this.y;
	        return point;
	    }
	};

	var GetScale = function (a, b) {
	    if (a === b) {
	        return 1;
	    } else {
	        return a / b;
	    }
	};

	var Position = {
	    updateChildPosition(child) {
	        if (child.isRexContainerLite) {
	            child.syncChildrenEnable = false;
	        }
	        var localState = GetLocalState(child);
	        var parent = localState.parent;

	        if (localState.syncPosition) {
	            child.x = localState.x;
	            child.y = localState.y;
	            parent.localToWorld(child);
	        }

	        if (localState.syncRotation) {
	            child.rotation = localState.rotation + parent.rotation;
	        }

	        if (localState.syncScale) {
	            child.scaleX = localState.scaleX * parent.scaleX;
	            child.scaleY = localState.scaleY * parent.scaleY;
	        }

	        if (child.isRexContainerLite) {
	            child.syncChildrenEnable = true;
	            child.syncPosition();
	        }
	        return this;
	    },

	    syncPosition() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateChildPosition, this);
	        }
	        return this;
	    },

	    resetChildPositionState(child) {
	        var localState = GetLocalState(child);
	        var parent = localState.parent;
	        localState.x = child.x;
	        localState.y = child.y;
	        parent.worldToLocal(localState);

	        localState.scaleX = GetScale(child.scaleX, parent.scaleX);
	        localState.scaleY = GetScale(child.scaleY, parent.scaleY);

	        localState.rotation = child.rotation - parent.rotation;
	        return this;
	    },

	    setChildPosition(child, x, y) {
	        child.x = x;
	        child.y = y;
	        this.resetChildPositionState(child);
	        return this;
	    },

	    setChildLocalPosition(child, x, y) {
	        var localState = GetLocalState(child);
	        localState.x = x;
	        localState.y = y;
	        this.updateChildPosition(child);
	        return this;
	    },

	    resetLocalPositionState() {
	        var parent = GetLocalState(this).parent;
	        if (parent) {
	            parent.resetChildPositionState(this);
	        }
	        return this;
	    },

	    getChildLocalX(child) {
	        var localState = GetLocalState(child);
	        return localState.x;
	    },

	    getChildLocalY(child) {
	        var localState = GetLocalState(child);
	        return localState.y;
	    },

	};

	const DegToRad$8 = Phaser.Math.DegToRad;

	var Rotation = {
	    updateChildRotation(child) {
	        var localState = GetLocalState(child);
	        var parent = localState.parent;
	        if (localState.syncRotation) {
	            child.rotation = parent.rotation + localState.rotation;
	        }
	        return this;
	    },

	    syncRotation() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateChildRotation, this);
	        }
	        return this;
	    },

	    resetChildRotationState(child) {
	        var localState = GetLocalState(child);
	        var parent = localState.parent;
	        localState.rotation = child.rotation - parent.rotation;
	        return this;
	    },

	    setChildRotation(child, rotation) {
	        child.rotation = rotation;
	        this.resetChildRotationState(child);
	        return this;
	    },

	    setChildAngle(child, angle) {
	        child.angle = angle;
	        this.resetChildRotationState(child);
	        return this;
	    },

	    setChildLocalRotation(child, rotation) {
	        var localState = GetLocalState(child);
	        localState.rotation = rotation;
	        this.updateChildRotation(child);
	        return this;
	    },

	    setChildLocalAngle(child, angle) {
	        var localState = GetLocalState(child);
	        localState.rotation = DegToRad$8(angle);
	        this.updateChildRotation(child);
	        return this;
	    },

	    resetLocalRotationState() {
	        var parent = GetLocalState(this).parent;
	        if (parent) {
	            parent.resetChildRotationState(this);
	        }
	        return this;
	    },

	    getChildLocalRotation(child) {
	        var localState = GetLocalState(child);
	        return localState.rotation;
	    },

	};

	var Scale$2 = {
	    updateChildScale(child) {
	        var state = GetLocalState(child);
	        var parent = state.parent;
	        if (state.syncScale) {
	            child.scaleX = parent.scaleX * state.scaleX;
	            child.scaleY = parent.scaleY * state.scaleY;
	        }
	        return this;
	    },

	    syncScale() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateChildScale, this);
	        }
	        return this;
	    },

	    resetChildScaleState(child) {
	        var state = GetLocalState(child);
	        var parent = state.parent;
	        state.scaleX = GetScale(child.scaleX, parent.scaleX);
	        state.scaleY = GetScale(child.scaleY, parent.scaleY);
	        return this;
	    },

	    setChildScale(child, scaleX, scaleY) {
	        if (scaleY === undefined) {
	            scaleY = scaleX;
	        }
	        child.scaleX = scaleX;
	        child.scaleY = scaleY;
	        this.resetChildScaleState(child);
	        return this;
	    },

	    setChildLocalScale(child, scaleX, scaleY) {
	        if (scaleY === undefined) {
	            scaleY = scaleX;
	        }
	        var state = GetLocalState(child);
	        state.scaleX = scaleX;
	        state.scaleY = scaleY;
	        this.updateChildScale(child);
	        return this;
	    },

	    setChildDisplaySize(child, width, height) {
	        child.setDisplaySize(width, height);
	        this.resetChildScaleState(child);
	        return this;
	    },

	    resetLocalScaleState() {
	        var parent = GetLocalState(this).parent;
	        if (parent) {
	            parent.resetChildScaleState(this);
	        }
	        return this;
	    },

	    getChildLocalScaleX(child) {
	        var localState = GetLocalState(child);
	        return localState.scaleX;
	    },

	    getChildLocalScaleY(child) {
	        var localState = GetLocalState(child);
	        return localState.scaleY;
	    },
	};

	/*

	Visible in localState:

	  - visible: original visible of child
	  - maskVisible: invisible by parent mask, see MaskChildren.js
	      - undefined (not in masking) : Equal to mask visible
	      - true (mask visible) : Inside, or across parent's visible area
	      - false (maske invisible) : Out of parent's visible area

	Visible result of child = (parent visible) && (child visible) && (mask visible)
	*/


	var Visible = {
	    updateChildVisible(child) {
	        var localState = GetLocalState(child);
	        var parent = localState.parent;
	        var maskVisible = (localState.hasOwnProperty('maskVisible')) ? localState.maskVisible : true;
	        var parentVisible = (parent) ? parent.visible : true;
	        child.visible = parentVisible && localState.visible && maskVisible;
	        return this;
	    },

	    syncVisible() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateChildVisible, this);
	        }
	        return this;
	    },

	    resetChildVisibleState(child) {
	        var localState = GetLocalState(child);
	        // Delete maskVisible property
	        if (localState.hasOwnProperty('maskVisible')) {
	            delete localState.maskVisible;
	        }
	        localState.visible = child.visible;
	        return this;
	    },

	    setChildVisible(child, visible) {
	        // Visible of child will be affect by parent's visible, and mask visible
	        this.setChildLocalVisible(child, visible);
	        return this;
	    },

	    // Internal method
	    setChildLocalVisible(child, visible) {
	        if (visible === undefined) {
	            visible = true;
	        }
	        var localState = GetLocalState(child);
	        localState.visible = visible;
	        this.updateChildVisible(child);
	        return this;
	    },

	    // Internal method
	    setChildMaskVisible(child, visible) {
	        if (visible === undefined) {
	            visible = true;
	        }
	        var localState = GetLocalState(child);
	        localState.maskVisible = visible;
	        this.updateChildVisible(child);
	        return this;
	    },

	    resetLocalVisibleState() {
	        var parent = GetLocalState(this).parent;
	        if (parent) {
	            parent.resetChildVisibleState(this);
	        }
	        return this;
	    },

	    getChildLocalVisible(child) {
	        var localState = GetLocalState(child);
	        return localState.visible;
	    },
	};

	var Alpha = {
	    updateChildAlpha(child) {
	        var state = GetLocalState(child);
	        var parent = state.parent;
	        if (state.syncAlpha) {
	            child.alpha = parent.alpha * state.alpha;
	        }
	        return this;
	    },

	    syncAlpha() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateChildAlpha, this);
	        }
	        return this;
	    },

	    resetChildAlphaState(child) {
	        var state = GetLocalState(child);
	        var parent = state.parent;
	        state.alpha = GetScale(child.alpha, parent.alpha);
	        return this;
	    },

	    setChildAlpha(child, alpha) {
	        child.alpha = alpha;
	        this.resetChildAlphaState(child);
	        return this;
	    },

	    setChildLocalAlpha(child, alpha) {
	        var state = GetLocalState(child);
	        state.alpha = alpha;
	        this.updateChildAlpha(child);
	        return this;
	    },

	    resetLocalAlphaState() {
	        var parent = GetLocalState(this).parent;
	        if (parent) {
	            parent.resetChildAlphaState(this);
	        }
	        return this;
	    },

	    getChildLocalAlpha(child) {
	        var localState = GetLocalState(child);
	        return localState.alpha;
	    },
	};

	var Active = {
	    updateChildActive(child) {
	        var localState = GetLocalState(child);
	        var parent = localState.parent;
	        child.active = parent.active && localState.active;
	        return this;
	    },

	    syncActive() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateChildActive, this);
	        }
	        return this;
	    },

	    resetChildActiveState(child) {
	        var localState = GetLocalState(child);
	        localState.active = child.active;
	        return this;
	    },

	    setChildActive(child, active) {
	        child.active = active;
	        this.resetChildActiveState(child);
	        return this;
	    },

	    setChildLocalActive(child, active) {
	        if (active === undefined) {
	            active = true;
	        }
	        var localState = GetLocalState(child);
	        localState.active = active;
	        this.updateChildActive(child);
	        return this;
	    },

	    resetLocalActiveState() {
	        var parent = GetLocalState(this).parent;
	        if (parent) {
	            parent.resetChildActiveState(this);
	        }
	        return this;
	    },

	    getChildLocalActive(child) {
	        var localState = GetLocalState(child);
	        return localState.active;
	    },
	};

	var ScrollFactor = {
	    updateChildScrollFactor(child) {
	        var localState = GetLocalState(child);
	        var parent = localState.parent;

	        if (localState.syncScrollFactor) {
	            child.scrollFactorX = parent.scrollFactorX;
	            child.scrollFactorY = parent.scrollFactorY;
	        }

	        return this;
	    },

	    syncScrollFactor() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateChildScrollFactor, this);
	        }
	        return this;
	    },

	};

	var CameraFilter = {
	    updateCameraFilter(child) {
	        var state = GetLocalState(child);
	        var parent = state.parent;

	        if (state.syncCameraFilter) {
	            child.cameraFilter = parent.cameraFilter;
	        }

	        return this;
	    },

	    syncCameraFilter() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateCameraFilter, this);
	        }
	        return this;
	    },
	};

	var Mask = {
	    updateChildMask(child) {
	        // Don't propagate null mask to clear children's mask
	        if (this.mask == null) {
	            return this;
	        }

	        var maskGameObject = (this.mask.hasOwnProperty('geometryMask')) ? this.mask.geometryMask : this.mask.bitmapMask;
	        if (maskGameObject !== child) {
	            child.mask = this.mask;
	        }
	        return this;
	    },

	    syncMask() {
	        if (this.syncChildrenEnable) {
	            this.children.forEach(this.updateChildMask, this);
	        }
	        return this;
	    },

	    setMask(mask) {
	        this.mask = mask;
	        return this;
	    },

	    clearMask(destroyMask) {
	        if (destroyMask === undefined) {
	            destroyMask = false;
	        }

	        var self = this;

	        // Clear current mask
	        this._mask = null;

	        this.setChildMaskVisible(this);
	        // Also set maskVisible to `true`

	        this.children.forEach(function (child) {
	            // Clear child's mask
	            if (child.clearMask) {
	                child.clearMask(false);
	            }

	            if (!child.hasOwnProperty('isRexContainerLite')) {
	                self.setChildMaskVisible(child);
	                // Set child's maskVisible to `true`
	            }
	        });

	        if (destroyMask && this.mask) {
	            this.mask.destroy();
	        }

	        return this;
	    },
	};

	var FilterDisplayGameObjects = function (gameObjects) {
	    return gameObjects.filter(function (gameObject) {
	        if (gameObject.displayList) {
	            // Inside a scene or a layer
	            return true;
	        } else if (gameObject.parentContainer) {
	            // Inside a container
	            return true;
	        }
	    })
	};

	var Depth = {
	    setDepth(value, containerOnly) {
	        this.depth = value;
	        if (!containerOnly && this.children) {
	            var children = this.getAllChildren();
	            for (var i = 0, cnt = children.length; i < cnt; i++) {
	                children[i].depth = value;
	            }
	        }
	        return this;
	    },

	    swapDepth(containerB) {
	        var depthA = this.depth;
	        var depthB = containerB.depth;
	        this.setDepth(depthB);
	        containerB.setDepth(depthA);
	        return this;
	    },

	    incDepth(inc) {
	        this.depth += inc;
	        if (this.children) {
	            var children = this.getAllChildren();
	            for (var i = 0, cnt = children.length; i < cnt; i++) {
	                children[i].depth += inc;
	            }
	        }
	        return this;
	    },

	    bringToTop() {
	        var displayList = this.displayList;
	        if (!displayList) {
	            return this;
	        }

	        var children = this.getAllChildren([this]);
	        SortGameObjectsByDepth(children, false);
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            var child = children[i];
	            if (displayList.exists(child)) {
	                displayList.bringToTop(child);
	            }
	        }
	        return this;
	    },

	    bringMeToTop() {
	        return this.bringToTop();
	    },

	    sendToBack() {
	        var displayList = this.displayList;
	        if (!displayList) {
	            return this;
	        }

	        var children = this.getAllChildren([this]);
	        SortGameObjectsByDepth(children, true);
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            var child = children[i];
	            if (displayList.exists(child)) {
	                displayList.sendToBack(child);
	            }
	        }
	        return this;
	    },

	    sendMeToBack() {
	        return this.sendToBack();
	    },

	    moveDepthBelow(gameObject) {
	        var displayList = this.displayList;
	        if (!displayList) {
	            return this;
	        }

	        if (gameObject.displayList !== displayList) {
	            // Do nothing if not at the same display list
	            return this;
	        }

	        var children = this.getAllChildren([this]);
	        SortGameObjectsByDepth(children, false);
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            var child = children[i];
	            if (displayList.exists(child)) {
	                displayList.moveBelow(gameObject, child);
	                break;
	            }
	        }
	        return this;
	    },

	    moveMyDepthBelow(gameObject) {
	        return this.moveDepthBelow(gameObject);
	    },

	    moveDepthAbove(gameObject) {
	        var displayList = this.displayList;
	        if (!displayList) {
	            return this;
	        }

	        if (gameObject.displayList !== displayList) {
	            // Do nothing if not at the same display list
	            return this;
	        }

	        var children = this.getAllChildren([this]);
	        SortGameObjectsByDepth(children, true);
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            var child = children[i];
	            if (displayList.exists(child)) {
	                displayList.moveAbove(gameObject, child);
	                break;
	            }
	        }
	        return this;
	    },

	    moveMyDepthAbove(gameObject) {
	        return this.moveDepthAbove(gameObject);
	    },

	    bringChildToTop(child) {
	        var gameObjects;
	        if ((child !== this) && child.isRexContainerLite) {
	            gameObjects = child.getAllChildren([child]);
	            gameObjects = FilterDisplayGameObjects(gameObjects);
	            gameObjects = SortGameObjectsByDepth(gameObjects, false);
	        } else {
	            gameObjects = [child];
	        }

	        var children = this.getAllChildren([this]);
	        children = FilterDisplayGameObjects(children);
	        children = SortGameObjectsByDepth(children, false);
	        var topChild = children[children.length - 1];

	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            var gameObject = gameObjects[i];
	            if (topChild === gameObject) {
	                continue;
	            }
	            if ((gameObject !== this) && (topChild.displayList !== gameObject.displayList)) {
	                continue;
	            }

	            topChild.displayList.moveAbove(gameObject, topChild);
	            topChild = gameObject;
	        }

	        return this;
	    },

	    sendChildToBack(child) {
	        var gameObjects;
	        if ((child !== this) && child.isRexContainerLite) {
	            gameObjects = child.getAllChildren([child]);
	            gameObjects = FilterDisplayGameObjects(gameObjects);
	            gameObjects = SortGameObjectsByDepth(gameObjects, false);
	        } else {
	            gameObjects = [child];
	        }

	        var children = this.getAllChildren([this]);
	        children = FilterDisplayGameObjects(children);
	        children = SortGameObjectsByDepth(children, false);
	        var bottomChild = children[0];

	        for (var i = gameObjects.length - 1; i >= 0; i--) {
	            var gameObject = gameObjects[i];
	            if (bottomChild === gameObject) {
	                continue;
	            }
	            if ((gameObject !== this) && (bottomChild.displayList !== gameObject.displayList)) {
	                continue;
	            }

	            bottomChild.displayList.moveBelow(gameObject, bottomChild);
	            bottomChild = gameObject;
	        }

	        return this;
	    },
	};

	var DepthFirstSearch = function (root, callback) {
	    var skip = callback(root);
	    if ((!skip) && root.isRexContainerLite) {
	        var children = root.children;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            DepthFirstSearch(children[i], callback);
	        }
	    }
	};

	var BreadthFirstSearch = function (root, callback) {
	    var queue = [root];
	    while (queue.length > 0) {
	        var current = queue.shift();
	        var skip = callback(current);

	        if ((!skip) && current.isRexContainerLite) {
	            queue.push(...current.children);
	        }
	    }
	};

	const ArrayUtils = Phaser.Utils.Array;

	var Children = {
	    getChildren(out) {
	        if (!out) {
	            out = this.children; // Return internal children array
	        } else {
	            for (var i = 0, cnt = this.children.length; i < cnt; i++) {
	                out.push(this.children[i]);
	            }
	            // Copy children
	        }
	        return out;
	    },

	    getAllChildren(out) {
	        if (out === undefined) {
	            out = [];
	        }

	        var root = this;
	        BreadthFirstSearch(root, function (child) {
	            // Don't add root
	            if (child === root) {
	                return;
	            }
	            out.push(child);
	        });

	        return out;
	    },

	    getAllVisibleChildren(out) {
	        if (out === undefined) {
	            out = [];
	        }

	        var root = this;
	        BreadthFirstSearch(root, function (child) {
	            // Don't add root
	            if (child === root) {
	                return;
	            }
	            // Don't add invisible child
	            if (!child.visible) {
	                return true;
	            }
	            out.push(child);
	        });

	        return out;
	    },

	    bfs(callback, root) {
	        if (root === undefined) {
	            root = this;
	        }
	        BreadthFirstSearch(root, callback);
	        return this;
	    },

	    dfs(callback, root) {
	        if (root === undefined) {
	            root = this;
	        }
	        DepthFirstSearch(root, callback);
	        return this;
	    },

	    contains(gameObject) { // Override Base.contains method
	        var parent = GetParent$1(gameObject);
	        if (!parent) {
	            return false;
	        } else if (parent === this) {
	            return true;
	        } else {
	            return this.contains(parent);
	        }
	    },

	    getByName(name, recursive) {
	        if (!recursive) {
	            return ArrayUtils.GetFirst(this.children, 'name', name); // object, or null if not found

	        } else { // recursive
	            // Breadth-first search
	            var queue = [this];
	            var parent, child;
	            while (queue.length) {
	                parent = queue.shift();

	                for (var i = 0, cnt = parent.children.length; i < cnt; i++) {
	                    child = parent.children[i];
	                    if (child.name === name) {
	                        return child;
	                    } else if (child.isRexContainerLite) {
	                        queue.push(child);
	                    }
	                }
	            }
	            return null;

	        }

	    },

	    getRandom(startIndex, length) {
	        return ArrayUtils.GetRandom(this.children, startIndex, length);
	    },

	    getFirst(property, value, startIndex, endIndex) {
	        return ArrayUtils.GetFirstElement(this.children, property, value, startIndex, endIndex);
	    },

	    getAll(property, value, startIndex, endIndex) {
	        return ArrayUtils.GetAll(this.children, property, value, startIndex, endIndex);
	    },

	    count(property, value, startIndex, endIndex) {
	        return ArrayUtils.CountAllMatching(this.children, property, value, startIndex, endIndex);
	    },

	    swap(child1, child2) {
	        ArrayUtils.Swap(this.children, child1, child2);
	        return this;
	    },

	    setAll(property, value, startIndex, endIndex) {
	        ArrayUtils.SetAll(this.children, property, value, startIndex, endIndex);
	        return this;
	    },
	};

	var GetLocalStates = function (gameObjects) {
	    var localStates = [];
	    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	        var gameObject = gameObjects[i];
	        if (!gameObject.hasOwnProperty('rexContainer')) {
	            continue;
	        }
	        localStates.push(gameObject.rexContainer);
	    }
	    return localStates;
	};

	var GetScene = function (gameObjects) {
	    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	        var scene = gameObjects[i].scene;
	        if (scene) {
	            return scene;
	        }
	    }
	    return null;
	};

	var UpdateChild = function (tween, key, target) {
	    if (!target.parent) {
	        // target object was removed, so remove this tween too
	        tween.remove();
	        return;
	    }

	    var parent = target.parent;
	    var child = target.self;
	    switch (key) {
	        case 'x':
	        case 'y':
	            parent.updateChildPosition(child);
	            break;

	        case 'angle':
	        case 'rotation':
	            parent.updateChildRotation(child);
	            break;

	        case 'scaleX':
	        case 'scaleY':        
	        case 'displayWidth':
	        case 'displayHeight':
	            parent.updateChildScale(child);
	            break;

	        case 'alpha':
	            parent.updateChildAlpha(child);
	            break;

	        default:
	            parent.updateChildPosition(child);
	            parent.updateChildRotation(child);
	            parent.updateChildScale(child);
	            parent.updateChildAlpha(child);
	            break;
	    }
	};

	var Tween = {
	    tweenChild(tweenConfig) {
	        var targets = tweenConfig.targets;
	        if (!Array.isArray(targets)) {
	            targets = [targets];
	        }

	        var scene = this.scene || GetScene(targets);
	        if (!scene) {
	            return;
	        }

	        // Map child game objects to local states
	        tweenConfig.targets = GetLocalStates(targets);
	        var tween = scene.tweens.add(tweenConfig);

	        // Update child game object in 'update' event
	        tween.on('update', UpdateChild);

	        return tween;
	    },

	    tweenSelf(tweenConfig) {
	        tweenConfig.targets = [this];
	        return this.tweenChild(tweenConfig);
	    },

	    createTweenChildConfig(tweenConfig) {
	        var targets = tweenConfig.targets;
	        if (targets) {
	            if (!Array.isArray(targets)) {
	                targets = [targets];
	            }
	            // Map child game objects to local states
	            tweenConfig.targets = GetLocalStates(targets);
	        }

	        var onUpdate = tweenConfig.onUpdate;
	        tweenConfig.onUpdate = function (tween, target) {
	            if (onUpdate) {
	                onUpdate(tween, target);
	            }
	            UpdateChild(tween, undefined, target);
	        };

	        return tweenConfig;
	    },

	    tween(tweenConfig) {
	        var scene = this.scene;
	        if (!tweenConfig.targets) {
	            tweenConfig.targets = this;
	        }
	        return scene.tweens.add(tweenConfig);
	    },
	};

	const ContainerClass = Phaser.GameObjects.Container;

	var IsContainerGameObject = function (gameObject) {
	    return (gameObject instanceof ContainerClass);
	};

	var GetValidChildren = function (parent) {
	    var children = parent.getAllChildren([parent]);
	    children = children.filter(function (gameObject) {
	        return !!gameObject.displayList ||   // At scene's displayList or at a layer
	            !!gameObject.parentContainer;  // At a container
	    });
	    return children;
	};

	var AddToContainer = function (p3Container) {
	    var gameObjects = GetValidChildren(this);
	    // This containerLite parent should be considered.
	    if (gameObjects.indexOf(this) === -1) {
	        gameObjects.push(this);
	    }

	    SortGameObjectsByDepth(gameObjects);

	    p3Container.add(gameObjects);
	};

	var RemoveFromContainer = function (p3Container, descending, addToScene) {
	    if (!this.scene) {
	        // Destroyed
	        return;
	    }

	    var gameObjects = GetValidChildren(this);

	    SortGameObjectsByDepth(gameObjects, descending);

	    p3Container.remove(gameObjects);

	    if (addToScene) {
	        gameObjects.forEach(function (gameObject) {
	            gameObject.addToDisplayList();
	        });
	    }
	};

	var P3Container$1 = {
	    addToContainer(p3Container) {
	        if (!IsContainerGameObject(p3Container)) {
	            return this;
	        }

	        this._setParentContainerFlag = true;
	        AddToContainer.call(this, p3Container);
	        this._setParentContainerFlag = false;
	        return this;
	    },

	    addToLayer(layer) {
	        if (!IsLayerGameObject(layer)) {
	            return this;
	        }

	        AddToContainer.call(this, layer);

	        return this;
	    },

	    removeFromContainer() {
	        if (!this.parentContainer) {
	            return this;
	        }

	        this._setParentContainerFlag = true;
	        RemoveFromContainer.call(this, this.parentContainer, true, false);
	        this._setParentContainerFlag = false;
	        return this;
	    },

	    removeFromLayer(addToScene) {
	        if (addToScene === undefined) {
	            addToScene = true;
	        }

	        if (!IsLayerGameObject(this.displayList)) {
	            return this;
	        }

	        RemoveFromContainer.call(this, this.displayList, false, addToScene);

	        return this;
	    },

	    getParentContainer() {
	        if (this.parentContainer) {
	            return this.parentContainer;
	        }

	        // One of parent container has a layer
	        var parent = this.getParent();
	        while (parent) {
	            var p3Container = parent.parentContainer;
	            if (p3Container) {
	                return p3Container;
	            }
	            parent = parent.getParent();
	        }

	        return null;
	    },

	    addToParentContainer(gameObject) {
	        // Do nothing if gameObject is not in any displayList
	        if (!gameObject.displayList) {
	            return this;
	        }

	        var p3Container = this.getParentContainer();
	        if (!p3Container) {
	            return this;
	        }

	        if (gameObject.isRexContainerLite) {
	            // Add containerLite and its children
	            gameObject.addToContainer(p3Container);
	        } else {
	            // Add gameObject directly
	            p3Container.add(gameObject);
	        }

	        return this;
	    },

	    addToPatentLayer(gameObject) {
	        // Do nothing if gameObject is not in any displayList
	        if (!gameObject.displayList) {
	            return this;
	        }

	        // At the same display list
	        var parentLayer = this.displayList;
	        if (parentLayer === gameObject.displayList) {
	            return this;
	        }

	        if (IsLayerGameObject(parentLayer)) {
	            if (gameObject.isRexContainerLite) {
	                // Add containerLite and its children
	                gameObject.addToLayer(parentLayer);
	            } else {
	                // Add gameObject directly
	                parentLayer.add(gameObject);
	            }
	        }

	        return this;
	    }
	};

	var RenderLayer = {
	    hasLayer() {
	        return !!this.privateRenderLayer;
	    },

	    enableLayer() {
	        if (this.hasLayer()) {
	            return this;
	        }

	        var layer = this.scene.add.layer();
	        // layer.name = (this.name) ? `${this.name}.privateLayer` : 'privateLayer';

	        this.moveDepthBelow(layer);

	        this.addToLayer(layer);

	        this.privateRenderLayer = layer;

	        return this;
	    },

	    getLayer() {
	        if (!this.hasLayer()) {
	            this.enableLayer();
	        }

	        return this.privateRenderLayer;
	    },

	    getRenderLayer() {
	        // This containerLite has a layer
	        if (this.hasLayer()) {
	            return this.privateRenderLayer;
	        }

	        // One of parent container has a layer
	        var parent = this.getParent();
	        while (parent) {
	            var layer = parent.privateRenderLayer;
	            if (layer) {
	                return layer;
	            }
	            parent = parent.getParent();
	        }

	        return null;
	    },

	    // Internal method for adding child
	    addToRenderLayer(gameObject) {
	        // Don't add to layer if gameObject is not in any displayList
	        if (!gameObject.displayList) {
	            return this;
	        }

	        // Move gameObject from scene to layer
	        var layer = this.getRenderLayer();
	        if (!layer) {
	            return this;
	        }

	        if (layer === gameObject.displayList) {
	            return this;
	        }

	        if (gameObject.isRexContainerLite) {
	            // Add containerLite and its children
	            gameObject.addToLayer(layer);
	        } else {
	            // Add gameObject directly
	            layer.add(gameObject);
	        }

	        var state = GetLocalState(gameObject);
	        state.layer = layer;

	        return this;
	    },

	    // Internal method for removing child
	    removeFromRenderLayer(gameObject) {
	        // Move gameObject from layer to scene
	        var state = GetLocalState(gameObject);
	        var layer = state.layer;
	        if (!layer) {
	            return this;
	        }

	        if (gameObject.isRexContainerLite) {
	            // Remove containerLite and its children
	            gameObject.removeFromLayer(true);
	        } else {
	            // Remove gameObject directly
	            layer.remove(gameObject);
	        }

	        state.layer = null;

	        return this;
	    },
	};

	const Rectangle$4 = Phaser.Geom.Rectangle;
	const Union = Phaser.Geom.Rectangle.Union;

	var GetBoundsOfGameObjects = function (gameObjects, out) {
	    if (out === undefined) {
	        out = new Rectangle$4();
	    } else if (out === true) {
	        if (GlobRect$1 === undefined) {
	            GlobRect$1 = new Rectangle$4();
	        }
	        out = GlobRect$1;
	    }

	    out.setTo(0, 0, 0, 0);

	    var gameObject;
	    var firstClone = true;
	    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	        gameObject = gameObjects[i];
	        if (!gameObject.getBounds) {
	            continue;
	        }

	        var boundsRect = GetBounds(gameObject, true);

	        if (firstClone) {
	            out.setTo(boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
	            firstClone = false;
	        } else {
	            Union(boundsRect, out, out);
	        }
	    }

	    return out;
	};

	var GlobRect$1;

	var GetValue$1U = Phaser.Utils.Objects.GetValue;

	var Snapshot = function (config) {
	    if (!config) {
	        return;
	    }

	    var gameObjects = config.gameObjects;
	    var renderTexture = config.renderTexture;  // renderTexture, or dynamicTexture
	    var saveTexture = config.saveTexture;
	    var x = GetValue$1U(config, 'x', undefined);
	    var y = GetValue$1U(config, 'y', undefined);
	    var width = GetValue$1U(config, 'width', undefined);
	    var height = GetValue$1U(config, 'height', undefined);
	    var originX = GetValue$1U(config, 'originX', 0);
	    var originY = GetValue$1U(config, 'originY', 0);
	    var padding = GetValue$1U(config, 'padding', 0);

	    var scrollX, scrollY;
	    if ((width === undefined) || (height === undefined) || (x === undefined) || (y === undefined)) {
	        // Union bounds of gameObjects
	        var bounds = GetBoundsOfGameObjects(gameObjects, true);
	        var isCenterOrigin = (x !== undefined) && (y !== undefined);
	        if (isCenterOrigin) {
	            width = Math.max((x - bounds.left), (bounds.right - x)) * 2;
	            height = Math.max((y - bounds.top), (bounds.bottom - y)) * 2;
	            originX = 0.5;
	            originY = 0.5;
	        } else {
	            x = bounds.x;
	            y = bounds.y;
	            width = bounds.width;
	            height = bounds.height;
	            originX = 0;
	            originY = 0;
	        }
	        scrollX = bounds.x;
	        scrollY = bounds.y;
	    } else {
	        scrollX = x + ((0 - originX) * width);
	        scrollY = y + ((0 - originY) * height);
	    }

	    scrollX -= padding;
	    scrollY -= padding;
	    width += (padding * 2);
	    height += (padding * 2);

	    var scene = gameObjects[0].scene;
	    var textureManager = scene.sys.textures;

	    // Snapshot on dynamicTexture directly
	    if (saveTexture && !renderTexture) {
	        renderTexture = textureManager.addDynamicTexture(saveTexture, width, height);
	    }

	    // Return a renderTexture
	    if (!renderTexture) {
	        renderTexture = scene.add.renderTexture(0, 0, width, height);
	    }

	    if (renderTexture.setPosition) {
	        renderTexture.setPosition(x, y);
	    }

	    if ((renderTexture.width !== width) || (renderTexture.height !== height)) {
	        renderTexture.setSize(width, height);
	    }

	    if (renderTexture.setOrigin) {
	        renderTexture.setOrigin(originX, originY);
	    }

	    renderTexture.camera.setScroll(scrollX, scrollY);

	    // Draw gameObjects
	    gameObjects = SortGameObjectsByDepth(Clone(gameObjects));
	    renderTexture.draw(gameObjects);

	    // Save render result to texture
	    if (saveTexture) {
	        if (IsGameObject(renderTexture)) {
	            renderTexture.saveTexture(saveTexture);
	        } else if (renderTexture.key !== saveTexture) {
	            textureManager.renameTexture(renderTexture.key, key);
	        }
	    }

	    return renderTexture;
	};

	var RenderTexture$1 = {
	    snapshot(config) {
	        // Save scale
	        var scaleXSave = this.scaleX;
	        var scaleYSave = this.scaleY;
	        var scale1 = (scaleXSave === 1) && (scaleYSave === 1);
	        if (!scale1) {
	            this.setScale(1);
	        }

	        // Snapshot with scale = 1
	        if (config === undefined) {
	            config = {};
	        }
	        config.gameObjects = this.getAllVisibleChildren();
	        config.x = this.x;
	        config.y = this.y;
	        config.originX = this.originX;
	        config.originY = this.originY;
	        var rt = Snapshot(config);
	        var isValidRT = !!rt.scene;

	        // Restore scale
	        if (!scale1) {
	            this.setScale(scaleXSave, scaleYSave);

	            if (isValidRT) {
	                rt.setScale(scaleXSave, scaleYSave);
	            }
	        }

	        return (isValidRT) ? rt : this;
	    }
	};

	const GetValue$1T = Phaser.Utils.Objects.GetValue;

	var DrawBounds$1 = function (graphics, config) {
	    var drawContainer = GetValue$1T(config, 'drawContainer', true);

	    var gameObjects = GetValue$1T(config, 'children');
	    if (gameObjects === undefined) {
	        gameObjects = this.getAllVisibleChildren([this]);
	    }

	    if (!drawContainer) {
	        gameObjects = gameObjects.filter(function (gameObject) {
	            return !gameObject.isRexContainerLite;
	        });
	    }

	    DrawBounds$2(gameObjects, graphics, config);

	    return this;
	};

	const RotateAround$5 = Phaser.Math.RotateAround;

	var ChangeOrigin$1 = function (gameObject, originX, originY) {
	    if (originY === undefined) {
	        originY = originX;
	    }

	    var deltaXY = {
	        x: (originX - gameObject.originX) * gameObject.displayWidth,
	        y: (originY - gameObject.originY) * gameObject.displayHeight
	    };
	    RotateAround$5(deltaXY, 0, 0, gameObject.rotation);

	    gameObject.originX = originX;
	    gameObject.originY = originY;
	    gameObject.x = gameObject.x + deltaXY.x;
	    gameObject.y = gameObject.y + deltaXY.y;

	    return gameObject;
	};

	var ChangeOrigin = function (originX, originY) {
	    this.syncChildrenEnable = false;
	    ChangeOrigin$1(this, originX, originY);
	    this.syncChildrenEnable = true;

	    var children = this.getAllChildren();
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        this.resetChildPositionState(children[i]);
	    }
	    return this;
	};

	var methods$k = {
	    changeOrigin: ChangeOrigin,
	    drawBounds: DrawBounds$1,
	};

	Object.assign(
	    methods$k,
	    Parent,
	    AddChild$3,
	    RemoveChild$2,
	    ChildState,
	    Transform$1,
	    Position,
	    Rotation,
	    Scale$2,
	    Visible,
	    Alpha,
	    Active,
	    ScrollFactor,
	    CameraFilter,
	    Mask,
	    Depth,
	    Children,
	    Tween,
	    P3Container$1,
	    RenderLayer,
	    RenderTexture$1,
	);

	class ContainerLite extends Base$3 {
	    constructor(scene, x, y, width, height, children) {
	        if (Array.isArray(width)) {
	            children = width;
	            width = undefined;
	            height = undefined;
	        }
	        super(scene, x, y, width, height);
	        this.type = 'rexContainerLite';
	        this.isRexContainerLite = true;
	        this.syncChildrenEnable = true;

	        this._active = true;
	        this._mask = null;
	        this._scrollFactorX = 1;
	        this._scrollFactorY = 1;
	        this._cameraFilter = 0;
	        this.privateRenderLayer = undefined;

	        if (children) {
	            this.add(children);
	        }
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        this.syncChildrenEnable = false; // Don't sync properties changing anymore
	        super.destroy(fromScene);

	        if (this.privateRenderLayer && this.privateRenderLayer.scene) {
	            this.privateRenderLayer.list.length = 0;  // Remove all children without trigger callback
	            this.privateRenderLayer.destroy();
	        }
	    }

	    resize(width, height) {
	        this.setSize(width, height);
	        return this;
	    }

	    get x() {
	        return this._x;
	    }

	    set x(value) {
	        if (this._x === value) {
	            return;
	        }
	        this._x = value;

	        this.syncPosition();
	    }

	    get y() {
	        return this._y;
	    }

	    set y(value) {
	        if (this._y === value) {
	            return;
	        }
	        this._y = value;

	        this.syncPosition();
	    }

	    // Override
	    get rotation() {
	        return super.rotation;
	    }

	    set rotation(value) {
	        if (this.rotation === value) {
	            return;
	        }
	        super.rotation = value;

	        this.syncPosition();
	    }

	    // Override
	    get scaleX() {
	        return super.scaleX;
	    }

	    set scaleX(value) {
	        if (this.scaleX === value) {
	            return;
	        }
	        super.scaleX = value;

	        this.syncPosition();
	    }

	    // Override
	    get scaleY() {
	        return super.scaleY;
	    }

	    set scaleY(value) {
	        if (this.scaleY === value) {
	            return;
	        }
	        super.scaleY = value;

	        this.syncPosition();
	    }

	    // Override
	    get scale() {
	        return super.scale;
	    }

	    set scale(value) {
	        if (this.scale === value) {
	            return;
	        }
	        super.scale = value;

	        this.syncPosition();
	    }

	    // Override
	    get visible() {
	        return super.visible;
	    }

	    set visible(value) {
	        if (super.visible === value) {
	            return;
	        }
	        super.visible = value;

	        this.syncVisible();
	    }

	    // Override
	    get alpha() {
	        return super.alpha;
	    }

	    set alpha(value) {
	        if (super.alpha === value) {
	            return;
	        }
	        super.alpha = value;

	        this.syncAlpha();
	    }

	    // Override
	    get active() {
	        return this._active;
	    }

	    set active(value) {
	        if (this._active === value) {
	            return;
	        }
	        this._active = value;

	        this.syncActive();
	    }

	    // Override
	    get mask() {
	        return this._mask;
	    }
	    set mask(mask) {
	        if (this._mask === mask) {
	            return;
	        }
	        this._mask = mask;

	        this.syncMask();
	    }

	    // Override
	    get scrollFactorX() {
	        return this._scrollFactorX;
	    }

	    set scrollFactorX(value) {
	        if (this._scrollFactorX === value) {
	            return;
	        }

	        this._scrollFactorX = value;
	        this.syncScrollFactor();
	    }
	    get scrollFactorY() {
	        return this._scrollFactorY;
	    }

	    set scrollFactorY(value) {
	        if (this._scrollFactorY === value) {
	            return;
	        }

	        this._scrollFactorY = value;
	        this.syncScrollFactor();
	    }

	    get cameraFilter() {
	        return this._cameraFilter;
	    }

	    set cameraFilter(value) {
	        if (this._cameraFilter === value) {
	            return;
	        }

	        this._cameraFilter = value;
	        this.syncCameraFilter();
	    }

	    // Compatiable with container plugin
	    get list() {
	        return this.children;
	    }

	    static GetParent(child) {
	        return GetParent$1(child);
	    }

	    // For p3-container
	    get parentContainer() {
	        return this._parentContainer;
	    }

	    set parentContainer(value) {
	        // Initialize
	        if (!this._parentContainer && !value) {
	            this._parentContainer = value;
	            return;
	        }

	        // Set this._parentContainer only,
	        // if under AddToContainer, or RemoveFromContainer methods
	        if (this.setParentContainerFlag) {
	            this._parentContainer = value;
	            return;
	        }
	        // else if (!this.setParentContainerFlag)

	        // Add itself and all children to container,
	        // Or remove itseld and all children from container
	        if (this._parentContainer && !value) {
	            // Remove from container
	            this.removeFromContainer();
	            this._parentContainer = value;
	        } else if (value) {
	            // Add to container
	            this._parentContainer = value;
	            this.addToContainer(value);
	        } else {
	            this._parentContainer = value;
	        }
	    }

	    get setParentContainerFlag() {
	        if (this._setParentContainerFlag) {
	            return true;
	        }
	        var parent = GetParent$1(this);
	        return (parent) ? parent.setParentContainerFlag : false;
	    }

	}

	Object.assign(
	    ContainerLite.prototype,
	    methods$k
	);

	var SetTransitionCallbackMethods = {
	    setTransitionStartCallback(callback, scope) {
	        this.onStartCallback = callback;
	        this.onStartCallbackScope = scope;
	        return this;
	    },

	    setTransitionProgressCallback(callback, scope) {
	        this.onProgressCallback = callback;
	        this.onProgressCallbackScope = scope;
	        return this;
	    },

	    setTransitionCompleteCallback(callback, scope) {
	        this.onCompleteCallback = callback;
	        this.onCompleteCallbackScope = scope;
	        return this;
	    },
	};

	const GetValue$1S = Phaser.Utils.Objects.GetValue;
	const Linear$h = Phaser.Math.Linear;

	class EaseValueTask extends EaseValueTaskBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;
	        // this.timer

	        this.resetFromJSON();
	        this.boot();
	    }

	    start(config) {
	        if (this.timer.isRunning) {
	            return this;
	        }

	        var target = this.target;
	        this.propertyKey = GetValue$1S(config, 'key', 'value');
	        var currentValue = target[this.propertyKey];
	        this.fromValue = GetValue$1S(config, 'from', currentValue);
	        this.toValue = GetValue$1S(config, 'to', currentValue);

	        this.setEase(GetValue$1S(config, 'ease', this.ease));
	        this.setDuration(GetValue$1S(config, 'duration', this.duration));
	        this.setRepeat(GetValue$1S(config, 'repeat', 0));
	        this.setDelay(GetValue$1S(config, 'delay', 0));
	        this.setRepeatDelay(GetValue$1S(config, 'repeatDelay', 0));

	        this.timer
	            .setDuration(this.duration)
	            .setRepeat(this.repeat)
	            .setDelay(this.delay)
	            .setRepeatDelay(this.repeatDelay);

	        target[this.propertyKey] = this.fromValue;

	        super.start();
	        return this;
	    }

	    updateTarget(target, timer) {
	        var t = timer.t;
	        t = this.easeFn(t);

	        target[this.propertyKey] = Linear$h(this.fromValue, this.toValue, t);
	    }
	}

	var FitTo = function (source, target, fitMode, out) {
	    if (fitMode === undefined) {
	        fitMode = 0;
	    } else {
	        var fitModeType = typeof (fitMode);
	        if (fitModeType === 'boolean') {
	            out = fitMode;
	            fitMode = 0;
	        } else if (fitModeType === 'string') {
	            fitMode = FitModeMap[fitMode];
	        }
	    }

	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        out = globalSize;
	    }

	    var scaleX = target.width / source.width;
	    var scaleY = target.height / source.height;
	    var scale = (!fitMode) ? Math.min(scaleX, scaleY) : Math.max(scaleX, scaleY);
	    out.width = source.width * scale;
	    out.height = source.height * scale;

	    return out;
	};

	const FitModeMap = {
	    'fit': 0,
	    'FIT': 0,
	    'envelop': 1,
	    'ENVELOP': 1
	};

	var globalSize = {};

	var FitImages = function () {
	    var scaleMode = this.scaleMode - 1;  // 1->0(FIT), 2->1(ENVELOP)
	    for (var i = 0, cnt = this.images.length; i < cnt; i++) {
	        var image = this.images[i];
	        var result = FitTo(image, this, scaleMode, true);
	        var biasScale = result.width / image.width;
	        this.setChildLocalScale(image, biasScale);
	        image.biasScale = biasScale;
	    }
	};

	var OnTextureChange = function (newImage) {
	    if (this.scaleMode === 0) {
	        this.resize(newImage.width, newImage.height);

	    } else {
	        // Fit all images to parent's size
	        FitImages.call(this);
	    }
	};

	const IsPlainObject$A = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$1R = Phaser.Utils.Objects.GetValue;
	const GetRandomItem$1 = Phaser.Utils.Array.GetRandom;

	var DirMode = {
	    out: 0,
	    in: 1
	};

	var GetValueFromConfigs = function (key, defaultValue, ...configs) {
	    for (var i = 0, cnt = configs.length; i < cnt; i++) {
	        var config = configs[i];
	        if (config && config.hasOwnProperty(key)) {
	            return config[key];
	        }
	    }
	    return defaultValue;
	};

	var TransitionMethods = {
	    setTransitionDirection(dir) {
	        if (typeof (dir) === 'string') {
	            dir = DirMode[dir];
	        }
	        this.dir = dir;
	        return this;
	    },

	    setDuration(duration) {
	        this.duration = duration;
	        return this;
	    },

	    setEaseFunction(ease) {
	        this.easeFunction = ease;
	        return this;
	    },

	    setNextTexture(texture, frame) {
	        this.nextImage.setTexture(texture, frame);

	        OnTextureChange.call(this, this.nextImage);
	        return this;
	    },

	    transit(texture, frame, mode) {
	        if (this.isRunning) {
	            this.ignoreCompleteEvent = true;
	            this.stop();
	            this.ignoreCompleteEvent = false;
	        }

	        if (mode !== undefined) {
	            texture = {
	                key: texture,
	                frame: frame,
	                mode: mode
	            };
	        }

	        this.currentTransitionMode = undefined;

	        if (IsPlainObject$A(texture)) {
	            var config = texture;
	            texture = GetValue$1R(config, 'key', undefined);
	            frame = GetValue$1R(config, 'frame', undefined);

	            mode = GetValue$1R(config, 'mode');
	            if (Array.isArray(mode)) {
	                mode = GetRandomItem$1(mode);
	            }

	            var modeConfig;
	            if (this.transitionModes && this.transitionModes.hasOwnProperty(mode)) {
	                modeConfig = this.transitionModes[mode];
	                this.currentTransitionMode = mode;
	            }

	            this
	                .setDuration(GetValueFromConfigs('duration', this.duration, config, modeConfig))
	                .setEaseFunction(GetValueFromConfigs('ease', this.easeFunction, config, modeConfig))
	                .setTransitionDirection(GetValueFromConfigs('dir', this.dir, config, modeConfig));

	            var maskGameObject = GetValueFromConfigs('mask', undefined, config, modeConfig);
	            if (maskGameObject) {
	                this.setMaskGameObject(maskGameObject);
	            }
	            this.setMaskEnable(maskGameObject === true);

	            var onStart = GetValueFromConfigs('onStart', undefined, config, modeConfig);
	            var onProgress = GetValueFromConfigs('onProgress', undefined, config, modeConfig);
	            var onComplete = GetValueFromConfigs('onComplete', undefined, config, modeConfig);
	            if ((onStart !== undefined) || (onProgress !== undefined) || (onComplete !== undefined)) {
	                this
	                    .setTransitionStartCallback(
	                        onStart,
	                        GetValueFromConfigs('onStartScope', undefined, config, modeConfig)
	                    )
	                    .setTransitionProgressCallback(
	                        onProgress,
	                        GetValueFromConfigs('onProgressScope', undefined, config, modeConfig)
	                    )
	                    .setTransitionCompleteCallback(
	                        onComplete,
	                        GetValueFromConfigs('onCompleteScope', undefined, config, modeConfig)
	                    );
	            }
	        }

	        this.setNextTexture(texture, frame);

	        this.start();
	        return this;
	    },

	    addTransitionMode(name, config) {
	        if (this.transitionModes === undefined) {
	            this.transitionModes = {};
	        }

	        if (IsPlainObject$A(name)) {
	            config = name;
	            name = config.name;
	            delete config.name;
	        }

	        this.transitionModes[name] = config;
	        return this;
	    },

	    start() {
	        if (this.easeValueTask === undefined) {
	            this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
	        }
	        this.easeValueTask.restart({
	            key: 't', from: 0, to: 1,
	            duration: this.duration,
	            ease: this.easeFunction
	        });
	        return this;
	    },

	    pause() {
	        if (this.easeValueTask) {
	            this.easeValueTask.pause();
	        }
	        return this;
	    },

	    resume() {
	        if (this.easeValueTask) {
	            this.easeValueTask.resume();
	        }
	        return this;
	    },

	    stop() {
	        if (this.easeValueTask) {
	            this.easeValueTask.stop();
	        }
	        this.setT(1);
	        return this;
	    },
	};

	const SetPositionBase = Phaser.GameObjects.Graphics.prototype.setPosition;

	var SetPosition = function (x, y) {
	    var parent = this.parent;
	    if (x === undefined) {
	        x = parent.x;
	    }
	    if (y === undefined) {
	        y = parent.y;
	    }

	    SetPositionBase.call(this, x, y);
	    return this;
	};

	const RectangleGeom = Phaser.Geom.Rectangle;
	const CircleGemo = Phaser.Geom.Circle;

	var GetGeom = function (shapeType, width, height, padding, originX, originY, out) {
	    switch (shapeType) {
	        case 1: // circle
	            // Assume that all padding are the same value in this circle shape
	            padding = padding.left;
	            var centerX = -width * (originX - 0.5);
	            var centerY = -height * (originY - 0.5);
	            var radius = Math.min(width, height) / 2 + padding;

	            if ((out === undefined) || !(out instanceof (CircleGemo))) {
	                out = new CircleGemo();
	            }
	            out.setTo(centerX, centerY, radius);
	            break;

	        default: // 0|'rectangle'
	            var topLeftX = -(width * originX) - padding.left;
	            var topLeftY = -(height * originY) - padding.top;
	            var rectWidth = width + padding.left + padding.right;
	            var rectHeight = height + padding.top + padding.bottom;

	            if ((out === undefined) || !(out instanceof (RectangleGeom))) {
	                out = new RectangleGeom();
	            }
	            out.setTo(topLeftX, topLeftY, rectWidth, rectHeight);
	            break;
	    }

	    return out;
	};

	var DrawShape = function (width, height, padding, originX, originY) {
	    this.geom = GetGeom(this.shapeType, width, height, padding, originX, originY, this.geom);

	    this.clear().fillStyle(0xffffff);
	    switch (this.shapeType) {
	        case 1: // circle
	            // Assume that all padding are the same value in this circle shape
	            this.fillCircleShape(this.geom);
	            break;

	        default: // 0|'rectangle'
	            this.fillRectShape(this.geom);
	            break;
	    }
	};

	var IsKeyValueEqual = function (objA, objB) {
	    for (var key in objA) {
	        if (!(key in objB)) {
	            return false;
	        }

	        if (objA[key] !== objB[key]) {
	            return false;
	        }
	    }

	    for (var key in objB) {
	        if (!(key in objA)) {
	            return false;
	        }
	    }

	    return true;
	};

	var Resize = function (width, height, padding) {
	    var parent = this.parent;
	    if (width === undefined) {
	        width = parent.width;
	    }
	    if (height === undefined) {
	        height = parent.height;
	    }

	    if (padding === undefined) {
	        padding = this.padding;
	    } else if (typeof (padding) === 'number') {
	        padding = GetBoundsConfig(padding);
	    }

	    var isSizeChanged = (this.width !== width) || (this.height !== height);
	    var isPaddingChanged = (this.padding !== padding) && !IsKeyValueEqual(this.padding, padding);
	    if (!isSizeChanged && !isPaddingChanged) {
	        return this;
	    }

	    this.width = width;
	    this.height = height;

	    if (isPaddingChanged) {
	        Clone(padding, this.padding);
	    }

	    // Graphics does not have originX, originY properties
	    this.originX = parent.originX;
	    this.originY = parent.originY;

	    DrawShape.call(this,
	        width, height, padding,
	        parent.originX, parent.originY
	    );

	    return this;
	};

	var SetOrigin = function (originX, originY) {
	    if (originY === undefined) {
	        originY = originX;
	    }

	    var parent = this.parent;
	    if (originX === undefined) {
	        originX = parent.originX;
	    }
	    if (originY === undefined) {
	        originY = parent.originY;
	    }
	    if ((this.originX === originX) && (this.originY === originY)) {
	        return this;
	    }

	    this.originX = originX;
	    this.originY = originY;

	    DrawShape.call(this,
	        this.width, this.height, this.padding,
	        originX, originY,
	    );
	    return this;
	};

	var Contains$2 = function (x, y) {
	    x -= this.x;
	    y -= this.y;
	    return this.geom.contains(x, y);
	};

	var Methods$b = {
	    setPosition: SetPosition,
	    resize: Resize,
	    setOrigin: SetOrigin,
	    contains: Contains$2,
	};

	const GetValue$1Q = Phaser.Utils.Objects.GetValue;

	var GetBoundsConfig$1 = function (config, out) {
	    if (config === undefined) {
	        config = 0;
	    }
	    if (out === undefined) {
	        out = {};
	    }

	    if (typeof (config) === 'number') {
	        out.left = config;
	        out.right = config;
	        out.top = config;
	        out.bottom = config;
	    } else {
	        out.left = GetValue$1Q(config, 'left', 0);
	        out.right = GetValue$1Q(config, 'right', 0);
	        out.top = GetValue$1Q(config, 'top', 0);
	        out.bottom = GetValue$1Q(config, 'bottom', 0);
	    }
	    return out;
	};

	const Graphics = Phaser.GameObjects.Graphics;

	class DefaultMaskGraphics extends Graphics {
	    constructor(parent, shapeType, padding) {
	        if (shapeType === undefined) {
	            shapeType = 0;
	        }
	        if (typeof (shapeType) === 'string') {
	            shapeType = SHAPEMODE[shapeType];
	        }

	        super(parent.scene);
	        this.parent = parent;
	        this.shapeType = shapeType;
	        this.padding = GetBoundsConfig$1(padding);
	        this.setPosition().resize().setVisible(false);
	        // Don't add it to display list
	    }

	    destroy() {
	        this.parent = undefined;
	        super.destroy();
	        return this;
	    }
	}

	const SHAPEMODE = {
	    rectangle: 0,
	    circle: 1,
	};

	Object.assign(
	    DefaultMaskGraphics.prototype,
	    Methods$b
	);

	var MaskMethods = {
	    setMaskGameObject(gameObject) {
	        if (!gameObject) {
	            this.removeMaskGameObject();
	            return this;
	        }

	        if (this.maskGameObject) {
	            if ((gameObject === true) && (this.maskGameObject instanceof DefaultMaskGraphics)) {
	                return this;
	            }
	            if (this.maskGameObject === gameObject) {
	                return this;
	            }

	            // Remove previous Mask Game Object
	            this.removeMaskGameObject();
	        }

	        // Add new Mask Game Object
	        if (gameObject === true) {
	            gameObject = new DefaultMaskGraphics(this);
	        }

	        gameObject
	            .resize(this.width, this.height)
	            .setOrigin(this.originX, this.originY)
	            .setPosition(0, 0)
	            .setScale(1)
	            .setVisible(false);
	        this.addLocal(gameObject);
	        this.maskGameObject = gameObject;

	        if (!gameObject._maskObject) {
	            gameObject._maskObject = gameObject.createGeometryMask();
	            gameObject.once('destroy', function () {
	                gameObject._maskObject.destroy();
	                gameObject._maskObject = undefined;
	            });
	        }
	        this.childrenMask = gameObject._maskObject;

	        return this;
	    },

	    removeMaskGameObject(destroyMaskGameObject) {
	        if (destroyMaskGameObject === undefined) {
	            destroyMaskGameObject = true;
	        }

	        this.backImage.clearMask();
	        this.frontImage.clearMask();
	        this.childrenMask = undefined;
	        this.remove(this.maskGameObject, destroyMaskGameObject);
	        this.maskGameObject = undefined;
	        return this;
	    },

	    setImageMaskEnable(gameObject, enable, invertAlpha) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        if (invertAlpha === undefined) {
	            invertAlpha = false;
	        }

	        if (enable) {
	            // Use DefaultMaskGraphics if not given    
	            if (!this.childrenMask) {
	                this.setMaskGameObject(true);
	            }
	            gameObject.setMask(this.childrenMask);
	            this.childrenMask.setInvertAlpha(invertAlpha);
	        } else {
	            gameObject.clearMask();
	        }

	        return this;
	    },

	    setCurrentImageMaskEnable(enable, invertAlpha) {
	        this.setImageMaskEnable(this.currentImage, enable, invertAlpha);
	        return this;
	    },

	    setNextImageMaskEnable(enable, invertAlpha) {
	        this.setImageMaskEnable(this.nextImage, enable, invertAlpha);
	        return this;
	    },

	    setCellImagesMaskEnable(enable, invertAlpha) {
	        var cellImages = this.getCellImages();
	        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
	            this.setImageMaskEnable(cellImages[i], enable, invertAlpha);
	        }
	        return this;
	    },

	    setMaskEnable(enable, invertAlpha) {
	        this.setImageMaskEnable(this.backImage, enable, invertAlpha);
	        this.setImageMaskEnable(this.frontImage, enable, invertAlpha);
	        this.setCellImagesMaskEnable(enable, invertAlpha);
	        return this;
	    }
	};

	var GetFrameNameCallback = function (baseFrameName, delimiter) {
	    if (typeof (baseFrameName) === 'object') {
	        baseFrameName = baseFrameName.name;
	    }

	    if (delimiter === undefined) {
	        delimiter = ',';
	    }

	    var callback;
	    if (baseFrameName === '__BASE') {
	        callback = function (colIndex, rowIndex) {
	            return `${colIndex}${delimiter}${rowIndex}`;
	        };
	    } else {
	        callback = function (colIndex, rowIndex) {
	            return `${baseFrameName}_${colIndex}${delimiter}${rowIndex}`;
	        };
	    }

	    return callback;
	};

	var GenerateFrames = function (scene, key, frame, columns, rows, getFrameNameCallback) {
	    if (frame == null) {
	        frame = '__BASE';
	    }

	    if (!getFrameNameCallback) {
	        getFrameNameCallback = GetFrameNameCallback(frame, getFrameNameCallback);
	    }

	    var texture = scene.sys.textures.get(key);
	    var baseFrame = (typeof (frame) === 'object') ? frame : texture.get(frame);

	    var baseWidth = baseFrame.width,
	        baseHeight = baseFrame.height;

	    var cellX, cellY, cellName;
	    var cellWidth = baseWidth / columns,
	        cellHeight = baseHeight / rows;

	    var frameCutX = baseFrame.cutX,
	        frameCutY = baseFrame.cutY;
	    var offsetX = 0,
	        offsetY = 0;
	    for (var y = 0; y < rows; y++) {
	        offsetX = 0;
	        for (var x = 0; x < columns; x++) {
	            cellName = getFrameNameCallback(x, y);

	            cellX = offsetX + frameCutX;
	            cellY = offsetY + frameCutY;

	            texture.add(
	                cellName, 0,
	                cellX, cellY,
	                cellWidth, cellHeight
	            );

	            offsetX += cellWidth;
	        }
	        offsetY += cellHeight;
	    }

	    return {
	        getFrameNameCallback: getFrameNameCallback,
	        cellWidth: cellWidth,
	        cellHeight: cellHeight,
	        columns: columns,
	        rows: rows
	    }
	};

	const GetValue$1P = Phaser.Utils.Objects.GetValue;
	const DefaultImageClass = Phaser.GameObjects.Image;
	const IsPlainObject$z = Phaser.Utils.Objects.IsPlainObject;
	const RotateAround$4 = Phaser.Math.RotateAround;

	var GridCutImage = function (gameObject, columns, rows, config) {
	    if (IsPlainObject$z(columns)) {
	        config = columns;
	        columns = GetValue$1P(config, 'columns', 1);
	        rows = GetValue$1P(config, 'rows', 1);
	    }

	    var createImageCallback = GetValue$1P(config, 'createImageCallback');
	    if (!createImageCallback) {
	        var ImageClass = GetValue$1P(config, 'ImageClass', DefaultImageClass);
	        createImageCallback = function (scene, key, frame) {
	            return new ImageClass(scene, 0, 0, key, frame);
	        };
	    }

	    var originX = GetValue$1P(config, 'originX', 0.5);
	    var originY = GetValue$1P(config, 'originY', 0.5);

	    var addToScene = GetValue$1P(config, 'add', true);

	    var align = GetValue$1P(config, 'align', addToScene);

	    var imageObjectPool = GetValue$1P(config, 'objectPool', undefined);

	    var scene = gameObject.scene;
	    var texture = gameObject.texture;
	    var frame = gameObject.frame;

	    var result = GenerateFrames(scene, texture, frame, columns, rows);
	    var getFrameNameCallback = result.getFrameNameCallback;
	    var scaleX = gameObject.scaleX,
	        scaleY = gameObject.scaleY;
	    var rotation = gameObject.rotation;
	    var topLeft = gameObject.getTopLeft(),
	        startX = topLeft.x,
	        startY = topLeft.y;

	    var cellGameObjects = [];
	    var scaleCellWidth = result.cellWidth * scaleX,
	        scaleCellHeight = result.cellHeight * scaleY;
	    for (var y = 0; y < rows; y++) {
	        for (var x = 0; x < columns; x++) {
	            var cellGameObject;

	            var frameName = getFrameNameCallback(x, y);
	            if (imageObjectPool && (imageObjectPool.length > 0)) {
	                cellGameObject = (imageObjectPool.pop()).setTexture(texture, frameName);
	            } else {
	                cellGameObject = createImageCallback(scene, texture, frameName);
	            }

	            if (addToScene) {
	                scene.add.existing(cellGameObject);
	            }

	            if (align) {
	                var cellTLX = startX + (scaleCellWidth * x);
	                var cellTLY = startY + (scaleCellHeight * y);
	                var cellX = cellTLX + (originX * scaleCellWidth);
	                var cellY = cellTLY + (originY * scaleCellHeight);

	                cellGameObject
	                    .setOrigin(originX, originY)
	                    .setPosition(cellX, cellY)
	                    .setScale(scaleX, scaleY)
	                    .setRotation(rotation);
	                RotateAround$4(cellGameObject, startX, startY, rotation);
	            }

	            cellGameObjects.push(cellGameObject);
	        }
	    }

	    return cellGameObjects;
	};

	var GridCutMethods = {
	    gridCutImage(gameObject, columns, rows, config) {
	        if (config === undefined) {
	            config = {};
	        }
	        config.objectPool = this.imagesPool;
	        var cellImages = GridCutImage(gameObject, columns, rows, config),
	            cellImage;
	        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
	            cellImage = cellImages[i];
	            cellImage.setVisible(true);
	            this.add(cellImage);
	        }

	        this.cellImages = cellImages;
	        this.setChildLocalVisible(gameObject, false);  // Set cut target to invisible
	        return cellImages;
	    },

	    gridCutCurrentImage(columns, rows, config) {
	        return this.gridCutImage(this.currentImage, columns, rows, config);
	    },

	    gridCutNextImage(columns, rows, config) {
	        return this.gridCutImage(this.nextImage, columns, rows, config);
	    },

	    getCellImages() {
	        return this.cellImages;
	    },

	    freeCellImages() {
	        if (this.cellImages.length === 0) {
	            return this;
	        }

	        var texture = this.cellImages[0].texture;
	        var cellImages = this.cellImages,
	            cellImage, frameName;
	        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
	            cellImage = cellImages[i];

	            // Reset property of cell image
	            this
	                .setChildLocalAlpha(cellImage, 1)
	                .setChildLocalScale(cellImage, 1)
	                .setChildLocalVisible(cellImage, false);

	            cellImage.clearMask();

	            // Remove frame object
	            frameName = cellImage.frame.name;
	            cellImage.setTexture();
	            texture.remove(frameName);
	        }

	        this.imagesPool.push(...cellImages);
	        cellImages.length = 0;

	        return this;
	    }
	};

	var FlipMethods = {
	    setFlipX(value) {
	        this.flipX = value;
	        return this;
	    },
	    setFlipY(value) {
	        this.flipY = value;
	        return this;
	    },
	    toggleFlipX() {
	        this.flipX = !this.flipX;
	        return this;
	    },
	    toggleFlipY() {
	        this.flipY = !this.flipY;
	        return this;
	    },
	    setFlip(x, y) {
	        this.flipX = x;
	        this.flipY = y;
	        return this;
	    },
	    resetFlip() {
	        this.flipX = false;
	        this.flipY = false;
	        return this;
	    }
	};

	var methods$j = {
	};

	Object.assign(
	    methods$j,
	    SetTransitionCallbackMethods,
	    TransitionMethods,
	    MaskMethods,
	    GridCutMethods,
	    FlipMethods
	);

	var OnStart = function (parent, currentImage, nextImage, t) {
	};

	var OnProgress = function (parent, currentImage, nextImage, t) {
	    parent
	        .setChildLocalAlpha(currentImage, 1 - t)
	        .setChildLocalAlpha(nextImage, t);
	};

	var OnComplete = function (parent, currentImage, nextImage, t) {
	    parent.setChildLocalAlpha(currentImage, 1);
	};

	const IsPlainObject$y = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$1O = Phaser.Utils.Objects.GetValue;
	const Clamp$7 = Phaser.Math.Clamp;

	class TransitionImage extends ContainerLite {
	    constructor(scene, x, y, texture, frame, config) {
	        if (IsPlainObject$y(x)) {
	            config = x;
	            x = GetValue$1O(config, 'x', 0);
	            y = GetValue$1O(config, 'y', 0);
	            texture = GetValue$1O(config, 'key', undefined);
	            frame = GetValue$1O(config, 'frame', undefined);
	        } else if (IsPlainObject$y(frame)) {
	            config = frame;
	            frame = undefined;
	        }

	        var backImage = GetValue$1O(config, 'back', undefined);
	        var frontImage = GetValue$1O(config, 'front', undefined);
	        if (!backImage) {
	            backImage = scene.add.image(x, y, texture, frame);
	        }
	        if (!frontImage) {
	            frontImage = scene.add.image(x, y, texture, frame);
	        }

	        var width = GetValue$1O(config, 'width', undefined);
	        var height = GetValue$1O(config, 'height', undefined);
	        var scaleMode = ((width !== undefined) && (height !== undefined)) ? 1 : 0;

	        if (width === undefined) {
	            width = frontImage.width;
	        }
	        if (height === undefined) {
	            height = frontImage.height;
	        }

	        super(scene, x, y, width, height);
	        this.type = 'rexTransitionImage';
	        this._flipX = false;
	        this._flipY = false;

	        scaleMode = GetValue$1O(config, 'scaleMode', scaleMode);
	        if (typeof (scaleMode) === 'string') {
	            scaleMode = ScaleModeMap[scaleMode];
	        }
	        this.scaleMode = scaleMode;

	        backImage.setVisible(false);
	        this.addMultiple([backImage, frontImage]);

	        this.backImage = backImage;
	        this.frontImage = frontImage;
	        this.images = [this.backImage, this.frontImage];
	        this.maskGameObject = undefined;
	        this.cellImages = [];
	        this.imagesPool = [];
	        this.transitionModes = undefined;
	        this.currentTransitionMode = undefined;

	        // Transition parameters
	        var onStart = GetValue$1O(config, 'onStart', undefined);
	        var onProgress = GetValue$1O(config, 'onProgress', undefined);
	        var onComplete = GetValue$1O(config, 'onComplete', undefined);
	        var dir = GetValue$1O(config, 'dir', 0);
	        if ((onStart === undefined) && (onProgress === undefined) && (onComplete === undefined)) {
	            onStart = OnStart;
	            onProgress = OnProgress;
	            onComplete = OnComplete;
	            dir = 0;
	        }

	        this
	            .setTransitionStartCallback(
	                onStart,
	                GetValue$1O(config, 'onStartScope', undefined)
	            )
	            .setTransitionProgressCallback(
	                onProgress,
	                GetValue$1O(config, 'onProgressScope', undefined)
	            )
	            .setTransitionCompleteCallback(
	                onComplete,
	                GetValue$1O(config, 'onCompleteScope', undefined)
	            )
	            .setTransitionDirection(dir)
	            .setDuration(GetValue$1O(config, 'duration', 1000))
	            .setEaseFunction(GetValue$1O(config, 'ease', 'Linear'));

	        var maskGameObject = GetValue$1O(config, 'mask', undefined);
	        if (maskGameObject) {
	            this.setMaskGameObject(maskGameObject);
	        }
	        this.setMaskEnable(false);

	        this.ignoreCompleteEvent = false;

	        OnTextureChange.call(this, this.frontImage);
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        if (this.childrenMask) {
	            this.childrenMask.destroy();
	            this.childrenMask = undefined;
	        }
	        this.backImage = undefined;
	        this.frontImage = undefined;
	        this.images.length = 0;
	        this.maskGameObject = undefined;
	        this.cellImages.length = 0;
	        this.imagesPool.length = 0;
	        this.transitionModes = undefined;

	        super.destroy(fromScene);

	        this.onStartCallback = undefined;
	        this.onStartCallbackScope = undefined;
	        this.onProgressCallback = undefined;
	        this.onProgressCallbackScope = undefined;
	        this.onCompleteCallback = undefined;
	        this.onCompleteCallbackScope = undefined;
	        this.easeValueTask = undefined;
	    }

	    get currentImage() {
	        return (this.dir === 0) ? this.frontImage : this.backImage;
	    }

	    get nextImage() {
	        return (this.dir === 0) ? this.backImage : this.frontImage;
	    }

	    get texture() {
	        return this.nextImage.texture;
	    }

	    get frame() {
	        return this.nextImage.frame;
	    }

	    get tint() {
	        return this._tint;
	    }

	    set tint(value) {
	        if (this._tint === value) {
	            return;
	        }

	        this._tint = value;
	        this.backImage.setTint(value);
	        this.frontImage.setTint(value);
	    }

	    setTint(value) {
	        this.tint = value;
	        return this;
	    }

	    get flipX() {
	        return this._flipX;
	    }

	    set flipX(value) {
	        if (this._flipX === value) {
	            return;
	        }

	        this._flipX = value;
	        this.backImage.setFlipX(value);
	        this.frontImage.setFlipX(value);
	    }

	    setFlipX(value) {
	        this.flipX = value;
	        return this;
	    }

	    toggleFlipX() {
	        this.flipX = !this.flipX;
	        return this;
	    }

	    get flipY() {
	        return this._flipY;
	    }

	    set flipY(value) {
	        if (this._flipY === value) {
	            return;
	        }
	        this._flipY = value;
	        this.backImage.setFlipY(value);
	        this.frontImage.setFlipY(value);
	    }

	    setFlipY(value) {
	        this.flipY = value;
	        return this;
	    }

	    toggleFlipY() {
	        this.flipY = !this.flipY;
	        return this;
	    }

	    setFlip(flipX, flipY) {
	        this.flipX = flipX;
	        this.flipY = flipY;
	        return this;
	    }

	    get t() {
	        return this._t;
	    }

	    set t(value) {
	        value = Clamp$7(value, 0, 1);
	        if (this._t === value) {
	            return;
	        }
	        this._t = value;

	        var currentImage = this.currentImage;
	        var nextImage = this.nextImage;

	        // Start
	        if (value === 0) {
	            this
	                .setChildVisible(this.frontImage, true)
	                .setChildVisible(this.backImage, true);

	            RunCallback.call(this,
	                this.onStartCallback, this.onStartCallbackScope,
	                this, currentImage, nextImage, value
	            );
	        }

	        // Progress
	        RunCallback.call(this,
	            this.onProgressCallback, this.onProgressCallbackScope,
	            this, currentImage, nextImage, value
	        );

	        // Complete
	        if (value === 1) {
	            RunCallback.call(this,
	                this.onCompleteCallback, this.onCompleteCallbackScope,
	                this, currentImage, nextImage, value
	            );

	            var key = nextImage.texture.key,
	                frame = nextImage.frame.name;
	            this.frontImage.setTexture(key, frame);
	            this.backImage.setTexture(key, frame);
	            OnTextureChange.call(this, nextImage);

	            this
	                .setChildVisible(this.frontImage, true)
	                .setChildVisible(this.backImage, false)
	                .setMaskEnable(false)
	                .freeCellImages();
	        }

	        if ((value === 1) && (!this.ignoreCompleteEvent)) {
	            this.emit('complete');
	        }
	    }

	    setT(value) {
	        this.t = value;
	        return this;
	    }

	    get isRunning() {
	        return (this.easeValueTask) ? this.easeValueTask.isRunning : false;
	    }

	    setOrigin(originX, originY) {
	        super.setOrigin(originX, originY);

	        this.backImage.setOrigin(originX, originY);
	        this.frontImage.setOrigin(originX, originY);

	        if (this.maskGameObject) {
	            this.maskGameObject.setOrigin(originX, originY);
	        }

	        return this;
	    }

	    setTexture(texture, frame) {
	        // Without transition
	        this.frontImage.setTexture(texture, frame);
	        this.backImage.setTexture(texture, frame).setVisible(false);

	        OnTextureChange.call(this, this.frontImage);

	        return this;
	    }

	    setSize(width, height) {
	        super.setSize(width, height);

	        if (this.scaleMode) {
	            FitImages.call(this);
	        }

	        return this;
	    }
	}

	var RunCallback = function (callback, scope, parent, currentImage, nextImage, t) {
	    if (!callback) {
	        return;
	    }

	    if (this.scaleMode) {
	        var localScale;
	        if (currentImage.biasScale > 0) {
	            localScale = this.getChildLocalScaleX(currentImage);
	            localScale = localScale / currentImage.biasScale;
	            this.setChildLocalScale(currentImage, localScale);
	        }
	        if (nextImage.biasScale) {
	            localScale = this.getChildLocalScaleX(nextImage);
	            localScale = localScale / nextImage.biasScale;
	            this.setChildLocalScale(nextImage, localScale);
	        }
	    }

	    if (scope) {
	        callback.call(scope, parent, currentImage, nextImage, t);
	    } else {
	        callback(parent, currentImage, nextImage, t);
	    }

	    if (this.scaleMode) {
	        var localScale;
	        if (currentImage.biasScale > 0) {
	            localScale = this.getChildLocalScaleX(currentImage);
	            localScale = localScale * currentImage.biasScale;
	            this.setChildLocalScale(currentImage, localScale);
	        }
	        if (nextImage.biasScale) {
	            localScale = this.getChildLocalScaleX(nextImage);
	            localScale = localScale * nextImage.biasScale;
	            this.setChildLocalScale(nextImage, localScale);
	        }
	    }
	};

	// mixin
	Object.assign(
	    TransitionImage.prototype,
	    methods$j
	);

	const ScaleModeMap = {
	    fit: 1,
	    FIT: 1,
	    envelop: 2,
	    ENVELOP: 2
	};

	// Slide modes
	const SlideLeft = 'slideLeft';
	const SlideRight = 'slideRight';
	const SlideUp = 'slideUp';
	const SlideDown = 'slideDown';
	const SlideAwayLeft = 'slideAwayLeft';
	const SlideAwayRight = 'slideAwayRight';
	const SlideAwayUp = 'slideAwayUp';
	const SlideAwayDown = 'slideAwayDown';
	const PushLeft = 'pushLeft';
	const PushRight = 'pushRight';
	const PushUp = 'pushUp';
	const PushDown = 'pushDown';

	// Zoom modes
	const ZoomOut = 'zoomOut';
	const ZoomIn = 'zoomIn';
	const ZoomInOut = 'zoomInOut';

	// Fade effect mode
	const Fade$1 = 'fade';
	const CrossFade = 'crossFade';

	// Wipe modes
	const WipeLeft = 'wipeLeft';
	const WipeRight = 'wipeRight';
	const WipeUp = 'wipeUp';
	const WipeDown = 'wipeDown';

	// Iris modes
	const IrisOut = 'irisOut';
	const IrisIn = 'irisIn';
	const IrisInOut = 'irisInOut';

	// Pie modes
	const PieOut = 'pieOut';
	const PieIn = 'pieIn';
	const PieInOut = 'pieInOut';

	// blinds, squares, diamonds, circles, curtain
	const Blinds = 'blinds';
	const Squares = 'squares';
	const Diamonds = 'diamonds';
	const Circles = 'circles';
	const Curtain = 'curtain';

	// Shader effect modes
	const Pixellate = 'pixellate';
	const Dissolve = 'dissolve';

	const RevealLeft = 'revealLeft';
	const RevealRight = 'revealRight';
	const RevealUp = 'revealUp';
	const RevealDown = 'revealDown';

	var AddSlideAwayModes = function (image) {
	    image
	        .addTransitionMode(SlideAwayRight, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var x = currentImage.width * (t);
	                parent.setChildLocalPosition(currentImage, x, 0);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(currentImage, 0, 0);
	            },
	        })
	        .addTransitionMode(SlideAwayLeft, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var x = currentImage.width * (-t);
	                parent.setChildLocalPosition(currentImage, x, 0);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(currentImage, 0, 0);
	            },
	        })
	        .addTransitionMode(SlideAwayDown, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var y = currentImage.height * (t);
	                parent.setChildLocalPosition(currentImage, 0, y);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(currentImage, 0, 0);
	            },
	        })
	        .addTransitionMode(SlideAwayUp, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var y = currentImage.height * (-t);
	                parent.setChildLocalPosition(currentImage, 0, y);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(currentImage, 0, 0);
	            },
	        });

	};

	var AddSlideModes = function (image) {
	    image
	        .addTransitionMode(SlideRight, {
	            ease: 'Linear', dir: 'in', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var x = nextImage.width * (t - 1);
	                parent.setChildLocalPosition(nextImage, x, 0);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(nextImage, 0, 0);
	            },
	        })
	        .addTransitionMode(SlideLeft, {
	            ease: 'Linear', dir: 'in', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var x = nextImage.width * (1 - t);
	                parent.setChildLocalPosition(nextImage, x, 0);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(nextImage, 0, 0);
	            },
	        })
	        .addTransitionMode(SlideDown, {
	            ease: 'Linear', dir: 'in', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var y = nextImage.height * (t - 1);
	                parent.setChildLocalPosition(nextImage, 0, y);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(nextImage, 0, 0);
	            },
	        })
	        .addTransitionMode(SlideUp, {
	            ease: 'Linear', dir: 'in', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var y = nextImage.height * (1 - t);
	                parent.setChildLocalPosition(nextImage, 0, y);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(nextImage, 0, 0);
	            },
	        });
	};

	var AddSliderModes = function (image) {
	    image
	        .addTransitionMode(PushRight, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                // SlideAwayRight
	                var x = currentImage.width * (t);
	                parent.setChildLocalPosition(currentImage, x, 0);

	                // SlideLeft
	                var x = nextImage.width * (t - 1);
	                parent.setChildLocalPosition(nextImage, x, 0);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(currentImage, 0, 0);
	                parent.setChildLocalPosition(nextImage, 0, 0);
	            },
	        })
	        .addTransitionMode(PushLeft, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                // SlideAwayLeft
	                var x = currentImage.width * (-t);
	                parent.setChildLocalPosition(currentImage, x, 0);

	                // SlideRight
	                var x = nextImage.width * (1 - t);
	                parent.setChildLocalPosition(nextImage, x, 0);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(currentImage, 0, 0);
	                parent.setChildLocalPosition(nextImage, 0, 0);
	            },
	        })
	        .addTransitionMode(PushDown, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                // SlideAwayDown
	                var y = currentImage.height * (t);
	                parent.setChildLocalPosition(currentImage, 0, y);

	                // SlideUp
	                var y = nextImage.height * (t - 1);
	                parent.setChildLocalPosition(nextImage, 0, y);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(currentImage, 0, 0);
	                parent.setChildLocalPosition(nextImage, 0, 0);
	            },
	        })
	        .addTransitionMode(PushUp, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                // SlideAwayUp
	                var y = currentImage.height * (-t);
	                parent.setChildLocalPosition(currentImage, 0, y);

	                // SlideDown
	                var y = nextImage.height * (1 - t);
	                parent.setChildLocalPosition(nextImage, 0, y);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalPosition(currentImage, 0, 0);
	                parent.setChildLocalPosition(nextImage, 0, 0);
	            },
	        });

	};

	var AddZoomModes = function (image) {
	    image
	        .addTransitionMode(ZoomOut, {
	            ease: 'Linear', dir: 'out', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var scale = 1 - t;
	                parent.setChildLocalScale(currentImage, scale, scale);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalScale(currentImage, 1, 1);
	            },
	        })
	        .addTransitionMode(ZoomIn, {
	            ease: 'Linear', dir: 'in', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var scale = t;
	                parent.setChildLocalScale(nextImage, scale, scale);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalScale(nextImage, 1, 1);
	            },
	        })
	        .addTransitionMode(ZoomInOut, {
	            ease: 'Linear', dir: 'out', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.tint = 0;  // Turn nextImage to black
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var scale;
	                if (t < 0.5) {
	                    scale = 1 - Yoyo$1(t);
	                    parent.setChildLocalScale(currentImage, scale, scale);
	                } else {
	                    if (currentImage.visible) {
	                        parent.setChildVisible(currentImage, false);
	                    }

	                    scale = 1 - Yoyo$1(t);
	                    parent.setChildLocalScale(nextImage, scale, scale);
	                }
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalScale(currentImage, 1, 1);
	                parent.setChildVisible(currentImage, true);
	                currentImage.tint = 0xffffff;

	                parent.setChildLocalScale(nextImage, 1, 1);
	                parent.setChildVisible(nextImage, true);
	                nextImage.tint = 0xffffff;
	            },
	        });


	};

	var AddFadeModes = function (image) {
	    image
	        .addTransitionMode(Fade$1, {
	            ease: 'Linear', dir: 'out', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.tint = 0;  // Turn nextImage to black
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var tintGray;
	                if (t < 0.5) {
	                    t = Yoyo$1(t);
	                    tintGray = Math.floor(255 * (1 - t));
	                    currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
	                } else {
	                    if (currentImage.visible) {
	                        parent.setChildVisible(currentImage, false);
	                    }

	                    t = Yoyo$1(t);
	                    tintGray = Math.floor(255 * (1 - t));
	                    nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
	                }
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildVisible(currentImage, true);
	                currentImage.tint = 0xffffff;

	                parent.setChildVisible(nextImage, true);
	                nextImage.tint = 0xffffff;
	            },
	        })
	        .addTransitionMode(CrossFade, {
	            ease: 'Linear', dir: 'out', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalAlpha(currentImage, 1 - t);
	                parent.setChildLocalAlpha(nextImage, t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.setChildLocalAlpha(currentImage, 1);
	            },
	        });

	};

	const GetCalcMatrix$1 = Phaser.GameObjects.GetCalcMatrix;

	var WebGLRenderer$2 = function (renderer, src, camera, parentMatrix) {
	    src.updateData();
	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix$1(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;

	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    var shapes = src.geom,
	        shape;
	    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	        shape = shapes[i];
	        if (shape.visible) {
	            shape.webglRender(pipeline, calcMatrix, alpha, dx, dy);
	        }
	    }

	    renderer.pipelines.postBatch(src);
	};

	const SetTransform$1 = Phaser.Renderer.Canvas.SetTransform;

	var CanvasRenderer$2 = function (renderer, src, camera, parentMatrix) {
	    src.updateData();
	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform$1(renderer, ctx, src, camera, parentMatrix)) {
	        var dx = src._displayOriginX;
	        var dy = src._displayOriginY;

	        var shapes = src.geom,
	            shape;
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            shape = shapes[i];
	            if (shape.visible) {
	                shape.canvasRender(ctx, dx, dy);
	            }
	        }

	        //  Restore the context saved in SetTransform
	        ctx.restore();
	    }
	};

	var Render$3 = {
	    renderWebGL: WebGLRenderer$2,
	    renderCanvas: CanvasRenderer$2

	};

	const Shape$1 = Phaser.GameObjects.Shape;
	const RemoveItem$9 = Phaser.Utils.Array.Remove;

	class BaseShapes extends Shape$1 {
	    constructor(scene, x, y, width, height) {
	        if (x === undefined) {
	            x = 0;
	        }
	        if (y === undefined) {
	            y = 0;
	        }
	        if (width === undefined) {
	            width = 2;
	        }
	        if (height === undefined) {
	            height = width;
	        }

	        super(scene, 'rexShapes', []);

	        this._width = -1;
	        this._height = -1;
	        this.dirty = true;
	        this.isSizeChanged = true;
	        this.shapes = {};

	        this.setPosition(x, y);
	        this.setSize(width, height);

	        this.updateDisplayOrigin();
	    }

	    get width() {
	        return this._width;
	    }

	    set width(value) {
	        this.setSize(value, this._height);
	    }

	    get height() {
	        return this._height;
	    }

	    set height(value) {
	        this.setSize(this._width, value);
	    }

	    setDirty(value) {
	        if (value === undefined) {
	            value = true;
	        }
	        this.dirty = value;
	        return this;
	    }

	    setSize(width, height) {
	        this.isSizeChanged = this.isSizeChanged || (this._width !== width) || (this._height !== height);
	        this.dirty = this.dirty || this.isSizeChanged;
	        this._width = width;
	        this._height = height;
	        this.updateDisplayOrigin();
	        var input = this.input;
	        if (input && !input.customHitArea) {
	            input.hitArea.width = width;
	            input.hitArea.height = height;
	        }
	        return this;
	    }

	    resize(width, height) {
	        this.setSize(width, height);
	        return this;
	    }

	    get fillColor() {
	        return this._fillColor;
	    }

	    set fillColor(value) {
	        this.setFillStyle(value, this._fillAlpha);
	    }

	    get fillAlpha() {
	        return this._fillAlpha;
	    }

	    set fillAlpha(value) {
	        this.setFillStyle(this._fillColor, value);
	    }

	    setFillStyle(color, alpha) {
	        if (alpha === undefined) {
	            alpha = 1;
	        }

	        this.dirty = this.dirty ||
	            (this.fillColor !== color) ||
	            (this.fillAlpha !== alpha);

	        this._fillColor = color;
	        this._fillAlpha = alpha;

	        return this;
	    }

	    get lineWidth() {
	        return this._lineWidth;
	    }

	    set lineWidth(value) {
	        this.setStrokeStyle(value, this._strokeColor, this._strokeAlpha);
	    }

	    get strokeColor() {
	        return this._strokeColor;
	    }

	    set strokeColor(value) {
	        this.setStrokeStyle(this._lineWidth, value, this._strokeAlpha);
	    }

	    get strokeAlpha() {
	        return this._strokeAlpha;
	    }

	    set strokeAlpha(value) {
	        this.setStrokeStyle(this._lineWidth, this._strokeColor, value);
	    }

	    setStrokeStyle(lineWidth, color, alpha) {
	        if (alpha === undefined) {
	            alpha = 1;
	        }

	        this.dirty = this.dirty ||
	            (this.lineWidth !== lineWidth) ||
	            (this.strokeColor !== color) ||
	            (this.strokeAlpha !== alpha);

	        this._lineWidth = lineWidth;
	        this._strokeColor = color;
	        this._strokeAlpha = alpha;

	        return this;
	    }

	    updateShapes() {

	    }

	    updateData() {
	        if (!this.dirty) {
	            return this;
	        }

	        this.updateShapes();
	        var shapes = this.geom;
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var shape = shapes[i];
	            if (shape.dirty) {
	                shape.updateData();
	            }
	        }

	        this.isSizeChanged = false;
	        this.dirty = false;


	        return this;
	    }

	    clear() {
	        this.geom.length = 0;
	        Clear(this.shapes);
	        this.dirty = true;
	        return this;
	    }

	    getShape(name) {
	        return this.shapes[name];
	    }

	    getShapes() {
	        return this.geom;
	    }

	    addShape(shape) {
	        this.geom.push(shape);
	        var name = shape.name;
	        if (name) {
	            this.shapes[name] = shape;
	        }
	        this.dirty = true;
	        return this;
	    }

	    deleteShape(name) {
	        var shape = this.getShape(name);
	        if (shape) {
	            delete this.shapes[name];
	            RemoveItem$9(this.geom, shape);
	        }
	        return this;
	    }
	}

	Object.assign(
	    BaseShapes.prototype,
	    Render$3
	);

	var FillStyle = function (color, alpha) {
	    if (color == null) {
	        this.isFilled = false;
	    } else {
	        if (alpha === undefined) {
	            alpha = 1;
	        }
	        this.isFilled = true;
	        this.fillColor = color;
	        this.fillAlpha = alpha;
	    }
	    return this;
	};

	var LineStyle = function (lineWidth, color, alpha) {
	    if ((lineWidth == null) || (color == null)) {
	        this.isStroked = false;
	    } else {
	        if (alpha === undefined) {
	            alpha = 1;
	        }
	        this.isStroked = true;
	        this.lineWidth = lineWidth;
	        this.strokeColor = color;
	        this.strokeAlpha = alpha;
	    }
	    return this;
	};

	var StyleMethods = {
	    fillStyle: FillStyle,
	    lineStyle: LineStyle
	};

	var DataMethods = {
	    enableData() {
	        if (this.data === undefined) {
	            this.data = {};
	        }
	        return this;
	    },

	    setData(key, value) {
	        this.enableData();
	        if (arguments.length === 1) {
	            var data = key;
	            for (key in data) {
	                this.data[key] = data[key];
	            }
	        } else {
	            this.data[key] = value;
	        }
	        return this;
	    },

	    getData(key, defaultValue) {
	        this.enableData();
	        return (key === undefined) ? this.data : GetValue$2b(this.data, key, defaultValue);
	    },

	    incData(key, inc, defaultValue) {
	        if (defaultValue === undefined) {
	            defaultValue = 0;
	        }
	        this.enableData();
	        this.setData(key, this.getData(key, defaultValue) + inc);
	        return this;
	    },

	    mulData(key, mul, defaultValue) {
	        if (defaultValue === undefined) {
	            defaultValue = 0;
	        }
	        this.enableData();
	        this.setData(key, this.getData(key, defaultValue) * mul);
	        return this;
	    },

	    clearData() {
	        if (this.data) {
	            Clear(this.data);
	        }
	        return this;
	    },
	};

	class BaseGeom {
	    constructor() {
	        this.name = undefined;
	        this.dirty = true;
	        this.visible = true;
	        this.data = undefined;

	        this.isFilled = false;
	        this.fillColor = undefined;
	        this.fillAlpha = 1;

	        this.isStroked = false;
	        this.lineWidth = 1;
	        this.strokeColor = undefined;
	        this.strokeAlpha = 1;
	    }

	    setName(name) {
	        this.name = name;
	        return this;
	    }

	    setVisible(visible) {
	        if (visible === undefined) {
	            visible = true;
	        }
	        this.visible = visible;
	        return this;
	    }

	    reset() {
	        this
	            .setVisible()
	            .fillStyle()
	            .lineStyle();

	        return this;
	    }

	    webglRender(pipeline, calcMatrix, alpha, dx, dy) {

	    }

	    canvasRender(ctx, dx, dy) {

	    }

	    updateData() {
	        this.dirty = false;
	    }
	}

	Object.assign(
	    BaseGeom.prototype,
	    StyleMethods,
	    DataMethods
	);

	/*
	src: {
	    fillColor, 
	    fillAlpha, 
	    pathData, 
	    pathIndexes  // Earcut(pathData)
	}
	*/

	var Utils$3 = Phaser.Renderer.WebGL.Utils;

	var FillPathWebGL = function (pipeline, calcMatrix, src, alpha, dx, dy)
	{
	    var fillTintColor = Utils$3.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);

	    var path = src.pathData;
	    var pathIndexes = src.pathIndexes;

	    for (var i = 0; i < pathIndexes.length; i += 3)
	    {
	        var p0 = pathIndexes[i] * 2;
	        var p1 = pathIndexes[i + 1] * 2;
	        var p2 = pathIndexes[i + 2] * 2;

	        var x0 = path[p0 + 0] - dx;
	        var y0 = path[p0 + 1] - dy;
	        var x1 = path[p1 + 0] - dx;
	        var y1 = path[p1 + 1] - dy;
	        var x2 = path[p2 + 0] - dx;
	        var y2 = path[p2 + 1] - dy;

	        var tx0 = calcMatrix.getX(x0, y0);
	        var ty0 = calcMatrix.getY(x0, y0);
	        var tx1 = calcMatrix.getX(x1, y1);
	        var ty1 = calcMatrix.getY(x1, y1);
	        var tx2 = calcMatrix.getX(x2, y2);
	        var ty2 = calcMatrix.getY(x2, y2);

	        pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
	    }
	};

	/*
	src: {
	    strokeColor,
	    strokeAlpha,
	    pathData,
	    lineWidth,
	    closePath
	}
	*/
	var Utils$2 = Phaser.Renderer.WebGL.Utils;

	var StrokePathWebGL = function (pipeline, src, alpha, dx, dy)
	{
	    var strokeTint = pipeline.strokeTint;
	    var strokeTintColor = Utils$2.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);

	    strokeTint.TL = strokeTintColor;
	    strokeTint.TR = strokeTintColor;
	    strokeTint.BL = strokeTintColor;
	    strokeTint.BR = strokeTintColor;

	    var path = src.pathData;
	    var pathLength = path.length - 1;
	    var lineWidth = src.lineWidth;
	    var halfLineWidth = lineWidth / 2;

	    var px1 = path[0] - dx;
	    var py1 = path[1] - dy;

	    if (!src.closePath)
	    {
	        pathLength -= 2;
	    }

	    for (var i = 2; i < pathLength; i += 2)
	    {
	        var px2 = path[i] - dx;
	        var py2 = path[i + 1] - dy;

	        pipeline.batchLine(
	            px1,
	            py1,
	            px2,
	            py2,
	            halfLineWidth,
	            halfLineWidth,
	            lineWidth,
	            i - 2,
	            (src.closePath) ? (i === pathLength - 1) : false
	        );

	        px1 = px2;
	        py1 = py2;
	    }
	};

	var FillStyleCanvas = function (ctx, src, altColor, altAlpha)
	{
	    var fillColor = (altColor) ? altColor : src.fillColor;
	    var fillAlpha = (altAlpha) ? altAlpha : src.fillAlpha;

	    var red = ((fillColor & 0xFF0000) >>> 16);
	    var green = ((fillColor & 0xFF00) >>> 8);
	    var blue = (fillColor & 0xFF);

	    ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
	};

	var LineStyleCanvas = function (ctx, src, altColor, altAlpha)
	{
	    var strokeColor = (altColor) ? altColor : src.strokeColor;
	    var strokeAlpha = (altAlpha) ? altAlpha : src.strokeAlpha;

	    var red = ((strokeColor & 0xFF0000) >>> 16);
	    var green = ((strokeColor & 0xFF00) >>> 8);
	    var blue = (strokeColor & 0xFF);

	    ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';
	    ctx.lineWidth = src.lineWidth;
	};

	const Earcut$1 = Phaser.Geom.Polygon.Earcut;

	class PathBase extends BaseGeom {
	    constructor() {
	        super();

	        this.pathData = [];
	        this.pathIndexes = [];
	        this.closePath = false;
	    }

	    updateData() {
	        this.pathIndexes = Earcut$1(this.pathData);

	        super.updateData();
	        return this;
	    }

	    webglRender(pipeline, calcMatrix, alpha, dx, dy) {
	        if (this.isFilled) {
	            FillPathWebGL(pipeline, calcMatrix, this, alpha, dx, dy);
	        }

	        if (this.isStroked) {
	            StrokePathWebGL(pipeline, this, alpha, dx, dy);
	        }
	    }

	    canvasRender(ctx, dx, dy) {
	        var path = this.pathData;
	        var pathLength = path.length - 1;

	        var px1 = path[0] - dx;
	        var py1 = path[1] - dy;

	        ctx.beginPath();

	        ctx.moveTo(px1, py1);

	        if (!this.closePath) {
	            pathLength -= 2;
	        }

	        for (var i = 2; i < pathLength; i += 2) {
	            var px2 = path[i] - dx;
	            var py2 = path[i + 1] - dy;
	            ctx.lineTo(px2, py2);
	        }

	        if (this.closePath) {
	            ctx.closePath();
	        }


	        if (this.isFilled) {
	            FillStyleCanvas(ctx, this);
	            ctx.fill();
	        }

	        if (this.isStroked) {
	            LineStyleCanvas(ctx, this);
	            ctx.stroke();
	        }
	    }
	}

	var LineTo = function (x, y, pathData) {
	    var cnt = pathData.length;
	    if (cnt >= 2) {
	        var lastX = pathData[cnt - 2];
	        var lastY = pathData[cnt - 1];
	        if ((x === lastX) && (y === lastY)) {
	            return pathData;
	        }
	    }

	    pathData.push(x, y);
	    return pathData;
	};

	const DegToRad$7 = Phaser.Math.DegToRad;

	var ArcTo$1 = function (centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, pathData) {
	    // startAngle, endAngle: 0 ~ 360
	    if (antiClockWise && (endAngle > startAngle)) {
	        endAngle -= 360;
	    } else if (!antiClockWise && (endAngle < startAngle)) {
	        endAngle += 360;
	    }

	    var deltaAngle = endAngle - startAngle;
	    var step = DegToRad$7(deltaAngle) / iteration;
	    startAngle = DegToRad$7(startAngle);
	    for (var i = 0; i <= iteration; i++) {
	        var angle = startAngle + (step * i);
	        var x = centerX + (radiusX * Math.cos(angle));
	        var y = centerY + (radiusY * Math.sin(angle));
	        LineTo(x, y, pathData);
	    }
	    return pathData;
	};

	const DegToRad$6 = Phaser.Math.DegToRad;

	class Arc extends PathBase {
	    constructor(x, y, radiusX, radiusY, startAngle, endAngle, anticlockwise, pie) {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (radiusX === undefined) { radiusX = 0; }
	        if (radiusY === undefined) { radiusY = 0; }
	        if (startAngle === undefined) { startAngle = 0; }
	        if (endAngle === undefined) { endAngle = 360; }
	        if (anticlockwise === undefined) { anticlockwise = false; }
	        if (pie === undefined) { pie = false; }

	        super();

	        this.setCenterPosition(x, y);
	        this.setRadius(radiusX, radiusY);
	        this.setAngle(startAngle, endAngle, anticlockwise);
	        this.setPie(pie);
	        this.setIterations(32);
	    }

	    get x() {
	        return this._x;
	    }

	    set x(value) {
	        this.dirty = this.dirty || (this._x !== value);
	        this._x = value;
	    }

	    get y() {
	        return this._y;
	    }

	    set y(value) {
	        this.dirty = this.dirty || (this._y !== value);
	        this._y = value;
	    }

	    setCenterPosition(x, y) {
	        if (y === undefined) {
	            y = x;
	        }
	        this.x = x;
	        this.y = y;
	        return this;
	    }

	    get radiusX() {
	        return this._radiusX;
	    }

	    set radiusX(value) {
	        this.dirty = this.dirty || (this._radiusX !== value);
	        this._radiusX = value;
	    }

	    get radiusY() {
	        return this._radiusY;
	    }

	    set radiusY(value) {
	        this.dirty = this.dirty || (this._radiusY !== value);
	        this._radiusY = value;
	    }

	    setRadius(radiusX, radiusY) {
	        if (radiusY === undefined) {
	            radiusY = radiusX;
	        }
	        this.radiusX = radiusX;
	        this.radiusY = radiusY;
	        return this;
	    }

	    get startAngle() {
	        return this._startAngle;
	    }

	    set startAngle(value) {
	        this.dirty = this.dirty || (this._startAngle !== value);
	        this._startAngle = value;
	    }

	    get endAngle() {
	        return this._endAngle;
	    }

	    set endAngle(value) {
	        this.dirty = this.dirty || (this._endAngle !== value);
	        this._endAngle = value;
	    }

	    get anticlockwise() {
	        return this._anticlockwise;
	    }

	    set anticlockwise(value) {
	        this.dirty = this.dirty || (this._anticlockwise !== value);
	        this._anticlockwise = value;
	    }

	    setAngle(startAngle, endAngle, anticlockwise) {
	        // startAngle, endAngle in degrees
	        if (anticlockwise === undefined) {
	            anticlockwise = false;
	        }

	        this.startAngle = startAngle;
	        this.endAngle = endAngle;
	        this.anticlockwise = anticlockwise;
	        return this;
	    }

	    get pie() {
	        return this._pie;
	    }

	    set pie(value) {
	        this.dirty = this.dirty || (this._pie !== value);
	        this._pie = value;
	    }

	    setPie(pie) {
	        if (pie === undefined) {
	            pie = true;
	        }
	        this.pie = pie;
	        return this;
	    }

	    get iterations() {
	        return this._iterations;
	    }

	    set iterations(value) {
	        this.dirty = this.dirty || (this._iterations !== value);
	        this._iterations = value;
	    }

	    setIterations(iterations) {
	        this.iterations = iterations;
	        return this;
	    }

	    updateData() {
	        this.pathData.length = 0;
	        if (this.pie) {
	            this.pathData.push(this.x, this.y);
	        }
	        ArcTo$1(
	            this.x, this.y,
	            this.radiusX, this.radiusY,
	            this.startAngle, this.endAngle, this.anticlockwise,
	            this.iterations,
	            this.pathData
	        );
	        if (this.pie) {
	            this.pathData.push(this.x, this.y);
	        }
	        // Close
	        this.pathData.push(this.pathData[0], this.pathData[1]);

	        super.updateData();
	        return this;
	    }

	    canvasRender(ctx, dx, dy) {
	        ctx.beginPath();
	        var x = this.x - dx,
	            y = this.y - dy,
	            startAngle = DegToRad$6(this.startAngle),
	            endAngle = DegToRad$6(this.endAngle);
	        if (this.pie) {
	            ctx.moveTo(x, y);
	            ctx.lineTo(
	                x + Math.cos(startAngle) * this.radiusX,
	                y + Math.sin(startAngle) * this.radiusY
	            );
	        }
	        ctx.ellipse(
	            x, y,
	            this.radiusX, this.radiusY,
	            0,
	            startAngle, endAngle, this.anticlockwise
	        );
	        if (this.pie) {
	            ctx.lineTo(x, y);
	        }
	        if (this.isFilled) {
	            FillStyleCanvas(ctx, this);
	            ctx.fill();
	        }
	        if (this.isStroked) {
	            LineStyleCanvas(ctx, this);
	            ctx.stroke();
	        }
	    }
	}

	class Circle extends Arc {
	    constructor(x, y, radius) {
	        super(x, y, radius, radius, 0, 360);
	    }
	}

	class Curve extends PathBase {
	    constructor(curve) {
	        super();
	        this.setCurve(curve);
	        this.setIterations(32);
	    }

	    get curve() {
	        return this._curve;
	    }

	    set curve(value) {
	        this.dirty = this.dirty || (this._curve !== value);
	        this._curve = value;
	    }

	    setCurve(curve) {
	        this.curve = curve;
	        return this;
	    }

	    get iterations() {
	        return this._iterations;
	    }

	    set iterations(value) {
	        this.dirty = this.dirty || (this._iterations !== value);
	        this._iterations = value;
	    }

	    setIterations(iterations) {
	        this.iterations = iterations;
	        return this;
	    }

	    updateData() {
	        this.pathData.length = 0;
	        var points = this.curve.getPoints(this.iterations);
	        for (var i = 0, cnt = points.length; i < cnt; i++) {
	            this.pathData.push(points[i].x, points[i].y);
	        }
	        this.pathData.push(points[0].x, points[0].y);

	        super.updateData();
	        return this;
	    }

	}

	class Ellipse extends Arc {
	    constructor(x, y, radiusX, radiusY) {
	        super(x, y, radiusX, radiusY, 0, 360);
	    }
	}

	class Line extends PathBase {
	    constructor(x0, y0, x1, y1) {
	        if (x0 === undefined) { x0 = 0; }
	        if (y0 === undefined) { y0 = 0; }
	        if (x1 === undefined) { x1 = 0; }
	        if (y1 === undefined) { y1 = 0; }

	        super();

	        this.setP0(x0, y0);
	        this.setP1(x1, y1);
	    }

	    get x0() {
	        return this._x0;
	    }

	    set x0(value) {
	        this.dirty = this.dirty || (this._x0 !== value);
	        this._x0 = value;
	    }

	    get y0() {
	        return this._y0;
	    }

	    set y0(value) {
	        this.dirty = this.dirty || (this._y0 !== value);
	        this._y0 = value;
	    }

	    setP0(x, y) {
	        this.x0 = x;
	        this.y0 = y;
	        return this;
	    }

	    get x1() {
	        return this._x1;
	    }

	    set x1(value) {
	        this.dirty = this.dirty || (this._x1 !== value);
	        this._x1 = value;
	    }

	    get y1() {
	        return this._y1;
	    }

	    set y1(value) {
	        this.dirty = this.dirty || (this._y1 !== value);
	        this._y1 = value;
	    }

	    setP1(x, y) {
	        this.x1 = x;
	        this.y1 = y;
	        return this;
	    }

	    updateData() {
	        this.pathData.length = 0;
	        this.pathData.push(this.x0, this.y0);
	        this.pathData.push(this.x1, this.y1);
	        this.pathData.push(this.x0, this.y0);

	        super.updateData();
	        return this;
	    }
	}

	var StartAt = function (x, y, pathData) {
	    pathData.length = 0;

	    if (x != null) {
	        pathData.push(x, y);
	    }

	    return pathData;
	};

	//import QuadraticBezierInterpolation from '../../utils/math/interpolation/QuadraticBezierInterpolation.js';

	const QuadraticBezierInterpolation = Phaser.Math.Interpolation.QuadraticBezier;

	var QuadraticBezierTo = function (cx, cy, x, y, iterations, pathData) {
	    var pathDataCnt = pathData.length;
	    var p0x = pathData[pathDataCnt - 2];
	    var p0y = pathData[pathDataCnt - 1];
	    for (var i = 1, last = iterations - 1; i <= last; i++) {
	        var t = i / last;
	        pathData.push(
	            QuadraticBezierInterpolation(t, p0x, cx, x),
	            QuadraticBezierInterpolation(t, p0y, cy, y)
	        );
	    }
	    return pathData;
	};

	// import CubicBezierInterpolation from '../../utils/math/interpolation/CubicBezierInterpolation.js';

	const CubicBezierInterpolation = Phaser.Math.Interpolation.CubicBezier;

	var CubicBezierCurveTo = function (cx0, cy0, cx1, cy1, x, y, iterations, pathData) {
	    var pathDataCnt = pathData.length;
	    var p0x = pathData[pathDataCnt - 2];
	    var p0y = pathData[pathDataCnt - 1];
	    for (var i = 1, last = iterations - 1; i <= last; i++) {
	        var t = i / last;
	        pathData.push(
	            CubicBezierInterpolation(t, p0x, cx0, cx1, x),
	            CubicBezierInterpolation(t, p0y, cy0, cy1, y)
	        );
	    }
	    return pathData;
	};

	//import CatmullRomInterpolation from '../../utils/math/interpolation/CatmullRomInterpolation.js';

	const CatmullRomInterpolation = Phaser.Math.Interpolation.CatmullRom;

	var CatmullRomTo = function (points, iterations, pathData) {
	    var pathDataCnt = pathData.length;
	    var p0x = pathData[pathDataCnt - 2];
	    var p0y = pathData[pathDataCnt - 1];

	    var xList = [p0x];
	    var yList = [p0y];
	    for (var i = 0, cnt = points.length; i < cnt; i += 2) {
	        xList.push(points[i]);
	        yList.push(points[i + 1]);
	    }

	    for (var i = 1, last = iterations - 1; i <= last; i++) {
	        var t = i / last;
	        pathData.push(
	            CatmullRomInterpolation(xList, t),
	            CatmullRomInterpolation(yList, t)
	        );
	    }
	    return pathData;
	};

	var DuplicateLast = function (pathData) {
	    var len = pathData.length;
	    if (len < 2) {
	        return pathData;
	    }

	    var lastX = pathData[len - 2];
	    var lastY = pathData[len - 1];
	    pathData.push(lastX);
	    pathData.push(lastY);

	    return pathData;
	};

	var AddPathMethods = {
	    clear() {
	        this.start();
	        return this;
	    },

	    start() {
	        this.startAt();
	        return this;
	    },

	    startAt(x, y) {
	        this.restorePathData();
	        this.accumulationLengths = undefined;

	        StartAt(x, y, this.pathData);
	        this.firstPointX = x;
	        this.firstPointY = y;
	        this.lastPointX = x;
	        this.lastPointY = y;

	        return this;
	    },

	    lineTo(x, y, relative) {
	        if (relative === undefined) {
	            relative = false;
	        }
	        if (relative) {
	            x += this.lastPointX;
	            y += this.lastPointY;
	        }

	        LineTo(x, y, this.pathData);

	        this.lastPointX = x;
	        this.lastPointY = y;
	        return this;
	    },

	    verticalLineTo(x, relative) {
	        this.lineTo(x, this.lastPointY, relative);
	        return this;
	    },

	    horizontalLineTo(y, relative) {
	        this.lineTo(this.lastPointX, y, relative);
	        return this;
	    },

	    ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
	        if (anticlockwise === undefined) {
	            anticlockwise = false;
	        }

	        ArcTo$1(
	            centerX, centerY,
	            radiusX, radiusY,
	            startAngle, endAngle, anticlockwise,
	            this.iterations,
	            this.pathData
	        );

	        this.lastPointX = this.pathData[this.pathData.length - 2];
	        this.lastPointY = this.pathData[this.pathData.length - 1];
	        return this;
	    },

	    arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
	        this.ellipticalArc(centerX, centerY, radius, radius, startAngle, endAngle, anticlockwise);
	        return this;
	    },

	    quadraticBezierTo(cx, cy, x, y) {
	        QuadraticBezierTo(
	            cx, cy, x, y,
	            this.iterations,
	            this.pathData
	        );

	        this.lastPointX = x;
	        this.lastPointY = y;
	        return this;
	    },

	    cubicBezierTo(cx0, cy0, cx1, cy1, x, y) {
	        CubicBezierCurveTo(
	            cx0, cy0, cx1, cy1, x, y,
	            this.iterations,
	            this.pathData
	        );

	        this.lastPointX = x;
	        this.lastPointY = y;
	        return this;
	    },

	    catmullRomTo(...points) {
	        CatmullRomTo(
	            points,
	            this.iterations,
	            this.pathData
	        );

	        this.lastPointX = points[points.length-2];
	        this.lastPointY = points[points.length-1];
	        return this;
	    },

	    close() {
	        // Line to first point        
	        var startX = this.pathData[0],
	            startY = this.pathData[1];
	        if ((startX !== this.lastPointX) || (startY !== this.lastPointY)) {
	            this.lineTo(startX, startY);
	        }

	        this.closePath = true;
	        return this;
	    },

	    end() {
	        DuplicateLast(this.pathData);
	        return this;
	    },

	};

	//import PointRotateAround from '../../utils/math/RotateAround.js';

	const PointRotateAround = Phaser.Math.RotateAround;

	var RotateAround$3 = function (centerX, centerY, angle, pathData) {
	    var point = { x: 0, y: 0 };
	    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
	        point.x = pathData[i];
	        point.y = pathData[i + 1];
	        PointRotateAround(point, centerX, centerY, angle);
	        pathData[i] = point.x;
	        pathData[i + 1] = point.y;
	    }
	    return pathData;
	};

	var Scale$1 = function (centerX, centerY, scaleX, scaleY, pathData) {
	    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
	        var x = pathData[i] - centerX;
	        var y = pathData[i + 1] - centerY;
	        x *= scaleX;
	        y *= scaleY;
	        pathData[i] = x + centerX;
	        pathData[i + 1] = y + centerY;
	    }
	    return pathData;
	};

	var Offset = function (x, y, pathData) {
	    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
	        pathData[i] += x;
	        pathData[i + 1] += y;
	    }
	    return pathData;
	};

	const DegToRad$5 = Phaser.Math.DegToRad;
	Phaser.Math.RotateAround;

	var TransformPointsMethods = {
	    rotateAround(centerX, centerY, angle) {
	        if (this.pathData.length === 0) {
	            return this;
	        }

	        angle = DegToRad$5(angle);

	        RotateAround$3(centerX, centerY, angle, this.pathData);

	        var pathDataCnt = this.pathData.length;
	        this.lastPointX = this.pathData[pathDataCnt - 2];
	        this.lastPointY = this.pathData[pathDataCnt - 1];
	        return this;
	    },

	    scale(centerX, centerY, scaleX, scaleY) {
	        if (this.pathData.length === 0) {
	            return this;
	        }

	        Scale$1(centerX, centerY, scaleX, scaleY, this.pathData);
	        this.lastPointX = this.pathData[pathDataCnt - 2];
	        this.lastPointY = this.pathData[pathDataCnt - 1];
	        return this;
	    },

	    offset(x, y) {
	        Offset(x, y, this.pathData);
	        return this;
	    }

	};

	var Copy = function (dest, src, startIdx, endIdx) {
	    if (startIdx === undefined) {
	        startIdx = 0;
	    }    if (endIdx === undefined) {
	        endIdx = src.length;
	    }
	    dest.length = endIdx - startIdx;
	    for (var i = 0, len = dest.length; i < len; i++) {
	        dest[i] = src[i + startIdx];
	    }
	    return dest;
	};

	var SavePathDataMethods = {
	    savePathData() {
	        if (this.pathDataSaved) {
	            return this;
	        }

	        this.pathDataSave = [...this.pathData];
	        this.pathData.length = 0;
	        this.pathDataSaved = true;
	        return this;
	    },

	    restorePathData() {
	        if (!this.pathDataSaved) {
	            return this;
	        }

	        Copy(this.pathData, this.pathDataSave);
	        this.pathDataSave = undefined;
	        this.pathDataSaved = false;
	        return this;
	    },
	};

	const DistanceBetween$6 = Phaser.Math.Distance.Between;
	const Wrap$1 = Phaser.Math.Wrap;
	const Linear$g = Phaser.Math.Linear;

	var AppendFromPathSegment = function (srcPathData, accumulationLengths, startT, endT, destPathData) {
	    if (endT === undefined) {
	        endT = startT;
	        startT = 0;
	    }

	    startT = WrapT(startT);
	    endT = WrapT(endT);

	    if (startT === endT) {
	        return;
	    }

	    var totalPathLength = accumulationLengths[accumulationLengths.length - 1];
	    var startL = totalPathLength * startT;
	    var endL = totalPathLength * endT;
	    if (startT < endT) {
	        AddPathSegment(srcPathData, accumulationLengths, startL, endL, destPathData);
	    } else {
	        AddPathSegment(srcPathData, accumulationLengths, startL, totalPathLength, destPathData);
	        AddPathSegment(srcPathData, accumulationLengths, 0, endL, destPathData);
	    }

	    DuplicateLast(destPathData);
	};

	var AddPathSegment = function (srcPathData, accumulationLengths, startL, endL, destPathData) {
	    var skipState = (startL > 0);
	    for (var i = 0, cnt = accumulationLengths.length; i < cnt; i++) {
	        var pIdx = i * 2;
	        var d = accumulationLengths[i];

	        if (skipState) {
	            if (d < startL) {
	                continue;
	            } else if (d == startL) {
	                skipState = false;
	            } else { // d > startL
	                var deltaD = d - accumulationLengths[i - 1];
	                var t = 1 - ((d - startL) / deltaD);
	                destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
	                destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
	                skipState = false;
	            }
	        }

	        if (d <= endL) {
	            destPathData.push(srcPathData[pIdx]);
	            destPathData.push(srcPathData[pIdx + 1]);
	            if (d === endL) {
	                break;
	            }
	        } else { // d > endL
	            var deltaD = d - accumulationLengths[i - 1];
	            var t = 1 - ((d - endL) / deltaD);
	            destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
	            destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
	            break;
	        }
	    }
	};

	var GetInterpolation = function (pathData, i0, i1, t) {
	    var p0 = pathData[i0], p1 = pathData[i1];
	    return Linear$g(p0, p1, t);
	};

	var WrapT = function (t) {
	    if (t === 0) {
	        return 0;
	    } else if ((t % 1) === 0) {
	        return 1;
	    }
	    return Wrap$1(t, 0, 1);
	};

	var PathSegmentMethods = {
	    updateAccumulationLengths() {
	        if (this.accumulationLengths == null) {
	            this.accumulationLengths = [];
	        } else if (this.accumulationLengths.length === (this.pathData.length / 2)) {
	            return this;
	        }

	        var accumulationLengths = this.accumulationLengths;
	        var pathData = this.pathData;
	        var prevX, prevY, x, y;
	        var d, accumulationLength = 0;
	        for (var i = 0, cnt = pathData.length; i < cnt; i += 2) {
	            x = pathData[i];
	            y = pathData[i + 1];

	            d = (prevX === undefined) ? 0 : DistanceBetween$6(prevX, prevY, x, y);
	            accumulationLength += d;
	            accumulationLengths.push(accumulationLength);

	            prevX = x;
	            prevY = y;
	        }

	        this.totalPathLength = accumulationLength;

	        return this;
	    },

	    setDisplayPathSegment(startT, endT) {
	        if (!this.pathDataSaved) {
	            this.updateAccumulationLengths();
	            this.savePathData();
	        }

	        this.pathData.length = 0;
	        AppendFromPathSegment(this.pathDataSave, this.accumulationLengths, startT, endT, this.pathData);

	        return this;
	    },

	    appendFromPathSegment(src, startT, endT) {
	        if (startT === undefined) {
	            this.pathData.push(...src.pathData);
	        } else {
	            src.updateAccumulationLengths();
	            AppendFromPathSegment(src.pathData, src.accumulationLengths, startT, endT, this.pathData);
	        }

	        this.firstPointX = this.pathData[0];
	        this.firstPointY = this.pathData[1];
	        this.lastPointX = this.pathData[this.pathData.length - 2];
	        this.lastPointY = this.pathData[this.pathData.length - 1];
	        return this;
	    },
	};

	var GraphicsMethods = {
	    draw(graphics, isFill, isStroke) {
	        var points = this.toPoints();
	        if (isFill) {
	            graphics.fillPoints(points, this.closePath, this.closePath);
	        }
	        if (isStroke) {
	            graphics.strokePoints(points, this.closePath, this.closePath);
	        }

	        return this;
	    }
	};

	var ToPoints = function (pathData, points) {
	    if (points === undefined) {
	        points = [];
	    }
	    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
	        points.push({
	            x: pathData[i],
	            y: pathData[i + 1]
	        });
	    }
	    return points;
	};

	//import Polygon from '../../utils/geom/polygon/Polygon.js';

	const Polygon = Phaser.Geom.Polygon;

	var ToPolygon = function (pathData, polygon) {
	    if (polygon === undefined) {
	        polygon = new Polygon();
	    }
	    polygon.setTo(pathData);
	    return polygon;
	};

	class PathDataBuilder {
	    constructor(pathData) {
	        if (pathData === undefined) {
	            pathData = [];
	        }

	        this.pathData = pathData;
	        this.closePath = false;
	        this.setIterations(32);

	        this.firstPointX = undefined;
	        this.firstPointY = undefined;
	        this.lastPointX = undefined;
	        this.lastPointY = undefined;
	        this.accumulationLengths = undefined;
	    }

	    setIterations(iterations) {
	        this.iterations = iterations;
	        return this;
	    }

	    toPoints() {
	        return ToPoints(this.pathData);
	    }

	    toPolygon(polygon) {
	        return ToPolygon(this.pathData, polygon);
	    }

	}

	Object.assign(
	    PathDataBuilder.prototype,
	    AddPathMethods,
	    TransformPointsMethods,
	    SavePathDataMethods,
	    PathSegmentMethods,
	    GraphicsMethods,
	);

	class Lines extends PathBase {
	    constructor() {
	        super();
	        this.builder = new PathDataBuilder(this.pathData);
	    }

	    get iterations() {
	        return this.builder.iterations;
	    }

	    set iterations(value) {
	        this.dirty = this.dirty || (this.builder.iterations !== value);
	        this.builder.setIterations(value);
	    }

	    setIterations(iterations) {
	        this.iterations = iterations;
	        return this;
	    }

	    get lastPointX() {
	        return this.builder.lastPointX;
	    }

	    get lastPointY() {
	        return this.builder.lastPointY;
	    }

	    start() {
	        this.builder.start();

	        this.dirty = true;
	        return this;
	    }

	    startAt(x, y) {
	        this.builder.startAt(x, y);

	        this.dirty = true;
	        return this;
	    }

	    lineTo(x, y, relative) {
	        this.builder.lineTo(x, y, relative);

	        this.dirty = true;
	        return this;
	    }

	    verticalLineTo(x, relative) {
	        this.builder.verticalLineTo(x, relative);

	        this.dirty = true;
	        return this;
	    }

	    horizontalLineTo(y, relative) {
	        this.builder.horizontalLineTo(y, relative);

	        this.dirty = true;
	        return this;
	    }

	    ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
	        this.builder.ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise);

	        this.dirty = true;
	        return this;
	    }

	    arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
	        this.builder.arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise);

	        this.dirty = true;
	        return this;
	    }

	    quadraticBezierTo(cx, cy, x, y) {
	        this.builder.quadraticBezierTo(cx, cy, x, y);

	        this.dirty = true;
	        return this;
	    }

	    cubicBezierTo(cx0, cy0, cx1, cy1, x, y) {
	        this.builder.cubicBezierTo(cx0, cy0, cx1, cy1, x, y);

	        this.dirty = true;
	        return this;
	    }

	    catmullRomTo(...points) {
	        this.builder.catmullRomTo(...points);

	        this.dirty = true;
	        return this;
	    }

	    close() {
	        this.builder.close();

	        this.closePath = this.builder.closePath;
	        this.dirty = true;
	        return this;
	    }

	    end() {
	        this.builder.end();
	        this.dirty = true;
	        return this;
	    }

	    rotateAround(centerX, centerY, angle) {
	        this.builder.rotateAround(centerX, centerY, angle);

	        this.dirty = true;
	        return this;
	    }

	    scale(centerX, centerY, scaleX, scaleY) {
	        this.builder.scale(centerX, centerY, scaleX, scaleY);

	        this.dirty = true;
	        return this;
	    }

	    offset(x, y) {
	        this.builder.offset(x, y);

	        this.dirty = true;
	        return this;
	    }

	    toPolygon(polygon) {
	        return this.builder.toPolygon(polygon);
	    }

	    appendPathFrom(src, startT, endT) {
	        this.builder.appendFromPathSegment(src.builder, startT, endT);
	        return this;
	    }

	    copyPathFrom(src, startT, endT) {
	        this.builder.clear().appendFromPathSegment(src.builder, startT, endT);
	        return this;
	    }

	    setDisplayPathSegment(startT, endT) {
	        this.builder.setDisplayPathSegment(startT, endT);
	        return this;
	    }
	}

	const GetTint$1 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;

	let Rectangle$3 = class Rectangle extends BaseGeom {
	    constructor(x, y, width, height) {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = width; }

	        super();

	        this.pathData = [];
	        this.closePath = true;

	        this.setTopLeftPosition(x, y);
	        this.setSize(width, height);
	    }

	    get x() {
	        return this._x;
	    }

	    set x(value) {
	        this.dirty = this.dirty || (this._x !== value);
	        this._x = value;
	    }

	    get y() {
	        return this._y;
	    }

	    set y(value) {
	        this.dirty = this.dirty || (this._y !== value);
	        this._y = value;
	    }

	    setTopLeftPosition(x, y) {
	        this.x = x;
	        this.y = y;
	        return this;
	    }

	    get width() {
	        return this._width;
	    }

	    set width(value) {
	        this.dirty = this.dirty || (this._width !== value);
	        this._width = value;
	    }

	    get height() {
	        return this._height;
	    }

	    set height(value) {
	        this.dirty = this.dirty || (this._height !== value);
	        this._height = value;
	    }

	    setSize(width, height) {
	        this.width = width;
	        this.height = height;
	        return this;
	    }

	    get centerX() {
	        return this.x + (this.width / 2);
	    }

	    set centerX(value) {
	        this.x = value - (this.width / 2);
	    }

	    get centerY() {
	        return this.y + (this.height / 2);
	    }

	    set centerY(value) {
	        this.y = value - (this.height / 2);
	    }

	    setCenterPosition(x, y) {
	        this.centerX = x;
	        this.centerY = y;
	        return this;
	    }

	    updateData() {
	        this.pathData.length = 0;
	        var x0 = this.x,
	            x1 = x0 + this.width,
	            y0 = this.y,
	            y1 = y0 + this.height;
	        this.pathData.push(x0, y0);
	        this.pathData.push(x1, y0);
	        this.pathData.push(x1, y1);
	        this.pathData.push(x0, y1);
	        this.pathData.push(x0, y0);

	        super.updateData();
	        return this;
	    }

	    webglRender(pipeline, calcMatrix, alpha, dx, dy) {
	        if (this.isFilled) {
	            var fillTint = pipeline.fillTint;
	            var fillTintColor = GetTint$1(this.fillColor, this.fillAlpha * alpha);

	            fillTint.TL = fillTintColor;
	            fillTint.TR = fillTintColor;
	            fillTint.BL = fillTintColor;
	            fillTint.BR = fillTintColor;

	            pipeline.batchFillRect(-dx + this.x, -dy + this.y, this.width, this.height);
	        }

	        if (this.isStroked) {
	            StrokePathWebGL(pipeline, this, alpha, dx, dy);
	        }
	    }

	    canvasRender(ctx, dx, dy) {
	        if (this.isFilled) {
	            FillStyleCanvas(ctx, this);
	            ctx.fillRect(-dx, -dy, this.width, this.height);
	        }

	        if (this.isStroked) {
	            LineStyleCanvas(ctx, this);
	            ctx.beginPath();
	            ctx.rect(-dx, -dy, this.width, this.height);
	            ctx.stroke();
	        }
	    }
	};

	const GetValue$1N = Phaser.Utils.Objects.GetValue;

	let RoundRectangle$2 = class RoundRectangle extends PathBase {
	    constructor(x, y, width, height, radius, iterations) {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = width; }
	        if (radius === undefined) { radius = 0; }
	        if (iterations === undefined) { iterations = 6; }

	        super();

	        this.setTopLeftPosition(x, y);
	        this.setSize(width, height);
	        this.setRadius(radius);
	        this.setIterations(iterations);
	        this.closePath = true;
	    }

	    get x() {
	        return this._x;
	    }

	    set x(value) {
	        this.dirty = this.dirty || (this._x !== value);
	        this._x = value;
	    }

	    get y() {
	        return this._y;
	    }

	    set y(value) {
	        this.dirty = this.dirty || (this._y !== value);
	        this._y = value;
	    }

	    setTopLeftPosition(x, y) {
	        this.x = x;
	        this.y = y;
	        return this;
	    }

	    get width() {
	        return this._width;
	    }

	    set width(value) {
	        this.dirty = this.dirty || (this._width !== value);
	        this._width = value;
	    }

	    get height() {
	        return this._height;
	    }

	    set height(value) {
	        this.dirty = this.dirty || (this._height !== value);
	        this._height = value;
	    }

	    setSize(width, height) {
	        this.width = width;
	        this.height = height;
	        return this;
	    }

	    get centerX() {
	        return this.x + (this.width / 2);
	    }

	    set centerX(value) {
	        this.x = value - (this.width / 2);
	    }

	    get centerY() {
	        return this.y + (this.height / 2);
	    }

	    set centerY(value) {
	        this.y = value - (this.height / 2);
	    }

	    setCenterPosition(x, y) {
	        this.centerX = x;
	        this.centerY = y;
	        return this;
	    }

	    get radiusTL() {
	        return this._radiusTL;
	    }

	    set radiusTL(value) {
	        var isConvex = (value > 0);
	        this.dirty = this.dirty || (this._radiusTL !== value) || (this._convexTL !== isConvex);
	        this._convexTL = isConvex;
	        this._radiusTL = Math.abs(value);

	    }

	    get radiusTR() {
	        return this._radiusTR;
	    }

	    set radiusTR(value) {
	        var isConvex = (value > 0);
	        this.dirty = this.dirty || (this._radiusTR !== value) || (this._convexTR !== isConvex);
	        this._convexTR = isConvex;
	        this._radiusTR = Math.abs(value);
	    }

	    get radiusBL() {
	        return this._radiusBL;
	    }

	    set radiusBL(value) {
	        var isConvex = (value > 0);
	        this.dirty = this.dirty || (this._radiusBL !== value) || (this._convexBL !== isConvex);
	        this._convexBL = isConvex;
	        this._radiusBL = Math.abs(value);
	    }

	    get radiusBR() {
	        return this._radiusBR;
	    }

	    set radiusBR(value) {
	        var isConvex = (value > 0);
	        this.dirty = this.dirty || (this._radiusBR !== value) || (this._convexBR !== isConvex);
	        this._convexBR = isConvex;
	        this._radiusBR = Math.abs(value);
	    }

	    get radius() {
	        return Math.max(this.radiusTL, this.radiusTR, this.radiusBL, this.radiusBR,);
	    }

	    set radius(value) {
	        if (typeof (value) === 'number') {
	            this.radiusTL = value;
	            this.radiusTR = value;
	            this.radiusBL = value;
	            this.radiusBR = value;
	        } else {
	            this.radiusTL = GetValue$1N(value, 'tl', 0);
	            this.radiusTR = GetValue$1N(value, 'tr', 0);
	            this.radiusBL = GetValue$1N(value, 'bl', 0);
	            this.radiusBR = GetValue$1N(value, 'br', 0);
	        }
	    }

	    setRadius(radius) {
	        if (radius === undefined) {
	            radius = 0;
	        }
	        this.radius = radius;
	        return this;
	    }

	    get iterations() {
	        return this._iterations;
	    }

	    set iterations(value) {
	        this.dirty = this.dirty || (this._iterations !== value);
	        this._iterations = value;
	    }

	    setIterations(iterations) {
	        this.iterations = iterations;
	        return this;
	    }

	    updateData() {
	        var pathData = this.pathData;
	        pathData.length = 0;

	        var width = this.width, height = this.height,
	            radius,
	            iterations = this.iterations + 1;

	        // top-left
	        radius = this.radiusTL;
	        if (radius > 0) {
	            if (this._convexTL) {
	                var centerX = radius;
	                var centerY = radius;
	                ArcTo$1(centerX, centerY, radius, radius, 180, 270, false, iterations, pathData);
	            } else {
	                var centerX = 0;
	                var centerY = 0;
	                ArcTo$1(centerX, centerY, radius, radius, 90, 0, true, iterations, pathData);
	            }
	        } else {
	            LineTo(0, 0, pathData);
	        }

	        // top-right
	        radius = this.radiusTR;
	        if (radius > 0) {
	            if (this._convexTR) {
	                var centerX = width - radius;
	                var centerY = radius;
	                ArcTo$1(centerX, centerY, radius, radius, 270, 360, false, iterations, pathData);
	            } else {
	                var centerX = width;
	                var centerY = 0;
	                ArcTo$1(centerX, centerY, radius, radius, 180, 90, true, iterations, pathData);
	            }
	        } else {
	            LineTo(width, 0, pathData);
	        }

	        // bottom-right
	        radius = this.radiusBR;
	        if (radius > 0) {
	            if (this._convexBR) {
	                var centerX = width - radius;
	                var centerY = height - radius;
	                ArcTo$1(centerX, centerY, radius, radius, 0, 90, false, iterations, pathData);
	            } else {
	                var centerX = width;
	                var centerY = height;
	                ArcTo$1(centerX, centerY, radius, radius, 270, 180, true, iterations, pathData);
	            }
	        } else {
	            LineTo(width, height, pathData);
	        }

	        // bottom-left
	        radius = this.radiusBL;
	        if (radius > 0) {
	            if (this._convexBL) {
	                var centerX = radius;
	                var centerY = height - radius;
	                ArcTo$1(centerX, centerY, radius, radius, 90, 180, false, iterations, pathData);
	            } else {
	                var centerX = 0;
	                var centerY = height;
	                ArcTo$1(centerX, centerY, radius, radius, 360, 270, true, iterations, pathData);
	            }
	        } else {
	            LineTo(0, height, pathData);
	        }

	        pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
	        Offset(this.x, this.y, pathData);

	        super.updateData();
	        return this;
	    }
	};

	const GetTint = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;

	class Triangle extends BaseGeom {
	    constructor(x0, y0, x1, y1, x2, y2) {
	        if (x0 === undefined) { x0 = 0; }
	        if (y0 === undefined) { y0 = 0; }
	        if (x1 === undefined) { x1 = 0; }
	        if (y1 === undefined) { y1 = 0; }
	        if (x2 === undefined) { x2 = 0; }
	        if (y2 === undefined) { y2 = 0; }

	        super();

	        this.pathData = [];
	        this.closePath = true;

	        this.setP0(x0, y0);
	        this.setP1(x1, y1);
	        this.setP2(x2, y2);
	    }

	    get x0() {
	        return this._x0;
	    }

	    set x0(value) {
	        this.dirty = this.dirty || (this._x0 !== value);
	        this._x0 = value;
	    }

	    get y0() {
	        return this._y0;
	    }

	    set y0(value) {
	        this.dirty = this.dirty || (this._y0 !== value);
	        this._y0 = value;
	    }

	    setP0(x, y) {
	        this.x0 = x;
	        this.y0 = y;
	        return this;
	    }

	    get x1() {
	        return this._x1;
	    }

	    set x1(value) {
	        this.dirty = this.dirty || (this._x1 !== value);
	        this._x1 = value;
	    }

	    get y1() {
	        return this._y1;
	    }

	    set y1(value) {
	        this.dirty = this.dirty || (this._y1 !== value);
	        this._y1 = value;
	    }

	    setP1(x, y) {
	        this.x1 = x;
	        this.y1 = y;
	        return this;
	    }

	    get x2() {
	        return this._x2;
	    }

	    set x2(value) {
	        this.dirty = this.dirty || (this._x2 !== value);
	        this._x2 = value;
	    }

	    get y2() {
	        return this._y2;
	    }

	    set y2(value) {
	        this.dirty = this.dirty || (this._y2 !== value);
	        this._y2 = value;
	    }

	    setP2(x, y) {
	        this.dirty = this.dirty || (this.x2 !== x) || (this.y2 !== y);
	        this.x2 = x;
	        this.y2 = y;
	        return this;
	    }

	    updateData() {
	        this.pathData.length = 0;
	        this.pathData.push(this.x0, this.y0);
	        this.pathData.push(this.x1, this.y1);
	        this.pathData.push(this.x2, this.y2);
	        this.pathData.push(this.x0, this.y0);

	        super.updateData();
	        return this;
	    }

	    webglRender(pipeline, calcMatrix, alpha, dx, dy) {
	        if (this.isFilled) {
	            var fillTintColor = GetTint(this.fillColor, this.fillAlpha * alpha);

	            var x0 = this.x0 - dx;
	            var y0 = this.y0 - dy;
	            var x1 = this.x1 - dx;
	            var y1 = this.y1 - dy;
	            var x2 = this.x2 - dx;
	            var y2 = this.y2 - dy;

	            var tx0 = calcMatrix.getX(x0, y0);
	            var ty0 = calcMatrix.getY(x0, y0);
	            var tx1 = calcMatrix.getX(x1, y1);
	            var ty1 = calcMatrix.getY(x1, y1);
	            var tx2 = calcMatrix.getX(x2, y2);
	            var ty2 = calcMatrix.getY(x2, y2);

	            pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
	        }

	        if (this.isStroked) {
	            StrokePathWebGL(pipeline, this, alpha, dx, dy);
	        }
	    }

	    canvasRender(ctx, dx, dy) {
	        var x1 = this.x1 - dx;
	        var y1 = this.y1 - dy;
	        var x2 = this.x2 - dx;
	        var y2 = this.y2 - dy;
	        var x3 = this.x3 - dx;
	        var y3 = this.y3 - dy;

	        ctx.beginPath();

	        ctx.moveTo(x1, y1);
	        ctx.lineTo(x2, y2);
	        ctx.lineTo(x3, y3);

	        ctx.closePath();

	        if (this.isFilled) {
	            FillStyleCanvas(ctx, this);
	            ctx.fill();
	        }

	        if (this.isStroked) {
	            LineStyleCanvas(ctx, this);
	            ctx.stroke();
	        }
	    }
	}

	const ShapeClasses = {
	    arc: Arc,
	    circle: Circle,
	    curve: Curve,
	    ellipse: Ellipse,
	    line: Line,
	    lines: Lines,
	    rectangle: Rectangle$3,
	    roundRectangle: RoundRectangle$2,
	    triangle: Triangle
	};

	const GetValue$1M = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$x = Phaser.Utils.Objects.IsPlainObject;

	const ClearAll = function () {
	    var shapes = this.getShapes();
	    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	        shapes[i].lineStyle().fillStyle();
	    }
	};

	var ShapesUpdateMethods = {
	    createShape(shapeType, name) {
	        var ShapeClass = ShapeClasses[shapeType];
	        var shape = new ShapeClass();
	        if (name) {
	            shape.setName(name);
	        }
	        return shape;
	    },

	    buildShapes(config) {
	        var createCallback = GetValue$1M(config, 'create', undefined);

	        if (IsPlainObject$x(createCallback)) {
	            var shapes = createCallback;
	            for (var shapeType in shapes) {
	                var name = shapes[shapeType];
	                switch (typeof (name)) {
	                    case 'number':
	                        for (var i = 0; i < name; i++) {
	                            this.addShape(this.createShape(shapeType));
	                        }
	                        break;

	                    case 'string':
	                        this.addShape(this.createShape(shapeType, name));
	                        break;

	                    default: //Array
	                        var names = name;
	                        for (var i = 0, cnt = names.length; i < cnt; i++) {
	                            this.addShape(this.createShape(shapeType, names[i]));
	                        }
	                        break;
	                }
	            }
	        } else if (Array.isArray(createCallback)) {
	            var shapes = createCallback;
	            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	                var shape = shapes[i];
	                this.addShape(this.createShape(shape.type, shape.name));
	            }

	        } else if (typeof (createCallback) === 'function') {
	            createCallback.call(this);

	        }

	        this.setUpdateShapesCallback(GetValue$1M(config, 'update'));
	    },

	    setUpdateShapesCallback(callback) {
	        if (callback === undefined) {
	            callback = ClearAll;
	        }
	        this.dirty = this.dirty || (this.updateCallback !== callback);
	        this.updateCallback = callback;
	        return this;
	    },

	    updateShapes() {
	        this.updateCallback.call(this);
	    }
	};

	const TransformMatrix$1 = Phaser.GameObjects.Components.TransformMatrix;
	const TransformXY = Phaser.Math.TransformXY;

	var WorldXYToGameObjectLocalXY = function (gameObject, worldX, worldY, camera, out) {
	    if (camera === undefined) {
	        camera = gameObject.scene.cameras.main;
	    }

	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        out = globOut$2;
	    }

	    var csx = camera.scrollX;
	    var csy = camera.scrollY;
	    var px = worldX + (csx * gameObject.scrollFactorX) - csx;
	    var py = worldY + (csy * gameObject.scrollFactorY) - csy;
	    if (gameObject.parentContainer) {
	        if (tempMatrix$1 === undefined) {
	            tempMatrix$1 = new TransformMatrix$1();
	            parentMatrix$1 = new TransformMatrix$1();
	        }

	        gameObject.getWorldTransformMatrix(tempMatrix$1, parentMatrix$1);
	        tempMatrix$1.applyInverse(px, py, out);
	    }
	    else {
	        TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, out);
	    }

	    out.x += gameObject.displayOriginX;
	    out.y += gameObject.displayOriginY;

	    return out;
	};

	var tempMatrix$1, parentMatrix$1;
	var globOut$2 = {};

	const GetValue$1L = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$w = Phaser.Utils.Objects.IsPlainObject;

	class CustomShapes extends BaseShapes {
	    constructor(scene, x, y, width, height, config) {
	        if (IsPlainObject$w(x)) {
	            config = x;
	            x = GetValue$1L(config, 'x', 0);
	            y = GetValue$1L(config, 'y', 0);
	            width = GetValue$1L(config, 'width', 2);
	            height = GetValue$1L(config, 'height', 2);
	        }

	        super(scene, x, y, width, height);
	        this.type = GetValue$1L(config, 'type', 'rexCustomShapes');
	        this.buildShapes(config);
	    }

	    get centerX() {
	        return this.width / 2;
	    }

	    get centerY() {
	        return this.height / 2;
	    }

	    worldToLocalXY(worldX, worldY, camera, out) {
	        if (typeof (camera) === 'boolean') {
	            out = camera;
	            camera = undefined;
	        }

	        return WorldXYToGameObjectLocalXY(this, worldX, worldY, camera, out);
	    }
	}

	Object.assign(
	    CustomShapes.prototype,
	    ShapesUpdateMethods
	);

	const Linear$f = Phaser.Math.Linear;
	const Percent$2 = Phaser.Math.Percent;

	var ProgressValueMethods = {
	    setValue(value, min, max) {
	        if ((value === undefined) || (value === null)) {
	            return this;
	        }

	        if (min !== undefined) {
	            value = Percent$2(value, min, max);
	        }
	        this.value = value;
	        return this;
	    },

	    addValue(inc, min, max) {
	        if (min !== undefined) {
	            inc = Percent$2(inc, min, max);
	        }
	        this.value += inc;
	        return this;
	    },

	    getValue(min, max) {
	        var value = this.value;
	        if (min !== undefined) {
	            value = Linear$f(min, max, value);
	        }
	        return value;
	    }
	};

	const Percent$1 = Phaser.Math.Percent;

	var SetEaseValuePropName = function (name) {
	    this.easeValuePropName = name;
	    return this;
	};

	var SetEaseValueDuration = function (duration) {
	    this.easeValueDuration = duration;
	    return this;
	};

	var SetEaseValueFunction = function (ease) {
	    this.easeFunction = ease;
	    return this;
	};

	var StopEaseValue = function () {
	    if (this.easeValueTask) {
	        this.easeValueTask.stop();
	    }
	    return this;
	};

	var EaseValueTo = function (value, min, max) {
	    if ((value === undefined) || (value === null)) {
	        return this;
	    }

	    if (min !== undefined) {
	        value = Percent$1(value, min, max);
	    }

	    if (this.easeValueTask === undefined) {
	        this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
	    }

	    this.easeValueTask.restart({
	        key: this.easeValuePropName,
	        to: value,
	        duration: this.easeValueDuration,
	        ease: this.easeFunction,
	    });

	    return this;
	};

	var EaseValueRepeat = function (from, to, repeat, repeatDelay) {     
	    if (repeat === undefined) {
	        repeat = -1;
	    }
	    if (repeatDelay === undefined) {
	        repeatDelay = 0;
	    }

	    if (this.easeValueTask === undefined) {
	        this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
	    }

	    this.easeValueTask.restart({
	        key: this.easeValuePropName,
	        from: from, to: to,
	        duration: this.easeValueDuration,
	        ease: this.easeFunction,
	        repeat: repeat, repeatDelay: repeatDelay,
	    });

	    return this;
	};

	var EaseValueMethods$1 = {
	    setEaseValuePropName: SetEaseValuePropName,
	    setEaseValueDuration: SetEaseValueDuration,
	    setEaseValueFunction: SetEaseValueFunction,
	    stopEaseValue: StopEaseValue,
	    easeValueTo: EaseValueTo,
	    easeValueRepeat: EaseValueRepeat
	};

	const GetValue$1K = Phaser.Utils.Objects.GetValue;
	const Clamp$6 = Phaser.Math.Clamp;

	function ProgressBase (BaseClass) {
	    class ProgressBase extends BaseClass {
	        bootProgressBase(config) {
	            this.eventEmitter = GetValue$1K(config, 'eventEmitter', this);

	            var callback = GetValue$1K(config, 'valuechangeCallback', null);
	            if (callback !== null) {
	                var scope = GetValue$1K(config, 'valuechangeCallbackScope', undefined);
	                this.eventEmitter.on('valuechange', callback, scope);
	            }

	            this
	                .setEaseValuePropName('value')
	                .setEaseValueDuration(GetValue$1K(config, 'easeValue.duration', 0))
	                .setEaseValueFunction(GetValue$1K(config, 'easeValue.ease', 'Linear'));

	            return this;
	        }

	        get value() {
	            return this._value;
	        }

	        set value(value) {
	            value = Clamp$6(value, 0, 1);

	            var oldValue = this._value;
	            var valueChanged = (oldValue != value);
	            this.dirty = this.dirty || valueChanged;
	            this._value = value;

	            if (valueChanged) {
	                this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
	            }
	        }
	    }

	    Object.assign(
	        ProgressBase.prototype,
	        ProgressValueMethods,
	        EaseValueMethods$1
	    );

	    return ProgressBase;
	}

	const GetValue$1J = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$v = Phaser.Utils.Objects.IsPlainObject;

	class CustomProgress extends ProgressBase(CustomShapes) {
	    constructor(scene, x, y, width, height, config) {
	        if (IsPlainObject$v(x)) {
	            config = x;
	            x = GetValue$1J(config, 'x', 0);
	            y = GetValue$1J(config, 'y', 0);
	            width = GetValue$1J(config, 'width', 2);
	            height = GetValue$1J(config, 'height', 2);
	        }
	        if (config === undefined) {
	            config = {};
	        }
	        if (!config.type) {
	            config.type = 'rexCustomProgress';
	        }

	        super(scene, x, y, width, height, config);

	        this.bootProgressBase(config);

	        this.setValue(GetValue$1J(config, 'value', 0));
	    }

	    get centerX() {
	        return this.width / 2;    }

	    get centerY() {
	        return this.height / 2;
	    }

	    get radius() {
	        return Math.min(this.centerX, this.centerY);
	    }
	}

	var CreateMask$7 = function (scene) {
	    var maskGameObject = new CustomProgress(scene, {
	        type: 'Graphics',
	        create: [
	            { name: 'rect', type: 'rectangle' },
	        ],
	        update: function () {
	            var rect = this.getShape('rect')
	                .fillStyle(0xffffff);

	            var t = 1 - this.value;
	            switch (this.wipeMode) {
	                case 'right':
	                    rect
	                        .setSize(this.width * t, this.height)
	                        .setTopLeftPosition(this.width - rect.width, 0);
	                    break;

	                case 'left':
	                    rect
	                        .setSize(this.width * t, this.height)
	                        .setTopLeftPosition(0, 0);
	                    break;

	                case 'down':
	                    rect
	                        .setSize(this.width, this.height * t)
	                        .setTopLeftPosition(0, this.height - rect.height);
	                    break;

	                case 'up':
	                    rect
	                        .setSize(this.width, this.height * t)
	                        .setTopLeftPosition(0, 0);
	                    break;
	            }
	        },
	    });
	    return maskGameObject;
	};

	var AddWipeModes = function (image) {
	    var maskGameObject = CreateMask$7(image.scene);

	    image
	        .once('destroy', function () {
	            maskGameObject.destroy();
	        })
	        .addTransitionMode(WipeRight, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true);
	                parent.maskGameObject.wipeMode = 'right';
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        })
	        .addTransitionMode(WipeLeft, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true);
	                parent.maskGameObject.wipeMode = 'left';
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        })
	        .addTransitionMode(WipeDown, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true);
	                parent.maskGameObject.wipeMode = 'down';
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        })
	        .addTransitionMode(WipeUp, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true);
	                parent.maskGameObject.wipeMode = 'up';
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        });

	};

	var CreateMask$6 = function (scene) {
	    var maskGameObject = new CustomProgress(scene, {
	        type: 'Graphics',
	        create: [
	            { name: 'rect', type: 'rectangle' },
	        ],
	        update: function () {
	            this.getShape('rect')
	                .fillStyle(0xffffff)
	                .setSize(this.width * this.value, this.height * this.value)
	                .setCenterPosition(this.centerX, this.centerY);
	        },
	    });
	    return maskGameObject;
	};

	var AddIrisModes = function (image) {
	    var maskGameObject = CreateMask$6(image.scene);

	    image
	        .once('destroy', function () {
	            maskGameObject.destroy();
	        })
	        .addTransitionMode(IrisOut, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        })
	        .addTransitionMode(IrisIn, {
	            ease: 'Linear', dir: 'in', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setNextImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(1 - t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        })
	        .addTransitionMode(IrisInOut, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.tint = 0;  // Turn nextImage to black
	                parent.setCurrentImageMaskEnable(true);
	                parent.setNextImageMaskEnable(true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var tintGray;
	                if (t < 0.5) {
	                    t = Yoyo$1(t);
	                    tintGray = Math.floor(255 * (1 - t));
	                    parent.maskGameObject.setValue(1 - t);
	                    currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;

	                } else {
	                    if (currentImage.visible) {
	                        parent.setChildVisible(currentImage, false);
	                    }

	                    t = Yoyo$1(t);
	                    tintGray = Math.floor(255 * (1 - t));
	                    parent.maskGameObject.setValue(1 - t);
	                    nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
	                }
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);

	                parent.setChildVisible(currentImage, true);
	                currentImage.tint = 0xffffff;

	                parent.setChildVisible(nextImage, true);
	                nextImage.tint = 0xffffff;
	            },
	        });
	};

	var CreateMask$5 = function (scene) {
	    var maskGameObject = new CustomProgress(scene, {
	        type: 'Graphics',
	        create: [
	            { name: 'pie', type: 'arc' },
	        ],
	        update: function () {
	            var radius = Math.max(this.width, this.height) * 2;
	            var deltaAngle = 90 * this.value;

	            this.getShape('pie')
	                .fillStyle(0xffffff)
	                .setCenterPosition(this.centerX, 0)
	                .setRadius(radius)
	                .setAngle(90 - deltaAngle, 90 + deltaAngle)
	                .setPie();

	        },
	    });
	    return maskGameObject;
	};

	var AddPieModes = function (image) {
	    var maskGameObject = CreateMask$5(image.scene);

	    image
	        .once('destroy', function () {
	            maskGameObject.destroy();
	        })
	        .addTransitionMode(PieOut, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        })
	        .addTransitionMode(PieIn, {
	            ease: 'Linear', dir: 'in', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setNextImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(1 - t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        })
	        .addTransitionMode(PieInOut, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.tint = 0;  // Turn nextImage to black
	                parent.setCurrentImageMaskEnable(true);
	                parent.setNextImageMaskEnable(true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var tintGray;
	                if (t < 0.5) {
	                    t = Yoyo$1(t);
	                    tintGray = Math.floor(255 * (1 - t));
	                    parent.maskGameObject.setValue(1 - t);
	                    currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
	                } else {
	                    if (currentImage.visible) {
	                        parent.setChildVisible(currentImage, false);
	                    }

	                    t = Yoyo$1(t);
	                    tintGray = Math.floor(255 * (1 - t));
	                    parent.maskGameObject.setValue(1 - t);
	                    nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
	                }
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);

	                parent.setChildVisible(currentImage, true);
	                currentImage.tint = 0xffffff;

	                parent.setChildVisible(nextImage, true);
	                nextImage.tint = 0xffffff;
	            },
	        });

	};

	var CreateMask$4 = function (scene, columns) {
	    var maskGameObject = new CustomProgress(scene, {
	        type: 'Graphics',
	        create: {
	            rectangle: columns
	        },
	        update: function () {
	            var shapes = this.getShapes();
	            var shapeWidth = this.width / columns;
	            for (var i = 0; i < columns; i++) {
	                shapes[i]
	                    .fillStyle(0xffffff)
	                    .setSize(shapeWidth * this.value, this.height)
	                    .setTopLeftPosition(shapeWidth * i, 0);
	            }
	        },
	    });
	    return maskGameObject;
	};

	var AddBlindsModes = function (image) {
	    var maskGameObject = CreateMask$4(image.scene, 10);

	    image
	        .once('destroy', function () {
	            maskGameObject.destroy();
	        })
	        .addTransitionMode(Blinds, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        });
	};

	var CreateMask$3 = function (scene, columns, rows) {
	    var maskGameObject = new CustomProgress(scene, {
	        type: 'Graphics',
	        create: {
	            rectangle: columns * rows
	        },
	        update: function () {
	            var shapes = this.getShapes();
	            var shapeWidth = this.width / columns,
	                shapeHeight = this.height / rows;
	            for (var r = 0; r < rows; r++) {
	                for (var c = 0; c < columns; c++) {
	                    shapes[c * rows + r]
	                        .fillStyle(0xffffff)
	                        .setSize(shapeWidth * this.value, shapeHeight * this.value)
	                        .setCenterPosition(shapeWidth * (c + 0.5), shapeHeight * (r + 0.5));
	                }
	            }
	        },
	    });
	    return maskGameObject;
	};

	var AddSquaresModes = function (image) {
	    var maskGameObject = CreateMask$3(image.scene, Math.ceil(image.width / 40), Math.ceil(image.height / 40));

	    image
	        .once('destroy', function () {
	            maskGameObject.destroy();
	        })
	        .addTransitionMode(Squares, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        });
	};

	var CreateMask$2 = function (scene, columns, rows) {
	    var maskGameObject = new CustomProgress(scene, {
	        type: 'Graphics',
	        create: {
	            lines: columns * rows
	        },
	        update: function () {
	            var shapes = this.getShapes();
	            var shapeHalfWidth = this.width / (columns - 1),
	                shapeHelfHeight = this.height / rows;
	            var shapeHeight = shapeHelfHeight * 2;
	            var halfWidth = shapeHalfWidth * this.value,
	                halfHeight = shapeHelfHeight * this.value;
	            for (var r = 0; r < rows; r++) {
	                for (var c = 0; c < columns; c++) {
	                    var centerX = c * shapeHalfWidth;
	                    var centerY = r * shapeHeight + (c % 2) * shapeHelfHeight;
	                    shapes[c * rows + r]
	                        .fillStyle(0xffffff)
	                        .start(centerX + halfWidth, centerY)
	                        .lineTo(centerX, centerY + halfHeight)
	                        .lineTo(centerX - halfWidth, centerY)
	                        .lineTo(centerX, centerY - halfHeight)
	                        .lineTo(centerX + halfWidth, centerY)
	                        .close();
	                }
	            }
	        },
	    });
	    return maskGameObject;
	};

	var AddDiamondsMode = function (image) {
	    var maskGameObject = CreateMask$2(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));

	    image
	        .once('destroy', function () {
	            maskGameObject.destroy();
	        })
	        .addTransitionMode(Diamonds, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        });
	};

	var CreateMask$1 = function (scene, columns, rows) {
	    var maskGameObject = new CustomProgress(scene, {
	        type: 'Graphics',
	        create: {
	            circle: columns * rows
	        },
	        update: function () {
	            var shapes = this.getShapes();
	            var shapeHalfWidth = this.width / (columns - 1),
	                shapeHelfHeight = this.height / rows;
	            var shapeHeight = shapeHelfHeight * 2;
	            var radius = Math.max(shapeHalfWidth, shapeHelfHeight) * this.value;
	            for (var r = 0; r < rows; r++) {
	                for (var c = 0; c < columns; c++) {
	                    var centerX = c * shapeHalfWidth;
	                    var centerY = r * shapeHeight + (c % 2) * shapeHelfHeight;
	                    shapes[c * rows + r]
	                        .fillStyle(0xffffff)
	                        .setCenterPosition(centerX, centerY)
	                        .setRadius(radius);
	                }
	            }
	        },
	    });
	    return maskGameObject;
	};

	var AddCirclesMode = function (image) {
	    var maskGameObject = CreateMask$1(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));

	    image
	        .once('destroy', function () {
	            maskGameObject.destroy();
	        })
	        .addTransitionMode(Circles, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setCurrentImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                parent.maskGameObject.setValue(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);
	            },
	        });
	};

	var CreateMask = function (scene, columns) {
	    var maskGameObject = new CustomProgress(scene, {
	        type: 'Graphics',
	        create: {
	            lines: columns
	        },
	        update: function () {
	            var shapes = this.getShapes();
	            var shapeWidth = this.width / columns;
	            var radius = shapeWidth / 2;
	            for (var i = 0; i < columns; i++) {
	                var leftX = shapeWidth * i;
	                var bottomY = this.height * this.value;
	                var centerX = leftX + radius;
	                shapes[i]
	                    .fillStyle(0xffffff)
	                    .start(leftX, 0)
	                    .horizontalLineTo(bottomY)
	                    .arc(centerX, bottomY, radius, 180, 0, true)
	                    .horizontalLineTo(-bottomY)
	                    .lineTo(leftX, 0)
	                    .close();
	            }
	        },
	    });
	    return maskGameObject;
	};

	var AddCurtainMode = function (image) {
	    var maskGameObject = CreateMask(image.scene, 10);

	    image
	        .once('destroy', function () {
	            maskGameObject.destroy();
	        })
	        .addTransitionMode(Curtain, {
	            ease: 'Linear', dir: 'out', mask: maskGameObject,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.tint = 0;  // Turn nextImage to black
	                parent.setCurrentImageMaskEnable(true, true);
	                parent.setNextImageMaskEnable(true, true);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                var tintGray;
	                if (t < 0.5) {
	                    t = Yoyo$1(t);
	                    tintGray = Math.floor(255 * (1 - t));
	                    parent.maskGameObject.setValue(t);
	                    currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;

	                } else {
	                    if (currentImage.visible) {
	                        parent.setChildVisible(currentImage, false);
	                    }

	                    t = Yoyo$1(t);
	                    tintGray = Math.floor(255 * (1 - t));
	                    parent.maskGameObject.setValue(t);
	                    nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
	                }
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                parent.removeMaskGameObject(false);

	                parent.setChildVisible(currentImage, true);
	                currentImage.tint = 0xffffff;

	                parent.setChildVisible(nextImage, true);
	                nextImage.tint = 0xffffff;
	            },
	        });
	};

	var AddPixellateMode = function (image) {
	    image
	        .addTransitionMode(Pixellate, {
	            ease: 'Linear', dir: 'out', mask: true,

	            onStart: function (parent, currentImage, nextImage, t) {
	                parent.setChildVisible(nextImage, false);
	                currentImage.effect = currentImage.preFX.addPixelate(0);
	                nextImage.effect = nextImage.preFX.addPixelate(0);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                if (t < 0.5) {
	                    t = Yoyo$1(t);
	                    var maxAmount = Math.min(currentImage.width, currentImage.height) / 5;
	                    currentImage.effect.amount = Math.ceil(maxAmount * t);
	                } else {
	                    if (currentImage.visible) {
	                        parent.setChildVisible(currentImage, false);
	                    }
	                    if (!nextImage.visible) {
	                        parent.setChildVisible(nextImage, true);
	                    }

	                    t = Yoyo$1(t);
	                    var maxAmount = Math.min(nextImage.width, nextImage.height) / 5;
	                    nextImage.effect.amount = Math.ceil(maxAmount * t);
	                }
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                currentImage.preFX.remove(currentImage.effect);
	                delete currentImage.effect;
	                parent.setChildVisible(currentImage, true);

	                nextImage.preFX.remove(nextImage.effect);
	                delete nextImage.effect;
	            },
	        });

	};

	// Reference: https://medium.com/neosavvy-labs/webgl-with-perlin-noise-part-1-a87b56bbc9fb
	const frag$1 = `\
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
float Perlin(vec3 P) {
    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0); gx1 = fract(gx1);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
}
float Perlin(vec2 P) { return Perlin(vec3(P, 0.0)); }
`;

	// https://github.com/ykob/glsl-dissolve/blob/master/src/glsl/dissolve.fs


	const frag = `\
#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
// Scene buffer
uniform sampler2D uMainSampler;
uniform sampler2D uMainSampler2;

uniform int resizeMode;
uniform float progress;
uniform float fromRatio;
uniform float toRatio;
varying vec2 outFragCoord;
// Effect parameters
uniform float noiseX;
uniform float noiseY;
uniform float noiseZ;
uniform float fromEdgeStart;
uniform float fromEdgeWidth;
uniform float toEdgeStart;
uniform float toEdgeWidth;

${frag$1}

vec4 getFromColor (vec2 uv) {
  return texture2D(uMainSampler, uv);
}

vec4 getToColor (vec2 uv) {
  if (resizeMode == 2) {
    //  cover
    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(min(fromRatio / toRatio, 1.0), min((toRatio / fromRatio), 1.0)));
  } else if (resizeMode == 1) {
    //  contain
    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(max(fromRatio / toRatio, 1.0), max((toRatio / fromRatio), 1.0)));
  } else {
    //  stretch
    return texture2D(uMainSampler2, vec2(uv.x, 1.0 - uv.y));
  }
}

vec4 transition (vec2 uv) {    
  vec4 colorFront = getFromColor(uv);
  vec4 colorTo = getToColor(uv);

  float noise = (Perlin(vec3(uv.x * noiseX, uv.y * noiseY, noiseZ)) + 1.0) / 2.0
    * (1.0 - (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth))
    + (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth) * 0.5;
  vec4 colorResult = colorFront * smoothstep(progress - (fromEdgeStart + fromEdgeWidth), progress - fromEdgeStart, noise)
    + colorTo * smoothstep((1.0 - progress) - (toEdgeStart + toEdgeWidth), (1.0 - progress) - toEdgeStart, (1.0 - noise));
  return colorResult;
}

void main () {
  vec2 uv = outFragCoord;
  gl_FragColor = transition(uv);
}
`;

	const PostFXPipeline = Phaser.Renderer.WebGL.Pipelines.PostFXPipeline;
	const GetValue$1I = Phaser.Utils.Objects.GetValue;
	const Clamp$5 = Phaser.Math.Clamp;

	class DissolvePostFxPipeline extends PostFXPipeline {
	    constructor(game) {
	        super({
	            name: 'rexDissolvePostFx',
	            game: game,
	            renderTarget: true,
	            fragShader: frag
	        });

	        this._progress = 0;
	        this.toFrame = null;
	        this.targetTexture = null;
	        this.resizeMode = 1;
	        this.toRatio = 1;

	        this.noiseX = 0;
	        this.noiseY = 0;
	        this.noiseZ = 0;
	        this.fromEdgeStart = 0.01;
	        this.fromEdgeWidth = 0.05;
	        this.toEdgeStart = 0.01;
	        this.toEdgeWidth = 0.05;
	    }

	    resetFromJSON(o) {
	        this.setProgress(GetValue$1I(o, 'progress', 0));
	        this.setTransitionTargetTexture(GetValue$1I(o, 'toTexture', '__DEFAULT'), GetValue$1I(o, 'toFrame', undefined), GetValue$1I(o, 'resizeMode', 1));
	        this.setNoise(GetValue$1I(o, 'noiseX', undefined), GetValue$1I(o, 'noiseY', undefined), GetValue$1I(o, 'noiseZ', undefined));
	        this.setFromEdge(GetValue$1I(o, 'fromEdgeStart', 0.01), GetValue$1I(o, 'fromEdgeWidth', 0.05));
	        this.setToEdge(GetValue$1I(o, 'toEdgeStart', 0.01), GetValue$1I(o, 'toEdgeWidth', 0.05));
	        return this;
	    }

	    onBoot() {

	    }

	    onPreRender() {
	        this.set1f('progress', this.progress);
	        this.set1i('resizeMode', this.resizeMode);

	        this.set1f('noiseX', this.noiseX);
	        this.set1f('noiseY', this.noiseY);
	        this.set1f('noiseZ', this.noiseZ);
	        this.set1f('fromEdgeStart', this.fromEdgeStart);
	        this.set1f('fromEdgeWidth', this.fromEdgeWidth);
	        this.set1f('toEdgeStart', this.toEdgeStart);
	        this.set1f('toEdgeWidth', this.toEdgeWidth);
	    }

	    onDraw(renderTarget) {
	        this.set1f('fromRatio', renderTarget.width / renderTarget.height);

	        this.set1f('toRatio', this.toRatio);

	        this.set1i('uMainSampler2', 1);

	        this.bindTexture(this.targetTexture, 1);

	        this.bindAndDraw(renderTarget);
	    }

	    get progress() {
	        return this._progress;
	    }

	    set progress(value) {
	        this._progress = Clamp$5(value, 0, 1);
	    }

	    setProgress(value) {
	        this.progress = value;
	        return this;
	    }

	    setTransitionTargetTexture(key, frame, resizeMode) {
	        if (key === undefined) {
	            key = '__DEFAULT';
	        }
	        var phaserTexture = this.game.textures.getFrame(key, frame);

	        if (!phaserTexture) {
	            phaserTexture = this.game.textures.getFrame('__DEFAULT');
	        }

	        this.toRatio = phaserTexture.width / phaserTexture.height;

	        this.toFrame = phaserTexture;
	        this.targetTexture = phaserTexture.glTexture;

	        if (resizeMode !== undefined) {
	            this.resizeMode = resizeMode;
	        }

	        return this;
	    }

	    setResizeMode(mode) {
	        if (typeof (mode) === 'string') {
	            mode = ResizeMode[mode];
	        }
	        this.resizeMode = mode;
	        return this;
	    }

	    setNoise(x, y, z) {
	        if (x === undefined) {
	            x = 4 + Math.random() * 6;
	        }
	        if (y === undefined) {
	            y = 4 + Math.random() * 6;
	        }
	        if (z === undefined) {
	            z = Math.random() * 10;
	        }
	        this.noiseX = x;
	        this.noiseY = y;
	        this.noiseZ = z;
	        return this;
	    }

	    setFromEdge(edgeStart, edgeWidth) {
	        this.fromEdgeStart = edgeStart;
	        this.fromEdgeWidth = edgeWidth;
	        return this;
	    }

	    setToEdge(edgeStart, edgeWidth) {
	        this.toEdgeStart = edgeStart;
	        this.toEdgeWidth = edgeWidth;
	        return this;
	    }
	}

	/**
	 * Set the resize mode of the target texture.
	 * 
	 * Can be either:
	 * 
	 * 0 - Stretch. The target texture is stretched to the size of the source texture.
	 * 1 - Contain. The target texture is resized to fit the source texture. This is the default.
	 * 2 - Cover. The target texture is resized to cover the source texture.
	 * 
	 * If the source and target textures are the same size, then use a resize mode of zero
	 * for speed.
	 *
	 */
	var ResizeMode = {
	    stretch: 0,
	    contain: 1,
	    cover: 2
	};

	var RegisterPostPipeline = function (game, postFxPipelineName, PostFxPipelineClass) {
	    GetGame(game).renderer.pipelines.addPostPipeline(postFxPipelineName, PostFxPipelineClass);
	};

	var AddPostFxPipelineInstance = function (gameObject, PostFxPipelineClass, config) {
	    if (config === undefined) {
	        config = {};
	    }

	    gameObject.setPostPipeline(PostFxPipelineClass);
	    var pipeline = gameObject.postPipelines[gameObject.postPipelines.length - 1];
	    pipeline.resetFromJSON(config);

	    if (config.name) {
	        pipeline.name = config.name;
	    }

	    return pipeline;
	};

	const SpliceOne$1 = Phaser.Utils.Array.SpliceOne;

	var RemovePostFxPipelineInstance = function (gameObject, PostFxPipelineClass, name) {
	    if (name === undefined) {
	        var pipelines = gameObject.postPipelines;
	        for (var i = (pipelines.length - 1); i >= 0; i--) {
	            var instance = pipelines[i];
	            if (instance instanceof PostFxPipelineClass) {
	                instance.destroy();
	                SpliceOne$1(pipelines, i);
	            }
	        }
	    } else {
	        var pipelines = gameObject.postPipelines;
	        for (var i = 0, cnt = pipelines.length; i < cnt; i++) {
	            var instance = pipelines[i];
	            if ((instance instanceof PostFxPipelineClass) && (instance.name === name)) {
	                instance.destroy();
	                SpliceOne$1(pipelines, i);
	            }
	        }
	    }

	    gameObject.hasPostPipeline = (gameObject.postPipelines.length > 0);

	};

	var AddDissolveMode = function (image) {
	    RegisterPostPipeline(image.scene.game, 'rexDissolvePostFx', DissolvePostFxPipeline);

	    image
	        .addTransitionMode(Dissolve, {
	            ease: 'Linear', dir: 'out', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	                currentImage.effect = AddPostFxPipelineInstance(currentImage, DissolvePostFxPipeline);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                currentImage.effect.setProgress(t);
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                RemovePostFxPipelineInstance(currentImage, DissolvePostFxPipeline);
	                delete currentImage.effect;
	            },
	        });
	};

	const WipeWidth = 0.1;
	const DirLeftToRight = 0;
	const DirTopToBottom = 0;
	const DirRightToLeft = 1;
	const DirBottomToTop = 1;
	const AxisX = 0;
	const AxisY = 1;

	var AddRevealModes = function (image) {
	    image
	        .addTransitionMode(RevealRight, {
	            ease: 'Linear', dir: 'in', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirLeftToRight, AxisX);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                nextImage.effect.progress = t;
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                nextImage.preFX.remove(nextImage.effect);
	                delete nextImage.effect;
	            },
	        })
	        .addTransitionMode(RevealLeft, {
	            ease: 'Linear', dir: 'in', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirRightToLeft, AxisX);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                nextImage.effect.progress = t;
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                nextImage.preFX.remove(nextImage.effect);
	                delete nextImage.effect;
	            },
	        })
	        .addTransitionMode(RevealDown, {
	            ease: 'Linear', dir: 'in', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirTopToBottom, AxisY);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                nextImage.effect.progress = t;
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                nextImage.preFX.remove(nextImage.effect);
	                delete nextImage.effect;
	            },
	        })
	        .addTransitionMode(RevealUp, {
	            ease: 'Linear', dir: 'in', mask: false,

	            onStart: function (parent, currentImage, nextImage, t) {
	                nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirBottomToTop, AxisY);
	            },
	            onProgress: function (parent, currentImage, nextImage, t) {
	                nextImage.effect.progress = t;
	            },
	            onComplete: function (parent, currentImage, nextImage, t) {
	                nextImage.preFX.remove(nextImage.effect);
	                delete nextImage.effect;
	            },
	        });

	};

	const Modes = [
	    AddSlideAwayModes, AddSlideModes, AddSliderModes,
	    AddZoomModes,
	    AddFadeModes,
	    AddIrisModes, AddPieModes, AddWipeModes,
	    AddBlindsModes, AddSquaresModes, AddDiamondsMode, AddCirclesMode, AddCurtainMode,
	    AddPixellateMode, AddDissolveMode, AddRevealModes
	];

	class TransitionImagePack extends TransitionImage {
	    constructor(scene, x, y, texture, frame, config) {
	        super(scene, x, y, texture, frame, config);

	        for (var i = 0, cnt = Modes.length; i < cnt; i++) {
	            Modes[i](this);
	        }
	    }
	}

	const GetValue$1H = Phaser.Utils.Objects.GetValue;

	class ShakePosition extends TickTask {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        this.timer = new Timer$1();
	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.timer.resetFromJSON(GetValue$1H(o, 'timer'));
	        this.setEnable(GetValue$1H(o, 'enable', true));
	        this.setMode(GetValue$1H(o, 'mode', 1));
	        this.isRunning = GetValue$1H(o, 'isRunning', false);
	        this.setMagnitudeMode(GetValue$1H(o, 'magnitudeMode', 1));
	        this.setAxisMode(GetValue$1H(o, "axis", 0));
	        this.setDuration(GetValue$1H(o, 'duration', 500));
	        this.setMagnitude(GetValue$1H(o, 'magnitude', 10));
	        this.ox = GetValue$1H(o, 'ox', undefined);
	        this.oy = GetValue$1H(o, 'oy', undefined);
	        return this;
	    }

	    toJSON() {
	        return {
	            timer: this.timer.toJSON(),
	            enable: this.enable,
	            mode: this.mode,
	            isRunning: this.isRunning,
	            magnitudeMode: magnitudeMode,
	            duration: this.duration,
	            magnitude: this.magnitude,
	            ox: this.ox,
	            oy: this.oy,
	        };
	    }

	    // override
	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        super.shutdown(fromScene);
	        this.timer.destroy();
	        this.timer = undefined;
	    }

	    startTicking() {
	        super.startTicking();

	        if (this.mode === 0) { // Effect mode
	            this.scene.game.events.on('poststep', this.update, this);
	            this.scene.game.events.on('prestep', this.backToOrigin, this);
	        } else { // Behavior Mode
	            this.scene.sys.events.on('preupdate', this.update, this);
	        }
	    }

	    stopTicking() {
	        super.stopTicking();

	        if (this.scene) { // Scene might be destoryed
	            if (this.mode === 0) { // Effect mode
	                this.scene.game.events.off('poststep', this.update, this);
	                this.scene.game.events.off('prestep', this.backToOrigin, this);
	            } else { // Behavior Mode
	                this.scene.sys.events.off('preupdate', this.update, this);
	            }

	        }
	    }

	    setEnable(e) {
	        if (e == undefined) {
	            e = true;
	        }
	        this.enable = e;
	        return this;
	    }

	    setMode(mode) {
	        if (typeof (mode) === 'string') {
	            mode = MODE$3[mode];
	        }
	        this.mode = mode;
	        return this;
	    }

	    setMagnitudeMode(magnitudeMode) {
	        if (typeof (magnitudeMode) === 'string') {
	            magnitudeMode = MANITUDEMODE[magnitudeMode];
	        }

	        this.magnitudeMode = magnitudeMode;
	        return this;
	    }

	    setAxisMode(m) {
	        if (typeof (m) === 'string') {
	            m = DIRECTIONNODE[m];
	        }
	        this.axisMode = m;
	        return this;
	    }

	    setDuration(duration) {
	        this.duration = duration;
	        return this;
	    }

	    setMagnitude(magnitude) {
	        this.magnitude = magnitude;
	        return this;
	    }

	    start(duration, magnitude) {
	        if (typeof (duration) !== 'number') {
	            var config = duration;
	            magnitude = GetValue$1H(config, 'magnitude', undefined);
	            duration = GetValue$1H(config, 'duration', undefined);
	        }
	        if (magnitude !== undefined) {
	            this.setMagnitude(magnitude);
	        }
	        if (duration !== undefined) {
	            this.setDuration(duration);
	        }

	        this.timer
	            .setDuration(this.duration)
	            .start();

	        super.start();
	        return this;
	    }

	    shake(duration, magnitude) {
	        this.start(duration, magnitude);
	        return this;
	    }

	    update(time, delta) {
	        if ((!this.isRunning) || (!this.enable)) {
	            return this;
	        }

	        var gameObject = this.parent;
	        if (!gameObject.active) {
	            return this;
	        }

	        this.timer.update(time, delta);
	        if (this.timer.isDone) {
	            this.backToOrigin();
	            this.complete();
	        } else {
	            if (this.ox === undefined) {
	                this.ox = gameObject.x;
	                this.oy = gameObject.y;
	            }

	            var magnitude = this.magnitude;
	            if (this.magnitudeMode === 1) // decay
	            {
	                magnitude *= (1 - this.timer.t);
	            }
	            var a = Math.random() * Math.PI * 2;
	            var x = this.ox + (Math.cos(a) * magnitude);
	            var y = this.oy + (Math.sin(a) * magnitude);

	            switch (this.axisMode) {
	                case 1:
	                    gameObject.x = x;
	                    break;

	                case 2:
	                    gameObject.y = y;
	                    break;

	                default:
	                    gameObject.x = x;
	                    gameObject.y = y;
	                    break;
	            }
	        }

	        return this;
	    }

	    backToOrigin() {
	        if ((!this.isRunning) || (!this.enable)) {
	            return this;
	        }

	        if (this.ox === undefined) {
	            return this;
	        }

	        var gameObject = this.parent;

	        switch (this.axisMode) {
	            case 1:
	                gameObject.x = this.ox;
	                break;

	            case 2:
	                gameObject.y = this.oy;
	                break;

	            default:
	                gameObject.x = this.ox;
	                gameObject.y = this.oy;
	                break;
	        }

	        this.ox = undefined;
	        this.oy = undefined;
	        return this;
	    }
	}

	const MODE$3 = {
	    effect: 0,
	    behavior: 1,
	};

	const DIRECTIONNODE = {
	    'both': 0,
	    'h&v': 0,
	    'x&y': 0,
	    'horizontal': 1,
	    'h': 1,
	    'x': 1,
	    'vertical': 2,
	    'v': 2,
	    'y': 2
	};

	const MANITUDEMODE = {
	    constant: 0,
	    decay: 1,
	};

	var AddShakeBehavior = function (gameObject, config) {
	    gameObject.__shakeBehavior = new ShakePosition(gameObject, config);
	};

	var Shake = function (
	    gameObject,
	    {
	        duration,
	        magnitude,
	        wait = true
	    } = {},
	    commandExecutor,
	    eventSheetManager, eventSheet
	) {
	    if (duration === undefined) {
	        duration = eventSheetManager.getData('$shakeDuration');
	    }

	    if (magnitude === undefined) {
	        magnitude = eventSheetManager.getData('$shakeMagnitude');
	    }

	    var shake = gameObject.__shakeBehavior;

	    if (wait) {
	        commandExecutor.waitEvent(shake, 'complete');
	    }

	    shake.shake(duration, magnitude);
	};

	var GenerateDefaultCreateGameObjectCallback$5 = function (
	    style,
	    {
	        viewport
	    } = {},
	    creators
	) {

	    return function (scene, config) {
	        if (!config.hasOwnProperty('scaleMode')) {
	            config.scaleMode = 0;
	        }

	        var gameObject = new TransitionImagePack(scene, config);
	        scene.add.existing(gameObject);

	        AddViewportCoordinateProperties(gameObject, viewport);

	        var {
	            vpx = 0.5, vpy = 0.5,
	            vpw, vph,
	            scaleMode
	        } = config;

	        gameObject.vpx = vpx;
	        gameObject.vpy = vpy;

	        if (scaleMode || (vpw !== undefined) || (vph !== undefined)) {
	            if (vpw === undefined) {
	                vpw = 1;
	            }
	            if (vph === undefined) {
	                vph = 1;
	            }
	            var width = viewport.width * vpw;
	            var height = viewport.height * vph;
	            gameObject.resize(width, height);
	        }

	        AddShakeBehavior(gameObject);

	        return gameObject;
	    }
	};

	var Cross$1 = function (
	    gameObject,
	    {
	        key, frame,
	        duration,
	        mode = 'fade',
	        wait = true
	    } = {},
	    commandExecutor,
	    eventSheetManager, eventSheet
	) {

	    key = key || gameObject.texture.key;

	    if (!frame) {
	        frame = '__BASE';
	    }
	    // Don't do transition if texture is not changed
	    if ((key === gameObject.texture.key) && (frame === gameObject.frame.name)) {
	        return;
	    }

	    if (duration === undefined) {
	        duration = eventSheetManager.getData('$transitionDuration');
	    }

	    // Wait until transition complete
	    if (wait) {
	        commandExecutor.waitEvent(gameObject, 'complete');
	    }

	    gameObject.setDuration(duration);
	    gameObject.transit(key, frame, mode);
	};

	const GetValue$1G = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$u = Phaser.Utils.Objects.IsPlainObject;

	var RegisterBackgroundType = function (commandExecutor, config) {
	    var { viewport } = config;
	    var createGameObjectCallback = GetValue$1G(config, `creators.${BG}`, undefined);
	    if (createGameObjectCallback === false) {
	        return;
	    }
	    if (IsPlainObject$u(createGameObjectCallback)) {
	        createGameObjectCallback = undefined;
	    }

	    if (createGameObjectCallback === undefined) {
	        var style = GetValue$1G(config, `styles.${BG}`, {});
	        createGameObjectCallback = GenerateDefaultCreateGameObjectCallback$5(
	            style,
	            {
	                viewport
	            });
	    }

	    commandExecutor.addGameObjectManager({
	        name: BG,
	        createGameObject: createGameObjectCallback,
	        fade: 0,  // No fade-in when creating/destroying gameobject
	        viewportCoordinate: { viewport },
	        defaultLayer: BGLayer,

	        commands: {
	            cross: Cross$1,
	            shake: Shake,
	        }
	    });
	};

	var GenerateDefaultCreateGameObjectCallback$4 = function (
	    style,
	    {
	        viewport
	    } = {},
	    creators
	) {

	    var defaultKey = style.key;
	    var defaultFrameDelimiter = style.frameDelimiter || '-';

	    return function (
	        scene,
	        config
	    ) {

	        var {
	            key = defaultKey,
	            name, expression,
	            frameDelimiter = defaultFrameDelimiter
	        } = config;

	        var isFrameNameMode = !!key;
	        if (isFrameNameMode) {
	            if (name && expression) {
	                config.frame = name + frameDelimiter + expression;
	            }
	        } else {
	            config.key = name;
	            config.frame = expression;
	        }

	        var gameObject = new TransitionImagePack(scene, config);
	        gameObject.setOrigin(0.5, 1);  // Align to bottom

	        scene.add.existing(gameObject);

	        gameObject.isFrameNameMode = isFrameNameMode;
	        gameObject.frameDelimiter = frameDelimiter;

	        AddViewportCoordinateProperties(gameObject, viewport);

	        var { vpx = 0.5, vpy = 1 } = config;
	        gameObject.vpx = vpx;
	        gameObject.vpy = vpy;

	        var { scale = 1, scaleX = scale, scaleY = scale } = config;
	        gameObject.setScale(scaleX, scaleY);

	        AddShakeBehavior(gameObject);

	        return gameObject;
	    }
	};

	var Cross = function (
	    gameObject,
	    {
	        key, frame,
	        name, expression,
	        duration, mode = 'crossFade',
	        wait = true
	    } = {},

	    commandExecutor, eventSheetManager, eventSheet
	) {

	    if (gameObject.isFrameNameMode) {
	        key = key || gameObject.texture.key;
	        if (name || expression) {
	            var frameDelimiter = gameObject.frameDelimiter;
	            var tokens = gameObject.frame.name.split(frameDelimiter);
	            name = name || tokens[0];
	            expression = expression || tokens[1];
	            frame = name + frameDelimiter + expression;
	        } else {
	            frame = gameObject.frame.name;
	        }

	    } else {
	        key = name || gameObject.texture.key;
	        frame = expression;
	    }

	    Cross$1(
	        gameObject,
	        {
	            key, frame,
	            duration, mode,
	            wait
	        },
	        commandExecutor, eventSheetManager);
	};

	var Focus$1 = function (
	    gameObject,
	    {
	        tintOthers,
	    } = {},

	    commandExecutor, eventSheetManager, eventSheet
	) {

	    if (tintOthers === undefined) {
	        tintOthers = eventSheetManager.getData('$tintOthers');
	    }

	    gameObject.bringMeToTop();

	    commandExecutor.setGOProperty(
	        {
	            goType: SPRITE,
	            id: gameObject.name,
	            tint: 0xffffff,
	        },
	        eventSheetManager
	    );

	    commandExecutor.setGOProperty(
	        {
	            goType: SPRITE,
	            id: '!' + gameObject.name,
	            tint: tintOthers,
	        },
	        eventSheetManager
	    );
	};

	var Focus = function (
	    gameObject,
	    config,

	    commandExecutor, eventSheetManager, eventSheet
	) {

	    commandExecutor.setGOProperty(
	        {
	            goType: SPRITE,
	            tint: 0xffffff,
	        },
	        eventSheetManager
	    );
	};

	var Typing = function (
	    gameObject,
	    {
	        text,
	        displayName,
	        icon, iconFrame,
	        name, expression,
	        typingSpeed,
	        iconCrossDuration, iconCrossMode = 'crossFade',
	        waitIconAnimationMode,
	        more = false,
	        clickAfterComplete = true,
	        wait = true,
	    } = {},

	    commandExecutor, eventSheetManager, eventSheet
	) {

	    if (displayName === null) {
	        var title = gameObject.getElement('title').setText('');
	        gameObject.setChildAlpha(title, 0);
	    } else if (displayName) {
	        var title = gameObject.getElement('title').setText(displayName);
	        gameObject.setChildAlpha(title, 1);
	    }

	    var iconGameObject = gameObject.getElement('icon');
	    if (iconGameObject) {
	        if (name || expression) {
	            var frameDelimiter = gameObject.frameDelimiter;
	            var tokens = gameObject.frame.name.split(frameDelimiter);
	            name = name || tokens[0];
	            expression = expression || tokens[1];
	            iconFrame = name + frameDelimiter + expression;
	        }

	        if (icon || iconFrame) {
	            icon = icon || iconGameObject.texture.key;
	            iconFrame = iconFrame || '__BASE';

	            // Don't do transition if texture is not changed
	            if ((icon !== iconGameObject.texture.key) || (iconFrame !== iconGameObject.frame.name)) {
	                if (iconCrossDuration === undefined) {
	                    iconCrossDuration = eventSheetManager.getData('$transitionDuration');
	                }
	                iconGameObject.setDuration(iconCrossDuration);
	                iconGameObject.transit(icon, iconFrame, iconCrossMode);
	            }

	        }

	        if (icon === null) {
	            gameObject.hide(iconGameObject);
	        } else {
	            gameObject.show(iconGameObject);
	        }
	    }

	    gameObject.layout();

	    if (text) {
	        /* 
	        Using $fastTypingSpeed speed in $fastTyping mode,
	        Otherwise using custom typingSpeed, or default typing speed
	        */

	        // Store gameObject.normalTypingSpeed
	        if (typingSpeed === undefined) {
	            gameObject.normalTypingSpeed = eventSheetManager.getData('$typingSpeed');
	        } else {
	            gameObject.normalTypingSpeed = typingSpeed;
	        }

	        var fastTyping = eventSheetManager.getData('$fastTyping');
	        if (fastTyping) {
	            typingSpeed = eventSheetManager.getData('$fastTypingSpeed');
	        } else if (typingSpeed === undefined) {
	            typingSpeed = gameObject.normalTypingSpeed;
	        }

	        if (clickAfterComplete) {
	            // Wait until typing complete, then one more clicking.
	            commandExecutor.waitEvent(gameObject, 'complete2');
	        } else if (wait) {
	            // Wait until typing complete
	            commandExecutor.waitEvent(gameObject, 'complete');
	        }

	        if (!more) {
	            gameObject.start(text, typingSpeed);
	        } else {
	            gameObject.more(text, typingSpeed);
	        }
	        gameObject.complete2Flag = false;
	        // Fire 'start' event, see GenerateDefaultCreateGameObjectCallback
	    }

	    if (waitIconAnimationMode) {
	        var icon = gameObject.getElement('action');
	        if (icon && icon.setAnimationMode) {
	            icon.setAnimationMode(waitIconAnimationMode);
	        }
	    }
	};

	var Say = function (
	    gameObject,
	    {
	        key, frame,
	        name, expression,
	        duration, mode = 'crossFade',
	        tintOthers,
	        text,
	        more = false,
	        displayName,
	        typingSpeed,
	        icon, iconFrame,
	        iconCrossDuration, iconCrossMode = 'crossFade',
	        waitIconAnimationMode,
	        clickAfterComplete = true,
	        wait = true
	    } = {},

	    commandExecutor, eventSheetManager, eventSheet
	) {

	    Cross(
	        gameObject,
	        {
	            key, frame,
	            name, expression,
	            duration, mode,
	            wait: false
	        },
	        commandExecutor, eventSheetManager);

	    Focus$1(
	        gameObject,
	        {
	            tintOthers
	        },
	        commandExecutor, eventSheetManager);

	    var textbox = commandExecutor.sys.getGameObject(TEXTBOX, undefined)[0];
	    if (textbox) {
	        Typing(
	            textbox,
	            {
	                text,
	                displayName,
	                icon, iconFrame,
	                name, expression,
	                typingSpeed,
	                iconCrossDuration, iconCrossMode,
	                more,
	                waitIconAnimationMode,
	                clickAfterComplete,
	                wait
	            },
	            commandExecutor, eventSheetManager);
	    }

	};

	const GetValue$1F = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$t = Phaser.Utils.Objects.IsPlainObject;

	var RegisterSpriteType = function (commandExecutor, config) {
	    var { viewport } = config;
	    var createGameObjectCallback = GetValue$1F(config, `creators.${SPRITE}`, undefined);
	    if (createGameObjectCallback === false) {
	        return;
	    }
	    if (IsPlainObject$t(createGameObjectCallback)) {
	        createGameObjectCallback = undefined;
	    }

	    if (createGameObjectCallback === undefined) {
	        var style = GetValue$1F(config, `styles.${SPRITE}`, {});
	        createGameObjectCallback = GenerateDefaultCreateGameObjectCallback$4(
	            style,
	            {
	                viewport
	            });
	    }

	    commandExecutor.addGameObjectManager({
	        name: SPRITE,
	        createGameObject: createGameObjectCallback,
	        fade: 0,  // No fade-in when creating/destroying gameobject
	        viewportCoordinate: { viewport },
	        defaultLayer: GOLayer,

	        commands: {
	            cross: Cross,
	            focus: Focus$1,
	            unfocus: Focus,
	            say: Say,
	            shake: Shake
	        }
	    });
	};

	const TextClass = Phaser.GameObjects.Text;

	var IsTextGameObject = function (gameObject) {
	    return (gameObject instanceof TextClass);
	};

	const BitmapTextClass = Phaser.GameObjects.BitmapText;

	var IsBitmapTextGameObject = function (gameObject) {
	    return (gameObject instanceof BitmapTextClass);
	};

	const TextType = 0;
	const TagTextType = 1;
	const BitmapTextType = 2;

	var GetTextObjectType = function (textObject) {
	    var textObjectType;
	    if (IsBitmapTextGameObject(textObject)) {
	        textObjectType = BitmapTextType;
	    } else if (IsTextGameObject(textObject)) {
	        textObjectType = TextType;
	    } else {
	        textObjectType = TagTextType;
	    }

	    return textObjectType;
	};

	var TextToLines = function (textObject, text, lines) {
	    var textObjectType = GetTextObjectType(textObject);
	    switch (textObjectType) {
	        case TextType:
	            lines = textObject.getWrappedText(text); // Array of string
	            break;
	        case TagTextType:
	            lines = textObject.getPenManager(text, lines); // Pens-manager
	            break;
	        case BitmapTextType:
	            if (textObject.maxWidth > 0) {
	                lines = textObject.setText(text).getTextBounds().wrappedText.split('\n');
	            } else {
	                lines = text.split('\n');
	            }

	            break;
	    }
	    return lines;
	};

	var TextHeightToLinesCount$1 = function (textObject) {
	    var textObjectType = GetTextObjectType(textObject);
	    var height, lineSpacing, lineHeight;
	    switch (textObjectType) {
	        case TextType:
	        case TagTextType:
	            height = textObject.height - textObject.padding.top - textObject.padding.bottom;
	            lineSpacing = textObject.lineSpacing;
	            lineHeight = textObject.style.metrics.fontSize + textObject.style.strokeThickness;
	            break;

	        case BitmapTextType:
	            height = textObject.height;
	            lineSpacing = 0;
	            var scale = (textObject.fontSize / textObject.fontData.size);
	            lineHeight = textObject.fontData.lineHeight * scale;
	            break;
	    }

	    // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
	    return (height - lineSpacing) / (lineHeight + lineSpacing);

	};

	var GetLines$1 = function (startLineIndex, endLineIdx) {
	    if (startLineIndex === undefined) {
	        startLineIndex = this.startLineIndex;
	    }
	    if (endLineIdx === undefined) {
	        var pageLinesCount = this.pageLinesCount;
	        if (pageLinesCount > 0) {
	            endLineIdx = startLineIndex + pageLinesCount;
	        } else {
	            endLineIdx = this.totalLinesCount;
	        }
	    }
	    if (endLineIdx > this.totalLinesCount) {
	        endLineIdx = this.totalLinesCount;
	    }

	    var text;
	    switch (this.textObjectType) {
	        case TextType:
	        case BitmapTextType:
	            text = this.lines.slice(startLineIndex, endLineIdx).join('\n');
	            break;
	        case TagTextType:
	            var startIdx = this.lines.getLineStartIndex(startLineIndex);
	            var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
	            text = this.lines.getSliceTagText(startIdx, endIdx, true);

	            // Check line count
	            var newLineCharCount = (text.match(/\n/g) || []).length;
	            if (newLineCharCount > (endLineIdx - startLineIndex - 1)) {
	                // Remove last '\n'
	                text = text.substring(0, text.length - 1);
	            }

	            break;
	    }

	    return text;
	};

	var GetString = function (value) {
	    if (value == null) {
	        value = '';
	    } else if (Array.isArray(value)) {
	        value = value.join('\n');
	    } else if (typeof (value) === 'number') {
	        value = value.toString();
	    }
	    return value;
	};

	var SetContentMethods = {
	    clearText() {
	        this.sections.length = 0;
	        this.pageStartIndexes.length = 0;
	        this.lines.length = 0;

	        return this;
	    },

	    appendPage(text) {
	        var pageStartIndex = this.totalLinesCount;

	        this.sections.push(GetString(text));
	        var text = this.sections.join('\n');
	        this.lines = TextToLines(this.parent, text, this.lines);

	        var newLinesCount = this.totalLinesCount - pageStartIndex;
	        var pageLinesCount = this.pageLinesCount;
	        var pageCount;
	        if (pageLinesCount > 0) {
	            pageCount = Math.ceil(newLinesCount / this.pageLinesCount);
	        } else {  // Height of Text object might be 0
	            pageCount = 1;
	        }

	        for (var i = 0; i < pageCount; i++) {
	            this.pageStartIndexes.push(
	                pageStartIndex + (i * this.pageLinesCount)
	            );
	        }

	        return this;
	    },

	    setText(text, resetIndex) {
	        if (resetIndex === undefined) {
	            resetIndex = true;
	        }

	        if (resetIndex) {
	            this.resetIndex();
	        }

	        this.clearText();

	        var sections = GetString(text).split(this.pageBreak);
	        // if (sections[sections.length - 1] === '') { // Last section is an empty string
	        //     sections.length -= 1;
	        // }

	        for (var i = 0, cnt = sections.length; i < cnt; i++) {
	            this.appendPage(sections[i]);
	        }

	        return this;
	    },

	    appendText(text) {
	        var content = this.content + GetString(text);
	        this.setText(content, false);
	        return this;
	    },


	};

	const Clamp$4 = Phaser.Math.Clamp;

	var GetPageMethods = {

	    resetIndex() {
	        this.pageIndex = -1;
	        this.startLineIndex = -1;
	        this.endLineIndex = undefined;
	        return this;
	    },

	    setPageIndex(idx) {
	        idx = Clamp$4(idx, 0, this.lastPageIndex);
	        this.pageIndex = idx;
	        this.startLineIndex = this.pageStartIndexes[idx];
	        this.endLineIndex = this.pageStartIndexes[idx + 1];
	        return this;
	    },

	    getPage(idx) {
	        if (idx === undefined) {
	            idx = this.pageIndex;
	        }

	        return this.setPageIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
	    },

	    getNextPage() {
	        return this.getPage(this.pageIndex + 1);
	    },

	    getPreviousPage() {
	        return this.getPage(this.pageIndex - 1);
	    },

	    getFirstPage() {
	        return this.getPage(0);
	    },

	    getLastPage() {
	        return this.getPage(this.lastPageIndex);
	    },

	    setStartLineIndex(idx) {
	        var lastStartLineIndex = Math.max(this.totalLinesCount - this.pageLinesCount, 0);
	        idx = Clamp$4(idx, 0, lastStartLineIndex);

	        this.startLineIndex = idx;
	        this.endLineIndex = idx + this.pageLinesCount;
	        return this;
	    },

	    getPageByLineIndex(idx) {
	        return this.setStartLineIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
	    },

	    getPageOfNextLine() {
	        return this.getPageByLineIndex(this.startLineIndex + 1);
	    },

	    getPageOfPreviousLine() {
	        return this.getPageByLineIndex(this.startLineIndex - 1);
	    },

	    getPageOfFirstLine() {
	        return this.getPageByLineIndex(0);
	    },

	    getPageOfLastLine() {
	        return this.getPageByLineIndex(this.totalLinesCount);
	    },

	};

	var SetNoWrapText = function (textObject, text) {
	    var textObjectType = GetTextObjectType(textObject);
	    switch (textObjectType) {
	        case TextType:
	            // Store wrap properties
	            var style = textObject.style;
	            var wordWrapWidth = style.wordWrapWidth;
	            var wordWrapCallback = style.wordWrapCallback;
	            // Disable wrap
	            style.wordWrapWidth = 0;
	            style.wordWrapCallback = undefined;
	            // Set text
	            textObject.setText(text);
	            // Restore wrap
	            style.wordWrapWidth = wordWrapWidth;
	            style.wordWrapCallback = wordWrapCallback;
	            break;

	        case TagTextType:
	            // Store wrap properties
	            var style = textObject.style;
	            var wrapMode = style.wrapMode;
	            // Disable wrap
	            style.wrapMode = 0;
	            // Set text
	            textObject.setText(text);
	            // Restore wrap
	            style.wrapMode = wrapMode;
	            break;

	        case BitmapTextType:
	            // Store wrap properties
	            var maxWidth = textObject._maxWidth;
	            // Disable wrap
	            textObject._maxWidth = 0;
	            // Set text
	            textObject.setText(text);
	            // Restore wrap
	            textObject._maxWidth = maxWidth;
	            break;
	    }
	};

	var ShowMethods = {
	    showPage(idx) {
	        this.displayText(
	            this.getPage(idx)
	        );
	        return this;
	    },

	    showNextPage() {
	        this.displayText(
	            this.getNextPage()
	        );
	        return this;
	    },

	    showPreviousPage() {
	        this.displayText(
	            this.getPreviousPage()
	        );
	        return this;
	    },

	    showFirstPage() {
	        this.displayText(
	            this.getFirstPage()
	        );
	        return this;
	    },

	    showLastPage() {
	        this.displayText(
	            this.getLastPage()
	        );
	        return this;
	    },

	    show() {
	        this.displayText(
	            this.getLines()
	        );
	        return this;
	    },

	    showPageByLineIndex(lineIndex) {
	        this.displayText(
	            this.getPageByLineIndex(lineIndex)
	        );
	        return this;
	    },

	    showNextLine() {
	        this.displayText(
	            this.getPageOfNextLine()
	        );
	        return this;
	    },

	    showPreviousLine() {
	        this.displayText(
	            this.getPageOfPreviousLine()
	        );
	        return this;
	    },

	    showFirstLine() {
	        this.displayText(
	            this.getPageOfFirstLine()
	        );
	        return this;
	    },

	    showLastLine() {
	        this.displayText(
	            this.getPageOfLastLine()
	        );
	        return this;
	    },

	    displayText(text) {
	        SetNoWrapText(this.parent, text);
	    }
	};

	var Methods$a = {   
	    getLines: GetLines$1,
	};

	Object.assign(
	    Methods$a,
	    SetContentMethods,
	    GetPageMethods,
	    ShowMethods
	);

	const GetValue$1E = Phaser.Utils.Objects.GetValue;
	Phaser.Math.Clamp;

	class TextPage extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, { eventEmitter: false });
	        // No event emitter
	        // this.parent = gameObject;

	        this.textObjectType = GetTextObjectType(this.parent);

	        this.pageStartIndexes = [];

	        // Text object : array of string
	        // Tag text object : pens-manager
	        // Bitmap text object : array of string
	        this.lines = TextToLines(this.parent, '');

	        this.sections = [];

	        this.resetFromJSON(config);
	    }

	    resetFromJSON(o) {
	        this.setMaxLines(GetValue$1E(o, 'maxLines', undefined));
	        this.setPageBreak(GetValue$1E(o, 'pageBreak', '\f\n'));
	        this.setText(GetValue$1E(o, 'text', ''));

	        this.startLineIndex = GetValue$1E(o, 'start', -1);
	        this.endLineIndex = GetValue$1E(o, 'end', undefined);

	        var pageIndex = GetValue$1E(o, 'page');
	        if (pageIndex === undefined) {
	            this.resetIndex();
	        } else {
	            this.setPageIndex(pageIndex);
	        }

	        return this;
	    }

	    toJSON() {
	        return {
	            maxLines: this.maxLines,
	            text: this.content,
	            start: this.startLineIndex,
	            end: this.endLineIndex,
	            page: this.pageIndex,
	            pageBreak: this.pageBreak
	        };
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        switch (this.textObjectType) {
	            case TextType:
	                this.lines.length = 0;
	                break;
	            case TagTextType:
	                this.lines.destroy();
	                break;
	            case BitmapTextType:
	                this.lines.length = 0;
	                break;
	        }

	        this.pageStartIndexes.length = 0;
	        this.sections.length = 0;

	        this.lines = undefined;
	        this.pageStartIndexes = undefined;
	        this.sections = undefined;

	        super.shutdown(fromScene);
	    }

	    setMaxLines(maxLines) {
	        this.maxLines = maxLines;
	        return this;
	    }

	    setPageBreak(pageBreak) {
	        this.pageBreak = pageBreak;
	        return this;
	    }

	    get pageCount() {
	        return this.pageStartIndexes.length;
	    }

	    get lastPageIndex() {
	        return this.pageCount - 1;
	    }

	    get isFirstPage() {
	        return (this.pageIndex <= 0);
	    }

	    get isLastPage() {
	        return (this.pageIndex >= (this.pageCount - 1));
	    }

	    get totalLinesCount() {
	        return (this.lines) ? this.lines.length : 0;
	    }

	    get pageLinesCount() {
	        // Since the line height of each line is the same, 
	        // each page will have the same number of lines

	        if (this.maxLines !== undefined) {
	            return this.maxLines;

	        } else {
	            var count;
	            switch (this.textObjectType) {
	                case TextType:
	                case TagTextType:
	                    var maxLines = this.parent.style.maxLines;
	                    if (maxLines > 0) {
	                        count = maxLines;
	                    } else {
	                        count = Math.floor(TextHeightToLinesCount$1(this.parent));
	                    }
	                    break;
	                case BitmapTextType:
	                    count = this.totalLinesCount;
	                    break;
	            }
	            return count;

	        }
	    }

	    get isFirstLine() {
	        return (this.startLineIndex <= 0);
	    }

	    get isLastLine() {
	        return this.endLineIndex === this.totalLinesCount;
	    }

	    get content() {
	        return this.sections.join(this.pageBreak);
	    }
	}

	Object.assign(
	    TextPage.prototype,
	    Methods$a,
	);

	var SetTextMethods$1 = {
	    setText(text) {
	        if (this.setTextCallback) {
	            if (this.setTextCallbackScope) {
	                text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIndex);
	            } else {
	                text = this.setTextCallback(text, this.isLastChar, this.insertIndex);
	            }
	        }

	        if (this.textWrapEnable) {
	            SetNoWrapText(this.parent, text);
	        } else {
	            this.parent.setText(text);
	        }
	    },

	    appendText(text) {
	        var newText = this.text.concat(GetString(text));
	        if (this.isTyping) {
	            this.setTypingContent(newText);
	        } else {
	            this.start(newText, undefined, this.textLength);
	        }

	        return this;
	    }

	};

	var StartTyping = function (text, speed, startIndex, timerStartAt) {
	    if (text !== undefined) {
	        this.setTypingContent(text);
	    }
	    if (speed !== undefined) {
	        this.speed = speed;
	    }
	    if (startIndex === undefined) {
	        startIndex = 0;
	    }

	    this.typingIndex = startIndex + 1;
	    if (this.speed === 0) {
	        this.stop(true);
	    } else {
	        this.setText('');
	        this.startTimer(timerStartAt);
	    }

	    return this;
	};

	var GetPlainText = function (textObject, text) {
	    if (textObject.getPlainText) {
	        text = textObject.getPlainText(text);
	    }

	    return text;
	};

	var StartTypingFromLine = function (text, lineIndex, speed, offsetIndex, timerStartAt) {
	    var startIdx;
	    if (lineIndex > 0) {
	        if (offsetIndex === undefined) {
	            offsetIndex = 0;
	        }

	        var plainText = GetPlainText(this.parent, text);
	        startIdx = GetNewLineIndex(plainText, lineIndex) + offsetIndex;
	    }
	    return this.start(text, speed, startIdx, timerStartAt);
	};

	var GetNewLineIndex = function (s, n) {
	    var index = undefined;
	    for (var i = 0; i < n; i++) {
	        index = s.indexOf('\n', index + 1);
	        if (index === -1) {
	            break;
	        }
	    }
	    return index;
	};

	var GetSubString = function (textObject, text, startIdx, endIdx) {
	    var result;
	    if (textObject.getSubString) {
	        result = textObject.getSubString(text, startIdx, endIdx);
	    } else {
	        result = text.slice(startIdx, endIdx);
	    }

	    return result;
	};

	var GetTypingString = function (text, typeIdx, textLength, typeMode) {
	    var textObject = this.parent;
	    var result;
	    if (typeMode === 0) { //left-to-right
	        var startIdx = 0;
	        var endIdx = typeIdx;
	        this.insertIndex = endIdx;
	        result = GetSubString(textObject, text, startIdx, endIdx);

	    } else if (typeMode === 1) { //right-to-left
	        var endIdx = textLength;
	        var startIdx = endIdx - typeIdx;
	        this.insertIndex = 0;
	        result = GetSubString(textObject, text, startIdx, endIdx);

	    } else if (typeMode === 2) { //middle-to-sides
	        var midIdx = textLength / 2;
	        var startIdx = Math.floor(midIdx - (typeIdx / 2));
	        var endIdx = startIdx + typeIdx;
	        this.insertIndex = (typeIdx % 2) ? typeIdx : 0;
	        result = GetSubString(textObject, text, startIdx, endIdx);

	    } else if (typeMode === 3) { //sides-to-middle
	        var lowerLen = Math.floor(typeIdx / 2);
	        var lowerResult;
	        if (lowerLen > 0) {
	            var endIdx = textLength;
	            var startIdx = endIdx - lowerLen;
	            lowerResult = GetSubString(textObject, text, startIdx, endIdx);
	        } else {
	            lowerResult = "";
	        }

	        var upperLen = typeIdx - lowerLen;
	        var upperResult;
	        if (upperLen > 0) {
	            var startIdx = 0;
	            var endIdx = startIdx + upperLen;
	            this.insertIndex = endIdx;
	            upperResult = GetSubString(textObject, text, startIdx, endIdx);
	        } else {
	            upperResult = "";
	            this.insertIndex = 0;
	        }
	        result = upperResult + lowerResult;
	    }

	    this.insertChar = result.charAt(this.insertIndex - 1);

	    return result;
	};

	var StopTyping = function (showAllText) {
	    var timer = this.getTimer();
	    if (timer) {
	        this.freeTimer();
	    }
	    if (showAllText) {
	        // Fire 'type' event for remainder characters until lastChar
	        while (!this.isLastChar) {
	            GetTypingString.call(this, this.text, this.typingIndex, this.textLength, this.typeMode);
	            this.emit('typechar', this.insertChar);
	            this.typingIndex++;
	        }
	        // Display all characters on text game object
	        this.setText(this.text);
	        this.emit('type');
	        this.emit('complete', this, this.parent);
	    }

	    return this;
	};

	var PauseTyping = function () {
	    var timer = this.getTimer();
	    if (timer) {
	        timer.paused = true;
	    }
	    return this;
	};

	var ResumeTyping = function () {
	    var timer = this.getTimer();
	    if (timer) {
	        timer.paused = false;
	    }
	    return this;
	};

	var methods$i = {
	    start: StartTyping,
	    startFromLine: StartTypingFromLine,
	    stop: StopTyping,
	    pause: PauseTyping,
	    resumeTyping: ResumeTyping,
	};

	Object.assign(
	    methods$i,
	    SetTextMethods$1
	);

	var GetWrapText = function (textObject, text) {
	    var textObjectType = GetTextObjectType(textObject);
	    switch (textObjectType) {
	        case TextType:
	            textObject.style.syncFont(textObject.canvas, textObject.context);
	            text = textObject.runWordWrap(text);
	            break;
	        case TagTextType:
	            text = textObject.getText(text, undefined, undefined, true);
	            break;
	        case BitmapTextType:
	            text = textObject.setText(text).getTextBounds().wrappedText;
	            break;
	    }
	    return text;
	};

	const GetFastValue$2 = Phaser.Utils.Objects.GetFastValue;
	const GetValue$1D = Phaser.Utils.Objects.GetValue;

	class TextTyping extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        this.timer = null;
	        this.resetFromJSON(config);
	    }

	    resetFromJSON(o) {
	        this.setTextWrapEnable(GetValue$1D(o, 'wrap', false));
	        this.setTypeMode(GetValue$1D(o, 'typeMode', 0));
	        this.setTypingSpeed(GetValue$1D(o, 'speed', 333));
	        this.setTextCallback = GetFastValue$2(o, 'setTextCallback', null);
	        this.setTextCallbackScope = GetFastValue$2(o, 'setTextCallbackScope', null);

	        this.setTypingContent(GetFastValue$2(o, 'text', ''));
	        this.typingIndex = GetFastValue$2(o, 'typingIndex', 0);
	        this.insertIndex = null;
	        this.insertChar = null;

	        var elapsed = GetFastValue$2(o, 'elapsed', null);
	        if (elapsed !== null) {
	            this.start(undefined, undefined, this.typingIndex, elapsed);
	        }

	        return this;
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        this.freeTimer();

	        super.shutdown(fromScene);
	    }

	    setTypeMode(m) {
	        if (typeof (m) === 'string') {
	            m = TYPEMODE[m];
	        }
	        this.typeMode = m;
	        return this;
	    }

	    setTypeSpeed(speed) {
	        this.speed = speed;
	        return this;
	    }

	    setTypingSpeed(speed) {
	        this.speed = speed;
	        return this;
	    }

	    setTextWrapEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.textWrapEnable = enable;
	        return this;
	    }

	    set text(value) {
	        var text = GetString(value);
	        if (this.textWrapEnable) {
	            text = GetWrapText(this.parent, text);
	        }

	        this._text = text;
	    }

	    get text() {
	        return this._text;
	    }

	    get isTyping() {
	        return (this.getTimer() !== null);
	    }

	    get isLastChar() {
	        return (this.typingIndex === this.textLength);
	    }

	    setTypingContent(text) {
	        this.text = text;
	        this.textLength = GetPlainText(this.parent, this.text).length;
	        return this;
	    }

	    onTyping() {
	        var newText = GetTypingString.call(this, this.text, this.typingIndex, this.textLength, this.typeMode);

	        this.setText(newText);

	        this.emit('typechar', this.insertChar);
	        this.emit('type');

	        if (this.isLastChar) {
	            this.freeTimer();
	            // Fire 'complete' next tick, to render last character on screen
	            this.scene.sys.events.once('preupdate', function () {
	                this.emit('complete', this, this.parent);
	            }, this);
	        } else {
	            this.timer.delay = this.speed; // delay of next typing            
	            this.typingIndex++;
	        }
	    }

	    startTimer(timerStartAt) {
	        if (this.timer) {
	            this.freeTimer();
	        }
	        var startAt;
	        if (timerStartAt === undefined) {
	            startAt = 0;
	        } else {
	            this.speed;
	            startAt = timerStartAt;
	        }

	        this.timer = this.scene.time.addEvent({
	            delay: 0.0001,
	            startAt: startAt,
	            loop: true,
	            callback: this.onTyping,
	            callbackScope: this
	        });
	        // Note: Throw error message if delay is 0 with repeat/loop

	        return this;
	    }

	    getTimer() {
	        return this.timer;
	    }

	    freeTimer() {
	        if (this.timer) {
	            this.timer.remove();
	            this.timer = null;
	        }

	        return this;
	    }

	    setText(text) {
	        if (this.setTextCallback) {
	            if (this.setTextCallbackScope) {
	                text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIndex);
	            } else {
	                text = this.setTextCallback(text, this.isLastChar, this.insertIndex);
	            }
	        }

	        if (this.textWrapEnable) {
	            SetNoWrapText(this.parent, text);
	        } else {
	            this.parent.setText(text);
	        }
	    }
	}

	const TYPEMODE = {
	    'left-to-right': 0,
	    'right-to-left': 1,
	    'middle-to-sides': 2,
	    'sides-to-middle': 3
	};

	Object.assign(
	    TextTyping.prototype,
	    methods$i
	);

	const GetValue$1C = Phaser.Utils.Objects.GetValue;

	var TextBoxBase = function (GOClass, type) {
	    if (type === undefined) {
	        type = 'rexTextBox';
	    }
	    class TextBox extends GOClass {
	        constructor(scene, config) {
	            super(scene, config);
	            this.type = type;
	            this.isRunning = false;
	            this._isPageEnd = false;

	            // childrenMap must have 'text' element
	            var text = this.childrenMap.text;

	            // Expand text size
	            var expandTextWidth = GetValue$1C(config, 'expandTextWidth', false);
	            var expandTextHeight = GetValue$1C(config, 'expandTextHeight', false);
	            if (expandTextWidth || expandTextHeight) {
	                var textObjectType = GetTextObjectType(text);
	                switch (textObjectType) {
	                    case TextType:
	                    case TagTextType:
	                        // Don't overwrite resize method if text has it already
	                        text.resize = function (width, height) {
	                            var fixedWidth = (expandTextWidth) ? width : 0;
	                            var fixedHeight = (expandTextHeight) ? height : 0;
	                            text.setFixedSize(fixedWidth, fixedHeight);

	                            if (fixedWidth > 0) {
	                                text.setWordWrapWidth(fixedWidth);
	                            }
	                        };

	                        if (textObjectType === TagTextType) {
	                            var style = text.style;
	                            if (style.wrapMode === 0) { // Turn no-wrap to word-wrap
	                                style.wrapMode = 1;
	                            }
	                        }
	                        break;

	                }

	                if (expandTextWidth) {
	                    text._minWidth = 0;
	                }
	                if (expandTextHeight) {
	                    text._minHeight = 0;
	                }
	            }

	            // Build typing and page behaviors
	            this.setTypingMode(GetValue$1C(config, 'typingMode', 'page'));
	            this.page = new TextPage(text, GetValue$1C(config, 'page', undefined));
	            this.typing = new TextTyping(text, GetValue$1C(config, 'typing', config.type));
	            this.typing
	                .on('complete', this.onTypingComplete, this)
	                .on('type', this.onType, this)
	                .on('typechar', this.onTypeChar, this);

	            // Run layout again when size of text game object has changed
	            this.textWidthSave = text.width;
	            this.textHeightSave = text.height;
	        }

	        setTypingMode(mode) {
	            if (typeof (mode) === 'string') {
	                mode = TypingMode[mode];
	            }
	            this.typingMode = mode;
	            return this;
	        }

	        start(text, speed) {
	            if (speed !== undefined) {
	                this.setTypingSpeed(speed);
	            }

	            // Start typing task
	            this.isRunning = true;

	            this.page.setText(text);

	            this.emit('start');

	            if (this.typingMode === 0) {
	                // Typing page by page
	                this.typeNextPage();
	            } else {
	                // Typing line by line
	                this.typeNextLine();
	            }
	            return this;
	        }

	        more(text, speed) {
	            if (speed !== undefined) {
	                this.setTypingSpeed(speed);
	            }

	            if (this.isRunning) {
	                this.page.appendText(text);
	                this.typing.appendText(text);

	            } else {
	                this.isRunning = true;

	                this.page.appendText(text);

	                this.emit('start');

	                if (this.typingMode === 0) {
	                    this._isPageEnd = false;
	                    var txt = this.page.getPage();
	                    var startIndex = this.typing.textLength;
	                    this.typing.start(txt, undefined, startIndex);

	                }
	                return this;
	            }
	        }

	        typeNextPage() {
	            // Do nothing if typing task does not start
	            if (!this.isRunning) {
	                return this;
	            }

	            if (!this.isLastPage) {
	                this._isPageEnd = false;
	                var txt = this.page.getNextPage();
	                this.typing.start(txt);

	            } else {
	                this.emit('complete');

	            }
	            return this;
	        }

	        typeNextLine() {
	            // Do nothing if typing task does not start
	            if (!this.isRunning) {
	                return this;
	            }

	            if (!this.isLastLine) {
	                var txt = this.page.getPageOfNextLine();

	                var startLineIndex;
	                if (this.isFirstLine) {
	                    // Typing from 1st line
	                    startLineIndex = 0;
	                } else {
	                    // Typing last line
	                    startLineIndex = this.page.pageLinesCount - 1;
	                }
	                this.typing.startFromLine(txt, startLineIndex);

	            } else {
	                // Stop typing tasl if typing complete at last line

	                this.isRunning = false;
	                this.emit('pageend');
	                this.emit('complete');

	            }
	        }

	        pause() {
	            // Do nothing if typing task does not start
	            if (!this.isRunning) {
	                return this;
	            }

	            if (this.isTyping) {
	                this.typing.pause();
	                this.emit('pause');
	            }
	            return this;
	        }

	        resume() {
	            // Do nothing if typing task does not start
	            if (!this.isRunning) {
	                return this;
	            }

	            if (!this.isTyping) {
	                this.emit('resume');
	                this.typing.resume();
	            }
	            return this;
	        }

	        stop(showAllText) {
	            // Do nothing if typing task does not start
	            if (!this.isRunning) {
	                return this;
	            }

	            this.typing.stop(showAllText);
	            return this;
	        }

	        showLastPage() {
	            // Do nothing if typing task does not start
	            if (!this.isRunning) {
	                return this;
	            }

	            this.typing.stop();
	            if (this.typingMode === 0) {
	                this.page.showLastPage();
	            } else {
	                this.page.showLastLine();
	            }
	            this.emit('type');
	            this.onTypingComplete();
	            return this;
	        }

	        setTypeSpeed(speed) {
	            this.typing.setTypingSpeed(speed);
	            return this;
	        }

	        setTypingSpeed(speed) {
	            this.typing.setTypingSpeed(speed);
	            return this;
	        }

	        get isTyping() {
	            return this.typing.isTyping;
	        }

	        get isPageEnd() {
	            return this._isPageEnd;
	        }

	        get isLastPage() {
	            return this.page.isLastPage;
	        }

	        get isFirstPage() {
	            return this.page.isFirstPage;
	        }

	        get pageCount() {
	            return this.page.pageCount;
	        }

	        get pageIndex() {
	            return this.page.pageIndex;
	        }

	        get isLastLine() {
	            return this.page.isLastLine;
	        }

	        get isFirstLine() {
	            return this.page.isFirstLine;
	        }

	        get lineCound() {
	            return this.page.totalLinesCount;
	        }

	        get startLineIndex() {
	            return this.page.startLineIndex;
	        }

	        get endLineIndex() {
	            return this.page.endLineIndex;
	        }

	        get typingSpeed() {
	            return this.typing.speed;
	        }

	        onType() {
	            var text = this.childrenMap.text;
	            if ((this.textWidthSave !== text.width) || (this.textHeightSave !== text.height)) {
	                this.textWidthSave = text.width;
	                this.textHeightSave = text.height;
	                this.getTopmostSizer().layout();
	            }
	            this.emit('type');
	        }

	        onTypeChar(char) {
	            this.emit('typechar', char);
	        }

	        onTypingComplete() {
	            if (this.typingMode === 0) {
	                this._isPageEnd = true;
	                var isLastPage = this.isLastPage;

	                // Stop typing tasl if typing complete at last page
	                this.isRunning = !isLastPage;

	                this.emit('pageend');
	                /*
	                Might enter this method immediately, if invoking typeNextPage() in this 'pageend' event.
	                */

	                if (isLastPage) {
	                    this.emit('complete');
	                }

	            } else {
	                // Typing next line continually
	                this.typeNextLine();

	            }

	        }

	    }

	    return TextBox;
	};

	const TypingMode = {
	    page: 0,
	    line: 1
	};

	var GetSizerConfig$1 = function (gameObject) {
	    if (!gameObject.hasOwnProperty('rexSizer')) {
	        gameObject.rexSizer = {};
	    }
	    return gameObject.rexSizer;
	};

	function GetSizerConfig (gameObject) {
	    if (gameObject === undefined) {
	        gameObject = this;
	    }
	    return GetSizerConfig$1(gameObject);
	}

	var GetChildPrevState = function (child) {
	    var childConfig = GetSizerConfig$1(child);
	    if (!childConfig.hasOwnProperty('prevState')) {
	        childConfig.prevState = {};
	    }
	    return childConfig.prevState;
	};

	var PushIntoBounds = function (bounds) {
	    if (bounds === undefined) {
	        bounds = GetViewport(this.scene);
	    }

	    this.left = Math.max(this.left, bounds.left);
	    this.right = Math.min(this.right, bounds.right);
	    this.top = Math.max(this.top, bounds.top);
	    this.bottom = Math.min(this.bottom, bounds.bottom);
	    return this;
	};

	const ALIGN$1 = Phaser.Display.Align;
	var AlignConst = {
	    center: ALIGN$1.CENTER,
	    left: ALIGN$1.LEFT_CENTER,
	    right: ALIGN$1.RIGHT_CENTER,
	    top: ALIGN$1.TOP_CENTER,
	    bottom: ALIGN$1.BOTTOM_CENTER,

	    'left-top': ALIGN$1.TOP_LEFT,
	    'top-left': ALIGN$1.TOP_LEFT,

	    'left-center': ALIGN$1.LEFT_CENTER,
	    'center-left': ALIGN$1.LEFT_CENTER,

	    'left-bottom': ALIGN$1.BOTTOM_LEFT,
	    'bottom-left': ALIGN$1.BOTTOM_LEFT,

	    'center-top': ALIGN$1.TOP_CENTER,
	    'top-center': ALIGN$1.TOP_CENTER,

	    'center-center': ALIGN$1.CENTER,

	    'center-bottom': ALIGN$1.BOTTOM_CENTER,
	    'bottom-center': ALIGN$1.BOTTOM_CENTER,

	    'right-top': ALIGN$1.TOP_RIGHT,
	    'top-right': ALIGN$1.TOP_RIGHT,

	    'right-center': ALIGN$1.RIGHT_CENTER,
	    'center-right': ALIGN$1.RIGHT_CENTER,

	    'right-bottom': ALIGN$1.BOTTOM_RIGHT,
	    'bottom-right': ALIGN$1.BOTTOM_RIGHT,
	};

	var NOOP = function () {
	    //  NOOP
	};

	var globZone = new Phaser.GameObjects.Zone({
	    sys: {
	        queueDepthSort: NOOP,
	        events: {
	            once: NOOP
	        }
	    }
	}, 0, 0, 1, 1);
	globZone.setOrigin(0);

	var ALIGN_CONST = {

	    /**
	    * A constant representing a top-left alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.TOP_LEFT
	    * @since 3.0.0
	    * @type {integer}
	    */
	    TOP_LEFT: 0,

	    /**
	    * A constant representing a top-center alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.TOP_CENTER
	    * @since 3.0.0
	    * @type {integer}
	    */
	    TOP_CENTER: 1,

	    /**
	    * A constant representing a top-right alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.TOP_RIGHT
	    * @since 3.0.0
	    * @type {integer}
	    */
	    TOP_RIGHT: 2,

	    /**
	    * A constant representing a left-top alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.LEFT_TOP
	    * @since 3.0.0
	    * @type {integer}
	    */
	    LEFT_TOP: 3,

	    /**
	    * A constant representing a left-center alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.LEFT_CENTER
	    * @since 3.0.0
	    * @type {integer}
	    */
	    LEFT_CENTER: 4,

	    /**
	    * A constant representing a left-bottom alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.LEFT_BOTTOM
	    * @since 3.0.0
	    * @type {integer}
	    */
	    LEFT_BOTTOM: 5,

	    /**
	    * A constant representing a center alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.CENTER
	    * @since 3.0.0
	    * @type {integer}
	    */
	    CENTER: 6,

	    /**
	    * A constant representing a right-top alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.RIGHT_TOP
	    * @since 3.0.0
	    * @type {integer}
	    */
	    RIGHT_TOP: 7,

	    /**
	    * A constant representing a right-center alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.RIGHT_CENTER
	    * @since 3.0.0
	    * @type {integer}
	    */
	    RIGHT_CENTER: 8,

	    /**
	    * A constant representing a right-bottom alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.RIGHT_BOTTOM
	    * @since 3.0.0
	    * @type {integer}
	    */
	    RIGHT_BOTTOM: 9,

	    /**
	    * A constant representing a bottom-left alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.BOTTOM_LEFT
	    * @since 3.0.0
	    * @type {integer}
	    */
	    BOTTOM_LEFT: 10,

	    /**
	    * A constant representing a bottom-center alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.BOTTOM_CENTER
	    * @since 3.0.0
	    * @type {integer}
	    */
	    BOTTOM_CENTER: 11,

	    /**
	    * A constant representing a bottom-right alignment or position.
	    * @constant
	    * @name Phaser.Display.Align.BOTTOM_RIGHT
	    * @since 3.0.0
	    * @type {integer}
	    */
	    BOTTOM_RIGHT: 12

	};

	var GetBottom = function (gameObject) {
	    var height = GetDisplayHeight(gameObject);
	    return (gameObject.y + height) - (height * gameObject.originY);
	};

	var GetCenterX = function (gameObject) {
	    var width = GetDisplayWidth(gameObject);
	    return gameObject.x - (width * gameObject.originX) + (width * 0.5);
	};

	var SetBottom = function (gameObject, value) {
	    var height = GetDisplayHeight(gameObject);
	    gameObject.y = (value - height) + (height * gameObject.originY);
	    return gameObject;
	};

	var SetCenterX = function (gameObject, x) {
	    var width = GetDisplayWidth(gameObject);
	    var offsetX = width * gameObject.originX;
	    gameObject.x = (x + offsetX) - (width * 0.5);

	    return gameObject;
	};

	var BottomCenter = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
	    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

	    return gameObject;
	};

	var GetLeft = function (gameObject) {
	    var width = GetDisplayWidth(gameObject);
	    return gameObject.x - (width * gameObject.originX);
	};

	var SetLeft = function (gameObject, value) {
	    var width = GetDisplayWidth(gameObject);
	    gameObject.x = value + (width * gameObject.originX);
	    return gameObject;
	};

	var BottomLeft = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
	    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

	    return gameObject;
	};

	var GetRight = function (gameObject) {
	    var width = GetDisplayWidth(gameObject);
	    return (gameObject.x + width) - (width * gameObject.originX);
	};

	var SetRight = function (gameObject, value) {
	    var width = GetDisplayWidth(gameObject);
	    gameObject.x = (value - width) + (width * gameObject.originX);

	    return gameObject;
	};

	var BottomRight = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetRight(alignIn) + offsetX);
	    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

	    return gameObject;
	};

	var SetCenterY = function (gameObject, y) {
	    var height = GetDisplayHeight(gameObject);
	    var offsetY = height * gameObject.originY;
	    gameObject.y = (y + offsetY) - (height * 0.5);

	    return gameObject;
	};

	var CenterOn = function (gameObject, x, y) {
	    SetCenterX(gameObject, x);
	    return SetCenterY(gameObject, y);
	};

	var GetCenterY = function (gameObject) {
	    var height = GetDisplayHeight(gameObject);
	    return gameObject.y - (height * gameObject.originY) + (height * 0.5);
	};

	var Center = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);

	    return gameObject;
	};

	var LeftCenter = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
	    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);

	    return gameObject;
	};

	var RightCenter = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetRight(alignIn) + offsetX);
	    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);

	    return gameObject;
	};

	var GetTop = function (gameObject) {
	    var height = GetDisplayHeight(gameObject);
	    return gameObject.y - (height * gameObject.originY);
	};

	var SetTop = function (gameObject, value) {
	    var height = GetDisplayHeight(gameObject);
	    gameObject.y = value + (height * gameObject.originY);
	    return gameObject;
	};

	var TopCenter = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
	    SetTop(gameObject, GetTop(alignIn) - offsetY);

	    return gameObject;
	};

	var TopLeft = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
	    SetTop(gameObject, GetTop(alignIn) - offsetY);

	    return gameObject;
	};

	var TopRight = function (gameObject, alignIn, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    SetRight(gameObject, GetRight(alignIn) + offsetX);
	    SetTop(gameObject, GetTop(alignIn) - offsetY);

	    return gameObject;
	};

	var AlignInMap = [];

	AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = BottomCenter;
	AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = BottomLeft;
	AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = BottomRight;
	AlignInMap[ALIGN_CONST.CENTER] = Center;
	AlignInMap[ALIGN_CONST.LEFT_CENTER] = LeftCenter;
	AlignInMap[ALIGN_CONST.RIGHT_CENTER] = RightCenter;
	AlignInMap[ALIGN_CONST.TOP_CENTER] = TopCenter;
	AlignInMap[ALIGN_CONST.TOP_LEFT] = TopLeft;
	AlignInMap[ALIGN_CONST.TOP_RIGHT] = TopRight;

	var QuickSet = function (child, alignIn, position, offsetX, offsetY) {
	    return AlignInMap[position](child, alignIn, offsetX, offsetY);
	};

	var AlignIn = function (child, x, y, width, height, align) {
	    globZone.setPosition(x, y).setSize(width, height);
	    QuickSet(child, globZone, align);
	};

	const GetValue$1B = Phaser.Utils.Objects.GetValue;
	const Group = Phaser.GameObjects.Group;
	const P3Container = Phaser.GameObjects.Container;

	var DrawBounds = function (graphics, config) {
	    var scene = graphics.scene;

	    var color, lineWidth;
	    var createTextCallback, createTextCallbackScope, textAlign;
	    if (typeof (config) === 'number') {
	        color = config;
	    } else {
	        color = GetValue$1B(config, 'color');
	        lineWidth = GetValue$1B(config, 'lineWidth');
	        var nameTextConfig = GetValue$1B(config, 'name', false);
	        if (nameTextConfig) {
	            createTextCallback = GetValue$1B(nameTextConfig, 'createTextCallback', DefaultCreateTextCallback);
	            createTextCallbackScope = GetValue$1B(nameTextConfig, 'createTextCallbackScope', undefined);
	            textAlign = GetValue$1B(nameTextConfig, 'align', 'left-top');
	            if (typeof (textAlign) === 'string') {
	                textAlign = AlignConst[textAlign];
	            }
	        }
	    }

	    if (color === undefined) {
	        color = 0xffffff;
	    }
	    if (lineWidth === undefined) {
	        lineWidth = 1;
	    }

	    if (createTextCallback && !graphics.children) {
	        graphics.children = new Group(scene);
	        graphics.once('destroy', function (graphics, fromScene) {
	            graphics.children.destroy(!fromScene);
	            graphics.children = undefined;
	        });
	        var graphicsClear = graphics.clear.bind(graphics);
	        graphics.clear = function () {
	            graphicsClear();
	            graphics.children.clear(false, true);
	        };
	    }

	    var children = this.getAllShownChildren([this]);
	    GetP3ContainerChildren(children, children);

	    var child;
	    var nameText;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        if (child.getBounds ||
	            ((child.width !== undefined) && (child.height !== undefined))
	        ) {
	            GlobRect = GetBounds(child, GlobRect);
	        } else {
	            continue;
	        }

	        if (color != null) {
	            graphics
	                .lineStyle(lineWidth, color)
	                .strokeRectShape(GlobRect);
	        }

	        if (child.name && createTextCallback) {
	            if (createTextCallbackScope) {
	                nameText = createTextCallback.call(createTextCallbackScope, scene);
	            } else {
	                nameText = createTextCallback(scene);
	            }
	            if (nameText) {
	                nameText.setText(child.name);
	                graphics.children.add(nameText);

	                AlignIn(nameText, GlobRect.x, GlobRect.y, GlobRect.width, GlobRect.height, textAlign);
	            }
	        }
	    }
	    return this;
	};

	var DefaultCreateTextCallback = function (scene, child, childBoundsRect) {
	    return scene.add.text(0, 0, '');
	};

	var GetP3ContainerChildren = function (gameObjects, output) {
	    if (!Array.isArray(gameObjects)) {
	        gameObjects = [gameObjects];
	    }
	    if (output === undefined) {
	        output = [];
	    }

	    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	        var gameObject = gameObjects[i];
	        if (gameObject instanceof P3Container) {
	            output.push(...gameObject.list);
	            GetP3ContainerChildren(gameObject.list, output);
	        }
	    }

	    return output;
	};

	var GlobRect = undefined;

	const ContainerAdd = ContainerLite.prototype.add;

	var AddChild$2 = function (gameObject) {
	    ContainerAdd.call(this, gameObject);

	    if (this.sizerEventsEnable) {
	        gameObject.emit('sizer.add', gameObject, this);
	        this.emit('add', gameObject, this);
	    }

	    return this;
	};

	var AddChildMethods$7 = {
	    addBackground(gameObject, paddingConfig, childKey) {
	        if (this.backgroundChildren === undefined) {
	            this.backgroundChildren = [];
	        }

	        if (typeof (paddingConfig) === 'string') {
	            childKey = paddingConfig;
	            paddingConfig = undefined;
	        }

	        if (paddingConfig === undefined) {
	            paddingConfig = 0;
	        }

	        AddChild$2.call(this, gameObject);
	        this.backgroundChildren.push(gameObject);

	        var config = this.getSizerConfig(gameObject);
	        config.padding = GetBoundsConfig$1(paddingConfig);

	        if (childKey !== undefined) {
	            this.addChildrenMap(childKey, gameObject);
	        }
	        return this;
	    },

	    isBackground(gameObject) {
	        if (this.backgroundChildren === undefined) {
	            return false;
	        }
	        return (this.backgroundChildren.indexOf(gameObject) !== -1);
	    }
	};

	var GetParent = function (gameObject, name) {
	    var parent = null;
	    if (name === undefined) {
	        if (gameObject.hasOwnProperty('rexContainer')) {
	            parent = gameObject.rexContainer.parent;
	            if (parent) {
	                if (!parent.isRexSizer) {
	                    // Try to get sizer parent
	                    parent = GetParent(parent);
	                }
	            } else {
	                parent = null;
	            }
	        }

	    } else {
	        parent = GetParent(gameObject);
	        while (parent) {
	            if (parent.name === name) {
	                break;
	            }
	            parent = GetParent(parent);
	        }
	    }
	    return parent;
	};

	var GetTopmostParent = function (gameObject) {
	    var parent = GetParent(gameObject);
	    while (parent) {
	        gameObject = parent;
	        parent = GetParent(parent);
	    }
	    return gameObject;
	};


	var GetParentSizerMethods = {
	    getParentSizer(gameObject, name) {
	        if (typeof (gameObject) === 'string') {
	            name = gameObject;
	            gameObject = undefined;
	        }
	        if (gameObject === undefined) {
	            gameObject = this;
	        }
	        return GetParent(gameObject, name);
	    },

	    getTopmostSizer(gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }
	        return GetTopmostParent(gameObject);
	    },

	    hasParentSizer(parentGameObject, gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }

	        var parent = GetParent(gameObject);
	        while (parent) {
	            if (parent === parentGameObject) {
	                return true;
	            }
	            parent = GetParent(parent);
	        }

	        return false;
	    },

	    hasChild(child, gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }

	        return this.hasParentSizer(gameObject, child);
	    }
	};

	const RemoveItem$8 = Phaser.Utils.Array.Remove;
	const ContainerRemove = ContainerLite.prototype.remove;
	const GetParentSizer$1 = GetParentSizerMethods.getParentSizer;

	var RemoveChild$1 = function (gameObject, destroyChild) {
	    // Invoke parent's removeChildCallback method
	    var parent = GetParentSizer$1(gameObject);
	    while (parent) {
	        if (parent.removeChildCallback) {
	            parent.removeChildCallback(gameObject, destroyChild);
	        }
	        parent = GetParentSizer$1(parent);
	    }

	    if (this.isBackground(gameObject)) {
	        RemoveItem$8(this.backgroundChildren, gameObject);
	    }
	    ContainerRemove.call(this, gameObject, destroyChild);

	    if (!destroyChild && this.sizerEventsEnable) {
	        gameObject.emit('sizer.remove', gameObject, this);
	        this.emit('remove', gameObject, this);
	    }

	    return this;
	};

	const RemoveItem$7 = Phaser.Utils.Array.Remove;
	const GetParentSizer = GetParentSizerMethods.getParentSizer;

	var RemoveChildMethods$7 = {
	    removeFromParentSizer() {
	        var parent = GetParentSizer(gameObject);
	        if (parent) {
	            parent.remove(this);
	        }
	        return this;
	    },

	    removeBackground(gameObject, destroyChild) {
	        if (this.backgroundChildren === undefined) {
	            return this;
	        }

	        if (this.getParentSizer(gameObject) !== this) {
	            return this;
	        }

	        RemoveItem$7(this.backgroundChildren, gameObject);
	        RemoveChild$1.call(this, gameObject, destroyChild);
	        return this;
	    },

	    removeAllBackgrounds(destroyChild) {
	        if (this.backgroundChildren === undefined) {
	            return this;
	        }

	        for (var i = this.backgroundChildren.length - 1; i >= 0; i--) {
	            this.remove(this.backgroundChildren[i], destroyChild);
	        }
	        return this;
	    },
	};

	var AddChildrenMap = function (key, gameObject) {
	    if (typeof (key) === 'string') {
	        this.childrenMap[key] = gameObject;
	    } else {
	        var config = key;
	        for (key in config) {
	            this.childrenMap[key] = config[key];
	        }
	    }
	    return this;
	};

	var RemoveChildrenMap = function (key) {
	    if (typeof (key) === 'object') {
	        var gameObject = key;
	        for (var key in this.childrenMap) {
	            if (this.childrenMap[key] === gameObject) {
	                delete this.childrenMap[key];
	                return this;
	            }
	        }
	    }

	    delete this.childrenMap[key];
	    return this;
	};

	var GetElement = function (mapNameList, recursive) {
	    if (typeof (mapNameList) === 'string') {
	        mapNameList = mapNameList.split('.');
	    }
	    if (mapNameList.length === 0) {
	        return undefined;
	    }

	    if (recursive === undefined) {
	        recursive = false;
	    }

	    var name = mapNameList.shift(),
	        element = null;
	    if (name.charAt(0) === '#') { // Get element by name
	        name = name.substring(1);
	        element = this.getByName(name, recursive);
	    } else if ((mapNameList.length === 0) && recursive) { // Get element by single key and recursive        
	        var childrenMap = this.childrenMap;
	        if (childrenMap) {
	            var queue = [childrenMap];
	            var child;
	            while (queue.length) {
	                childrenMap = queue.shift();

	                for (var key in childrenMap) {
	                    child = childrenMap[key];
	                    if (key === name) {
	                        element = child;
	                        break;  // Leave for-loop
	                    } else if (child && (typeof (child) === 'object') && child.childrenMap) {
	                        queue.push(child.childrenMap);
	                    }
	                }

	                if (element) { // leave while-loop
	                    break;
	                }
	            }
	        }

	    } else if (name.indexOf('[') === (-1)) { // Get element by key
	        if (this.childrenMap) {
	            element = this.childrenMap[name];
	        }
	    } else { // Get element by key[]
	        var innerMatch = name.match(RE_OBJ);
	        if (innerMatch != null) {
	            if (this.childrenMap) {
	                var elements = this.childrenMap[innerMatch[1]];
	                if (elements) {
	                    element = elements[innerMatch[2]];
	                }
	            }
	        }
	    }

	    if (mapNameList.length === 0) {
	        return element;
	    } else if (element && element.childrenMap) {
	        return element.getElement(mapNameList);
	    } else {
	        return null;
	    }
	};

	const RE_OBJ = /(\S+)\[(\d+)\]/i;

	var GetChildIndex = function (child) {
	    if (Array.isArray(this.sizerChildren)) {
	        var index = this.sizerChildren.indexOf(child);
	        if (index === -1) {
	            index = null;
	        }
	        return index;

	    } else {
	        if (this.getParentSizer(child) !== this) {
	            return null;
	        }

	        for (var key in this.sizerChildren) {
	            if (this.sizerChildre[key] === child) {
	                return key;
	            }
	        }
	        return null;
	    }
	};

	const GetValue$1A = Phaser.Utils.Objects.GetValue;

	var GetPadding$1 = function (padding, key) {
	    if (key === undefined) {
	        return padding;
	    }
	    return padding[key];
	};

	var SetPadding$1 = function (padding, key, value) {
	    if (padding === undefined) {
	        padding = {};
	    }
	    if (key === undefined) {
	        key = 0;
	    }

	    var keyType = typeof (key);
	    if (keyType === 'string') {
	        padding[key] = value;
	    } else if (keyType === 'number') {
	        padding.left = key;
	        padding.right = key;
	        padding.top = key;
	        padding.bottom = key;
	    } else {
	        padding.left = GetValue$1A(key, 'left', 0);
	        padding.right = GetValue$1A(key, 'right', 0);
	        padding.top = GetValue$1A(key, 'top', 0);
	        padding.bottom = GetValue$1A(key, 'bottom', 0);
	    }
	    return padding;
	};

	var PaddingMethods = {
	    getInnerPadding(key) {
	        return GetPadding$1(this.space, key);
	    },

	    setInnerPadding(key, value) {
	        SetPadding$1(this.space, key, value);
	        return this;
	    },

	    getOuterPadding(key) {
	        return GetPadding$1(this.getSizerConfig(this).padding, key);
	    },

	    setOuterPadding(key, value) {
	        SetPadding$1(this.getSizerConfig(this).padding, key, value);
	        return this;
	    },

	    getChildOuterPadding(child, key) {
	        if (typeof (child) === 'string') {
	            child = this.getElement(child);
	        }
	        return GetPadding$1(this.getSizerConfig(child).padding, key);
	    },

	    setChildOuterPadding(child, key, value) {
	        if (typeof (child) === 'string') {
	            child = this.getElement(child);
	        }
	        SetPadding$1(this.getSizerConfig(child).padding, key, value);
	        return this;
	    },
	};

	var ResolveWidth$3 = function (width) {
	    var childrenWidth = this.childrenWidth;
	    if (childrenWidth === undefined) {  // Can't resolve child width
	        return undefined;
	    }

	    var minWidth = (this.minWidth !== undefined) ? (this.minWidth * this.scaleX) : 0;
	    if (width === undefined) {
	        width = Math.max(minWidth, childrenWidth);

	        if (this.layoutWarnEnable) {
	            if ((minWidth > 0) && (childrenWidth > minWidth)) {
	                console.warn(`Layout width warn: ${this.constructor.name}'s minWidth (${minWidth}) < childrenWidth (${childrenWidth})`);
	            }
	        }
	    } else {
	        if (this.layoutWarnEnable) {
	            if ((minWidth > width) || (childrenWidth > width)) {
	                console.warn(`Layout width warn: ${this.constructor.name}'s minWidth (${minWidth}) or childrenWidth (${childrenWidth} > targetWidth ${width})`);
	            }
	        }
	    }

	    return width;
	};

	var HasWidthWrap$2 = function () {
	    var child;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (
	            (!child) ||
	            (child.isRexSizer && child.ignoreLayout) ||
	            (!child.runWidthWrap)
	        ) {
	            continue;
	        }

	        if (
	            !child.hasWidthWrap ||
	            child.hasWidthWrap()
	        ) {
	            return true;
	        }
	    }

	    return false;
	};

	var ResolveChildrenWidth$1 = function (parentWidth) {
	    // Resolve width of sizer children
	    var child, expandedChildWidth, childWidth;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (child && child.isRexSizer && !child.ignoreLayout) {
	            expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
	            childWidth = child.resolveWidth(expandedChildWidth);
	            if (childWidth === undefined) {
	                childWidth = expandedChildWidth;
	            }
	            child.resolveChildrenWidth(childWidth);
	        }
	    }
	};

	// Default method
	var RunWidthWrap$3 = function (parentWidth) {
	    var child, expandedChildWidth, childWidth;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (
	            (!child) ||
	            (child.isRexSizer && child.ignoreLayout) ||
	            (!child.runWidthWrap)
	        ) {
	            continue;
	        }

	        expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
	        if (child.isRexSizer) {
	            childWidth = child.resolveWidth(expandedChildWidth);
	            if (childWidth === undefined) {
	                childWidth = expandedChildWidth;
	            }
	        } else {
	            childWidth = expandedChildWidth;
	        }
	        child.runWidthWrap(childWidth);
	    }
	    return this;
	};

	var ResolveHeight$3 = function (height) {
	    var childrenHeight = this.childrenHeight;
	    if (childrenHeight === undefined) {  // Can't resolve child height
	        return undefined;
	    }

	    var minHeight = (this.minHeight !== undefined) ? (this.minHeight * this.scaleY) : 0;
	    if (height === undefined) {
	        height = Math.max(minHeight, childrenHeight);

	        if (this.layoutWarnEnable) {
	            if ((minHeight > 0) && (childrenHeight > minHeight)) {
	                console.warn(`Layout height warn: ${this.constructor.name}'s minHeight (${minHeight}) < childrenHeight (${childrenHeight})`);
	            }
	        }
	    } else {
	        if (this.layoutWarnEnable) {
	            if ((minHeight > height) || (childrenHeight > height)) {
	                console.warn(`Layout height warn: ${this.constructor.name}'s minHeight (${minHeight}) or childrenHeight (${childrenHeight}) > targetHeight (${height})`);
	            }
	        }
	    }

	    return height;
	};

	var HasHeightWrap$2 = function () {
	    var child;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (
	            (!child) ||
	            (child.isRexSizer && child.ignoreLayout) ||
	            (!child.runHeightWrap)
	        ) {
	            continue;
	        }

	        if (
	            !child.hasHeightWrap ||
	            child.hasHeightWrap()     // all kind of sizers has hasHeightWrap method
	        ) {
	            return true;
	        }
	    }

	    return false;
	};

	var ResolveChildrenHeight$1 = function (parentHeight) {
	    // Resolve width of sizer children
	    var child, expandedChildHeight, childHeight;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (child && child.isRexSizer && !child.ignoreLayout) {
	            expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
	            childHeight = child.resolveHeight(expandedChildHeight);
	            if (childHeight === undefined) {
	                childHeight = expandedChildHeight;
	            }
	            child.resolveChildrenHeight(childHeight);
	        }
	    }
	};

	// Default method
	var RunHeightWrap$3 = function (parentHeight) {
	    var child, expandedChildHeight, childHeight;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (
	            (!child) ||
	            (child.isRexSizer && child.ignoreLayout) ||
	            (!child.runHeightWrap)
	        ) {
	            continue;
	        }

	        expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
	        if (child.isRexSizer) {
	            childHeight = child.resolveHeight(expandedChildHeight);
	            if (childHeight === undefined) {
	                childHeight = expandedChildHeight;
	            }
	        } else {
	            childHeight = expandedChildHeight;
	        }
	        child.runHeightWrap(childHeight);
	    }
	    return this;
	};

	var GetChildWidth = function (child) {
	    var childWidth;
	    if (child.isRexSizer) { // Sizer game object
	        var childrenWidth = child.childrenWidth;
	        if (childrenWidth == undefined) {
	            return undefined;
	        }

	        var childMinWidth = child.minWidth * child.scaleX;
	        childWidth = Math.max(childMinWidth, childrenWidth);
	    } else {  // Normal game object
	        if (child.minWidth !== undefined) {  // Force minWidth
	            childWidth = child.minWidth;
	        } else if (child._minWidth !== undefined) {  // Force minWidth
	            childWidth = child._minWidth;
	        } else {
	            childWidth = GetDisplayWidth(child);
	        }
	    }

	    return childWidth;
	};

	var GetChildHeight = function (child) {
	    var childHeight;
	    if (child.isRexSizer) {  // Sizer game object
	        var childrenHeight = child.childrenHeight;
	        if (childrenHeight === undefined) {
	            return undefined;
	        }

	        var childMinHeight = child.minHeight * child.scaleY;
	        childHeight = Math.max(childMinHeight, childrenHeight);
	    } else {  // Normal game object
	        if (child.minHeight !== undefined) {  // Force minHeight
	            childHeight = child.minHeight;
	        } else if (child._minHeight !== undefined) {
	            childHeight = child._minHeight;
	        } else {
	            childHeight = GetDisplayHeight(child);
	        }
	    }
	    return childHeight;
	};

	// Override
	var GetExpandedChildWidth$4 = function (child, parentWidth) {
	    return parentWidth;
	};

	// Override
	var GetExpandedChildHeight$4 = function (child, parentHeight) {
	    return parentHeight;
	};

	// Override
	var GetChildrenWidth$4 = function () {
	    return 0;
	};

	// Override
	var GetChildrenHeight$4 = function () {
	    return 0;
	};

	var GetAllChildrenSizers = function (out) {
	    if (out === undefined) {
	        out = [];
	    }
	    var startIdx = out.length;
	    var children = this.getChildrenSizers(out);
	    var endIdx = out.length;
	    for (var i = startIdx; i < endIdx; i++) {
	        children[i].getAllChildrenSizers(out);
	    }

	    return out;
	};

	// Default method
	var GetChildrenSizers$4 = function(out) {
	    if (out === undefined) {
	        out = [];
	    }
	    return out;
	};

	var GetShownChildrenMethods = {
	    getShownChildren(out) {
	        if (out === undefined) {
	            out = [];
	        }
	        var children = this.children,
	            child;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = children[i];
	            if (child.rexSizer && child.rexSizer.hidden) { // Don't add hidden child
	                continue;
	            }

	            out.push(child);
	        }

	        return out;
	    },

	    getAllShownChildren(out) {
	        if (out === undefined) {
	            out = [];
	        }

	        var queue = [this];
	        while (queue.length > 0) {
	            var current = queue.shift();
	            if (current.rexSizer && current.rexSizer.hidden) {
	                continue;
	            }

	            if (current !== this) {
	                out.push(current);
	            }

	            if (current.isRexContainerLite) {
	                queue.push(...current.children);
	            }
	        }

	        return out;
	    }
	};

	var PreLayout$4 = function () {
	    this._childrenWidth = undefined;
	    this._childrenHeight = undefined;

	    var children = this.getChildrenSizers(),
	        child;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        if (child.ignoreLayout) {
	            continue;
	        }
	        child.preLayout();
	    }
	};

	var Layout = function () {
	    this.runLayout();
	    return this;
	};

	var HasResizeMethod = function (gameObject) {
	    // 1st pass : Has `resize` method?
	    if (gameObject.resize) {
	        return true;
	    }

	    // 2nd pass : Has `setSize` method?
	    // Does not have `setSize` method
	    if (!gameObject.setSize) {
	        return false;
	    }

	    // Has `setSize` method but only for internal usage.
	    for (var i = 0, cnt = ExcludeClassList$1.length; i < cnt; i++) {
	        var excludeClass = ExcludeClassList$1[i];
	        if (excludeClass && gameObject instanceof excludeClass) {
	            return false;
	        }
	    }

	    return true;
	};

	var ExcludeClassList$1 = [
	    Phaser.GameObjects.Image,
	    Phaser.GameObjects.Sprite,
	    Phaser.GameObjects.Mesh,
	    Phaser.GameObjects.Shader,
	    Phaser.GameObjects.Video
	];

	var CanSetDisplaySize = function (gameObject) {
	    if (gameObject.displayWidth === undefined) {
	        return false;
	    }

	    for (var i = 0, cnt = ExcludeClassList.length; i < cnt; i++) {
	        var excludeClass = ExcludeClassList[i];
	        if (excludeClass && gameObject instanceof excludeClass) {
	            return false;
	        }
	    }

	    return true;
	};

	var ExcludeClassList = [
	    Phaser.GameObjects.BitmapText,
	];

	var ResizeGameObject = function (gameObject, newDisplayWidth, newDisplayHeight) {
	    // Set display size

	    if (!gameObject || ((newDisplayWidth === undefined) && (newDisplayHeight === undefined))) {
	        return;
	    }

	    if (HasResizeMethod(gameObject)) { // Has `resize`, or `setSize` method
	        var newWidth, newHeight;
	        if (newDisplayWidth === undefined) {
	            newWidth = gameObject.width;
	        } else {
	            newWidth = newDisplayWidth / gameObject.scaleX;
	        }
	        if (newDisplayHeight === undefined) {
	            newHeight = gameObject.height;
	        } else {
	            newHeight = newDisplayHeight / gameObject.scaleY;
	        }

	        if (gameObject.resize) {
	            gameObject.resize(newWidth, newHeight);
	        } else {
	            gameObject.setSize(newWidth, newHeight);
	        }

	    } else {
	        var canSetDisplaySize = CanSetDisplaySize(gameObject);
	        if (newDisplayWidth !== undefined) {
	            if (canSetDisplaySize) {
	                gameObject.displayWidth = newDisplayWidth;
	            } else {
	                gameObject.scaleX = newDisplayWidth / gameObject.width;
	            }
	        }
	        if (newDisplayHeight !== undefined) {
	            if (canSetDisplaySize) {
	                gameObject.displayHeight = newDisplayHeight;
	            } else {
	                gameObject.scaleY = newDisplayHeight / gameObject.height;
	            }
	        }

	    }
	};

	// Override
	var RunLayout = function (parent, newWidth, newHeight) {
	    // Skip hidden or !dirty sizer
	    if (this.ignoreLayout) {
	        return this;
	    }

	    var isTopmostParent = !parent;
	    // Pre-processor, top parent only
	    if (isTopmostParent) {
	        this.preLayout();
	    }

	    var runWidthWrap, runHeightWrap;
	    if (isTopmostParent || parent.runChildrenWrapFlag) {
	        runWidthWrap = this.hasWidthWrap();
	        runHeightWrap = this.hasHeightWrap();
	    } else {
	        runWidthWrap = false;
	        runHeightWrap = false;
	    }

	    var size = ResolveSize(this, newWidth, newHeight, runWidthWrap, runHeightWrap);
	    if (!size) {
	        console.error('Can\'t resolve size of ', this);
	    }

	    var width = size.width;
	    var height = size.height;

	    // Resize parent
	    ResizeGameObject(this, width, height);

	    if (this.sizerEventsEnable) {
	        if (this.layoutedChildren === undefined) {
	            this.layoutedChildren = [];
	        }
	    }

	    // Layout children    
	    this.layoutChildren();

	    // Layout background children
	    this.layoutBackgrounds();

	    if (this.sizerEventsEnable) {
	        this.emit('postlayout', this.layoutedChildren, this);
	        this.layoutedChildren.length = 0;
	    }

	    // Custom postLayout callback
	    this.postLayout(parent, width, height);

	    // Post-processor, top parent only
	    if (isTopmostParent) {
	        if (this._anchor) {
	            this._anchor.updatePosition();
	        }
	    }

	    return this;
	};

	var ResolveSize = function (self, width, height, runWidthWrap, runHeightWrap) {
	    var newWidth = ResolveWidth$2(self, width, runWidthWrap);

	    var newHeight = ResolveHeight$2(self, height, runHeightWrap);

	    if (newWidth === undefined) {
	        newWidth = ResolveWidth$2(self, width, runWidthWrap);
	    }

	    if ((newWidth !== undefined) && (newHeight !== undefined)) {
	        return {
	            width: newWidth,
	            height: newHeight
	        }
	    }

	    return false;
	};

	var ResolveWidth$2 = function (self, width, runWidthWrap) {
	    // Calculate parent width
	    var width = self.resolveWidth(width);

	    // Calculate all children width, run width wrap
	    if (width !== undefined) {
	        if (runWidthWrap) {
	            self.resolveChildrenWidth(width);
	            self.runWidthWrap(width);
	        }
	    }

	    return width;
	};

	var ResolveHeight$2 = function (self, height, runHeightWrap) {
	    // Calculate parent height
	    var height = self.resolveHeight(height);

	    // Calculate all children width, run width wrap
	    if (height !== undefined) {
	        if (runHeightWrap) {
	            self.resolveChildrenHeight(height);
	            self.runHeightWrap(height);
	        }
	    }

	    return height;
	};

	// Override
	var LayoutChildren$5 = function () {

	};

	// Override
	var PostLayout = function (parent, newWidth, newHeight) {
	    return this;
	};

	var DefaultResizeCallback = function (width, height, gameObject, anchor) {
	    ResizeGameObject(gameObject, width, height);
	};

	const GetValue$1z = Phaser.Utils.Objects.GetValue;

	class Anchor extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, { eventEmitter: false });
	        // No event emitter
	        // this.parent = gameObject;

	        this.viewport = undefined;
	        this.resetFromJSON(config);
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        this.autoAnchor(false);

	        this.viewport = undefined;
	        this.onUpdateViewportCallback = undefined;
	        this.onUpdateViewportCallbackScope = undefined;
	        this.onResizeCallback = undefined;
	        this.onResizeCallbackScope = undefined;

	        super.shutdown(fromScene);
	    }

	    resetFromJSON(o) {
	        if (o === undefined) {
	            o = {};
	        }

	        // Position
	        var alignX, configX;
	        if (o.x !== undefined) {
	            alignX = null;
	            configX = o.x;
	        } else if (o.left !== undefined) {
	            alignX = 0;
	            configX = o.left;
	        } else if (o.right !== undefined) {
	            alignX = 1;
	            configX = o.right;
	        } else if (o.centerX !== undefined) {
	            alignX = 0.5;
	            configX = o.centerX;
	        }

	        var alignY, configY;
	        if (o.y !== undefined) {
	            alignY = null;
	            configY = o.y;
	        } else if (o.top !== undefined) {
	            alignY = 0;
	            configY = o.top;
	        } else if (o.bottom !== undefined) {
	            alignY = 1;
	            configY = o.bottom;
	        } else if (o.centerY !== undefined) {
	            alignY = 0.5;
	            configY = o.centerY;
	        }

	        var percentageX, offsetX;
	        if (configX !== undefined) {
	            configX = configX.replace('left', '0%').replace('right', '100%').replace('center', '50%').split('%');
	            percentageX = parseFloat(configX[0]) / 100;
	            offsetX = (configX[1] === '') ? 0 : parseFloat(configX[1]);
	        }
	        var percentageY, offsetY;
	        if (configY !== undefined) {
	            configY = configY.replace('top', '0%').replace('bottom', '100%').replace('center', '50%').split('%');
	            percentageY = parseFloat(configY[0]) / 100;
	            offsetY = (configY[1] === '') ? 0 : parseFloat(configY[1]);
	        }

	        // Size
	        var configWidth = o.width;
	        var percentageWidth, paddingWidth;
	        if (configWidth !== undefined) {
	            configWidth = configWidth.split('%');
	            percentageWidth = parseFloat(configWidth[0]) / 100;
	            paddingWidth = (configWidth[1] === '') ? 0 : parseFloat(configWidth[1]);
	        }

	        var configHeight = o.height;
	        var percentageHeight, paddingHeight;
	        if (configHeight !== undefined) {
	            configHeight = configHeight.split('%');
	            percentageHeight = parseFloat(configHeight[0]) / 100;
	            paddingHeight = (configHeight[1] === '') ? 0 : parseFloat(configHeight[1]);
	        }

	        // Position
	        this.setAlign(alignX, alignY);
	        this.setPercentage(percentageX, percentageY);
	        this.setOffset(offsetX, offsetY);
	        // Size
	        this.setSizePercentage(percentageWidth, percentageHeight);
	        this.setSizePadding(paddingWidth, paddingHeight);

	        var onResizeCallback = GetValue$1z(o, 'onResizeCallback', DefaultResizeCallback);
	        var onResizeCallbackScope = GetValue$1z(o, 'onResizeCallbackScope');
	        this.setResizeCallback(onResizeCallback, onResizeCallbackScope);

	        var onUpdateViewportCallback = GetValue$1z(o, 'onUpdateViewportCallback');
	        var onUpdateViewportCallbackScope = GetValue$1z(o, 'onUpdateViewportCallbackScope');
	        this.setUpdateViewportCallback(onUpdateViewportCallback, onUpdateViewportCallbackScope);

	        this.autoAnchor(o.enable);

	        return this;
	    }

	    autoAnchor(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }

	        enable = !!enable;
	        if (this.autoAnchorEnable === enable) {
	            return this;
	        }

	        if (enable) {
	            this.scene.sys.scale.on('resize', this.anchor, this);
	            this.anchor();
	        } else {
	            this.scene.sys.scale.off('resize', this.anchor, this);
	        }

	        this.autoAnchorEnable = enable;

	        return this;
	    }

	    // Position
	    setAlign(x, y) {
	        this.alignX = x;
	        this.alignY = y;
	        return this;
	    }

	    setPercentage(x, y) {
	        this.percentageX = x;
	        this.percentageY = y;
	        return this;
	    }

	    setOffset(x, y) {
	        this.offsetX = x;
	        this.offsetY = y;
	        return this;
	    }

	    // Size
	    setSizePercentage(width, height) {
	        this.percentageWidth = width;
	        this.percentageHeight = height;
	        return this;
	    }

	    setSizePadding(width, height) {
	        this.paddingWidth = width;
	        this.paddingHeight = height;
	        return this;
	    }

	    setResizeCallback(callback, scope) {
	        this.onResizeCallback = callback;
	        this.onResizeCallbackScope = scope;
	        return this;
	    }

	    setUpdateViewportCallback(callback, scope) {
	        this.onUpdateViewportCallback = callback;
	        this.onUpdateViewportCallbackScope = scope;
	        return this;
	    }

	    anchor() {
	        this.updateViewport();
	        this.updateSize();
	        this.updatePosition();
	        return this;
	    }

	    updateSize() {
	        var callback = this.onResizeCallback,
	            scope = this.onResizeCallbackScope;
	        var newWidth = this.anchorWidth,
	            newHeight = this.anchorHeight;
	        if (((newWidth === undefined) && (newHeight === undefined)) || !callback) {
	            return;
	        }

	        var gameObject = this.parent;
	        if (newWidth === undefined) {
	            newWidth = gameObject.width;
	        }
	        if (newHeight === undefined) {
	            newHeight = gameObject.height;
	        }

	        if (scope) {
	            callback.call(scope, newWidth, newHeight, gameObject, this);
	        } else {
	            callback(newWidth, newHeight, gameObject, this);
	        }
	    }

	    updatePosition() {
	        var gameObject = this.parent;

	        if (this.alignX === null) {
	            gameObject.x = this.anchorX;
	        } else if (this.alignX !== undefined) {
	            gameObject.x = this.anchorX + (gameObject.displayWidth * (gameObject.originX - this.alignX));
	        }

	        if (this.alignY === null) {
	            gameObject.y = this.anchorY;
	        } else if (this.alignY !== undefined) {
	            gameObject.y = this.anchorY + (gameObject.displayHeight * (gameObject.originY - this.alignY));
	        }

	        return this;
	    }

	    get anchorX() {
	        return this.viewport.x + (this.viewport.width * this.percentageX) + this.offsetX;
	    }

	    get anchorY() {
	        return this.viewport.y + (this.viewport.height * this.percentageY) + this.offsetY;
	    }

	    get anchorWidth() {
	        if (this.percentageWidth === undefined) {
	            return undefined;
	        }
	        return (this.viewport.width * this.percentageWidth) + this.paddingWidth;
	    }

	    get anchorHeight() {
	        if (this.percentageHeight === undefined) {
	            return undefined;
	        }
	        return (this.viewport.height * this.percentageHeight) + this.paddingHeight;
	    }

	    updateViewport() {
	        var camera = this.parent.scene.cameras.main;
	        this.viewport = GetViewport(this.scene, camera, this.viewport);

	        var viewport = this.viewport;
	        var callback = this.onUpdateViewportCallback,
	            scope = this.onUpdateViewportCallbackScope;
	        if (callback) {
	            if (scope) {
	                callback.call(scope, viewport, this.parent, this);
	            } else {
	                callback(viewport, this.parent, this);
	            }
	        }
	    }
	}

	var SetAnchor = function (config) {
	    if (config === undefined) {
	        config = {};
	    }

	    // Assign default onResizeCallback if not given    
	    var hasMinWidth = config.hasOwnProperty('width');
	    var hasMinHeight = config.hasOwnProperty('height');
	    var hasOnResizeCallback = config.hasOwnProperty('onResizeCallback');
	    if ((hasMinWidth || hasMinHeight) && !hasOnResizeCallback) {
	        config.onResizeCallback = function (width, height, sizer) {
	            if (hasMinWidth) {
	                sizer.setMinWidth(width);
	            }

	            if (hasMinHeight) {
	                sizer.setMinHeight(height);
	            }

	            sizer.layout();
	        };
	    }

	    if (this._anchor === undefined) {
	        this._anchor = new Anchor(this, config);
	    } else {
	        this._anchor.resetFromJSON(config);
	    }
	    return this;
	};

	const GetValue$1y = Phaser.Utils.Objects.GetValue;
	const GetAdvancedValue$3 = Phaser.Utils.Objects.GetAdvancedValue;
	const Linear$e = Phaser.Math.Linear;

	class Scale extends EaseValueTaskBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;
	        // this.timer

	        this.scaleStart = {};
	        this.scaleEnd = {};

	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);

	        this.setMode(GetValue$1y(o, 'mode', 0));
	        this.setScaleRange(
	            GetAdvancedValue$3(o, 'start', undefined),
	            GetAdvancedValue$3(o, 'end', 0)
	        );

	        return this;
	    }

	    setMode(m) {
	        if (typeof (m) === 'string') {
	            m = MODE$2[m];
	        }
	        this.mode = m;
	        return this;
	    }

	    setScaleRange(start, end) {
	        if (typeof (start) === 'number') {
	            this.startX = start;
	            this.startY = start;
	        } else {
	            this.startX = GetAdvancedValue$3(start, 'x', this.parent.scaleX);
	            this.startY = GetAdvancedValue$3(start, 'y', this.parent.scaleY);
	        }
	        if (typeof (end) === 'number') {
	            this.endX = end;
	            this.endY = end;
	        } else {
	            this.endX = GetAdvancedValue$3(end, 'x', undefined);
	            this.endY = GetAdvancedValue$3(end, 'y', undefined);
	        }

	        this.hasScaleX = (this.startX !== undefined) && (this.endX !== undefined);
	        this.hasScaleY = (this.startY !== undefined) && (this.endY !== undefined);
	        return this;
	    }

	    start() {
	        if (this.timer.isRunning) {
	            return this;
	        }

	        var gameObject = this.parent;
	        if (this.hasScaleX) {
	            gameObject.scaleX = this.startX;
	        }
	        if (this.hasScaleY) {
	            gameObject.scaleY = this.startY;
	        }

	        var repeat = this.repeat;
	        if (this.mode === 2) {  // Yoyo
	            if (repeat !== -1) {
	                repeat = ((repeat + 1) * 2) - 1;
	            }
	        }

	        this.timer
	            .setDelay(this.delay)
	            .setDuration(this.duration)
	            .setRepeat(repeat);

	        super.start();
	        return this;
	    }

	    updateTarget(gameObject, timer) {
	        var t = timer.t;
	        if (timer.isOddIteration) {  // Yoyo
	            t = 1 - t;
	        }
	        t = this.easeFn(t);

	        if (this.hasScaleX) {
	            gameObject.scaleX = Linear$e(this.startX, this.endX, t);
	        }
	        if (this.hasScaleY) {
	            gameObject.scaleY = Linear$e(this.startY, this.endY, t);
	        }
	    }

	    complete() {
	        super.complete();

	        if (this.mode === 1) {
	            this.parent.destroy();
	            // Will also destroy this behavior
	        }
	        return this;
	    }
	}

	const MODE$2 = {
	    stop: 0,
	    destroy: 1,
	    yoyo: 2
	};

	var PopUp$1 = function (gameObject, duration, orientation, ease, scale) {
	    if (ease === undefined) {
	        ease = 'Cubic';
	    }

	    // Ease scale from 0 to current scale
	    var start, end;
	    switch (orientation) {
	        case 0:
	        case 'x':
	            start = { x: 0 };
	            end = { x: gameObject.scaleX };
	            break;
	        case 1:
	        case 'y':
	            start = { y: 0 };
	            end = { y: gameObject.scaleY };
	            break;
	        default:
	            start = 0;
	            end = gameObject.scale;
	            break;
	    }

	    var config = {
	        mode: 0,
	        start: start,
	        end: end,
	        duration: duration,
	        ease: ease
	    };

	    if (scale === undefined) {
	        scale = new Scale(gameObject, config);
	    } else {
	        scale.resetFromJSON(config);
	    }
	    scale.restart();

	    return scale;
	};

	var ScaleDownDestroy = function (gameObject, duration, orientation, ease, destroyMode, scale) {
	    if (ease === undefined) {
	        ease = 'Linear';
	    }

	    // Ease from current scale to 0
	    if (destroyMode instanceof Scale) {
	        scale = destroyMode;
	        destroyMode = undefined;
	    }

	    if (destroyMode === undefined) {
	        destroyMode = true;
	    }

	    var config = {};
	    config.mode = (destroyMode) ? 1 : 0;
	    switch (orientation) {
	        case 0:
	        case 'x':
	            config.end = {
	                x: 0
	            };
	            break;
	        case 1:
	        case 'y':
	            config.end = {
	                y: 0
	            };
	            break;
	        default:
	            config.end = 0;
	            break;
	    }
	    config.duration = duration;
	    config.ease = ease;

	    if (scale === undefined) {
	        scale = new Scale(gameObject, config);
	    } else {
	        scale.resetFromJSON(config);
	    }
	    scale.restart();

	    return scale;
	};

	var Yoyo = function (gameObject, duration, peakValue, repeat, orientation, ease, scale) {
	    if (peakValue === undefined) {
	        peakValue = 1.2;
	    }
	    if (repeat === undefined) {
	        repeat = 0;
	    }
	    if (ease === undefined) {
	        ease = 'Cubic';
	    }

	    // Ease scale from 0 to current scale
	    var start, end;
	    switch (orientation) {
	        case 0:
	        case 'x':
	            start = { x: gameObject.scaleX };
	            end = { x: peakValue };
	            break;
	        case 1:
	        case 'y':
	            start = { y: gameObject.scaleX };
	            end = { y: peakValue };
	            break;
	        default:
	            start = gameObject.scaleX;
	            end = peakValue;
	            break;
	    }

	    var config = {
	        mode: 2,
	        start: start,
	        end: end,
	        duration: (duration / 2),
	        ease: ease,
	        repeat: repeat,
	    };

	    if (scale === undefined) {
	        scale = new Scale(gameObject, config);
	    } else {
	        scale.resetFromJSON(config);
	    }
	    scale.restart();

	    return scale;
	};

	var WaitEvent = function (eventEmitter, eventName) {
	    return new Promise(function (resolve, reject) {
	        eventEmitter.once(eventName, function () {
	            resolve();
	        });
	    });
	};

	var WaitComplete = function (eventEmitter) {
	    return WaitEvent(eventEmitter, 'complete');
	};

	const IsPlainObject$s = Phaser.Utils.Objects.IsPlainObject;

	var ScaleMethods = {
	    onInitScale() {
	        var gameObject = this;
	        var scale = this._scaleBehavior;

	        // Route 'complete' of scale to gameObject
	        scale.completeEventName = undefined;
	        scale.on('complete', function () {
	            if (scale.completeEventName) {
	                gameObject.emit(scale.completeEventName, gameObject);
	                scale.completeEventName = undefined;
	            }
	        });
	    },

	    popUp(duration, orientation, ease) {
	        if (IsPlainObject$s(duration)) {
	            var config = duration;
	            duration = config.duration;
	            orientation = config.orientation;
	            ease = config.ease;
	        }

	        var isInit = (this._scaleBehavior === undefined);

	        this._scaleBehavior = PopUp$1(this, duration, orientation, ease, this._scaleBehavior);

	        if (isInit) {
	            this.onInitScale();
	        }

	        this._scaleBehavior.completeEventName = 'popup.complete';

	        return this;
	    },

	    popUpPromise(duration, orientation, ease) {
	        this.popUp(duration, orientation, ease);
	        return WaitComplete(this._scaleBehavior);
	    },

	    isRunningPopUp() {
	        return this._scaleBehavior && (this._scaleBehavior.completeEventName === 'popup.complete');
	    },

	    scaleDownDestroy(duration, orientation, ease, destroyMode) {
	        if (IsPlainObject$s(duration)) {
	            var config = duration;
	            duration = config.duration;
	            orientation = config.orientation;
	            ease = config.ease;
	            destroyMode = config.destroy;
	        }

	        var isInit = (this._scaleBehavior === undefined);

	        this._scaleBehavior = ScaleDownDestroy(this, duration, orientation, ease, destroyMode, this._scaleBehavior);

	        if (isInit) {
	            this.onInitScale();
	        }

	        this._scaleBehavior.completeEventName = 'scaledown.complete';

	        return this;
	    },

	    scaleDownDestroyPromise(duration, orientation, ease, destroyMode) {
	        this.scaleDownDestroy(duration, orientation, ease, destroyMode);
	        return WaitComplete(this._scaleBehavior);
	    },

	    scaleDown(duration, orientation, ease) {
	        this.scaleDownDestroy(duration, orientation, ease, false);
	        return this;
	    },

	    scaleDownPromise(duration, orientation, ease) {
	        this.scaleDown(duration, orientation, ease);
	        return WaitComplete(this._scaleBehavior);
	    },

	    isRunningScaleDown() {
	        return this._scaleBehavior && (this._scaleBehavior.completeEventName === 'scaledown.complete');
	    },

	    scaleYoyo(duration, peakValue, repeat, orientation, ease) {
	        if (IsPlainObject$s(duration)) {
	            var config = duration;
	            duration = config.duration;
	            peakValue = config.peakValue;
	            repeat = config.repeat;
	            orientation = config.orientation;
	            ease = config.ease;
	        }

	        var isInit = (this._scaleBehavior === undefined);

	        this._scaleBehavior = Yoyo(this, duration, peakValue, repeat, orientation, ease, this._scaleBehavior);

	        if (isInit) {
	            this.onInitScale();
	        }

	        this._scaleBehavior.completeEventName = 'scaleyoyo.complete';

	        return this;
	    },

	    scaleYoyoPromise(duration, peakValue, repeat, orientation, ease) {
	        this.scaleYoyo(duration, peakValue, repeat, orientation, ease);
	        return WaitComplete(this._scaleBehavior);
	    },

	    isRunningScaleYoyo() {
	        return this._scaleBehavior && (this._scaleBehavior.completeEventName = 'scaleyoyo.complete');
	    },

	    isRunningEaseScale() {
	        return this.isRunningPopUp() || this.isRunningScaleDown() || this.isRunningScaleYoyo();
	    },
	};

	var methods$h = {};
	Object.assign(methods$h, ScaleMethods);

	methods$h.onInitScale = function () {
	    ScaleMethods.onInitScale.call(this);

	    var gameObject = this;
	    var scale = this._scaleBehavior;
	    // Update local state
	    scale.on('update', function () {
	        var parent = GetParentSizerMethods.getParentSizer(gameObject);
	        if (parent) {
	            parent.resetChildPositionState(gameObject);
	        }
	    });
	};

	const GetValue$1x = Phaser.Utils.Objects.GetValue;
	const GetAdvancedValue$2 = Phaser.Utils.Objects.GetAdvancedValue;
	const Linear$d = Phaser.Math.Linear;

	class Fade extends EaseValueTaskBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;
	        // this.timer

	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);

	        this.setMode(GetValue$1x(o, 'mode', 0));
	        this.setAlphaRange(
	            GetAdvancedValue$2(o, 'start', this.parent.alpha),
	            GetAdvancedValue$2(o, 'end', 0)
	        );
	        return this;
	    }

	    setMode(m) {
	        if (typeof (m) === 'string') {
	            m = MODE$1[m];
	        }
	        this.mode = m;
	        return this;
	    }

	    setAlphaRange(start, end) {
	        this.alphaStart = start;
	        this.alphaEnd = end;
	        return this;
	    }

	    start() {
	        if (this.timer.isRunning) {
	            return this;
	        }

	        var gameObject = this.parent;
	        gameObject.setAlpha(this.alphaStart);

	        this.timer
	            .setDelay(this.delay)
	            .setDuration(this.duration)
	            .setRepeat((this.mode === 2) ? -1 : 0);

	        super.start();
	        return this;
	    }

	    updateTarget(gameObject, timer) {
	        var t = timer.t;
	        if (timer.isOddIteration) {  // Yoyo
	            t = 1 - t;
	        }

	        gameObject.alpha = Linear$d(this.alphaStart, this.alphaEnd, t);
	    }

	    complete() {
	        super.complete();
	        if (this.mode === 1) {
	            this.parent.destroy();
	            // Will also destroy this behavior
	        }
	        return this;
	    }

	}

	const MODE$1 = {
	    stop: 0,
	    destroy: 1,
	    yoyo: 2
	};

	const IsPlainObject$r = Phaser.Utils.Objects.IsPlainObject;

	var FadeIn = function (gameObject, duration, alpha, fade) {
	    var startAlpha, endAlpha;
	    if (IsPlainObject$r(alpha)) {
	        startAlpha = alpha.start;
	        endAlpha = alpha.end;
	    } else {
	        endAlpha = alpha;
	    }
	    if (startAlpha === undefined) {
	        startAlpha = 0;
	    }
	    if (endAlpha === undefined) {
	        endAlpha = 1;
	    }

	    var config = {
	        mode: 0,
	        start: startAlpha,
	        end: endAlpha,
	        duration: duration,
	    };

	    if (fade === undefined) {
	        fade = new Fade(gameObject, config);
	    } else {
	        fade.resetFromJSON(config);
	    }
	    fade.restart();

	    return fade;
	};

	var FadeOutDestroy = function (gameObject, duration, destroyMode, fade) {
	    if (destroyMode instanceof Fade) {
	        fade = destroyMode;
	        destroyMode = undefined;
	    }

	    if (destroyMode === undefined) {
	        destroyMode = true;
	    }

	    var config = {
	        mode: (destroyMode) ? 1 : 0,
	        end: 0,
	        duration: duration,
	    };

	    if (fade === undefined) {
	        fade = new Fade(gameObject, config);
	    } else {
	        fade.resetFromJSON(config);
	    }
	    fade.restart();

	    return fade;
	};

	const IsPlainObject$q = Phaser.Utils.Objects.IsPlainObject;

	var FadeMethods = {
	    onInitFade() {
	        var gameObject = this;
	        var fade = this._fade;

	        // Route 'complete' of fade to gameObject
	        fade.completeEventName = undefined;
	        fade.on('complete', function () {
	            if (fade.completeEventName) {
	                gameObject.emit(fade.completeEventName, gameObject);
	                fade.completeEventName = undefined;
	            }
	        });
	    },

	    fadeIn(duration, alpha) {
	        if (IsPlainObject$q(duration)) {
	            var config = duration;
	            duration = config.duration;
	            alpha = config.alpha;
	        }

	        var isInit = (this._fade === undefined);

	        this._fade = FadeIn(this, duration, alpha, this._fade);

	        if (isInit) {
	            this.onInitFade();
	        }

	        this._fade.completeEventName = 'fadein.complete';

	        return this;
	    },

	    fadeInPromise(duration, alpha) {
	        this.fadeIn(duration, alpha);
	        return WaitComplete(this._fade);
	    },

	    isRunningFadeIn() {
	        return this._fade && (this._fade.completeEventName === 'fadein.complete');
	    },

	    fadeOutDestroy(duration, destroyMode) {
	        if (IsPlainObject$q(duration)) {
	            var config = duration;
	            duration = config.duration;
	            destroyMode = config.destroy;
	        }

	        var isInit = (this._fade === undefined);

	        this._fade = FadeOutDestroy(this, duration, destroyMode, this._fade);

	        if (isInit) {
	            this.onInitFade();
	        }

	        this._fade.completeEventName = 'fadeout.complete';

	        return this;
	    },

	    fadeOutDestroyPromise(duration, destroyMode) {
	        this.fadeOutDestroy(duration, destroyMode);
	        return WaitComplete(this._fade);
	    },

	    fadeOut(duration) {
	        this.fadeOutDestroy(duration, false);
	        return this;
	    },

	    fadeOutPromise(duration) {
	        this.fadeOut(duration);
	        return WaitComplete(this._fade);
	    },

	    isRunningFadeOut() {
	        return this._fade && (this._fade.completeEventName === 'fadeout.complete');
	    },

	    isRunningEaseFade() {
	        return this.isRunningFadeIn() || this.isRunningFadeOut();
	    }
	};

	var methods$g = {};
	Object.assign(methods$g, FadeMethods);

	methods$g.onInitFade = function () {
	    FadeMethods.onInitFade.call(this);

	    var gameObject = this;
	    var fade = this._fade;
	    // Update local state
	    fade.on('update', function () {
	        var parent = GetParentSizerMethods.getParentSizer(gameObject);
	        if (parent) {
	            parent.resetChildAlphaState(gameObject);
	        }
	    });
	};

	const GetValue$1w = Phaser.Utils.Objects.GetValue;
	const GetAdvancedValue$1 = Phaser.Utils.Objects.GetAdvancedValue;
	const Linear$c = Phaser.Math.Linear;

	class EaseMove extends EaseValueTaskBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;
	        // this.timer

	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);

	        this.setMode(GetValue$1w(o, 'mode', 0));

	        if (o && (o.hasOwnProperty('x') || o.hasOwnProperty('y'))) {
	            var endX = GetAdvancedValue$1(o, 'x', undefined);
	            var endY = GetAdvancedValue$1(o, 'y', undefined);
	            this.setTargetPosition(endX, endY);
	        } else {
	            this.setTargetPosition(o);
	        }

	        return this;
	    }

	    setMode(m) {
	        if (typeof (m) === 'string') {
	            m = MODE[m];
	        }
	        this.mode = m;
	        return this;
	    }

	    setTargetPosition(x, y) {
	        if ((typeof (x) === 'number') || (typeof (y) === 'number')) {
	            // endX, endY
	            // x,y : a number, or undefined
	            this.startX = this.parent.x;
	            this.startY = this.parent.y;
	            this.endX = x;
	            this.endY = y;
	        } else {
	            var config = x;
	            this.startX = GetAdvancedValue$1(config, 'startX', undefined);
	            this.startY = GetAdvancedValue$1(config, 'startY', undefined);
	            this.endX = GetAdvancedValue$1(config, 'endX', undefined);
	            this.endY = GetAdvancedValue$1(config, 'endY', undefined);
	        }

	        this.hasMoveX = (this.startX !== undefined) && (this.endX !== undefined);
	        this.hasMoveY = (this.startY !== undefined) && (this.endY !== undefined);
	        return this;
	    }

	    start() {
	        if (this.timer.isRunning) {
	            return this;
	        }

	        var gameObject = this.parent;
	        if (this.hasMoveX) {
	            gameObject.x = this.startX;
	        }
	        if (this.hasMoveY) {
	            gameObject.y = this.startY;
	        }

	        this.timer
	            .setDelay(this.delay)
	            .setDuration(this.duration)
	            .setRepeat((this.mode === 2) ? -1 : 0);

	        super.start();
	        return this;
	    }

	    updateTarget(gameObject, timer) {
	        var t = timer.t;
	        if (timer.isOddIteration) {   // Yoyo
	            t = 1 - t;
	        }
	        t = this.easeFn(t);

	        if (this.hasMoveX) {
	            gameObject.x = Linear$c(this.startX, this.endX, t);
	        }
	        if (this.hasMoveY) {
	            gameObject.y = Linear$c(this.startY, this.endY, t);
	        }
	    }

	    complete() {
	        super.complete();

	        if (this.mode === 1) {
	            this.parent.destroy();
	            // Will also destroy this behavior
	        }
	        return this;
	    }
	}

	const MODE = {
	    stop: 0,
	    destroy: 1,
	    yoyo: 2
	};

	var ParseValue = function (propertyValue, startValue) {
	    // propertyValue : number or string
	    if (typeof (propertyValue) === 'number') {
	        return propertyValue;
	    } else {
	        var op = propertyValue[0];
	        var num = parseFloat(propertyValue.substr(2));
	        switch (op) {
	            case '+': return startValue + num;
	            case '-': return startValue - num;
	            case '*': return startValue * num;
	            case '/': return startValue / num;
	        }
	    }
	};

	var EaseMoveTo = function (gameObject, duration, endX, endY, ease, destroyMode, easeMove) {
	    if (destroyMode instanceof EaseMove) {
	        easeMove = destroyMode;
	        destroyMode = undefined;
	    }

	    if (destroyMode === undefined) {
	        destroyMode = false;
	    }

	    var config = {};
	    config.mode = (destroyMode) ? 1 : 0;
	    if (endX !== undefined) {
	        config.startX = gameObject.x;
	        config.endX = ParseValue(endX, gameObject.x);
	    }
	    if (endY !== undefined) {
	        config.startY = gameObject.y;
	        config.endY = ParseValue(endY, gameObject.y);
	    }
	    config.duration = duration;
	    config.ease = (ease === undefined) ? 'Linear' : ease;

	    if (easeMove === undefined) {
	        easeMove = new EaseMove(gameObject, config);
	    } else {
	        easeMove.resetFromJSON(config);
	    }
	    easeMove.restart();

	    return easeMove;
	};

	var EaseMoveFrom = function (gameObject, duration, startX, startY, ease, destroyMode, easeMove) {
	    if (destroyMode instanceof EaseMove) {
	        easeMove = destroyMode;
	        destroyMode = undefined;
	    }

	    if (destroyMode === undefined) {
	        destroyMode = false;
	    }

	    var config = {};
	    config.mode = (destroyMode) ? 1 : 0;
	    if (startX !== undefined) {
	        config.startX = ParseValue(startX, gameObject.x);
	        config.endX = gameObject.x;
	    }
	    if (startY !== undefined) {
	        config.startY = ParseValue(startY, gameObject.y);
	        config.endY = gameObject.y;
	    }
	    config.duration = duration;
	    config.ease = (ease === undefined) ? 'Linear' : ease;

	    if (easeMove === undefined) {
	        easeMove = new EaseMove(gameObject, config);
	    } else {
	        easeMove.resetFromJSON(config);
	    }
	    easeMove.restart();

	    return easeMove;
	};

	const IsPlainObject$p = Phaser.Utils.Objects.IsPlainObject;
	const DistanceBetween$5 = Phaser.Math.Distance.Between;

	var EaseMoveMethods = {
	    onInitEaseMove() {
	        var gameObject = this;
	        var easeMove = this._easeMove;
	        // Route 'complete' of easeMove to gameObject
	        easeMove.completeEventName = undefined;
	        easeMove.on('complete', function () {
	            if (easeMove.completeEventName) {
	                gameObject.emit(easeMove.completeEventName, gameObject);
	                easeMove.completeEventName = undefined;
	            }
	        });
	    },

	    moveFrom(duration, x, y, ease, destroyMode) {
	        if (IsPlainObject$p(duration)) {
	            var config = duration;
	            x = config.x;
	            y = config.y;
	            if (config.hasOwnProperty('speed')) {
	                duration = (DistanceBetween$5(x, y, this.x, this.y) * 1000) / config.speed;
	            } else {
	                duration = config.duration;
	            }

	            ease = config.ease;
	        }

	        var isInit = (this._easeMove === undefined);

	        this._easeMove = EaseMoveFrom(this, duration, x, y, ease, destroyMode, this._easeMove);

	        if (isInit) {
	            this.onInitEaseMove();
	        }

	        this._easeMove.completeEventName = 'movefrom.complete';

	        return this;
	    },

	    moveFromPromise(duration, x, y, ease, destroyMode) {
	        this.moveFrom(duration, x, y, ease, destroyMode);
	        return WaitComplete(this._easeMove);
	    },

	    moveFromDestroy(duration, x, y, ease) {
	        this.moveFrom(duration, x, y, ease, true);
	        return this;
	    },

	    moveFromDestroyPromise(duration, x, y, ease) {
	        this.moveFromDestroy(duration, x, y, ease);
	        return WaitComplete(this._easeMove);
	    },

	    isRunningMoveFrom() {
	        return this._easeMove && (this._easeMove.completeEventName = 'movefrom.complete');
	    },

	    moveTo(duration, x, y, ease, destroyMode) {
	        if (IsPlainObject$p(duration)) {
	            var config = duration;
	            x = config.x;
	            y = config.y;
	            if (config.hasOwnProperty('speed')) {
	                duration = (DistanceBetween$5(x, y, this.x, this.y) * 1000) / config.speed;
	            } else {
	                duration = config.duration;
	            }

	            ease = config.ease;
	        }

	        var isInit = (this._easeMove === undefined);

	        this._easeMove = EaseMoveTo(this, duration, x, y, ease, destroyMode, this._easeMove);

	        if (isInit) {
	            this.onInitEaseMove();
	        }

	        this._easeMove.completeEventName === 'moveto.complete';

	        return this;
	    },

	    moveToPromise(duration, x, y, ease, destroyMode) {
	        this.moveTo(duration, x, y, ease, destroyMode);
	        return WaitComplete(this._easeMove);
	    },

	    moveToDestroy(duration, x, y, ease) {
	        this.moveTo(duration, x, y, ease, true);
	        return this;
	    },

	    moveToDestroyPromise(duration, x, y, ease) {
	        this.moveToDestroy(duration, x, y, ease, true);
	        return WaitComplete(this._easeMove);
	    },

	    isRunningMoveTo() {
	        return this._easeMove && (this._easeMove.completeEventName === 'moveto.complete');
	    },

	    isRunningEaseMove() {
	        return this.isRunningMoveFrom() || this.isRunningMoveTo();
	    },

	    moveStop(toEnd) {
	        if (!this._easeMove) {
	            return this;
	        }

	        this._easeMove.stop(toEnd);
	        return this;
	    }
	};

	var methods$f = {};
	Object.assign(methods$f, EaseMoveMethods);

	methods$f.onInitEaseMove = function () {
	    EaseMoveMethods.onInitEaseMove.call(this);

	    var gameObject = this;
	    var easeMove = this._easeMove;
	    easeMove.on('update', function () {
	        var parent = GetParentSizerMethods.getParentSizer(gameObject);
	        if (parent) {
	            parent.resetChildPositionState(gameObject);
	        }
	    });
	};

	const IsPlainObject$o = Phaser.Utils.Objects.IsPlainObject;

	var OnInitShake = function (gameObject, shake) {
	    // Route 'complete' of shake to gameObject
	    shake.on('complete', function () {
	        gameObject.emit('shake.complete', gameObject);
	    });

	    // Shake effect won't change position
	};

	var ShakeMethods = {
	    shake(duration, magnitude, magnitudeMode) {
	        if (IsPlainObject$o(duration)) {
	            var config = duration;
	            duration = config.duration;
	            magnitude = config.magnitude;
	            magnitudeMode = config.magnitudeMode;
	        }

	        if (this._shake === undefined) {
	            this._shake = new ShakePosition(this, {
	                mode: 0,
	                magnitudeMode: 1
	            });
	            OnInitShake(this, this._shake);
	        }

	        if (duration !== undefined) {
	            this._shake.setDuration(duration);
	        }

	        if (magnitude !== undefined) {
	            this._shake.setMagnitude(magnitude);
	        }

	        if (magnitudeMode !== undefined) {
	            this._shake.setMagnitudeMode(magnitudeMode);
	        }

	        this._shake.shake();

	        return this;
	    },

	    shakePromise(duration, alpha) {
	        this.shake(duration, alpha);
	        return WaitComplete(this._shake);
	    },
	};

	const IsPlainObject$n = Phaser.Utils.Objects.IsPlainObject;

	class EaseData extends ComponentBase {
	    constructor(parent, config) {
	        super(parent, config);

	        this.parent.setDataEnabled();
	        this.easeTasks = {};
	    }

	    complete(key) {
	        this.emit(`complete-${key}`, this.parent, this);
	        this.emit('complete', key, this.parent, this);
	    }

	    getEaseTask(key) {
	        var easeTask = this.easeTasks[key];
	        if (easeTask === undefined) {
	            easeTask = new EaseValueTask(this.parent);
	            this.easeTasks[key] = easeTask;

	            easeTask
	                .setTarget(this.parent.data.values)
	                .on('complete', function () {
	                    this.complete(key);
	                }, this);
	        }
	        return easeTask;
	    }

	    easeTo(key, value, duration, ease) {
	        if (IsPlainObject$n(key)) {
	            var config = key;
	            key = config.key;
	            value = config.value;
	            duration = config.duration;
	            ease = config.ease;

	            var speed = config.speed;
	            if ((duration === undefined) && (speed !== undefined)) {
	                duration = (Math.abs(value - this.parent.data.values[key]) / speed) * 1000;
	            }
	        }

	        if (duration === undefined) {
	            duration = 1000;
	        }
	        if (ease === undefined) {
	            ease = 'Linear';
	        }

	        var easeTask = this.getEaseTask(key);
	        easeTask.restart({
	            key: key,
	            to: value,
	            duration: duration,
	            ease: ease
	        });

	        return this;
	    }

	    easeFrom(key, value, duration, ease) {
	        if (IsPlainObject$n(key)) {
	            var config = key;
	            key = config.key;
	            value = config.value;
	            duration = config.duration;
	            ease = config.ease;

	            var speed = config.speed;
	            if ((duration === undefined) && (speed !== undefined)) {
	                duration = (Math.abs(value - this.parent.data.values[key]) / speed) * 1000;
	            }
	        }

	        if (duration === undefined) {
	            duration = 1000;
	        }
	        if (ease === undefined) {
	            ease = 'Linear';
	        }

	        var easeTask = this.getEaseTask(key);
	        easeTask.restart({
	            key: key,
	            from: value,
	            duration: duration,
	            ease: ease
	        });

	        return this;
	    }

	    stopEase(key, toEnd) {
	        if (toEnd === undefined) {
	            toEnd = true;
	        }

	        var easeTask = this.easeTasks[key];
	        if (easeTask) {
	            easeTask.stop(toEnd);
	        }

	        return this;
	    }

	    stopAll(toEnd) {
	        if (toEnd === undefined) {
	            toEnd = true;
	        }

	        for (var key in this.easeTasks) {
	            this.stopEase(key, toEnd);
	        }
	        return this;
	    }
	}

	var OnInitEaseData = function (gameObject, easeData) {
	    // Route 'complete' of easeData to gameObject
	    easeData.on('complete', function (key) {
	        gameObject.emit(`easedata.${key}.complete`, gameObject);
	        gameObject.emit('easedata.complete', key, gameObject);
	    });
	};

	var EaseDataMethods = {
	    easeDataTo(key, value, duration, ease) {
	        if (!this._easeData) {
	            this._easeData = new EaseData(this);
	            OnInitEaseData(this, this._easeData);
	        }
	        this._easeData.easeTo(key, value, duration, ease);
	        return this;
	    },

	    easeDataToPromise(key, value, duration, ease) {
	        this.easeDataTo(key, value, duration, ease);
	        return WaitEvent(this._easeData, `complete-${key}`);
	    },

	    stopEaseData(key, toEnd) {
	        if (!this._easeData) {
	            return this;
	        }

	        this._easeData.stopEase(key, toEnd);
	        return this;
	    },

	    stopAllEaseData(toEnd) {
	        if (!this._easeData) {
	            return this;
	        }

	        this._easeData.stopAll(toEnd);
	        return this;
	    }
	};

	var RemoveItem$6 = Phaser.Utils.Array.Remove;

	var OnInitDelayCallTimers = function (gameObject) {
	    gameObject._delayCallTimers = [];
	    gameObject.once('destroy', function () {
	        var timers = gameObject._delayCallTimers;
	        for (var i = 0, cnt = timers.length; i < cnt; i++) {
	            timers[i].remove();
	        }
	        gameObject._delayCallTimers = undefined;
	    });
	};

	var DelayCallMethods$1 = {
	    delayCall(delay, callback, scope) {
	        var timers = this._delayCallTimers;

	        if (timers === undefined) {
	            OnInitDelayCallTimers(this);
	        }


	        var timer;
	        var self = this;
	        var OnTimeOut = function () {
	            RemoveItem$6(self._delayCallTimers, timer);
	            if (scope) {
	                callback.call(scope);
	            } else {
	                callback();
	            }
	        };

	        timer = this.scene.time.delayedCall(delay, OnTimeOut);
	        this._delayCallTimers.push(timer);

	        return this;
	    },
	};

	var Show = function (gameObject) {
	    _hide(gameObject, false);
	};

	var Hide = function (gameObject) {
	    _hide(gameObject, true);
	};

	var IsShown = function (gameObject) {
	    if (!gameObject) {
	        return false;
	    }
	    var config = GetSizerConfig$1(gameObject);
	    return !config.hidden;
	};

	var _hide = function (gameObject, hidden) {
	    if (!gameObject) {
	        return;
	    }
	    var config = GetSizerConfig$1(gameObject);
	    config.hidden = hidden;

	    var parent = GetParent$1(gameObject);
	    if (parent) {
	        parent.setChildVisible(gameObject, !hidden);
	    } else {
	        gameObject.setVisible(!hidden);
	    }
	};

	var HideMethods = {
	    show(gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }
	        Show(gameObject);
	        return this;
	    },

	    hide(gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }
	        Hide(gameObject);
	        return this;
	    },

	    isShow(gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }
	        return IsShown(gameObject);
	    }
	};

	const StateProperties$1 = ['next', 'exit', 'enter'];

	let FSM$1 = class FSM {
	    /*
	    var config = {
	        start: 'A',   // default: undefined
	        states: {
	            A: {
	                next: 'B',  // function() { return 'B'; }
	                enter: function() {},
	                exit: function() {},
	            },
	            // ...
	        },        
	        extend: {
	            i: 0,
	            name: 'abc'
	            // ...
	        },
	        init: function() {},
	        enable: true,
	        eventEmitter: true,
	    };
	    */
	    constructor(config) {
	        // Attach get-next-state function
	        var states = GetValue$2b(config, 'states', undefined);
	        if (states) {
	            this.addStates(states);
	        }

	        // Attach extend members
	        var extend = GetValue$2b(config, 'extend', undefined);
	        if (extend) {
	            for (var name in extend) {
	                if (!this.hasOwnProperty(name) || this[name] === undefined) {
	                    this[name] = extend[name];
	                }
	            }
	        }

	        // Event emitter
	        var eventEmitter = GetValue$2b(config, 'eventEmitter', undefined);
	        var EventEmitterClass = GetValue$2b(config, 'EventEmitterClass', undefined);
	        this.setEventEmitter(eventEmitter, EventEmitterClass);

	        this._stateLock = false;
	        this.resetFromJSON(config);
	    }

	    shutdown() {
	        this.destroyEventEmitter();
	    }

	    destroy() {
	        this.shutdown();
	    }

	    resetFromJSON(o) {
	        this.setEnable(GetValue$2b(o, 'enable', true));
	        this.start(GetValue$2b(o, 'start', undefined));
	        var init = GetValue$2b(o, 'init', undefined);
	        if (init) {
	            init.call(this);
	        }

	        return this;
	    }

	    toJSON() {
	        return {
	            curState: this.state,
	            prevState: this.prevState,

	            enable: this.enable,
	            start: this._start
	        };
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }
	        this.enable = e;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }

	    set state(newState) {
	        if (!this.enable || this._stateLock) {
	            return;
	        }
	        if (this._state === newState) {
	            return;
	        }
	        this._prevState = this._state;
	        this._state = newState;

	        this._stateLock = true; // lock state

	        this.emit('statechange', this);

	        if (this._prevState != null) {
	            var exitEventName = 'exit_' + this._prevState;
	            var exitCallback = this[exitEventName];
	            if (exitCallback) {
	                exitCallback.call(this);
	            }
	            this.emit(exitEventName, this);
	        }

	        this._stateLock = false;

	        if (this._state != null) {
	            var enterEventName = 'enter_' + this._state;
	            var enterCallback = this[enterEventName];
	            if (enterCallback) {
	                enterCallback.call(this);
	            }
	            this.emit(enterEventName, this);
	        }
	    }

	    get state() {
	        return this._state;
	    }

	    get prevState() {
	        return this._prevState;
	    }

	    start(state) {
	        this._start = state;
	        this._prevState = undefined;
	        this._state = state; // Won't fire statechange events
	        return this;
	    }

	    goto(nextState) {
	        if (nextState != null) {
	            this.state = nextState;
	        }
	        return this;
	    }

	    next() {
	        var nextState;
	        var getNextState = this['next_' + this.state];
	        if (getNextState) {
	            if (typeof (getNextState) === 'string') {
	                nextState = getNextState;
	            } else {
	                nextState = getNextState.call(this);
	            }
	        }

	        this.goto(nextState);
	        return this;
	    }

	    get stateProperties() {
	        return StateProperties$1;
	    }

	    addState(name, state) {
	        if (typeof (name) !== 'string') {
	            state = name;
	            name = state.name;
	        }

	        var stateProperties = this.stateProperties;
	        for (var i = 0, cnt = stateProperties.length; i < cnt; i++) {
	            var propertyName = stateProperties[i];
	            var propertyValue = state[propertyName];
	            if (propertyValue) {
	                this[`${propertyName}_${name}`] = propertyValue;
	            }
	        }

	        return this;
	    }

	    addStates(states) {
	        if (Array.isArray(states)) {
	            for (var i = 0, cnt = states.length; i < cnt; i++) {
	                this.addState(states[i]);
	            }
	        } else {
	            for (var name in states) {
	                this.addState(name, states[name]);
	            }
	        }
	        return this;
	    }

	    runMethod(methodName, a1, a2, a3, a4, a5) {
	        var fn = this[methodName + '_' + this.state];
	        if (!fn) {
	            return undefined;
	        }

	        // Copy from eventemitter3
	        var len = arguments.length;
	        switch (len) {
	            case 1: return fn.call(this);
	            case 2: return fn.call(this, a1);
	            case 3: return fn.call(this, a1, a2);
	            case 4: return fn.call(this, a1, a2, a3);
	            case 5: return fn.call(this, a1, a2, a3, a4);
	            case 6: return fn.call(this, a1, a2, a3, a4, a5);
	        }
	        var args = new Array(len - 1);
	        for (var i = 1; i < len; i++) {
	            args[i - 1] = arguments[i];
	        }
	        return fn.apply(this, args);
	    }
	};

	Object.assign(
	    FSM$1.prototype,
	    EventEmitterMethods,
	);

	var HasListener = function (eventEmitter, eventName, fn, context, once) {
	    if (once === undefined) {
	        once = false;
	    }

	    var listeners = eventEmitter._events[eventName];
	    if (!listeners) {
	        return false;
	    }

	    for (var i = 0, cnt = listeners.length; i < cnt; i++) {
	        var listener = listeners[i];
	        if ((listener.fn === fn) &&
	            (listener.context === context) &&
	            (listener.once === once)
	        ) {
	            return true;
	        }
	    }

	    return false;

	};

	const StateProperties = ['next', 'exit', 'enter', 'update', 'preupdate', 'postupdate'];

	class FSM extends FSM$1 {
	    /*
	    var config = {
	        start: 'A',   // default: undefined
	        states: {
	            A: {
	                next: 'B',  // function() { return 'B'; }
	                enter: function() {},
	                exit: function() {},
	                update: function(time, delta) {},
	                preupdate: function(time, delta) {},
	                postupdate: function(time, delta) {},
	            },
	            // ...
	        },        
	        extend: {
	            i: 0,
	            name: 'abc'
	            // ...
	        },
	        init: function() {},
	        enable: true,
	        scene: undefined,
	        eventEmitter: true,
	    };
	    */
	    shutdown() {
	        this.stopUpdate();
	        this.stopPreUpdate();
	        this.stopPostUpdate();
	        this._scene = undefined;

	        super.shutdown();
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);
	        this._scene = GetValue$2b(o, 'scene', undefined);
	        return this;
	    }

	    get stateProperties() {
	        return StateProperties;
	    }

	    update(time, delta) {
	        this.runMethod('update', time, delta);
	    }

	    preupdate(time, delta) {
	        this.runMethod('preupdate', time, delta);
	    }

	    postupdate(time, delta) {
	        this.runMethod('postupdate', time, delta);
	    }

	    startUpdate(scene) {
	        if (!scene) {
	            scene = this._scene;
	        }

	        var eventEmitter = scene.sys.events;
	        if (HasListener(eventEmitter, 'update', this.update, this)) {
	            return this;
	        }

	        this._scene = scene;
	        eventEmitter.on('update', this.update, this);
	        return this;
	    }

	    stopUpdate() {
	        if (!this._scene) {
	            return this;
	        }

	        this._scene.sys.events.off('update', this.update, this);
	        return this;
	    }

	    startPreUpdate(scene) {
	        if (!scene) {
	            scene = this._scene;
	        }

	        var eventEmitter = scene.sys.events;
	        if (HasListener(eventEmitter, 'preupdate', this.preupdate, this)) {
	            return this;
	        }

	        this._scene = scene;
	        eventEmitter.on('preupdate', this.preupdate, this);
	        return this;
	    }

	    stopPreUpdate() {
	        if (!this._scene) {
	            return this;
	        }

	        this._scene.sys.events.off('preupdate', this.preupdate, this);
	        return this;
	    }

	    startPostUpdate(scene) {
	        if (!scene) {
	            scene = this._scene;
	        }

	        var eventEmitter = scene.sys.events;
	        if (HasListener(eventEmitter, 'postupdate', this.postupdate, this)) {
	            return this;
	        }

	        this._scene = scene;
	        eventEmitter.on('postupdate', this.postupdate, this);
	        return this;
	    }

	    stopPostUpdate() {
	        if (!this._scene) {
	            return this;
	        }

	        this._scene.sys.events.off('postupdate', this.postupdate, this);
	        return this;
	    }
	}

	/*
	graph TD

	IDLE --> |"requestOpen()"| TRANS_OPNE["TRAN_OPEN<br>runTransitionInCallback()"]
	TRANS_OPNE --> |transitInTime| OPEN
	OPEN --> |"requestClose()"| TRANS_CLOSE["TRANS_CLOSE<br>runTransitionOutCallback()"]
	TRANS_CLOSE --> |transitOutTime| CLOSE
	CLOSE --> |"requestOpen()"| TRANS_OPNE
	*/

	let State$1 = class State extends FSM {
	    constructor(parent, config) {
	        super(config);
	        this.parent = parent;

	        var initState = config.initState || 'IDLE';
	        this.start(initState);
	    }

	    init() {
	        this.start('IDLE');
	    }

	    // IDLE -> TRANS_OPNE
	    next_IDLE() {
	        return 'TRANS_OPNE';
	    }
	    // IDLE

	    // TRANS_OPNE -> OPEN
	    next_TRANS_OPNE() {
	        return 'OPEN';
	    }
	    enter_TRANS_OPNE() {
	        var transitionBehavior = this.parent;
	        if (transitionBehavior.transitInTime > 0) {
	            var delay = transitionBehavior.runTransitionInCallback();
	            transitionBehavior.delayCall(delay, this.next, this);
	        } else {
	            this.next();
	        }
	    }
	    exit_TRANS_OPNE() {
	        var transitionBehavior = this.parent;
	        transitionBehavior.removeDelayCall();
	    }
	    // TRANS_OPNE

	    // OPEN -> TRANS_CLOSE
	    next_OPEN() {
	        return 'TRANS_CLOSE';
	    }
	    enter_OPEN() {
	        var transitionBehavior = this.parent;
	        transitionBehavior.onOpen();
	    }
	    exit_OPEN() {
	        var transitionBehavior = this.parent;
	        transitionBehavior.removeDelayCall();
	    }
	    // OPEN

	    // TRANS_CLOSE -> CLOSE
	    next_TRANS_CLOSE() {
	        return 'CLOSE';
	    }
	    enter_TRANS_CLOSE() {
	        var transitionBehavior = this.parent;
	        if (transitionBehavior.transitOutTime > 0) {
	            var delay = transitionBehavior.runTransitionOutCallback();
	            transitionBehavior.delayCall(delay, this.next, this);
	        } else {
	            this.next();
	        }
	    }
	    exit_TRANS_CLOSE() {
	        var transitionBehavior = this.parent;
	        transitionBehavior.removeDelayCall();
	    }
	    // TRANS_CLOSE

	    // CLOSE -> TRANS_OPNE
	    next_CLOSE() {
	        return 'TRANS_OPNE';
	    }
	    enter_CLOSE() {
	        var transitionBehavior = this.parent;
	        transitionBehavior.onClose();
	    }
	    exit_CLOSE() {
	    }
	    // CLOSE

	    canOpen() {
	        return (this.state === 'IDLE') || (this.state === 'CLOSE');
	    }

	    canClose() {
	        return (this.state === 'IDLE') || (this.state === 'OPEN');
	    }
	};

	var PostStepDelayCall = function (gameObject, delay, callback, scope, args) {
	    // Invoke callback under game's 'poststep' event
	    var scene = GetSceneObject(gameObject);
	    var timer = scene.time.delayedCall(delay, function () {
	        scene.game.events.once('poststep', function () {
	            callback.call(scope, args);
	        });
	    });
	    return timer;
	};

	var DelayCallMethods = {
	    delayCall(delay, callback, scope) {
	        // Invoke callback under scene's 'postupdate' event
	        this.delayCallTimer = PostStepDelayCall(this, delay, callback, scope);
	        return this;
	    },

	    removeDelayCall() {
	        if (this.delayCallTimer) {
	            this.delayCallTimer.remove(false);
	            this.delayCallTimer = undefined;
	        }
	        return this;
	    }

	};

	var ConfigurationMethods = {
	    setTransitInTime(time) {
	        this.transitInTime = time;
	        return this;
	    },

	    setTransitOutTime(time) {
	        this.transitOutTime = time;
	        return this;
	    },

	    setTransitInCallback(callback) {
	        if (!callback) {
	            callback = NOOP;
	        }

	        this.transitInCallback = callback;
	        // callback = function(gameObject, duration) {}
	        return this;
	    },

	    setTransitOutCallback(callback) {
	        if (!callback) {
	            callback = NOOP;
	        }

	        this.transitOutCallback = callback;
	        // callback = function(gameObject, duration) {}
	        return this;
	    },

	};

	var OpenMethods = {
	    // Override
	    runTransitionInCallback() {
	        this.transitInCallback(this.parent, this.transitInTime);
	        return this.transitInTime;
	    },

	    // Override
	    onOpen() {
	    },

	    requestOpen(openEventData, duration) {
	        if (!this._state.canOpen()) {
	            return this;
	        }

	        this.openEventData = (arguments.length > 0) ? openEventData : this.parent;

	        var transitionTimeSave = this.transitInTime;
	        if (duration !== undefined) {
	            this.transitInTime = duration;
	        }

	        this._state.goto('TRANS_OPNE');

	        this.transitInTime = transitionTimeSave;

	        return this;
	    },
	};

	var CloseMethods = {
	    // Override
	    runTransitionOutCallback() {
	        this.transitOutCallback(this.parent, this.transitOutTime);
	        return this.transitOutTime;
	    },

	    // Override
	    onClose() {
	        // Destroy parent and this behavior
	        if (this.oneShotMode) {
	            this.parent.destroy();
	            // Will invoke `this.destroy()`
	        }
	    },

	    requestClose(closeEventData, duration) {
	        if (!this._state.canClose) {
	            return this;
	        }

	        this.closeEventData = (arguments.length > 0) ? closeEventData : this.parent;

	        var transitionTimeSave = this.transitOutTime;
	        if (duration !== undefined) {
	            this.transitOutTime = duration;
	        }

	        this._state.goto('TRANS_CLOSE');

	        this.transitOutTime = transitionTimeSave;

	        return this;
	    },
	};

	var methods$e = {};

	Object.assign(
	    methods$e,
	    DelayCallMethods,
	    ConfigurationMethods,
	    OpenMethods,
	    CloseMethods,
	);

	const GetValue$1v = Phaser.Utils.Objects.GetValue;

	class OpenCloseTransition extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;
	        // this.scene

	        this.setTransitInTime(GetValue$1v(config, 'duration.in', 200));
	        this.setTransitOutTime(GetValue$1v(config, 'duration.out', 200));
	        this.setTransitInCallback(GetValue$1v(config, 'transitIn'));
	        this.setTransitOutCallback(GetValue$1v(config, 'transitOut'));

	        this.oneShotMode = GetValue$1v(config, 'destroy', false);

	        this.delayCallTimer = undefined;
	        this._state = new State$1(this, {
	            eventEmitter: false,
	            initState: GetValue$1v(config, 'initState', 'IDLE')
	        });
	        this.openEventData = undefined;
	        this.closeEventData = undefined;
	    }

	    get state() {
	        return this._state.state;
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        this.transitInCallback = undefined;
	        this.transitOutCallback = undefined;
	        this.openEventData = undefined;
	        this.closeEventData = undefined;

	        this.removeDelayCall();

	        super.shutdown(fromScene);
	    }
	}

	Object.assign(
	    OpenCloseTransition.prototype,
	    methods$e,
	);

	const Rectangle$2 = Phaser.GameObjects.Rectangle;

	class FullWindowRectangle extends Rectangle$2 {
	    constructor(scene, color, alpha) {
	        super(scene, 0, 0, 2, 2, color, 1);

	        this.fullWindow = new FullWindow(this);

	        this.setAlpha(alpha);
	    }

	    get tint() {
	        return this.fillColor;
	    }

	    set tint(value) {
	        this.setFillStyle(value, this.fillAlpha);
	    }
	}

	const GetValue$1u = Phaser.Utils.Objects.GetValue;

	class TouchEventStop extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, { eventEmitter: false });
	        // No event emitter
	        // this.parent = gameObject;

	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.setHitAreaMode(GetValue$1u(o, 'hitAreaMode', 0));
	        this.setEnable(GetValue$1u(o, 'enable', true));
	        this.setStopMode(GetValue$1u(o, 'stopAllLevels', true));
	        return this;
	    }

	    boot() {
	        this.parent
	            .on('pointerdown', function (pointer, localX, localY, event) {
	                if (this.stopAllLevels) {
	                    event.stopPropagation();
	                }
	            }, this)
	            .on('pointerup', function (pointer, localX, localY, event) {
	                if (this.stopAllLevels) {
	                    event.stopPropagation();
	                }
	            }, this)
	            .on('pointermove', function (pointer, localX, localY, event) {
	                if (this.stopAllLevels) {
	                    event.stopPropagation();
	                }
	            }, this)
	            .on('pointerover', function (pointer, localX, localY, event) {
	                if (this.stopAllLevels) {
	                    event.stopPropagation();
	                }
	            }, this)
	            .on('pointerout', function (pointer, event) {
	                if (this.stopAllLevels) {
	                    event.stopPropagation();
	                }
	            }, this);
	    }

	    setHitAreaMode(mode) {
	        if (typeof (mode) === 'string') {
	            mode = HitAreaMode[mode];
	        }

	        var gameObject = this.parent;
	        if (gameObject.input) {
	            gameObject.removeInteractive();
	        }

	        if (mode === 0) {
	            gameObject.setInteractive();
	        } else {
	            gameObject.setInteractive({
	                hitArea: {},
	                hitAreaCallback: function () { return true; }
	            });
	        }

	        return this;
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        if (e) {
	            this.parent.setInteractive();
	        } else {
	            this.parent.disableInteractive();
	        }

	        this.enable = e;
	        return this;
	    }

	    setStopMode(allLevels) {
	        if (allLevels === undefined) {
	            allLevels = true;
	        }
	        this.stopAllLevels = allLevels;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }
	}

	var HitAreaMode = {
	    default: 0,
	    fullWindow: 1
	};

	const GetValue$1t = Phaser.Utils.Objects.GetValue;

	class Cover extends FullWindowRectangle {
	    constructor(scene, config) {
	        var fillColor = GetValue$1t(config, 'color', 0x0);
	        var fillAlpha = GetValue$1t(config, 'alpha', 0.8);
	        super(scene, fillColor, fillAlpha);

	        this.touchEventStop = new TouchEventStop(this, { hitAreaMode: 1 });
	    }
	}

	var CreateCover = function (gameObject, config) {
	    var scene = gameObject.scene;
	    var cover = new Cover(scene, config);
	    scene.add.existing(cover);

	    // Put cover behind game object
	    if (gameObject.isRexContainerLite) {
	        gameObject.pin(cover, {
	            syncPosition: false,
	            syncRotation: false,
	            syncScale: false,
	            syncAlpha: false,
	            syncScrollFactor: false
	        });
	        gameObject.moveDepthBelow(cover);
	    } else {
	        scene.children.moveBelow(cover, gameObject);
	    }
	    return cover;
	};

	var DefaultTransitCallbacks = {
	    popUp(gameObject, duration) {
	        if (gameObject._modalScaleSave !== undefined) {
	            gameObject.scaleX = gameObject._modalScaleSave;
	            gameObject.scaleY = gameObject._modalScaleSave;
	        } else {
	            gameObject._modalScaleSave = gameObject.scaleX;
	        }

	        PopUp$1(gameObject, duration);
	    },

	    scaleDown(gameObject, duration) {
	        // Don't destroy here
	        ScaleDownDestroy(gameObject, duration, undefined, undefined, false);
	    },

	    fadeIn(gameObject, duration) {
	        if (gameObject._modalAlphaSave !== undefined) {
	            gameObject.alpha = gameObject._modalAlphaSave;
	        } else {
	            gameObject._modalAlphaSave = gameObject.alpha;
	        }

	        FadeIn(gameObject, duration);
	    },

	    fadeOut(gameObject, duration) {
	        // Don't destroy here
	        FadeOutDestroy(gameObject, duration, false);
	    },
	};

	var DefaultCoverTransitInCallback = function (cover, duration) {
	    if (cover._modalAlphaSave !== undefined) {
	        cover.alpha = cover._modalAlphaSave;
	    } else {
	        cover._modalAlphaSave = cover.alpha;
	    }

	    FadeIn(cover, duration, cover.alpha);
	};

	var DefaultCoverTransitOutCallback = function (cover, duration) {
	    FadeOutDestroy(cover, duration, false);
	};

	var IsPointInBounds = function (gameObject, x, y, preTest, postTest) {
	    // Can't get bounds
	    if (!gameObject) {
	        return false;
	    }

	    if (preTest && !preTest(gameObject, x, y)) {
	        return false;
	    }

	    var boundsRect = GetBounds(gameObject, true);
	    if (!boundsRect.contains(x, y)) {
	        return false;
	    }

	    if (postTest && !postTest(gameObject, x, y)) {
	        return false;
	    }

	    return true;
	};

	const GetValue$1s = Phaser.Utils.Objects.GetValue;

	let Modal$3 = class Modal extends OpenCloseTransition {
	    constructor(gameObject, config) {
	        if (config === undefined) {
	            config = {};
	        }
	        if (config.transitIn == null) {
	            config.transitIn = TransitionMode.popUp;
	        }
	        if (config.transitOut == null) {
	            config.transitOut = TransitionMode.scaleDown;
	        }

	        config.destroy = GetValue$1s(config, 'destroy', true);

	        super(gameObject, config);
	        // this.parent = gameObject;
	        // this.scene

	        // Cover : key of modal, to block touch input        
	        var coverConfig = GetValue$1s(config, 'cover');
	        this.cover = (coverConfig !== false) ? CreateCover(gameObject, coverConfig) : undefined;
	        if (this.cover) {
	            this.setCoverTransitInCallback(GetValue$1s(coverConfig, 'transitIn', DefaultCoverTransitInCallback));
	            this.setCoverTransitOutCallback(GetValue$1s(coverConfig, 'transitOut', DefaultCoverTransitOutCallback));
	        }

	        // Close conditions:
	        var touchOutsideClose = GetValue$1s(config, 'touchOutsideClose', false);
	        var timeOutDuration = GetValue$1s(config, 'duration.hold', -1);
	        var timeOutClose = GetValue$1s(config, 'timeOutClose', (timeOutDuration >= 0));
	        var anyTouchClose = GetValue$1s(config, 'anyTouchClose', false);
	        var manualClose = GetValue$1s(config, 'manualClose', false);

	        if (manualClose) {
	            touchOutsideClose = false;
	            anyTouchClose = false;
	            timeOutClose = false;
	        }

	        if (anyTouchClose) {
	            touchOutsideClose = false;
	        }

	        if (timeOutClose) {
	            this.setDisplayTime(timeOutDuration);
	        } else {
	            this.setDisplayTime(-1);
	        }

	        // Registet touch-close event after opened
	        if (anyTouchClose) {
	            this.once('open', this.anyTouchClose, this);
	        } else if (touchOutsideClose) {
	            this.once('open', this.touchOutsideClose, this);
	        }

	        if (GetValue$1s(config, 'openOnStart', true)) {
	            // Run this.requestOpen() next tick
	            // User can register events before this.requestOpen()
	            this.delayCall(0, this.requestOpen, this);
	        }
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        // Registered in touchOutsideClose(), or anyTouchClose()
	        if (!this.cover) {
	            this.scene.input.off('pointerup', this.touchCloseCallback, this);
	        }

	        if (this.cover && !fromScene) {
	            this.cover.destroy();
	            this.cover = undefined;
	        }

	        super.shutdown(fromScene);
	    }

	    touchOutsideClose() {
	        if (this.cover) {
	            this.cover.on('pointerup', this.touchCloseCallback, this);
	        } else {
	            this.scene.input.on('pointerup', this.touchCloseCallback, this);
	        }
	        this.clickOutsideTest = true;
	        return this;
	    }

	    anyTouchClose() {
	        if (this.cover) {
	            this.cover.once('pointerup', this.touchCloseCallback, this);
	        } else {
	            this.scene.input.once('pointerup', this.touchCloseCallback, this);
	        }
	        return this;
	    }

	    touchCloseCallback(pointer) {
	        if (this.clickOutsideTest && IsPointInBounds(this.parent, pointer.worldX, pointer.worldY)) {
	            return;
	        }
	        this.requestClose();
	    }

	    runTransitionInCallback() {
	        var duration = super.runTransitionInCallback();

	        var cover = this.cover;
	        if (cover && this.coverTransitInCallback) {
	            this.coverTransitInCallback(cover, duration);
	        }

	        return duration;
	    }

	    runTransitionOutCallback() {
	        var duration = super.runTransitionOutCallback();

	        var cover = this.cover;
	        if (cover && this.coverTransitOutCallback) {
	            this.coverTransitOutCallback(cover, duration);
	        }

	        return duration;
	    }

	    onOpen() {
	        var duration = this.displayTime;
	        if (duration >= 0) {
	            this.delayCall(
	                duration,
	                this.requestClose, // callback
	                this               // scope
	            );
	        }

	        this.emit('open', this.parent, this);

	        super.onOpen();
	    }

	    onClose() {
	        this.emit('close', this.closeEventData);

	        super.onClose();
	    }

	    setDisplayTime(time) {
	        this.displayTime = time;
	        return this;
	    }

	    setTransitInCallback(callback) {
	        if (typeof (callback) === 'string') {
	            callback = TransitionMode[callback];
	        }

	        switch (callback) {
	            case TransitionMode.popUp:
	                callback = DefaultTransitCallbacks.popUp;
	                break;
	            case TransitionMode.fadeIn:
	                callback = DefaultTransitCallbacks.fadeIn;
	                break;
	        }

	        super.setTransitInCallback(callback);
	        // callback = function(gameObject, duration) {}
	        return this;
	    }

	    setTransitOutCallback(callback) {
	        if (typeof (callback) === 'string') {
	            callback = TransitionMode[callback];
	        }

	        switch (callback) {
	            case TransitionMode.scaleDown:
	                callback = DefaultTransitCallbacks.scaleDown;
	                break;
	            case TransitionMode.fadeOut:
	                callback = DefaultTransitCallbacks.fadeOut;
	                break;
	        }

	        super.setTransitOutCallback(callback);
	        // callback = function(gameObject, duration) {}
	        return this;
	    }

	    setCoverTransitInCallback(callback) {
	        this.coverTransitInCallback = callback;
	        return this;
	    }

	    setCoverTransitOutCallback(callback) {
	        this.coverTransitOutCallback = callback;
	        return this;
	    }

	};

	const TransitionMode = {
	    popUp: 0,
	    fadeIn: 1,
	    scaleDown: 0,
	    fadeOut: 1,
	};

	var Modal$2 = function (gameObject, config) {
	    var modalBehavior = new Modal$3(gameObject, config);

	    // Route modal's 'open', 'close' event
	    modalBehavior.on('open', function () {
	        gameObject.emit('modal.open', modalBehavior);
	    });
	    modalBehavior.on('close', function (closeEventData) {
	        gameObject.emit('modal.close', closeEventData, modalBehavior);
	    });

	    // Reigster 'modal.requestClose' event for invoking modalBehavior.requestClose() method
	    gameObject.on('modal.requestClose', modalBehavior.requestClose, modalBehavior);
	    /*
	    It is not necessary to turn off gameObject's 'modal.requestClose' event because that :

	    - If `config.destroy` is `undefined` (or `true), gameObject and modalBehavior will be destroyed
	    - If `config.destroy` is `false` (for reusing dialog), keeping gameObject and modalBehavior 
	    */

	    return modalBehavior;
	};

	var ModalClose = function (gameObject, closeEventData) {
	    gameObject.emit('modal.requestClose', closeEventData);
	};

	var IsFunction = function (obj) {    
	    return obj && (typeof(obj) === 'function');
	};

	var ModalMethods$1 = {
	    // Override
	    // onCreateModalBehavior(self, config) { },

	    modal(config, onClose) {
	        if (IsFunction(config)) {
	            onClose = config;
	            config = undefined;
	        }

	        if (this._modalBehavior === undefined) {
	            if (this.onCreateModalBehavior) {
	                this.onCreateModalBehavior(this, config);
	            }
	            this._modalBehavior = Modal$2(this, config);
	        }

	        if (onClose) {
	            this._modalBehavior.once('close', onClose);
	        }

	        this._modalBehavior.requestOpen();

	        return this;
	    },

	    modalPromise(config) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            self.modal(config, resolve);
	        });
	    },

	    modalClose(closeEventData) {
	        ModalClose(this, closeEventData);
	        return this;
	    }
	};

	var BindSceneEvent = function (eventName, gameObject, callback, scope, once) {
	    if (IsFunction(gameObject)) {
	        once = scope;
	        scope = callback;
	        callback = gameObject;
	        gameObject = this;
	    }

	    var eventEmitter = this.scene.events;

	    this.bindEvent(gameObject, eventEmitter, eventName, callback, scope, once);

	    return this;
	};

	var BindEventMethods = {
	    bindEvent(gameObject, eventEmitter, eventName, callback, scope, once) {
	        if (typeof (eventEmitter) === 'string') {
	            once = scope;
	            scope = callback;
	            callback = eventName;
	            eventName = eventEmitter;
	            eventEmitter = gameObject;
	            gameObject = this;
	        }

	        BindEventWithGameObject(gameObject, eventEmitter, eventName, callback, scope, once);

	        return this;
	    },

	    bindScenePreupdateEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'preupdate', gameObject, callback, scope, once);
	        return this;
	    },

	    bindSceneUpdateEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'update', gameObject, callback, scope, once);
	        return this;
	    },

	    bindScenePostupdateEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'postupdate', gameObject, callback, scope, once);
	        return this;
	    },

	    bindSceneRenderEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'render', gameObject, callback, scope, once);
	        return this;
	    },

	    bindScenePauseEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'pause', gameObject, callback, scope, once);
	        return this;
	    },

	    bindSceneResumeEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'resume', gameObject, callback, scope, once);
	        return this;
	    },

	    bindSceneSleepEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'sleep', gameObject, callback, scope, once);
	        return this;
	    },

	    bindSceneWakeEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'wake', gameObject, callback, scope, once);
	        return this;
	    },

	    bindSceneShutdownEvent(gameObject, callback, scope, once) {
	        BindSceneEvent.call(this, 'shutdown', gameObject, callback, scope, once);
	        return this;
	    },


	};

	var GetPointerWorldXY = function (pointer, targetCamera, out) {
	    var camera = pointer.camera;
	    if (!camera) {
	        return null;
	    }

	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        out = globalOut$1;
	    }

	    if (camera === targetCamera) {
	        out.x = pointer.worldX;
	        out.y = pointer.worldY;
	    } else {
	        camera.getWorldPoint(pointer.x, pointer.y, out);
	    }

	    return out;
	};

	var globalOut$1 = {};

	var IsPointerInBounds = function (gameObject, pointer, preTest, postTest) {
	    var mainCamera = gameObject.scene.sys.cameras.main,
	        worldXY;

	    var useScreenXY = (gameObject.scrollFactorX === 0) && (gameObject.scrollFactorY === 0);

	    if (pointer) {
	        if (useScreenXY) {
	            return IsPointInBounds(gameObject, pointer.x, pointer.y, preTest, postTest);

	        } else {
	            worldXY = GetPointerWorldXY(pointer, mainCamera, true);
	            if (!worldXY) {
	                return false;
	            }
	            return IsPointInBounds(gameObject, worldXY.x, worldXY.y, preTest, postTest);

	        }

	    } else {
	        var inputManager = gameObject.scene.input.manager;
	        var pointersTotal = inputManager.pointersTotal;
	        var pointers = inputManager.pointers;
	        for (var i = 0; i < pointersTotal; i++) {
	            pointer = pointers[i];

	            if (useScreenXY) {
	                if (IsPointInBounds(gameObject, pointer.x, pointer.y, preTest, postTest)) {
	                    return true;
	                }

	            } else {
	                worldXY = GetPointerWorldXY(pointer, mainCamera, true);
	                if (!worldXY) {
	                    continue;
	                }

	                if (IsPointInBounds(gameObject, worldXY.x, worldXY.y, preTest, postTest)) {
	                    return true;
	                }

	            }

	        }
	        return false;

	    }

	};

	var IsInTouching = function (pointer, gameObject) {
	    if (IsGameObject(pointer) || (typeof (pointer) === 'string')) {
	        gameObject = pointer;
	        pointer = undefined;
	    }

	    if (gameObject === undefined) {
	        gameObject = this;
	    } else if (typeof (gameObject) === 'string') {
	        gameObject = this.getElement(gameObject);
	    }

	    return IsPointerInBounds(gameObject, pointer);
	};

	var IsArray = function(obj) {
	    return Object.prototype.toString.call(obj) === '[object Array]';
	};

	var ContainsPoint$1 = function (gameObject, x, y, preTest, postTest) {
	    return IsPointInBounds(
	        gameObject,
	        x, y,
	        GetPreTestCallback(preTest),
	        postTest
	    );
	};

	var IsShownSizer = function (gameObject) {
	    var isHiddenSizer = gameObject.rexSizer && gameObject.rexSizer.hidden;
	    return !isHiddenSizer;
	};

	var GetPreTestCallback = function (preTest) {
	    if (!preTest) {
	        return IsShownSizer;
	    }

	    return function (gameObject, x, y) {
	        if (!IsShownSizer(gameObject)) {
	            return false;
	        }
	        preTest(gameObject, x, y);
	        return true;
	    }
	};

	var PointToChild = function (x, y, preTest, postTest, children) {
	    if (!IsFunction(preTest)) {
	        children = preTest;
	        preTest = undefined;
	        postTest = undefined;
	    }

	    if (children === undefined) {
	        if (this.sizerChildren) {
	            children = this.sizerChildren;
	        } else {
	            children = this.children;
	        }
	    }

	    if (IsArray(children)) {
	        var child;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = children[i];
	            if (ContainsPoint$1(child, x, y, preTest, postTest)) {
	                return child;
	            }
	        }
	    } else {
	        var child;
	        for (var key in children) {
	            child = children[key];
	            if (ContainsPoint$1(child, x, y, preTest, postTest)) {
	                return child;
	            }
	        }
	    }

	    return null;
	};

	var CopyState = function (gamObject, out) {
	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        out = GlobState;
	    }

	    out.x = gamObject.x;
	    out.y = gamObject.y;
	    out.scaleX = gamObject.scaleX;
	    out.scaleY = gamObject.scaleY;
	    out.width = gamObject.width;
	    out.height = gamObject.height;
	    out.displayWidth = gamObject.displayWidth;
	    out.displayHeight = gamObject.displayHeight;

	    return out;
	};

	var GlobState = {};

	var PreLayoutChild = function (child) {
	    if (this.sizerEventsEnable) {
	        CopyState(child, this.getChildPrevState(child));
	        this.layoutedChildren.push(child);
	    }
	};

	var LayoutChild = function (child, x, y, width, height, align, offsetX, offsetY) {
	    if (offsetX === undefined) { offsetX = 0; }
	    if (offsetY === undefined) { offsetY = 0; }

	    AlignIn(child, x, y, width, height, align);

	    child.x += offsetX;
	    child.y += offsetY;

	    this.resetChildPositionState(child);

	    if (this.sizerEventsEnable) {
	        child.emit('sizer.postlayout', child, this);
	    }
	};

	const ALIGN_CENTER$4 = Phaser.Display.Align.CENTER;

	var LayoutBackgrounds = function () {
	    if (this.backgroundChildren === undefined) {
	        return;
	    }
	    var backgrounds = this.backgroundChildren;

	    var startX = this.left,
	        startY = this.top;
	    var parentWidth = this.width * this.scaleX,
	        parentHeight = this.height * this.scaleY;
	    var child, childConfig, padding,
	        x, y, width, height;
	    for (var i = 0, cnt = backgrounds.length; i < cnt; i++) {
	        child = backgrounds[i];
	        childConfig = child.rexSizer;
	        if (childConfig.hidden) {
	            continue;
	        }

	        padding = childConfig.padding;

	        PreLayoutChild.call(this, child);

	        x = startX + (padding.left * this.scaleX);
	        y = startY + (padding.top * this.scaleY);
	        width = parentWidth - ((padding.left + padding.right) * this.scaleX);
	        height = parentHeight - ((padding.top + padding.bottom) * this.scaleY);

	        ResizeGameObject(child, width, height);

	        LayoutChild.call(this,
	            child, x, y, width, height, ALIGN_CENTER$4,
	            0, 0
	        );
	    }
	};

	const IsPlainObject$m = Phaser.Utils.Objects.IsPlainObject;
	var SetDraggable = function (sensor, draggable, dragTarget) {
	    if (IsPlainObject$m(sensor)) {
	        var config = sensor;
	        sensor = config.sensor;
	        dragTarget = config.target;
	        draggable = config.draggable;
	    } else {
	        if (typeof (draggable) !== 'boolean') {
	            dragTarget = draggable;
	            draggable = undefined;
	        }
	    }

	    var sensorType = typeof (sensor);
	    if (sensorType === 'string') {
	        var sensorName = sensor;
	        sensor = this.getElement(sensorName);
	        if (!sensor) {
	            console.error(`Can get element '${sensorName}'`);
	            return this;
	        }
	    } else if ((sensor === undefined) || (sensorType != 'object')) {
	        draggable = sensor;
	        sensor = this;
	    }

	    if (draggable === undefined) {
	        draggable = true;
	    }

	    if (sensor.input && sensor.input._rexUIDragSizer) {
	        // Draggable is already registered
	        sensor.input.draggable = draggable;
	    } else if (draggable) {
	        // Register draggable
	        sensor.setInteractive();
	        sensor.scene.input.setDraggable(sensor);
	        sensor
	            .on('drag', function (pointer, dragX, dragY) {
	                var currentDragTarget = (dragTarget === undefined) ? this.getTopmostSizer() : dragTarget;
	                currentDragTarget.x += (dragX - sensor.x);
	                currentDragTarget.y += (dragY - sensor.y);
	                currentDragTarget.emit('sizer.drag', pointer, dragX, dragY);
	            }, this)
	            .on('dragstart', function (pointer, dragX, dragY) {
	                var currentDragTarget = (dragTarget === undefined) ? this.getTopmostSizer() : dragTarget;
	                currentDragTarget.emit('sizer.dragstart', pointer, dragX, dragY);
	            }, this)
	            .on('dragend', function (pointer, dragX, dragY, dropped) {
	                var currentDragTarget = (dragTarget === undefined) ? this.getTopmostSizer() : dragTarget;
	                currentDragTarget.emit('sizer.dragend', pointer, dragX, dragY, dropped);
	            }, this)
	            .on('drop', function (pointer, dropZone) {
	                var currentDragTarget = (dragTarget === undefined) ? this.getTopmostSizer() : dragTarget;
	                currentDragTarget.emit('sizer.drop', pointer, dropZone);
	            });
	        sensor.input._rexUIDragSizer = true;
	    } else ;
	    return this;
	};

	const GetValue$1r = Phaser.Utils.Objects.GetValue;

	class Button extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        this._enable = undefined;
	        gameObject.setInteractive(GetValue$1r(config, "inputConfig", undefined));
	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.pointer = undefined;
	        this.lastClickTime = undefined;
	        this.isDown = false;
	        this.isOver = false;
	        this.setEnable(GetValue$1r(o, "enable", true));
	        this.setMode(GetValue$1r(o, "mode", 1));
	        this.setClickInterval(GetValue$1r(o, "clickInterval", 100));
	        this.setDragThreshold(GetValue$1r(o, 'threshold', undefined));
	        return this;
	    }

	    boot() {
	        var gameObject = this.parent;
	        gameObject.on('pointerdown', this.onPress, this);
	        gameObject.on('pointerup', this.onRelease, this);
	        gameObject.on('pointerout', this.onPointOut, this);
	        gameObject.on('pointermove', this.onMove, this);

	        gameObject.on('pointerover', this.onOver, this);
	        gameObject.on('pointerout', this.onOut, this);
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        // GameObject events will be removed when this gameObject destroyed 
	        // this.parent.on('pointerdown', this.onPress, this);
	        // this.parent.on('pointerup', this.onRelease, this);
	        // this.parent.on('pointerout', this.onPointOut, this);
	        // this.parent.on('pointermove', this.onMove, this);
	        this.pointer = null;

	        super.shutdown(fromScene);
	    }

	    get enable() {
	        return this._enable;
	    }

	    set enable(e) {
	        if (this._enable === e) {
	            return;
	        }

	        if (!e) {
	            this.cancel();
	        }
	        this._enable = e;

	        var eventName = (e) ? 'enable' : 'disable';
	        this.emit(eventName, this, this.parent);
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        this.enable = e;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }

	    setMode(m) {
	        if (typeof (m) === 'string') {
	            m = CLICKMODE$1[m];
	        }
	        this.mode = m;
	        return this;
	    }

	    setClickInterval(interval) {
	        this.clickInterval = interval; // ms
	        return this;
	    }

	    setDragThreshold(distance) {
	        this.dragThreshold = distance;
	        return this;
	    }

	    // internal
	    onPress(pointer, localX, localY, event) {
	        if (this.pointer !== undefined) {
	            return;
	        }

	        this.pointer = pointer;

	        this.isDown = true;
	        this.emit('down', this, this.parent, pointer, event);

	        if (this.mode === 0) {
	            this.click(pointer.downTime, pointer, event);
	        }

	    }

	    onRelease(pointer, localX, localY, event) {
	        if (this.pointer !== pointer) {
	            return;
	        }

	        this.isDown = false;
	        this.emit('up', this, this.parent, pointer, event);

	        if (this.mode === 1) {
	            this.click(pointer.upTime, pointer, event);
	        }

	        this.pointer = undefined;
	    }

	    onPointOut(pointer, event) {
	        if (this.pointer !== pointer) {
	            return;
	        }

	        this.cancel();
	    }

	    onMove(pointer, localX, localY, event) {
	        if (this.pointer !== pointer) {
	            return;
	        }

	        if (this.dragThreshold === undefined) {
	            return;
	        }

	        if (this.mode === 1) {
	            if (pointer.getDistance() >= this.dragThreshold) {
	                this.cancel();
	            }
	        }
	    }

	    onOver(pointer, localX, localY, event) {
	        if (!this.enable) {
	            return this;
	        }

	        this.isOver = true;
	        this.emit('over', this, this.parent, pointer, event);

	        return this;
	    }

	    onOut(pointer, event) {
	        if (!this.enable) {
	            return this;
	        }

	        this.isOver = false;
	        this.emit('out', this, this.parent, pointer, event);

	        return this;
	    }

	    click(nowTime, pointer, event) {
	        if (!this.enable) {
	            return this;
	        }

	        if (nowTime === undefined) {
	            // fires 'click' event manually
	            this.emit('click', this, this.parent, pointer, event);
	            return this;
	        }

	        this.pointer = undefined;
	        var lastClickTime = this.lastClickTime;
	        if ((lastClickTime !== undefined) &&
	            ((nowTime - lastClickTime) <= this.clickInterval)) {
	            return this;
	        }
	        this.lastClickTime = nowTime;
	        this.emit('click', this, this.parent, pointer, event);
	        return this;
	    }

	    cancel() {
	        this.pointer = undefined;
	        return this;
	    }

	}

	const CLICKMODE$1 = {
	    press: 0,
	    pointerdown: 0,
	    release: 1,
	    pointerup: 1,
	};

	var ClickMethods = {
	    onClick(gameObject, callback, scope, config) {
	        if (!gameObject) {
	            return this;
	        }

	        if (typeof (gameObject) === 'function') {
	            config = scope;
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        if (gameObject._click === undefined) {
	            gameObject._click = new Button(gameObject, config);
	        }
	        gameObject._click.on('click', callback, scope);

	        return this;
	    },

	    offClick(gameObject, callback, scope) {
	        if (typeof (gameObject) === 'function') {
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        if (gameObject._click === undefined) {
	            return this;
	        }
	        gameObject._click.off('click', callback, scope);

	        return this;
	    },

	    enableClick(gameObject, enabled) {
	        if (typeof (gameObject) === 'boolean') {
	            enabled = gameObject;
	            gameObject = undefined;
	        }

	        if (gameObject === undefined) {
	            gameObject = this;
	        }

	        if (gameObject._click === undefined) {
	            return this;
	        }

	        gameObject._click.setEnable(enabled);
	        return this;
	    },

	    disableClick(gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }

	        if (gameObject._click === undefined) {
	            return this;
	        }
	        gameObject._click.setEnable(false);

	        return this;
	    }
	};

	var IsPointerInHitArea = function (gameObject, pointer, preTest, postTest, returnFirstPointer) {
	    if (pointer) {
	        if (preTest && !preTest(gameObject, pointer)) {
	            return false;
	        }
	        if (!HitTest(gameObject, pointer)) {
	            return false;
	        }
	        if (postTest && !postTest(gameObject, pointer)) {
	            return false;
	        }
	        return true;

	    } else {
	        if (returnFirstPointer === undefined) {
	            returnFirstPointer = false;
	        }

	        var inputManager = gameObject.scene.input.manager;
	        var pointersTotal = inputManager.pointersTotal;
	        var pointers = inputManager.pointers,
	            pointer;
	        for (var i = 0; i < pointersTotal; i++) {
	            pointer = pointers[i];
	            if (preTest && !preTest(gameObject, pointer)) {
	                continue;
	            }
	            if (!HitTest(gameObject, pointer)) {
	                continue;
	            }
	            if (postTest && !postTest(gameObject, pointer)) {
	                continue;
	            }

	            if (returnFirstPointer) {
	                return pointer;
	            }

	            return true;
	        }

	        return false;
	    }
	};

	var HitTest = function (gameObject, pointer) {
	    var scene = gameObject.scene;
	    var cameras = scene.input.cameras.getCamerasBelowPointer(pointer);
	    var inputManager = scene.input.manager;
	    var gameObjects = [gameObject];

	    for (var i = 0, len = cameras.length; i < len; i++) {
	        inputManager.hitTest(pointer, gameObjects, cameras[i], HitTestResult);
	        if (HitTestResult.length > 0) {
	            HitTestResult.length = 0;
	            return true;
	        }
	    }

	    HitTestResult.length = 0;
	    return false;
	};

	var HitTestResult = [];

	const GetValue$1q = Phaser.Utils.Objects.GetValue;

	class ClickOutside extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        this._enable = undefined;

	        var inputConfig = GetValue$1q(config, "inputConfig", undefined);
	        if (inputConfig) {
	            gameObject.setInteractive(inputConfig);
	        }

	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.pointer = undefined;
	        this.lastClickTime = undefined;
	        this.setEnable(GetValue$1q(o, "enable", true));
	        this.setMode(GetValue$1q(o, "mode", 1));
	        this.setClickInterval(GetValue$1q(o, "clickInterval", 100));
	        this.setDragThreshold(GetValue$1q(o, 'threshold', undefined));
	        return this;
	    }

	    boot() {
	        var scene = this.parent.scene;
	        scene.input.on('pointerdown', this.onPress, this);
	        scene.input.on('pointerup', this.onRelease, this);
	        scene.input.on('pointermove', this.onMove, this);
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        var scene = this.parent.scene;
	        scene.input.off('pointerdown', this.onPress, this);
	        scene.input.off('pointerup', this.onRelease, this);
	        scene.input.off('pointermove', this.onMove, this);
	        this.pointer = null;

	        super.shutdown(fromScene);
	    }

	    get enable() {
	        return this._enable;
	    }

	    set enable(e) {
	        if (this._enable === e) {
	            return;
	        }

	        if (!e) {
	            this.cancel();
	        }
	        this._enable = e;

	        var eventName = (e) ? 'enable' : 'disable';
	        this.emit(eventName, this, this.parent);
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        this.enable = e;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }

	    setMode(m) {
	        if (typeof (m) === 'string') {
	            m = CLICKMODE[m];
	        }
	        this.mode = m;
	        return this;
	    }

	    setClickInterval(interval) {
	        this.clickInterval = interval; // ms
	        return this;
	    }

	    setDragThreshold(distance) {
	        this.dragThreshold = distance;
	        return this;
	    }

	    isPointerInside(pointer) {
	        var gameObject = this.parent;
	        var isInsideCallback = (gameObject.input) ? IsPointerInHitArea : IsPointerInBounds;
	        return isInsideCallback(gameObject, pointer);
	    }

	    // internal
	    onPress(pointer) {
	        // Do nothing if game object is not visible
	        if (!this.parent.willRender(pointer.camera)) {
	            return;
	        }

	        if (this.pointer !== undefined) {
	            return;
	        }

	        if (this.isPointerInside(pointer)) {
	            return;
	        }

	        this.pointer = pointer;

	        if (this.mode === 0) {
	            if (!this.isPointerInside(pointer)) {
	                this.click(pointer.downTime, pointer);
	            }
	        }
	    }

	    onRelease(pointer) {
	        // Do nothing if game object is not visible
	        if (!this.parent.willRender(pointer.camera)) {
	            return;
	        }

	        if (this.pointer !== pointer) {
	            return;
	        }

	        if (this.mode === 1) {
	            if (!this.isPointerInside(pointer)) {
	                this.click(pointer.upTime, pointer);
	            }
	        }

	        this.pointer = undefined;
	    }

	    onMove(pointer, localX, localY, event) {
	        if (this.pointer !== pointer) {
	            return;
	        }

	        if (this.dragThreshold === undefined) {
	            return;
	        }

	        if (this.mode === 1) {
	            if ((pointer.getDistance() >= this.dragThreshold) ||
	                (this.isPointerInside(pointer))) {
	                this.cancel();
	            }
	        }
	    }

	    click(nowTime, pointer) {
	        if (!this.enable) {
	            return this;
	        }

	        if (nowTime === undefined) {
	            // fires 'clickoutside' event manually
	            this.emit('clickoutside', this, this.parent, pointer);
	            return this;
	        }

	        this.pointer = undefined;
	        var lastClickTime = this.lastClickTime;
	        if ((lastClickTime !== undefined) &&
	            ((nowTime - lastClickTime) <= this.clickInterval)) {
	            return this;
	        }
	        this.lastClickTime = nowTime;
	        this.emit('clickoutside', this, this.parent, pointer);

	        return this;
	    }

	    cancel() {
	        this.pointer = undefined;
	        return this;
	    }
	}

	const CLICKMODE = {
	    press: 0,
	    pointerdown: 0,
	    release: 1,
	    pointerup: 1,
	};

	var ClickOutsideMethods = {
	    onClickOutside(gameObject, callback, scope, config) {
	        if (!gameObject) {
	            return this;
	        }

	        if (typeof (gameObject) === 'function') {
	            config = scope;
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        if (gameObject._clickOutside === undefined) {
	            gameObject._clickOutside = new ClickOutside(gameObject, config);
	        }
	        gameObject._clickOutside.on('clickoutside', callback, scope);

	        return this;
	    },

	    offClickOutside(gameObject, callback, scope) {
	        if (typeof (gameObject) === 'function') {
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        if (gameObject._clickOutside === undefined) {
	            return this;
	        }
	        gameObject._clickOutside.off('clickoutside', callback, scope);

	        return this;
	    },

	    enableClickOutside(gameObject, enabled) {
	        if (typeof (gameObject) === 'boolean') {
	            enabled = gameObject;
	            gameObject = undefined;
	        }

	        if (gameObject === undefined) {
	            gameObject = this;
	        }

	        if (gameObject._clickOutside === undefined) {
	            return this;
	        }
	        gameObject._clickOutside.setEnable(enabled);

	        return this;
	    },

	    disableClickOutside(gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }

	        if (gameObject._clickOutside === undefined) {
	            return this;
	        }
	        gameObject._clickOutside.setEnable(false);

	        return this;
	    }
	};

	class Cooldown extends FSM {
	    constructor() {
	        super({
	            eventEmitter: false
	        });

	        this.goto('IDLE');
	    }

	    setCooldownTime(time) {
	        this.cooldownTime = time;
	        this.cooldownMode = (time !== undefined);
	        return this;
	    }

	    request() {
	        return this.runMethod('request');
	    }

	    // IDLE state
	    update_IDLE() {
	        this.compensationTime = 0;
	    }
	    request_IDLE() {
	        this.next();
	        return true;
	    }
	    next_IDLE() {
	        if (this.cooldownMode) {
	            return 'COOLDOWN';
	        }
	    }

	    // COOLDOWN state
	    enter_COOLDOWN() {
	        this.remainderTime = this.cooldownTime + this.compensationTime;
	    }
	    update_COOLDOWN(time, delta) {
	        this.remainderTime -= delta;
	        if (this.remainderTime < 0) {
	            this.compensationTime = (this.cooldownTime > delta) ? (-this.remainderTime) : 0;
	            this.goto('IDLE');
	        }
	    }
	    request_COOLDOWN() {
	        return false;
	    }

	}

	const GetValue$1p = Phaser.Utils.Objects.GetValue;

	class InTouching extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        this._enable = undefined;
	        this.cooldown = new Cooldown();
	        this.parent.setInteractive(GetValue$1p(config, 'inputConfig', undefined));
	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.pointer = undefined;
	        this.prevIsInTouch = false;
	        this.isInTouching = false;
	        this.setEnable(GetValue$1p(o, 'enable', true));
	        this.setCooldown(GetValue$1p(o, 'cooldown', undefined));
	        return this;
	    }

	    boot() {
	        var gameObject = this.parent;
	        gameObject.on('pointerdown', this.onPointIn, this);
	        gameObject.on('pointerover', this.onPointIn, this);
	        gameObject.on('pointerup', this.onPointOut, this);
	        gameObject.on('pointerout', this.onPointOut, this);
	        this.scene.sys.events.on('preupdate', this.preupdate, this);
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        // GameObject events will be removed when this gameObject destroyed 
	        // this.parent.off('pointerdown', this.onPointIn, this);
	        // this.parent.off('pointerover', this.onPointIn, this);
	        // this.parent.off('pointerup', this.onPointOut, this);
	        // this.parent.off('pointerout', this.onPointOut, this);
	        this.scene.sys.events.off('preupdate', this.preupdate, this);

	        this.pointer = undefined;
	        super.shutdown(fromScene);
	    }

	    get enable() {
	        return this._enable;
	    }

	    set enable(e) {
	        if (this._enable === e) {
	            return;
	        }

	        if (!e) {
	            this.prevIsInTouch = false;
	            this.isInTouching = false;
	            this.pointer = undefined;
	        }
	        this._enable = e;
	        return this;
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        this.enable = e;
	        return this;
	    }

	    get cooldownTime() {
	        return this.cooldown.cooldownTime;
	    }

	    set cooldownTime(time) {
	        this.cooldown.setCooldownTime(time);
	    }

	    setCooldown(time) {
	        this.cooldownTime = time;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }

	    // internal
	    onPointIn(pointer, localX, localY) {
	        if ((!this.enable) ||
	            (!pointer.isDown) ||
	            (this.pointer !== undefined)) {
	            return;
	        }
	        this.pointer = pointer;
	        this.isInTouching = true;
	    }

	    onPointOut(pointer) {
	        if ((!this.enable) ||
	            (this.pointer !== pointer)) {
	            return;
	        }
	        this.pointer = undefined;
	        this.isInTouching = false;
	    }

	    preupdate(time, delta) {
	        this.cooldown.update(time, delta);

	        if (!this.prevIsInTouch && this.isInTouching) {
	            this.emit('touchstart', this, this.parent);
	        }

	        if (this.isInTouching && this.cooldown.request()) {
	            this.emit('intouch', this, this.parent, this.pointer);
	        }
	        
	        if (this.prevIsInTouch && !this.isInTouching) {
	            this.emit('touchend', this, this.parent);
	        }

	        this.prevIsInTouch = this.isInTouching;
	    }
	}

	var TouchingMethods = {
	    isPointerInBounds(target) {
	        if (target === undefined) {
	            target = this;
	        } else if (typeof (target) === 'string') {
	            target = this.getElement(target);
	        }

	        if (!target) {
	            return false;
	        }

	        return IsPointerInBounds(target);
	    },

	    onTouching(gameObject, callback, scope, config) {
	        if (!gameObject) {
	            return this;
	        }

	        if (typeof (gameObject) === 'function') {
	            config = scope;
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        if (gameObject._inTouching === undefined) {
	            gameObject._inTouching = new InTouching(gameObject, config);
	        }
	        gameObject._inTouching.on('intouch', callback, scope);

	        return this;
	    },

	    offTouching(gameObject, callback, scope) {
	        if (typeof (gameObject) === 'function') {
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        if (gameObject._inTouching === undefined) {
	            return this;
	        }
	        gameObject._inTouching.off('intouch', callback, scope);

	        return this;
	    },

	    onTouchingEnd(gameObject, callback, scope, config) {
	        if (!gameObject) {
	            return this;
	        }

	        if (typeof (gameObject) === 'function') {
	            config = scope;
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        if (gameObject._inTouching === undefined) {
	            gameObject._inTouching = new InTouching(gameObject, config);
	        }
	        gameObject._inTouching.on('touchend', callback, scope);

	        return this;
	    },

	    offTouchingEnd(gameObject, callback, scope) {
	        if (typeof (gameObject) === 'function') {
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        if (gameObject._inTouching === undefined) {
	            return this;
	        }
	        gameObject._inTouching.off('touchend', callback, scope);

	        return this;
	    },


	    enableTouching(gameObject, enabled) {
	        if (typeof (gameObject) === 'boolean') {
	            enabled = gameObject;
	            gameObject = undefined;
	        }

	        if (gameObject === undefined) {
	            gameObject = this;
	        }

	        if (gameObject._inTouching === undefined) {
	            return this;
	        }
	        gameObject._inTouching.setEnable(enabled);

	        return this;
	    },

	    disableTouching(gameObject) {
	        if (gameObject === undefined) {
	            gameObject = this;
	        }

	        if (gameObject._inTouching === undefined) {
	            return this;
	        }
	        gameObject._inTouching.setEnable(false);

	        return this;
	    },


	};

	var HoverMethods = {
	    onOver(gameObject, callback, scope) {
	        if (!gameObject) {
	            return this;
	        }
	        if (typeof (gameObject) === 'function') {
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        gameObject
	            .setInteractive()
	            .on('pointerover', callback, scope);

	        return this;
	    },

	    onOut(gameObject, callback, scope) {
	        if (!gameObject) {
	            return this;
	        }
	        if (typeof (gameObject) === 'function') {
	            scope = callback;
	            callback = gameObject;
	            gameObject = this;
	        }

	        gameObject
	            .setInteractive()
	            .on('pointerout', callback, scope);

	        return this;
	    },
	};

	var ContainsPoint = function (targetMode, gameObjects, x, y) {
	    if (targetMode === 'parent') {
	        var parent;
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            parent = gameObjects[i];
	            if (!ContainsPoint$1(parent, x, y)) {
	                continue;
	            }

	            return parent.pointToChild(x, y);
	        }
	    } else {  // direct mode
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            var target = gameObjects[i];
	            if (ContainsPoint$1(target, x, y)) {
	                return target;
	            }
	        }
	    }

	    return null;
	};

	var EmitChildEvent = function (eventEmitter, eventName, targets, targetMode, worldX, worldY, pointer, event) {
	    var child;
	    if (worldY === undefined) {
	        child = worldX;
	    } else {
	        var firstChild = targets[0];
	        if (!firstChild) {
	            return;
	        }
	        var camera = pointer.camera;
	        var px = worldX + camera.scrollX * (firstChild.scrollFactorX - 1);
	        var py = worldY + camera.scrollY * (firstChild.scrollFactorY - 1);
	        child = ContainsPoint(targetMode, targets, px, py);
	    }

	    if (!child) {
	        return;
	    }

	    eventEmitter.emit(eventName, child, pointer, event);
	};

	const GetValue$1o = Phaser.Utils.Objects.GetValue;

	var DownChild = function (config) {
	    var downConfig = GetValue$1o(config, 'down', undefined);
	    if (downConfig === false) {
	        return;
	    } else if (downConfig === true) {
	        downConfig = undefined;
	    }

	    this
	        .on('pointerdown', OnDown, this);
	};

	var OnDown = function (pointer, localX, localY, event) {
	    var childrenInteractive = this._childrenInteractive;

	    EmitChildEvent(
	        childrenInteractive.eventEmitter,
	        `${childrenInteractive.eventNamePrefix}down`,
	        childrenInteractive.targetSizers,
	        childrenInteractive.targetMode,
	        pointer.worldX, pointer.worldY,
	        pointer, event
	    );
	};

	const GetValue$1n = Phaser.Utils.Objects.GetValue;

	var UpChild = function (config) {
	    var upConfig = GetValue$1n(config, 'up', undefined);
	    if (upConfig === false) {
	        return;
	    } else if (upConfig === true) {
	        upConfig = undefined;
	    }

	    this
	        .on('pointerup', OnUp, this);
	};

	var OnUp = function (pointer, localX, localY, event) {
	    var childrenInteractive = this._childrenInteractive;

	    EmitChildEvent(
	        childrenInteractive.eventEmitter,
	        `${childrenInteractive.eventNamePrefix}up`,
	        childrenInteractive.targetSizers,
	        childrenInteractive.targetMode,
	        pointer.worldX, pointer.worldY,
	        pointer, event
	    );
	};

	const GetValue$1m = Phaser.Utils.Objects.GetValue;

	var OverChild = function (config) {
	    var overConfig = GetValue$1m(config, 'over', undefined);
	    if (overConfig === false) {
	        return;
	    } else if (overConfig === true) {
	        overConfig = undefined;
	    }

	    this
	        .on('pointermove', OnMove, this)
	        .on('pointerover', OnMove, this)
	        .on('pointerout', OnOut, this);  // pointer-up is included too
	};

	var OnMove = function (pointer, localX, localY, event) {
	    var childrenInteractive = this._childrenInteractive;
	    var firstChild = childrenInteractive.targetSizers[0];
	    if (!firstChild) {
	        return;
	    }
	    var camera = pointer.camera;
	    var px = pointer.worldX + camera.scrollX * (firstChild.scrollFactorX - 1);
	    var py = pointer.worldY + camera.scrollY * (firstChild.scrollFactorY - 1);

	    var child = ContainsPoint(childrenInteractive.targetMode, childrenInteractive.targetSizers, px, py);
	    var preChild = childrenInteractive.lastOverChild;
	    if (child && preChild &&
	        (child === preChild)) {
	        return;
	    }

	    childrenInteractive.lastOverChild = child;
	    EmitChildEvent(
	        childrenInteractive.eventEmitter,
	        `${childrenInteractive.eventNamePrefix}out`,
	        childrenInteractive.targetSizers,
	        childrenInteractive.targetMode,
	        preChild, undefined,
	        pointer, event
	    );
	    EmitChildEvent(
	        childrenInteractive.eventEmitter,
	        `${childrenInteractive.eventNamePrefix}over`,
	        childrenInteractive.targetSizers,
	        childrenInteractive.targetMode,
	        child, undefined,
	        pointer, event
	    );
	};

	var OnOut = function (pointer, event) {
	    var childrenInteractive = this._childrenInteractive;
	    var child = childrenInteractive.lastOverChild;
	    childrenInteractive.lastOverChild = null;
	    EmitChildEvent(
	        childrenInteractive.eventEmitter,
	        `${childrenInteractive.eventNamePrefix}out`,
	        childrenInteractive.targetSizers,
	        childrenInteractive.targetMode,
	        child, undefined,
	        pointer, event
	    );
	};

	const GetValue$1l = Phaser.Utils.Objects.GetValue;

	var ClickChild = function (config) {
	    var clickConfig = GetValue$1l(config, 'click', undefined);
	    if (clickConfig === false) {
	        return;
	    } else if (clickConfig === true) {
	        clickConfig = undefined;
	    }

	    if (clickConfig === undefined) {
	        clickConfig = {};
	    }
	    if (!clickConfig.hasOwnProperty('threshold')) {
	        clickConfig.threshold = 10;
	    }

	    var childrenInteractive = this._childrenInteractive;
	    this._click = new Button(this, clickConfig);
	    this._click.on('click', function (button, gameObject, pointer, event) {
	        EmitChildEvent(
	            childrenInteractive.eventEmitter,
	            `${childrenInteractive.eventNamePrefix}click`,
	            childrenInteractive.targetSizers,
	            childrenInteractive.targetMode,
	            pointer.worldX, pointer.worldY,
	            pointer, event
	        );
	    }, this);
	};

	const GetValue$1k = Phaser.Utils.Objects.GetValue;

	class OnePointerTracer extends TickTask {
	    constructor(gameObject, config) {
	        var scene = GetSceneObject(gameObject);
	        if (scene === gameObject) {
	            gameObject = undefined;
	        }
	        super(scene, config);

	        this.gameObject = gameObject;
	        if (gameObject) {
	            gameObject.setInteractive(GetValue$1k(config, 'inputConfig', undefined));
	        }
	        this._enable = undefined;
	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.setEnable(GetValue$1k(o, 'enable', true));

	        this.setDetectBounds();
	        if (this.gameObject === undefined) {
	            this.setDetectBounds(GetValue$1k(o, 'bounds', undefined));
	        } else {
	            this.setDetectBounds();
	        }

	        this.tracerState = TOUCH0$1;
	        // this.recongizedState = new stateClass(this);
	        this.pointer = undefined;
	        this.lastPointer = undefined; // Last catched pointer
	        this.movedState = false;
	        this.isTouchingAnyObject = false;
	        return this;
	    }

	    boot() {
	        super.boot();
	        if (this.gameObject) {
	            this.gameObject.on('pointerdown', this.onPointerDown, this);
	        } else {
	            this.scene.input.on('pointerdown', this.onPointerDown, this);
	        }
	        this.scene.input.on('pointerup', this.onPointerUp, this);
	        this.scene.input.on('gameout', this.dragCancel, this);

	        this.scene.input.on('pointermove', this.onPointerMove, this);
	        this.scene.sys.events.once('shutdown', this.destroy, this);
	    }

	    shutdown(fromScene) {
	        if (!this.scene) {
	            return
	        }

	        if (this.gameObject) ; else {
	            this.scene.input.off('pointerdown', this.onPointerDown, this);
	        }
	        this.scene.input.off('pointerup', this.onPointerUp, this);
	        this.scene.input.off('gameout', this.dragCancel, this);

	        this.scene.input.off('pointermove', this.onPointerMove, this);
	        this.scene.sys.events.off('shutdown', this.destroy, this);

	        this.gameObject = undefined;
	        this.bounds = undefined;
	        this.pointer = undefined;
	        this.lastPointer = undefined; // Last catched pointer
	        this.movedState = false;

	        super.shutdown(fromScene);
	    }

	    get enable() {
	        return this._enable;
	    }

	    set enable(e) {
	        if (this._enable === e) {
	            return;
	        }

	        if (!e) {
	            this.dragCancel();
	        }
	        this._enable = e;
	        return this;
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        this.enable = e;
	        return this;
	    }

	    setDetectBounds(bounds) {
	        this.bounds = bounds;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }

	    onPointerDown(pointer, gameObjects) {
	        if (!this.enable) {
	            return;
	        }

	        if (this.pointer !== undefined) {
	            return;
	        }

	        var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
	        if (!isInsideBounds) {
	            return;
	        }

	        if (this.pointer === pointer) {
	            return;
	        }

	        this.pointer = pointer;
	        this.pointerCamera = pointer.camera;
	        this.lastPointer = pointer;
	        this.movedState = false;
	        this.tracerState = TOUCH1$1;

	        if (this.gameObject === undefined) {
	            this.isTouchingAnyObject = (gameObjects.length > 0);
	        }
	        this.onDragStart();
	    }

	    onPointerUp(pointer) {
	        if (!this.enable) {
	            return;
	        }

	        var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
	        if (!isInsideBounds) {
	            return;
	        }

	        if (this.pointer !== pointer) {
	            return;
	        }

	        this.pointer = undefined;
	        this.pointerCamera = undefined;
	        this.movedState = false;
	        this.tracerState = TOUCH0$1;
	        this.onDragEnd();
	    }

	    onPointerMove(pointer) {
	        if (!this.enable) {
	            return;
	        }

	        if (pointer.isDown) {
	            var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
	            var isCatchedPointer = (this.pointer === pointer);
	            if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) { // Pointer moves out of bounds
	                this.onPointerUp(pointer);
	            } else { // Pointer drags in bounds
	                if (!this.movedState) {
	                    this.movedState = (pointer.x !== pointer.downX) || (pointer.y !== pointer.downY);
	                }
	                if (this.movedState) {
	                    this.onDrag();
	                }
	            }
	        }
	    }

	    dragCancel() {
	        if (this.tracerState === TOUCH1$1) {
	            this.onDragEnd();
	        }
	        this.pointer = undefined;
	        this.tracerState = TOUCH0$1;
	        return this;
	    }

	    onDragStart() {
	        this.emit('dragstart', this);
	    }

	    onDragEnd() {
	        this.emit('dragend', this);
	    }

	    onDrag() {
	        this.emit('drag', this);
	    }

	    // onLastPointerMove() { }

	    preUpdate(time, delta) { }

	    postUpdate(time, delta) { }

	    startTicking() {
	        super.startTicking();
	        this.scene.sys.events.on('preupdate', this.preUpdate, this);
	        this.scene.sys.events.on('postupdate', this.postUpdate, this);
	    }

	    stopTicking() {
	        super.stopTicking();
	        if (this.scene) { // Scene might be destoryed
	            this.scene.sys.events.off('preupdate', this.preUpdate, this);
	            this.scene.sys.events.off('postupdate', this.postUpdate, this);
	        }
	    }

	    setRecongizedStateObject(stateObject) {
	        this.recongizedState = stateObject;
	        return this;
	    }

	    get state() {
	        return this.recongizedState.state;
	    }

	    set state(newState) {
	        this.recongizedState.state = newState;
	    }

	    cancel() {
	        this.state = IDLE$5;
	        return this;
	    }

	    isPointerInGameObject(gameObject, preTest, postTest) {
	        var pointer = this.lastPointer;
	        if (!pointer) {
	            return false;
	        }

	        return IsPointerInBounds(gameObject, pointer, preTest, postTest);
	    }
	}

	const TOUCH0$1 = 0;
	const TOUCH1$1 = 1;

	const IDLE$5 = 'IDLE';

	const GetValue$1j = Phaser.Utils.Objects.GetValue;
	const DistanceBetween$4 = Phaser.Math.Distance.Between;

	class Tap extends OnePointerTracer {
	    constructor(gameObject, config) {
	        super(gameObject, config);

	        var self = this;
	        var stateConfig = {
	            states: {
	                IDLE: {
	                    enter: function () {
	                        self.stop();
	                        self.tapsCount = 0;
	                        self.x = 0;
	                        self.y = 0;
	                        self.worldX = 0;
	                        self.worldY = 0;
	                        self.lastPointer = undefined;
	                    },
	                    exit: function () {
	                        var pointer = self.lastPointer;
	                        self.x = pointer.x;
	                        self.y = pointer.y;
	                        self.worldX = pointer.worldX;
	                        self.worldY = pointer.worldY;
	                    }
	                },
	                BEGIN: {
	                    enter: function () {
	                        self.start();
	                        self.tapsCount = 0;
	                        self.emit('tappingstart', self, self.gameObject, self.lastPointer);
	                    },
	                },
	                RECOGNIZED: {
	                    enter: function () {
	                        self.start();
	                        self.emit('tap', self, self.gameObject, self.lastPointer);
	                        self.emit(`${self.tapsCount}tap`, self, self.gameObject, self.lastPointer);
	                    },
	                }
	            },
	            init: function () {
	                this.state = IDLE$4;
	            },
	            eventEmitter: false,
	        };
	        this.setRecongizedStateObject(new FSM(stateConfig));
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);
	        this.setHoldTime(GetValue$1j(o, 'time', 250)); // min-hold-time of Press is 251
	        this.setTapInterval(GetValue$1j(o, 'tapInterval', 200));
	        this.setDragThreshold(GetValue$1j(o, 'threshold', 9));
	        this.setTapOffset(GetValue$1j(o, 'tapOffset', 10));

	        var taps = GetValue$1j(o, 'taps', undefined);
	        if (taps !== undefined) {
	            this.setTaps(taps);
	        } else {
	            this.setMaxTaps(GetValue$1j(o, 'maxTaps', undefined));
	            this.setMinTaps(GetValue$1j(o, 'minTaps', undefined));
	        }
	        return this;
	    }

	    onDragStart() {
	        switch (this.state) {
	            case IDLE$4:
	                this.state = BEGIN$3;
	                break;

	            case BEGIN$3:
	                var pointer = this.lastPointer;
	                var tapsOffset = DistanceBetween$4(
	                    pointer.upX,
	                    pointer.upY,
	                    pointer.x,
	                    pointer.y);
	                if (tapsOffset > this.tapOffset) { // Can't recognize next level, restart here
	                    this.state = RECOGNIZED$3;
	                    this.state = BEGIN$3;
	                }
	                break;

	            case RECOGNIZED$3:
	                this.state = BEGIN$3;
	                break;
	        }
	    }

	    onDragEnd() {
	        if (this.state === BEGIN$3) {
	            this.tapsCount++; // Try recognize next level
	            this.emit('tapping', this, this.gameObject, this.lastPointer);

	            if ((this.maxTaps !== undefined) && (this.tapsCount === this.maxTaps)) { // Reach to maxTaps, stop here                
	                this.state = RECOGNIZED$3;
	            }
	        }
	    }

	    onDrag() {
	        if (this.state === IDLE$4) {
	            return;
	        }

	        if (this.pointer.getDistance() > this.dragThreshold) { // Cancel
	            this.state = IDLE$4;
	        }
	    }

	    preUpdate(time, delta) {
	        if ((!this.isRunning) || (!this.enable)) {
	            return;
	        }
	        if (this.state === BEGIN$3) {
	            var pointer = this.lastPointer;
	            if (pointer.isDown) {
	                var holdTime = time - pointer.downTime;
	                if (holdTime > this.holdTime) {
	                    this.state = IDLE$4;
	                }
	            } else { // isUp
	                var releasedTime = time - pointer.upTime;
	                if (releasedTime > this.tapInterval) {
	                    if ((this.minTaps === undefined) || (this.tapsCount >= this.minTaps)) {
	                        this.state = RECOGNIZED$3;
	                    } else {
	                        this.state = IDLE$4;
	                    }
	                }
	            }
	        }
	    }

	    postUpdate(time, delta) {
	        if ((!this.isRunning) || (!this.enable)) {
	            return;
	        }
	        // Clear RECOGNIZED after update()
	        if (this.state === RECOGNIZED$3) {
	            this.state = IDLE$4;
	        }
	    }

	    get isTapped() {
	        return (this.state === RECOGNIZED$3);
	    }

	    setHoldTime(time) {
	        this.holdTime = time; // ms
	        return this;
	    }

	    setTapInterval(time) {
	        this.tapInterval = time; // ms
	        return this;
	    }

	    setDragThreshold(distance) {
	        this.dragThreshold = distance;
	        return this;
	    }

	    setTapOffset(distance) {
	        this.tapOffset = distance;
	        return this;
	    }

	    setMaxTaps(taps) {
	        this.maxTaps = taps;
	        return this;
	    }

	    setMinTaps(taps) {
	        this.minTaps = taps;
	        return this;
	    }

	    setTaps(minTaps, maxTaps) {
	        if (maxTaps === undefined) {
	            maxTaps = minTaps;
	        }
	        this.setMinTaps(minTaps).setMaxTaps(maxTaps);
	        return this;
	    }
	}

	const IDLE$4 = 'IDLE';
	const BEGIN$3 = 'BEGIN';
	const RECOGNIZED$3 = 'RECOGNIZED';

	const GetValue$1i = Phaser.Utils.Objects.GetValue;

	class Press extends OnePointerTracer {
	    constructor(gameObject, config) {
	        super(gameObject, config);

	        var self = this;
	        var stateConfig = {
	            states: {
	                IDLE: {
	                    enter: function () {
	                        self.x = 0;
	                        self.y = 0;
	                        self.worldX = 0;
	                        self.worldY = 0;
	                        self.lastPointer = undefined;
	                    },
	                    exit: function () {
	                        var pointer = self.lastPointer;
	                        self.x = pointer.x;
	                        self.y = pointer.y;
	                        self.worldX = pointer.worldX;
	                        self.worldY = pointer.worldY;
	                    }
	                },
	                BEGIN: {
	                    enter: function () {
	                        self.start();
	                    },
	                    exit: function () {
	                        self.stop();
	                    }
	                },
	                RECOGNIZED: {
	                    enter: function () {
	                        self.emit('pressstart', self, self.gameObject, self.lastPointer);
	                    },
	                    exit: function () {
	                        self.emit('pressend', self, self.gameObject, self.lastPointer);
	                    }
	                }
	            },
	            init: function () {
	                this.state = IDLE$3;
	            },
	            eventEmitter: false,
	        };
	        this.setRecongizedStateObject(new FSM(stateConfig));
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);
	        this.setDragThreshold(GetValue$1i(o, 'threshold', 9));
	        this.setHoldTime(GetValue$1i(o, 'time', 251));
	        return this;
	    }

	    onDragStart() {
	        this.state = BEGIN$2;
	        if (this.holdTime === 0) {
	            this.state = RECOGNIZED$2;
	        }
	    }

	    onDragEnd() {
	        this.state = IDLE$3;
	    }

	    onDrag() {
	        if (this.state === IDLE$3) {
	            return;
	        }

	        if (this.pointer.getDistance() > this.dragThreshold) {
	            this.state = IDLE$3;
	        }
	    }

	    preUpdate(time, delta) {
	        if ((!this.isRunning) || (!this.enable)) {
	            return;
	        }
	        if (this.state === BEGIN$2) {
	            var holdTime = time - this.pointer.downTime;
	            if (holdTime >= this.holdTime) {
	                this.state = RECOGNIZED$2;
	            }
	        }
	    }

	    get isPressed() {
	        return (this.state === RECOGNIZED$2);
	    }

	    setHoldTime(time) {
	        this.holdTime = time; // ms
	        return this;
	    }

	    setDragThreshold(distance) {
	        this.dragThreshold = distance;
	        return this;
	    }
	}

	const IDLE$3 = 'IDLE';
	const BEGIN$2 = 'BEGIN';
	const RECOGNIZED$2 = 'RECOGNIZED';

	Phaser.Utils.Objects.GetValue;

	var GetTickDelta = function (game) {
	    return GetGame(game).loop.delta;
	};

	const DistanceBetween$3 = Phaser.Math.Distance.Between;
	const AngleBetween$1 = Phaser.Math.Angle.Between;

	var VelocityMethods = {
	    getDt: function () {
	        var dt = GetTickDelta(this.scene);
	        return dt;
	    },

	    getVelocity: function () {
	        var p1 = this.pointer.position;
	        var p0 = this.pointer.prevPosition;
	        var d = DistanceBetween$3(p0.x, p0.y, p1.x, p1.y);
	        var velocity = d / (this.getDt() * 0.001);
	        return velocity;
	    },

	    getVelocityX: function () {
	        var p1 = this.pointer.position;
	        var p0 = this.pointer.prevPosition;
	        var d = Math.abs(p1.x - p0.x);
	        var velocity = d / (this.getDt() * 0.001);
	        return velocity;
	    },

	    getVelocityY: function () {
	        var p1 = this.pointer.position;
	        var p0 = this.pointer.prevPosition;
	        var d = Math.abs(p1.y - p0.y);
	        var velocity = d / (this.getDt() * 0.001);
	        return velocity;
	    },

	    getVelocityAngle: function () {
	        var p1 = this.pointer.position;
	        var p0 = this.pointer.prevPosition;
	        var angle = AngleBetween$1(p0.x, p0.y, p1.x, p1.y);
	        return angle;
	    }
	};

	var DIRMODE = {
	    'up&down': 0,
	    'left&right': 1,
	    '4dir': 2,
	    '8dir': 3
	};

	var AngleToDirections = function (angle, dirMode, out) {
	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        out = globOut$1;
	    }

	    out.left = false;
	    out.right = false;
	    out.up = false;
	    out.down = false;

	    angle = (angle + 360) % 360;
	    switch (dirMode) {
	        case 0: // up & down
	            if (angle < 180) {
	                out.down = true;
	            } else {
	                out.up = true;
	            }
	            break;

	        case 1: // left & right
	            if ((angle > 90) && (angle <= 270)) {
	                out.left = true;
	            } else {
	                out.right = true;
	            }
	            break;

	        case 2: // 4 dir
	            if ((angle > 45) && (angle <= 135)) {
	                out.down = true;
	            } else if ((angle > 135) && (angle <= 225)) {
	                out.left = true;
	            } else if ((angle > 225) && (angle <= 315)) {
	                out.up = true;
	            } else {
	                out.right = true;
	            }
	            break;

	        case 3: // 8 dir
	            if ((angle > 22.5) && (angle <= 67.5)) {
	                out.down = true;
	                out.right = true;
	            } else if ((angle > 67.5) && (angle <= 112.5)) {
	                out.down = true;
	            } else if ((angle > 112.5) && (angle <= 157.5)) {
	                out.down = true;
	                out.left = true;
	            } else if ((angle > 157.5) && (angle <= 202.5)) {
	                out.left = true;
	            } else if ((angle > 202.5) && (angle <= 247.5)) {
	                out.left = true;
	                out.up = true;
	            } else if ((angle > 247.5) && (angle <= 292.5)) {
	                out.up = true;
	            } else if ((angle > 292.5) && (angle <= 337.5)) {
	                out.up = true;
	                out.right = true;
	            } else {
	                out.right = true;
	            }
	            break;
	    }

	    return out;
	};

	var globOut$1 = {};

	const GetValue$1h = Phaser.Utils.Objects.GetValue;
	const RadToDeg$3 = Phaser.Math.RadToDeg;

	class Swipe extends OnePointerTracer {
	    constructor(gameObject, config) {
	        super(gameObject, config);

	        var self = this;
	        var stateConfig = {
	            states: {
	                IDLE: {
	                    enter: function () {
	                        self.x = 0;
	                        self.y = 0;
	                        self.worldX = 0;
	                        self.worldY = 0;
	                    },
	                    exit: function () {
	                        var pointer = self.lastPointer;
	                        self.x = pointer.x;
	                        self.y = pointer.y;
	                        self.worldX = pointer.worldX;
	                        self.worldY = pointer.worldY;
	                    }
	                },
	                BEGIN: {
	                    enter: function () {
	                        self.validDrag = false;
	                    }
	                },
	                RECOGNIZED: {
	                    enter: function () {
	                        self.start();
	                        self.updateDirectionStates();
	                        self.emit('swipe', self, self.gameObject, self.lastPointer);
	                    },

	                    exit: function () {
	                        self.stop();
	                        self.clearDirectionStates();
	                    }
	                }
	            },
	            init: function () {
	                this.state = IDLE$2;
	            },
	            eventEmitter: false,
	        };
	        this.setRecongizedStateObject(new FSM(stateConfig));
	        this.clearDirectionStates();
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);
	        this.setDragThreshold(GetValue$1h(o, 'threshold', 10));
	        this.setVelocityThreshold(GetValue$1h(o, 'velocityThreshold', 1000));
	        this.setDirectionMode(GetValue$1h(o, 'dir', '8dir'));
	        return this;
	    }

	    onDragStart() {
	        this.state = BEGIN$1;
	    }

	    onDragEnd() {
	        this.state = IDLE$2;
	    }

	    onDrag() {
	        if (this.state === BEGIN$1) {
	            if (!this.validDrag) {
	                this.validDrag = (this.dragThreshold === 0) || (this.pointer.getDistance() >= this.dragThreshold);
	            }
	            if (this.validDrag && (this.dragVelocity > this.velocityThreshold)) {
	                this.state = RECOGNIZED$1;
	            }
	        }
	    }

	    postUpdate(time, delta) {
	        if ((!this.isRunning) || (!this.enable)) {
	            return;
	        }
	        // Clear RECOGNIZED after update()
	        if (this.state === RECOGNIZED$1) {
	            this.state = IDLE$2;
	        }
	    }

	    get isSwiped() {
	        return (this.state === RECOGNIZED$1);
	    }

	    get dragVelocity() {
	        var velocity;
	        switch (this.dirMode) {
	            case 0: velocity = this.getVelocityY(); break; // up & down
	            case 1: velocity = this.getVelocityX(); break; // left & right
	            default: velocity = this.getVelocity(); break; // 4 dir, 8 dir
	        }
	        return velocity;
	    }

	    setDragThreshold(distance) {
	        this.dragThreshold = distance;
	        return this;
	    }

	    setVelocityThreshold(velocity) {
	        this.velocityThreshold = velocity;
	        return this;
	    }

	    setDirectionMode(m) {
	        if (typeof (m) === 'string') {
	            m = DIRMODE[m];
	        }
	        this.dirMode = m;
	        return this;
	    }

	    updateDirectionStates() {
	        var angle = RadToDeg$3(this.getVelocityAngle());
	        AngleToDirections(angle, this.dirMode, this);
	        return this;
	    }

	    clearDirectionStates() {
	        this.left = false;
	        this.right = false;
	        this.up = false;
	        this.down = false;
	        return this;
	    }
	}

	Object.assign(
	    Swipe.prototype,
	    VelocityMethods
	);

	const IDLE$2 = 'IDLE';
	const BEGIN$1 = 'BEGIN';
	const RECOGNIZED$1 = 'RECOGNIZED';

	const GetValue$1g = Phaser.Utils.Objects.GetValue;
	const SpliceOne = Phaser.Utils.Array.SpliceOne;
	const DistanceBetween$2 = Phaser.Math.Distance.Between;
	const AngleBetween = Phaser.Math.Angle.Between;

	class TwoPointersTracer {
	    constructor(gameObject, config) {
	        var scene = GetSceneObject(gameObject);
	        if (scene === gameObject) {
	            gameObject = undefined;
	        }

	        var amount = scene.input.manager.pointersTotal - 1;
	        if (amount < 2) {
	            scene.input.addPointer(2 - amount);
	        }

	        this.scene = scene;
	        this.gameObject = gameObject;
	        if (gameObject) {
	            gameObject.setInteractive(GetValue$1g(config, 'inputConfig', undefined));
	        }

	        // Event emitter
	        this.setEventEmitter(GetValue$1g(config, 'eventEmitter', undefined));

	        this._enable = undefined;
	        this.pointers = [];
	        this.movedState = {};
	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.setEnable(GetValue$1g(o, "enable", true));
	        this.bounds = GetValue$1g(o, 'bounds', undefined);

	        this.tracerState = TOUCH0;
	        this.pointers.length = 0;
	        Clear(this.movedState);
	        return this;
	    }

	    boot() {
	        if (this.gameObject) {
	            this.gameObject.on('pointerdown', this.onPointerDown, this);
	        } else {
	            this.scene.input.on('pointerdown', this.onPointerDown, this);
	        }

	        this.scene.input.on('pointerup', this.onPointerUp, this);
	        this.scene.input.on('gameout', this.dragCancel, this);

	        this.scene.input.on('pointermove', this.onPointerMove, this);
	        this.scene.sys.events.once('shutdown', this.destroy, this);
	    }

	    shutdown() {
	        if (!this.scene) {
	            return
	        }

	        this.destroyEventEmitter();
	        this.pointers.length = 0;
	        Clear(this.movedState);

	        if (this.gameObject) ; else {
	            this.scene.input.off('pointerdown', this.onPointerDown, this);
	        }

	        this.scene.input.off('pointerup', this.onPointerUp, this);
	        this.scene.input.off('gameout', this.dragCancel, this);

	        this.scene.input.off('pointermove', this.onPointerMove, this);
	        this.scene.sys.events.off('shutdown', this.destroy, this);
	        this.scene = undefined;
	        this.gameObject = undefined;
	    }

	    destroy() {
	        this.shutdown();
	    }

	    get enable() {
	        return this._enable;
	    }

	    set enable(e) {
	        if (this._enable === e) {
	            return;
	        }

	        if (!e) {
	            this.dragCancel();
	        }
	        this._enable = e;
	        return this;
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        this.enable = e;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }

	    onPointerDown(pointer) {
	        if (!this.enable) {
	            return;
	        }

	        if (this.pointers.length === 2) {
	            return;
	        }

	        var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
	        if (!isInsideBounds) {
	            return;
	        }

	        var index = this.pointers.indexOf(pointer);
	        if (index !== -1) { // Already in catched pointers
	            return;
	        }

	        this.movedState[pointer.id] = false;
	        this.pointers.push(pointer);
	        this.pointerCamera = pointer.camera;

	        switch (this.tracerState) {
	            case TOUCH0:
	                this.tracerState = TOUCH1;
	                this.onDrag1Start();
	                break;
	            case TOUCH1:
	                this.tracerState = TOUCH2;
	                this.onDrag2Start();
	                break;
	        }
	    }

	    onPointerUp(pointer) {
	        if (!this.enable) {
	            return;
	        }

	        var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
	        if (!isInsideBounds) {
	            return;
	        }

	        var index = this.pointers.indexOf(pointer);
	        if (index === -1) { // Not in catched pointers
	            return;
	        } else {
	            delete this.movedState[pointer.id];
	            SpliceOne(this.pointers, index);
	        }

	        switch (this.tracerState) {
	            case TOUCH1:
	                this.tracerState = TOUCH0;
	                this.onDrag1End();
	                break;
	            case TOUCH2:
	                this.tracerState = TOUCH1;
	                this.onDrag2End();
	                this.onDrag1Start();
	                break;
	        }
	    }

	    onPointerMove(pointer) {
	        if (!this.enable) {
	            return;
	        }

	        if (pointer.isDown) {
	            var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
	            var isCatchedPointer = (this.pointers.indexOf(pointer) !== -1);
	            if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) { // Pointer moves out of bounds, lose pointer
	                this.onPointerUp(pointer);
	            } else {  // Pointer drags in bounds
	                if (!this.movedState[pointer.id]) {
	                    this.movedState[pointer.id] = (pointer.x !== pointer.downX) || (pointer.y !== pointer.downY);
	                }
	                if (this.movedState[pointer.id]) {
	                    switch (this.tracerState) {
	                        case TOUCH1:
	                            this.onDrag1();
	                            break;
	                        case TOUCH2:
	                            this.onDrag2();
	                            break;
	                    }
	                }
	            }
	        }
	    }

	    dragCancel() {
	        if (this.tracerState === TOUCH2) {
	            this.onDrag2End();
	        }
	        this.pointers.length = 0;
	        Clear(this.movedState);
	        this.tracerState = TOUCH0;
	        return this;
	    }

	    onDrag1Start() {
	        this.emit('drag1start', this);
	    }

	    onDrag1End() {
	        this.emit('drag1end', this);
	    }

	    onDrag1() {
	        this.emit('drag1', this);
	    }

	    onDrag2Start() {
	        this.emit('drag2start', this);
	    }

	    onDrag2End() {
	        this.emit('drag2end', this);
	    }

	    onDrag2() {
	        this.emit('drag2', this);
	    }

	    get distanceBetween() {
	        if (this.tracerState !== TOUCH2) {
	            return 0;
	        }
	        var p0 = this.pointers[0],
	            p1 = this.pointers[1];
	        return DistanceBetween$2(p0.x, p0.y, p1.x, p1.y);
	    }

	    get angleBetween() {
	        if (this.tracerState !== TOUCH2) {
	            return 0;
	        }
	        var p0 = this.pointers[0],
	            p1 = this.pointers[1];
	        return AngleBetween(p0.x, p0.y, p1.x, p1.y);
	    }

	    get drag1Vector() {
	        var pointer = this.pointers[0];
	        if (pointer && this.movedState[pointer.id]) {
	            var p1 = pointer.position;
	            var p0 = pointer.prevPosition;
	            tmpDragVector.x = p1.x - p0.x;
	            tmpDragVector.y = p1.y - p0.y;
	        } else {
	            tmpDragVector.x = 0;
	            tmpDragVector.y = 0;
	        }
	        return tmpDragVector;
	    }

	    get centerX() {
	        if (this.tracerState !== TOUCH2) {
	            return 0;
	        }
	        var p0 = this.pointers[0].position;
	        var p1 = this.pointers[1].position;
	        return (p0.x + p1.x) / 2;
	    }

	    get centerY() {
	        if (this.tracerState !== TOUCH2) {
	            return 0;
	        }
	        var p0 = this.pointers[0].position;
	        var p1 = this.pointers[1].position;
	        return (p0.y + p1.y) / 2;
	    }

	    get prevCenterX() {
	        if (this.tracerState !== TOUCH2) {
	            return 0;
	        }
	        var preP0 = (this.movedState[this.pointers[0].id]) ? this.pointers[0].prevPosition : this.pointers[0].position;
	        var preP1 = (this.movedState[this.pointers[1].id]) ? this.pointers[1].prevPosition : this.pointers[1].position;
	        return (preP0.x + preP1.x) / 2;
	    }

	    get prevCenterY() {
	        if (this.tracerState !== TOUCH2) {
	            return 0;
	        }
	        var preP0 = (this.movedState[this.pointers[0].id]) ? this.pointers[0].prevPosition : this.pointers[0].position;
	        var preP1 = (this.movedState[this.pointers[1].id]) ? this.pointers[1].prevPosition : this.pointers[1].position;
	        return (preP0.y + preP1.y) / 2;
	    }

	    get movementCenterX() {
	        return this.centerX - this.prevCenterX;
	    }

	    get movementCenterY() {
	        return this.centerY - this.prevCenterY;
	    }

	    setRecongizedStateObject(stateObject) {
	        this.recongizedState = stateObject;
	        return this;
	    }

	    get state() {
	        return this.recongizedState.state;
	    }

	    set state(newState) {
	        this.recongizedState.state = newState;
	    }

	    cancel() {
	        this.state = IDLE$1;
	        return this;
	    }

	    isPointer0InGameObject(gameObject, preTest, postTest) {
	        var pointer = this.pointers[0];
	        if (!pointer) {
	            return false;
	        }

	        return IsPointerInBounds(gameObject, pointer, preTest, postTest);
	    }

	    isPointer1InGameObject(gameObject, preTest, postTest) {
	        var pointer = this.pointers[1];
	        if (!pointer) {
	            return false;
	        }

	        return IsPointerInBounds(gameObject, pointer, preTest, postTest);
	    }
	}

	Object.assign(
	    TwoPointersTracer.prototype,
	    EventEmitterMethods$1
	);

	var tmpDragVector = {};

	const TOUCH0 = 0;
	const TOUCH1 = 1;
	const TOUCH2 = 2;

	const IDLE$1 = 'IDLE';

	Phaser.Utils.Objects.GetValue;

	const RotateAround$2 = Phaser.Math.RotateAround;

	var RotateObjectAround = function (gameObject, x, y, angle) {
	    RotateAround$2(gameObject, x, y, angle);
	    gameObject.rotation += angle;
	    return gameObject;
	};

	var ScreenXYToWorldXY = function (screenX, screenY, camera, out) {
	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        out = globalOut;
	    }

	    camera.getWorldPoint(screenX, screenY, out);
	    return out;
	};

	var globalOut = {};

	var SpinObject = function (gameObject, camera) {
	    if (!this.isRotation) {
	        return this;
	    }

	    if (camera === undefined) {
	        camera = this.pointers[0].camera;
	    }

	    var movementX = this.movementCenterX,
	        movementY = this.movementCenterY;

	    var worldXY = ScreenXYToWorldXY(this.centerX, this.centerY, camera, true);
	    var centerWorldX = worldXY.x;
	    var centerWorldY = worldXY.y;

	    var angle = this.rotation;
	    if (Array.isArray(gameObject)) {
	        var gameObjects = gameObject;
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            gameObject = gameObjects[i];
	            gameObject.x += movementX;
	            gameObject.y += movementY;
	            RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
	        }
	    } else {
	        gameObject.x += movementX;
	        gameObject.y += movementY;
	        RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
	    }
	    return this;
	};

	const GetValue$1f = Phaser.Utils.Objects.GetValue;
	const WrapDegrees$1 = Phaser.Math.Angle.WrapDegrees; // Wrap degrees: -180 to 180 
	const ShortestBetween$1 = Phaser.Math.Angle.ShortestBetween;
	const RadToDeg$2 = Phaser.Math.RadToDeg;
	const DegToRad$4 = Phaser.Math.DegToRad;

	class Rotate extends TwoPointersTracer {
	    constructor(gameObject, config) {
	        super(gameObject, config);

	        var self = this;
	        var stateConfig = {
	            states: {
	                IDLE: {
	                    enter: function () {
	                        self.prevAngle = undefined;
	                        self.angle = 0;
	                    },
	                },
	                BEGIN: {
	                },
	                RECOGNIZED: {
	                    enter: function () {
	                        self.emit('rotatestart', self);
	                    },
	                    exit: function () {
	                        self.emit('rotateend', self);
	                    }
	                }
	            },
	            init: function () {
	                this.state = IDLE;
	            },
	            eventEmitter: false,
	        };
	        this.setRecongizedStateObject(new FSM(stateConfig));
	    }

	    resetFromJSON(o) {
	        super.resetFromJSON(o);
	        this.setDragThreshold(GetValue$1f(o, 'threshold', 0));
	        return this;
	    }

	    onDrag2Start() {
	        this.prevAngle = WrapDegrees$1(RadToDeg$2(this.angleBetween)); // Degrees
	        this.state = BEGIN;
	        if (this.dragThreshold === 0) {
	            this.state = RECOGNIZED;
	        }
	    }

	    onDrag2End() {
	        this.state = IDLE;
	    }

	    onDrag2() {
	        switch (this.state) {
	            case BEGIN:
	                if ((this.pointers[0].getDistance() >= this.dragThreshold) &&
	                    (this.pointers[1].getDistance() >= this.dragThreshold)) {
	                    var curAngle = WrapDegrees$1(RadToDeg$2(this.angleBetween));
	                    this.angle = ShortestBetween$1(this.prevAngle, curAngle);
	                    this.prevAngle = curAngle;
	                    this.state = RECOGNIZED;
	                }
	                break;
	            case RECOGNIZED:
	                var curAngle = WrapDegrees$1(RadToDeg$2(this.angleBetween));
	                this.angle = ShortestBetween$1(this.prevAngle, curAngle);
	                this.prevAngle = curAngle;
	                this.emit('rotate', this);
	                break;
	        }
	    }

	    get isRotated() {
	        return (this.state === RECOGNIZED);
	    }

	    get rotation() {
	        return DegToRad$4(this.angle);
	    }

	    setDragThreshold(distance) {
	        this.dragThreshold = distance;
	        return this;
	    }

	}

	var methods$d = {
	    spinObject: SpinObject,
	};
	Object.assign(
	    Rotate.prototype,
	    methods$d
	);


	const IDLE = 'IDLE';
	const BEGIN = 'BEGIN';
	const RECOGNIZED = 'RECOGNIZED';

	const GetValue$1e = Phaser.Utils.Objects.GetValue;

	var TapChild = function (config) {
	    var tapConfig = GetValue$1e(config, 'tap', undefined);
	    if (tapConfig === false) {
	        return;
	    } else if (tapConfig === true) {
	        tapConfig = undefined;
	    }

	    var childrenInteractive = this._childrenInteractive;
	    this._tap = new Tap(this, tapConfig);
	    this._tap
	        .on('tap', function (tap, gameObject, lastPointer) {
	            EmitChildEvent(
	                childrenInteractive.eventEmitter,
	                `${childrenInteractive.eventNamePrefix}${tap.tapsCount}tap`,
	                childrenInteractive.targetSizers,
	                childrenInteractive.targetMode,
	                tap.worldX, tap.worldY,
	                lastPointer, tap
	            );

	            EmitChildEvent(
	                childrenInteractive.eventEmitter,
	                `${childrenInteractive.eventNamePrefix}tap`,
	                childrenInteractive.targetSizers,
	                childrenInteractive.targetMode,
	                tap.worldX, tap.worldY,
	                lastPointer, tap
	            );
	        }, this);
	};

	const GetValue$1d = Phaser.Utils.Objects.GetValue;

	var PressChild = function (config) {
	    var pressConfig = GetValue$1d(config, 'press', undefined);
	    if (pressConfig === false) {
	        return;
	    } else if (pressConfig === true) {
	        pressConfig = undefined;
	    }

	    var childrenInteractive = this._childrenInteractive;
	    this._press = new Press(this, pressConfig);
	    this._press
	        .on('pressstart', function (press, gameObject, lastPointer) {
	            EmitChildEvent(
	                childrenInteractive.eventEmitter,
	                `${childrenInteractive.eventNamePrefix}pressstart`,
	                childrenInteractive.targetSizers,
	                childrenInteractive.targetMode,
	                press.worldX, press.worldY,
	                lastPointer, press
	            );
	        }, this)
	        .on('pressend', function (press, gameObject, lastPointer) {
	            EmitChildEvent(
	                childrenInteractive.eventEmitter,
	                `${childrenInteractive.eventNamePrefix}pressend`,
	                childrenInteractive.targetSizers,
	                childrenInteractive.targetMode,
	                press.worldX, press.worldY,
	                lastPointer, press
	            );
	        }, this);
	};

	const GetValue$1c = Phaser.Utils.Objects.GetValue;

	var SwipeChild = function (config) {
	    var swipeConfig = GetValue$1c(config, 'swipe', undefined);
	    if (swipeConfig === false) {
	        return;
	    } else if (swipeConfig === true) {
	        swipeConfig = undefined;
	    }

	    if (swipeConfig === undefined) {
	        swipeConfig = {};
	    }
	    if (!swipeConfig.hasOwnProperty('dir')) {
	        swipeConfig.dir = '4dir';
	    }

	    var childrenInteractive = this._childrenInteractive;
	    this._swipe = new Swipe(this, swipeConfig);
	    this._swipe
	        .on('swipe', function (swipe, gameObject, lastPointer) {
	            var dirName =
	                (swipe.left) ? 'left' :
	                    (swipe.right) ? 'right' :
	                        (swipe.up) ? 'up' :
	                            'down';
	            EmitChildEvent(
	                childrenInteractive.eventEmitter,
	                `${childrenInteractive.eventNamePrefix}swipe${dirName}`,
	                childrenInteractive.targetSizers,
	                childrenInteractive.targetMode,
	                swipe.worldX, swipe.worldY,
	                lastPointer, swipe
	            );

	            EmitChildEvent(
	                childrenInteractive.eventEmitter,
	                `${childrenInteractive.eventNamePrefix}swipe`,
	                childrenInteractive.targetSizers,
	                childrenInteractive.targetMode,
	                swipe.worldX, swipe.worldY,
	                lastPointer, swipe
	            );
	        }, this);
	};

	const GetValue$1b = Phaser.Utils.Objects.GetValue;

	var SetChildrenInteractive$1 = function (gameObject, config) {
	    gameObject.setInteractive();

	    if (GetValue$1b(config, 'dropZone', false)) {
	        gameObject.input.dropZone = true;
	    }

	    gameObject._childrenInteractive = {
	        targetSizers: GetValue$1b(config, 'targets', [gameObject]),
	        targetMode: GetValue$1b(config, 'targetMode', 'parent'),
	        eventEmitter: GetValue$1b(config, 'eventEmitter', gameObject),
	        eventNamePrefix: GetValue$1b(config, 'inputEventPrefix', 'child.')
	    };

	    DownChild.call(gameObject, config);
	    UpChild.call(gameObject, config);
	    OverChild.call(gameObject, config);
	    ClickChild.call(gameObject, config);
	    TapChild.call(gameObject, config);
	    PressChild.call(gameObject, config);
	    SwipeChild.call(gameObject, config);

	    return gameObject;
	};

	var SetChildrenInteractiveWrap = function (config) {    
	    SetChildrenInteractive$1(this, config);
	    return this;
	};

	var BroadcastEvent = function () {
	    var gameObjects = this.getAllChildren([this]);
	    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	        var gameObject = gameObjects[i];
	        gameObject.emit.apply(gameObject, arguments);
	    }
	    return this;
	};

	var methods$c = {
	    getSizerConfig: GetSizerConfig,
	    getChildPrevState: GetChildPrevState,
	    pushIntoBounds: PushIntoBounds,
	    drawBounds: DrawBounds,
	    resolveWidth: ResolveWidth$3,
	    hasWidthWrap: HasWidthWrap$2,
	    resolveChildrenWidth: ResolveChildrenWidth$1,
	    runWidthWrap: RunWidthWrap$3,
	    resolveHeight: ResolveHeight$3,
	    hasHeightWrap: HasHeightWrap$2,
	    resolveChildrenHeight: ResolveChildrenHeight$1,
	    runHeightWrap: RunHeightWrap$3,
	    getChildWidth: GetChildWidth,
	    getChildHeight: GetChildHeight,
	    getExpandedChildWidth: GetExpandedChildWidth$4,
	    getExpandedChildHeight: GetExpandedChildHeight$4,

	    getChildrenWidth: GetChildrenWidth$4,
	    getChildrenHeight: GetChildrenHeight$4,
	    addChildrenMap: AddChildrenMap,
	    addElement: AddChildrenMap,
	    removeChildrenMap: RemoveChildrenMap,
	    getElement: GetElement,
	    getChildIndex: GetChildIndex,
	    getAllChildrenSizers: GetAllChildrenSizers,
	    getChildrenSizers: GetChildrenSizers$4,
	    preLayout: PreLayout$4,
	    layout: Layout,
	    runLayout: RunLayout,
	    layoutChildren: LayoutChildren$5,

	    layoutBackgrounds: LayoutBackgrounds,
	    postLayout: PostLayout,

	    setAnchor: SetAnchor,
	    isInTouching: IsInTouching,
	    pointToChild: PointToChild,
	    setDraggable: SetDraggable,
	    setChildrenInteractive: SetChildrenInteractiveWrap,
	    broadcastEvent: BroadcastEvent,

	};

	Object.assign(
	    methods$c,
	    PaddingMethods,
	    AddChildMethods$7,
	    RemoveChildMethods$7,
	    GetParentSizerMethods,
	    methods$h,
	    methods$g,
	    methods$f,
	    ShakeMethods,
	    EaseDataMethods,
	    DelayCallMethods$1,
	    ClickMethods,
	    ClickOutsideMethods,
	    TouchingMethods,
	    HoverMethods,
	    HideMethods,
	    ModalMethods$1,
	    GetShownChildrenMethods,
	    BindEventMethods,
	);

	const GetValue$1a = Phaser.Utils.Objects.GetValue;

	let Base$2 = class Base extends ContainerLite {
	    constructor(scene, x, y, minWidth, minHeight, config) {
	        super(scene, x, y, 1, 1);
	        this.isRexSizer = true;

	        var origin = GetValue$1a(config, 'origin', 0.5);
	        var originX = GetValue$1a(config, 'originX', origin);
	        var originY = GetValue$1a(config, 'originY', origin);
	        this.setOrigin(originX, originY);

	        this.setMinSize(minWidth, minHeight);
	        this.setName(GetValue$1a(config, 'name', ''));
	        this.rexSizer = {};
	        this.space = {};
	        this.backgroundChildren = undefined;
	        this.sizerChildren = undefined; // [] or {}
	        this.childrenMap = {};
	        this.layoutedChildren = undefined;

	        // FixWidthSizer uses these flag
	        this.runChildrenWrapFlag = false;

	        this.enableLayoutWarn(false);

	        var anchorConfig = GetValue$1a(config, 'anchor', undefined);
	        if (anchorConfig) {
	            this.setAnchor(anchorConfig);
	        }

	        this.setInnerPadding(GetValue$1a(config, 'space', 0));

	        var draggable = GetValue$1a(config, 'draggable', false);
	        if (draggable) {
	            this.setDraggable(draggable);
	        }

	        this.setSizerEventsEnable(GetValue$1a(config, 'sizerEvents', false));
	        this.setDirty(true);

	        if (GetValue$1a(config, 'enableLayer', false)) {
	            this.enableLayer();
	        }
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        if (fromScene) {
	            // In this case, children will be cleared and destroy in scene level
	            var sizers = this.getAllChildrenSizers([this]);
	            for (var i = 0, cnt = sizers.length; i < cnt; i++) {
	                sizers[i].sizerEventsEnable = false;
	            }
	        }

	        super.destroy(fromScene);

	        Clear(this.backgroundChildren);
	        Clear(this.sizerChildren);
	        this.childrenMap = undefined;
	        this.space = undefined;
	        this.rexSizer = undefined;
	        this.layoutedChildren = undefined;
	    }

	    setMinSize(minWidth, minHeight) {
	        this.setMinWidth(minWidth).setMinHeight(minHeight);
	        return this;
	    }

	    setMinWidth(minWidth) {
	        if (minWidth == null) {
	            minWidth = 0;
	        }
	        this.minWidth = minWidth;
	        return this;
	    }

	    setMinHeight(minHeight) {
	        if (minHeight == null) {
	            minHeight = 0;
	        }
	        this.minHeight = minHeight;
	        return this;
	    }

	    setDirty(dirty) {
	        if (dirty === undefined) {
	            dirty = true;
	        }
	        this.dirty = dirty;
	        return this;
	    }

	    setSizerEventsEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }

	        this.sizerEventsEnable = enable;
	        return this;
	    }

	    enableLayoutWarn(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.layoutWarnEnable = enable;
	        return this;
	    }

	    get ignoreLayout() {
	        // Skip hidden or !dirty sizer
	        return this.rexSizer.hidden || (!this.dirty);
	    }

	    get childrenWidth() {
	        if (this._childrenWidth === undefined) {
	            this._childrenWidth = this.getChildrenWidth();
	        }
	        return this._childrenWidth;
	    }

	    get childrenHeight() {
	        if (this._childrenHeight === undefined) {
	            this._childrenHeight = this.getChildrenHeight();
	        }
	        return this._childrenHeight;
	    }

	    get left() {
	        return this.x - (GetDisplayWidth(this) * this.originX);
	    }

	    set left(value) {
	        this.x += (value - this.left);
	    }

	    alignLeft(value) {
	        this.left = value;
	        return this;
	    }

	    get right() {
	        return this.left + GetDisplayWidth(this);
	    }

	    set right(value) {
	        this.x += (value - this.right);
	    }

	    alignRight(value) {
	        this.right = value;
	        return this;
	    }

	    get centerX() {
	        return this.left + (GetDisplayWidth(this) / 2);
	    }

	    set centerX(value) {
	        this.x += (value - this.centerX);
	    }

	    alignCenterX(value) {
	        this.centerX = value;
	        return this;
	    }

	    get top() {
	        return this.y - (GetDisplayHeight(this) * this.originY);
	    }

	    set top(value) {
	        this.y += (value - this.top);
	    }

	    alignTop(value) {
	        this.top = value;
	        return this;
	    }

	    get bottom() {
	        return this.top + GetDisplayHeight(this);
	    }

	    set bottom(value) {
	        this.y += (value - this.bottom);
	    }

	    alignBottom(value) {
	        this.bottom = value;
	        return this;
	    }

	    get centerY() {
	        return this.top + (GetDisplayHeight(this) / 2);
	    }

	    set centerY(value) {
	        this.y += (value - this.centerY);
	    }

	    alignCenterY(value) {
	        this.centerY = value;
	        return this;
	    }

	    get innerLeft() {
	        return this.left + (this.space.left * this.scaleX);
	    }

	    get innerRight() {
	        return this.right - (this.space.right * this.scaleX);
	    }

	    get innerTop() {
	        return this.top + (this.space.top * this.scaleY);
	    }

	    get innerBottom() {
	        return this.bottom - (this.space.bottom * this.scaleY);
	    }

	    get innerWidth() {
	        return (this.width - this.space.left - this.space.right) * this.scaleX;
	    }

	    get innerHeight() {
	        return (this.height - this.space.top - this.space.bottom) * this.scaleY;
	    }

	    get minInnerWidth() {
	        var result = (this.minWidth - this.space.left - this.space.right) * this.scaleX;
	        return Math.max(result, 0);
	    }

	    get minInnerHeight() {
	        var result = (this.minHeight - this.space.top - this.space.bottom) * this.scaleY;
	        return Math.max(result, 0);
	    }
	};

	Object.assign(
	    Base$2.prototype,
	    methods$c
	);

	var GetChildrenWidth$3 = function (minimumMode) {
	    if (this.rexSizer.hidden) {
	        return 0;
	    }

	    if (minimumMode === undefined) {
	        minimumMode = true;
	    }

	    var result = 0;
	    var children = this.sizerChildren;
	    var child, sizerConfig, proportion, padding, childWidth;
	    var hasUnknownChildWidth = false;
	    this.childrenProportion; // To update this.hasProportion0Child member

	    if (this.orientation === 0) { // x
	        // Get summation of minimum width
	        var isFirstChild = true;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = children[i];
	            if (!child.hasOwnProperty('rexSizer')) {
	                continue;
	            }

	            sizerConfig = child.rexSizer;
	            if (sizerConfig.hidden) {
	                continue;
	            }

	            proportion = sizerConfig.proportion;
	            if ((proportion === 0) || minimumMode) {
	                childWidth = this.getChildWidth(child);
	                if ((sizerConfig.fitRatio > 0) && (!sizerConfig.resolved)) {
	                    childWidth = undefined;
	                }

	                if (childWidth === undefined) {
	                    if ((proportion !== 0) && (!this.hasProportion0Child)) {
	                        childWidth = 0;
	                    } else {
	                        hasUnknownChildWidth = true;
	                    }
	                }
	            } else {
	                childWidth = 0;
	            }

	            if (hasUnknownChildWidth) {
	                continue;
	            }

	            padding = child.rexSizer.padding;
	            childWidth += (padding.left + padding.right) * this.scaleX;

	            if (isFirstChild) {
	                isFirstChild = false;
	            } else {
	                childWidth += (this.space.item * this.scaleX);
	            }

	            result += childWidth;
	        }
	    } else {
	        // Get maximun width
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = children[i];
	            if (!child.hasOwnProperty('rexSizer')) {
	                continue;
	            }

	            sizerConfig = child.rexSizer;
	            if (sizerConfig.hidden) {
	                continue;
	            }

	            childWidth = this.getChildWidth(child);
	            if (childWidth === undefined) {
	                hasUnknownChildWidth = true;
	            }

	            if (hasUnknownChildWidth) {
	                continue;
	            }

	            padding = sizerConfig.padding;
	            childWidth += (padding.left + padding.right) * this.scaleX;

	            result = Math.max(childWidth, result);
	        }
	    }

	    if (hasUnknownChildWidth) {
	        return undefined;
	    }

	    return result + (this.space.left + this.space.right) * this.scaleX;
	};

	var GetChildrenHeight$3 = function (minimumMode) {
	    if (this.rexSizer.hidden) {
	        return 0;
	    }

	    if (minimumMode === undefined) {
	        minimumMode = true;
	    }

	    var result = 0;
	    var children = this.sizerChildren;
	    var child, sizerConfig, proportion, padding, childHeight;
	    var hasUnknownChildHeight = false;
	    this.childrenProportion; // To update this.hasProportion0Child member

	    if (this.orientation === 0) { // x
	        // Get maximun height
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = children[i];
	            if (!child.hasOwnProperty('rexSizer')) {
	                continue;
	            }

	            sizerConfig = child.rexSizer;
	            if (sizerConfig.hidden) {
	                continue;
	            }

	            childHeight = this.getChildHeight(child);
	            if (childHeight === undefined) {
	                hasUnknownChildHeight = true;
	            }

	            if (hasUnknownChildHeight) {
	                continue;
	            }

	            padding = sizerConfig.padding;
	            childHeight += (padding.top + padding.bottom) * this.scaleY;
	            result = Math.max(childHeight, result);
	        }
	    } else {
	        // Get summation of minimum height
	        var isFirstChild = true;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = children[i];
	            if (!child.hasOwnProperty('rexSizer')) {
	                continue;
	            }

	            sizerConfig = child.rexSizer;
	            if (sizerConfig.hidden) {
	                continue;
	            }

	            proportion = sizerConfig.proportion;
	            if ((proportion === 0) || minimumMode) {
	                childHeight = this.getChildHeight(child);
	                if ((sizerConfig.fitRatio > 0) && (!sizerConfig.resolved)) {
	                    childHeight = undefined;
	                }

	                if (childHeight === undefined) {
	                    if ((proportion !== 0) && (!this.hasProportion0Child)) {
	                        childHeight = 0;
	                    } else {
	                        hasUnknownChildHeight = true;
	                    }
	                }
	            } else {
	                childHeight = 0;
	            }

	            if (hasUnknownChildHeight) {
	                continue;
	            }

	            padding = sizerConfig.padding;
	            childHeight += (padding.top + padding.bottom) * this.scaleY;

	            if (isFirstChild) {
	                isFirstChild = false;
	            } else {
	                childHeight += (this.space.item * this.scaleY);
	            }

	            result += childHeight;
	        }
	    }

	    if (hasUnknownChildHeight) {
	        return undefined;
	    }

	    return result + (this.space.top + this.space.bottom) * this.scaleY;
	};

	var GetExpandedChildWidth$3 = function (child, parentWidth) {
	    if (parentWidth === undefined) {
	        parentWidth = this.width * this.scaleX;
	    }

	    var childWidth;
	    var sizerConfig = child.rexSizer;
	    if (this.orientation === 0) { // x
	        if ((sizerConfig.proportion > 0) && (this.proportionLength > 0)) {
	            childWidth = (sizerConfig.proportion * this.proportionLength);
	        }
	    } else { // y
	        if (sizerConfig.expand) {
	            var space = this.space;
	            var innerWidth = parentWidth - (space.left + space.right) * this.scaleX;
	            var padding = sizerConfig.padding;
	            childWidth = innerWidth - (padding.left + padding.right) * this.scaleX;
	        }
	    }
	    return childWidth;
	};

	var GetExpandedChildHeight$3 = function (child, parentHeight) {
	    if (parentHeight === undefined) {
	        parentHeight = this.height;
	    }

	    var childHeight;
	    var sizerConfig = child.rexSizer;
	    if (this.orientation === 0) { // x
	        if (sizerConfig.expand) {
	            var space = this.space;
	            var innerHeight = parentHeight - ((space.top + space.bottom) * this.scaleY);
	            var padding = sizerConfig.padding;
	            childHeight = innerHeight - ((padding.top + padding.bottom) * this.scaleY);
	        }
	    } else { // y
	        if ((sizerConfig.proportion > 0) && (this.proportionLength > 0)) {
	            childHeight = (sizerConfig.proportion * this.proportionLength);
	        }
	    }
	    return childHeight;
	};

	var GetChildrenSizers$3 = function(out) {
	    if (out === undefined) {
	        out = [];
	    }
	    var children = this.sizerChildren,
	        child;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        if (child.isRexSizer) {
	            out.push(child);
	        }
	    }
	    return out;
	};

	var PreLayout$3 = function () {
	    // Resize child to 1x1 for ratio-fit 
	    this.hasRatioFitChild = false;
	    var child, sizerConfig;
	    var children = this.sizerChildren;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        sizerConfig = child.rexSizer;
	        if (sizerConfig.hidden) {
	            continue;
	        }

	        if (sizerConfig.fitRatio > 0) {
	            ResizeGameObject(child, 0, 0);
	            sizerConfig.resolved = false;
	            this.hasRatioFitChild = true;
	        }

	    }

	    this._childrenProportion = undefined;
	    this.hasProportion0Child = false;
	    this.proportionLength = undefined; // Display proportion-length, contains scale
	    PreLayout$4.call(this);
	    return this;
	};

	var CheckSize = function (child, parent) {
	    if (child.layoutWarnEnable) {
	        if (child.width < child.childrenWidth) {
	            // Warning
	            console.warn(`Layout width error: Parent=${parent.constructor.name}, Child=${child.constructor.name}`);
	        }
	        if (child.height < child.childrenHeight) {
	            // Warning
	            console.warn(`Layout height error: Parent=${parent.constructor.name}, Child=${child.constructor.name}`);
	        }
	    }
	};

	const Wrap = Phaser.Math.Wrap;

	var LayoutChildren$4 = function () {
	    var children = this.sizerChildren;
	    var child, childConfig, padding;
	    var startX = this.innerLeft,
	        startY = this.innerTop;
	    var innerWidth = this.innerWidth;
	    var innerHeight = this.innerHeight;
	    var itemX = startX,
	        itemY = startY;
	    var x, y, width, height, alignOffsetX, alignOffsetY; // Align zone
	    var childWidth, childHeight;
	    var childIndex, startChildIndex = this.startChildIndex;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        if (startChildIndex === 0) {
	            childIndex = i;
	        } else {
	            childIndex = Wrap((i + startChildIndex), 0, cnt);
	        }

	        if (this.rtl) {
	            childIndex = cnt - childIndex - 1;
	        }

	        child = children[childIndex];
	        if (child.rexSizer.hidden) {
	            continue;
	        }

	        childConfig = child.rexSizer;
	        padding = childConfig.padding;

	        PreLayoutChild.call(this, child);

	        // Set size
	        if (child.isRexSpace) {
	            childWidth = 0;
	            childHeight = 0;
	        } else {
	            childWidth = this.getExpandedChildWidth(child);
	            childHeight = this.getExpandedChildHeight(child);
	        }
	        if (child.isRexSizer) {
	            child.runLayout(this, childWidth, childHeight);
	            CheckSize(child, this);
	        } else {
	            ResizeGameObject(child, childWidth, childHeight);
	        }

	        if (childWidth === undefined) {
	            childWidth = GetDisplayWidth(child);
	        }
	        if (childHeight === undefined) {
	            childHeight = GetDisplayHeight(child);
	        }

	        // Set position
	        if (this.orientation === 0) { // x
	            x = itemX + (padding.left * this.scaleX);
	            if ((childConfig.proportion === 0) || (this.proportionLength === 0)) {
	                width = childWidth;
	            } else {
	                width = (childConfig.proportion * this.proportionLength);
	            }

	            y = itemY + (padding.top * this.scaleY);
	            height = innerHeight - ((padding.top + padding.bottom) * this.scaleY);
	        } else { // y
	            x = itemX + (padding.left * this.scaleX);
	            width = innerWidth - ((padding.left + padding.right) * this.scaleX);

	            y = itemY + (padding.top * this.scaleY);
	            if ((childConfig.proportion === 0) || (this.proportionLength === 0)) {
	                height = childHeight;
	            } else {
	                height = (childConfig.proportion * this.proportionLength);
	            }
	        }

	        if (childWidth === undefined) {
	            childWidth = GetDisplayWidth(child);
	        }
	        if (childHeight === undefined) {
	            childHeight = GetDisplayHeight(child);
	        }
	        alignOffsetX = (childConfig.alignOffsetX + (childConfig.alignOffsetOriginX * childWidth)) * this.scaleX;
	        alignOffsetY = (childConfig.alignOffsetY + (childConfig.alignOffsetOriginY * childHeight)) * this.scaleY;

	        LayoutChild.call(this,
	            child, x, y, width, height, childConfig.align,
	            alignOffsetX, alignOffsetY
	        );

	        if (this.orientation === 0) { // x
	            itemX += (width + ((padding.left + padding.right) * this.scaleX) + (this.space.item * this.scaleX));
	        } else { // y
	            itemY += (height + ((padding.top + padding.bottom) * this.scaleY) + (this.space.item * this.scaleY));
	        }
	    }

	};

	var ResolveWidth$1 = function (width) {
	    var width = ResolveWidth$3.call(this, width);

	    // Calculate proportionLength
	    if ((width !== undefined) && (this.orientation === 0) && (this.proportionLength === undefined)) {
	        var remainder = width - this.childrenWidth;
	        if (remainder > 0) {
	            remainder = width - this.getChildrenWidth(false);
	            this.proportionLength = remainder / this.childrenProportion;
	        } else {
	            this.proportionLength = 0;
	        }
	    }

	    return width;
	};

	var ResolveHeight$1 = function (height) {
	    var height = ResolveHeight$3.call(this, height);

	    // Get proportionLength
	    if ((height !== undefined) && (this.orientation === 1) && (this.proportionLength === undefined)) {
	        var remainder = height - this.childrenHeight;
	        if (remainder > 0) {
	            remainder = height - this.getChildrenHeight(false);            
	            this.proportionLength = remainder / this.childrenProportion;
	        } else {
	            this.proportionLength = 0;
	        }
	    }

	    return height;
	};

	var HasWidthWrap$1 = function () {
	    if (this.hasRatioFitChild && (this.orientation === 1)) {
	        return true;
	    }

	    return HasWidthWrap$2.call(this);
	};

	var ExpandFitRatioChildren = function (width, height) {
	    if (!this.hasRatioFitChild) {
	        return;
	    }

	    var innerHeight;
	    if (this.orientation === 0) {
	        innerHeight = height - ((this.getInnerPadding('top') + this.getInnerPadding('bottom')) * this.scaleY);
	    } else {
	        width - ((this.getInnerPadding('left') + this.getInnerPadding('right')) * this.scaleX);
	    }

	    var child, sizerConfig;
	    var childWidth, childHeight;
	    var children = this.sizerChildren;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        var sizerConfig = child.rexSizer;
	        if (sizerConfig.hidden) {
	            continue;
	        }

	        var fitRatio = sizerConfig.fitRatio;
	        if (!fitRatio) {
	            continue;
	        }

	        if (this.orientation === 0) {
	            // Set child width by child height 
	            childHeight = innerHeight - ((this.getChildOuterPadding(child, 'top') + this.getChildOuterPadding(child, 'bottom')) * this.scaleY);
	            childWidth = childHeight * fitRatio;
	        } else {
	            // Set child height by child width
	            childWidth = innerHeight - ((this.getChildOuterPadding(child, 'top') + this.getChildOuterPadding(child, 'bottom')) * this.scaleX);
	            childHeight = childWidth / fitRatio;
	        }

	        ResizeGameObject(child, childWidth, childHeight);
	        if (child.isRexSizer) {
	            child.setMinSize(childWidth, childHeight);
	        }

	        sizerConfig.resolved = true;
	    }
	};

	var RunWidthWrap$2 = function (width) {
	    if (this.wrapResult) {
	        // Already got wrapResult
	        return;
	    }

	    if (this.orientation === 1) {
	        ExpandFitRatioChildren.call(this, width, undefined);
	    }

	    RunWidthWrap$3.call(this, width);
	};

	var HasHeightWrap$1 = function () {
	    if (this.hasRatioFitChild && (this.orientation === 0)) {
	        return true;
	    }

	    return HasHeightWrap$2.call(this);
	};

	var RunHeightWrap$2 = function (height) {
	    if (this.wrapResult) {
	        // Already got wrapResult
	        return;
	    }

	    if (this.orientation === 0) {
	        ExpandFitRatioChildren.call(this, undefined, height);
	    }

	    RunHeightWrap$3.call(this, height);
	};

	const Zone = Phaser.GameObjects.Zone;

	let Space$1 = class Space extends Zone {
	    constructor(scene) {
	        super(scene, 0, 0, 1, 1);
	        // Don't add Zone into scene
	        this.isRexSpace = true;
	    }
	};

	var GetNearestChildIndex$1 = function (x, y) {
	    var children = this.sizerChildren;
	    if (children.length === 0) {
	        return -1;
	    }

	    var nearestIndex = -1,
	        minDistance = Infinity;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];

	        var distance;
	        if (this.orientation === 0) { // x
	            distance = Math.abs(child.left - x);
	        } else {
	            distance = Math.abs(child.top - y);
	        }

	        if (minDistance > distance) {
	            minDistance = distance;
	            nearestIndex = i;
	        }
	    }

	    // Check right bound of last child
	    var child = children[children.length - 1];
	    var distance;
	    if (this.orientation === 0) { // x
	        distance = Math.abs(child.right - x);
	    } else {
	        distance = Math.abs(child.bottom - y);
	    }

	    if (minDistance > distance) {
	        minDistance = distance;
	        nearestIndex = i + 1;
	    }

	    return nearestIndex;
	};

	const IsPlainObject$l = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$19 = Phaser.Utils.Objects.GetValue;
	const ALIGN_CENTER$3 = Phaser.Display.Align.CENTER;
	const PROPORTIONMODE = {
	    min: 0,
	    full: -1,
	};

	var Add$6 = function (
	    gameObject,
	    proportion, align, paddingConfig, expand,
	    childKey, index,
	    minWidth, minHeight,
	    fitRatio
	) {
	    var offsetX, offsetY;
	    var offsetOriginX, offsetOriginY;

	    AddChild$2.call(this, gameObject);

	    var isRexSpace = gameObject.isRexSpace;
	    var proportionType = typeof (proportion);
	    if (proportion === null) {
	        return this;
	    } else if (proportionType === 'number') ; else if (proportionType === 'string') {
	        proportion = PROPORTIONMODE[proportion];
	    } else if (IsPlainObject$l(proportion)) {
	        var config = proportion;
	        proportion = GetValue$19(config, 'proportion', undefined);
	        align = GetValue$19(config, 'align', ALIGN_CENTER$3);
	        paddingConfig = GetValue$19(config, 'padding', 0);
	        expand = GetValue$19(config, 'expand', false);
	        childKey = GetValue$19(config, 'key', undefined);
	        index = GetValue$19(config, 'index', undefined);

	        if (!gameObject.isRexSizer) {
	            minWidth = GetValue$19(config, 'minWidth', undefined);
	            minHeight = GetValue$19(config, 'minHeight', undefined);
	        }

	        fitRatio = GetValue$19(config, 'fitRatio', 0);  // width/height

	        offsetX = GetValue$19(config, 'offsetX', 0);
	        offsetY = GetValue$19(config, 'offsetY', 0);
	        offsetOriginX = GetValue$19(config, 'offsetOriginX', 0);
	        offsetOriginY = GetValue$19(config, 'offsetOriginY', 0);
	    }

	    if (typeof (align) === 'string') {
	        align = AlignConst[align];
	    }

	    if (proportion === undefined) {
	        proportion = (isRexSpace) ? 1 : 0;
	    }
	    if (align === undefined) {
	        align = ALIGN_CENTER$3;
	    }
	    if (paddingConfig === undefined) {
	        paddingConfig = 0;
	    }
	    if (expand === undefined) {
	        expand = false;
	    }

	    if (minWidth === undefined) {
	        if (isRexSpace) {
	            minWidth = 0;
	        } else if (!gameObject.isRexSizer) {
	            minWidth = gameObject._minWidth;
	        }
	    }
	    if (minHeight === undefined) {
	        if (isRexSpace) {
	            minHeight = 0;
	        } else if (!gameObject.isRexSizer) {
	            minHeight = gameObject._minHeight;
	        }
	    }

	    if ((fitRatio === undefined) || (fitRatio === false)) {
	        fitRatio = 0;
	    } else if (fitRatio === true) {
	        fitRatio = GetDisplayWidth(gameObject) / GetDisplayHeight(gameObject);
	    }

	    if (offsetX === undefined) {
	        offsetX = 0;
	    }
	    if (offsetY === undefined) {
	        offsetY = 0;
	    }
	    if (offsetOriginX === undefined) {
	        offsetOriginX = 0;
	    }
	    if (offsetOriginY === undefined) {
	        offsetOriginY = 0;
	    }

	    var config = this.getSizerConfig(gameObject);
	    config.proportion = proportion;
	    config.align = align;
	    config.padding = GetBoundsConfig$1(paddingConfig);
	    config.expand = expand;
	    config.fitRatio = (proportion === 0) ? fitRatio : 0;
	    config.alignOffsetX = offsetX;
	    config.alignOffsetY = offsetY;
	    config.alignOffsetOriginX = offsetOriginX;
	    config.alignOffsetOriginY = offsetOriginY;

	    if ((index === undefined) || (index >= this.sizerChildren.length)) {
	        this.sizerChildren.push(gameObject);
	    } else {
	        this.sizerChildren.splice(index, 0, gameObject);
	    }

	    if (!gameObject.isRexSizer) { // Expand normal game object
	        if (proportion > 0) {
	            if (this.orientation === 0) { // x
	                // minWidth is still undefined, uses current display width
	                gameObject.minWidth = (minWidth === undefined) ? GetDisplayWidth(gameObject) : minWidth;
	            } else {
	                // minHeight is still undefined, uses current display height
	                gameObject.minHeight = (minHeight === undefined) ? GetDisplayHeight(gameObject) : minHeight;
	            }
	        }
	        if (expand) {
	            if (this.orientation === 0) { // x
	                // Might have minHeight value, or still undefined
	                gameObject.minHeight = minHeight;
	            } else {
	                // Might have minWidth value, or still undefined
	                gameObject.minWidth = minWidth;
	            }
	        }
	    }

	    if (childKey !== undefined) {
	        this.addChildrenMap(childKey, gameObject);
	    }

	    return this;
	};

	var AddChildMethods$6 = {
	    add: Add$6, // sizer.add could be override

	    addSpace(proportion) {
	        this.insertSpace(undefined, proportion);
	        return this;
	    },

	    insertSpace(index, proportion) {
	        if (proportion === undefined) {
	            proportion = 1;
	        }
	        Add$6.call(this, new Space$1(this.scene),
	            {
	                proportion: proportion,
	                minWidth: 0,
	                minHeight: 0,
	                index: index
	            }
	        );
	        // No problem if sizer.add is override
	        return this;
	    },

	    insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
	        if (IsPlainObject$l(proportion)) {
	            proportion.index = index;
	        }

	        Add$6.call(this, gameObject, proportion, align, paddingConfig, expand, childKey, index, minSize);
	        // No problem if sizer.add is override
	        return this;
	    },

	    insertAtPosition(x, y, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
	        var index = GetNearestChildIndex$1.call(this, x, y);
	        if (index === -1) {
	            index = undefined;
	        }
	        this.insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize);
	        return this;
	    }
	};

	const ContainerClear = ContainerLite.prototype.clear;

	var ClearChildren = function (destroyChild) {
	    if (this.backgroundChildren) {
	        this.backgroundChildren.length = 0;
	    }

	    var fireRemoveEvent = !destroyChild && this.sizerEventsEnable;
	    var children;
	    if (fireRemoveEvent) {
	        children = this.getChildren([]);
	    }

	    ContainerClear.call(this, destroyChild);

	    if (fireRemoveEvent) {
	        var gameObject;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            gameObject = children[i];
	            gameObject.emit('sizer.remove', gameObject, this);
	            this.emit('remove', gameObject, this);
	        }
	    }
	    return this;
	};

	const RemoveItem$5 = Phaser.Utils.Array.Remove;

	var RemoveChildMethods$6 = {
	    remove(gameObject, destroyChild) {
	        if (this.getParentSizer(gameObject) !== this) {
	            return this;
	        }

	        RemoveItem$5(this.sizerChildren, gameObject);
	        RemoveChild$1.call(this, gameObject, destroyChild);
	        return this;
	    },

	    removeAll(destroyChild) {
	        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
	            this.remove(this.sizerChildren[i], destroyChild);
	        }
	        return this;
	    },

	    clear(destroyChild) {
	        this.sizerChildren.length = 0;
	        ClearChildren.call(this, destroyChild);
	        return this;
	    }
	};

	var AlignMethods = {
	    getChildAlign(gameObject) {
	        return this.getSizerConfig(gameObject).align;
	    },

	    setChildAlign(gameObject, align) {
	        if (typeof (align) === 'string') {
	            align = AlignConst[align];
	        }

	        this.getSizerConfig(gameObject).align = align;
	        return this;
	    },

	};

	var ProportionMethods = {
	    getChildProportion(gameObject) {
	        return this.getSizerConfig(gameObject).proportion;
	    },

	    setChildProportion(gameObject, proportion) {
	        this.getSizerConfig(gameObject).proportion = proportion;
	        return this;
	    },

	};

	var ExpandMethods = {
	    getChildExpand(gameObject) {
	        return this.getSizerConfig(gameObject).expand;
	    },

	    setChildExpand(gameObject, expand) {
	        this.getSizerConfig(gameObject).expand = expand;
	        return this;
	    },

	};

	var SetChildrenAlignMode = function (mode) {
	    if (mode === undefined) {
	        mode = 'left';
	    }

	    var children = this.sizerChildren;

	    var firstChild = children[0];
	    var isFirstChildASpace = firstChild && firstChild.isRexSpace;

	    if (    // Has left space
	        (mode === 'right') ||
	        (mode === 'bottom') ||
	        (mode === 'center')
	    ) {
	        if (!isFirstChildASpace) {
	            this.insertSpace(0);
	        }

	    } else {  // Does not have left space
	        if (isFirstChildASpace) {
	            this.remove(firstChild, true);
	        }
	    }

	    var lastChildIndex = children.length - 1;
	    var lastChild = children[lastChildIndex];
	    var isLastChildASpace = lastChild && lastChild.isRexSpace;
	    if (mode === 'center') {   // Has right space
	        if (!isLastChildASpace) {
	            this.insertSpace(lastChildIndex + 1);
	        }

	    } else {  // Does not have right space
	        if (isLastChildASpace) {
	            this.remove(lastChild, true);
	        }
	    }

	    return this;
	};

	var SortChildrenMethods = {
	    sortChildren(callback) {
	        this.sizerChildren.sort(callback);
	        return this;
	    },

	    sortChildrenByData(key, descending) {
	        this.sizerChildren.sort(function (childA, childB) {
	            var valueA = childA.getData(key);
	            var valueB = childB.getData(key);
	            if (descending) {
	                return valueB - valueA;
	            } else {
	                return valueA - valueB;
	            }
	        });
	        return this;
	    },

	    sortChildrenByProperty(key, descending) {
	        this.sizerChildren.sort(function (childA, childB) {
	            var valueA = childA[key];
	            var valueB = childB[key];
	            if (descending) {
	                return valueB - valueA;
	            } else {
	                return valueA - valueB;
	            }
	        });
	        return this;
	    },
	};

	var methods$b = {
	    getChildrenWidth: GetChildrenWidth$3,
	    getChildrenHeight: GetChildrenHeight$3,
	    getExpandedChildWidth: GetExpandedChildWidth$3,
	    getExpandedChildHeight: GetExpandedChildHeight$3,
	    getChildrenSizers: GetChildrenSizers$3,
	    preLayout: PreLayout$3,
	    layoutChildren: LayoutChildren$4,
	    resolveWidth: ResolveWidth$1,
	    resolveHeight: ResolveHeight$1,
	    hasWidthWrap: HasWidthWrap$1,
	    runWidthWrap: RunWidthWrap$2,
	    hasHeightWrap: HasHeightWrap$1,
	    runHeightWrap: RunHeightWrap$2,

	    setChildrenAlignMode: SetChildrenAlignMode,
	};

	Object.assign(
	    methods$b,
	    AddChildMethods$6,
	    RemoveChildMethods$6,
	    AlignMethods,
	    ProportionMethods,
	    ExpandMethods,
	    SortChildrenMethods,
	);

	var GetChildrenProportion = function () {
	    var result = 0;
	    var children = this.sizerChildren;
	    var child, proportion;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        if (child.rexSizer.hidden) {
	            continue;
	        }
	        proportion = child.rexSizer.proportion;
	        if (proportion > 0) {
	            result += proportion;
	        } else if (proportion === 0) {
	            this.hasProportion0Child = true;
	        }
	    }
	    return result;
	};

	var OrientationMode = {
	    x: 0,
	    h: 0,
	    horizontal: 0,
	    'left-to-right': 0,

	    y: 1,
	    v: 1,
	    vertical: 1,
	    'top-to-bottom': 1
	};

	var GetOrientationMode = function (orientation) {
	    if (typeof (orientation) === 'string') {
	        orientation = OrientationMode[orientation];
	    }
	    return orientation;
	};

	const IsPlainObject$k = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$18 = Phaser.Utils.Objects.GetValue;

	class Sizer extends Base$2 {
	    constructor(scene, x, y, minWidth, minHeight, orientation, config) {
	        if (IsPlainObject$k(x)) {
	            config = x;
	            x = GetValue$18(config, 'x', 0);
	            y = GetValue$18(config, 'y', 0);
	            minWidth = GetValue$18(config, 'width', undefined);
	            minHeight = GetValue$18(config, 'height', undefined);
	            orientation = GetValue$18(config, 'orientation', 0);
	        } else if (IsPlainObject$k(minWidth)) {
	            config = minWidth;
	            minWidth = GetValue$18(config, 'width', undefined);
	            minHeight = GetValue$18(config, 'height', undefined);
	            orientation = GetValue$18(config, 'orientation', 0);
	        } else if (IsPlainObject$k(orientation)) {
	            config = orientation;
	            orientation = GetValue$18(config, 'orientation', 0);
	        }

	        if (orientation === undefined) {
	            orientation = 0;
	        }
	        super(scene, x, y, minWidth, minHeight, config);

	        this.type = 'rexSizer';
	        this.sizerChildren = [];
	        this.setOrientation(orientation);
	        this.setItemSpacing(GetValue$18(config, 'space.item', 0));
	        this.setStartChildIndex(GetValue$18(config, 'startChildIndex', 0));
	        this.setRTL(GetValue$18(config, 'rtl', false));

	        this.addChildrenMap('items', this.sizerChildren);
	    }

	    setOrientation(orientation) {
	        this.orientation = GetOrientationMode(orientation);
	        return this;
	    }

	    setItemSpacing(space) {
	        this.space.item = space;
	        return this;
	    }

	    setStartChildIndex(index) {
	        this.startChildIndex = index;
	        return this;
	    }

	    setRTL(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.rtl = enable;
	        return this;
	    }

	    get childrenProportion() {
	        if (this._childrenProportion === undefined) {
	            this._childrenProportion = GetChildrenProportion.call(this);
	        }
	        return this._childrenProportion;
	    }
	}

	Object.assign(
	    Sizer.prototype,
	    methods$b
	);

	var SetDisplaySize = function (gameObject, width, height) {
	    if (!gameObject) {
	        return;
	    }

	    var unknownWidth = (width == null);
	    var unknownHeight = (height == null);

	    if (unknownWidth && unknownHeight) {
	        return gameObject;
	    }

	    if (!unknownWidth) {
	        gameObject.displayWidth = width;
	    }

	    if (!unknownHeight) {
	        gameObject.displayHeight = height;
	    }

	    if (unknownWidth) {
	        gameObject.scaleX = gameObject.scaleY;
	    }

	    if (unknownHeight) {
	        gameObject.scaleY = gameObject.scaleX;
	    }

	    return gameObject;
	};

	var AppendText$1 = function (value, addCR) {
	    if (!value && value !== 0) {
	        value = '';
	    }

	    if (addCR === undefined) {
	        addCR = true;
	    }

	    if (Array.isArray(value)) {
	        value = value.join('\n');
	    }

	    var newText;
	    if (addCR) {
	        newText = `${this.text}\n${value}`;
	    } else {
	        newText = `${this.text}${value}`;
	    }

	    if (newText != this.text) {
	        this.setText(newText);
	    }

	    return this;
	};

	var ResetDisplayContent$2 = function (config) {
	    if (config === undefined) {
	        config = {};
	    } else if (typeof (config) === 'string') {
	        config = {
	            text: config,
	        };
	    }

	    var text = config.text || '';
	    this.setText(text);

	    var iconGameObjct = this.childrenMap.icon;
	    if (iconGameObjct) {
	        if (!config.icon) {
	            this.hide(iconGameObjct);
	        } else {
	            this.show(iconGameObjct);
	        }
	        var iconSize = config.iconSize;
	        if (iconSize) {
	            this.setChildDisplaySize(iconGameObjct, iconSize, iconSize);

	            if (this.iconWidth !== undefined) {
	                this.setIconSize(iconSize);
	            }
	        }
	        if (config.icon !== true) {
	            this.setIconTexture(config.icon, config.iconFrame);
	        }
	    }

	    var actionGameObjct = this.childrenMap.action;
	    if (actionGameObjct) {
	        if (!config.action) {
	            this.hide(actionGameObjct);
	        } else {
	            this.show(actionGameObjct);
	        }
	        var actionSize = config.actionSize;
	        if (actionSize) {
	            this.setChildDisplaySize(actionGameObjct, actionSize, actionSize);

	            if (this.actionWidth !== undefined) {
	                this.setActionSize(actionSize);
	            }

	        }
	        if (config.action !== true) {
	            this.setActionTexture(config.action, config.actionFrame);
	        }
	    }

	    return this;
	};

	var methods$a = {
	    appendText: AppendText$1,
	    resetDisplayContent: ResetDisplayContent$2,
	};

	class LabelBase extends Sizer {
	    /*
	    Elements in childrenMap: 
	    
	    - background
	    - icon, iconMask
	    - text, 
	    - action, actionMask
	    */

	    // Access text game object
	    get text() {
	        var textObject = this.childrenMap.text;
	        if (!textObject) {
	            return '';
	        }
	        return textObject.text;
	    }

	    set text(value) {
	        var textObject = this.childrenMap.text;
	        if (!textObject) {
	            return;
	        }
	        textObject.setText(value);
	    }

	    setText(value) {
	        this.text = value;
	        return this;
	    }

	    // Access icon game object
	    setIconTexture(key, frame) {
	        var imageObject = this.childrenMap.icon;
	        if (!imageObject || !imageObject.setTexture) {
	            return this;
	        }
	        imageObject.setTexture(key, frame);

	        if ((this.iconWidth !== undefined) && (this.iconHeight !== undefined)) {
	            SetDisplaySize(imageObject, this.iconWidth, this.iconHeight);
	            this.resetChildScaleState(imageObject);
	        }

	        return this;
	    }

	    setTexture(key, frame) {
	        this.setIconTexture(key, frame);
	        return this;
	    }

	    setIconSize(width, height) {
	        if (height === undefined) {
	            height = width;
	        }

	        this.iconWidth = width;
	        this.iconHeight = height;

	        return this;
	    }

	    get texture() {
	        var imageObject = this.childrenMap.icon;
	        if (!imageObject) {
	            return undefined;
	        }
	        return imageObject.texture;
	    }

	    get frame() {
	        var imageObject = this.childrenMap.icon;
	        if (!imageObject) {
	            return undefined;
	        }
	        return imageObject.frame;
	    }

	    setActionTexture(key, frame) {
	        var imageObject = this.childrenMap.action;
	        if (!imageObject || !imageObject.setTexture) {
	            return this;
	        }
	        imageObject.setTexture(key, frame);

	        if ((this.actionWidth !== undefined) && (this.actionHeight !== undefined)) {
	            SetDisplaySize(imageObject, this.actionWidth, this.actionHeight);
	            this.resetChildScaleState(imageObject);
	        }

	        return this;
	    }

	    get actionTexture() {
	        var imageObject = this.childrenMap.action;
	        if (!imageObject) {
	            return undefined;
	        }
	        return imageObject.texture;
	    }

	    get actionFrame() {
	        var imageObject = this.childrenMap.action;
	        if (!imageObject) {
	            return undefined;
	        }
	        return imageObject.frame;
	    }

	    setActionSize(width, height) {
	        if (height === undefined) {
	            height = width;
	        }

	        this.actionWidth = width;
	        this.actionHeight = height;

	        return this;
	    }

	    preLayout() {
	        var icon = this.childrenMap.icon;
	        if (icon && (this.iconWidth !== undefined) && (this.iconHeight !== undefined)) {
	            SetDisplaySize(icon, this.iconWidth, this.iconHeight);
	        }

	        var action = this.childrenMap.action;
	        if (action && (this.actionWidth !== undefined) && (this.actionHeight !== undefined)) {
	            SetDisplaySize(action, this.actionWidth, this.actionHeight);
	        }

	        super.preLayout();
	    }

	    postLayout(parent, newWidth, newHeight) {
	        // Pin icon-mask to icon game object
	        var iconMask = this.childrenMap.iconMask;
	        if (iconMask) {
	            iconMask.setPosition();
	            this.resetChildPositionState(iconMask);
	        }
	        // Pin action-mask to action game object
	        var actionMask = this.childrenMap.actionMask;
	        if (actionMask) {
	            actionMask.setPosition();
	            this.resetChildPositionState(actionMask);
	        }
	        super.postLayout(parent, newWidth, newHeight);
	        return this;
	    }

	    resize(width, height) {
	        super.resize(width, height);
	        // Resize icon-mask to icon game object
	        var iconMask = this.childrenMap.iconMask;
	        if (iconMask) {
	            iconMask.resize();
	        }
	        // Resize action-mask to icon game object
	        var actionMask = this.childrenMap.actionMask;
	        if (actionMask) {
	            actionMask.resize();
	        }
	        return this;
	    }
	}

	Object.assign(
	    LabelBase.prototype,
	    methods$a,
	);

	var AddChildMask = function (maskTarget, sizeTarget, shape, padding) {
	    var maskGameObject = new DefaultMaskGraphics(sizeTarget, shape, padding); // A Graphics game object
	    if (maskTarget && !maskTarget.isRexSizer) { // Sizer game object can't apply mask
	        var mask = maskGameObject.createGeometryMask();
	        maskTarget.setMask(mask);
	        this.once('destroy', function () {
	            maskTarget.setMask();
	            mask.destroy();
	        });
	    }
	    this.pin(maskGameObject);
	    return maskGameObject;
	};

	/*
	Elements:

	Icon  Title      ActionIcon
	Icon  Separator  ActionIcon
	Icon  Text       ActionIcon

	*/


	const GetValue$17 = Phaser.Utils.Objects.GetValue;

	var LayoutMode0 = function (config) {
	    var scene = this.scene;

	    var orientation = GetValue$17(config, 'orientation', 0);
	    this.setOrientation(orientation);

	    // Add elements
	    var icon = GetValue$17(config, 'icon', undefined);
	    var iconMask = GetValue$17(config, 'iconMask', undefined);
	    var innerBackground = GetValue$17(config, 'innerBackground', undefined);
	    var title = GetValue$17(config, 'title', undefined);
	    var separator = GetValue$17(config, 'separator', undefined);
	    var text = GetValue$17(config, 'text', undefined);
	    var action = GetValue$17(config, 'action', undefined);
	    var actionMask = GetValue$17(config, 'actionMask', undefined);


	    if (icon) {
	        var align = GetValue$17(config, 'align.icon', 'center');
	        var padding;
	        if (this.orientation === 0) {
	            padding = {
	                right: GetValue$17(config, 'space.icon', 0),
	                top: GetValue$17(config, 'space.iconTop', 0),
	                bottom: GetValue$17(config, 'space.iconBottom', 0),
	                left: GetValue$17(config, 'space.iconLeft', 0),
	            };
	        } else {
	            padding = {
	                bottom: GetValue$17(config, 'space.icon', 0),
	                left: GetValue$17(config, 'space.iconLeft', 0),
	                right: GetValue$17(config, 'space.iconRight', 0),
	                top: GetValue$17(config, 'space.iconTop', 0),
	            };
	        }
	        var fitRatio = GetValue$17(config, 'squareFitIcon', false) ? 1 : 0;

	        this.add(
	            icon,
	            { proportion: 0, align: align, padding: padding, fitRatio: fitRatio }
	        );

	        if (iconMask) {
	            iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
	        }

	        if (!fitRatio) {
	            var iconSize = GetValue$17(config, 'iconSize', undefined);
	            this.setIconSize(
	                GetValue$17(config, 'iconWidth', iconSize),
	                GetValue$17(config, 'iconHeight', iconSize)
	            );
	        }
	    }

	    // InnerSizer : title, separator, text
	    var innerSizer = new Sizer(scene, {
	        orientation: 1,
	    });

	    if (innerBackground) {
	        innerSizer.addBackground(innerBackground);
	    }

	    var separatorSpace = GetValue$17(config, 'space.separator', 0);

	    if (title) {
	        var align = GetValue$17(config, 'align.title', 'left');
	        var expandTitleWidth = GetValue$17(config, 'expandTitleWidth', false);
	        var expandTitleHeight = GetValue$17(config, 'expandTitleHeight', false);
	        var proportion, padding, expand;
	        proportion = (expandTitleHeight) ? 1 : 0;
	        expand = expandTitleWidth;
	        padding = {
	            bottom: (!separator && text) ? GetValue$17(config, 'space.title', separatorSpace) : 0,
	            left: GetValue$17(config, 'space.titleLeft', 0),
	            right: GetValue$17(config, 'space.titleRight', 0),
	        };
	        innerSizer.add(
	            title,
	            { proportion: proportion, expand: expand, align: align, padding: padding }
	        );
	    }

	    if (separator) {
	        var padding = {
	            top: (title) ? separatorSpace : 0,
	            bottom: (text) ? separatorSpace : 0,
	            left: GetValue$17(config, 'space.separatorLeft', 0),
	            right: GetValue$17(config, 'space.separatorRight', 0),
	        };
	        innerSizer.add(
	            separator,
	            { expand: true, padding: padding }
	            // Fixed height, expand width
	        );
	    }

	    if (text) {
	        var align = GetValue$17(config, 'align.text', 'left');
	        var expandTextWidth = GetValue$17(config, 'expandTextWidth', false);
	        var expandTextHeight = GetValue$17(config, 'expandTextHeight', false);
	        var proportion, padding, expand;
	        proportion = (expandTextHeight) ? 1 : 0;
	        expand = expandTextWidth;
	        padding = {
	            left: GetValue$17(config, 'space.textLeft', 0),
	            right: GetValue$17(config, 'space.textRight', 0),
	        };
	        innerSizer.add(
	            text,
	            { proportion: proportion, expand: expand, align: align, padding: padding }
	        );
	    }

	    var padding = undefined;
	    if (action) {
	        padding = {
	            right: GetValue$17(config, 'space.text', 0)
	        };
	    }
	    this.add(
	        innerSizer,
	        { proportion: 1, padding: padding }
	    );
	    // InnerSizer : title, separator, text

	    if (action) {
	        var align = GetValue$17(config, 'align.action', 'center');
	        var padding;
	        if (this.orientation === 0) {
	            padding = {
	                top: GetValue$17(config, 'space.actionTop', 0),
	                bottom: GetValue$17(config, 'space.actionBottom', 0),
	                right: GetValue$17(config, 'space.actionRight', 0),
	            };
	        } else {
	            padding = {
	                left: GetValue$17(config, 'space.actionLeft', 0),
	                right: GetValue$17(config, 'space.actionRight', 0),
	                bottom: GetValue$17(config, 'space.actionBottom', 0),
	            };
	        }
	        var fitRatio = GetValue$17(config, 'squareFitAction', false) ? 1 : 0;

	        this.add(
	            action,
	            { proportion: 0, align: align, padding: padding, fitRatio: fitRatio }
	        );

	        if (actionMask) {
	            actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
	        }

	        if (!fitRatio) {
	            var actionSize = GetValue$17(config, 'actionSize');
	            this.setActionSize(
	                GetValue$17(config, 'actionWidth', actionSize),
	                GetValue$17(config, 'actionHeight', actionSize)
	            );
	        }
	    }

	    this.addChildrenMap('icon', icon);
	    this.addChildrenMap('iconMask', iconMask);
	    this.addChildrenMap('innerSizer', innerSizer);
	    this.addChildrenMap('innerBackground', innerBackground);
	    this.addChildrenMap('title', title);
	    this.addChildrenMap('separator', separator);
	    this.addChildrenMap('text', text);
	    this.addChildrenMap('action', action);
	    this.addChildrenMap('actionMask', actionMask);
	};

	/*
	Elements:

	Title      Title       Title
	Separator  Separator   Separator
	Icon       Text        ActionIcon 

	*/


	const GetValue$16 = Phaser.Utils.Objects.GetValue;

	var LayoutMode1 = function (config) {
	    this.setOrientation(1);
	    this.setRTL(false);

	    var scene = this.scene;

	    // Add elements
	    var title = GetValue$16(config, 'title', undefined);
	    var separator = GetValue$16(config, 'separator', undefined);
	    var innerBackground = GetValue$16(config, 'innerBackground', undefined);
	    var icon = GetValue$16(config, 'icon', undefined);
	    var iconMask = GetValue$16(config, 'iconMask', undefined);
	    var text = GetValue$16(config, 'text', undefined);
	    var action = GetValue$16(config, 'action', undefined);
	    var actionMask = GetValue$16(config, 'actionMask', undefined);


	    if (title) {
	        var align = GetValue$16(config, 'align.title', 'left');
	        var expandTitleWidth = GetValue$16(config, 'expandTitleWidth', false);
	        var expandTitleHeight = GetValue$16(config, 'expandTitleHeight', false);
	        var proportion, padding, expand;
	        proportion = (expandTitleHeight) ? 1 : 0;
	        expand = expandTitleWidth;
	        padding = {
	            bottom: GetValue$16(config, 'space.title', 0),
	            left: GetValue$16(config, 'space.titleLeft', 0),
	            right: GetValue$16(config, 'space.titleRight', 0),
	        };
	        this.add(
	            title,
	            { proportion: proportion, expand: expand, align: align, padding: padding }
	        );
	    }

	    if (separator) {
	        var separatorSpace = GetValue$16(config, 'space.separator', 0);
	        var padding = {
	            top: (title) ? separatorSpace : 0,
	            bottom: (text) ? separatorSpace : 0,
	            left: GetValue$16(config, 'space.separatorLeft', 0),
	            right: GetValue$16(config, 'space.separatorRight', 0),
	        };
	        this.add(
	            separator,
	            { proportion: 0, expand: true, padding: padding }
	            // Fixed height, expand width
	        );
	    }

	    var orientation = GetValue$16(config, 'orientation', 0);
	    var innerSizer = new Sizer(scene, {
	        orientation: orientation,
	        rtl: GetValue$16(config, 'rtl', false),

	        space: {
	            left: GetValue$16(config, 'space.innerLeft', 0),
	            right: GetValue$16(config, 'space.innerRight', 0),
	            top: GetValue$16(config, 'space.innerTop', 0),
	            bottom: GetValue$16(config, 'space.innerBottom', 0),
	        }
	    });
	    if (innerBackground) {
	        innerSizer.addBackground(innerBackground);
	    }

	    this.add(
	        innerSizer,
	        { proportion: 1, expand: true }
	    );

	    if (icon) {
	        var align = GetValue$16(config, 'align.icon', 'center');
	        var padding;
	        if (innerSizer.orientation === 0) {
	            padding = {
	                right: GetValue$16(config, 'space.icon', 0),
	                top: GetValue$16(config, 'space.iconTop', 0),
	                bottom: GetValue$16(config, 'space.iconBottom', 0),
	                left: GetValue$16(config, 'space.iconLeft', 0),
	            };
	        } else {
	            padding = {
	                bottom: GetValue$16(config, 'space.icon', 0),
	                left: GetValue$16(config, 'space.iconLeft', 0),
	                right: GetValue$16(config, 'space.iconRight', 0),
	                top: GetValue$16(config, 'space.iconTop', 0),
	            };
	        }
	        var fitRatio = GetValue$16(config, 'squareFitIcon', false) ? 1 : 0;

	        innerSizer.add(
	            icon,
	            { proportion: 0, align: align, padding: padding, fitRatio: fitRatio }
	        );

	        if (iconMask) {
	            iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
	        }

	        if (!fitRatio) {
	            var iconSize = GetValue$16(config, 'iconSize', undefined);
	            this.setIconSize(
	                GetValue$16(config, 'iconWidth', iconSize),
	                GetValue$16(config, 'iconHeight', iconSize)
	            );
	        }
	    }

	    if (text) {
	        var align = GetValue$16(config, 'align.text', 'left');
	        var textSpace = GetValue$16(config, 'space.text', 0);
	        var expandTextWidth = GetValue$16(config, 'expandTextWidth', false);
	        var expandTextHeight = GetValue$16(config, 'expandTextHeight', false);
	        var proportion, padding, expand;
	        if (innerSizer.orientation === 0) {
	            proportion = (expandTextWidth) ? 1 : 0;
	            if (action) {
	                padding = { right: textSpace };
	            }
	            expand = expandTextHeight;
	        } else {
	            proportion = (expandTextHeight) ? 1 : 0;
	            if (action) {
	                padding = {
	                    bottom: textSpace
	                };
	            }
	            expand = expandTextWidth;
	        }

	        innerSizer.add(
	            text,
	            { proportion: proportion, expand: expand, align: align, padding: padding }
	        );
	    }

	    if (action) {
	        var align = GetValue$16(config, 'align.action', 'center');
	        var padding;
	        if (innerSizer.orientation === 0) {
	            padding = {
	                top: GetValue$16(config, 'space.actionTop', 0),
	                bottom: GetValue$16(config, 'space.actionBottom', 0),
	                right: GetValue$16(config, 'space.actionRight', 0),
	            };
	        } else {
	            padding = {
	                left: GetValue$16(config, 'space.actionLeft', 0),
	                right: GetValue$16(config, 'space.actionRight', 0),
	                bottom: GetValue$16(config, 'space.actionBottom', 0),
	            };
	        }
	        var fitRatio = GetValue$16(config, 'squareFitAction', false) ? 1 : 0;

	        innerSizer.add(
	            action,
	            { proportion: 0, align: align, padding: padding, fitRatio: fitRatio }
	        );

	        if (actionMask) {
	            actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
	        }

	        if (!fitRatio) {
	            var actionSize = GetValue$16(config, 'actionSize');
	            this.setActionSize(
	                GetValue$16(config, 'actionWidth', actionSize),
	                GetValue$16(config, 'actionHeight', actionSize)
	            );
	        }
	    }

	    this.addChildrenMap('title', title);
	    this.addChildrenMap('separator', separator);
	    this.addChildrenMap('innerSizer', innerSizer);
	    this.addChildrenMap('innerBackground', innerBackground);
	    this.addChildrenMap('icon', icon);
	    this.addChildrenMap('iconMask', iconMask);
	    this.addChildrenMap('text', text);
	    this.addChildrenMap('action', action);
	    this.addChildrenMap('actionMask', actionMask);
	};

	var RE_ASCII = /^[\x00-\x7F]+$/;
	var IsASCIIString = function (s) {
	    return RE_ASCII.test(s);
	};

	var TextWrapByCharCallback = function (text, textObject) {
	    var output = [];

	    var textLines = text.split('\n');
	    var style = textObject.style;
	    var wrapWidth = style.wordWrapWidth;
	    var wrapMode = (style.hasOwnProperty('wrapMode')) ? style.wrapMode : 3;
	    var context = textObject.context;
	    for (var i = 0, cnt = textLines.length; i < cnt; i++) {
	        WrapLine(context, textLines[i], wrapWidth, wrapMode, output);
	    }

	    return output;
	};

	var GetTokenArray = function (text, wrapMode) {
	    var tokenArray;

	    if (wrapMode === 2) {  // CHAR_WRAP
	        tokenArray = text.split('');
	    } else {  // MIX_WRAP
	        tokenArray = [];
	        var words = text.split(' '), word;
	        for (var i = 0, wordCount = words.length; i < wordCount; i++) {
	            word = words[i];

	            if (i < (wordCount - 1)) {
	                if (IsASCIIString(word)) {
	                    tokenArray.push(word + ' ');
	                } else {
	                    tokenArray.push(...word.split(''));
	                    // Add space as last token
	                    tokenArray.push(' ');
	                }

	            } else {  // The last word
	                if (word !== '') {
	                    if (IsASCIIString(word)) {
	                        tokenArray.push(word);
	                    } else {
	                        tokenArray.push(...word.split(''));
	                    }
	                }

	            }

	        }
	    }

	    return tokenArray;
	};

	var WrapLine = function (context, text, wrapWidth, wrapMode, output) {
	    if (text.length <= 100) {
	        var textWidth = context.measureText(text).width;
	        if (textWidth <= wrapWidth) {
	            output.push(text);
	            return output;
	        }
	    }

	    var tokenArray = GetTokenArray(text, wrapMode);

	    var token, tokenWidth;
	    var line = [], remainderLineWidth = wrapWidth;
	    for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
	        token = tokenArray[j];
	        tokenWidth = context.measureText(token).width;

	        remainderLineWidth -= tokenWidth;
	        if (remainderLineWidth < 0) {
	            output.push(line.join(''));
	            line.length = 0;
	            remainderLineWidth = wrapWidth - tokenWidth;
	        }

	        line.push(token);
	    }

	    if (line.length > 0) {
	        output.push(line.join(''));
	    }

	    return output;
	};

	var CONST = {
	    // new line mode
	    NO_NEWLINE: 0,
	    RAW_NEWLINE: 1,
	    WRAPPED_NEWLINE: 2,

	    // wrap mode
	    NO_WRAP: 0,
	    WORD_WRAP: 1,
	    CHAR_WRAP: 2,
	    MIX_WRAP: 3,

	    // split lines
	    SPLITREGEXP: /(?:\r\n|\r|\n)/
	};

	const WRAPMODE$1 = {
	    none: CONST.NO_WRAP,
	    word: CONST.WORD_WRAP,
	    char: CONST.CHAR_WRAP,
	    character: CONST.CHAR_WRAP,
	    mix: CONST.MIX_WRAP
	};

	var SetWrapMode = function (textObject, mode) {
	    var textObjectType = GetTextObjectType(textObject);
	    switch (textObjectType) {
	        case TextType:
	            if (typeof mode === 'string') {
	                mode = WRAPMODE$1[mode] || 0;
	            }

	            textObject.style.wrapMode = mode;
	            switch (mode) {
	                case 2:  // CHAR_WRAP
	                case 3:  // MIX_WRAP
	                    textObject.style.wordWrapCallback = TextWrapByCharCallback;
	                    break;

	                case 1:  // WORD_WRAP
	                default:  // NO_WRAP
	                    textObject.style.wordWrapCallback = null;
	                    break;
	            }

	            break;

	        case TagTextType:
	            if (typeof mode === 'string') {
	                mode = WRAPMODE$1[mode] || 0;
	            }
	            textObject.style.wrapMode = mode;
	            break;


	    }
	};

	// copy from Phaser.GameObjects.Text

	const Utils$1 = Phaser.Renderer.WebGL.Utils;

	var WebGLRenderer$1 = function (renderer, src, camera, parentMatrix) {
	    if (src.dirty) {
	        src.updateTexture();
	        src.dirty = false;
	    }

	    if ((src.width === 0) || (src.height === 0)) {
	        return;
	    }

	    camera.addToRenderList(src);

	    var frame = src.frame;
	    var width = frame.width;
	    var height = frame.height;
	    var getTint = Utils$1.getTintAppendFloatAlpha;
	    var pipeline = renderer.pipelines.set(src.pipeline, src);
	    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);

	    renderer.pipelines.preBatch(src);

	    pipeline.batchTexture(
	        src,
	        frame.glTexture,
	        width, height,
	        src.x, src.y,
	        width / src.resolution, height / src.resolution,
	        src.scaleX, src.scaleY,
	        src.rotation,
	        src.flipX, src.flipY,
	        src.scrollFactorX, src.scrollFactorY,
	        src.displayOriginX, src.displayOriginY,
	        0, 0, width, height,
	        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
	        getTint(src.tintTopRight, camera.alpha * src._alphaTR),
	        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
	        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
	        src.tintFill,
	        0, 0,
	        camera,
	        parentMatrix,
	        false,
	        textureUnit
	    );

	    renderer.pipelines.postBatch(src);
	};

	// copy from Phaser.GameObjects.Text

	var CanvasRenderer$1 = function (renderer, src, camera, parentMatrix) {
	    if (src.dirty) {
	        src.updateTexture();
	        src.dirty = false;
	    }

	    if ((src.width === 0) || (src.height === 0)) {
	        return;
	    }

	    camera.addToRenderList(src);

	    renderer.batchSprite(src, src.frame, camera, parentMatrix);
	};

	var Render$2 = {
	    renderWebGL: WebGLRenderer$1,
	    renderCanvas: CanvasRenderer$1

	};

	const Color = Phaser.Display.Color;

	var CanvasMethods = {
	    clear() {
	        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	        this.dirty = true;
	        return this;
	    },

	    fill(color) {
	        this.context.fillStyle = color;
	        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
	        this.dirty = true;
	        return this;
	    },

	    drawFrame(key, frame, dx, dy, dWidth, dHeight, sxOffset, syOffset, sWidth, sHeight) {

	        var textureFrame = this.scene.sys.textures.getFrame(key, frame);
	        if (!textureFrame) {
	            return this;
	        }

	        var frameWidth = textureFrame.cutWidth,
	            frameHeight = textureFrame.cutHeight;

	        if (dx === undefined) { dx = 0; }
	        if (dy === undefined) { dy = 0; }
	        if (dWidth === undefined) { dWidth = frameWidth; }
	        if (dHeight === undefined) { dHeight = frameHeight; }
	        if (sxOffset === undefined) { sxOffset = 0; }
	        if (syOffset === undefined) { syOffset = 0; }
	        if (sWidth === undefined) { sWidth = frameWidth; }
	        if (sHeight === undefined) { sHeight = frameHeight; }

	        var sx = textureFrame.cutX + sxOffset;
	        var sy = textureFrame.cutY + syOffset;

	        this.context.drawImage(
	            textureFrame.source.image,  // image
	            sx, sy, sWidth, sHeight,
	            dx, dy, dWidth, dHeight
	        );

	        this.dirty = true;

	        return this;
	    },

	    getDataURL(type, encoderOptions) {
	        return this.canvas.toDataURL(type, encoderOptions);
	    },

	    getPixel(x, y, out) {
	        if (out === undefined) {
	            out = new Color();
	        }
	        var rgb = this.context.getImageData(x, y, 1, 1);
	        out.setTo(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
	        return out;
	    },

	    setPixel(x, y, r, g, b, a) {
	        if (typeof (r) !== 'number') {
	            var color = r;
	            r = color.red;
	            g = color.green;
	            b = color.blue;
	            a = color.alpha;
	        }

	        if (a === undefined) {
	            a = ((r !== 0) || (g !== 0) || (b !== 0)) ? 255 : 0;
	        }

	        var imgData = this.context.createImageData(1, 1);
	        imgData.data[0] = r;
	        imgData.data[1] = g;
	        imgData.data[2] = b;
	        imgData.data[3] = a;
	        this.context.putImageData(imgData, x, y);
	        this.dirty = true;
	        return this;
	    }
	};

	var CopyCanvasToTexture = function (scene, srcCanvas, key, x, y, width, height) {
	    var textures = scene.sys.textures;
	    var renderer = scene.renderer;

	    if (x === undefined) {
	        x = 0;
	    }
	    if (y === undefined) {
	        y = 0;
	    }
	    if (width === undefined) {
	        width = srcCanvas.width;
	    }
	    if (height === undefined) {
	        height = srcCanvas.height;
	    }

	    var texture;
	    if (textures.exists(key)) {
	        texture = textures.get(key);
	    } else {
	        texture = textures.createCanvas(key, width, height);
	    }

	    var destCanvas = texture.getSourceImage();
	    if (destCanvas.width !== width) {
	        destCanvas.width = width;
	    }
	    if (destCanvas.height !== height) {
	        destCanvas.height = height;
	    }

	    var destCtx = destCanvas.getContext('2d', { willReadFrequently: true });
	    destCtx.clearRect(0, 0, width, height);
	    destCtx.drawImage(srcCanvas, x, y, width, height);
	    if (renderer.gl && texture) {
	        renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);
	    }
	};

	var TextureMethods = {
	    updateTexture(callback, scope) {
	        if (callback) {
	            var scale = this.resolution;
	            if (scale !== 1) {
	                this.context.save();
	                this.context.scale(scale, scale);
	            }

	            if (scope) {
	                callback.call(scope, this.canvas, this.context);
	            } else {
	                callback(this.canvas, this.context);
	            }

	            if (scale !== 1) {
	                this.context.restore();
	            }
	        }

	        if ((this.canvas.width !== this.frame.width) || (this.canvas.height !== this.frame.height)) {
	            this.frame.setSize(this.canvas.width, this.canvas.height);
	        }
	        if (this.renderer && this.renderer.gl) {
	            this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);
	            if (typeof WEBGL_DEBUG) {
	                this.frame.glTexture.spectorMetadata = { textureKey: 'Canvas Game Object' };
	            }
	        }
	        this.dirty = false;

	        var input = this.input;
	        if (input && !input.customHitArea) {
	            input.hitArea.width = this.width;
	            input.hitArea.height = this.height;
	        }
	        return this;
	    },

	    generateTexture(key, x, y, width, height) {
	        var srcCanvas = this.canvas;
	        if (width === undefined) {
	            width = srcCanvas.width;
	        } else {
	            width *= this.resolution;
	        }
	        if (height === undefined) {
	            height = srcCanvas.height;
	        } else {
	            height *= this.resolution;
	        }

	        CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);

	        return this;
	    },

	    loadTexture(key, frame) {
	        var textureFrame = this.scene.sys.textures.getFrame(key, frame);
	        if (!textureFrame) {
	            return this;
	        }

	        if ((this.width !== textureFrame.cutWidth) || (this.height !== textureFrame.cutHeight)) {
	            this.setSize(textureFrame.cutWidth, textureFrame.cutHeight);
	        } else {
	            this.clear();
	        }

	        this.drawFrame(key, frame);
	        this.dirty = true;
	        return this;
	    }

	};

	CheckP3Version();

	const CanvasPool$4 = Phaser.Display.Canvas.CanvasPool;
	const GameObject$3 = Phaser.GameObjects.GameObject;
	const UUID$2 = Phaser.Utils.String.UUID;

	class Canvas extends GameObject$3 {
	    constructor(scene, x, y, width, height, resolution) {
	        if (x === undefined) {
	            x = 0;
	        }
	        if (y === undefined) {
	            y = 0;
	        }
	        if (width === undefined) {
	            width = 1;
	        }
	        if (height === undefined) {
	            height = 1;
	        }
	        if (resolution === undefined) {
	            resolution = 1;
	        }

	        super(scene, 'rexCanvas');

	        this.renderer = scene.sys.game.renderer;

	        this._width = width;
	        this._height = height;
	        this.resolution = resolution;

	        width = Math.max(Math.ceil(width * this.resolution), 1);
	        height = Math.max(Math.ceil(height * this.resolution), 1);
	        this.canvas = CanvasPool$4.create(this, width, height);
	        this.context = this.canvas.getContext('2d', { willReadFrequently: true });

	        this.dirty = false;

	        this.setPosition(x, y);
	        this.setOrigin(0.5, 0.5);
	        this.initPipeline();
	        this.initPostPipeline(true);

	        this._crop = this.resetCropObject();

	        //  Create a Texture for this Text object
	        this._textureKey = UUID$2();

	        this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);

	        //  Get the frame
	        this.frame = this.texture.get();

	        //  Set the resolution
	        this.frame.source.resolution = this.resolution;

	        if (this.renderer && this.renderer.gl) {
	            //  Clear the default 1x1 glTexture, as we override it later
	            this.renderer.deleteTexture(this.frame.source.glTexture);
	            this.frame.source.glTexture = null;
	        }

	        this.dirty = true;
	    }

	    preDestroy() {
	        CanvasPool$4.remove(this.canvas);

	        this.canvas = null;
	        this.context = null;

	        var texture = this.texture;

	        if (texture) {
	            texture.destroy();
	        }
	    }

	    setResolution(resolution) {
	        if (this.resolution === resolution) {
	            return this;
	        }

	        this.resolution = resolution;

	        var width = Math.max(Math.ceil(this.width * resolution), 1);
	        var height = Math.max(Math.ceil(this.height * resolution), 1);
	        this.canvas.width = width;
	        this.canvas.height = height;

	        this.frame.source.resolution = resolution;
	        this.dirty = true;

	        return this;
	    }

	    get width() {
	        return this._width;
	    }

	    set width(value) {
	        this.setSize(value, this._height);
	    }

	    get height() {
	        return this._height;
	    }

	    set height(value) {
	        this.setSize(this._width, value);
	    }

	    setCanvasSize(width, height) {
	        if ((this._width === width) && (this._height === height)) {
	            return this;
	        }

	        this._width = width;
	        this._height = height;

	        this.updateDisplayOrigin();

	        width = Math.max(Math.ceil(width * this.resolution), 1);
	        height = Math.max(Math.ceil(height * this.resolution), 1);
	        this.canvas.width = width;
	        this.canvas.height = height;

	        this.frame.setSize(width, height);

	        this.dirty = true;
	        return this;
	    }

	    // setSize might be override
	    setSize(width, height) {
	        this.setCanvasSize(width, height);
	        return this;
	    }

	    get displayWidth() {
	        return this.scaleX * this._width;
	    }

	    set displayWidth(value) {
	        this.scaleX = value / this._width;
	    }

	    get displayHeight() {
	        return this.scaleY * this._height;
	    }

	    set displayHeight(value) {
	        this.scaleY = value / this._height;
	    }

	    setDisplaySize(width, height) {
	        this.displayWidth = width;
	        this.displayHeight = height;
	        return this;
	    }

	    getCanvas(readOnly) {
	        if (!readOnly) {
	            this.dirty = true;
	        }
	        return this.canvas;
	    }

	    getContext(readOnly) {
	        if (!readOnly) {
	            this.dirty = true;
	        }
	        return this.context;
	    }

	    needRedraw() {
	        this.dirty = true;
	        return this;
	    }

	    resize(width, height) {
	        this.setSize(width, height);
	        return this;
	    }
	}

	const Components$2 = Phaser.GameObjects.Components;
	Phaser.Class.mixin(Canvas,
	    [
	        Components$2.Alpha,
	        Components$2.BlendMode,
	        Components$2.Crop,
	        Components$2.Depth,
	        Components$2.Flip,
	        Components$2.GetBounds,
	        Components$2.Mask,
	        Components$2.Origin,
	        Components$2.Pipeline,
	        Components$2.PostPipeline,
	        Components$2.ScrollFactor,
	        Components$2.Tint,
	        Components$2.Transform,
	        Components$2.Visible,
	        Render$2,
	        CanvasMethods,
	        TextureMethods,
	    ]
	);

	let Base$1 = class Base {
	    constructor(parent, type) {
	        this.setParent(parent);
	        this.type = type;
	        this.renderable = false;

	        this.reset().setActive();
	    }

	    destroy() {
	        this.parent.removeChild(this);
	    }

	    setParent(parent) {
	        this.parent = parent;
	        return this;
	    }

	    get scene() {
	        return this.parent.scene;
	    }

	    get canvas() {
	        return (this.parent) ? this.parent.canvas : null;
	    }

	    get context() {
	        return (this.parent) ? this.parent.context : null;
	    }

	    setDirty(dirty) {
	        if (dirty && this.parent) {
	            this.parent.dirty = true;
	        }
	        return this;
	    }

	    get active() {
	        return this._active;
	    }

	    set active(value) {
	        this.setDirty(this._active != value);
	        this._active = value;
	    }

	    setActive(active) {
	        if (active === undefined) {
	            active = true;
	        }
	        this.active = active;
	        return this;
	    }

	    modifyPorperties(o) {
	        return this;
	    }

	    // Override
	    onFree() {
	        this.reset().setParent();
	    }

	    // Override
	    reset() {
	        return this;
	    }

	    // Override
	    render() { }

	    // Override
	    contains(x, y) {
	        return false;
	    }
	};

	Object.assign(
	    Base$1.prototype,
	    DataMethods
	);

	var RenderMethods = {
	    // Override
	    renderContent() {

	    },

	    // Override
	    render() {
	        if (!this.willRender) {
	            return this;
	        }

	        var context = this.context;
	        context.save();
	        context.globalAlpha = this.alpha;

	        if (this.toLocalPosition) {
	            var x = this.drawX, y = this.drawY;
	            if (this.autoRound) {
	                x = Math.round(x);
	                y = Math.round(y);
	            }

	            context.translate(x, y);
	            context.scale(this.scaleX, this.scaleY);
	            context.rotate(this.rotation);
	        }

	        if (this.drawBelowCallback) {
	            this.drawBelowCallback(this);
	        }

	        this.renderContent();

	        if (this.drawAboveCallback) {
	            this.drawAboveCallback(this);
	        }

	        context.restore();

	        return this;
	    },
	};

	const RotateAround$1 = Phaser.Math.RotateAround;

	var CanvasPositionToBobPosition = function (canvasX, canvasY, bob, out) {
	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        if (globPoint$1 === undefined) {
	            globPoint$1 = {};
	        }
	        out = globPoint$1;
	    }

	    out.x = (canvasX - bob.drawX) / bob.scaleX;
	    out.y = (canvasY - bob.drawY) / bob.scaleY;

	    if (bob.rotation !== 0) {
	        RotateAround$1(out, 0, 0, -bob.rotation);
	    }
	    return out;
	};

	var globPoint$1;

	const Rectangle$1 = Phaser.Geom.Rectangle;

	var Contains$1 = function (canvasX, canvasY) {
	    if ((this.width === 0) || (this.height === 0)) {
	        return false;
	    }

	    var bobPosition = CanvasPositionToBobPosition(canvasX, canvasY, this, true);
	    return GetBobBounds(this).contains(bobPosition.x, bobPosition.y);
	};

	var GetBobBounds = function (bob) {
	    if (bobBounds === undefined) {
	        bobBounds = new Rectangle$1();
	    }

	    var x = bob.drawTLX,
	        y = bob.drawTLY;
	    bobBounds.setTo(x, y, (bob.drawTRX - x), (bob.drawBLY - y));

	    return bobBounds;
	};

	var bobBounds;

	const RotateAround = Phaser.Math.RotateAround;

	var BobPositionToCanvasPosition = function (bob, bobX, bobY, out) {
	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        if (globPoint === undefined) {
	            globPoint = {};
	        }
	        out = globPoint;
	    }

	    out.x = bobX;
	    out.y = bobY;

	    if (bob.rotation !== 0) {
	        RotateAround(out, 0, 0, bob.rotation);
	    }

	    out.x = (out.x * bob.scaleX) + bob.drawX;
	    out.y = (out.y * bob.scaleY) + bob.drawY;

	    return out;
	};

	var globPoint;

	const TransformMatrix = Phaser.GameObjects.Components.TransformMatrix;

	var GameObjectLocalXYToWorldXY = function (gameObject, localX, localY, out) {
	    if (out === undefined) {
	        out = {};
	    } else if (out === true) {
	        out = globOut;
	    }

	    var px = localX - (gameObject.width * gameObject.originX);
	    var py = localY - (gameObject.height * gameObject.originY);

	    if (tempMatrix === undefined) {
	        tempMatrix = new TransformMatrix();
	        parentMatrix = new TransformMatrix();
	    }

	    if (gameObject.parentContainer) {
	        gameObject.getWorldTransformMatrix(tempMatrix, parentMatrix);
	    }
	    else {
	        tempMatrix.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY);
	    }

	    tempMatrix.transformPoint(px, py, out);

	    return out;
	};

	var tempMatrix, parentMatrix;
	var globOut = {};

	var BobPositionToWorldPosition = function (dynamicText, bob, bobX, bobY, out) {
	    var localXY = BobPositionToCanvasPosition(bob, bobX, bobY, true);
	    var worldXY = GameObjectLocalXYToWorldXY(dynamicText, localXY.x, localXY.y, out);
	    return worldXY;
	};

	var GetBobWorldPosition = function (dynamicText, bob, offsetX, offsetY, out) {
	    if (typeof (offsetX) !== 'number') {
	        out = offsetX;
	        offsetX = 0;
	        offsetY = 0;
	    }
	    var bobX = bob.drawCenterX + offsetX;
	    var bobY = bob.drawCenterY + offsetY;
	    return BobPositionToWorldPosition(dynamicText, bob, bobX, bobY, out);
	};

	var GetWorldPosition = function (offsetX, offsetY, out) {
	    return GetBobWorldPosition(this.parent, this, offsetX, offsetY, out);
	};

	var Methods$9 = {
	    contains: Contains$1,
	    getWorldPosition: GetWorldPosition,
	};

	Object.assign(
	    Methods$9,
	    RenderMethods
	);

	const DegToRad$3 = Phaser.Math.DegToRad;
	const RadToDeg$1 = Phaser.Math.RadToDeg;
	const GetValue$15 = Phaser.Utils.Objects.GetValue;

	class RenderBase extends Base$1 {
	    constructor(parent, type) {
	        super(parent, type);

	        this.renderable = true;
	        this.scrollFactorX = 1;
	        this.scrollFactorY = 1;
	        this.toLocalPosition = true;
	        this.originX = 0;
	        this.offsetX = 0;  // Override
	        this.offsetY = 0;  // Override
	    }

	    get visible() {
	        return this._visible;
	    }

	    set visible(value) {
	        this.setDirty(this._visible != value);
	        this._visible = value;
	    }

	    setVisible(visible) {
	        if (visible === undefined) {
	            visible = true;
	        }

	        this.visible = visible;
	        return this;
	    }

	    get alpha() { return this._alpha; }

	    set alpha(value) {
	        this.setDirty(this._alpha != value);
	        this._alpha = value;
	    }

	    setAlpha(alpha) {
	        this.alpha = alpha;
	        return this;
	    }

	    get x() { return this._x; }

	    set x(value) {
	        this.setDirty(this._x != value);
	        this._x = value;
	    }

	    setX(x) {
	        this.x = x;
	        return this;
	    }

	    get y() { return this._y; }

	    set y(value) {
	        this.setDirty(this._y != value);
	        this._y = value;
	    }

	    setY(y) {
	        this.y = y;
	        return this;
	    }

	    setPosition(x, y) {
	        this.x = x;
	        this.y = y;
	        return this;
	    }

	    setInitialPosition(x, y) {
	        this.x0 = x;
	        this.y0 = y;
	        return this;
	    }

	    setScrollFactorX(x) {
	        this.scrollFactorX = x;
	        return this;
	    }

	    setScrollFactorY(y) {
	        this.scrollFactorY = y;
	        return this;
	    }

	    setScrollFactor(x, y) {
	        if (y === undefined) {
	            y = x;
	        }
	        this.scrollFactorX = x;
	        this.scrollFactorY = y;
	        return this;
	    }

	    get rotation() { return this._rotation; }

	    set rotation(value) {
	        this.setDirty(this._rotation != value);
	        this._rotation = value;
	    }

	    setRotation(rotation) {
	        this.rotation = rotation;
	        return this;
	    }

	    get angle() { return RadToDeg$1(this._rotation); }

	    set angle(value) {
	        this.rotation = DegToRad$3(value);
	    }

	    setAngle(angle) {
	        this.angle = angle;
	        return this;
	    }

	    get scaleX() { return this._scaleX; }

	    set scaleX(value) {
	        this.setDirty(this._scaleX !== value);
	        this._scaleX = value;
	    }

	    setScaleX(scaleX) {
	        this.scaleX = scaleX;
	        return this;
	    }

	    // Override
	    get width() { return 0; }

	    // Override
	    set width(value) { }

	    setWidth(width, keepAspectRatio) {
	        if (keepAspectRatio === undefined) {
	            keepAspectRatio = false;
	        }
	        this.width = width;

	        if (keepAspectRatio) {
	            this.scaleY = this.scaleX;
	        }
	        return this;
	    }

	    get leftSpace() { return this._leftSpace; }

	    set leftSpace(value) {
	        this.setDirty(this._leftSpace !== value);
	        this._leftSpace = value;
	    }

	    setLeftSpace(value) {
	        this.leftSpace = value;
	        return this;
	    }

	    get rightSpace() { return this._rightSpace; }

	    set rightSpace(value) {
	        this.setDirty(this._rightSpace !== value);
	        this._rightSpace = value;
	    }

	    setRightSpace(value) {
	        this.rightSpace = value;
	        return this;
	    }

	    get outerWidth() {
	        return this.width + this.leftSpace + this.rightSpace;
	    }

	    get scaleY() { return this._scaleY; }

	    set scaleY(value) {
	        this.setDirty(this._scaleY !== value);
	        this._scaleY = value;
	    }

	    setScaleY(scaleY) {
	        this.scaleY = scaleY;
	        return this;
	    }

	    // Override
	    get height() { return 0; }

	    // Override
	    set height(value) { }

	    setHeight(height, keepAspectRatio) {
	        if (keepAspectRatio === undefined) {
	            keepAspectRatio = false;
	        }
	        this.height = height;

	        if (keepAspectRatio) {
	            this.scaleX = this.scaleY;
	        }
	        return this;
	    }

	    setScale(scaleX, scaleY) {
	        if (scaleY === undefined) {
	            scaleY = scaleX;
	        }

	        this.scaleX = scaleX;
	        this.scaleY = scaleY;
	        return this;
	    }

	    setOrigin(x) {
	        this.originX = x;
	        return this;
	    }

	    setAlign(align) {
	        this.align = align;
	        return this;
	    }

	    modifyPorperties(o) {
	        if (!o) {
	            return this;
	        }

	        if (o.hasOwnProperty('x')) {
	            this.setX(o.x);
	        }
	        if (o.hasOwnProperty('y')) {
	            this.setY(o.y);
	        }

	        if (o.hasOwnProperty('rotation')) {
	            this.setRotation(o.rotation);
	        } else if (o.hasOwnProperty('angle')) {
	            this.setAngle(o.angle);
	        }

	        if (o.hasOwnProperty('alpha')) {
	            this.setAlpha(o.alpha);
	        }

	        // ScaleX, ScaleY
	        var width = GetValue$15(o, 'width', undefined);
	        var height = GetValue$15(o, 'height', undefined);
	        var scaleX = GetValue$15(o, 'scaleX', undefined);
	        var scaleY = GetValue$15(o, 'scaleY', undefined);

	        if (width !== undefined) {
	            if ((height === undefined) && (scaleY === undefined)) {
	                this.setWidth(width, true);
	            } else {
	                this.setWidth(width);
	            }
	        } else if (scaleX !== undefined) {
	            this.setScaleX(scaleX);
	        }
	        if (height !== undefined) {
	            if ((width === undefined) && (scaleX === undefined)) {
	                this.setHeight(height, true);
	            } else {
	                this.setHeight(height);
	            }
	        } else if (scaleY !== undefined) {
	            this.setScaleY(scaleY);
	        }

	        if (o.hasOwnProperty('leftSpace')) {
	            this.setLeftSpace(o.leftSpace);
	        }
	        if (o.hasOwnProperty('rightSpace')) {
	            this.setRightSpace(o.rightSpace);
	        }

	        if (o.hasOwnProperty('align')) {
	            this.setAlign(o.align);
	        }

	        return this;
	    }

	    setDrawBelowCallback(callback) {
	        this.drawBelowCallback = callback;
	        return this;
	    }

	    setDrawAboveCallback(callback) {
	        this.drawAboveCallback = callback;
	        return this;
	    }

	    reset() {
	        this
	            .setVisible()
	            .setAlpha(1)
	            .setPosition(0, 0)
	            .setRotation(0)
	            .setScale(1, 1)
	            .setLeftSpace(0).setRightSpace(0)
	            .setOrigin(0)
	            .setAlign()
	            .setDrawBelowCallback()
	            .setDrawAboveCallback();
	        return this;
	    }

	    // Override
	    get willRender() {
	        return this.visible && (this.alpha > 0);
	    }

	    get drawX() {
	        var x = this.x + this.leftSpace + this.offsetX - (this.originX * this.width);
	        return (this.parent._textOX * this.scrollFactorX) + x;
	    }
	    get drawY() {
	        var y = this.y + this.offsetY;
	        return (this.parent._textOY * this.scrollFactorY) + y;
	    }

	    // Override
	    get drawTLX() { return 0; }
	    get drawTLY() { return 0; }
	    get drawBLX() { return 0; }
	    get drawBLY() { return 0; }
	    get drawTRX() { return 0; }
	    get drawTRY() { return 0; }
	    get drawBRX() { return 0; }
	    get drawBRY() { return 0; }

	    get drawCenterX() {
	        return (this.drawTRX + this.drawTLX) / 2;
	    }
	    get drawCenterY() {
	        return (this.drawBLY + this.drawTLY) / 2;
	    }
	}

	Object.assign(
	    RenderBase.prototype,
	    Methods$9,
	);

	const Pad = Phaser.Utils.String.Pad;
	var GetStyle = function (style, canvas, context) {
	    if (style == null) {
	        return style;
	    }

	    switch (typeof (style)) {
	        case 'string': return style;
	        case 'number': return `#${Pad(Math.floor(style).toString(16), 6, '0', 1)}`;
	        case 'function': return style(canvas, context);
	        case 'object':
	            if (style.hasOwnProperty('r')) {
	                if (style.hasOwnProperty('a')) {  // rgba
	                    return `rgba(${style.r},${style.g},${style.b},${style.a})`;
	                } else {  // rgb
	                    return `rgb(${style.r},${style.g},${style.b})`;
	                }
	            } else if (style.hasOwnProperty('h')) {
	                if (style.hasOwnProperty('a')) {  // hsla
	                    return `hsla(${style.h},${style.s},${style.l},${style.a})`;
	                } else {  // hsl
	                    return `hsl(${style.h},${style.s},${style.l})`;
	                }
	            } else {
	                return style; // Not a valid input
	            }
	        default: return style;
	    }
	};

	var GetProperty = function (name, config, defaultConfig) {
	    if (config.hasOwnProperty(name)) {
	        return config[name];
	    } else {
	        return defaultConfig[name];
	    }
	};

	const GetValue$14 = Phaser.Utils.Objects.GetValue;

	let RoundRectangle$1 = class RoundRectangle {
	    constructor(x, y, width, height, radiusConfig) {
	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = x; }
	        if (width === undefined) { width = 0; }
	        if (height === undefined) { height = 0; }
	        if (radiusConfig === undefined) { radiusConfig = 0; }

	        this.cornerRadius = {};
	        this._width = 0;
	        this._height = 0;
	        this.setTo(x, y, width, height, radiusConfig);
	    }

	    setTo(x, y, width, height, radiusConfig) {
	        this.setPosition(x, y);
	        this.setRadius(radiusConfig);
	        this.setSize(width, height);
	        return this;
	    }

	    setPosition(x, y) {
	        this.x = x;
	        this.y = y;
	        return this;
	    }

	    setRadius(value) {
	        if (value === undefined) {
	            value = 0;
	        }
	        this.radius = value;
	        return this;
	    }

	    setSize(width, height) {
	        this.width = width;
	        this.height = height;
	        return this;
	    }

	    get minWidth() {
	        var radius = this.cornerRadius;
	        return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
	    }

	    get minHeight() {
	        var radius = this.cornerRadius;
	        return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
	    }

	    get width() {
	        return this._width;
	    }

	    set width(value) {
	        if (value == null) {
	            value = 0;
	        }
	        this._width = Math.max(value, this.minWidth);
	    }

	    get height() {
	        return this._height;
	    }

	    set height(value) {
	        if (value == null) {
	            value = 0;
	        }
	        this._height = Math.max(value, this.minHeight);
	    }

	    get radius() {
	        var radius = this.cornerRadius;
	        return Math.max(
	            radius.tl.x, radius.tl.y,
	            radius.tr.x, radius.tr.y,
	            radius.bl.x, radius.bl.y,
	            radius.br.x, radius.br.y
	        );
	    }

	    set radius(value) {
	        var defaultRadiusX, defaultRadiusY;
	        if (typeof (value) === 'number') {
	            defaultRadiusX = value;
	            defaultRadiusY = value;
	        } else {
	            defaultRadiusX = GetValue$14(value, 'x', 0);
	            defaultRadiusY = GetValue$14(value, 'y', 0);
	        }

	        var radius = this.cornerRadius;
	        radius.tl = GetRadius(GetValue$14(value, 'tl', undefined), defaultRadiusX, defaultRadiusY);
	        radius.tr = GetRadius(GetValue$14(value, 'tr', undefined), defaultRadiusX, defaultRadiusY);
	        radius.bl = GetRadius(GetValue$14(value, 'bl', undefined), defaultRadiusX, defaultRadiusY);
	        radius.br = GetRadius(GetValue$14(value, 'br', undefined), defaultRadiusX, defaultRadiusY);
	    }

	    get radiusTL() {
	        var radius = this.cornerRadius.tl;
	        return Math.max(radius.x, radius.y);
	    }

	    set radiusTL(value) {
	        SetRadius(this.cornerRadius.tl, value);
	    }

	    get radiusTR() {
	        var radius = this.cornerRadius.tr;
	        return Math.max(radius.x, radius.y);
	    }

	    set radiusTR(value) {
	        SetRadius(this.cornerRadius.tr, value);
	    }

	    get radiusBL() {
	        var radius = this.cornerRadius.bl;
	        return Math.max(radius.x, radius.y);
	    }

	    set radiusBL(value) {
	        SetRadius(this.cornerRadius.bl, value);
	    }

	    get radiusBR() {
	        var radius = this.cornerRadius.br;
	        return Math.max(radius.x, radius.y);
	    }

	    set radiusBR(value) {
	        SetRadius(this.cornerRadius.br, value);
	    }
	};

	var GetRadius = function (radius, defaultRadiusX, defaultRadiusY) {
	    if (radius === undefined) {
	        radius = {
	            x: defaultRadiusX,
	            y: defaultRadiusY
	        };
	    } else if (typeof (radius) === 'number') {
	        radius = {
	            x: radius,
	            y: radius
	        };
	    }

	    SetConvex(radius);
	    return radius;

	};

	var SetRadius = function (radius, value) {
	    if (typeof (value) === 'number') {
	        radius.x = value;
	        radius.y = value;
	    } else {
	        radius.x = GetValue$14(value, 'x', 0);
	        radius.y = GetValue$14(value, 'y', 0);
	    }

	    SetConvex(radius);
	};

	var SetConvex = function (radius) {
	    radius.convex = (radius.x >= 0) || (radius.y >= 0);

	    radius.x = Math.abs(radius.x);
	    radius.y = Math.abs(radius.y);
	};

	const DegToRad$2 = Phaser.Math.DegToRad;

	var AddRoundRectanglePath = function (context, x, y, width, height, radiusConfig, iteration) {
	    var geom = new RoundRectangle$1(x, y, width, height, radiusConfig),
	        minWidth = geom.minWidth,
	        minHeight = geom.minHeight,
	        scaleRX = (width >= minWidth) ? 1 : (width / minWidth),
	        scaleRY = (height >= minHeight) ? 1 : (height / minHeight);

	    var cornerRadius = geom.cornerRadius;
	    var radius, radiusX, radiusY, centerX, centerY;
	    var startX, startY;

	    context.save();
	    context.beginPath();

	    context.translate(x, y);

	    // Top-left
	    radius = cornerRadius.tl;
	    if (IsArcCorner$1(radius)) {
	        radiusX = radius.x * scaleRX;
	        radiusY = radius.y * scaleRY;
	        if (IsConvexArc(radius)) {
	            centerX = radiusX;
	            centerY = radiusY;
	            ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 270, false, iteration);
	        } else {
	            centerX = 0;
	            centerY = 0;
	            ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 0, true, iteration);
	        }

	        startX = 0;
	        startY = radiusY;
	    } else {
	        context.lineTo(0, 0);

	        startX = 0;
	        startY = 0;
	    }

	    // Top-right
	    radius = cornerRadius.tr;
	    if (IsArcCorner$1(radius)) {
	        radiusX = radius.x * scaleRX;
	        radiusY = radius.y * scaleRY;
	        if (IsConvexArc(radius)) {
	            centerX = width - radiusX;
	            centerY = radiusY;
	            ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 360, false, iteration);
	        } else {
	            centerX = width;
	            centerY = 0;
	            ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 90, true, iteration);
	        }
	    } else {
	        context.lineTo(width, 0);
	    }

	    // Bottom-right
	    radius = cornerRadius.br;
	    if (IsArcCorner$1(radius)) {
	        radiusX = radius.x * scaleRX;
	        radiusY = radius.y * scaleRY;
	        if (IsConvexArc(radius)) {
	            centerX = width - radiusX;
	            centerY = height - radiusY;
	            ArcTo(context, centerX, centerY, radiusX, radiusY, 0, 90, false, iteration);
	        } else {
	            centerX = width;
	            centerY = height;
	            ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 180, true, iteration);
	        }
	    } else {
	        context.lineTo(width, height);
	    }

	    // Bottom-left
	    radius = cornerRadius.bl;
	    if (IsArcCorner$1(radius)) {
	        radiusX = radius.x * scaleRX;
	        radiusY = radius.y * scaleRY;
	        if (IsConvexArc(radius)) {
	            centerX = radiusX;
	            centerY = height - radiusY;
	            ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 180, false, iteration);
	        } else {
	            centerX = 0;
	            centerY = height;
	            ArcTo(context, centerX, centerY, radiusX, radiusY, 360, 270, true, iteration);
	        }
	    } else {
	        context.lineTo(0, height);
	    }

	    context.lineTo(startX, startY);
	    context.closePath();
	    context.restore();
	};

	var IsConvexArc = function (radius) {
	    return (!radius.hasOwnProperty('convex')) ||  // radius does not have convex property
	        radius.convex;
	};

	var IsArcCorner$1 = function (radius) {
	    return ((radius.x > 0) && (radius.y > 0));
	};

	var ArcTo = function (
	    context,
	    centerX, centerY,
	    radiusX, radiusY,
	    startAngle, endAngle,
	    antiClockWise,
	    iteration
	) {

	    // startAngle, endAngle: 0 ~ 360
	    if (antiClockWise && (endAngle > startAngle)) {
	        endAngle -= 360;
	    } else if (!antiClockWise && (endAngle < startAngle)) {
	        endAngle += 360;
	    }

	    startAngle = DegToRad$2(startAngle);
	    endAngle = DegToRad$2(endAngle);

	    if (iteration == null) {  // undefined, or null
	        context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle, antiClockWise);
	    } else {
	        iteration += 1;
	        var x, y, angle;
	        var step = (endAngle - startAngle) / iteration;
	        for (var i = 0; i <= iteration; i++) {
	            angle = startAngle + (step * i);
	            x = centerX + (radiusX * Math.cos(angle));
	            y = centerY + (radiusY * Math.sin(angle));
	            context.lineTo(x, y);
	        }
	    }
	};

	var DrawRoundRectangle = function (
	    canvas, context,
	    x, y,
	    width, height, radiusConfig,
	    fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient,
	    iteration
	) {

	    AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration);

	    if (fillStyle != null) {
	        if (fillColor2 != null) {
	            var grd;
	            if (isHorizontalGradient) {
	                grd = context.createLinearGradient(0, 0, width, 0);
	            } else {
	                grd = context.createLinearGradient(0, 0, 0, height);
	            }
	            grd.addColorStop(0, fillStyle);
	            grd.addColorStop(1, fillColor2);
	            fillStyle = grd;
	        }

	        context.fillStyle = fillStyle;
	        context.fill();
	    }

	    if ((strokeStyle != null) && (lineWidth > 0)) {
	        context.strokeStyle = strokeStyle;
	        context.lineWidth = lineWidth;
	        context.stroke();
	    }
	};

	var DrawRoundRectangleBackground = function (
	    canvasObject,
	    color,
	    strokeColor, strokeLineWidth,
	    radius,
	    color2, isHorizontalGradient,
	    iteration
	) {

	    if ((color == null) && (strokeColor == null)) {
	        return;
	    }

	    var width = canvasObject.canvas.width,
	        height = canvasObject.canvas.height;

	    if (strokeColor == null) {
	        strokeLineWidth = 0;
	    }
	    var x = strokeLineWidth / 2;
	    width = Math.max(1, width - strokeLineWidth);   // Min width is 1
	    height = Math.max(1, height - strokeLineWidth); // Min height is 1
	    DrawRoundRectangle(canvasObject.canvas, canvasObject.context,
	        x, x,
	        width, height,
	        radius,
	        color,
	        strokeColor, strokeLineWidth,
	        color2, isHorizontalGradient,
	        iteration
	    );
	};

	const GetValue$13 = Phaser.Utils.Objects.GetValue;

	class Background extends RenderBase {
	    constructor(parent, config) {
	        super(parent, 'background');

	        this.setScrollFactor(0);

	        this.setColor(
	            GetValue$13(config, 'color', null),
	            GetValue$13(config, 'color2', null),
	            GetValue$13(config, 'horizontalGradient', true)
	        );

	        this.setStroke(
	            GetValue$13(config, 'stroke', null),
	            GetValue$13(config, 'strokeThickness', 2)
	        );

	        this.setCornerRadius(
	            GetValue$13(config, 'cornerRadius', 0),
	            GetValue$13(config, 'cornerIteration', null)
	        );
	    }

	    set color(value) {
	        value = GetStyle(value, this.canvas, this.context);
	        this.setDirty(this._color != value);
	        this._color = value;
	    }

	    get color() {
	        return this._color;
	    }

	    set color2(value) {
	        value = GetStyle(value, this.canvas, this.context);
	        this.setDirty(this._color2 != value);
	        this._color2 = value;
	    }

	    get color2() {
	        return this._color2;
	    }

	    set horizontalGradient(value) {
	        this.setDirty(this._horizontalGradient != value);
	        this._horizontalGradient = value;
	    }

	    get horizontalGradient() {
	        return this._horizontalGradient;
	    }

	    setColor(color, color2, isHorizontalGradient) {
	        if (isHorizontalGradient === undefined) {
	            isHorizontalGradient = true;
	        }

	        this.color = color;
	        this.color2 = color2;
	        this.horizontalGradient = isHorizontalGradient;
	        return this;
	    }

	    set stroke(value) {
	        value = GetStyle(value, this.canvas, this.context);
	        this.setDirty(this._stroke != value);
	        this._stroke = value;
	    }

	    get stroke() {
	        return this._stroke;
	    }

	    set strokeThickness(value) {
	        this.setDirty(this._strokeThickness != value);
	        this._strokeThickness = value;
	    }

	    get strokeThickness() {
	        return this._strokeThickness;
	    }

	    setStroke(color, lineWidth) {
	        if (color != null) {
	            if (lineWidth === undefined) {
	                lineWidth = 2;
	            }
	        }
	        this.stroke = color;
	        this.strokeThickness = lineWidth;
	        return this;
	    }

	    set cornerRadius(value) {
	        this.setDirty(this._cornerRadius != value);
	        this._cornerRadius = value;
	    }

	    get cornerRadius() {
	        return this._cornerRadius;
	    }

	    set cornerIteration(value) {
	        this.setDirty(this._cornerIteration != value);
	        this._cornerIteration = value;
	    }

	    get cornerIteration() {
	        return this._cornerIteration;
	    }

	    modifyStyle(o) {
	        if (o.hasOwnProperty('color')) {
	            this.setColor(
	                o.color,
	                GetProperty('color2', o, this),
	                GetProperty('horizontalGradient', o, this),
	            );
	        }
	        if (o.hasOwnProperty('stroke')) {
	            this.setStroke(
	                o.stroke,
	                GetProperty('strokeThickness', o, this),
	            );
	        }
	        if (o.hasOwnProperty('cornerRadius')) {
	            this.setCornerRadius(
	                o.cornerRadius,
	                GetProperty('cornerIteration', o, this),
	            );
	        }

	        return this;
	    }

	    modifyPorperties(o) {
	        super.modifyPorperties(o);

	        this.modifyStyle(o);

	        return this;
	    }

	    setCornerRadius(radius, iteration) {
	        this.cornerRadius = radius;
	        this.cornerIteration = iteration;
	        return this;
	    }

	    renderContent() {
	        DrawRoundRectangleBackground(
	            this.parent,
	            this.color,
	            this.stroke,
	            this.strokeThickness,
	            this.cornerRadius,
	            this.color2,
	            this.horizontalGradient,
	            this.cornerIteration
	        );
	    }
	}

	const GetValue$12 = Phaser.Utils.Objects.GetValue;

	class InnerBounds extends RenderBase {
	    constructor(parent, config) {
	        super(parent, 'innerbounds');

	        this.setScrollFactor(0);

	        this.setColor(
	            GetValue$12(config, 'color', null),
	            GetValue$12(config, 'color2', null),
	            GetValue$12(config, 'horizontalGradient', true)
	        );

	        this.setStroke(
	            GetValue$12(config, 'stroke', null),
	            GetValue$12(config, 'strokeThickness', 2)
	        );
	    }

	    set color(value) {
	        value = GetStyle(value, this.canvas, this.context);
	        this.setDirty(this._color != value);
	        this._color = value;
	    }

	    get color() {
	        return this._color;
	    }

	    set color2(value) {
	        value = GetStyle(value, this.canvas, this.context);
	        this.setDirty(this._color2 != value);
	        this._color2 = value;
	    }

	    get color2() {
	        return this._color2;
	    }

	    set horizontalGradient(value) {
	        this.setDirty(this._horizontalGradient != value);
	        this._horizontalGradient = value;
	    }

	    get horizontalGradient() {
	        return this._horizontalGradient;
	    }

	    setColor(color, color2, isHorizontalGradient) {
	        if (isHorizontalGradient === undefined) {
	            isHorizontalGradient = true;
	        }

	        this.color = color;
	        this.color2 = color2;
	        this.horizontalGradient = isHorizontalGradient;
	        return this;
	    }

	    set stroke(value) {
	        value = GetStyle(value, this.canvas, this.context);
	        this.setDirty(this._stroke != value);
	        this._stroke = value;
	    }

	    get stroke() {
	        return this._stroke;
	    }

	    set strokeThickness(value) {
	        this.setDirty(this._strokeThickness != value);
	        this._strokeThickness = value;
	    }

	    get strokeThickness() {
	        return this._strokeThickness;
	    }

	    setStroke(color, lineWidth) {
	        if (color != null) {
	            if (lineWidth === undefined) {
	                lineWidth = 2;
	            }
	        }
	        this.stroke = color;
	        this.strokeThickness = lineWidth;
	        return this;
	    }

	    modifyPorperties(o) {
	        super.modifyPorperties(o);

	        if (o.hasOwnProperty('color')) {
	            this.setColor(
	                o.color,
	                GetValue$12(o, 'color2', null),
	                GetValue$12(o, 'horizontalGradient', true)
	            );
	        }
	        if (o.hasOwnProperty('stroke')) {
	            this.setStroke(
	                o.stroke,
	                GetValue$12(o, 'strokeThickness', 2)
	            );
	        }
	    }

	    renderContent() {
	        var padding = this.parent.padding;
	        var x = padding.left,
	            y = padding.top,
	            width = this.parent.width - padding.left - padding.right,
	            height = this.parent.height - padding.top - padding.bottom;
	        var context = this.context;
	        if (this.color != null) {
	            var fillStyle;
	            if (this.color2 != null) {
	                var grd;
	                if (this.horizontalGradient) {
	                    grd = context.createLinearGradient(0, 0, width, 0);
	                } else {
	                    grd = context.createLinearGradient(0, 0, 0, height);
	                }
	                grd.addColorStop(0, this.color);
	                grd.addColorStop(1, this.color2);
	                fillStyle = grd;
	            } else {
	                fillStyle = this.color;
	            }

	            context.fillStyle = fillStyle;
	            context.fillRect(x, y, width, height);
	        }

	        if ((this.stroke != null) && (this.strokeThickness > 0)) {
	            context.strokeStyle = this.stroke;
	            context.lineWidth = this.strokeThickness;
	            context.strokeRect(x, y, width, height);
	        }
	    }
	}

	const GetValue$11 = Phaser.Utils.Objects.GetValue;

	let TextStyle$1 = class TextStyle {
	    constructor(parent, config) {
	        this.parent = parent;
	        this.set(config);
	    }

	    toJSON() {
	        return {
	            bold: this.bold,
	            italic: this.italic,
	            fontSize: this.fontSize,
	            fontFamily: this.fontFamily,
	            color: this.color,
	            stroke: this.stroke,
	            strokeThickness: this.strokeThickness,
	            shaodwColor: this.shadowColor,
	            shadowBlur: this.shadowBlur,
	            shadowOffsetX: this.shadowOffsetX,
	            shadowOffsetY: this.shadowOffsetY,
	            offsetX: this.offsetX,
	            offsetY: this.offsetY,
	            leftSpace: this.leftSpace,
	            rightSpace: this.rightSpace,
	            backgroundHeight: this.backgroundHeight,
	            backgroundBottomY: this.backgroundBottomY,
	            align: this.align
	        }
	    }

	    set(o) {
	        this.setBold(GetValue$11(o, 'bold', false));
	        this.setItalic(GetValue$11(o, 'italic', false));
	        this.setFontSize(GetValue$11(o, 'fontSize', '16px'));
	        this.setFontFamily(GetValue$11(o, 'fontFamily', 'Courier'));
	        this.setColor(GetValue$11(o, 'color', '#fff'));
	        this.setStrokeStyle(
	            GetValue$11(o, 'stroke', null),
	            GetValue$11(o, 'strokeThickness', 0)
	        );
	        this.setShadow(
	            GetValue$11(o, 'shadowColor', null),
	            GetValue$11(o, 'shadowOffsetX', 0),
	            GetValue$11(o, 'shadowOffsetY', 0),
	            GetValue$11(o, 'shadowBlur', 0)
	        );
	        this.setOffset(
	            GetValue$11(o, 'offsetX', 0),
	            GetValue$11(o, 'offsetY', 0)
	        );
	        this.setSpace(
	            GetValue$11(o, 'leftSpace', 0),
	            GetValue$11(o, 'rightSpace', 0)
	        );
	        this.setAlign(GetValue$11(o, 'align', undefined));
	        this.setBackgroundColor(GetValue$11(o, 'backgroundColor', null));
	        this.setBackgroundHeight(GetValue$11(o, 'backgroundHeight', undefined));
	        this.setBackgroundBottomY(GetValue$11(o, 'backgroundBottomY', undefined));
	        this.setBackgroundLeftX(GetValue$11(o, 'backgroundLeftX', 0));
	        this.setBackgroundRightX(GetValue$11(o, 'backgroundRightX', 0));

	        return this;
	    }

	    modify(o) {
	        if (o.hasOwnProperty('bold')) {
	            this.setBold(o.bold);
	        }
	        if (o.hasOwnProperty('italic')) {
	            this.setItalic(o.italic);
	        }
	        if (o.hasOwnProperty('fontSize')) {
	            this.setFontSize(o.fontSize);
	        }
	        if (o.hasOwnProperty('fontFamily')) {
	            this.setFontFamily(o.fontFamily);
	        }
	        if (o.hasOwnProperty('color')) {
	            this.setColor(o.color);
	        }
	        if (o.hasOwnProperty('stroke') || o.hasOwnProperty('strokeThickness')) {
	            this.setStrokeStyle(
	                GetProperty('stroke', o, this),
	                GetProperty('strokeThickness', o, this)
	            );
	        }

	        if (o.hasOwnProperty('shadowColor')) {
	            this.setShadowColor(o.shadowColor);
	        }

	        if (o.hasOwnProperty('shadowOffsetX') || o.hasOwnProperty('shadowOffsetY')) {
	            this.setShadowOffset(
	                GetProperty('shadowOffsetX', o, this),
	                GetProperty('shadowOffsetY', o, this),
	            );
	        }

	        if (o.hasOwnProperty('shadowBlur')) {
	            this.setShadowBlur(o.shaodwBlur);
	        }

	        if (o.hasOwnProperty('offsetX')) {
	            this.setOffsetX(o.offsetX);
	        }
	        if (o.hasOwnProperty('offsetY')) {
	            this.setOffsetY(o.offsetY);
	        }

	        if (o.hasOwnProperty('leftSpace')) {
	            this.setLeftSpace(o.leftSpace);
	        }
	        if (o.hasOwnProperty('rightSpace')) {
	            this.setRightSpace(o.rightSpace);
	        }

	        if (o.hasOwnProperty('align')) {
	            this.setAlign(o.align);
	        }

	        if (o.hasOwnProperty('backgroundColor')) {
	            this.setBackgroundColor(o.backgroundColor);
	        }

	        if (o.hasOwnProperty('backgroundHeight')) {
	            this.setBackgroundHeight(o.backgroundHeight);
	        }
	        if (o.hasOwnProperty('backgroundBottomY')) {
	            this.setBackgroundBottomY(o.backgroundBottomY);
	        }
	        if (o.hasOwnProperty('backgroundLeftX')) {
	            this.setBackgroundLeftX(o.backgroundLeftX);
	        }
	        if (o.hasOwnProperty('backgroundRightX')) {
	            this.setBackgroundRightX(o.backgroundRightX);
	        }        

	        return this;
	    }

	    setUpdateTextFlag() {
	        if (this.parent) {
	            this.parent.updateTextFlag = true;
	        }
	        return this;
	    }

	    clone() {
	        return new TextStyle(null, this.toJSON());
	    }

	    copyFrom(sourceTextStyle) {
	        this.set(sourceTextStyle.toJSON());
	        return this;
	    }

	    copyTo(targetTextStyle) {
	        targetTextStyle.set(this.toJSON());
	        return this;
	    }

	    setBold(value) {
	        if (value === undefined) {
	            value = true;
	        }
	        this.bold = value;
	        this.setUpdateTextFlag();
	        return this;
	    }

	    setItalic(value) {
	        if (value === undefined) {
	            value = true;
	        }
	        this.italic = value;
	        this.setUpdateTextFlag();
	        return this;
	    }

	    get fontStyle() {
	        if (this.bold && this.italic) {
	            return 'bold italic';
	        } else if (this.bold) {
	            return 'bold';
	        } else if (this.italic) {
	            return 'italic';
	        } else {
	            return '';
	        }
	    }

	    setFontSize(fontSize) {
	        if (typeof (fontSize) === 'number') {
	            fontSize = `${fontSize}px`;
	        }
	        this.fontSize = fontSize;
	        this.setUpdateTextFlag();
	        return this;
	    }

	    setFontFamily(fontFamily) {
	        this.fontFamily = fontFamily;
	        this.setUpdateTextFlag();
	        return this;
	    }

	    get font() {
	        return `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`;
	    }

	    setColor(color) {
	        this.color = GetStyle(color);
	        return this;
	    }

	    get hasFill() {
	        return this.color != null;
	    }

	    setStrokeStyle(stroke, strokeThickness) {
	        this.stroke = GetStyle(stroke);
	        if (strokeThickness !== undefined) {
	            this.strokeThickness = strokeThickness;
	        }
	        return this;
	    }

	    setStrokeThickness(strokeThickness) {
	        this.strokeThickness = strokeThickness;
	        return this;
	    }

	    get hasStroke() {
	        return (this.stroke != null) && (this.strokeThickness > 0);
	    }

	    setShadowColor(color) {
	        this.shadowColor = GetStyle(color);
	        return this;
	    }

	    setShadowOffset(offsetX, offsetY) {
	        if (offsetX === undefined) {
	            offsetX = 0;
	        }
	        if (offsetY === undefined) {
	            offsetY = 0;
	        }

	        this.shadowOffsetX = offsetX;
	        this.shadowOffsetY = offsetY;
	        return this;
	    }

	    setShadowBlur(blur) {
	        if (blur === undefined) {
	            blur = 0;
	        }

	        this.shaodwBlur = blur;
	        return this;
	    }

	    setShadow(color, offsetX, offsetY, blur) {
	        this
	            .setShadowColor(color)
	            .setShadowOffset(offsetX, offsetY)
	            .setShadowBlur(blur);
	        return this;
	    }

	    setBackgroundColor(color) {
	        this.backgroundColor = GetStyle(color);
	        return this;
	    }

	    get hasBackgroundColor() {
	        return this.backgroundColor != null;
	    }

	    setBackgroundHeight(height) {
	        this.backgroundHeight = height;
	        return this;
	    }

	    setBackgroundBottomY(y) {
	        this.backgroundBottomY = y;
	        return this;
	    }

	    setBackgroundLeftX(x) {
	        this.backgroundLeftX = x;
	        return this;
	    }

	    setBackgroundRightX(x) {
	        this.backgroundRightX = x;
	        return this;
	    }

	    setOffsetX(offsetX) {
	        if (offsetX === undefined) {
	            offsetX = 0;
	        }

	        this.offsetX = offsetX;
	        return this;
	    }

	    setOffsetY(offsetY) {
	        if (offsetY === undefined) {
	            offsetY = 0;
	        }

	        this.offsetY = offsetY;
	        return this;
	    }

	    setOffset(offsetX, offsetY) {
	        this
	            .setOffsetX(offsetX)
	            .setOffsetY(offsetY);
	        return this;
	    }

	    setLeftSpace(space) {
	        if (space === undefined) {
	            space = 0;
	        }

	        this.leftSpace = space;
	        return this;
	    }

	    setRightSpace(space) {
	        if (space === undefined) {
	            space = 0;
	        }

	        this.rightSpace = space;
	        return this;
	    }

	    setSpace(leftSpace, rightSpace) {
	        this
	            .setLeftSpace(leftSpace)
	            .setRightSpace(rightSpace);
	        return this;
	    }

	    setAlign(align) {
	        this.align = align;
	        return this;
	    }

	    syncFont(context) {
	        context.font = this.font;
	        return this;
	    }

	    syncStyle(context) {
	        context.textBaseline = 'alphabetic';

	        var hasFill = this.hasFill;
	        var hasStroke = this.hasStroke;
	        context.fillStyle = (hasFill) ? this.color : '#000';

	        context.strokeStyle = (hasStroke) ? this.stroke : '#000';
	        context.lineWidth = (hasStroke) ? this.strokeThickness : 0;
	        context.lineCap = 'round';
	        context.lineJoin = 'round';

	        return this;
	    }

	    syncShadow(context) {
	        if (context.shadowColor != null) {
	            context.shadowColor = this.shadowColor;
	            context.shadowOffsetX = this.shadowOffsetX;
	            context.shadowOffsetY = this.shadowOffsetY;
	            context.shadowBlur = this.shadowBlur;
	        } else {
	            context.shadowColor = 0;
	            context.shadowOffsetX = 0;
	            context.shadowOffsetY = 0;
	            context.shadowBlur = 0;
	        }
	    }

	    getTextMetrics(context, text) {
	        this.syncFont(context).syncStyle(context);
	        return context.measureText(text);
	    }

	};

	var SetFixedSize = function (width, height) {
	    if (width === undefined) {
	        width = 0;
	    }
	    if (height === undefined) {
	        height = 0;
	    }

	    if ((this.fixedWidth === width) && (this.fixedHeight === height)) {
	        return this;
	    }

	    this.fixedWidth = width;
	    this.fixedHeight = height;
	    this.dirty = true;  // -> this.updateTexture();

	    this.setCanvasSize(
	        (width > 0) ? width : this.width,
	        (height > 0) ? height : this.height
	    );

	    return this;
	};

	var SetPadding = function (key, value) {
	    var padding = this.padding;
	    var paddingLeft = padding.left,
	        paddingRight = padding.right,
	        paddingTop = padding.top,
	        paddingBottom = padding.bottom;

	    SetPadding$1(padding, key, value);

	    this.dirty = this.dirty ||
	        (paddingLeft != padding.left) ||
	        (paddingRight != padding.right) ||
	        (paddingTop != padding.top) ||
	        (paddingBottom != padding.bottom)
	        ;
	    return this;
	};

	var GetPadding = function (key) {
	    return GetPadding$1(this.padding, key);
	};

	var ModifyTextStyle = function (style) {
	    this.textStyle.modify(style);
	    return this;
	};

	var ModifyDefaultTextStyle = function (style) {
	    this.defaultTextStyle.modify(style);
	    return this;
	};

	var ResetTextStyle = function () {
	    this.textStyle.copyFrom(this.defaultTextStyle);
	    return this;
	};

	var SetTestString = function (testString) {
	    this.testString = testString;
	    return this;
	};

	const RemoveItem$4 = Phaser.Utils.Array.Remove;

	var RemoveChild = function (child) {
	    this.poolManager.free(child);
	    RemoveItem$4(this.children, child);
	    this.lastAppendedChildren.length = 0;
	    this.lastOverChild = null;
	    this.dirty = true;
	    return this;
	};

	var RemoveChildren = function () {
	    this.poolManager.freeMultiple(this.children);
	    this.children.length = 0;
	    this.lastAppendedChildren.length = 0;
	    this.lastOverChild = null;
	    this.dirty = true;
	    return this;
	};

	const RemoveItem$3 = Phaser.Utils.Array.Remove;

	var PopChild = function (child) {
	    RemoveItem$3(this.children, child);
	    this.lastAppendedChildren.length = 0;
	    this.lastOverChild = null;
	    this.dirty = true;
	    return this;
	};

	var ClearContent = function() {
	    this.setText();
	    return this;
	};

	// const RemoveItem = Phaser.Utils.Array.Remove;

	var AddChild$1 = function (child, index) {
	    var areChildren = Array.isArray(child);

	    // Remove existed child(s)
	    // RemoveItem(this.children, child);

	    if ((index === undefined) || (index === this.children.length)) {
	        if (areChildren) {
	            this.children.push(...child);
	        } else {
	            this.children.push(child);
	        }
	    } else {
	        if (areChildren) {
	            this.children.splice(index, 0, ...child);
	        } else {
	            this.children.splice(index, 0, child);
	        }
	    }

	    this.lastAppendedChildren.length = 0;
	    if (areChildren) {
	        this.lastAppendedChildren.push(...child);
	    } else {
	        this.lastAppendedChildren.push(child);
	    }

	    return this;
	};

	const CharTypeName = 'text';
	const ImageTypeName = 'image';
	const DrawerTypeName = 'drawer';
	const SpaceTypeName = 'space';
	const CmdTypeName = 'command';

	var IsNewLineChar = function (bob) {
	    return (bob.type === CharTypeName) && (bob.text === '\n');
	};

	var IsPageBreakChar = function (bob) {
	    return (bob.type === CharTypeName) && (bob.text === '\f');
	};

	var IsChar = function (bob) {
	    return (bob.type === CharTypeName);
	};

	class CharData extends RenderBase {
	    constructor(
	        parent,
	        text,
	        style
	    ) {
	        super(parent, CharTypeName);
	        this.updateTextFlag = false;
	        this.style = new TextStyle$1(this, style);
	        this.setText(text);
	    }

	    get autoRound() {
	        return this.parent.autoRound;
	    }

	    get offsetX() {
	        return this.style.offsetX;
	    }

	    set offsetX(value) {
	        if (this.style) {
	            this.style.offsetX = value;
	        }
	    }

	    get offsetY() {
	        return this.style.offsetY;
	    }

	    set offsetY(value) {
	        if (this.style) {
	            this.style.offsetY = value;
	        }
	    }

	    get leftSpace() {
	        return this.style.leftSpace * this.scaleX;
	    }

	    set leftSpace(value) {
	        if (this.style) {
	            this.style.leftSpace = value;
	        }
	        super.leftSpace = value;
	    }

	    get rightSpace() {
	        return this.style.rightSpace * this.scaleX;
	    }

	    set rightSpace(value) {
	        if (this.style) {
	            this.style.rightSpace = value;
	        }
	        super.rightSpace = value;
	    }

	    get align() {
	        return this.style.align;
	    }

	    set align(value) {
	        if (this.style) {
	            this.style.align = value;
	        }
	    }

	    modifyStyle(style) {
	        this.setDirty(true);
	        this.style.modify(style);

	        if (this.updateTextFlag) {
	            this.updateTextSize();
	        }
	        return this;
	    }

	    modifyPorperties(o) {
	        if (!o) {
	            return this;
	        }

	        this.modifyStyle(o);
	        super.modifyPorperties(o);
	        return this;
	    }

	    setText(text) {
	        this.setDirty(this.text != text);
	        this.text = text;

	        this.updateTextSize();

	        return this;
	    }

	    updateTextSize() {
	        var text = this.text;
	        // Is new-line, page-break, or empty character
	        if ((text === '\n') || (text === '\f') || (text === '')) {
	            this.clearTextSize();

	        } else {
	            var metrics = this.style.getTextMetrics(this.context, this.text);
	            this.textWidth = metrics.width;

	            var ascent, descent;
	            if ('actualBoundingBoxAscent' in metrics) {
	                ascent = metrics.actualBoundingBoxAscent;
	                descent = metrics.actualBoundingBoxDescent;
	            } else {
	                ascent = 0;
	                descent = 0;
	            }

	            this.textHeight = ascent + descent;
	            this.ascent = ascent;
	            this.descent = descent;
	        }

	        this.updateTextFlag = false;
	        return this;
	    }

	    clearTextSize() {
	        this.textWidth = 0;
	        this.textHeight = 0;
	        this.ascent = 0;
	        this.descent = 0;
	        return this;
	    }

	    copyTextSize(child) {
	        this.textWidth = child.textWidth;
	        this.textHeight = child.textHeight;
	        this.ascent = child.ascent;
	        this.descent = child.descent;
	        return this;
	    }

	    get width() {
	        return this.textWidth * this.scaleX;
	    }

	    set width(value) {
	        if (this.textWidth > 0) {
	            this.scaleX = value / this.textWidth;
	        } else {
	            this.scaleX = 1;
	        }
	    }

	    get height() {
	        return this.textHeight * this.scaleY;
	    }

	    set height(value) {
	        if (this.textHeight > 0) {
	            this.scaleY = value / this.textHeight;
	        } else {
	            this.scaleY = 1;
	        }
	    }

	    get willRender() {
	        if (this.textWidth === 0) {
	            return false;
	        }

	        return super.willRender;
	    }

	    renderContent() {
	        var context = this.context;
	        var textStyle = this.style;

	        if (textStyle.hasBackgroundColor) {
	            context.fillStyle = textStyle.backgroundColor;

	            var leftX = this.drawTLX + textStyle.backgroundLeftX;
	            var rightX = this.drawTRX + textStyle.backgroundRightX;
	            var x = leftX;
	            var width = rightX - leftX + 1; // Add extra 1 pixel width

	            if (width > 0) {
	                var bottomY = textStyle.backgroundBottomY;
	                if (bottomY == null) {
	                    bottomY = this.drawBLY;
	                }
	                var height = textStyle.backgroundHeight;
	                if (height == null) {
	                    height = bottomY - this.drawTLY;
	                }
	                var y = bottomY - height;

	                context.fillRect(x, y, width, height);
	            }
	        }

	        var hasFill = textStyle.hasFill,
	            hasStroke = textStyle.hasStroke;

	        if (!hasFill && !hasStroke) {
	            return;
	        }

	        textStyle.syncFont(context).syncStyle(context);
	        // textBaseline = 'alphabetic'

	        if (hasStroke) {
	            textStyle.syncShadow(context);
	            context.strokeText(this.text, 0, 0);
	        }

	        if (hasFill) {
	            textStyle.syncShadow(context);
	            context.fillText(this.text, 0, 0);
	        }
	    }

	    get drawTLX() { return -this.leftSpace; }
	    get drawTLY() { return -this.ascent; }
	    get drawBLX() { return -this.leftSpace; }
	    get drawBLY() { return this.descent; }
	    get drawTRX() { return this.textWidth + this.rightSpace; }
	    get drawTRY() { return -this.ascent; }
	    get drawBRX() { return this.textWidth + this.rightSpace; }
	    get drawBRY() { return this.descent; }

	}

	var CreateCharChild = function (text, style) {
	    if (style) {
	        this.textStyle.modify(style);
	    }

	    var child = this.poolManager.allocate(CharTypeName);
	    if (child === null) {
	        child = new CharData(
	            this,               // parent
	            text,               // text
	            this.textStyle,     // style
	        );
	    } else {
	        child
	            .setParent(this)
	            .setActive()
	            .modifyStyle(this.textStyle)
	            .setText(text);
	    }

	    return child;
	};

	var CreateCharChildren = function (text, style) {
	    if (style) {
	        this.textStyle.modify(style);
	    }

	    var children = [];
	    for (var i = 0, cnt = text.length; i < cnt; i++) {
	        var char = text.charAt(i);
	        var child = this.poolManager.allocate(CharTypeName);
	        if (child === null) {
	            child = new CharData(
	                this,               // parent
	                char,               // text
	                this.textStyle,     // style
	            );
	        } else {
	            child
	                .setParent(this)
	                .setActive()
	                .modifyStyle(this.textStyle)
	                .setText(char);
	        }
	        // child.modifyPorperties(properties);  // Warning: Will modify text-style twice

	        children.push(child);
	    }

	    return children;
	};

	var AppendText = function (text, style) {
	    var children = this.createCharChildren(text, style);
	    this.addChild(children);
	    return this;
	};

	var SetText$3 = function (text, style) {
	    if (text === undefined) {
	        text = '';
	    }

	    this.removeChildren();
	    AppendText.call(this, text, style);  // this.appendText might be override

	    this.dirty = true;
	    return this;
	};

	var InsertText = function (index, text, style) {
	    var children = this.createCharChildren(text, style);
	    index = this.getCharChildIndex(index, true);
	    this.addChild(children, index);

	    return this;
	};

	var RemoveText = function (index, length) {
	    if (length === undefined) {
	        length = 1;
	    }

	    for (var i = 0; i < length; i++) {
	        var childIndex = this.getCharChildIndex(index, true);
	        if (childIndex === undefined) {
	            break;
	        }
	        this.removeChild(this.children[childIndex]);
	    }
	    return this;
	};

	var GetText = function (activeOnly) {
	    var text = '';
	    this.forEachCharChild(function (child) {
	        text += child.text;
	    }, undefined, activeOnly);
	    return text;
	};

	const CanvasPool$3 = Phaser.Display.Canvas.CanvasPool;

	var DrawFrameToCanvas = function (frame, canvas, x, y, width, height, color, autoRound) {
	    if (x === undefined) { x = 0; }
	    if (y === undefined) { y = 0; }
	    if (width === undefined) { width = frame.cutWidth; }
	    if (height === undefined) { height = frame.cutHeight; }
	    if (autoRound === undefined) { autoRound = false; }
	    if (autoRound) {
	        x = Math.round(x);
	        y = Math.round(y);
	    }

	    var context = canvas.getContext('2d', { willReadFrequently: true });

	    if (color) {
	        // Draw image at tempCanvas

	        // Get tempCanvas
	        var tempCanvas = CanvasPool$3.create(null, width, height, Phaser.CANVAS, true);

	        var tempContext = tempCanvas.getContext('2d', { willReadFrequently: true });

	        tempContext.drawImage(
	            frame.source.image,
	            frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight,
	            0, 0, width, height
	        );

	        // Tint-fill
	        tempContext.globalCompositeOperation = 'source-in';
	        tempContext.fillStyle = color;
	        tempContext.fillRect(0, 0, width, height);

	        // Draw tempCanvas at context
	        context.drawImage(
	            tempCanvas,
	            0, 0, width, height,
	            x, y, width, height
	        );

	        // Release tempCanvas
	        CanvasPool$3.remove(tempCanvas);
	    } else {
	        context.drawImage(
	            frame.source.image,
	            frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight,
	            x, y, width, height
	        );
	    }
	};

	Phaser.Display.Canvas.CanvasPool;

	class ImageData extends RenderBase {
	    constructor(
	        parent,
	        key, frame
	    ) {
	        super(parent, ImageTypeName);
	        this.setTexture(key, frame);
	        this.color = undefined;
	    }

	    get frameWidth() {
	        return (this.frameObj) ? this.frameObj.cutWidth : 0;
	    }

	    get frameHeight() {
	        return (this.frameObj) ? this.frameObj.cutHeight : 0;
	    }

	    get offsetY() {
	        return -this.height;
	    }

	    set offsetY(value) { }

	    get key() {
	        return this._key;
	    }

	    set key(value) {
	        this.setDirty(this._key != value);
	        this._key = value;
	    }

	    get frame() {
	        return this._frame;
	    }

	    set frame(value) {
	        this.setDirty(this._frame != value);
	        this._frame = value;
	    }

	    setTexture(key, frame) {
	        this.key = key;
	        this.frame = frame;

	        this.frameObj = this.scene.sys.textures.getFrame(key, frame);
	        return this;
	    }

	    get width() {
	        return this.frameWidth * this.scaleX;
	    }

	    set width(value) {
	        this.setDirty(this.width !== value);
	        this.scaleX = value / this.frameWidth;
	    }

	    get height() {
	        return this.frameHeight * this.scaleY;
	    }

	    set height(value) {
	        this.setDirty(this.height !== value);
	        this.scaleY = value / this.frameHeight;
	    }

	    setHeight(height, keepAspectRatio) {
	        if (keepAspectRatio === undefined) {
	            keepAspectRatio = false;
	        }
	        this.height = height;

	        if (keepAspectRatio) {
	            this.scaleX = this.scaleY;
	        }
	        return this;
	    }

	    setColor(color) {
	        this.color = color;
	        return this;
	    }

	    modifyPorperties(o) {
	        if (o.hasOwnProperty('color')) {
	            this.setColor(o.color);
	        }

	        super.modifyPorperties(o);
	        return this;
	    }

	    renderContent() {
	        DrawFrameToCanvas(
	            this.frameObj, this.canvas,
	            0, 0, this.frameWidth, this.frameHeight,
	            this.color, false
	        );

	    }

	    get drawTLX() { return -this.leftSpace; }
	    get drawTLY() { return 0; }
	    get drawBLX() { return -this.leftSpace; }
	    get drawBLY() { return this.frameHeight; }
	    get drawTRX() { return this.frameWidth + this.rightSpace; }
	    get drawTRY() { return 0; }
	    get drawBRX() { return this.frameWidth + this.rightSpace; }
	    get drawBRY() { return this.frameHeight; }
	}

	var CreateImageChild = function(key, frame, properties) {
	    var child = this.poolManager.allocate(ImageTypeName);

	    if (child === null) {
	        child = new ImageData(
	            this,               // parent
	            key,
	            frame
	        );
	    } else {
	        child
	            .setParent(this)
	            .setActive()
	            .setTexture(key, frame);
	    }
	    child.modifyPorperties(properties);

	    return child;
	};

	var AppendImage = function (key, frame, properties) {
	    var child = this.createImageChild(key, frame, properties);
	    this.addChild(child);

	    return this;
	};

	class Drawer extends RenderBase {
	    constructor(parent, renderCallback, width, height) {
	        super(parent, DrawerTypeName);

	        this.setRenderCallback(renderCallback);
	        this.setDrawerSize(width, height);
	    }

	    setRenderCallback(callback) {
	        if (callback) {
	            this.renderContent = callback.bind(this);
	        } else {
	            delete this.renderContent;
	        }
	        return this;
	    }

	    setDrawerSize(width, height) {
	        // Whole canvas
	        if (width === true) {
	            this.toLocalPosition = false;
	            width = undefined;
	            height = undefined;
	        } else {
	            this.toLocalPosition = true;
	        }

	        if (width === undefined) {
	            width = 0;
	        }
	        if (height === undefined) {
	            height = width;
	        }

	        this.drawerWidth = width;
	        this.drawerHeight = height;

	        return this;
	    }

	    onFree() {
	        super.onFree();
	        this
	            .setRenderCallback();
	    }

	    get width() {
	        return this.drawerWidth * this.scaleX;
	    }

	    set width(value) {
	        this.setDirty(this.width !== value);
	        this.scaleX = (this.drawerWidth > 0) ? value / this.drawerWidth : 1;
	    }

	    get height() {
	        return this.drawerHeight * this.scaleY;
	    }

	    set height(value) {
	        this.setDirty(this.height !== value);
	        this.scaleY = (this.drawerHeight > 0) ? value / this.drawerHeight : 1;
	    }

	    get offsetY() {
	        return -this.height;
	    }

	    set offsetY(value) { }

	    get drawTLX() { return -this.leftSpace; }
	    get drawTLY() { return 0; }
	    get drawBLX() { return -this.leftSpace; }
	    get drawBLY() { return this.drawerHeight; }
	    get drawTRX() { return this.drawerWidth + this.rightSpace; }
	    get drawTRY() { return 0; }
	    get drawBRX() { return this.drawerWidth + this.rightSpace; }
	    get drawBRY() { return this.drawerHeight; }

	}

	var CreateDrawerChild = function (renderCallback, width, height) {
	    var child = this.poolManager.allocate(DrawerTypeName);

	    if (child === null) {
	        child = new Drawer(
	            this,               // parent
	            renderCallback,
	            width, height
	        );
	    } else {
	        child
	            .setParent(this)
	            .setActive()
	            .setRenderCallback(renderCallback)
	            .setDrawerSize(width, height);
	    }

	    return child;
	};

	var AppendDrawer = function (renderCallback, width, height) {
	    var child = this.createDrawerChild(renderCallback, width, height);
	    this.addChild(child);

	    return this;
	};

	class Space extends RenderBase {
	    constructor(
	        parent,
	        width
	    ) {
	        super(parent, SpaceTypeName);
	        this.setSpaceWidth(width);
	    }

	    get width() {
	        return this.spaceWidth * this.scaleX;
	    }

	    set width(value) {
	        if (this.spaceWidth > 0) {
	            this.scaleX = value / this.spaceWidth;
	        } else {
	            this.scaleX = 1;
	        }
	    }

	    setSpaceWidth(width) {
	        this.spaceWidth = width;
	        return this;
	    }

	}

	var CreateSpaceChild = function (width) {
	    var child = this.poolManager.allocate(SpaceTypeName);

	    if (child === null) {
	        child = new Space(
	            this,               // parent
	            width
	        );
	    } else {
	        child
	            .setParent(this)
	            .setActive()
	            .setSpaceWidth(width);
	    }
	    return child;
	};

	var AppendSpace = function (width) {
	    var child = this.createSpaceChild(width);
	    this.addChild(child);

	    return this;
	};

	class Command extends Base$1 {
	    constructor(parent, name, callback, param, scope) {
	        super(parent, CmdTypeName);

	        this
	            .setName(name)
	            .setParameter(param)
	            .setCallback(callback, scope);
	    }

	    setName(name) {
	        this.name = name;
	        return this;
	    }

	    setParameter(param) {
	        this.param = param;
	        return this;
	    }

	    setCallback(callback, scope) {
	        this.callback = callback;
	        this.scope = scope;
	        return this;
	    }

	    exec() {
	        var result;
	        if (this.scope) {
	            result = this.callback.call(this.scope, this.param, this.name);
	        } else {
	            result = this.callback(this.param, this.name);
	        }
	        return result;
	    }

	    onFree() {
	        super.onFree();
	        this
	            .setName()
	            .setCallback()
	            .setParameter();
	    }
	}

	var CreateCommandChild = function (name, callback, param, scope) {
	    var child = this.poolManager.allocate(CmdTypeName);

	    if (child === null) {
	        child = new Command(
	            this,               // parent
	            name,
	            callback, param, scope,
	        );
	    } else {
	        child
	            .setParent(this)
	            .setActive()
	            .setName(name)
	            .setCallback(callback, scope)
	            .setParameter(param);

	    }

	    return child;
	};

	var AppendCommand = function (name, callback, param, scope) {
	    var child = this.createCommandChild(name, callback, param, scope);
	    this.addChild(child);

	    return this;
	};

	var SetWrapConfig = function (config) {
	    if (config === undefined) {
	        config = {};
	    } else if (typeof (config) === 'object') {
	        config = DeepClone(config);
	    }

	    this.wrapConfig = config;
	    return this;
	};

	var CreateWrapResultData = function (config) {
	    var data = {
	        callback: undefined,
	        start: 0,  // Next start index
	        isLastPage: false,  // Is last page
	        maxLines: undefined,
	        padding: undefined,
	        letterSpacing: undefined,
	        hAlign: undefined,
	        vAlign: undefined,
	        children: [],       // Wrap result
	        lines: [],          // Wrap result in lines

	        // WordWrap
	        maxLineWidth: 0,
	        linesHeight: 0,
	        lineHeight: undefined,

	        // VerticalWrap
	        maxLineHeight: 0,
	        linesWidth: 0,
	        lineWidth: undefined,
	    };

	    return Object.assign(data, config);
	};

	const WRAPMODE = {
	    none: 0,
	    word: 1,
	    char: 2,
	    character: 2,
	    mix: 3
	};

	var GetWord = function (children, startIndex, wrapMode, result) {
	    if (result === undefined) {
	        result = { word: [], width: 0 };
	    }

	    result.word.length = 0;

	    var isCharWrap = (wrapMode === 2);
	    var isMixWrap = (wrapMode === 3);
	    var isWordWrap = !isCharWrap && !isMixWrap;

	    var endIndex = children.length;
	    var currentIndex = startIndex;
	    var word = result.word;
	    var wordWidth = 0;
	    var hasAnyASCIICharacter = false;
	    while (currentIndex < endIndex) {
	        var child = children[currentIndex];
	        // Can't render (command child), put into output directly
	        if (!child.renderable) {
	            word.push(child);
	            currentIndex++;
	            continue;
	        }

	        var text = (child.type === CharTypeName) ? child.text : null;
	        // Get image child, a new-line, or page-break
	        if ((text === null) || (text === '\n') || (text === '\f')) {
	            if (currentIndex === startIndex) { // Single child
	                word.push(child);
	                wordWidth += child.outerWidth;
	            }
	            break;
	        }

	        if (isWordWrap) {
	            word.push(child);
	            wordWidth += child.outerWidth;
	            if (text === ' ') { // Word is end with a space character
	                break;
	            }

	            currentIndex++;

	        } else if (isCharWrap) {  // Word only contains 1 character
	            word.push(child);
	            wordWidth += child.outerWidth;
	            // Flush this 1 character
	            break;

	        } else if (isMixWrap) {
	            if (!IsASCIIString(text)) {
	                if (!hasAnyASCIICharacter) {
	                    word.push(child);
	                    wordWidth += child.outerWidth;

	                    // Is next child a space character?
	                    var nextChild = children[currentIndex + 1];
	                    if (nextChild &&
	                        (nextChild.type === CharTypeName) &&
	                        (nextChild.text === ' ')) {
	                        word.push(nextChild);
	                        wordWidth += nextChild.outerWidth;
	                        // Include this space character
	                    }
	                    // Flush this 1 non-ascii character
	                    break;

	                } else {
	                    // Flush remainder children (all ascii character), except current child
	                    break;

	                }
	            } else {
	                word.push(child);
	                wordWidth += child.outerWidth;
	                if (text === ' ') { // Word is end with a space character
	                    break;
	                }

	                currentIndex++;
	                hasAnyASCIICharacter = true;
	                // Test next child until ...
	            }

	        }
	    }

	    result.width = wordWidth;
	    return result;
	};

	var GetChildrenAlign = function (children) {
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        if (child.align !== undefined) {
	            return child.align;
	        }
	    }

	    return undefined;
	};

	var OffsetChildren = function (children, offsetX, offsetY) {
	    if ((offsetX === 0) && (offsetY === 0)) {
	        return;
	    }

	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        if (!child.renderable) {
	            continue;
	        }

	        child.x += offsetX;
	        child.y += offsetY;
	    }
	};

	var AlignLines$1 = function (result, width, height) {
	    var hAlign = result.hAlign,
	        vAlign = result.vAlign,
	        justifyPercentage = result.justifyPercentage;

	    var lines = result.lines;
	    var offsetX, offsetY;
	    for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
	        var line = lines[li];
	        var lineWidth = line.width,
	            children = line.children;

	        var lineHAlign = GetChildrenAlign(children);
	        if (lineHAlign === undefined) {
	            lineHAlign = hAlign;
	        }

	        switch (lineHAlign) {
	            case 0:
	            case 'left':
	                offsetX = 0;
	                break;

	            case 1:  // center
	            case 'center':
	                var remainderWidth = width - lineWidth;
	                offsetX = remainderWidth / 2;
	                break;

	            case 2:  // right
	            case 'right':
	                var remainderWidth = width - lineWidth;
	                offsetX = remainderWidth;
	                break;

	            case 3:
	            case 'justify':
	            case 'justify-left':
	                var remainderWidth = width - lineWidth;
	                var remainderPercentage = remainderWidth / width;
	                if (remainderPercentage < justifyPercentage) {
	                    JustifyChildren(children, remainderWidth);
	                    offsetX = 0;
	                } else {
	                    offsetX = 0;
	                }
	                break;

	            case 4:
	            case 'justify-center':
	                var remainderWidth = width - lineWidth;
	                var remainderPercentage = remainderWidth / width;
	                if (remainderPercentage < justifyPercentage) {
	                    JustifyChildren(children, remainderWidth);
	                    offsetX = 0;
	                } else {
	                    offsetX = remainderWidth / 2;
	                }
	                break;

	            case 5:
	            case 'justify-right':
	                var remainderWidth = width - lineWidth;
	                var remainderPercentage = remainderWidth / width;
	                if (remainderPercentage < justifyPercentage) {
	                    JustifyChildren(children, remainderWidth);
	                    offsetX = 0;
	                } else {
	                    offsetX = remainderWidth;
	                }
	                break;

	            default:
	                offsetX = 0;
	                break;
	        }

	        var linesHeight = result.linesHeight;
	        switch (vAlign) {
	            case 1: // center
	            case 'center':
	                offsetY = (height - linesHeight) / 2;
	                break;

	            case 2: // bottom
	            case 'bottom':
	                offsetY = height - linesHeight;
	                break;

	            default:
	                offsetY = 0;
	                break;
	        }

	        OffsetChildren(children, offsetX, offsetY);

	    }

	};

	var JustifyChildren = function (children, remainderWidth) {
	    var offset = remainderWidth / children.length;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        if (!child.renderable) {
	            continue;
	        }

	        child.x += offset * i;
	    }
	};

	var GetDefaultTextHeight = function () {
	    var metrics = this.defaultTextStyle.getTextMetrics(this.context, this.testString);
	    var ascent, descent;
	    if ('actualBoundingBoxAscent' in metrics) {
	        ascent = metrics.actualBoundingBoxAscent;
	        descent = metrics.actualBoundingBoxDescent;
	    } else {
	        ascent = 0;
	        descent = 0;
	    }
	    
	    Result.ascent = ascent;
	    Result.descent = descent;
	    Result.height = ascent + descent;

	    return Result;
	};

	var Result = {};

	const GetValue$10 = Phaser.Utils.Objects.GetValue;

	var RunWordWrap$1 = function (config) {
	    // Parse parameters
	    var startIndex = GetValue$10(config, 'start', 0);

	    SetPadding$1(this.wrapPadding, GetValue$10(config, 'padding', 0));
	    var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
	    var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;

	    // Get lineHeight, maxLines
	    var lineHeight = GetValue$10(config, 'lineHeight');
	    var ascent = GetValue$10(config, 'ascent', lineHeight);
	    var maxLines;
	    if (lineHeight === undefined) {
	        // Calculate lineHeight
	        var useDefaultTextHeight = GetValue$10(config, 'useDefaultTextHeight', false);
	        maxLines = GetValue$10(config, 'maxLines', 0);
	        if ((this.fixedHeight > 0) && (!useDefaultTextHeight)) {
	            var innerHeight = this.fixedHeight - paddingVertical;
	            if (maxLines > 0) {
	                // Calculate lineHeight via maxLines, in fixedHeight mode
	                lineHeight = innerHeight / maxLines;
	            } else {
	                var textHeightResult = GetDefaultTextHeight.call(this);
	                lineHeight = textHeightResult.height;
	                ascent = textHeightResult.ascent;
	                // Calculate maxLines via (ascent, lineHeight), in fixedHeight mode
	                maxLines = Math.floor((innerHeight - ascent) / lineHeight);
	            }
	        } else {
	            var textHeightResult = GetDefaultTextHeight.call(this);
	            lineHeight = textHeightResult.height;
	            ascent = textHeightResult.ascent;
	        }

	    } else {
	        // Calculate maxLines
	        if (this.fixedHeight > 0) {
	            // Calculate maxLines via lineHeight, in fixedHeight mode
	            maxLines = GetValue$10(config, 'maxLines');
	            if (maxLines === undefined) {
	                var innerHeight = this.fixedHeight - paddingVertical;
	                maxLines = Math.floor(innerHeight / lineHeight);
	            }
	        } else {
	            maxLines = GetValue$10(config, 'maxLines', 0); // Default is show all lines
	        }

	    }

	    // If ascent is undefined, assign to lineHeight
	    if (ascent === undefined) {
	        ascent = lineHeight;
	    }

	    var showAllLines = (maxLines === 0);

	    var wrapMode = GetValue$10(config, 'wrapMode');
	    if (wrapMode === undefined) {
	        var charWrap = GetValue$10(config, 'charWrap', false);
	        wrapMode = (charWrap) ? 'char' : 'word';
	    }
	    if (typeof (wrapMode) === 'string') {
	        wrapMode = WRAPMODE[wrapMode];
	    }

	    // Get wrapWidth
	    var wrapWidth = GetValue$10(config, 'wrapWidth', undefined);
	    if (wrapWidth === undefined) {
	        if (this.fixedWidth > 0) {
	            wrapWidth = this.fixedWidth - paddingHorizontal;
	        } else {
	            wrapWidth = Infinity; // No word-wrap
	            wrapMode = 0;
	        }
	    }

	    var letterSpacing = GetValue$10(config, 'letterSpacing', 0);

	    var hAlign = GetValue$10(config, 'hAlign', 0);
	    var vAlign = GetValue$10(config, 'vAlign', 0);
	    var justifyPercentage = GetValue$10(config, 'justifyPercentage', 0.25);

	    var result = CreateWrapResultData({
	        // Override properties
	        callback: 'runWordWrap',
	        start: startIndex,  // Next start index
	        padding: this.wrapPadding,
	        letterSpacing: letterSpacing,
	        maxLines: maxLines,
	        hAlign: hAlign,
	        vAlign: vAlign,
	        justifyPercentage: justifyPercentage,

	        // Specific properties
	        ascent: ascent,
	        lineHeight: lineHeight,
	        wrapWidth: wrapWidth,
	        wrapMode: wrapMode,
	    });

	    // Set all children to inactive
	    var children = this.children;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        children[i].setActive(false);
	    }

	    // Layout children
	    wrapWidth += letterSpacing;
	    var startX = this.padding.left + this.wrapPadding.left,
	        startY = this.padding.top + this.wrapPadding.top + ascent,  // Start(baseline) from ascent, not 0
	        x = startX,
	        y = startY;
	    var remainderWidth = wrapWidth,
	        childIndex = startIndex,
	        lastChildIndex = children.length;
	    var resultChildren = result.children;
	    var resultLines = result.lines,
	        lastLine = [], lastLineWidth = 0, maxLineWidth = 0;
	    var wordResult;
	    var isPageBreakChar = false;
	    while (childIndex < lastChildIndex) {
	        wordResult = GetWord(children, childIndex, wrapMode, wordResult);
	        var word = wordResult.word;
	        var charCnt = word.length;
	        var wordWidth = wordResult.width + (charCnt * letterSpacing);

	        childIndex += charCnt;
	        // Next line
	        var isNewLineChar = IsNewLineChar(word[0]);
	        isPageBreakChar = IsPageBreakChar(word[0]);
	        var isControlChar = isNewLineChar || isPageBreakChar;
	        if ((remainderWidth < wordWidth) || isControlChar) {
	            // Add to result
	            if (isControlChar) {
	                var char = word[0];
	                char.setActive().setPosition(x, y);
	                resultChildren.push(char);
	                lastLine.push(char);
	            }

	            // Move cursor
	            x = startX;
	            y += lineHeight;
	            remainderWidth = wrapWidth;
	            resultLines.push({ children: lastLine, width: lastLineWidth });
	            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);

	            lastLineWidth = 0;
	            lastLine = [];

	            var isPageEnd = isPageBreakChar ||
	                (!showAllLines && (resultLines.length === maxLines)); // Exceed maxLines
	            if (isPageEnd) {
	                break;
	            } else if (isControlChar) {  // Already add to result
	                continue;
	            }
	        }
	        remainderWidth -= wordWidth;
	        lastLineWidth += wordWidth;

	        for (var i = 0, cnt = word.length; i < cnt; i++) {
	            var child = word[i];
	            child.setActive();
	            resultChildren.push(child);
	            lastLine.push(child);

	            if (child.renderable) {
	                child.setPosition(x, y);
	                x += (child.outerWidth + letterSpacing);
	            }
	        }
	    }

	    if (lastLine.length > 0) {
	        resultLines.push({ children: lastLine, width: lastLineWidth });
	        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
	    }

	    result.start += resultChildren.length;
	    result.isLastPage = (!isPageBreakChar) && (result.start === lastChildIndex);
	    result.maxLineWidth = maxLineWidth;
	    result.linesHeight = (resultLines.length * lineHeight);

	    // Calculate size of game object
	    var width = (this.fixedWidth > 0) ? this.fixedWidth : (result.maxLineWidth + paddingHorizontal);
	    var height = (this.fixedHeight > 0) ? this.fixedHeight : (result.linesHeight + paddingVertical);

	    // Size might be changed after wrapping
	    var innerWidth = width - paddingHorizontal;
	    var innerHeight = height - paddingVertical;
	    AlignLines$1(result, innerWidth, innerHeight);

	    // Resize
	    this.setCanvasSize(width, height);

	    // Set initial position
	    for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
	        var child = resultChildren[i];
	        if (!child.renderable) {
	            continue;
	        }
	        child.x0 = child.x;
	        child.y0 = child.y;
	    }

	    return result;
	};

	const Merge$4 = Phaser.Utils.Objects.Merge;

	var RunWordWrap = function (config) {
	    if (config === undefined) {
	        config = {};
	    }

	    return RunWordWrap$1.call(this, Merge$4(config, this.wrapConfig));
	};

	var AlignLines = function (result, width, height) {
	    var hAlign = result.hAlign,
	        vAlign = result.vAlign;

	    var offsetX, offsetY;

	    var rtl = result.rtl;
	    var lines = result.lines,
	        lineWidth = result.lineWidth,
	        linesWidth = result.linesWidth;
	    switch (hAlign) {
	        case 1:  // center
	        case 'center':
	            offsetX = (width - linesWidth) / 2;
	            break;

	        case 2:  // right
	        case 'right':
	            offsetX = width - linesWidth;
	            break;

	        default:  // left
	            offsetX = 0;
	            break;
	    }
	    if (rtl) {
	        offsetX += lineWidth;
	    }

	    for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
	        var line = lines[(rtl) ? (lcnt - li - 1) : li];
	        var children = line.children;
	        var lineHeight = line.height;

	        var lineVAlign = GetChildrenAlign(children);
	        if (lineVAlign === undefined) {
	            lineVAlign = vAlign;
	        }

	        switch (lineVAlign) {
	            case 1: // center
	            case 'center':
	                offsetY = (height - lineHeight) / 2;
	                break;

	            case 2: // bottom
	            case 'bottom':
	                offsetY = height - lineHeight;
	                break;

	            default: // top
	                offsetY = 0;
	                break;
	        }

	        OffsetChildren(children, offsetX, offsetY);

	        offsetX += lineWidth;
	    }
	};

	const GetValue$$ = Phaser.Utils.Objects.GetValue;

	var RunVerticalWrap$1 = function (config) {
	    // Parse parameters
	    var startIndex = GetValue$$(config, 'start', 0);

	    SetPadding$1(this.wrapPadding, GetValue$$(config, 'padding', 0));
	    var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
	    var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;

	    var lineWidth = GetValue$$(config, 'lineWidth', undefined);
	    var maxLines;
	    if (lineWidth === undefined) {
	        // Calculate lineWidth via maxLines, in fixedWidth mode
	        maxLines = GetValue$$(config, 'maxLines', 0);
	        if (this.fixedWidth > 0) {
	            var innerWidth = this.fixedWidth - paddingHorizontal;
	            lineWidth = innerWidth / maxLines;
	        } else {
	            lineWidth = 0;
	        }
	    } else {
	        if (this.fixedWidth > 0) {
	            // Calculate maxLines via lineWidth, in fixedWidth mode
	            maxLines = GetValue$$(config, 'maxLines', undefined);
	            if (maxLines === undefined) {
	                var innerWidth = this.fixedWidth - paddingHorizontal;
	                maxLines = Math.floor(innerWidth / lineWidth) + 1;
	            }
	        } else {
	            maxLines = GetValue$$(config, 'maxLines', 0); // Default is show all lines
	        }

	    }
	    var showAllLines = (maxLines === 0);

	    // Get fixedCharacterHeight
	    var fixedCharacterHeight = GetValue$$(config, 'fixedCharacterHeight', undefined);
	    if (fixedCharacterHeight === undefined) {
	        var charPerLine = GetValue$$(config, 'charPerLine', undefined);
	        if (charPerLine !== undefined) {
	            var innerHeight = this.fixedHeight - paddingVertical;
	            fixedCharacterHeight = Math.floor(innerHeight / charPerLine);
	        }
	    }

	    // Get wrapHeight
	    var wrapHeight = GetValue$$(config, 'wrapHeight', undefined);
	    if (wrapHeight === undefined) {
	        if (this.fixedHeight > 0) {
	            wrapHeight = this.fixedHeight - paddingVertical;
	        } else {
	            wrapHeight = Infinity; // No word-wrap
	        }
	    }

	    var letterSpacing = GetValue$$(config, 'letterSpacing', 0);

	    var rtl = GetValue$$(config, 'rtl', true);
	    var hAlign = GetValue$$(config, 'hAlign', rtl ? 2 : 0);
	    var vAlign = GetValue$$(config, 'vAlign', 0);

	    var result = CreateWrapResultData({
	        // Override properties
	        callback: 'runVerticalWrap',
	        start: startIndex,  // Next start index
	        padding: this.wrapPadding,
	        letterSpacing: letterSpacing,
	        maxLines: maxLines,
	        hAlign: hAlign,
	        vAlign: vAlign,

	        // Specific properties
	        lineWidth: lineWidth,
	        fixedCharacterHeight: fixedCharacterHeight,
	        wrapHeight: wrapHeight,        
	        rtl: rtl,
	    });

	    // Set all children to active
	    var children = this.children;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        children[i].setActive(false);
	    }

	    // Layout children
	    wrapHeight += letterSpacing;
	    var startX = this.padding.left + this.wrapPadding.left,  // Reset x of each character in AlignLines method
	        startY = this.padding.top + this.wrapPadding.top,
	        x = startX,
	        y = startY;
	    var remainderHeight = wrapHeight,
	        childIndex = startIndex,
	        lastChildIndex = children.length;
	    var resultChildren = result.children;
	    var resultLines = result.lines,
	        lastLine = [], lastLineHeight = 0, maxLineHeight = 0;
	    while (childIndex < lastChildIndex) {
	        // Append non-typeable child directly
	        var child = children[childIndex];
	        childIndex++;
	        if (!child.renderable) {
	            child.setActive();
	            resultChildren.push(child);
	            lastLine.push(child);
	            continue;
	        }

	        var childHeight = ((fixedCharacterHeight !== undefined) ? fixedCharacterHeight : child.height) + letterSpacing;
	        // Next line
	        var isNewLineChar = IsNewLineChar(child);
	        var isPageBreakChar = IsPageBreakChar(child);
	        var isControlChar = isNewLineChar || isPageBreakChar;
	        if ((remainderHeight < childHeight) || isControlChar) {
	            // Add to result
	            if (isNewLineChar) {
	                child.setActive().setPosition(x, y).setOrigin(0.5);
	                resultChildren.push(child);
	                lastLine.push(child);
	            }

	            // Move cursor
	            x = startX;
	            y = startY;
	            remainderHeight = wrapHeight;
	            resultLines.push({ children: lastLine, height: lastLineHeight });
	            maxLineHeight = Math.max(maxLineHeight, lastLineHeight);

	            lastLineHeight = 0;
	            lastLine = [];

	            var isPageEnd = isPageBreakChar ||
	                (!showAllLines && (resultLines.length === maxLines)); // Exceed maxLines
	            if (isPageEnd) {
	                break;
	            } else if (isControlChar) {  // Already add to result                
	                continue;
	            }
	        }
	        remainderHeight -= childHeight;
	        lastLineHeight += childHeight;

	        child.setActive().setPosition(x, y).setOrigin(0.5);
	        resultChildren.push(child);
	        lastLine.push(child);
	        y += childHeight;
	    }

	    if (lastLine.length > 0) {
	        resultLines.push({ children: lastLine, height: lastLineHeight });
	        maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
	    }

	    result.start += resultChildren.length;
	    result.isLastPage = (result.start === lastChildIndex);
	    result.maxLineHeight = maxLineHeight;
	    result.linesWidth = (resultLines.length * lineWidth);

	    // Calculate size of game object
	    var width = (this.fixedWidth > 0) ? this.fixedWidth : (result.linesWidth + paddingHorizontal);
	    var height = (this.fixedHeight > 0) ? this.fixedHeight : (result.maxLineHeight + paddingVertical);

	    // Size might be changed after wrapping
	    var innerWidth = width - paddingHorizontal;
	    var innerHeight = height - paddingVertical;
	    AlignLines(result, innerWidth, innerHeight);

	    // Resize
	    this.setCanvasSize(width, height);

	    // Set initial position
	    for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
	        var child = resultChildren[i];
	        if (!child.renderable) {
	            continue;
	        }
	        child.x0 = child.x;
	        child.y0 = child.y;
	    }

	    return result;
	};

	const Merge$3 = Phaser.Utils.Objects.Merge;

	var RunVerticalWrap = function (config) {
	    if (config === undefined) {
	        config = {};
	    }

	    return RunVerticalWrap$1.call(this, Merge$3(config, this.wrapConfig));
	};

	const GetValue$_ = Phaser.Utils.Objects.GetValue;

	var RunWrap = function (config) {
	    var wrapCallback = GetValue$_(this.wrapConfig, 'callback');
	    if (!wrapCallback) {
	        wrapCallback = GetValue$_(config, 'callback', this.runWordWrap);
	    }
	    if (typeof (wrapCallback) === 'string') {
	        wrapCallback = this[wrapCallback];
	    }

	    return wrapCallback.call(this, config);
	};

	var SetAlignMethods = {
	    setVAlign(align) {
	        this.wrapConfig.vAlign = align;
	        return this;
	    },

	    setHAlign(align) {
	        this.wrapConfig.hAlign = align;
	        return this;
	    }
	};

	var SetTextOXYMethods$1 = {
	    setTextOX(ox) {
	        if (ox === this._textOX) {
	            return this;
	        }

	        this._textOX = ox;
	        return this;
	    },

	    setTextOY(oy) {
	        if (oy === this._textOY) {
	            return this;
	        }

	        this._textOY = oy;
	        return this;
	    },

	    setTextOXY(ox, oy) {
	        if ((ox === this._textOX) && (oy === this._textOY)) {
	            return;
	        }

	        this._textOX = ox;
	        this._textOY = oy;
	        return this;
	    },

	    addTextOX(incX) {
	        this.setTextOX(this._textOX + incX);
	        return this;
	    },

	    addTextOY(incY) {
	        this.setTextOY(this._textOY + incY);
	        return this;
	    },

	    addTextOXY(incX, incY) {
	        this.setTextOXY(this._textOX + incX, this._textOY + incY);
	        return this;
	    }

	};

	var RenderContent = function () {
	    this.clear();

	    this.setCanvasSize(this.width, this.height);

	    if (this.background.active) {
	        this.background.render();
	    }

	    var child;
	    for (var i = 0, cnt = this.children.length; i < cnt; i++) {
	        child = this.children[i];
	        if (child.active) {
	            child.render();
	        }
	    }

	    if (this.innerBounds.active) {
	        this.innerBounds.render();
	    }
	};

	var ForEachChild = function (callback, scope, activeOnly) {
	    if (activeOnly === undefined) {
	        activeOnly = true;
	    }

	    var children = this.children.filter(function (child) {
	        if (activeOnly && !child.active) {
	            return false;
	        }
	        return true;
	    });

	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];

	        var isBreak;
	        if (scope) {
	            isBreak = callback.call(this, child, i, children);
	        } else {
	            isBreak = callback(child, i, children);
	        }

	        if (isBreak) {
	            break;
	        }
	    }

	    return this;
	};

	var ForEachRenderableChild = function (callback, scope, activeOnly) {
	    if (activeOnly === undefined) {
	        activeOnly = true;
	    }

	    var children = this.children.filter(function (child) {
	        if (activeOnly && !child.active) {
	            return false;
	        }
	        if (!child.renderable || child.removed) {
	            return false;
	        }

	        return true;
	    });

	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];

	        var isBreak;
	        if (scope) {
	            isBreak = callback.call(this, child, i, children);
	        } else {
	            isBreak = callback(child, i, children);
	        }

	        if (isBreak) {
	            break;
	        }
	    }

	    return this;
	};

	var ForEachCharChild = function (callback, scope, activeOnly) {
	    if (activeOnly === undefined) {
	        activeOnly = true;
	    }

	    var children = this.children.filter(function (child) {
	        if (activeOnly && !child.active) {
	            return false;
	        }
	        if (!IsChar(child) || child.removed) {
	            return false;
	        }

	        return true;
	    });

	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];

	        var isBreak;
	        if (scope) {
	            isBreak = callback.call(this, child, i, children);
	        } else {
	            isBreak = callback(child, i, children);
	        }

	        if (isBreak) {
	            break;
	        }
	    }

	    return this;
	};

	var GetChildren = function () {
	    return this.children;
	};

	const GetAll = Phaser.Utils.Array.GetAll;

	var GetActiveChildren = function () {
	    return GetAll(this.children, 'active', true);
	};

	var GetCharChildren = function (activeOnly, out) {
	    if (out === undefined) {
	        out = [];
	    }

	    this.forEachCharChild(function (child) {
	        out.push(child);
	    }, undefined, activeOnly);

	    return out;
	};

	var GetLastAppendedChildren = function () {
	    return this.lastAppendedChildren;
	};

	var GetBobCenterPosition = function (bob, offsetX, offsetY, out) {
	    if (typeof (offsetX) !== 'number') {
	        out = offsetX;
	        offsetX = 0;
	        offsetY = 0;
	    }
	    var bobX = bob.drawCenterX + offsetX;
	    var bobY = bob.drawCenterY + offsetY;
	    return BobPositionToCanvasPosition(bob, bobX, bobY, out);
	};

	const GetDistance = Phaser.Math.Distance.BetweenPointsSquared;

	var GetNearestChild = function (canvasX, canvasY) {
	    var pointA = { x: canvasX, y: canvasY };

	    var minDistance = Infinity;
	    var nearestChild = null;
	    this.forEachRenderableChild(function (child) {
	        var distance = GetDistance(pointA, GetBobCenterPosition(child, true));
	        if (minDistance > distance) {
	            minDistance = distance;
	            nearestChild = child;
	        }
	    });

	    return nearestChild;
	};

	var GetCharWorldPosition = function (child, offsetX, offsetY, out) {
	    if (typeof (child) === 'number') {
	        child = this.getCharChild(child, true);
	    }

	    return GetBobWorldPosition(this, child, offsetX, offsetY, out);
	};

	var SetToMinSize = function () {
	    var children = this.children;
	    var maxX = 0,
	        maxY = 0;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        if (!child.renderable || !child.active || !child.visible) {
	            continue;
	        }

	        var x0 = (child.x0 !== undefined) ? child.x0 : child.x;
	        var y0 = (child.y0 !== undefined) ? child.y0 : child.y;
	        maxX = Math.max(maxX, x0);
	        maxY = Math.max(maxY, y0);
	    }

	    var width = maxX + this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
	    var height = maxY + this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;

	    // Ignore fixedWidth, and fixedHeight
	    if ((this.width !== width) || (this.height !== height)) {
	        this.dirty = true;
	        this.setCanvasSize(width, height);
	    }
	    return this;
	};

	var GetCharChildIndex = function (charIndex, activeOnly) {
	    if (activeOnly === undefined) {
	        activeOnly = true;
	    }

	    var children = this.children;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        if (activeOnly && !child.active) {
	            continue;
	        }

	        if (IsChar(child) && !child.removed) {
	            if (charIndex === 0) {
	                return i;
	            } else {
	                charIndex--;
	            }
	        }
	    }

	    return undefined;
	};

	var GetCharChild = function (charIndex, activeOnly) {
	    if (activeOnly === undefined) {
	        activeOnly = true;
	    }

	    var children = this.children;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        if (activeOnly && !child.active) {
	            continue;
	        }

	        if (IsChar(child) && !child.removed) {
	            if (charIndex === 0) {
	                return child;
	            } else {
	                charIndex--;
	            }
	        }
	    }

	    return undefined;
	};

	var GetCharIndex = function (childIndex, activeOnly) {
	    if (typeof (childIndex) !== 'number') {
	        childIndex = this.children.indexOf(childIndex);
	        if (childIndex < 0) {
	            return null;
	        }
	    }

	    if (activeOnly === undefined) {
	        activeOnly = true;
	    }

	    var children = this.children;
	    if (childIndex >= children.length) {
	        childIndex = children.length;
	    }
	    var charIndex = 0;
	    for (var i = 0; i < childIndex; i++) {
	        var child = children[i];
	        if (activeOnly && !child.active) {
	            continue;
	        }

	        if (IsChar(child) && !child.removed) {
	            charIndex++;
	        }
	    }

	    return charIndex;
	};

	var SetChildrenInteractiveEnable = function (enable) {
	    if (enable === undefined) {
	        enable = true;
	    }

	    if (this.childrenInteractiveEnable !== enable) {
	        this.lastOverChild = null;
	    }

	    this.childrenInteractiveEnable = enable;

	    return this;
	};

	var GetFirstChildContains = function (children, x, y) {
	    var children = children;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        if (!child.active || !child.renderable) {
	            continue;
	        }
	        if (child.contains(x, y)) {
	            return child;
	        }
	    }
	    return null;
	};

	var SetChildrenInteractive = function () {
	    this
	        .on('pointerdown', OnPointerDown, this)

	        .on('pointerdown', OnPointerUp, this)

	        .on('pointermove', OnPointOverOut, this)
	        .on('pointerover', OnPointOverOut, this)
	        .on('pointerout', function (pointer, event) {
	            OnPointOverOut.call(this, pointer, null, null, event);
	        }, this);

	    return this;
	};

	var OnPointerDown = function (pointer, localX, localY, event) {
	    if (!this.childrenInteractiveEnable) {
	        return;
	    }

	    var child = GetFirstChildContains(this.children, localX, localY);
	    if (!child) {
	        return;
	    }

	    this.emit('child.pointerdown', child, pointer, localX, localY, event);
	};

	var OnPointerUp = function (pointer, localX, localY, event) {
	    if (!this.childrenInteractiveEnable) {
	        return;
	    }

	    var child = GetFirstChildContains(this.children, localX, localY);
	    if (!child) {
	        return;
	    }

	    this.emit('child.pointerup', child, pointer, localX, localY, event);
	};

	var OnPointOverOut = function (pointer, localX, localY, event) {
	    if (!this.childrenInteractiveEnable) {
	        return;
	    }

	    if (localX === null) {  // Case of pointerout
	        if (this.lastOverChild !== null) {
	            this.emit('child.pointerout', this.lastOverChild, pointer, localX, localY, event);
	            this.lastOverChild = null;
	        }
	        return;
	    }

	    var child = GetFirstChildContains(this.children, localX, localY);
	    if (child === this.lastOverChild) {
	        return;
	    }

	    if (this.lastOverChild !== null) {
	        this.emit('child.pointerout', this.lastOverChild, pointer, localX, localY, event);
	    }

	    if (child !== null) {
	        this.emit('child.pointerover', child, pointer, localX, localY, event);
	    }

	    this.lastOverChild = child;
	};

	const GameObject$2 = Phaser.GameObjects.GameObject;

	var SetInteractive$1 = function (hitArea, hitAreaCallback, dropZone) {
	    var isInteractived = !!this.input;

	    GameObject$2.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);

	    if (!isInteractived) {
	        SetChildrenInteractive.call(this);
	    }

	    return this;
	};

	const BringToTop = Phaser.Utils.Array.BringToTop;
	const SendToBack = Phaser.Utils.Array.SendToBack;
	const MoveUp = Phaser.Utils.Array.MoveUp;
	const MoveDown = Phaser.Utils.Array.MoveDown;
	const MoveAbove = Phaser.Utils.Array.MoveAbove;
	const MoveBelow = Phaser.Utils.Array.MoveBelow;

	var MoveChildMethods = {
	    moveChildToFist(child) {
	        SendToBack(this.children, child);
	        return this;
	    },

	    moveChildToLast(child) {
	        BringToTop(this.children, child);
	        return this;
	    },
	    movechildUp(child) {
	        MoveUp(this.children, child);
	        return this;
	    },

	    movechildDown(child) {
	        MoveDown(this.children, child);
	        return this;
	    },

	    movechildAbove(child, baseChild) {
	        MoveAbove(this.children, child, baseChild);
	        return this;
	    },

	    movechildBelow(child, baseChild) {
	        MoveBelow(this.children, child, baseChild);
	        return this;
	    },

	};

	var BackgroundMethods = {
	    setBackgroundColor(color, color2, isHorizontalGradient) {
	        this.background.setColor(color, color2, isHorizontalGradient);
	        return this;
	    },

	    setBackgroundStroke(color, lineWidth) {
	        this.background.setStroke(color, lineWidth);
	        return this;
	    },

	    setBackgroundCornerRadius(radius, iteration) {
	        this.background.setCornerRadius(radius, iteration);
	        return this;
	    }
	};

	var InnerBoundsMethods = {
	    setInnerBoundsColor(color, color2, isHorizontalGradient) {
	        this.innerBounds.setColor(color, color2, isHorizontalGradient);
	        return this;
	    },

	    setInnerBoundsStroke(color, lineWidth) {
	        this.innerBounds.setStroke(color, lineWidth);
	        return this;
	    },
	};

	var Methods$8 = {
	    setFixedSize: SetFixedSize,
	    setPadding: SetPadding,
	    getPadding: GetPadding,
	    modifyTextStyle: ModifyTextStyle,
	    modifyDefaultTextStyle: ModifyDefaultTextStyle,
	    resetTextStyle: ResetTextStyle,
	    setTestString: SetTestString,

	    removeChild: RemoveChild,
	    removeChildren: RemoveChildren,
	    popChild: PopChild,
	    clearContent: ClearContent,
	    addChild: AddChild$1,
	    createCharChild: CreateCharChild,
	    createCharChildren: CreateCharChildren,
	    setText: SetText$3,
	    appendText: AppendText,
	    insertText: InsertText,
	    removeText: RemoveText,
	    getText: GetText,
	    createImageChild: CreateImageChild,
	    appendImage: AppendImage,
	    createDrawerChild: CreateDrawerChild,
	    appendDrawer: AppendDrawer,
	    createSpaceChild: CreateSpaceChild,
	    appendSpace: AppendSpace,
	    createCommandChild: CreateCommandChild,
	    appendCommand: AppendCommand,

	    setWrapConfig: SetWrapConfig,
	    runWordWrap: RunWordWrap,
	    runVerticalWrap: RunVerticalWrap,
	    runWrap: RunWrap,
	    renderContent: RenderContent,

	    forEachChild: ForEachChild,
	    forEachRenderableChild: ForEachRenderableChild,
	    forEachCharChild: ForEachCharChild,
	    getChildren: GetChildren,
	    getActiveChildren: GetActiveChildren,
	    getCharChildren: GetCharChildren,
	    getLastAppendedChildren: GetLastAppendedChildren,
	    getNearestChild: GetNearestChild,
	    getCharWorldPosition: GetCharWorldPosition,

	    setToMinSize: SetToMinSize,

	    getCharChildIndex: GetCharChildIndex,
	    getCharChild: GetCharChild,
	    getCharIndex: GetCharIndex,


	    setChildrenInteractiveEnable: SetChildrenInteractiveEnable,
	    setInteractive: SetInteractive$1,
	};

	Object.assign(
	    Methods$8,

	    MoveChildMethods,
	    BackgroundMethods,
	    InnerBoundsMethods,
	    SetAlignMethods,
	    SetTextOXYMethods$1,

	);

	const GetFastValue$1 = Phaser.Utils.Objects.GetFastValue;

	var Pools = {};
	class PoolManager {
	    constructor(config) {
	        this.pools = GetFastValue$1(config, 'pools', Pools);
	    }

	    free(bob) {
	        if (!this.pools) {
	            return this;
	        }

	        var bobType = bob.type;
	        if (!this.pools.hasOwnProperty(bobType)) {
	            this.pools[bobType] = new Stack();
	        }
	        this.pools[bobType].push(bob);
	        bob.onFree();
	        return this;
	    }

	    freeMultiple(arr) {
	        if (!this.pools) {
	            return this;
	        }

	        for (var i = 0, cnt = arr.length; i < cnt; i++) {
	            this.free(arr[i]);
	        }
	        return this;
	    }

	    allocate(bobType) {
	        if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
	            return null;
	        }
	        return this.pools[bobType].pop();
	    }
	}

	const IsPlainObject$j = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$Z = Phaser.Utils.Objects.GetValue;

	class DynamicText extends Canvas {
	    constructor(scene, x, y, fixedWidth, fixedHeight, resolution, config) {
	        if (IsPlainObject$j(x)) {
	            config = x;
	            x = GetValue$Z(config, 'x', 0);
	            y = GetValue$Z(config, 'y', 0);
	            fixedWidth = GetValue$Z(config, 'width', 0);
	            fixedHeight = GetValue$Z(config, 'height', 0);
	            resolution = GetValue$Z(config, 'resolution', 1);
	        } else if (IsPlainObject$j(fixedWidth)) {
	            config = fixedWidth;
	            fixedWidth = GetValue$Z(config, 'width', 0);
	            fixedHeight = GetValue$Z(config, 'height', 0);
	            resolution = GetValue$Z(config, 'resolution', 1);
	        } else if (IsPlainObject$j(resolution)) {
	            config = resolution;
	            resolution = GetValue$Z(config, 'resolution', 1);
	        }

	        var width = (fixedWidth === 0) ? 1 : fixedWidth;
	        var height = (fixedHeight === 0) ? 1 : fixedHeight;
	        super(scene, x, y, width, height, resolution);
	        this.type = 'rexDynamicText';
	        this.autoRound = true;
	        this.padding = SetPadding$1();
	        this.wrapPadding = SetPadding$1();

	        var textStyleConfig = GetValue$Z(config, 'style', undefined);
	        this.defaultTextStyle = new TextStyle$1(null, textStyleConfig);
	        this.textStyle = this.defaultTextStyle.clone();
	        this.setTestString(GetValue$Z(config, 'testString', '|MÉqgy'));

	        this._textOX = 0;
	        this._textOY = 0;
	        this.background = new Background(this, GetValue$Z(config, 'background', undefined));
	        this.innerBounds = new InnerBounds(this, GetValue$Z(config, 'innerBounds', undefined));
	        this.children = [];
	        this.lastAppendedChildren = [];
	        this.lastOverChild = null;
	        this.poolManager = new PoolManager(config);

	        this.setFixedSize(fixedWidth, fixedHeight);
	        this.setPadding(GetValue$Z(config, 'padding', 0));
	        this.setWrapConfig(GetValue$Z(config, 'wrap', undefined));
	        this.setChildrenInteractiveEnable(GetValue$Z(config, 'childrenInteractive', false));

	        var text = GetValue$Z(config, 'text', undefined);
	        if (text) {
	            this.setText(text);
	        }
	    }

	    updateTexture() {
	        super.updateTexture(function () {
	            this.renderContent();
	        }, this);
	        return this;
	    }

	    get text() {
	        return this.getText(true);
	    }

	    set text(value) {
	        this.setText(value);
	    }

	    setSize(width, height) {
	        this.setFixedSize(width, height);
	        return this;
	    }

	    get textOX() {
	        return this._textOX;
	    }

	    set textOX(value) {
	        this.setTextOX(value);
	    }

	    get textOY() {
	        return this._textOY;
	    }

	    set textOY(value) {
	        this.setTextOY(value);
	    }
	}

	Object.assign(
	    DynamicText.prototype,
	    Methods$8
	);

	var TextRunWidthWrap = function (textObject) {
	    var RunWidthWrap = function (width) {
	        var padding = textObject.padding;
	        var wrapWidth = width - ((padding.left + padding.right) * textObject.scaleX);
	        var style = textObject.style;
	        if (IsTextGameObject(textObject)) {
	            style.wordWrapWidth = wrapWidth;
	            style.maxLines = 0;
	        } else {  // BBCode text, Tag text
	            if (style.wrapMode === 0) { // Turn no-wrap to word-wrap
	                style.wrapMode = 1;
	            }
	            style.wrapWidth = wrapWidth;
	            style.maxLines = 0;
	        }
	        style.fixedWidth = width;
	        style.fixedHeight = 0;
	        textObject.updateText();  // Redraw text

	        textObject.minHeight = textObject.height;
	        return textObject;
	    };
	    return RunWidthWrap;
	};

	var DynamicTextRunWidthWrap = function (textObject) {
	    var RunWidthWrap = function (width) {
	        textObject
	            .setFixedSize(width, 0)
	            .runWordWrap();

	        textObject.minHeight = textObject.height;
	        return textObject;
	    };
	    return RunWidthWrap;
	};

	var BitmapTextRunWidthWrap = function (textObject) {
	    var RunWidthWrap = function (width) {
	        textObject.setMaxWidth(width);

	        textObject.minHeight = textObject.height;
	        return textObject;
	    };
	    return RunWidthWrap;
	};

	var IsDynamicTextGameObject = function (gameObject) {
	    return (gameObject instanceof DynamicText);
	};

	var WrapExpandText = function (textObject, minWidth) {
	    if (minWidth === undefined) {
	        minWidth = 0;
	    }

	    textObject._minWidth = minWidth;

	    textObject.runWidthWrap =
	        IsDynamicTextGameObject(textObject) ? DynamicTextRunWidthWrap(textObject) :
	            IsBitmapTextGameObject(textObject) ? BitmapTextRunWidthWrap(textObject) :
	                TextRunWidthWrap(textObject);

	    return textObject;
	};

	const MaxTestCount = 65535;

	var FontSizeFit = function (textObject, width, height) {
	    if (width == null) {
	        // Do nothing if invalid width input
	        return textObject;
	    }
	    if (width === 0) {
	        SetTextWidth(textObject, 0, height);
	        return textObject;
	    }

	    var textLength = textObject.text.length;
	    if (textLength === 0) {
	        SetTextWidth(textObject, width, height);
	        return textObject;
	    }

	    var fontSize = Math.floor(width * 1.5 / textLength);
	    if (height !== undefined) {
	        if (fontSize > height) {
	            fontSize = Math.floor(height);
	        }
	    }

	    var sizeData = {};
	    var testResult = TestFontSize(textObject, fontSize, width, height, sizeData);
	    for (var i = 0; i <= MaxTestCount; i++) {
	        if (testResult === 0) {
	            break;
	        } else {
	            fontSize += testResult;
	            if (fontSize < 0) {
	                fontSize = 0;
	                break;
	            }
	        }
	        testResult = TestFontSize(textObject, fontSize, width, height, sizeData);
	        // console.log(fontSize, testResult)
	    }

	    if (i === MaxTestCount) {
	        console.warn(`FontSizeFit: Test count exceeds ${MaxTestCount}`);
	    }

	    textObject.setFontSize(fontSize);
	    SetTextWidth(textObject, width, height);

	    return textObject;
	};

	var GetTextSize = function (textObject, fontSize, sizeData) {
	    if (sizeData[fontSize] === undefined) {
	        textObject.setFontSize(fontSize);
	        sizeData[fontSize] = {
	            width: textObject.width,
	            height: textObject.height
	        };
	    }

	    return sizeData[fontSize]
	};

	var TestFontSize = function (textObject, fontSize, width, height, sizeData) {
	    var textSize = GetTextSize(textObject, fontSize, sizeData);
	    var textSize1 = GetTextSize(textObject, fontSize + 1, sizeData);

	    var deltaHeight;
	    if (height !== undefined) {
	        // Clamp by height
	        if ((textSize.height <= height) && (textSize1.height > height)) {
	            deltaHeight = 0;

	        } else if (textSize.height > height) { // Reduce font size
	            return -1;

	        } else {
	            // Increase font size
	            deltaHeight = Math.floor(height - textSize.height);
	        }
	    }

	    // Clamp by width
	    var deltaWidth;
	    if ((textSize.width <= width) && (textSize1.width > width)) {
	        return 0;

	    } else if (textSize.width > width) {  // Reduce font size
	        return -1;

	    } else {
	        // Increase font size
	        var deltaWidth = Math.floor(width - textSize.width);
	        if (deltaHeight === undefined) {
	            return deltaWidth;
	        } else {
	            return Math.min(deltaWidth, deltaHeight);
	        }
	    }
	};

	var SetTextWidth = function (textObject, width, height) {
	    var style = textObject.style;

	    if (!style) {
	        // BitmapText game object does not have style property
	        return;
	    }

	    style.fixedWidth = width;
	    style.parent.width = width;

	    if (height !== undefined) {
	        style.fixedHeight = height;
	        style.parent.height = height;
	    }

	    style.update(false);
	};

	const GetValue$Y = Phaser.Utils.Objects.GetValue;

	var FontSizeExpandText = function (textObject, config) {
	    if (typeof (config) === 'number') {
	        config = {
	            minWidth: config
	        };
	    }

	    var minWidth = GetValue$Y(config, 'minWidth', 0);
	    var minHeight = GetValue$Y(config, 'minHeight', 0);
	    var fitHeight = GetValue$Y(config, 'fitHeight', false);

	    textObject._minWidth = minWidth;
	    textObject._minHeight = minHeight;

	    if (!fitHeight) {
	        // Set font size to fit width only
	        textObject.runWidthWrap = function (width) {
	            if (textObject.setFixedSize) {
	                textObject.setFixedSize(0, 0);
	            }
	            FontSizeFit(textObject, width, undefined);
	            return textObject;
	        };
	        textObject.resize = function (width, height) {
	            if ((textObject.width === width) && (textObject.height === height)) {
	                return textObject;
	            }

	            // Font size is set under runWidthWrap/FontSizeFit
	            textObject.setFixedSize(width, height);
	            return textObject;
	        };

	    } else {
	        // Set font size to fit width and height
	        textObject.runWidthWrap = function (width) {
	            // Minimun text size
	            if (textObject.setFixedSize) {
	                textObject.setFixedSize(0, 0);
	            }

	            textObject.setFontSize(1);
	            return textObject;
	        };
	        textObject.resize = function (width, height) {
	            FontSizeFit(textObject, width, height);
	            return textObject;
	        };
	    }

	    return textObject;
	};

	const GetValue$X = Phaser.Utils.Objects.GetValue;
	const LayoutCallbacks = [LayoutMode0, LayoutMode1];

	class TitleLabel extends LabelBase {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        // Create sizer
	        super(scene, config);
	        this.type = 'rexTitleLabel';

	        // Add Background
	        var background = GetValue$X(config, 'background', undefined);
	        if (background) {
	            this.addBackground(background);
	        }

	        // Wrap title, text
	        var title = GetValue$X(config, 'title', undefined);
	        var text = GetValue$X(config, 'text', undefined);

	        if (title) {
	            var wrapTitle = GetValue$X(config, 'wrapTitle', false);
	            var adjustTitleFontSize = GetValue$X(config, 'adjustTitleFontSize', false);
	            if (wrapTitle) {
	                if (wrapTitle === true) {
	                    wrapTitle = 'word';
	                }

	                SetWrapMode(title, wrapTitle);
	                config.expandTitleWidth = true;
	                WrapExpandText(title);

	            } else if (adjustTitleFontSize) {
	                config.expandTextWidth = true;
	                config.expandTextHeight = true;
	                FontSizeExpandText(title, { fitHeight: true });

	            }
	        }

	        if (text) {
	            var wrapText = GetValue$X(config, 'wrapText', false);
	            var adjustTextFontSize = GetValue$X(config, 'adjustTextFontSize', false);
	            if (wrapText) {
	                if (wrapText === true) {
	                    wrapText = 'word';
	                }

	                SetWrapMode(text, wrapText);
	                config.expandTextWidth = true;
	                WrapExpandText(text);

	            } else if (adjustTextFontSize) {
	                config.expandTextWidth = true;
	                config.expandTextHeight = true;
	                FontSizeExpandText(text, { fitHeight: true });

	            }
	        }

	        var layoutMode = GetValue$X(config, 'layoutMode', 0);
	        var layoutCallback = LayoutCallbacks[layoutMode] || LayoutCallbacks[0];
	        layoutCallback.call(this, config);

	        // Elements : title, separator, innerBackground,
	        //            icon, iconMask, text, action, actionMask, background
	        //            innerSizer
	        this.addChildrenMap('background', config.background);

	    }

	    // Access title game object
	    get title() {
	        var textObject = this.childrenMap.title;
	        if (!textObject) {
	            return '';
	        }
	        return textObject.title;
	    }

	    set title(value) {
	        var textObject = this.childrenMap.title;
	        if (!textObject) {
	            return;
	        }
	        textObject.setText(value);
	    }

	    setTitle(value) {
	        this.title = value;
	        return this;
	    }

	    resetDisplayContent(config) {
	        if (config === undefined) {
	            config = {};
	        } else if (typeof (config) === 'string') {
	            config = {
	                text: config,
	            };
	        }

	        super.resetDisplayContent(config);

	        var textObject = this.childrenMap.title;
	        if (textObject) {
	            if (config.title === undefined) ; else if (config.title) {
	                this.show(textObject);
	                this.setTitle(config.title);
	            } else { // false, null
	                this.hide(textObject);
	            }
	        }

	        return this;
	    }
	}

	class TextBox extends TextBoxBase(TitleLabel) {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        if (!config.hasOwnProperty('layoutMode')) {
	            config.layoutMode = 1;
	        }

	        super(scene, config);
	    }
	}

	const GetCalcMatrix = Phaser.GameObjects.GetCalcMatrix;

	var PolygonWebGLRenderer = function (renderer, src, camera, parentMatrix) {    
	    if (src.dirty) {
	        src.updateData();
	        src.dirty = false;
	    }

	    camera.addToRenderList(src);

	    var pipeline = renderer.pipelines.set(src.pipeline);

	    var result = GetCalcMatrix(src, camera, parentMatrix);

	    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

	    var dx = src._displayOriginX;
	    var dy = src._displayOriginY;

	    var alpha = camera.alpha * src.alpha;

	    renderer.pipelines.preBatch(src);

	    if (src.isFilled) {
	        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
	    }

	    if (src.isStroked) {
	        StrokePathWebGL(pipeline, src, alpha, dx, dy);
	    }

	    renderer.pipelines.postBatch(src);
	};

	const SetTransform = Phaser.Renderer.Canvas.SetTransform;

	var PolygonCanvasRenderer = function (renderer, src, camera, parentMatrix) {
	    if (src.dirty) {
	        src.updateData();
	        src.dirty = false;
	    }

	    camera.addToRenderList(src);

	    var ctx = renderer.currentContext;

	    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
	        var dx = src._displayOriginX;
	        var dy = src._displayOriginY;

	        var path = src.pathData;
	        var pathLength = path.length - 1;

	        var px1 = path[0] - dx;
	        var py1 = path[1] - dy;

	        ctx.beginPath();

	        ctx.moveTo(px1, py1);

	        if (!src.closePath) {
	            pathLength -= 2;
	        }

	        for (var i = 2; i < pathLength; i += 2) {
	            var px2 = path[i] - dx;
	            var py2 = path[i + 1] - dy;

	            ctx.lineTo(px2, py2);
	        }

	        ctx.closePath();

	        if (src.isFilled) {
	            FillStyleCanvas(ctx, src);

	            ctx.fill();
	        }

	        if (src.isStroked) {
	            LineStyleCanvas(ctx, src);

	            ctx.stroke();
	        }

	        //  Restore the context saved in SetTransform
	        ctx.restore();
	    }
	};

	var Render$1 = {
	    renderWebGL: PolygonWebGLRenderer,
	    renderCanvas: PolygonCanvasRenderer

	};

	const Shape = Phaser.GameObjects.Shape;

	class PolygnBase extends Shape {
	    get fillColor() {
	        return this._fillColor;
	    }

	    set fillColor(value) {
	        this._fillColor = value;
	        this.isFilled = (value != null) && (this._fillAlpha > 0);
	    }

	    get fillAlpha() {
	        return this._fillAlpha;
	    }

	    set fillAlpha(value) {
	        this._fillAlpha = value;
	        this.isFilled = (value > 0) && (this._fillColor != null);
	    }

	    // Fully override setFillStyle method
	    setFillStyle(color, alpha) {
	        if (alpha === undefined) {
	            alpha = 1;
	        }

	        this.fillColor = color;
	        this.fillAlpha = alpha;

	        return this;
	    }

	    get strokeColor() {
	        return this._strokeColor;
	    }

	    set strokeColor(value) {
	        this._strokeColor = value;
	        this.isStroked = (value != null) && (this._strokeAlpha > 0) && (this._lineWidth > 0);
	    }

	    get strokeAlpha() {
	        return this._strokeAlpha;
	    }

	    set strokeAlpha(value) {
	        this._strokeAlpha = value;
	        this.isStroked = (value > 0) && (this._strokeColor != null) && (this._lineWidth > 0);
	    }

	    get lineWidth() {
	        return this._lineWidth;
	    }

	    set lineWidth(value) {
	        this._lineWidth = value;
	        this.isStroked = (value > 0) && (this._strokeColor != null);
	    }

	    // Fully override setStrokeStyle method
	    setStrokeStyle(lineWidth, color, alpha) {
	        if (alpha === undefined) {
	            alpha = 1;
	        }

	        this.lineWidth = lineWidth;
	        this.strokeColor = color;
	        this.strokeAlpha = alpha;

	        return this;
	    }

	    updateData() {
	        return this;
	    }

	    get width() {
	        return this.geom.width;
	    }
	    set width(value) {
	        this.resize(value, this.height);
	    }

	    get height() {
	        return this.geom.height;
	    }
	    set height(value) {
	        this.resize(this.width, value);
	    }

	    setSize(width, height) {
	        var input = this.input;
	        if (input && !input.customHitArea) {
	            input.hitArea.width = width;
	            input.hitArea.height = height;
	        }
	        return this;
	    }

	    resize(width, height) {
	        this.setSize(width, height);
	        return this;
	    }

	}

	Object.assign(
	    PolygnBase.prototype,
	    Render$1
	);

	var IsArcCorner = function (radius) {
	    return ((radius.x > 0) && (radius.y > 0));
	};

	const IsPlainObject$i = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$W = Phaser.Utils.Objects.GetValue;
	const Earcut = Phaser.Geom.Polygon.Earcut;

	class RoundRectangle extends PolygnBase {
	    constructor(scene, x, y, width, height, radiusConfig, fillColor, fillAlpha) {
	        var strokeColor, strokeAlpha, strokeWidth, shapeType;
	        if (IsPlainObject$i(x)) {
	            var config = x;

	            x = config.x;
	            y = config.y;
	            width = config.width;
	            height = config.height;
	            radiusConfig = config.radius;
	            fillColor = config.color;
	            fillAlpha = config.alpha;

	            strokeColor = config.strokeColor;
	            strokeAlpha = config.strokeAlpha;
	            strokeWidth = config.strokeWidth;

	            shapeType = config.shape;
	        }

	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 1; }
	        if (height === undefined) { height = width; }
	        if (radiusConfig === undefined) { radiusConfig = 0; }
	        if (shapeType === undefined) { shapeType = 0; }

	        var geom = new RoundRectangle$1();  // Configurate it later
	        super(scene, 'rexRoundRectangleShape', geom);

	        this.setShapeType(shapeType);

	        if (this.shapeType === 0) {
	            var radius = GetValue$W(radiusConfig, 'radius', radiusConfig);
	            geom.setTo(0, 0, width, height, radius);
	        } else {
	            var radius = { x: (width / 2), y: (height / 2) };
	            geom.setTo(0, 0, width, height, radius);
	        }

	        this.setIteration(GetValue$W(radiusConfig, 'iteration', undefined));
	        this.setPosition(x, y);

	        this.setFillStyle(fillColor, fillAlpha);

	        if (strokeWidth === undefined) {
	            strokeWidth = 2;
	        }
	        this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);

	        this.updateDisplayOrigin();
	        this.dirty = true;
	    }

	    updateData() {
	        var geom = this.geom;
	        var pathData = this.pathData;

	        pathData.length = 0;

	        var width = geom.width,
	            height = geom.height,
	            cornerRadius = geom.cornerRadius,
	            radius,
	            iteration = this.iteration + 1;

	        // Top-left
	        radius = cornerRadius.tl;
	        if (IsArcCorner(radius)) {
	            if (radius.convex) {
	                var centerX = radius.x;
	                var centerY = radius.y;
	                ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 270, false, iteration, pathData);
	            } else {
	                var centerX = 0;
	                var centerY = 0;
	                ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 0, true, iteration, pathData);
	            }
	        } else {
	            LineTo(0, 0, pathData);
	        }

	        // Top-right
	        radius = cornerRadius.tr;
	        if (IsArcCorner(radius)) {
	            if (radius.convex) {
	                var centerX = width - radius.x;
	                var centerY = radius.y;
	                ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 360, false, iteration, pathData);
	            } else {
	                var centerX = width;
	                var centerY = 0;
	                ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 90, true, iteration, pathData);
	            }
	        } else {
	            LineTo(width, 0, pathData);
	        }

	        // Bottom-right
	        radius = cornerRadius.br;
	        if (IsArcCorner(radius)) {
	            if (radius.convex) {
	                var centerX = width - radius.x;
	                var centerY = height - radius.y;
	                ArcTo$1(centerX, centerY, radius.x, radius.y, 0, 90, false, iteration, pathData);
	            } else {
	                var centerX = width;
	                var centerY = height;
	                ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 180, true, iteration, pathData);
	            }
	        } else {
	            LineTo(width, height, pathData);
	        }

	        // Bottom-left
	        radius = cornerRadius.bl;
	        if (IsArcCorner(radius)) {
	            if (radius.convex) {
	                var centerX = radius.x;
	                var centerY = height - radius.y;
	                ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 180, false, iteration, pathData);
	            } else {
	                var centerX = 0;
	                var centerY = height;
	                ArcTo$1(centerX, centerY, radius.x, radius.y, 360, 270, true, iteration, pathData);
	            }
	        } else {
	            LineTo(0, height, pathData);
	        }

	        pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
	        this.pathIndexes = Earcut(pathData);
	        return this;
	    }

	    setShapeType(shapeType) {
	        if (typeof (shapeType) === 'string') {
	            shapeType = ShapeTypeMap[shapeType];
	        }

	        this.shapeType = shapeType;
	        return this;
	    }

	    setSize(width, height) {
	        // Override Shape's setSize method
	        if (height === undefined) {
	            height = width;
	        }
	        if ((this.geom.width === width) && (this.geom.height === height)) {
	            return this;
	        }
	        this.geom.setSize(width, height);

	        if (this.shapeType === 1) {
	            this.setRadius({ x: (width / 2), y: (height / 2) });
	        }

	        this.updateDisplayOrigin();
	        this.dirty = true;

	        super.setSize(width, height);
	        return this;
	    }

	    get radius() {
	        return this.geom.radius;
	    }

	    set radius(value) {
	        this.geom.setRadius(value);
	        this.updateDisplayOrigin();
	        this.dirty = true;
	    }

	    get radiusTL() {
	        return this.geom.radiusTL;
	    }

	    set radiusTL(value) {
	        this.geom.radiusTL = value;
	        this.dirty = true;
	    }

	    get radiusTR() {
	        return this.geom.radiusTR;
	    }

	    set radiusTR(value) {
	        this.geom.radiusTR = value;
	        this.dirty = true;
	    }

	    get radiusBL() {
	        return this.geom.radiusBL;
	    }

	    set radiusBL(value) {
	        this.geom.radiusBL = value;
	        this.dirty = true;
	    }

	    get radiusBR() {
	        return this.geom.radiusBR;
	    }

	    set radiusBR(value) {
	        this.geom.radiusBR = value;
	        this.dirty = true;
	    }

	    setRadius(value) {
	        if (value === undefined) {
	            value = 0;
	        }
	        this.radius = value;
	        return this;
	    }

	    setRadiusTL(value) {
	        if (value === undefined) {
	            value = 0;
	        }
	        this.radiusTL = value;
	        return this;
	    }

	    setRadiusTR(value) {
	        if (value === undefined) {
	            value = 0;
	        }
	        this.radiusTR = value;
	        return this;
	    }

	    setRadiusBL(value) {
	        if (value === undefined) {
	            value = 0;
	        }
	        this.radiusBL = value;
	        return this;
	    }

	    setRadiusBR(value) {
	        if (value === undefined) {
	            value = 0;
	        }
	        this.radiusBR = value;
	        return this;
	    }

	    get cornerRadius() {
	        return this.geom.cornerRadius;
	    }

	    set cornerRadius(value) {
	        this.radius = value;
	    }

	    setCornerRadius(value) {
	        return this.setRadius(value);
	    }

	    get iteration() {
	        return this._iteration;
	    }

	    set iteration(value) {
	        // Set iteration first time
	        if (this._iteration === undefined) {
	            this._iteration = value;
	            return;
	        }

	        // Change iteration value
	        if (this._iteration === value) {
	            return;
	        }

	        this._iteration = value;
	        this.dirty = true;
	    }

	    setIteration(iteration) {
	        if (iteration === undefined) {
	            iteration = 6;
	        }
	        this.iteration = iteration;
	        return this;
	    }

	}

	const ShapeTypeMap = {
	    rectangle: 0,
	    circle: 1
	};

	var ExtractByPrefix = function (obj, prefix, delimiter, out) {
	    if (delimiter === undefined) {
	        delimiter = '.';
	    }

	    if (out === undefined) {
	        out = {};
	    }

	    if (!obj) {
	        return out;
	    }

	    if (prefix in obj) {
	        return Object.assign(out, obj[prefix])
	    }

	    prefix += delimiter;

	    for (var key in obj) {
	        if (!key.startsWith(prefix)) {
	            continue;
	        }

	        out[key.replace(prefix, '')] = obj[key];
	    }

	    return out;
	};

	var GetPartialData = function (obj, keys, out) {
	    if (out === undefined) {
	        out = {};
	    }

	    if (Array.isArray(keys)) {
	        var key;
	        for (var i = 0, cnt = keys.length; i < cnt; i++) {
	            key = keys[i];
	            out[key] = obj[key];
	        }
	    } else {
	        for (var key in keys) {
	            out[key] = obj[key];
	        }
	    }

	    return out;
	};

	const GetValue$V = Phaser.Utils.Objects.GetValue;

	class StyleManager extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        this.style = GetValue$V(config, 'style', this);

	        var propertiesMap = GetValue$V(config, 'propertiesMap');
	        this.activeStyle = ExtractStyle(config, 'active', propertiesMap);
	        this.hoverStyle = ExtractStyle(config, 'hover', propertiesMap);
	        this.disableStyle = ExtractStyle(config, 'disable', propertiesMap);

	        this.onModifyStyle = GetValue$V(config, 'onModifyStyle');
	    }

	    getStyle(keys) {
	        return GetPartialData(this.style, keys);
	    }

	    modifyStyle(style) {
	        for (var key in style) {
	            this.style[key] = style[key];
	        }

	        if (this.onModifyStyle) {
	            this.onModifyStyle(this.parent, style);
	        }

	        return this;
	    }

	    applyStyle(newStyle) {
	        if (!newStyle) {
	            return undefined;
	        }

	        var currentStyle = this.getStyle(newStyle);
	        if (!IsKeyValueEqual(currentStyle, newStyle)) {
	            this.modifyStyle(newStyle);
	            return currentStyle;
	        } else {
	            return undefined;
	        }
	    }

	    setActiveState(enable) {
	        SetStateEnableMethod.call(this, 'active', enable);
	        return this;
	    }

	    setHoverState(enable) {
	        SetStateEnableMethod.call(this, 'hover', enable);
	        return this;
	    }

	    setDisableState(enable) {
	        SetStateEnableMethod.call(this, 'disable', enable);
	        return this;
	    }
	}

	var ExtractStyle = function (config, prefix, propertiesMap) {
	    var result = ExtractByPrefix(config, prefix);

	    if (propertiesMap) {
	        for (var name in result) {
	            if (propertiesMap.hasOwnProperty(name)) {
	                result[propertiesMap[name]] = result[name];
	                delete result[name];
	            }
	        }
	    }

	    return result;
	};

	var SetStateEnableMethod = function (stateName, enable) {
	    if (enable === undefined) {
	        enable = true;
	    }

	    var stateVarName = `${stateName}State`;
	    var styleVarName = `${stateName}Style`;
	    var styleSaveVarName = `${stateName}StyleSave`;

	    if (this[stateVarName] === enable) {
	        return;
	    }

	    this[stateVarName] = enable;

	    if (enable) {
	        this[styleSaveVarName] = this.applyStyle(this[styleVarName]);
	    } else {
	        this.applyStyle(this[styleSaveVarName]);
	        this[styleSaveVarName] = undefined;
	    }
	};

	var HelperMethods = {
	    addStyleManager(config) {
	        this.styleManager = new StyleManager(this, config);
	        return this;
	    },

	    setActiveState(enable) {
	        this.styleManager.setActiveState(enable);
	        return this;
	    },

	    setHoverState(enable) {
	        this.styleManager.setHoverState(enable);
	        return this;
	    },

	    setDisableState(enable) {
	        this.styleManager.setDisableState(enable);
	        return this;
	    }
	};

	class StatesRoundRectangle extends RoundRectangle {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }
	        super(scene, config);
	        this.type = 'rexStatesRoundRectangleShape';

	        config.style = this;
	        config.propertiesMap = PropertiesMap$1;

	        this.addStyleManager(config);

	        delete config.style;
	        delete config.propertiesMap;
	    }
	}

	const PropertiesMap$1 = {
	    color: 'fillColor',
	    alpha: 'fillAlpha',
	    // strokeColor: 'strokeColor',
	    // strokeAlpha: 'strokeAlpha',
	    strokeWidth: 'lineWidth',
	};

	Object.assign(
	    StatesRoundRectangle.prototype,
	    HelperMethods
	);

	var UpdateShapes = function () {
	    var skewX = this.skewX;
	    var width = this.width - Math.abs(skewX);
	    var height = this.height;

	    var trackFill = this.getShape('trackFill');
	    trackFill.fillStyle(this.trackColor);
	    if (trackFill.isFilled) {
	        BuildRectangle(
	            trackFill,      // lines
	            0, 0,           // x0, y0
	            width, height,  // x1, y1
	            skewX           // skewX
	        );
	    }

	    var bar = this.getShape('bar');
	    bar.fillStyle(this.barColor);
	    if (bar.isFilled) {
	        var barX0, barX1;
	        if (!this.rtl) {
	            barX0 = 0;
	            barX1 = width * this.value;
	        } else {
	            barX0 = width * (1 - this.value);
	            barX1 = width;
	        }

	        BuildRectangle(
	            bar,            // lines
	            barX0, 0,       // x0, y0
	            barX1, height,  // x1, y1
	            skewX           // skew
	        );
	    }

	    var trackStroke = this.getShape('trackStroke');
	    trackStroke.lineStyle(this.trackStrokeThickness, this.trackStrokeColor);
	    if (trackStroke.isStroked) {
	        BuildRectangle(
	            trackStroke,     // lines            
	            0, 0,           // x0, y0
	            width, height,  // x1, y1
	            skewX           // skewX
	        );
	    }
	};

	var BuildRectangle = function (lines, x0, y0, x1, y1, skewX) {
	    var startX = (x0 + x1) / 2;  // Start x from middle
	    if (skewX >= 0) {
	        lines
	            .startAt(startX + skewX, y0).lineTo(x1 + skewX, y0)
	            .lineTo(x1, y1)
	            .lineTo(x0, y1)
	            .lineTo(x0 + skewX, y0).lineTo(startX + skewX, y0);
	    } else {
	        lines
	            .startAt(startX, y0).lineTo(x1, y0)
	            .lineTo(x1 - skewX, y1)
	            .lineTo(x0 - skewX, y1)
	            .lineTo(x0, y0).lineTo(startX, y0);
	    }

	    lines.close();

	    return lines;
	};

	const GetValue$U = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$h = Phaser.Utils.Objects.IsPlainObject;

	class LineProgress extends ProgressBase(BaseShapes) {
	    constructor(scene, x, y, width, height, barColor, value, config) {
	        if (IsPlainObject$h(x)) {
	            config = x;

	            x = config.x;
	            y = config.y;
	            width = config.width;
	            height = config.height;
	            barColor = config.barColor;
	            value = config.value;
	        } else if (IsPlainObject$h(width)) {
	            config = width;

	            width = config.width;
	            height = config.height;
	            barColor = config.barColor;
	            value = config.value;
	        } else if (IsPlainObject$h(barColor)) {
	            config = barColor;

	            barColor = config.barColor;
	            value = config.value;
	        }

	        if (x === undefined) { x = 0; }
	        if (y === undefined) { y = 0; }
	        if (width === undefined) { width = 2; }
	        if (height === undefined) { height = width; }
	        if (value === undefined) { value = 0; }

	        super(scene, x, y, width, height, config);
	        this.type = 'rexLineProgress';

	        this.bootProgressBase(config);

	        this
	            .addShape((new Lines()).setName('trackFill'))
	            .addShape((new Lines()).setName('bar'))
	            .addShape((new Lines()).setName('trackStroke'));

	        this.setTrackColor(GetValue$U(config, 'trackColor', undefined));
	        this.setBarColor(barColor);
	        this.setTrackStroke(GetValue$U(config, 'trackStrokeThickness', 2), GetValue$U(config, 'trackStrokeColor', undefined));

	        this.setSkewX(GetValue$U(config, 'skewX', 0));

	        this.setRTL(GetValue$U(config, 'rtl', false));

	        this.setValue(value);
	    }

	    get trackColor() {
	        return this._trackColor;
	    }

	    set trackColor(value) {
	        this.dirty = this.dirty || (this._trackColor != value);
	        this._trackColor = value;
	    }

	    setTrackColor(color) {
	        this.trackColor = color;
	        return this;
	    }

	    get trackStrokeColor() {
	        return this._trackStrokeColor;
	    }

	    set trackStrokeColor(value) {
	        this.dirty = this.dirty || (this._trackStrokeColor != value);
	        this._trackStrokeColor = value;
	    }

	    get trackStrokeThickness() {
	        return this._trackStrokeThickness;
	    }

	    set trackStrokeThickness(value) {
	        this.dirty = this.dirty || (this._trackStrokeThickness != value);
	        this._trackStrokeThickness = value;
	    }

	    setTrackStroke(lineWidth, color) {
	        this.trackStrokeThickness = lineWidth;
	        this.trackStrokeColor = color;
	        return this;
	    }

	    get barColor() {
	        return this._barColor;
	    }

	    set barColor(value) {
	        this.dirty = this.dirty || (this._barColor != value);
	        this._barColor = value;
	    }

	    setBarColor(color) {
	        this.barColor = color;
	        return this;
	    }

	    get skewX() {
	        return this._skewX;
	    }

	    set skewX(value) {
	        this.dirty = this.dirty || (this._skewX != value);
	        this._skewX = value;
	    }

	    setSkewX(value) {
	        this.skewX = value;
	        return this;
	    }

	    get rtl() {
	        return this._rtl;
	    }

	    set rtl(value) {
	        value = !!value;
	        this.dirty = this.dirty || (this._rtl != value);
	        this._rtl = value;
	    }

	    setRTL(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.rtl = enable;
	        return this;
	    }

	}

	var Methods$7 = {
	    updateShapes: UpdateShapes,
	};

	Object.assign(
	    LineProgress.prototype,
	    Methods$7,
	);

	class StatesBarRectangle extends LineProgress {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        if (!config.hasOwnProperty('value')) {
	            config.value = 0;
	        }

	        if (!config.hasOwnProperty('hover.bar')) {
	            config['hover.bar'] = true;
	        }

	        if (!config.hasOwnProperty('easeDuration')) {
	            config.easeDuration = 200;
	        }

	        if (!config.hasOwnProperty('ease')) {
	            config.ease = 'Quad';
	        }

	        SetValue(config, 'easeValue.duration', config.easeDuration);
	        SetValue(config, 'easeValue.ease', config.ease);

	        super(scene, config);
	        this.type = 'rexStatesBarRectangleShape';

	        this.barState = false;

	        config.style = this;
	        config.propertiesMap = PropertiesMap;

	        this.addStyleManager(config);

	        delete config.style;
	        delete config.propertiesMap;
	    }

	    get bar() {
	        return this.barState;
	    }

	    set bar(value) {
	        value = !!value;
	        if (this.barState === value) {
	            return;
	        }
	        this.barState = value;
	        this.easeValueTo((this.barState) ? 1 : 0);
	    }

	}

	const PropertiesMap = {
	    color: 'trackColor',
	    strokeColor: 'trackStrokeColor',
	    strokeWidth: 'trackStrokeThickness',

	    // barColor: 'barColor'
	};

	Object.assign(
	    StatesBarRectangle.prototype,
	    HelperMethods
	);

	let Style$3 = class Style extends ComponentBase {
	    constructor(gameObject, style) {
	        super(gameObject);
	        // this.parent = gameObject;

	        return new Proxy(this, this);
	    }

	    get(target, prop) {
	        if (HasProperty(target, prop)) {
	            return target[prop];
	        }

	        var gameObject = target.parent;
	        if (HasProperty(gameObject, prop)) {
	            return gameObject[prop];
	        }
	    }

	    set(target, prop, value) {
	        if (HasProperty(target, prop)) {
	            target[prop] = value;

	        } else if (HasProperty(target.parent, prop)) {
	            target.parent[prop] = value;
	        }

	        return true;
	    }

	    get key() {
	        return this.parent.texture.key;
	    }

	    set key(value) {
	        if (this.key === value) {
	            return;
	        }
	        this.parent.setTexture(value, this.frame);
	    }

	    get frame() {
	        return this.parent.frame.name;
	    }

	    set frame(value) {
	        if (this.frame === value) {
	            return;
	        }
	        this.parent.setFrame(value);
	    }
	};

	const PhaserNineSlice = Phaser.GameObjects.NineSlice;
	const GetValue$T = Phaser.Utils.Objects.GetValue;

	class StatesNineSlice extends PhaserNineSlice {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var x = GetValue$T(config, 'x', 0);
	        var y = GetValue$T(config, 'y', 0);
	        var key = GetValue$T(config, 'key', null);
	        var frame = GetValue$T(config, 'frame', null);
	        var width = GetValue$T(config, 'width', 0);
	        var height = GetValue$T(config, 'height', 0);
	        var leftWidth = GetValue$T(config, 'leftWidth', 0);
	        var rightWidth = GetValue$T(config, 'rightWidth', 0);
	        var topHeight = GetValue$T(config, 'topHeight', 0);
	        var bottomHeight = GetValue$T(config, 'bottomHeight', 0);
	        super(scene, x, y, key, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight);
	        this.type = 'rexStatesNineSlice';

	        var effectConfig = GetValue$T(config, 'effects', true);
	        if (effectConfig) {
	            AddEffectProperties(this, effectConfig);
	        }

	        this.style = new Style$3(this, config);

	        config.style = this.style;
	        this.addStyleManager(config);

	        delete config.style;
	    }
	}

	Object.assign(
	    StatesNineSlice.prototype,
	    HelperMethods
	);

	let Style$2 = class Style extends ComponentBase {
	    constructor(gameObject, style) {
	        super(gameObject);
	        // this.parent = gameObject;

	        return new Proxy(this, this);
	    }

	    get(target, prop) {
	        if (HasProperty(target, prop)) {
	            return target[prop];
	        }

	        var gameObject = target.parent;
	        if (HasProperty(gameObject, prop)) {
	            return gameObject[prop];
	        }
	    }

	    set(target, prop, value) {
	        if (HasProperty(target, prop)) {
	            target[prop] = value;

	        } else if (HasProperty(target.parent, prop)) {
	            target.parent[prop] = value;
	        }

	        return true;
	    }

	    get key() {
	        return this.parent.texture.key;
	    }

	    set key(value) {
	        this.parent.setTexture(value, this.frame);
	    }

	    get frame() {
	        return this.parent.frame.name;
	    }

	    set frame(value) {
	        this.parent.setFrame(value);
	    }

	    get scale() {
	        return this.parent.scaleX;
	    }

	    set scale(value) {
	        this.parent.setScale(value);
	    }
	};

	const PhaserImage = Phaser.GameObjects.Image;
	const GetValue$S = Phaser.Utils.Objects.GetValue;

	class StatesImage extends PhaserImage {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var x = GetValue$S(config, 'x', 0);
	        var y = GetValue$S(config, 'y', 0);
	        var key = GetValue$S(config, 'key', '');
	        var frame = GetValue$S(config, 'frame', undefined);
	        super(scene, x, y, key, frame);
	        this.type = 'rexStatesImage';

	        var effectConfig = GetValue$S(config, 'effects', true);
	        if (effectConfig) {
	            AddEffectProperties(this, effectConfig);
	        }

	        this.style = new Style$2(this, config);

	        config.style = this.style;
	        this.addStyleManager(config);

	        delete config.style;
	    }
	}

	Object.assign(
	    StatesImage.prototype,
	    HelperMethods
	);

	var SetGetFrameNameCallback = function(callback) {
	    if (callback === undefined) {
	        callback = DefaultGetFrameNameCallback;
	    }
	    this.getFrameNameCallback = callback;
	    return this;
	};

	var DefaultGetFrameNameCallback = function (colIndex, rowIndex, baseFrameName) {
	    if (baseFrameName === '__BASE') {
	        return `${colIndex},${rowIndex}`;
	    } else {
	        return `${baseFrameName}:${colIndex},${rowIndex}`;
	    }
	};

	var SetBaseTexture = function (key, baseFrameName, columns, rows) {
	    if (Array.isArray(baseFrameName)) {
	        rows = columns;
	        columns = baseFrameName;
	        baseFrameName = undefined;
	    }

	    if (baseFrameName == null) {
	        baseFrameName = '__BASE';
	    }

	    if ((typeof (columns) === 'number') && (arguments.length >= 6)) {
	        columns = [arguments[2], undefined, arguments[3]];
	        rows = [arguments[4], undefined, arguments[5]];
	    } else if (
	        (columns === undefined) &&
	        (rows === undefined) &&
	        (this.columns.data !== undefined) &&
	        (this.rows.data !== undefined)
	    ) {
	        columns = this.columns.data;
	        rows = this.rows.data;
	    } else {
	        columns = DeepClone(columns);
	        rows = DeepClone(rows);
	    }

	    this.textureKey = key;
	    this.baseFrameName = baseFrameName;
	    this.columns.data = columns;
	    this.columns.count = (columns) ? columns.length : 0;
	    this.columns.stretch = 0;
	    this.columns.minWidth = 0;
	    this.columns.scale = 1;
	    this.rows.data = rows;
	    this.rows.count = (rows) ? rows.length : 0;
	    this.rows.stretch = 0;
	    this.rows.minHeight = 0;
	    this.rows.scale = 1;

	    var texture = this.scene.sys.textures.get(key);
	    if (!texture) {
	        this.clear();
	        return this;
	    }
	    if (!columns || !rows) {
	        this.clear();
	        return this;
	    }

	    // Get remainder width/height for unknown width/height
	    var baseFrame = texture.get(baseFrameName);
	    var remainderTextureWidth = baseFrame.width;
	    var unknownColumnWidthCount = 0;
	    for (var i = 0, cnt = columns.length; i < cnt; i++) {
	        if (columns[i] === undefined) {
	            unknownColumnWidthCount++;
	        } else if (typeof (columns[i]) === 'number') {
	            remainderTextureWidth -= columns[i];
	        } else {
	            remainderTextureWidth -= columns[i].width;
	        }
	    }
	    var unknownColumnWidth = (unknownColumnWidthCount > 0) ? (remainderTextureWidth / unknownColumnWidthCount) : 0;

	    var remainderTextureHeight = baseFrame.height;
	    var unknownRowHeightCount = 0;
	    for (var i = 0, cnt = rows.length; i < cnt; i++) {
	        if (rows[i] === undefined) {
	            unknownRowHeightCount++;
	        } else if (typeof (rows[i]) === 'number') {
	            remainderTextureHeight -= rows[i];
	        } else {
	            remainderTextureHeight -= rows[i].width;
	        }
	    }
	    var unknownRowHeight = (unknownRowHeightCount) ? (remainderTextureHeight / unknownRowHeightCount) : 0;

	    var row, col, rowHeight, colWidth, frameName;
	    var offsetX = 0, offsetY = 0;
	    for (var j = 0, jcnt = rows.length; j < jcnt; j++) {
	        // Unknown height
	        if (rows[j] === undefined) {
	            rows[j] = unknownRowHeight;
	        }

	        if (typeof (rows[j]) === 'number') {
	            rows[j] = {
	                height: rows[j],
	                stretch: (j % 2),
	            };
	        }

	        row = rows[j];
	        rowHeight = row.height;

	        this.rows.stretch += (row.stretch | 0);
	        this.rows.minHeight += (row.stretch > 0) ? 0 : rowHeight;

	        offsetX = 0;
	        for (var i = 0, icnt = columns.length; i < icnt; i++) {
	            // Unknown width
	            if (columns[i] === undefined) {
	                columns[i] = unknownColumnWidth;
	            }

	            if (typeof (columns[i]) === 'number') {
	                columns[i] = {
	                    width: columns[i],
	                    stretch: (i % 2),
	                };
	            }

	            col = columns[i];
	            colWidth = col.width;

	            if (j === 0) {
	                this.columns.stretch += (col.stretch | 0);
	                this.columns.minWidth += (col.stretch > 0) ? 0 : colWidth;
	            }

	            if ((colWidth >= 1) && (rowHeight >= 1)) {
	                frameName = this.getFrameNameCallback(i, j, baseFrameName);
	                var frameNameType = typeof (frameName);
	                if ((frameNameType === 'string') || (frameNameType === 'number')) {
	                    texture.add(
	                        frameName, 0,
	                        (offsetX + baseFrame.cutX), (offsetY + baseFrame.cutY),
	                        colWidth, rowHeight
	                    );
	                    // Do nothing if frameName is existed
	                }
	            }
	            offsetX += colWidth;
	        }
	        offsetY += rowHeight;
	    }

	    this.updateTexture();
	    return this;
	};

	var UpdateTexture = function () {
	    this.clear();

	    if (this.textureKey === undefined) {
	        return this;
	    }
	    var texture = this.scene.sys.textures.get(this.textureKey);
	    if (!texture) {
	        return this;
	    }

	    var minWidth = this.columns.minWidth * this.maxFixedPartScaleX;  // Fixed-part width
	    var minHeight = this.rows.minHeight * this.maxFixedPartScaleY;   // Fixed-part height
	    var stretchWidth = this.width - minWidth;
	    var stretchHeight = this.height - minHeight;
	    var fixedPartScaleX = (stretchWidth >= 0) ? this.maxFixedPartScaleX : (this.width / minWidth);
	    var fixedPartScaleY = (stretchHeight >= 0) ? this.maxFixedPartScaleY : (this.height / minHeight);

	    if (this.preserveRatio) {
	        var minScale = Math.min(fixedPartScaleX, fixedPartScaleY);
	        if (fixedPartScaleX > minScale) {
	            var compensationWidth = (fixedPartScaleX - minScale) * minWidth;
	            if (stretchWidth >= 0) {
	                stretchWidth += compensationWidth;
	            } else {
	                stretchWidth = compensationWidth;
	            }
	            fixedPartScaleX = minScale;
	        }
	        if (fixedPartScaleY > minScale) {
	            var compensationHeight = (fixedPartScaleY - minScale) * minHeight;
	            if (stretchHeight >= 0) {
	                stretchHeight += compensationHeight;
	            } else {
	                stretchHeight = compensationHeight;
	            }
	            fixedPartScaleY = minScale;
	        }
	    }
	    this.columns.scale = fixedPartScaleX;
	    this.rows.scale = fixedPartScaleY;

	    var proportionWidth;
	    if (stretchWidth > 0) {
	        proportionWidth = (this.columns.stretch > 0) ? (stretchWidth / this.columns.stretch) : 0;
	    } else {
	        proportionWidth = 0;
	    }

	    var proportionHeight;
	    if (stretchHeight > 0) {
	        proportionHeight = (this.rows.stretch > 0) ? (stretchHeight / this.rows.stretch) : 0;
	    } else {
	        proportionHeight = 0;
	    }

	    var frameName, col, row, colWidth, rowHeight;
	    var offsetX = 0, offsetY = 0;
	    var imageType;

	    this._beginDraw();
	    for (var j = 0, jcnt = this.rows.count; j < jcnt; j++) {
	        row = this.rows.data[j];
	        rowHeight = (row.stretch === 0) ? (row.height * fixedPartScaleY) : (proportionHeight * row.stretch);

	        offsetX = 0;
	        for (var i = 0, icnt = this.columns.count; i < icnt; i++) {
	            col = this.columns.data[i];
	            colWidth = (col.stretch === 0) ? (col.width * fixedPartScaleX) : (proportionWidth * col.stretch);

	            frameName = this.getFrameNameCallback(i, j, this.baseFrameName);
	            if (texture.has(frameName) && (colWidth > 0) && (rowHeight > 0)) {
	                if ((row.stretch === 0) && (col.stretch === 0)) { // Fixed parts
	                    imageType = 0; // Draw image
	                } else { // Stretchable parts
	                    if (this.getStretchMode(i, j) === 0) { // Scaled image
	                        imageType = 0; // Draw scaled image
	                    } else { // Repeat tile-sprite
	                        imageType = 1; // Draw tile-sprite
	                    }
	                }

	                if (imageType === 0) {
	                    this._drawImage(
	                        this.textureKey, frameName,
	                        offsetX, offsetY,
	                        colWidth, rowHeight
	                    );
	                } else {
	                    this._drawTileSprite(
	                        this.textureKey, frameName,
	                        offsetX, offsetY,
	                        colWidth, rowHeight
	                    );
	                }
	            }

	            offsetX += colWidth;
	        }

	        offsetY += rowHeight;
	    }
	    this._endDraw();
	};

	const IsPlainObject$g = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$R = Phaser.Utils.Objects.GetValue;

	var SetStretchMode = function(mode) {
	    if (IsPlainObject$g(mode)) {
	        this.stretchMode.edge = parseMode(GetValue$R(mode, 'edge', 0));
	        this.stretchMode.internal = parseMode(GetValue$R(mode, 'internal', 0));
	    } else {
	        mode = parseMode(mode);
	        this.stretchMode.edge = mode;
	        this.stretchMode.internal = mode;
	    }
	    return this;
	};

	var parseMode = function (mode) {
	    if (typeof (mode) === 'string') {
	        mode = EXTENDMODE[mode];
	    }
	    return mode;
	};

	const EXTENDMODE = {
	    scale: 0,
	    repeat: 1,
	};

	var IsEdge = function (colIndex, rowIndex) {
	    return (colIndex === 0) || (colIndex === (this.columns.count - 1)) ||
	        (rowIndex === 0) || (rowIndex === (this.rows.count - 1));
	};

	var GetStretchMode = function(colIndex, rowIndex) {
	    return (IsEdge.call(this, colIndex, rowIndex)) ? this.stretchMode.edge : this.stretchMode.internal;
	};

	var SetPreserveRatio = function (enable) {
	    if (enable == undefined) {
	        enable = true;
	    }

	    this.preserveRatio = enable;
	    return this;
	};

	var SetMaxFixedPartScale = function (scaleX, scaleY) {
	    if (scaleY === undefined) {
	        scaleY = scaleX;
	    }

	    this.maxFixedPartScaleX = scaleX;
	    this.maxFixedPartScaleY = scaleY;
	    return this;
	};

	var Methods$6 = {
	    _beginDraw: NOOP,
	    _drawImage: NOOP,
	    _drawTileSprite: NOOP,
	    _endDraw: NOOP,

	    setGetFrameNameCallback: SetGetFrameNameCallback,
	    setBaseTexture: SetBaseTexture,
	    updateTexture: UpdateTexture,
	    setStretchMode: SetStretchMode,
	    getStretchMode: GetStretchMode,
	    setPreserveRatio: SetPreserveRatio,
	    setMaxFixedPartScale: SetMaxFixedPartScale,
	};

	const IsPlainObject$f = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$Q = Phaser.Utils.Objects.GetValue;

	var NinePatchBase = function (GOClass, type) {
	    class NinePatch extends GOClass {
	        constructor(scene, x, y, width, height, key, baseFrame, columns, rows, config) {
	            if (IsPlainObject$f(x)) {
	                config = x;
	                x = GetValue$Q(config, 'x', 0);
	                y = GetValue$Q(config, 'y', 0);
	                width = GetValue$Q(config, 'width', 1);
	                height = GetValue$Q(config, 'height', 1);
	                key = GetValue$Q(config, 'key', undefined);
	                baseFrame = GetValue$Q(config, 'baseFrame', undefined);
	                columns = GetValue$Q(config, 'columns', undefined);
	                rows = GetValue$Q(config, 'rows', undefined);
	            } else if (IsPlainObject$f(width)) {
	                config = width;
	                width = GetValue$Q(config, 'width', 1);
	                height = GetValue$Q(config, 'height', 1);
	                key = GetValue$Q(config, 'key', undefined);
	                baseFrame = GetValue$Q(config, 'baseFrame', undefined);
	                columns = GetValue$Q(config, 'columns', undefined);
	                rows = GetValue$Q(config, 'rows', undefined);
	            } else if (IsPlainObject$f(key)) {
	                config = key;
	                key = GetValue$Q(config, 'key', undefined);
	                baseFrame = GetValue$Q(config, 'baseFrame', undefined);
	                columns = GetValue$Q(config, 'columns', undefined);
	                rows = GetValue$Q(config, 'rows', undefined);
	            } else if (IsPlainObject$f(baseFrame)) {
	                config = baseFrame;
	                baseFrame = GetValue$Q(config, 'baseFrame', undefined);
	                columns = GetValue$Q(config, 'columns', undefined);
	                rows = GetValue$Q(config, 'rows', undefined);
	            } else if (Array.isArray(baseFrame)) {
	                config = rows;
	                rows = columns;
	                columns = baseFrame;
	                baseFrame = GetValue$Q(config, 'baseFrame', undefined);
	            } else if (IsPlainObject$f(columns)) {
	                config = columns;
	                columns = GetValue$Q(config, 'columns', undefined);
	                rows = GetValue$Q(config, 'rows', undefined);
	            }

	            if (baseFrame === undefined) {
	                baseFrame = GetValue$Q(config, 'frame', undefined);
	            }

	            if (columns === undefined) {
	                var leftWidth = GetValue$Q(config, 'leftWidth', undefined);
	                var rightWidth = GetValue$Q(config, 'rightWidth', undefined);
	                if ((leftWidth !== undefined) && (rightWidth !== undefined)) {
	                    columns = [leftWidth, undefined, rightWidth];
	                }
	            }

	            if (rows === undefined) {
	                var topHeight = GetValue$Q(config, 'topHeight', undefined);
	                var bottomHeight = GetValue$Q(config, 'bottomHeight', undefined);
	                if ((topHeight !== undefined) && (bottomHeight !== undefined)) {
	                    rows = [topHeight, undefined, bottomHeight];
	                }
	            }

	            super(scene);
	            this.type = type;
	            this
	                .setPosition(x, y)
	                .setSize(width, height)
	                .setOrigin(0.5, 0.5);

	            this.columns = {};
	            this.rows = {};
	            this.stretchMode = {};
	            this._tileSprite = undefined; // Reserved for drawing image
	            this._image = undefined; // Reserved for drawing image

	            this.setGetFrameNameCallback(GetValue$Q(config, 'getFrameNameCallback', undefined));
	            this.setStretchMode(GetValue$Q(config, 'stretchMode', 0));
	            this.setPreserveRatio(GetValue$Q(config, 'preserveRatio', true));

	            var maxFixedPartScale = GetValue$Q(config, 'maxFixedPartScale', 1);
	            var maxFixedPartScaleX = GetValue$Q(config, 'maxFixedPartScaleX', maxFixedPartScale);
	            var maxFixedPartScaleY = GetValue$Q(config, 'maxFixedPartScaleY', undefined);
	            this.setMaxFixedPartScale(maxFixedPartScaleX, maxFixedPartScaleY);

	            this.setBaseTexture(key, baseFrame, columns, rows);
	        }

	        get minWidth() {
	            return this.columns.minWidth;
	        }

	        get minHeight() {
	            return this.rows.minHeight;
	        }

	        get fixedPartScaleX() {
	            return this.columns.scale;
	        }

	        get fixedPartScaleY() {
	            return this.rows.scale;
	        }

	        resize(width, height) {
	            if ((this.width === width) && (this.height === height)) {
	                return this;
	            }

	            if (super.resize) {
	                super.resize(width, height);
	            } else {
	                // Use setSize method for alternative 
	                super.setSize(width, height);
	            }
	            this.updateTexture();

	            return this;
	        }

	        get leftWidth() {
	            return this.columns.data[0];
	        }

	        get rightWidth() {
	            return this.columns.data[this.columns.count - 1];
	        }

	        get topHeight() {
	            return this.rows.data[0];
	        }

	        get bottomHeight() {
	            return this.rows.data[this.rows.count - 1];
	        }

	    }

	    Object.assign(
	        NinePatch.prototype,
	        Methods$6
	    );

	    return NinePatch;
	};

	const GameObjectClasses = Phaser.GameObjects;

	var GameObjects = undefined;

	var GetStampGameObject = function (gameObject, className) {
	    if (!GameObjects) {
	        GameObjects = {};

	        GetGame(gameObject).events.once('destroy', function () {
	            for (var name in GameObjects) {
	                GameObjects[name].destroy();
	            }
	            GameObjects = undefined;
	        });
	    }

	    if (!GameObjects.hasOwnProperty(className)) {
	        var scene = GetGame(gameObject).scene.systemScene;
	        var gameObject = new GameObjectClasses[className](scene);
	        gameObject.setOrigin(0);

	        GameObjects[className] = gameObject;
	    }

	    return GameObjects[className];
	};

	var DrawImage$1 = function (key, frame, x, y, width, height) {
	    var gameObject = GetStampGameObject(this, 'Image')
	        .setTexture(key, frame)
	        .setDisplaySize(width, height);

	    this.draw(gameObject, x, y);
	};

	var DrawTileSprite = function (key, frame, x, y, width, height) {
	    var gameObject = GetStampGameObject(this, 'TileSprite')
	        .setTexture(key, frame)
	        .setSize(width, height);

	    this.draw(gameObject, x, y);
	};

	const RenderTexture = Phaser.GameObjects.RenderTexture;

	class NinePatch extends NinePatchBase(RenderTexture, 'rexNinePatch') {
	}

	var Methods$5 = {
	    _drawImage: DrawImage$1,
	    _drawTileSprite: DrawTileSprite,
	};
	Object.assign(
	    NinePatch.prototype,
	    Methods$5
	);

	let Style$1 = class Style extends ComponentBase {
	    constructor(gameObject, style) {
	        super(gameObject);
	        // this.parent = gameObject;

	        return new Proxy(this, this);
	    }

	    get(target, prop) {
	        if (HasProperty(target, prop)) {
	            return target[prop];
	        }

	        var gameObject = target.parent;
	        if (HasProperty(gameObject, prop)) {
	            return gameObject[prop];
	        }
	    }

	    set(target, prop, value) {
	        if (HasProperty(target, prop)) {
	            target[prop] = value;

	        } else if (HasProperty(target.parent, prop)) {
	            target.parent[prop] = value;
	        }

	        return true;
	    }

	    get key() {
	        return this.parent.textureKey;
	    }

	    set key(value) {
	        if (this.key === value) {
	            return;
	        }
	        this.parent.setBaseTexture(value, this.baseFrameName);
	    }

	    get frame() {
	        return this.parent.baseFrameName;
	    }

	    set frame(value) {
	        if (this.frame === value) {
	            return;
	        }
	        this.parent.setBaseTexture(this.parent.textureKey, value);
	    }
	};

	const GetValue$P = Phaser.Utils.Objects.GetValue;

	class StatesNinePatch extends NinePatch {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }
	       
	        super(scene, config);
	        this.type = 'rexStatesNinePatch';

	        var effectConfig = GetValue$P(config, 'effects', true);
	        if (effectConfig) {
	            AddEffectProperties(this, effectConfig);
	        }

	        this.style = new Style$1(this, config);

	        config.style = this.style;
	        this.addStyleManager(config);

	        delete config.style;
	    }
	}

	Object.assign(
	    StatesNinePatch.prototype,
	    HelperMethods
	);

	const Properties = [
	    'alpha', 'tint', 'flipX', 'flipY'
	];

	var DecorateGameObject = function (gameObject, config) {
	    if (!config) {
	        return gameObject;
	    }

	    for (var i = 0, cnt = Properties.length; i < cnt; i++) {
	        var propertyName = Properties[i];
	        if ((propertyName in config) && (propertyName in gameObject)) {
	            gameObject[propertyName] = config[propertyName];
	        }
	    }

	    if (('origin' in config) && ('originX' in gameObject)) {
	        gameObject.setOrigin(config.origin);
	    } else {
	        var originX, originY;
	        if (('originX' in config) && ('originX' in gameObject)) {
	            originX = config.originX;
	        }
	        if (('originY' in config) && ('originY' in gameObject)) {
	            originY = config.originY;
	        }
	        if ((originX !== undefined) && (originY !== undefined)) {
	            gameObject.setOrigin(originX, originY);
	        }
	    }

	    return gameObject;
	};

	var CreateBackground = function (scene, config) {
	    var gameObjectType;
	    if (config) {
	        if (config.hasOwnProperty('$type')) {
	            gameObjectType = config.$type;
	        } else {
	            if (config.hasOwnProperty('barColor')) {
	                gameObjectType = 'bar';
	            } else if (config.hasOwnProperty('leftWidth')) {
	                gameObjectType = 'nineSlice';
	            } else if (config.hasOwnProperty('key')) {
	                gameObjectType = 'image';
	            }
	        }
	    }

	    var gameObject;
	    switch (gameObjectType) {
	        case 'bar':
	            gameObject = new StatesBarRectangle(scene, config);
	            break;

	        case 'image':
	            gameObject = new StatesImage(scene, config);
	            break;

	        case 'nineSlice':
	            if (!config.hasOwnProperty('stretchMode')) {
	                gameObject = new StatesNineSlice(scene, config);
	            } else {
	                gameObject = new StatesNinePatch(scene, config);
	            }
	            break;

	        default:
	            gameObject = new StatesRoundRectangle(scene, config);
	            break;
	    }

	    DecorateGameObject(gameObject, config);
	    scene.add.existing(gameObject);
	    return gameObject;
	};

	const PhaserText = Phaser.GameObjects.Text;
	const GetValue$O = Phaser.Utils.Objects.GetValue;

	class StatesText extends PhaserText {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var x = GetValue$O(config, 'x', 0);
	        var y = GetValue$O(config, 'y', 0);
	        var text = GetValue$O(config, 'text', '');
	        super(scene, x, y, text, config);
	        this.type = 'rexStatesText';

	        config.style = this.style;
	        config.onModifyStyle = function (gameObject, style) {
	            var recalculateMetrics = style.hasOwnProperty('fontStyle') || style.hasOwnProperty('fontSize') || style.hasOwnProperty('fontFamily');
	            gameObject.style.update(recalculateMetrics);
	        };

	        this.addStyleManager(config);

	        delete config.style;
	    }
	}

	Object.assign(
	    StatesText.prototype,
	    HelperMethods
	);

	var Utils = Phaser.Renderer.WebGL.Utils;

	var WebGLRenderer = function (renderer, src, camera, parentMatrix) {
	    if ((src.width === 0) || (src.height === 0)) {
	        return;
	    }

	    camera.addToRenderList(src);

	    var frame = src.frame;
	    var width = frame.width;
	    var height = frame.height;
	    var getTint = Utils.getTintAppendFloatAlpha;
	    var pipeline = renderer.pipelines.set(src.pipeline, src);
	    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);

	    renderer.pipelines.preBatch(src);

	    pipeline.batchTexture(
	        src,
	        frame.glTexture,
	        width, height,
	        src.x, src.y,
	        width / src.style.resolution, height / src.style.resolution,
	        src.scaleX, src.scaleY,
	        src.rotation,
	        src.flipX, src.flipY,
	        src.scrollFactorX, src.scrollFactorY,
	        src.displayOriginX, src.displayOriginY,
	        0, 0, width, height,
	        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
	        getTint(src.tintTopRight, camera.alpha * src._alphaTR),
	        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
	        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
	        src.tintFill,
	        0, 0,
	        camera,
	        parentMatrix,
	        false,
	        textureUnit
	    );

	    renderer.pipelines.postBatch(src);
	};

	var CanvasRenderer = function (renderer, src, camera, parentMatrix) {
	    if ((src.width === 0) || (src.height === 0)) {
	        return;
	    }

	    camera.addToRenderList(src);

	    renderer.batchSprite(src, src.frame, camera, parentMatrix);
	};

	var Render = {
	    renderWebGL: WebGLRenderer,
	    renderCanvas: CanvasRenderer

	};

	const CanvasPool$2 = Phaser.Display.Canvas.CanvasPool;

	var MeasureTextMargins = function (textStyle, testString, out) {
	    if (out === undefined) {
	        out = {};
	    }

	    var canvas = CanvasPool$2.create(this);
	    var context = canvas.getContext('2d', { willReadFrequently: true });

	    textStyle.syncFont(canvas, context);

	    var metrics = context.measureText(testString);

	    var width = Math.ceil(metrics.width * textStyle.baselineX);
	    var baseline = width;
	    var height = 2 * baseline;

	    baseline = baseline * textStyle.baselineY | 0;

	    canvas.width = width;
	    canvas.height = height;

	    context.fillStyle = '#f00';
	    context.fillRect(0, 0, width, height);

	    context.font = textStyle._font;

	    context.textBaseline = 'alphabetic';
	    context.fillStyle = '#000';
	    context.fillText(textStyle.testString, 0, baseline);

	    out.left = 0;

	    if ((width === 0) || (height === 0) || !context.getImageData(0, 0, width, height)) {
	        CanvasPool$2.remove(canvas);
	        return out;
	    }

	    var imagedata = context.getImageData(0, 0, width, height).data;
	    var stop = false;
	    for (var x = 0; x < width; x++) {
	        for (var y = 0; y < height; y++) {
	            var idx = (y * width + x) * 4;
	            if (imagedata[idx] !== 255) {
	                out.left = x;
	                stop = true;
	                break;
	            }
	        }
	        if (stop) {
	            break;
	        }
	    }

	    CanvasPool$2.remove(canvas);
	    return out;
	};

	CheckP3Version();

	const GameObject$1 = Phaser.GameObjects.GameObject;

	class TextBase extends GameObject$1 {

	    setStyle(style) {
	        return this.style.setStyle(style);
	    }

	    setFont(font) {
	        return this.style.setFont(font);
	    }

	    setFontFamily(family) {
	        return this.style.setFontFamily(family);
	    }

	    setFontSize(size) {
	        return this.style.setFontSize(size);
	    }

	    setFontStyle(style) {
	        return this.style.setFontStyle(style);
	    }

	    setTestString(string) {
	        return this.style.setTestString(string);
	    }

	    setFixedSize(width, height) {
	        return this.style.setFixedSize(width, height);
	    }

	    setBackgroundColor(color, color2, isHorizontalGradient) {
	        return this.style.setBackgroundColor(color, color2, isHorizontalGradient);
	    }

	    setBackgroundStrokeColor(color, lineWidth) {
	        return this.style.setBackgroundStrokeColor(color, lineWidth);
	    }

	    setBackgroundCornerRadius(radius, iteration) {
	        return this.style.setBackgroundCornerRadius(radius, iteration);
	    }

	    setFill(color) {
	        return this.style.setFill(color);
	    }

	    setColor(color) {
	        return this.style.setColor(color);
	    }

	    setStroke(color, thickness) {
	        return this.style.setStroke(color, thickness);
	    }

	    setShadow(x, y, color, blur, shadowStroke, shadowFill) {
	        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
	    }

	    setShadowOffset(x, y) {
	        return this.style.setShadowOffset(x, y);
	    }

	    setShadowColor(color) {
	        return this.style.setShadowColor(color);
	    }

	    setShadowBlur(blur) {
	        return this.style.setShadowBlur(blur);
	    }

	    setShadowStroke(enabled) {
	        return this.style.setShadowStroke(enabled);
	    }

	    setShadowFill(enabled) {
	        return this.style.setShadowFill(enabled);
	    }

	    setUnderline(color, thickness, offset) {
	        return this.style.setUnderline(color, thickness, offset);
	    }

	    setUnderlineColor(color) {
	        return this.style.setUnderlineColor(color);
	    }

	    setUnderlineThickness(thickness) {
	        return this.style.setUnderlineThickness(thickness);
	    }

	    setUnderlineOffset(offset) {
	        return this.style.setUnderlineOffset(offset);
	    }

	    setStrikethrough(color, thickness, offset) {
	        return this.style.setStrikethrough(color, thickness, offset);
	    }

	    setStrikethroughColor(color) {
	        return this.style.setStrikethroughColor(color);
	    }

	    setStrikethroughThickness(thickness) {
	        return this.style.setStrikethroughThickness(thickness);
	    }

	    setStrikethroughOffset(offset) {
	        return this.style.setStrikethroughOffset(offset);
	    }

	    setWrapMode(mode) {
	        return this.style.setWrapMode(mode);
	    }

	    setWrapWidth(width) {
	        return this.style.setWrapWidth(width);
	    }

	    // Align with built-in text game object
	    setWordWrapWidth(width) {
	        return this.style.setWrapWidth(width);
	    }

	    setAlign(align) {
	        return this.style.setHAlign(align);
	    }
	    setHAlign(align) {
	        return this.style.setHAlign(align);
	    }
	    setVAlign(align) {
	        return this.style.setVAlign(align);
	    }

	    get lineSpacing() {
	        return this.style.lineSpacing;
	    }

	    set lineSpacing(value) {
	        this.style.lineSpacing = value;
	    }

	    setLineSpacing(value) {
	        this.style.lineSpacing = value;
	        this.updateText(true);
	        return this;
	    }

	    setXOffset(value) {
	        return this.style.setXOffset(value);
	    }

	    setMaxLines(max) {
	        return this.style.setMaxLines(max);
	    }

	    setResolution(value) {
	        return this.style.setResolution(value);
	    }

	    getTextMetrics() {
	        return this.style.getTextMetrics();
	    }

	    setTextMetrics(metrics, font) {
	        return this.style.setTextMetrics(metrics, font);
	    }

	    measureTextMargins(testString, out) {
	        return MeasureTextMargins(this.style, testString, out);
	    }

	}

	const Components$1 = Phaser.GameObjects.Components;
	Phaser.Class.mixin(TextBase,
	    [
	        Components$1.Alpha,
	        Components$1.BlendMode,
	        Components$1.ComputedSize,
	        Components$1.Crop,
	        Components$1.Depth,
	        Components$1.Flip,
	        Components$1.GetBounds,
	        Components$1.Mask,
	        Components$1.Origin,
	        Components$1.Pipeline,
	        Components$1.PostPipeline,
	        Components$1.ScrollFactor,
	        Components$1.Tint,
	        Components$1.Transform,
	        Components$1.Visible,
	        Render
	    ]
	);

	//  Key: [ Object Key, Default Value, postCallback ]

	var PropertyMap = {
	    // background
	    backgroundColor: ['backgroundColor', null, GetStyle],
	    backgroundColor2: ['backgroundColor2', null, GetStyle],
	    backgroundHorizontalGradient: ['backgroundHorizontalGradient', true, null],
	    backgroundStrokeColor: ['backgroundStrokeColor', null, GetStyle],
	    backgroundStrokeLineWidth: ['backgroundStrokeLineWidth', 2, null],
	    backgroundCornerRadius: ['backgroundCornerRadius', 0, null],
	    backgroundCornerIteration: ['backgroundCornerIteration', null, null],

	    // font
	    fontFamily: ['fontFamily', 'Courier', null],
	    fontSize: ['fontSize', '16px', null],
	    fontStyle: ['fontStyle', '', null],
	    color: ['color', '#fff', GetStyle],
	    stroke: ['stroke', '#fff', GetStyle],
	    strokeThickness: ['strokeThickness', 0, null],
	    shadowOffsetX: ['shadow.offsetX', 0, null],
	    shadowOffsetY: ['shadow.offsetY', 0, null],
	    shadowColor: ['shadow.color', '#000', GetStyle],
	    shadowBlur: ['shadow.blur', 0, null],
	    shadowStroke: ['shadow.stroke', false, null],
	    shadowFill: ['shadow.fill', false, null],

	    // underline
	    underlineColor: ['underline.color', '#000', GetStyle],
	    underlineThickness: ['underline.thickness', 0, null],
	    underlineOffset: ['underline.offset', 0, null],

	    // strikethrough
	    strikethroughColor: ['strikethrough.color', '#000', GetStyle],
	    strikethroughThickness: ['strikethrough.thickness', 0, null],
	    strikethroughOffset: ['strikethrough.offset', 0, null],

	    // align
	    halign: ['halign', 'left', null],
	    valign: ['valign', 'top', null],

	    // size
	    maxLines: ['maxLines', 0, null],
	    fixedWidth: ['fixedWidth', 0, null],
	    fixedHeight: ['fixedHeight', 0, null],
	    resolution: ['resolution', 0, null],
	    lineSpacing: ['lineSpacing', 0, null],
	    xOffset: ['xOffset', 0, null],

	    rtl: ['rtl', false, null],
	    testString: ['testString', '|MÃ‰qgy', null],
	    baselineX: ['baselineX', 1.2, null],
	    baselineY: ['baselineY', 1.4, null],

	    // wrap
	    wrapMode: ['wrap.mode', 0, null],
	    wrapWidth: ['wrap.width', 0, null],
	    wrapCallback: ['wrap.callback', null],
	    wrapCallbackScope: ['wrap.callbackScope', null],
	};

	/**
	 * @author       Richard Davey <rich@photonstorm.com>
	 * @copyright    2018 Photon Storm Ltd.
	 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
	 */

	const CanvasPool$1 = Phaser.Display.Canvas.CanvasPool;

	/**
	 * Calculates the ascent, descent and fontSize of a given font style.
	 *
	 * @function Phaser.GameObjects.MeasureText
	 * @since 3.0.0
	 *
	 * @param {Phaser.GameObjects.Text.TextStyle} textStyle - The TextStyle object to measure.
	 *
	 * @return {object} An object containing the ascent, descent and fontSize of the TextStyle.
	 */
	var MeasureText = function (textStyle) {
	    // @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
	    var canvas = CanvasPool$1.create(this);

	    // @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
	    var context = canvas.getContext('2d', { willReadFrequently: true });

	    textStyle.syncFont(canvas, context);

	    var metrics = context.measureText(textStyle.testString);

	    if ('actualBoundingBoxAscent' in metrics) {
	        var ascent = metrics.actualBoundingBoxAscent;
	        var descent = metrics.actualBoundingBoxDescent;

	        var output = {
	            ascent: ascent,
	            descent: descent,
	            fontSize: (ascent + descent)
	        };

	        CanvasPool$1.remove(canvas);

	        return output;
	    }

	    var width = Math.ceil(metrics.width * textStyle.baselineX);
	    var baseline = width;
	    var height = 2 * baseline;

	    baseline = baseline * textStyle.baselineY | 0;

	    canvas.width = width;
	    canvas.height = height;

	    context.fillStyle = '#f00';
	    context.fillRect(0, 0, width, height);

	    context.font = textStyle._font;

	    context.textBaseline = 'alphabetic';
	    context.fillStyle = '#000';
	    context.fillText(textStyle.testString, 0, baseline);

	    var output = {
	        ascent: 0,
	        descent: 0,
	        fontSize: 0
	    };

	    if (!context.getImageData(0, 0, width, height)) {
	        output.ascent = baseline;
	        output.descent = baseline + 6;
	        output.fontSize = output.ascent + output.descent;

	        CanvasPool$1.remove(canvas);

	        return output;
	    }

	    var imagedata = context.getImageData(0, 0, width, height).data;
	    var pixels = imagedata.length;
	    var line = width * 4;
	    var i;
	    var j;
	    var idx = 0;
	    var stop = false;

	    // ascent. scan from top to bottom until we find a non red pixel
	    for (i = 0; i < baseline; i++) {
	        for (j = 0; j < line; j += 4) {
	            if (imagedata[idx + j] !== 255) {
	                stop = true;
	                break;
	            }
	        }

	        if (!stop) {
	            idx += line;
	        }
	        else {
	            break;
	        }
	    }

	    output.ascent = baseline - i;

	    idx = pixels - line;
	    stop = false;

	    // descent. scan from bottom to top until we find a non red pixel
	    for (i = height; i > baseline; i--) {
	        for (j = 0; j < line; j += 4) {
	            if (imagedata[idx + j] !== 255) {
	                stop = true;
	                break;
	            }
	        }

	        if (!stop) {
	            idx -= line;
	        }
	        else {
	            break;
	        }
	    }

	    output.descent = (i - baseline);
	    output.fontSize = output.ascent + output.descent;

	    CanvasPool$1.remove(canvas);

	    return output;
	};

	const GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
	const GetValue$N = Phaser.Utils.Objects.GetValue;

	class TextStyle {
	    constructor(text, style, propertyMap) {
	        this.parent = text;
	        // parent.updateText()
	        // parent.width, parent.height

	        if (propertyMap === undefined) {
	            propertyMap = PropertyMap;
	        }
	        this.propertyMap = propertyMap;

	        this.backgroundColor;
	        this.backgroundColor2;
	        this.backgroundHorizontalGradient;
	        this.backgroundStrokeColor;
	        this.backgroundStrokeLineWidth;
	        this.backgroundCornerRadius;
	        this.backgroundCornerIteration;

	        this.fontFamily;
	        this.fontSize;
	        this.fontStyle;
	        this.color;
	        this.stroke;
	        this.strokeThickness;
	        this.shadowOffsetX;
	        this.shadowOffsetY;
	        this.shadowColor;
	        this.shadowBlur;
	        this.shadowStroke;
	        this.shadowFill;

	        this.underlineColor;
	        this.underlineThickness;
	        this.underlineOffset;

	        this.strikethroughColor;
	        this.strikethroughThickness;
	        this.strikethroughOffset;

	        this.halign;
	        this.valign;

	        this.maxLines;
	        this.fixedWidth;
	        this.fixedHeight;
	        this.resolution;
	        this.xOffset;

	        this.rtl;
	        this.testString;

	        this.baselineX;
	        this.baselineY;

	        this.wrapMode;
	        this.wrapWidth;
	        this.wrapCallback;
	        this.wrapCallbackScope;

	        this._font;

	        //  Set to defaults + user style
	        this.setStyle(style, false, true);
	    }

	    get isWrapFitMode() {
	        return (this.fixedWidth > 0) && (this.wrapMode !== CONST.NO_WRAP) && (this.wrapWidth === 0);
	    }

	    setStyle(style, updateText, setDefaults) {
	        if (updateText === undefined) {
	            updateText = true;
	        }
	        if (setDefaults === undefined) {
	            setDefaults = false;
	        }

	        // Compatible with Text game object
	        if (style && style.hasOwnProperty('wordWrap')) {
	            var wordWrap = style.wordWrap;
	            if (wordWrap.hasOwnProperty('width')) {
	                style.wrap = {
	                    mode: 'word',
	                    width: wordWrap.width,
	                };
	            }
	        }

	        if (style && style.hasOwnProperty('wrap')) {
	            var wrap = style.wrap;
	            if (wrap.hasOwnProperty('mode')) {
	                var mode = wrap.mode;
	                if (typeof mode === 'string') {
	                    wrap.mode = WRAPMODE$1[mode];
	                }
	            } else {
	                if (wrap.hasOwnProperty('width')) {
	                    wrap.mode = 1;
	                }
	            }
	        }

	        // default halign of RTL is 'right'
	        if (style && style.rtl && setDefaults && (!style.hasOwnProperty('halign'))) {
	            style.halign = 'right';
	        }

	        //  Avoid type mutation
	        if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {
	            style.fontSize = style.fontSize.toString() + 'px';
	        }

	        var propertyMap = this.propertyMap;
	        for (var key in propertyMap) {
	            var prop = propertyMap[key];  // [ Object Key, Default Value, preCallback ]
	            var objKey = prop[0];
	            var defaultValue = (setDefaults) ? prop[1] : this[key];
	            var postCallback = prop[2];


	            if (key === 'wrapCallback' || key === 'wrapCallbackScope') {
	                // Callback & scope should be set without processing the values
	                this[key] = GetValue$N(style, objKey, defaultValue);
	            } else {
	                var value = GetAdvancedValue(style, objKey, defaultValue);
	                if (postCallback) {
	                    value = postCallback(value);
	                }
	                this[key] = value;
	            }

	        }

	        //  Allow for 'font' override
	        var font = GetValue$N(style, 'font', null);

	        if (font === null) {
	            this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;
	        } else {
	            this._font = font;
	        }

	        //  Allow for 'fill' to be used in place of 'color'
	        var fill = GetValue$N(style, 'fill', null);

	        if (fill !== null) {
	            this.color = GetStyle(fill);
	        }

	        var metrics = GetValue$N(style, 'metrics', false);

	        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
	        //  Doing this is reset if you then change the font of this TextStyle after creation
	        if (metrics) {
	            this.metrics = {
	                ascent: GetValue$N(metrics, 'ascent', 0),
	                descent: GetValue$N(metrics, 'descent', 0),
	                fontSize: GetValue$N(metrics, 'fontSize', 0)
	            };
	        } else if (updateText || (!this.metrics)) {
	            this.metrics = MeasureText(this);
	        }

	        if (updateText) {
	            return this.parent.updateText();
	        } else {
	            return this.parent;
	        }
	    }

	    syncFont(canvas, context) {
	        context.font = this._font;
	    }

	    syncStyle(canvas, context) {
	        context.textBaseline = 'alphabetic';

	        context.fillStyle = this.color;
	        context.strokeStyle = this.stroke;

	        context.lineWidth = this.strokeThickness;
	        context.lineCap = 'round';
	        context.lineJoin = 'round';
	    }

	    syncShadow(context, enabled) {
	        if (enabled) {
	            context.shadowOffsetX = this.shadowOffsetX;
	            context.shadowOffsetY = this.shadowOffsetY;
	            context.shadowColor = this.shadowColor;
	            context.shadowBlur = this.shadowBlur;
	        } else {
	            context.shadowOffsetX = 0;
	            context.shadowOffsetY = 0;
	            context.shadowColor = 0;
	            context.shadowBlur = 0;
	        }
	    }

	    update(recalculateMetrics) {
	        if (recalculateMetrics) {
	            this._font = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();

	            this.metrics = MeasureText(this);
	        }

	        return this.parent.updateText(recalculateMetrics);
	    }

	    buildFont() {
	        var newFont = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();
	        if (newFont !== this._font) {
	            this._font = newFont;
	            //this.metrics = MeasureText(this);
	        }
	        return this;
	    }

	    setFont(font) {
	        if (typeof font === 'string') {
	            this.fontFamily = font;
	            this.fontSize = '';
	            this.fontStyle = '';
	        } else {
	            this.fontFamily = GetValue$N(font, 'fontFamily', 'Courier');
	            this.fontSize = GetValue$N(font, 'fontSize', '16px');
	            this.fontStyle = GetValue$N(font, 'fontStyle', '');
	        }

	        return this.update(true);
	    }

	    setFontFamily(family) {
	        this.fontFamily = family;

	        return this.update(true);
	    }

	    setFontStyle(style) {
	        this.fontStyle = style;

	        return this.update(true);
	    }

	    setFontSize(size) {
	        if (typeof size === 'number') {
	            size = size.toString() + 'px';
	        }

	        this.fontSize = size;

	        return this.update(true);
	    }

	    setTestString(string) {
	        this.testString = string;

	        return this.update(true);
	    }

	    setFixedSize(width, height) {
	        this.fixedWidth = width;
	        this.fixedHeight = height;

	        if (width) {
	            this.parent.width = width;
	        }

	        if (height) {
	            this.parent.height = height;
	        }

	        return this.update(this.isWrapFitMode);
	    }

	    setResolution(value) {
	        this.resolution = value;

	        return this.update(false);
	    }

	    setXOffset(value) {
	        this.xOffset = value;

	        return this.update(false);
	    }

	    setBackgroundColor(color, color2, isHorizontalGradient) {
	        if (isHorizontalGradient === undefined) {
	            isHorizontalGradient = true;
	        }

	        this.backgroundColor = GetStyle(color, this.parent.canvas, this.parent.context);
	        this.backgroundColor2 = GetStyle(color2, this.parent.canvas, this.parent.context);
	        this.backgroundHorizontalGradient = isHorizontalGradient;

	        return this.update(false);
	    }

	    setBackgroundStrokeColor(color, lineWidth) {
	        this.backgroundStrokeColor = GetStyle(color, this.parent.canvas, this.parent.context);
	        this.backgroundStrokeLineWidth = lineWidth;

	        return this.update(false);
	    }

	    setBackgroundCornerRadius(radius, iteration) {
	        this.backgroundCornerRadius = radius;
	        this.backgroundCornerIteration = iteration;

	        return this.update(false);
	    }

	    setFill(color) {
	        this.color = GetStyle(color, this.parent.canvas, this.parent.context);

	        return this.update(false);
	    }

	    setColor(color) {
	        this.color = GetStyle(color, this.parent.canvas, this.parent.context);

	        return this.update(false);
	    }

	    setStroke(color, thickness) {
	        if (color === undefined) {
	            //  Reset the stroke to zero (disabling it)
	            this.strokeThickness = 0;
	        } else {
	            if (thickness === undefined) {
	                thickness = this.strokeThickness;
	            }

	            this.stroke = GetStyle(color, this.parent.canvas, this.parent.context);
	            this.strokeThickness = thickness;
	        }

	        return this.update(true);
	    }

	    setShadow(x, y, color, blur, shadowStroke, shadowFill) {
	        if (x === undefined) {
	            x = 0;
	        }
	        if (y === undefined) {
	            y = 0;
	        }
	        if (color === undefined) {
	            color = '#000';
	        }
	        if (blur === undefined) {
	            blur = 0;
	        }
	        if (shadowStroke === undefined) {
	            shadowStroke = false;
	        }
	        if (shadowFill === undefined) {
	            shadowFill = true;
	        }

	        this.shadowOffsetX = x;
	        this.shadowOffsetY = y;
	        this.shadowColor = GetStyle(color, this.parent.canvas, this.parent.context);
	        this.shadowBlur = blur;
	        this.shadowStroke = shadowStroke;
	        this.shadowFill = shadowFill;

	        return this.update(false);
	    }

	    setShadowOffset(x, y) {
	        if (x === undefined) {
	            x = 0;
	        }
	        if (y === undefined) {
	            y = x;
	        }

	        this.shadowOffsetX = x;
	        this.shadowOffsetY = y;

	        return this.update(false);
	    }

	    setShadowColor(color) {
	        if (color === undefined) {
	            color = '#000';
	        }

	        this.shadowColor = GetStyle(color, this.parent.canvas, this.parent.context);

	        return this.update(false);
	    }

	    setShadowBlur(blur) {
	        if (blur === undefined) {
	            blur = 0;
	        }

	        this.shadowBlur = blur;

	        return this.update(false);
	    }

	    setShadowStroke(enabled) {
	        this.shadowStroke = enabled;

	        return this.update(false);
	    }

	    setShadowFill(enabled) {
	        this.shadowFill = enabled;

	        return this.update(false);
	    }

	    setUnderline(color, thickness, offset) {
	        if (color === undefined) {
	            color = '#000';
	        }
	        if (thickness === undefined) {
	            thickness = 0;
	        }
	        if (offset === undefined) {
	            offset = 0;
	        }

	        this.underlineColor = GetStyle(color, this.parent.canvas, this.parent.context);
	        this.underlineThickness = thickness;
	        this.underlineOffset = offset;

	        return this.update(false);
	    }

	    setUnderlineColor(color) {
	        if (color === undefined) {
	            color = '#000';
	        }

	        this.underlineColor = GetStyle(color, this.parent.canvas, this.parent.context);
	        return this.update(false);
	    }

	    setUnderlineThickness(thickness) {
	        if (thickness === undefined) {
	            thickness = 0;
	        }

	        this.underlineThickness = thickness;
	        return this.update(false);
	    }

	    setUnderlineOffset(offset) {
	        if (offset === undefined) {
	            offset = 0;
	        }

	        this.underlineOffset = offset;
	        return this.update(false);
	    }

	    setStrikethrough(color, thickness, offset) {
	        if (color === undefined) {
	            color = '#000';
	        }
	        if (thickness === undefined) {
	            thickness = 0;
	        }
	        if (offset === undefined) {
	            offset = 0;
	        }

	        this.strikethroughColor = GetStyle(color, this.parent.canvas, this.parent.context);
	        this.strikethroughThickness = thickness;
	        this.strikethroughOffset = offset;

	        return this.update(false);
	    }

	    setStrikethroughColor(color) {
	        if (color === undefined) {
	            color = '#000';
	        }

	        this.strikethroughColor = GetStyle(color, this.parent.canvas, this.parent.context);
	        return this.update(false);
	    }

	    setStrikethroughThickness(thickness) {
	        if (thickness === undefined) {
	            thickness = 0;
	        }

	        this.strikethroughThickness = thickness;
	        return this.update(false);
	    }

	    setStrikethroughOffset(offset) {
	        if (offset === undefined) {
	            offset = 0;
	        }

	        this.strikethroughOffset = offset;
	        return this.update(false);
	    }

	    setWrapMode(mode) {
	        if (typeof mode === 'string') {
	            mode = WRAPMODE$1[mode.toLowerCase()] || 0;
	        }
	        this.wrapMode = mode;
	        return this.update(true);
	    }

	    setWrapWidth(width) {
	        this.wrapWidth = width;
	        return this.update(false);
	    }

	    setAlign(halign, valign) {
	        if (halign === undefined) {
	            halign = 'left';
	        }
	        if (valign === undefined) {
	            valign = 'top';
	        }
	        this.halign = halign;
	        this.valign = valign;

	        return this.update(false);
	    }

	    setHAlign(halign) {
	        if (halign === undefined) {
	            halign = 'left';
	        }
	        this.halign = halign;

	        return this.update(false);
	    }

	    setVAlign(valign) {
	        if (valign === undefined) {
	            valign = 'top';
	        }
	        this.valign = valign;

	        return this.update(false);
	    }

	    setMaxLines(max) {
	        if (max === undefined) {
	            max = 0;
	        }

	        this.maxLines = max;

	        return this.update(false);
	    }

	    getTextMetrics() {
	        var metrics = this.metrics;

	        return {
	            ascent: metrics.ascent,
	            descent: metrics.descent,
	            fontSize: metrics.fontSize
	        };
	    }

	    setTextMetrics(metrics, font) {
	        this.metrics.ascent = metrics.ascent;
	        this.metrics.descent = metrics.descent;
	        this.metrics.fontSize = metrics.fontSize;

	        if (font) {
	            if (typeof font === 'string') {
	                this.fontFamily = font;
	                this.fontSize = '';
	                this.fontStyle = '';
	            } else {
	                this.fontFamily = GetValue$N(font, 'fontFamily', this.fontFamily);
	                this.fontSize = GetValue$N(font, 'fontSize', this.fontSize);
	                this.fontStyle = GetValue$N(font, 'fontStyle', this.fontStyle);
	            }
	        }

	        return this.parent.updateText(true);
	    }

	    get lineHeight() {
	        return this.metrics.fontSize + this.parent.lineSpacing;
	    }

	    toJSON() {
	        var output = {};

	        var propertyMap = this.propertyMap;
	        for (var key in propertyMap) {
	            output[key] = this[key];
	        }

	        output.metrics = this.getTextMetrics();

	        return output;
	    }

	    destroy() {
	        this.parent = undefined;
	    }

	}

	var DrawMethods = {
	    draw(startX, startY, textWidth, textHeight) {
	        var penManager = this.penManager;
	        this.hitAreaManager.clear();

	        var context = this.context;
	        context.save();

	        var defaultStyle = this.defaultStyle;

	        this.clear();
	        DrawRoundRectangleBackground(
	            this,
	            defaultStyle.backgroundColor,
	            defaultStyle.backgroundStrokeColor,
	            defaultStyle.backgroundStrokeLineWidth,
	            defaultStyle.backgroundCornerRadius,
	            defaultStyle.backgroundColor2,
	            defaultStyle.backgroundHorizontalGradient,
	            defaultStyle.backgroundCornerIteration
	        );

	        // draw lines
	        startX += this.startXOffset;
	        startY += this.startYOffset;
	        var defaultHalign = defaultStyle.halign,
	            valign = defaultStyle.valign;

	        var lineWidth, lineHeight = defaultStyle.lineHeight;
	        var lines = penManager.lines;
	        var totalLinesNum = lines.length,
	            maxLines = defaultStyle.maxLines;
	        var drawLinesNum, drawLineStartIdx, drawLineEndIdx;
	        if ((maxLines > 0) && (totalLinesNum > maxLines)) {
	            drawLinesNum = maxLines;
	            if (valign === 'center') { // center
	                drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
	            } else if (valign === 'bottom') { // bottom
	                drawLineStartIdx = totalLinesNum - drawLinesNum;
	            } else {
	                drawLineStartIdx = 0;
	            }
	        } else {
	            drawLinesNum = totalLinesNum;
	            drawLineStartIdx = 0;
	        }
	        drawLineEndIdx = drawLineStartIdx + drawLinesNum;

	        var offsetX, offsetY;
	        var rtl = this.rtl,
	            rtlOffset = (rtl) ? this.parent.width : undefined;
	        if (valign === 'center') { // center
	            offsetY = Math.max((textHeight - (drawLinesNum * lineHeight)) / 2, 0);
	        } else if (valign === 'bottom') { // bottom
	            offsetY = Math.max(textHeight - (drawLinesNum * lineHeight) - 2, 0);
	        } else {
	            offsetY = 0;
	        }
	        offsetY += startY;
	        for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
	            lineWidth = penManager.getLineWidth(lineIdx);
	            if (lineWidth === 0) {
	                continue;
	            }

	            var pens = lines[lineIdx],
	                penCount = pens.length;
	            var halign = defaultHalign;
	            // Seek if there has algin tag
	            for (var penIdx = 0; penIdx < penCount; penIdx++) {
	                var penAlign = pens[penIdx].prop.align;
	                if (penAlign !== undefined) {
	                    halign = penAlign;
	                    break;
	                }
	            }

	            if (halign === 'center') { // center
	                offsetX = (textWidth - lineWidth) / 2;
	            } else if (halign === 'right') { // right
	                offsetX = (!rtl) ? (textWidth - lineWidth) : 0;
	            } else {
	                offsetX = (!rtl) ? 0 : (textWidth - lineWidth);
	            }
	            offsetX += startX;

	            for (var penIdx = 0; penIdx < penCount; penIdx++) {
	                this.drawPen(pens[penIdx], offsetX, offsetY, rtlOffset);
	            }
	        }

	        context.restore();
	    },

	    drawPen(pen, offsetX, offsetY, rtlOffset) {
	        offsetX += pen.x;
	        offsetY += pen.y + (pen.prop.y || 0);

	        if (rtlOffset !== undefined) {
	            offsetX = rtlOffset - offsetX;
	        }

	        var canvas = this.canvas;
	        var context = this.context;
	        context.save();

	        var curStyle = this.parser.propToContextStyle(this.defaultStyle, pen.prop);

	        // Background
	        if ((curStyle.bgcolor !== null) && (pen.width > 0)) {
	            var metrics = this.defaultStyle.metrics;
	            var bgTLY = offsetY - metrics.ascent;
	            var bgHeight = metrics.fontSize;
	            this.drawRectangle(offsetX, bgTLY, pen.width, bgHeight, curStyle.bgcolor, curStyle);
	        }

	        // Underline
	        if ((curStyle.underlineThickness > 0) && (pen.width > 0)) {
	            var lineOffsetY = offsetY + curStyle.underlineOffset - (curStyle.underlineThickness / 2);
	            this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.underlineThickness, curStyle.underlineColor, curStyle);
	        }

	        // Text
	        if (pen.isTextPen) {
	            curStyle.buildFont();
	            curStyle.syncFont(canvas, context);
	            curStyle.syncStyle(canvas, context);
	            this.drawText(offsetX, offsetY, pen.text, curStyle);
	        }

	        // Image
	        if (pen.isImagePen) {
	            this.drawImage(offsetX, offsetY, pen.prop.img, pen.prop.color, curStyle);
	        }

	        // Strikethrough
	        if ((curStyle.strikethroughThickness > 0) && (pen.width > 0)) {
	            var lineOffsetY = offsetY + curStyle.strikethroughOffset - (curStyle.strikethroughThickness / 2);
	            this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.strikethroughThickness, curStyle.strikethroughColor, curStyle);
	        }

	        context.restore();

	        if (pen.hasAreaMarker && (pen.width > 0)) {
	            var data;
	            var areaKey = pen.prop.area;
	            if (areaKey) {
	                data = {
	                    key: areaKey
	                };
	            } else {
	                var url = pen.prop.url;
	                data = {
	                    key: `url:${url}`,
	                    url: url
	                };
	            }

	            this.hitAreaManager.add(
	                offsetX,                       // x
	                (offsetY - this.startYOffset), // y
	                pen.width,                     // width
	                this.defaultStyle.lineHeight,  // height
	                data
	            );
	        }
	    },

	    clear() {
	        var canvas = this.canvas;
	        this.context.clearRect(0, 0, canvas.width, canvas.height);
	    },

	    drawRectangle(x, y, width, height, color, style) {
	        if (this.autoRound) {
	            x = Math.round(x);
	            y = Math.round(y);
	        }

	        var context = this.context;
	        context.fillStyle = color;
	        context.fillRect(x, y, width, height);
	    },

	    drawLine(x, y, width, height, color, style) {
	        if (this.autoRound) {
	            x = Math.round(x);
	            y = Math.round(y);
	        }

	        var context = this.context;
	        style.syncShadow(context, style.shadowStroke);

	        var savedLineCap = context.lineCap;
	        context.lineCap = 'butt';
	        context.strokeStyle = color;
	        context.lineWidth = height;
	        context.beginPath();
	        context.moveTo(x, y);
	        context.lineTo((x + width), y);
	        context.stroke();
	        context.lineCap = savedLineCap;
	    },

	    drawText(x, y, text, style) {
	        if (this.autoRound) {
	            x = Math.round(x);
	            y = Math.round(y);
	        }

	        var context = this.context;
	        if (style.stroke && (style.stroke !== 'none') && (style.strokeThickness > 0)) {
	            style.syncShadow(context, style.shadowStroke);
	            context.strokeText(text, x, y);
	        }

	        if (style.color && (style.color !== 'none')) {
	            style.syncShadow(context, style.shadowFill);
	            context.fillText(text, x, y);
	        }
	    },

	    drawImage(x, y, imgKey, color, style) {
	        y -= this.startYOffset;
	        this.parent.imageManager.draw(imgKey, this.context, x, y, color, this.autoRound);
	    }

	};

	const GetValue$M = Phaser.Utils.Objects.GetValue;
	const NO_NEWLINE$3 = CONST.NO_NEWLINE;
	const RAW_NEWLINE$1 = CONST.RAW_NEWLINE;

	class Pen {
	    constructor(config) {
	        this.prop = {};
	        this.resetFromJSON(config);
	    }

	    resetFromJSON(o) { // (txt, x, y, width, prop, newLineMode, startIndex)
	        this.text = GetValue$M(o, 'text', '');
	        this.x = GetValue$M(o, 'x', 0);
	        this.y = GetValue$M(o, 'y', 0);
	        this.width = GetValue$M(o, 'width', 0);

	        var prop = GetValue$M(o, 'prop', null);
	        if (prop === null) {
	            prop = {};
	        }
	        this.prop = prop;
	        this.newLineMode = GetValue$M(o, 'newLineMode', 0);
	        this.startIndex = GetValue$M(o, 'startIndex', 0);
	    }

	    get plainText() {
	        var txt = this.text;
	        if (this.newLineMode === RAW_NEWLINE$1) {
	            txt += "\n";
	        }

	        return txt;
	    }

	    get wrapText() {
	        var txt = this.text;
	        if (this.newLineMode !== NO_NEWLINE$3) {
	            txt += "\n";
	        }

	        return txt;
	    }

	    get rawTextLength() {
	        var len = this.text.length;
	        if (this.newLineMode === RAW_NEWLINE$1) {
	            len += 1;
	        }
	        return len;
	    }

	    get endIndex() {
	        return this.startIndex + this.rawTextLength;
	    }

	    get lastX() {
	        return this.x + this.width;
	    }

	    get isTextPen() {
	        return (this.text !== '');
	    }

	    get isImagePen() {
	        return !!this.prop.img;
	    }

	    get hasAreaMarker() {
	        return !!this.prop.area || !!this.prop.url;
	    }
	}

	const GetFastValue = Phaser.Utils.Objects.GetFastValue;
	const NO_NEWLINE$2 = CONST.NO_NEWLINE;
	const WRAPPED_NEWLINE$2 = CONST.WRAPPED_NEWLINE;

	class PenManager {
	    constructor(config) {
	        this.pens = []; // all pens
	        this.lines = []; // pens in lines [ [],[],[],.. ]
	        this.maxLinesWidth = undefined;

	        this.pensPool = config.pensPool;    // Required
	        this.linesPool = config.linesPool;  // Required
	        this.tagToText = GetFastValue(config, 'tagToText', NOOP);
	        this.tagToTextScope = GetFastValue(config, 'tagToTextScope', undefined);
	    }

	    destroy() {
	        this.clear();
	        this.tagToText = undefined;
	        this.tagToTextScope = undefined;
	    }

	    clear() {
	        for (var i = 0, len = this.lines.length; i < len; i++) {
	            this.lines[i].length = 0;
	        }

	        this.pensPool.pushMultiple(this.pens);
	        this.linesPool.pushMultiple(this.lines);
	        this.maxLinesWidth = undefined;
	    }

	    addTextPen(text, x, y, width, prop, newLineMode) {
	        var pen = this.pensPool.pop();
	        if (pen == null) {
	            pen = new Pen();
	        }
	        PEN_CONFIG.text = text;
	        PEN_CONFIG.x = x;
	        PEN_CONFIG.y = y;
	        PEN_CONFIG.width = width;
	        PEN_CONFIG.prop = prop;
	        PEN_CONFIG.newLineMode = newLineMode;
	        pen.resetFromJSON(PEN_CONFIG);
	        this.addPen(pen);
	        return this;
	    }

	    addImagePen(x, y, width, prop) {
	        this.addTextPen('', x, y, width, prop, NO_NEWLINE$2);
	        return this;
	    }

	    addNewLinePen() {
	        var previousPen = this.lastPen;
	        var x = (previousPen) ? previousPen.lastX : 0;
	        var y = (previousPen) ? previousPen.y : 0;
	        var prop = (previousPen) ? Clone(previousPen.prop) : null;
	        this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE$2);
	        return this;
	    }

	    addPen(pen) {
	        var previousPen = this.lastPen;
	        if (previousPen == null) {
	            pen.startIndex = 0;
	        } else {
	            pen.startIndex = previousPen.endIndex;
	        }
	        this.pens.push(pen);

	        // maintan lines
	        var line = this.lastLine;
	        if (line == null) {
	            line = this.linesPool.pop() || [];
	            this.lines.push(line);
	        }
	        line.push(pen);

	        // new line, add an empty line
	        if (pen.newLineMode !== NO_NEWLINE$2) {
	            line = this.linesPool.pop() || [];
	            this.lines.push(line);
	        }
	        this.maxLinesWidth = undefined;
	    }

	    clone(targetPenManager) {
	        if (targetPenManager == null)
	            targetPenManager = new PenManager();

	        targetPenManager.clear();

	        for (var li = 0, llen = this.lines.length; li < llen; li++) {
	            var pens = this.lines[li];
	            for (var pi = 0, plen = pens.length; pi < plen; pi++) {
	                var pen = pens[pi];
	                targetPenManager.addPen(
	                    pen.text,
	                    pen.x,
	                    pen.y,
	                    pen.width,
	                    Clone(pen.prop),
	                    pen.newLineMode
	                );
	            }
	        }

	        return targetPenManager;
	    }

	    get lastPen() {
	        return this.pens[this.pens.length - 1];
	    }

	    get lastLine() {
	        return this.lines[this.lines.length - 1];
	    }

	    getLineStartIndex(i) {
	        if (i >= this.lines.length) {
	            return this.getLineEndIndex(i);
	        } else {
	            var line = this.lines[i];
	            return (line && line[0]) ? line[0].startIndex : 0;
	        }
	    }

	    getLineEndIndex(i) {
	        if (i >= this.lines.length) {
	            i = this.lines.length - 1;
	        }
	        var li, hasLastPen = false,
	            line;
	        for (li = i; li >= 0; li--) {
	            line = this.lines[li];
	            hasLastPen = (line != null) && (line.length > 0);
	            if (hasLastPen) {
	                break;
	            }
	        }
	        if (!hasLastPen) {
	            return 0;
	        }

	        var lastPen = line[line.length - 1];
	        return lastPen.endIndex;
	    }

	    getLineWidth(i) {
	        var line = this.lines[i];
	        if (!line) {
	            return 0;
	        }

	        var lastPen = line[line.length - 1];
	        if (lastPen == null) {
	            return 0;
	        }

	        var lineWidth = lastPen.lastX; // start from 0
	        return lineWidth;
	    }

	    getMaxLineWidth() {
	        if (this.maxLinesWidth !== undefined) {
	            return this.maxLinesWidth;
	        }
	        var w, maxW = 0;
	        for (var i = 0, len = this.lines.length; i < len; i++) {
	            w = this.getLineWidth(i);
	            if (w > maxW) {
	                maxW = w;
	            }
	        }
	        this.maxLinesWidth = maxW;
	        return maxW;
	    }

	    getLineWidths() {
	        var result = [];
	        for (var i = 0, len = this.lines.length; i < len; i++) {
	            result.push(this.getLineWidth(i));
	        }
	        return result;
	    }

	    get linesCount() {
	        return this.lines.length;
	    }

	    get plainText() {
	        var txt = "",
	            pens = this.pens;
	        for (var i = 0, len = pens.length; i < len; i++) {
	            txt += pens[i].plainText;
	        }

	        return txt;
	    }

	    get rawTextLength() {
	        var l = 0,
	            pens = this.pens;
	        for (var i = 0, len = this.pens.length; i < len; i++) {
	            l += pens[i].rawTextLength;
	        }

	        return l;
	    }

	    getSliceTagText(start, end, wrap) {
	        var lastPen = this.lastPen;
	        if (lastPen == null) {
	            return '';
	        }
	        var lastPenEnd = lastPen.endIndex;

	        if ((start === undefined) || (start === 0)) {
	            // Image pen before first character
	            start = -1;
	        }

	        if ((end === undefined) || (end === lastPenEnd)) {
	            // Image pen after last character
	            end = lastPenEnd + 1;
	        }
	        if (wrap === undefined) {
	            wrap = false;
	        }

	        var txt = "",
	            pen, penTxt, penStartIdx, penEndIdx, isInRange;
	        var currentProp, previousProp;
	        for (var i = 0, len = this.pens.length; i < len; i++) {
	            pen = this.pens[i];
	            penEndIdx = pen.endIndex;
	            if (penEndIdx <= start) {
	                continue;
	            }
	            pen = this.pens[i];
	            penTxt = (!wrap) ? pen.plainText : pen.wrapText;
	            currentProp = pen.prop;
	            penStartIdx = pen.startIndex;

	            isInRange = (penStartIdx >= start) && (penEndIdx <= end);
	            if (!isInRange) {
	                penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
	            }

	            if (this.tagToTextScope) {
	                txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
	            } else {
	                txt += this.tagToText(penTxt, currentProp, previousProp);
	            }

	            previousProp = currentProp;
	            if (penEndIdx >= end) {
	                break;
	            }
	        }

	        return txt;
	    }

	    get length() {
	        return this.lines.length;
	    }

	    set length(value) {
	        // Only for set length to 0 (clear)
	        this.clear();
	    }
	}
	var PEN_CONFIG = {};

	const Rectangle = Phaser.Geom.Rectangle;

	var RectanglePool = new Stack();
	class HitAreaManager {
	    constructor() {
	        this.hitAreas = [];
	    }

	    destroy() {
	        this.clear();
	    }

	    clear() {
	        // Reuse hitArea(rectangle) later
	        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
	            Clear(this.hitAreas[i].data);
	        }
	        RectanglePool.pushMultiple(this.hitAreas);
	        return this;
	    }

	    add(x, y, width, height, data) {
	        var rectangle = RectanglePool.pop();
	        if (rectangle === null) {
	            rectangle = new Rectangle(x, y, width, height);
	        } else {
	            rectangle.setTo(x, y, width, height);
	        }

	        rectangle.data = data;

	        this.hitAreas.push(rectangle);
	        return this;
	    }

	    getFirst(x, y) {
	        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
	            var hitArea = this.hitAreas[i];
	            if (hitArea.contains(x, y)) {
	                return hitArea;
	            }
	        }
	        return null;
	    }

	    getByKey(key) {
	        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
	            var hitArea = this.hitAreas[i];
	            if (hitArea.data.key === key) {
	                return hitArea;
	            }
	        }
	        return null;
	    }

	    drawBounds(graphics, color, parent) {
	        if (color === undefined) {
	            color = 0xffffff;
	        }

	        if (parent) {
	            graphics
	                .save()
	                .scaleCanvas(parent.scaleX, parent.scaleY)
	                .rotateCanvas(parent.rotation)
	                .translateCanvas(parent.x, parent.y);
	        }

	        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
	            var hitArea = this.hitAreas[i];
	            graphics
	                .lineStyle(1, color)
	                .strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
	        }

	        if (parent) {
	            graphics
	                .restore();
	        }
	        return this;
	    }
	}

	var SetInteractive = function () {
	    this.parent

	        .on('pointerdown', OnAreaDown, this)

	        .on('pointerup', OnAreaUp, this)

	        .on('pointermove', OnAreaOverOut, this)
	        .on('pointerover', OnAreaOverOut, this)
	        .on('pointerout', function (pointer, event) {
	            OnAreaOverOut.call(this, pointer, null, null, event);
	        }, this);
	};

	var OnAreaDown = function (pointer, localX, localY, event) {
	    var area = this.hitAreaManager.getFirst(localX, localY);
	    if (area === null) {
	        return;
	    }

	    var key = area.data.key;
	    FireEvent$1.call(this, 'areadown', key, pointer, localX, localY, event);

	    area.data.isDown = true;
	};

	var OnAreaUp = function (pointer, localX, localY, event) {
	    var area = this.hitAreaManager.getFirst(localX, localY);
	    if (area === null) {
	        return;
	    }

	    var areaData = area.data;

	    var key = areaData.key;
	    FireEvent$1.call(this, 'areaup', key, pointer, localX, localY, event);

	    if (areaData.isDown) {
	        FireEvent$1.call(this, 'areaclick', key, pointer, localX, localY, event);

	        var url = areaData.url;
	        if (url) {
	            window.open(url, '_blank');
	        }
	    }

	    areaData.isDown = false;
	};

	var OnAreaOverOut = function (pointer, localX, localY, event) {
	    if (localX === null) {  // Case of pointerout
	        if (this.lastHitAreaKey !== null) {
	            FireEvent$1.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);
	            this.hitAreaManager.getByKey(this.lastHitAreaKey).isDown = false;
	            this.lastHitAreaKey = null;
	        }
	        return;
	    }

	    var area = this.hitAreaManager.getFirst(localX, localY);
	    var key = (area) ? area.data.key : null;
	    if (this.lastHitAreaKey === key) {
	        return;
	    }

	    if (this.lastHitAreaKey !== null) {
	        FireEvent$1.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);

	        var prevHitArea = this.hitAreaManager.getByKey(this.lastHitAreaKey);
	        if (this.urlTagCursorStyle && !!prevHitArea.data.url) {
	            this.scene.input.manager.canvas.style.cursor = '';
	        }

	        prevHitArea.isDown = false;
	    }
	    if (key !== null) {
	        FireEvent$1.call(this, 'areaover', key, pointer, localX, localY, event);

	        if (this.urlTagCursorStyle && !!area.data.url) {
	            this.scene.input.manager.canvas.style.cursor = this.urlTagCursorStyle;
	        }
	    }

	    this.lastHitAreaKey = key;
	};

	var FireEvent$1 = function (eventName, key, pointer, localX, localY, event) {
	    this.parent.emit(`${eventName}-${key}`, pointer, localX, localY, event);
	    this.parent.emit(eventName, key, pointer, localX, localY, event);
	};

	const NO_NEWLINE$1 = CONST.NO_NEWLINE;
	const RAW_NEWLINE = CONST.RAW_NEWLINE;
	const WRAPPED_NEWLINE$1 = CONST.WRAPPED_NEWLINE;
	const NO_WRAP$1 = CONST.NO_WRAP;
	const WORD_WRAP = CONST.WORD_WRAP;
	const CHAR_WRAP = CONST.CHAR_WRAP;
	const splitRegExp = CONST.SPLITREGEXP;

	var WrapText = function (text, context, wrapMode, wrapWidth, offset, wrapTextLinesPool) {
	    if (wrapWidth <= 0) {
	        wrapMode = NO_WRAP$1;
	    }

	    var retLines = [];
	    if (!text || !text.length) {
	        return retLines;
	    }

	    var isNoWrap = (wrapMode === NO_WRAP$1);

	    var lines = text.split(splitRegExp),
	        line, remainWidth, newLineMode;
	    for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
	        line = lines[i];
	        newLineMode = (i === (linesLen - 1)) ? NO_NEWLINE$1 : RAW_NEWLINE;

	        if (isNoWrap) {
	            var textWidth = context.measureText(line).width;
	            retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
	            continue;
	        }

	        remainWidth = (i === 0) ? (wrapWidth - offset) : wrapWidth;

	        // Short string testing
	        if (line.length <= 100) {
	            var textWidth = context.measureText(line).width;
	            if (textWidth <= remainWidth) {
	                retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
	                continue;
	            }
	        }

	        var tokenArray = ParseLine(line, wrapMode);
	        var token, tokenWidth;
	        var lineText = '', lineWidth = 0;
	        var currLineWidth;
	        for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
	            token = tokenArray[j];
	            tokenWidth = context.measureText(token).width;

	            // Text width of single token is larger than a line width
	            if ((tokenWidth > wrapWidth) && IsWord(token)) {
	                if (lineText !== '') {
	                    // Has pending lineText, flush it out
	                    retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE$1));

	                } else if ((j === 0) && (offset > 0)) {
	                    // No pending lineText, but has previous text. Append a newline
	                    retLines.push(wrapTextLinesPool.getLine('', 0, WRAPPED_NEWLINE$1));

	                }

	                // Word break
	                retLines.push(...WrapText(token, context, CHAR_WRAP, wrapWidth, 0, wrapTextLinesPool));
	                // Continue at last-wordBreak-line
	                var lastwordBreakLine = retLines.pop();
	                lineText = lastwordBreakLine.text;
	                lineWidth = lastwordBreakLine.width;
	                // Free this line
	                wrapTextLinesPool.freeLine(lastwordBreakLine);

	                // Special case : Start at a space character, discard it
	                if (lineText === ' ') {
	                    lineText = '';
	                    lineWidth = 0;
	                }
	                continue;
	            }

	            currLineWidth = lineWidth + tokenWidth;
	            if (currLineWidth > remainWidth) {
	                // New line
	                retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE$1));
	                lineText = token;
	                lineWidth = tokenWidth;
	                remainWidth = wrapWidth;

	            } else {
	                // Append token, continue
	                lineText += token;
	                lineWidth = currLineWidth;
	            }

	            if (j === (tokenLen - 1)) {
	                // Flush remain text
	                retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, newLineMode));
	            }
	        } // for token in tokenArray

	    } // for each line in lines

	    return retLines;
	};

	var ParseLine = function (s, mode) {
	    var tokens;

	    switch (mode) {
	        case WORD_WRAP:
	            tokens = [];
	            s = s.split(' ');
	            for (var i = 0, icnt = s.length; i < icnt; i++) {
	                var token = s[i];
	                if (i < (icnt - 1)) {
	                    tokens.push(token + ' ');
	                } else { // The last token
	                    if (token !== '') {
	                        tokens.push(token);
	                    }
	                }
	            }
	            break;

	        case CHAR_WRAP:
	            tokens = s.split('');
	            break;

	        default: // MIX_WRAP
	            tokens = [];
	            s = s.split(' ');
	            for (var i = 0, icnt = s.length; i < icnt; i++) {
	                var token = s[i];
	                if (i < (icnt - 1)) {
	                    if (IsASCIIString(token)) {
	                        tokens.push(token + ' ');
	                    } else {
	                        tokens.push(...token.split(''));
	                        // Add space as last token
	                        tokens.push(' ');
	                    }
	                } else { // The last token
	                    if (token !== '') {
	                        if (IsASCIIString(token)) {
	                            tokens.push(token);
	                        } else {
	                            tokens.push(...token.split(''));
	                        }
	                    }
	                }

	            }
	            break;
	    }

	    return tokens;
	};

	var IsWord = function (s) {
	    switch (s.length) {
	        case 1: return false;
	        case 2: return (s.charAt(1) !== ' ');
	        default: return true;
	    }
	};

	const GetValue$L = Phaser.Utils.Objects.GetValue;
	const NO_WRAP = CONST.NO_WRAP;
	const NO_NEWLINE = CONST.NO_NEWLINE;
	const WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;

	class CanvasText {
	    constructor(config) {
	        this.parent = config.parent;
	        this.scene = this.parent.scene;
	        this.context = GetValue$L(config, 'context', null);
	        this.canvas = this.context.canvas;
	        this.parser = GetValue$L(config, 'parser', null);
	        this.defaultStyle = GetValue$L(config, 'style', null);
	        this.autoRound = true;

	        this.pensPool = config.pensPool;                     // Required
	        this.linesPool = config.linesPool;                   // Required
	        this.wrapTextLinesPool = config.wrapTextLinesPool;   // Required

	        this.penManager = this.newPenManager();
	        this._tmpPenManager = null;

	        this.hitAreaManager = new HitAreaManager();
	        this.lastHitAreaKey = null;
	        this.urlTagCursorStyle = null;
	    }

	    destroy() {
	        this.parent = undefined;
	        this.scene = undefined;
	        this.context = undefined;
	        this.canvas = undefined;
	        this.parser = undefined;
	        this.defaultStyle = undefined;

	        if (this.penManager) {
	            this.penManager.destroy();
	            this.penManager = undefined;
	        }
	        if (this._tmpPenManager) {
	            this._tmpPenManager.destroy();
	            this._tmpPenManager = undefined;
	        }
	        if (this.hitAreaManager) {
	            this.hitAreaManager.destroy();
	            this.hitAreaManager = undefined;
	        }

	        this.pensPool = undefined;
	        this.linesPool = undefined;
	        this.wrapTextLinesPool = undefined;
	    }

	    updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
	        if (penManager === undefined) {
	            penManager = this.penManager;
	        }
	        penManager.clear();
	        if (text === "") {
	            return penManager;
	        }

	        var textStyle = this.parent.style;
	        if (textStyle.isWrapFitMode) {
	            var padding = this.parent.padding;
	            wrapWidth = textStyle.fixedWidth - padding.left - padding.right;
	        }

	        var canvas = this.canvas;
	        var context = this.context;

	        var cursorX = 0,
	            cursorY = 0;

	        var customTextWrapCallback = textStyle.wrapCallback,
	            customTextWrapCallbackScope = textStyle.wrapCallbackScope;
	        var reuseLines = true;

	        var plainText, curProp, curStyle;
	        var match = this.parser.splitText(text),
	            result, wrapLines,
	            wrapTextLinesPool = this.wrapTextLinesPool;
	        for (var i = 0, len = match.length; i < len; i++) {
	            result = this.parser.tagTextToProp(match[i], curProp);
	            plainText = result.plainText;
	            curProp = result.prop;

	            if (curProp.img) { // Image tag                
	                var imgWidth = this.imageManager.getOuterWidth(curProp.img);
	                if ((wrapWidth > 0) && (wrapMode !== NO_WRAP)) {  // Wrap mode
	                    if (wrapWidth < (cursorX + imgWidth)) {
	                        penManager.addNewLinePen();
	                        cursorY += lineHeight;
	                        cursorX = 0;
	                    }
	                }
	                penManager.addImagePen(cursorX, cursorY, imgWidth, Clone(curProp));
	                cursorX += imgWidth;

	            } else if (plainText !== '') {
	                // wrap text to lines
	                // Save the current context.
	                context.save();
	                curStyle = this.parser.propToContextStyle(this.defaultStyle, curProp);
	                curStyle.buildFont();
	                curStyle.syncFont(canvas, context);
	                curStyle.syncStyle(canvas, context);

	                if (!customTextWrapCallback) {
	                    wrapLines = WrapText(
	                        plainText,
	                        context,
	                        wrapMode, wrapWidth,
	                        cursorX,
	                        wrapTextLinesPool
	                    );

	                } else { // customTextWrapCallback
	                    wrapLines = customTextWrapCallback.call(customTextWrapCallbackScope,
	                        plainText,
	                        context,
	                        wrapWidth,
	                        cursorX
	                    );

	                    if (typeof (wrapLines) === 'string') {
	                        wrapLines = wrapLines.split('\n');
	                    }

	                    var segment;
	                    for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
	                        segment = wrapLines[j];
	                        if (typeof (segment) === 'string') {
	                            wrapLines[j] = wrapTextLinesPool.getLine(
	                                segment,
	                                context.measureText(segment).width,
	                                (j < (jLen - 1)) ? WRAPPED_NEWLINE : NO_NEWLINE
	                            );
	                        } else {
	                            reuseLines = false;
	                        }
	                    }
	                }  // customTextWrapCallback

	                // add pens
	                var segment;
	                for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
	                    segment = wrapLines[j];
	                    penManager.addTextPen(
	                        segment.text,
	                        cursorX, cursorY,
	                        segment.width,
	                        Clone(curProp),
	                        segment.newLineMode
	                    );

	                    if (segment.newLineMode !== NO_NEWLINE) {
	                        cursorX = 0;
	                        cursorY += lineHeight;
	                    } else {
	                        cursorX += segment.width;
	                    }

	                }

	                if (reuseLines) {
	                    wrapTextLinesPool.freeLines(wrapLines);
	                }
	                wrapLines = null;

	                context.restore();

	            }

	        }

	        // Add strokeThinkness to last pen of each line
	        for (var i = 0, len = this.lines.length; i < len; i++) {
	            var line = this.lines[i];
	            var lastPen = line[line.length - 1];
	            if (lastPen) {
	                lastPen.width += this.parser.getStrokeThinkness(this.defaultStyle, lastPen.prop);
	            }
	        }

	        return penManager;
	    }

	    get startXOffset() {
	        return this.defaultStyle.xOffset;
	    }

	    get startYOffset() {
	        return this.defaultStyle.metrics.ascent;
	    }

	    get lines() {
	        return this.penManager.lines;
	    }

	    get displayLinesCount() {
	        var linesCount = this.penManager.linesCount,
	            maxLines = this.defaultStyle.maxLines;
	        if ((maxLines > 0) && (linesCount > maxLines)) {
	            linesCount = maxLines;
	        }
	        return linesCount;
	    }

	    get linesWidth() {
	        return Math.ceil(this.penManager.getMaxLineWidth());
	    }

	    get linesHeight() {
	        var linesCount = this.displayLinesCount;
	        var linesHeight = (this.defaultStyle.lineHeight * linesCount);
	        if (linesCount > 0) {
	            linesHeight -= this.defaultStyle.lineSpacing;
	        }
	        return linesHeight;
	    }

	    get imageManager() {
	        return this.parent.imageManager;
	    }

	    get rtl() {
	        return this.parent.style.rtl;
	    }

	    newPenManager() {
	        return new PenManager({
	            pensPool: this.pensPool,
	            linesPool: this.linesPool,
	            tagToText: this.parser.propToTagText,
	            tagToTextScope: this.parser
	        });
	    }

	    get tmpPenManager() {
	        if (this._tmpPenManager === null) {
	            this._tmpPenManager = this.newPenManager();
	        }
	        return this._tmpPenManager;
	    }

	    getPlainText(text, start, end) {
	        var plainText;
	        if (text == null) {
	            plainText = this.penManager.plainText;
	        } else {
	            var match = this.parser.splitText(text, 1); // PLAINTEXTONLY_MODE
	            plainText = "";
	            for (var i = 0, len = match.length; i < len; i++) {
	                plainText += match[i];
	            }
	        }

	        if ((start != null) || (end != null)) {
	            if (start == null) {
	                start = 0;
	            }
	            if (end == null) {
	                end = plainText.length;
	            }
	            plainText = plainText.substring(start, end);
	        }

	        return plainText;
	    }

	    getPenManager(text, retPenManager) {
	        if (text === undefined) {
	            return this.copyPenManager(retPenManager, this.penManager);
	        }

	        if (retPenManager === undefined) {
	            retPenManager = this.newPenManager();
	        }

	        var defaultStyle = this.defaultStyle;
	        this.updatePenManager(
	            text,
	            defaultStyle.wrapMode,
	            defaultStyle.wrapWidth,
	            defaultStyle.lineHeight,
	            retPenManager
	        );
	        return retPenManager;
	    }

	    getText(text, start, end, wrap) {
	        if (text == null) {
	            return this.penManager.getSliceTagText(start, end, wrap);
	        }

	        var penManager = this.tmpPenManager;
	        var defaultStyle = this.defaultStyle;
	        this.updatePenManager(
	            text,
	            defaultStyle.wrapMode,
	            defaultStyle.wrapWidth,
	            defaultStyle.lineHeight,
	            penManager
	        );

	        return penManager.getSliceTagText(start, end, wrap);
	    }

	    copyPenManager(ret, src) {
	        if (src === undefined) {
	            src = this.penManager;
	        }
	        return src.copy(ret);
	    }

	    getTextWidth(penManager) {
	        if (penManager === undefined) {
	            penManager = this.penManager;
	        }

	        return penManager.getMaxLineWidth();
	    }

	    getLastPen(penManager) {
	        if (penManager === undefined) {
	            penManager = this.penManager;
	        }

	        return penManager.lastPen;
	    }
	}
	var methods$9 = {
	    setInteractive: SetInteractive,
	};

	Object.assign(
	    CanvasText.prototype,
	    DrawMethods,
	    methods$9
	);

	class WrapTextLinesPool extends Stack {
	    freeLine(line) {
	        if (!line) {
	            return;
	        }
	        this.push(line);
	        return this;
	    }

	    freeLines(lines) {
	        if (!lines) {
	            return;
	        }
	        this.pushMultiple(lines);
	        return this;
	    }

	    getLine(text, width, newLineMode) {
	        var l = this.pop();
	        if (l === null) {
	            l = {};
	        }
	        l.text = text;
	        l.width = width;
	        l.newLineMode = newLineMode;
	        return l;
	    }

	}

	const IsPlainObject$e = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$K = Phaser.Utils.Objects.GetValue;

	var AddImage = function (key, config) {
	    if (IsPlainObject$e(key)) {
	        config = key;
	        key = config.key;
	    } else if (config === undefined) {
	        config = {
	            key: key
	        };
	    }

	    if (!config.hasOwnProperty('key')) {
	        config.key = key;
	    }

	    var textureKey = config.key, frameKey = config.frame;
	    var width = config.width, height = config.height;

	    if ((width === undefined) || (height === undefined)) {
	        var frame = this.textureManager.getFrame(textureKey, frameKey);
	        var frameWidth = (frame) ? frame.cutWidth : 0;
	        var frameHeight = (frame) ? frame.cutHeight : 0;
	        if ((width === undefined) && (height === undefined)) {
	            width = frameWidth;
	            height = frameHeight;
	        } else if (width === undefined) {
	            width = frameWidth * (height / frameHeight);
	        } else if (height === undefined) {
	            height = frameHeight * (width / frameWidth);
	        }
	    }

	    this.images[key] = {
	        key: textureKey,
	        frame: frameKey,
	        width: width,
	        height: height,
	        y: GetValue$K(config, 'y', 0),
	        left: GetValue$K(config, 'left', 0),
	        right: GetValue$K(config, 'right', 0),
	        originX: GetValue$K(config, 'originX', 0),
	        originY: GetValue$K(config, 'originY', 0),
	        tintFill: GetValue$K(config, 'tintFill', false),
	    };
	};

	var DrawImage = function (key, context, x, y, color, autoRound) {
	    var imgData = this.get(key);
	    if (!imgData) {
	        // Invalid key
	        return;
	    }

	    var frame = this.textureManager.getFrame(imgData.key, imgData.frame);

	    var width = imgData.width,
	        height = imgData.height;
	    x += imgData.left - (imgData.originX * width);
	    y += imgData.y - (imgData.originY * height);

	    if (!imgData.tintFill) {
	        color = undefined;
	    }

	    DrawFrameToCanvas(
	        frame, context.canvas,
	        x, y, width, height,
	        color, autoRound
	    );
	};

	class ImageManager {
	    constructor(scene) {
	        this.textureManager = scene.sys.textures;
	        this.images = {};
	    }

	    destroy() {
	        this.textureManager = undefined;
	        this.images = undefined;
	    }

	    add(key, config) {
	        if (typeof (key) === 'string') {
	            AddImage.call(this, key, config);
	        } else if (Array.isArray(key)) {
	            var data = key;
	            for (var i = 0, cnt = data.length; i < cnt; i++) {
	                AddImage.call(this, data[i]);
	            }
	        } else {
	            var data = key;
	            for (var key in data) {
	                AddImage.call(this, key, data[key]);
	            }
	        }
	        return this;
	    }

	    has(key) {
	        return this.images.hasOwnProperty(key);
	    }

	    remove(key) {
	        if (this.has(key)) {
	            delete this.images[key];
	        }
	        return this;
	    }

	    get(key) {
	        if (!this.has(key)) {
	            if (this.textureManager.exists(key)) {
	                this.add(key);
	            }
	        }
	        return this.images[key];
	    }

	    getOuterWidth(key) {
	        var data = this.get(key);
	        return (data) ? (data.width + data.left + data.right) : 0;
	    }

	    getFrame(key) {
	        var data = this.get(key);
	        return (data) ? this.textureManager.getFrame(data.key, data.frame) : undefined;
	    }

	    hasTexture(key) {
	        return !!this.getFrame(key);
	    }
	}

	var methods$8 = {
	    draw: DrawImage
	};

	Object.assign(
	    ImageManager.prototype,
	    methods$8
	);

	const IsPlainObject$d = Phaser.Utils.Objects.IsPlainObject;
	const AddToDOM = Phaser.DOM.AddToDOM;
	const CanvasPool = Phaser.Display.Canvas.CanvasPool;
	const GameObject = Phaser.GameObjects.GameObject;
	const GetValue$J = Phaser.Utils.Objects.GetValue;
	const RemoveFromDOM = Phaser.DOM.RemoveFromDOM;
	const SPLITREGEXP = CONST.SPLITREGEXP;
	const UUID$1 = Phaser.Utils.String.UUID;

	// Reuse objects can increase performance
	var SharedPensPools = null;
	var SharedLinesPool = null;
	var SharedWrapTextLinesPool = null;

	class Text extends TextBase {
	    constructor(scene, x, y, text, style, type, parser) {
	        if (IsPlainObject$d(x)) {
	            var config = x;
	            x = GetValue$J(config, 'x', 0);
	            y = GetValue$J(config, 'y', 0);
	            text = GetValue$J(config, 'text', '');
	            style = GetValue$J(config, 'style');
	        }
	        if (x === undefined) {
	            x = 0;
	        }
	        if (y === undefined) {
	            y = 0;
	        }

	        super(scene, type);

	        this.renderer = scene.sys.game.renderer;

	        this.setPosition(x, y);
	        this.setOrigin(0, 0);
	        this.initPipeline();
	        this.initPostPipeline(true);

	        this.canvas = CanvasPool.create(this);

	        this.context = this.canvas.getContext('2d', { willReadFrequently: true });

	        this._imageManager = undefined;

	        if (style) {
	            // Override align
	            if (style.hasOwnProperty('align')) {
	                var halign = style.align;
	                delete style.align;
	                style.halign = halign;
	            }
	            // Has Stroke color but stroke thinkness, set stroke thinkness to 1
	            if (style.hasOwnProperty('stroke') && !style.hasOwnProperty('strokeThickness')) {
	                style.strokeThickness = 1;
	            }
	        }
	        this.style = new TextStyle(this, style);

	        var imageData = GetValue$J(style, 'images', undefined);
	        if (imageData) {
	            this.addImage(imageData);
	        }

	        this.autoRound = true;

	        this._text = undefined;

	        this.padding = {
	            left: 0,
	            right: 0,
	            top: 0,
	            bottom: 0
	        };

	        this.width = 1;

	        this.height = 1;

	        this.dirty = false;

	        //  If resolution wasn't set, force it to 1
	        if (this.style.resolution === 0) {
	            this.style.resolution = 1;
	        }

	        this._crop = this.resetCropObject();

	        //  Create a Texture for this Text object
	        this._textureKey = UUID$1();

	        this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);

	        //  Get the frame
	        this.frame = this.texture.get();

	        //  Set the resolution
	        this.frame.source.resolution = this.style.resolution;

	        if (this.renderer && this.renderer.gl) {
	            //  Clear the default 1x1 glTexture, as we override it later
	            this.renderer.deleteTexture(this.frame.source.glTexture);
	            this.frame.source.glTexture = null;
	        }

	        var sharedPoolMode = GetValue$J(style, 'sharedPool', true);

	        var pensPool, linesPool, wrapTextLinesPool;
	        if (sharedPoolMode) {
	            // Use pools first time
	            if (!SharedPensPools) {
	                SharedPensPools = {};
	                SharedLinesPool = new Stack();
	                SharedWrapTextLinesPool = new WrapTextLinesPool();

	                // Remove cached data
	                this.scene.game.events.once('destroy', function () {
	                    SharedPensPools = null;
	                    SharedLinesPool = null;
	                    SharedWrapTextLinesPool = null;
	                });
	            }
	            if (!SharedPensPools.hasOwnProperty(type)) {
	                SharedPensPools[type] = new Stack();
	            }

	            pensPool = SharedPensPools[type];
	            linesPool = SharedLinesPool;
	            wrapTextLinesPool = SharedWrapTextLinesPool;
	        } else {
	            pensPool = new Stack();
	            linesPool = new Stack();
	            wrapTextLinesPool = new WrapTextLinesPool();
	        }

	        this.canvasText = new CanvasText({
	            parent: this,
	            context: this.context,
	            parser: parser,
	            style: this.style,
	            pensPool: pensPool,
	            linesPool: linesPool,
	            wrapTextLinesPool: wrapTextLinesPool,
	        });
	        this.parser = parser;

	        this.initRTL();

	        if (style && style.padding) {
	            this.setPadding(style.padding);
	        }

	        this.setText(text);

	        this.setUrlTagCursorStyle(GetValue$J(style, 'urlTagCursorStyle', 'pointer'));

	        if (GetValue$J(style, 'interactive', false)) {
	            this.setInteractive();
	        }
	    }

	    preDestroy() {
	        RemoveFromDOM(this.canvas);
	        // Do nothing if canvas did not add to parent node before

	        this.canvasText.destroy();
	        this.canvasText = undefined;

	        if (this._imageManager) {
	            this._imageManager.destroy();
	            this._imageManager = undefined;
	        }

	        CanvasPool.remove(this.canvas);

	        var texture = this.texture;

	        if (texture) {
	            texture.destroy();
	        }
	    }

	    set text(value) {
	        this.setText(value);
	    }
	    get text() {
	        return this._text;
	    }

	    initRTL() {
	        if (!this.style.rtl) {
	            return;
	        }

	        //  Here is where the crazy starts.
	        //
	        //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas
	        //  that is not part of the DOM. It just completely ignores the direction property.

	        this.canvas.dir = 'rtl';

	        //  Experimental atm, but one day ...
	        this.context.direction = 'rtl';

	        //  Add it to the DOM, but hidden within the parent canvas.
	        this.canvas.style.display = 'none';

	        AddToDOM(this.canvas, this.scene.sys.canvas);

	        //  And finally we set the x origin
	        this.originX = 1;
	    }

	    setRTL(rtl) {
	        if (rtl === undefined) {
	            rtl = true;
	        }

	        var style = this.style;
	        if (style.rtl === rtl) {
	            return this;
	        }

	        style.rtl = rtl;

	        if (rtl) {
	            this.canvas.dir = 'rtl';
	            this.context.direction = 'rtl';
	            this.canvas.style.display = 'none';
	            AddToDOM(this.canvas, this.scene.sys.canvas);
	        } else {
	            this.canvas.dir = 'ltr';
	            this.context.direction = 'ltr';
	        }

	        if (style.halign === 'left') {
	            style.halign = 'right';
	        } else if (style.halign === 'right') {
	            style.halign = 'left';
	        }

	        if (this._imageManager) {
	            var images = this._imageManager.images;
	            for (var key in images) {
	                images[key].originX = 1 - images[key].originX;
	            }
	        }

	        return this;
	    }

	    setText(value) {
	        value = GetString(value);

	        if (value === this._text) {
	            return this;
	        }

	        this._text = value;
	        this.updateText();

	        return this;
	    }

	    setPadding(left, top, right, bottom) {
	        if (typeof left === 'object') {
	            var config = left;

	            //  If they specify x and/or y this applies to all
	            var x = GetValue$J(config, 'x', null);

	            if (x !== null) {
	                left = x;
	                right = x;
	            } else {
	                left = GetValue$J(config, 'left', 0);
	                right = GetValue$J(config, 'right', left);
	            }

	            var y = GetValue$J(config, 'y', null);

	            if (y !== null) {
	                top = y;
	                bottom = y;
	            } else {
	                top = GetValue$J(config, 'top', 0);
	                bottom = GetValue$J(config, 'bottom', top);
	            }
	        } else {
	            if (left === undefined) {
	                left = 0;
	            }
	            if (top === undefined) {
	                top = left;
	            }
	            if (right === undefined) {
	                right = left;
	            }
	            if (bottom === undefined) {
	                bottom = top;
	            }
	        }

	        this.padding.left = left;
	        this.padding.top = top;
	        this.padding.right = right;
	        this.padding.bottom = bottom;

	        return this.updateText(false);
	    }

	    updateText(runWrap) {
	        if (runWrap === undefined) {
	            runWrap = true;
	        }
	        var canvasText = this.canvasText;

	        // wrap text to pens
	        var style = this.style;
	        if (runWrap) {
	            canvasText.updatePenManager(
	                this._text,
	                style.wrapMode,
	                style.wrapWidth,
	                style.lineHeight
	            );
	        }

	        // resize
	        var padding = this.padding;
	        var textWidth, textHeight;
	        var linesWidth = Math.ceil(canvasText.linesWidth);
	        if (style.fixedWidth === 0) {
	            this.width = linesWidth + padding.left + padding.right;
	            textWidth = linesWidth;
	        }
	        else {
	            this.width = style.fixedWidth;
	            textWidth = this.width - padding.left - padding.right;
	            if (textWidth < linesWidth) {
	                textWidth = linesWidth;
	            }
	        }
	        if (style.fixedHeight === 0) {
	            this.height = canvasText.linesHeight + padding.top + padding.bottom;
	            textHeight = canvasText.linesHeight;
	        }
	        else {
	            this.height = style.fixedHeight;
	            textHeight = this.height - padding.top - padding.bottom;
	            if (textHeight < canvasText.linesHeight) {
	                textHeight = canvasText.linesHeight;
	            }
	        }

	        var w = this.width;
	        var h = this.height;

	        this.updateDisplayOrigin();

	        var resolution = style.resolution;
	        w *= resolution;
	        h *= resolution;

	        w = Math.max(Math.ceil(w), 1);
	        h = Math.max(Math.ceil(h), 1);

	        var canvas = this.canvas;
	        var context = this.context;
	        if (canvas.width !== w || canvas.height !== h) {
	            canvas.width = w;
	            canvas.height = h;
	            this.frame.setSize(w, h);
	        } else {
	            context.clearRect(0, 0, w, h);
	        }

	        context.save();
	        context.scale(resolution, resolution);

	        // draw
	        var startX = (!this.style.rtl) ? padding.left : padding.right;
	        var startY = padding.top;
	        canvasText.draw(
	            startX,
	            startY,
	            textWidth,
	            textHeight,
	        );

	        context.restore();

	        if (this.renderer && this.renderer.gl) {
	            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
	            if (typeof WEBGL_DEBUG) {
	                this.frame.glTexture.spectorMetadata = { textureKey: 'BBCodeText Game Object' };
	            }
	        }

	        this.dirty = true;

	        var input = this.input;

	        if (input && !input.customHitArea) {
	            input.hitArea.width = this.width;
	            input.hitArea.height = this.height;
	        }

	        return this;
	    }

	    toJSON() {
	        var out = Components.ToJSON(this);

	        //  Extra Text data is added here

	        var data = {
	            autoRound: this.autoRound,
	            text: this._text,
	            style: this.style.toJSON(),
	            resolution: this.resolution,
	            padding: {
	                left: this.padding.left,
	                right: this.padding.right,
	                top: this.padding.top,
	                bottom: this.padding.bottom
	            }
	        };

	        out.data = data;

	        return out;
	    }

	    setInteractive(hitArea, hitAreaCallback, dropZone) {
	        var isInteractived = !!this.input;

	        GameObject.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);

	        if (!isInteractived) {
	            this.canvasText.setInteractive();
	        }

	        return this;
	    }

	    setUrlTagCursorStyle(cursor) {
	        this.urlTagCursorStyle = cursor;
	        return this;
	    }

	    get urlTagCursorStyle() {
	        return this.canvasText.urlTagCursorStyle;
	    }

	    set urlTagCursorStyle(value) {
	        this.canvasText.urlTagCursorStyle = value;
	    }

	    getWrappedText(text, start, end) {
	        if (typeof (text) === 'number') {
	            end = start;
	            start = text;
	            text = undefined;
	        }
	        text = this.canvasText.getText(text, start, end, true);
	        return text.split(SPLITREGEXP);
	    }

	    getPlainText(text, start, end) {
	        if (typeof (text) === 'number') {
	            end = start;
	            start = text;
	            text = undefined;
	        }
	        return this.canvasText.getPlainText(text, start, end);
	    }

	    getText(text, start, end, wrap) {
	        if (typeof (text) === 'number') {
	            wrap = end;
	            end = start;
	            start = text;
	            text = undefined;
	        }
	        if (wrap === undefined) {
	            wrap = false;
	        }
	        return this.canvasText.getText(text, start, end, wrap);
	    }

	    getSubString(text, start, end) {
	        if (typeof (text) === 'number') {
	            end = start;
	            start = text;
	            text = undefined;
	        }
	        return this.getText(text, start, end);
	    }

	    copyPenManager(penManager) {
	        return this.canvasText.copyPenManager(penManager);
	    }

	    getPenManager(text, penManager) {
	        return this.canvasText.getPenManager(text, penManager);
	    }

	    setSize(width, height) {
	        return this.setFixedSize(width, height);
	    }

	    resize(width, height) {
	        return this.setFixedSize(width, height);
	    }

	    get imageManager() {
	        if (!this._imageManager) {
	            this._imageManager = new ImageManager(this.scene);
	        }
	        return this._imageManager;
	    }

	    addImage(key, config) {
	        this.imageManager.add(key, config);
	        return this;
	    }

	    drawAreaBounds(graphics, color) {
	        this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
	        return this;
	    }

	    generateTexture(key, x, y, width, height) {
	        var srcCanvas = this.canvas;
	        if (width === undefined) {
	            width = srcCanvas.width;
	        } else {
	            width *= this.resolution;
	        }
	        if (height === undefined) {
	            height = srcCanvas.height;
	        } else {
	            height *= this.resolution;
	        }

	        CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
	        return this;
	    }
	}

	var methods$7 = {
	    appendText: AppendText$1,
	};

	Object.assign(
	    Text.prototype,
	    methods$7
	);

	var SplitText = function (text, mode) {
	    var TagRegex = this.tagRegex;

	    var result = [];
	    var charIdx = 0;
	    var rawMode = false,
	        escMode = false;
	    while (true) {
	        var regexResult = TagRegex.RE_SPLITTEXT.exec(text);
	        if (!regexResult) {
	            break;
	        }

	        var match = regexResult[0];
	        if (escMode) {
	            if (TagRegex.RE_ESC_CLOSE.test(match)) {
	                escMode = false;
	            } else {
	                continue; // Skip other tags
	            }

	        } else if (rawMode) {
	            if (TagRegex.RE_RAW_CLOSE.test(match)) {
	                rawMode = false;
	            } else {
	                continue; // Skip other tags
	            }

	        } else {
	            if (TagRegex.RE_ESC_OPEN.test(match)) {
	                escMode = true;
	            } else if (TagRegex.RE_RAW_OPEN.test(match)) {
	                rawMode = true;
	            }
	        }

	        var matchEnd = TagRegex.RE_SPLITTEXT.lastIndex;
	        var matchStart = matchEnd - match.length;

	        if (charIdx < matchStart) {
	            var content = text.substring(charIdx, matchStart);
	            result.push(content);
	        }

	        if (mode === undefined) {
	            result.push(match);
	        }

	        charIdx = matchEnd;
	    }

	    var totalLen = text.length;
	    if (charIdx < totalLen) { // Push remainder string
	        result.push(text.substring(charIdx, totalLen));
	    }

	    return result; // [text,...]
	};

	const PROP_REMOVE = false;
	const PROP_ADD = true;

	var GETPROP_RESULT = {
	    plainText: null,
	    prevProp: null
	};

	var TagTextToProp = function (text, prevProp) {
	    var TagRegex = this.tagRegex;

	    // text : result of splitText()
	    if (prevProp == null) {
	        prevProp = {};
	    }
	    var plainText = '';

	    // close image tag
	    if (prevProp.img) {
	        UpdateProp(prevProp, PROP_REMOVE, 'img');
	    }

	    if (prevProp.esc) {
	        if (TagRegex.RE_ESC_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'esc');
	        } else {
	            plainText = text;
	        }

	    } else if (prevProp.raw) {
	        if (TagRegex.RE_RAW_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'raw');
	        } else {
	            plainText = text;
	        }

	    } else {
	        if (TagRegex.RE_ESC_OPEN.test(text)) {
	            UpdateProp(prevProp, PROP_ADD, 'esc', true);
	        } else if (TagRegex.RE_ESC_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'esc');

	        } else if (TagRegex.RE_RAW_OPEN.test(text)) {
	            UpdateProp(prevProp, PROP_ADD, 'raw', true);
	        } else if (TagRegex.RE_RAW_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'raw');

	        } else if (TagRegex.RE_BLOD_OPEN.test(text)) {
	            UpdateProp(prevProp, PROP_ADD, 'b', true);
	        } else if (TagRegex.RE_BLOD_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'b');

	        } else if (TagRegex.RE_ITALICS_OPEN.test(text)) {
	            UpdateProp(prevProp, PROP_ADD, 'i', true);
	        } else if (TagRegex.RE_ITALICS_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'i');

	        } else if (TagRegex.RE_WEIGHT_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_WEIGHT_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'weight', innerMatch[1]);
	        } else if (TagRegex.RE_WEIGHT_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'weight');

	        } else if (TagRegex.RE_SIZE_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_SIZE_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'size', `${innerMatch[1]}px`);
	        } else if (TagRegex.RE_SIZE_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'size');

	        } else if (TagRegex.RE_FAMILY_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_FAMILY_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'family', innerMatch[1]);
	        } else if (TagRegex.RE_FAMILY_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'family');

	        } else if (TagRegex.RE_COLOR_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_COLOR_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'color', innerMatch[1]);
	        } else if (TagRegex.RE_COLOR_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'color');

	        } else if (TagRegex.RE_UNDERLINE_OPEN.test(text)) {
	            UpdateProp(prevProp, PROP_ADD, 'u', true);
	        } else if (TagRegex.RE_UNDERLINE_OPENC.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_UNDERLINE_OPENC);
	            UpdateProp(prevProp, PROP_ADD, 'u', innerMatch[1]);
	        } else if (TagRegex.RE_UNDERLINE_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'u');

	        } else if (TagRegex.RE_STRIKETHROUGH_OPEN.test(text)) {
	            UpdateProp(prevProp, PROP_ADD, 's', true);
	        } else if (TagRegex.RE_STRIKETHROUGH_OPENC.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_STRIKETHROUGH_OPENC);
	            UpdateProp(prevProp, PROP_ADD, 's', innerMatch[1]);
	        } else if (TagRegex.RE_STRIKETHROUGH_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 's');

	        } else if (TagRegex.RE_SHADOW_OPEN.test(text)) {
	            UpdateProp(prevProp, PROP_ADD, 'shadow', true);
	        } else if (TagRegex.RE_SHADOW_OPENC.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_SHADOW_OPENC);
	            UpdateProp(prevProp, PROP_ADD, 'shadow', innerMatch[1]);
	        } else if (TagRegex.RE_SHADOW_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'shadow');

	        } else if (TagRegex.RE_STROKE_OPEN.test(text)) {
	            UpdateProp(prevProp, PROP_ADD, 'stroke', true);
	        } else if (TagRegex.RE_STROKE_OPENC.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_STROKE_OPENC);
	            UpdateProp(prevProp, PROP_ADD, 'stroke', innerMatch[1]);
	        } else if (TagRegex.RE_STROKE_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'stroke');

	        } else if (TagRegex.RE_BGCOLOR_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_BGCOLOR_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'bgcolor', innerMatch[1]);
	        } else if (TagRegex.RE_BGCOLOR_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'bgcolor');

	        } else if (TagRegex.RE_OFFSETY_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_OFFSETY_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'y', parseFloat(innerMatch[1]));
	        } else if (TagRegex.RE_OFFSETY_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'y');

	        } else if (TagRegex.RE_IMAGE_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_IMAGE_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'img', innerMatch[1]);
	        } else if (TagRegex.RE_IMAGE_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'img');

	        } else if (TagRegex.RE_AREA_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_AREA_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'area', innerMatch[1]);
	        } else if (TagRegex.RE_AREA_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'area');

	        } else if (TagRegex.RE_URL_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_URL_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'url', innerMatch[1]);
	        } else if (TagRegex.RE_URL_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'url');

	        } else if (TagRegex.RE_ALIGN_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_ALIGN_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'align', innerMatch[1]);
	        } else if (TagRegex.RE_ALIGN_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'align');

	        } else if (TagRegex.RE_ID_OPEN.test(text)) {
	            var innerMatch = text.match(TagRegex.RE_ID_OPEN);
	            UpdateProp(prevProp, PROP_ADD, 'id', innerMatch[1]);
	        } else if (TagRegex.RE_ID_CLOSE.test(text)) {
	            UpdateProp(prevProp, PROP_REMOVE, 'id');

	        } else {
	            plainText = text;
	        }
	    }

	    var result = GETPROP_RESULT;
	    result.plainText = plainText;
	    result.prop = prevProp;
	    return result;
	};

	var UpdateProp = function (prop, op, key, value) {
	    if (op === PROP_ADD) {
	        // PROP_ADD     
	        prop[key] = value;
	    } else {
	        // PROP_REMOVE        
	        if (prop.hasOwnProperty(key)) {
	            delete prop[key];
	        }
	    }

	    return prop;
	};

	var PropToContextStyle = function (defaultStyle, prop) {
	    var result = STYLE_RESULT;
	    if (!prop.hasOwnProperty('img')) {
	        result.image = null;

	        if (prop.hasOwnProperty('family')) {
	            result.fontFamily = prop.family;
	        } else {
	            result.fontFamily = defaultStyle.fontFamily;
	        }

	        if (prop.hasOwnProperty('size')) {
	            var size = prop.size;
	            if (typeof (size) === 'number') {
	                size = `${size}px`;
	            }
	            result.fontSize = size;
	        } else {
	            result.fontSize = defaultStyle.fontSize;
	        }
	        result.fontStyle = GetFontStyle(prop);

	        if (prop.hasOwnProperty('color')) {
	            result.color = prop.color;
	        } else {
	            result.color = defaultStyle.color;
	        }

	        if (prop.hasOwnProperty('stroke')) {
	            if (prop.stroke === true) {
	                result.stroke = defaultStyle.stroke;
	                result.strokeThickness = defaultStyle.strokeThickness;
	            } else {
	                result.stroke = prop.stroke;
	                result.strokeThickness = defaultStyle.strokeThickness;
	            }
	        } else {
	            result.stroke = defaultStyle.stroke;
	            result.strokeThickness = 0;
	        }
	    } else {
	        result.image = prop.img;
	    }

	    if (prop.hasOwnProperty('shadow')) {
	        if (prop.shadow === true) {
	            result.shadowColor = defaultStyle.shadowColor;
	            result.shadowOffsetX = defaultStyle.shadowOffsetX;
	            result.shadowOffsetY = defaultStyle.shadowOffsetY;
	            result.shadowBlur = defaultStyle.shadowBlur;
	            result.shadowStroke = true;
	            result.shadowFill = true;
	        } else {
	            result.shadowColor = prop.shadow;
	            result.shadowOffsetX = defaultStyle.shadowOffsetX;
	            result.shadowOffsetY = defaultStyle.shadowOffsetY;
	            result.shadowBlur = defaultStyle.shadowBlur;
	            result.shadowStroke = true;
	            result.shadowFill = true;
	        }
	    } else {
	        result.shadowColor = '#000';
	        result.shadowOffsetX = 0;
	        result.shadowOffsetY = 0;
	        result.shadowBlur = 0;
	        result.shadowStroke = false;
	        result.shadowFill = false;
	    }

	    if (prop.hasOwnProperty('u')) {
	        if (prop.u === true) {
	            result.underlineColor = defaultStyle.underlineColor;
	            result.underlineThickness = defaultStyle.underlineThickness;
	            result.underlineOffset = defaultStyle.underlineOffset;
	        } else {
	            result.underlineColor = prop.u;
	            result.underlineThickness = defaultStyle.underlineThickness;
	            result.underlineOffset = defaultStyle.underlineOffset;
	        }
	    } else {
	        result.underlineColor = '#000';
	        result.underlineThickness = 0;
	        result.underlineOffset = 0;
	    }

	    if (prop.hasOwnProperty('s')) {
	        if (prop.s === true) {
	            result.strikethroughColor = defaultStyle.strikethroughColor;
	            result.strikethroughThickness = defaultStyle.strikethroughThickness;
	            result.strikethroughOffset = defaultStyle.strikethroughOffset;
	        } else {
	            result.strikethroughColor = prop.s;
	            result.strikethroughThickness = defaultStyle.strikethroughThickness;
	            result.strikethroughOffset = defaultStyle.strikethroughOffset;
	        }
	    } else {
	        result.strikethroughColor = '#000';
	        result.strikethroughThickness = 0;
	        result.strikethroughOffset = 0;
	    }

	    if (prop.hasOwnProperty('bgcolor')) {
	        result.bgcolor = prop.bgcolor;
	    } else {
	        result.bgcolor = null;
	    }

	    return result;
	};

	var GetFontStyle = function (prop) {
	    var isBold = prop.b;
	    var weight = prop.weight;
	    var isItalic = prop.i;

	    if (isBold || weight || isItalic) {
	        if (isItalic) {
	            if (isBold) {
	                return 'bold italic';
	            } else if (weight) {
	                return `${weight} italic`;
	            } else {
	                return 'italic';
	            }
	        } else {  // !isItalic
	            if (isBold) {
	                return 'bold';
	            } else {
	                return weight.toString();
	            }
	        }
	    } else {
	        return '';
	    }
	};


	var STYLE_RESULT = new TextStyle();

	var PropToTagText = function (text, prop, prevProp) {
	    if (prevProp == null) {
	        prevProp = EMPTYPROP;
	    }

	    var delimiterLeft = this.delimiters[0];
	    var delimiterRight = this.delimiters[1];

	    var headers = [];

	    for (var k in prevProp) {
	        if (!prop.hasOwnProperty(k)) {
	            headers.push(`${delimiterLeft}/${k}${delimiterRight}`);
	        }
	    }

	    for (var k in prop) {
	        var value = prop[k];


	        if (k === 'img') ; else {
	            if (prevProp[k] === value) {
	                continue;
	            }
	        }

	        switch (k) {
	            case 'size':
	                headers.push(`${delimiterLeft}size=${value.replace('px', '')}${delimiterRight}`);
	                break;

	            case 'color':
	            case 'weight':
	            case 'family':
	            case 'stroke':
	            case 'bgcolor':
	            case 'y':
	            case 'img':
	            case 'area':
	            case 'url':
	            case 'align':
	            case 'id':
	                headers.push(`${delimiterLeft}${k}=${value}${delimiterRight}`);
	                break;

	            case 'u':
	            case 's':
	                if (value === true) {
	                    headers.push(`${delimiterLeft}${k}${delimiterRight}`);
	                } else {
	                    headers.push(`${delimiterLeft}${k}=${value}${delimiterRight}`);
	                }
	                break;

	            default:
	                headers.push(`${delimiterLeft}${k}${delimiterRight}`);
	                break;
	        }
	    }

	    headers.push(text);

	    return headers.join('');
	};

	var EMPTYPROP = {};

	var DelimiterLeftSave;
	var DelimiterRightSave;
	var TagRegexSave = {};

	var GetOpenTagRegString = function (delimiterLeft, delimiterRight, tagName, param) {
	    if (param === undefined) {
	        return `${delimiterLeft}${tagName}${delimiterRight}`;
	    } else {
	        return `${delimiterLeft}${tagName}=(${param})${delimiterRight}`;
	    }
	};
	var GetCloseTagRegString = function (delimiterLeft, delimiterRight, tagName) {
	    return `${delimiterLeft}\/${tagName}${delimiterRight}`;
	};

	var GenerateStringRegEx = function (delimiterRight) {
	    return `[^${delimiterRight}]+`
	};
	var NUMBER_PARAM = '[-.0-9]+';

	var colorParameterList = [
	    '[a-zA-Z]+',      // 'white'
	    '#[0-9abcdef]+',  // '#FFFFFF'
	    'rgba?\\(\s*[.0-9]+\s*(,\s*[.0-9]+\s*){2,3}\\)',  // rgb(255,255,255), or rgba(255,255,255,1)
	];
	var COLOR_PARAM = colorParameterList.join('|');  // '[a-z]+|#[0-9abcdef]+'

	var SetDelimiters = function (delimiterLeft, delimiterRight) {
	    if (delimiterRight === undefined) {
	        var delimeters = delimiterLeft;
	        delimiterLeft = delimeters[0];
	        delimiterRight = delimeters[1];
	    }

	    if ((DelimiterLeftSave === delimiterLeft) && (DelimiterRightSave === delimiterRight)) {
	        return false;
	    }

	    DelimiterLeftSave = delimiterLeft;
	    DelimiterRightSave = delimiterRight;

	    delimiterLeft = EscapeRegex(delimiterLeft);
	    delimiterRight = EscapeRegex(delimiterRight);

	    var STR_PARAM = GenerateStringRegEx(delimiterRight);

	    var ESC = 'esc';
	    var ESC_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ESC);
	    var ESC_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ESC);

	    var RAW = 'raw';
	    var RAW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, RAW);
	    var RAW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, RAW);

	    var BLOD = 'b';
	    var BLOD_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BLOD);
	    var BLOD_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BLOD);

	    var ITALICS = 'i';
	    var ITALICS_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ITALICS);
	    var ITALICS_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ITALICS);

	    var WEIGHT = 'weight';
	    var WEIGHT_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, WEIGHT, NUMBER_PARAM);
	    var WEIGHT_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, WEIGHT);

	    var SIZE = 'size';
	    var SIZE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SIZE, NUMBER_PARAM);
	    var SIZE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SIZE);

	    var FAMILY = 'family';
	    var FAMILY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, FAMILY, STR_PARAM);
	    var FAMILY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, FAMILY);

	    var COLOR = 'color';
	    var COLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, COLOR, COLOR_PARAM);
	    var COLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, COLOR);

	    var UNDERLINE = 'u';
	    var UNDERLINE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
	    var UNDERLINE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE, COLOR_PARAM);
	    var UNDERLINE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, UNDERLINE);

	    var STRIKETHROUGH = 's';
	    var STRIKETHROUGH_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
	    var STRIKETHROUGH_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH, COLOR_PARAM);
	    var STRIKETHROUGH_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);

	    var SHADOW = 'shadow';
	    var SHADOW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW);
	    var SHADOW_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW, COLOR_PARAM);
	    var SHADOW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SHADOW);

	    var STROKE = 'stroke';
	    var STROKE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE);
	    var STROKE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE, COLOR_PARAM);
	    var STROKE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STROKE);

	    var BGCOLOR = 'bgcolor';
	    var BGCOLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BGCOLOR, COLOR_PARAM);
	    var BGCOLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BGCOLOR);

	    var OFFSETY = 'y';
	    var OFFSETY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, OFFSETY, NUMBER_PARAM);
	    var OFFSETY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, OFFSETY);

	    var IMAGE = 'img';
	    var IMAGE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, IMAGE, STR_PARAM);
	    var IMAGE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, IMAGE);

	    var AREA = 'area';
	    var AREA_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, AREA, STR_PARAM);
	    var AREA_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, AREA);

	    var URL = 'url';
	    var URL_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, URL, STR_PARAM);
	    var URL_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, URL);

	    var ALIGN = 'align';
	    var ALIGN_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ALIGN, STR_PARAM);
	    var ALIGN_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ALIGN);

	    var ID = 'id';
	    var ID_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ID, STR_PARAM);
	    var ID_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ID);

	    TagRegexSave.RE_ESC_OPEN = new RegExp(ESC_OPEN, 'i');
	    TagRegexSave.RE_ESC_CLOSE = new RegExp(ESC_CLOSE, 'i');

	    TagRegexSave.RE_RAW_OPEN = new RegExp(RAW_OPEN, 'i');
	    TagRegexSave.RE_RAW_CLOSE = new RegExp(RAW_CLOSE, 'i');

	    TagRegexSave.RE_BLOD_OPEN = new RegExp(BLOD_OPEN, 'i');
	    TagRegexSave.RE_BLOD_CLOSE = new RegExp(BLOD_CLOSE, 'i');

	    TagRegexSave.RE_ITALICS_OPEN = new RegExp(ITALICS_OPEN, 'i');
	    TagRegexSave.RE_ITALICS_CLOSE = new RegExp(ITALICS_CLOSE, 'i');

	    TagRegexSave.RE_WEIGHT_OPEN = new RegExp(WEIGHT_OPEN, 'i');
	    TagRegexSave.RE_WEIGHT_CLOSE = new RegExp(WEIGHT_CLOSE, 'i');

	    TagRegexSave.RE_SIZE_OPEN = new RegExp(SIZE_OPEN, 'i');
	    TagRegexSave.RE_SIZE_CLOSE = new RegExp(SIZE_CLOSE, 'i');

	    TagRegexSave.RE_FAMILY_OPEN = new RegExp(FAMILY_OPEN, 'i');
	    TagRegexSave.RE_FAMILY_CLOSE = new RegExp(FAMILY_CLOSE, 'i');

	    TagRegexSave.RE_COLOR_OPEN = new RegExp(COLOR_OPEN, 'i');
	    TagRegexSave.RE_COLOR_CLOSE = new RegExp(COLOR_CLOSE, 'i');

	    TagRegexSave.RE_UNDERLINE_OPEN = new RegExp(UNDERLINE_OPEN, 'i');
	    TagRegexSave.RE_UNDERLINE_OPENC = new RegExp(UNDERLINE_OPENC, 'i');
	    TagRegexSave.RE_UNDERLINE_CLOSE = new RegExp(UNDERLINE_CLOSE, 'i');

	    TagRegexSave.RE_STRIKETHROUGH_OPEN = new RegExp(STRIKETHROUGH_OPEN, 'i');
	    TagRegexSave.RE_STRIKETHROUGH_OPENC = new RegExp(STRIKETHROUGH_OPENC, 'i');
	    TagRegexSave.RE_STRIKETHROUGH_CLOSE = new RegExp(STRIKETHROUGH_CLOSE, 'i');

	    TagRegexSave.RE_SHADOW_OPEN = new RegExp(SHADOW_OPEN, 'i');
	    TagRegexSave.RE_SHADOW_OPENC = new RegExp(SHADOW_OPENC, 'i');
	    TagRegexSave.RE_SHADOW_CLOSE = new RegExp(SHADOW_CLOSE, 'i');

	    TagRegexSave.RE_STROKE_OPEN = new RegExp(STROKE_OPEN, 'i');
	    TagRegexSave.RE_STROKE_OPENC = new RegExp(STROKE_OPENC, 'i');
	    TagRegexSave.RE_STROKE_CLOSE = new RegExp(STROKE_CLOSE, 'i');

	    TagRegexSave.RE_BGCOLOR_OPEN = new RegExp(BGCOLOR_OPEN, 'i');
	    TagRegexSave.RE_BGCOLOR_CLOSE = new RegExp(BGCOLOR_CLOSE, 'i');

	    TagRegexSave.RE_OFFSETY_OPEN = new RegExp(OFFSETY_OPEN, 'i');
	    TagRegexSave.RE_OFFSETY_CLOSE = new RegExp(OFFSETY_CLOSE, 'i');

	    TagRegexSave.RE_IMAGE_OPEN = new RegExp(IMAGE_OPEN, 'i');
	    TagRegexSave.RE_IMAGE_CLOSE = new RegExp(IMAGE_CLOSE, 'i');

	    TagRegexSave.RE_AREA_OPEN = new RegExp(AREA_OPEN, 'i');
	    TagRegexSave.RE_AREA_CLOSE = new RegExp(AREA_CLOSE, 'i');

	    TagRegexSave.RE_URL_OPEN = new RegExp(URL_OPEN, 'i');
	    TagRegexSave.RE_URL_CLOSE = new RegExp(URL_CLOSE, 'i');

	    TagRegexSave.RE_ALIGN_OPEN = new RegExp(ALIGN_OPEN, 'i');
	    TagRegexSave.RE_ALIGN_CLOSE = new RegExp(ALIGN_CLOSE, 'i');

	    TagRegexSave.RE_ID_OPEN = new RegExp(ID_OPEN, 'i');
	    TagRegexSave.RE_ID_CLOSE = new RegExp(ID_CLOSE, 'i');

	    TagRegexSave.RE_SPLITTEXT = new RegExp([
	        RAW_OPEN, RAW_CLOSE,
	        ESC_OPEN, ESC_CLOSE,

	        BLOD_OPEN, BLOD_CLOSE,
	        ITALICS_OPEN, ITALICS_CLOSE,
	        WEIGHT_OPEN, WEIGHT_CLOSE,

	        SIZE_OPEN, SIZE_CLOSE,
	        FAMILY_OPEN, FAMILY_CLOSE,
	        COLOR_OPEN, COLOR_CLOSE,
	        UNDERLINE_OPEN, UNDERLINE_OPENC, UNDERLINE_CLOSE,
	        STRIKETHROUGH_OPEN, STRIKETHROUGH_OPENC, STRIKETHROUGH_CLOSE,
	        SHADOW_OPEN, SHADOW_OPENC, SHADOW_CLOSE,
	        STROKE_OPEN, STROKE_OPENC, STROKE_CLOSE,
	        BGCOLOR_OPEN, BGCOLOR_CLOSE,
	        OFFSETY_OPEN, OFFSETY_CLOSE,
	        IMAGE_OPEN, IMAGE_CLOSE,
	        AREA_OPEN, AREA_CLOSE,
	        URL_OPEN, URL_CLOSE,
	        ALIGN_OPEN, ALIGN_CLOSE,
	        ID_OPEN, ID_CLOSE
	    ].join('|'), 'ig');

	    return true;
	};

	var GetTagRegex = function (delimiterLeft, delimiterRight) {
	    if (delimiterLeft !== undefined) {
	        SetDelimiters(delimiterLeft, delimiterRight);
	    }

	    return Object.assign({}, TagRegexSave);
	};

	const GetValue$I = Phaser.Utils.Objects.GetValue;

	class Parser {
	    constructor(style) {
	        var delimiters = GetValue$I(style, 'delimiters', '[]');
	        this.tagRegex = GetTagRegex(delimiters);
	        this.delimiters = delimiters;
	    }

	    getStrokeThinkness(defaultStyle, prop) {
	        var strokeThickness;
	        if (prop.hasOwnProperty('stroke')) {
	            strokeThickness = defaultStyle.strokeThickness;
	        } else {
	            strokeThickness = 0;
	        }
	        return strokeThickness;
	    }

	    setDelimiters(delimiterLeft, delimiterRight) {
	        if (SetDelimiters(delimiterLeft, delimiterRight)) {
	            this.tagRegex = GetTagRegex();
	        }
	        return this;
	    }

	}

	var methods$6 = {
	    splitText: SplitText,
	    tagTextToProp: TagTextToProp,
	    propToContextStyle: PropToContextStyle,
	    propToTagText: PropToTagText,
	};

	Object.assign(
	    Parser.prototype,
	    methods$6
	);

	class BBCodeText extends Text {
	    constructor(scene, x, y, text, style) {
	        var parser = new Parser(style);
	        super(scene, x, y, text, style, 'rexBBCodeText', parser);
	    }

	    setDelimiters(delimiterLeft, delimiterRight) {
	        this.parse.setDelimiters(delimiterLeft, delimiterRight);
	        return this;
	    }
	}

	class Style extends ComponentBase {
	    constructor(gameObject, style) {
	        super(gameObject);
	        // this.parent = gameObject;

	        return new Proxy(this, this);
	    }

	    get(target, prop) {
	        if (HasProperty(target, prop)) {
	            return target[prop];
	        }

	        var gameObject = target.parent;
	        if (HasProperty(gameObject, prop)) {
	            return gameObject[prop];
	        }
	    }

	    set(target, prop, value) {
	        if (HasProperty(target, prop)) {
	            target[prop] = value;

	        } else if (HasProperty(target.parent, prop)) {
	            target.parent[prop] = value;
	        }

	        return true;
	    }

	    get key() {
	        return this.parent.texture.key;
	    }

	    set key(value) {
	        this.parent.setTexture(value, this.frame);
	    }

	    get fontSize() {
	        return this.parent.fontSize;
	    }

	    set fontSize(value) {
	        this.parent.setFontSize(value);
	    }

	    get tint() {
	        return this.parent.tintTopLeft;
	    }

	    set tint(value) {
	        this.parent.setTint(value);
	    }
	    get letterSpacing() {
	        return this.parent.letterSpacing;
	    }

	    set letterSpacing(value) {
	        this.parent.setLetterSpacing(value);
	    }

	    get lineSpacing() {
	        return this.parent.lineSpacing;
	    }

	    set lineSpacing(value) {
	        this.parent.setLineSpacing(value);
	    }

	}

	const PhaserBitmapText = Phaser.GameObjects.BitmapText;
	const GetValue$H = Phaser.Utils.Objects.GetValue;

	class StatesBitmapText extends PhaserBitmapText {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var x = GetValue$H(config, 'x', 0);
	        var y = GetValue$H(config, 'y', 0);
	        var font = GetValue$H(config, 'font', '');
	        var size = GetValue$H(config, 'fontSize', false);
	        var align = GetValue$H(config, 'align', 0);
	        var tint = GetValue$H(config, 'tint');
	        super(scene, x, y, font, '', size, align);
	        this.type = 'rexStatesBitmapText';

	        if (tint !== undefined) {
	            this.setTint(tint);
	        }

	        var effectConfig = GetValue$H(config, 'effects', true);
	        if (effectConfig) {
	            AddEffectProperties(this, effectConfig);
	        }

	        this.style = new Style(this, config);

	        config.style = this.style;
	        this.addStyleManager(config);

	        delete config.style;
	    }
	}

	Object.assign(
	    StatesBitmapText.prototype,
	    HelperMethods
	);

	const GetValue$G = Phaser.Utils.Objects.GetValue;

	class Label extends LabelBase {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        // Create sizer
	        super(scene, config);
	        this.type = 'rexLabel';

	        // Add elements
	        var background = GetValue$G(config, 'background', undefined);
	        var icon = GetValue$G(config, 'icon', undefined);
	        var iconMask = GetValue$G(config, 'iconMask', undefined);
	        var text = GetValue$G(config, 'text', undefined);
	        var action = GetValue$G(config, 'action', undefined);
	        var actionMask = GetValue$G(config, 'actionMask', undefined);
	        // Align
	        var align = GetValue$G(config, 'align', undefined); // undefined/left/top: no space


	        if (background) {
	            this.addBackground(background);
	        }

	        if (icon) {
	            var padding;
	            if (this.orientation === 0) {
	                if (text || action) {
	                    padding = {
	                        right: GetValue$G(config, 'space.icon', 0),
	                        top: GetValue$G(config, 'space.iconTop', 0),
	                        bottom: GetValue$G(config, 'space.iconBottom', 0),
	                        left: GetValue$G(config, 'space.iconLeft', 0),
	                    };
	                }
	            } else {
	                if (text || action) {
	                    padding = {
	                        bottom: GetValue$G(config, 'space.icon', 0),
	                        left: GetValue$G(config, 'space.iconLeft', 0),
	                        right: GetValue$G(config, 'space.iconRight', 0),
	                        top: GetValue$G(config, 'space.iconTop', 0),
	                    };
	                }
	            }
	            var fitRatio = GetValue$G(config, 'squareFitIcon', false) ? 1 : 0;

	            this.add(
	                icon,
	                { proportion: 0, padding: padding, fitRatio: fitRatio }
	            );

	            if (iconMask) {
	                iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
	            }

	            if (!fitRatio) {
	                var iconSize = GetValue$G(config, 'iconSize', undefined);
	                this.setIconSize(
	                    GetValue$G(config, 'iconWidth', iconSize),
	                    GetValue$G(config, 'iconHeight', iconSize)
	                );
	            }
	        }


	        if (text) {
	            var wrapText = GetValue$G(config, 'wrapText', false);
	            var adjustTextFontSize = GetValue$G(config, 'adjustTextFontSize', false);
	            if (wrapText) {
	                if (wrapText === true) {
	                    wrapText = 'word';
	                }
	                SetWrapMode(text, wrapText);
	                config.expandTextWidth = true;
	                WrapExpandText(text);

	            } else if (adjustTextFontSize) {
	                config.expandTextWidth = true;
	                config.expandTextHeight = true;
	                FontSizeExpandText(text, { fitHeight: true });

	            }

	            var textSpace = GetValue$G(config, 'space.text', 0);
	            var expandTextWidth = GetValue$G(config, 'expandTextWidth', false);
	            var expandTextHeight = GetValue$G(config, 'expandTextHeight', false);
	            var proportion, padding, expand;
	            if (this.orientation === 0) {
	                proportion = (expandTextWidth) ? 1 : 0;
	                if (action) {
	                    padding = { right: textSpace };
	                }
	                expand = expandTextHeight;
	            } else {
	                proportion = (expandTextHeight) ? 1 : 0;
	                if (action) {
	                    padding = { bottom: textSpace };
	                }
	                expand = expandTextWidth;
	            }

	            this.add(
	                text,
	                { proportion: proportion, expand: expand, padding: padding, }
	            );
	        }

	        if (action) {
	            var padding;
	            if (this.orientation === 0) {
	                padding = {
	                    top: GetValue$G(config, 'space.actionTop', 0),
	                    bottom: GetValue$G(config, 'space.actionBottom', 0),
	                    right: GetValue$G(config, 'space.actionRight', 0),
	                };
	            } else {
	                padding = {
	                    left: GetValue$G(config, 'space.actionLeft', 0),
	                    right: GetValue$G(config, 'space.actionRight', 0),
	                    bottom: GetValue$G(config, 'space.actionBottom', 0),
	                };
	            }
	            var fitRatio = GetValue$G(config, 'squareFitAction', false) ? 1 : 0;
	            this.add(
	                action,
	                { proportion: 0, padding: padding, fitRatio: fitRatio }
	            );

	            if (actionMask) {
	                actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
	            }

	            if (!fitRatio) {
	                var actionSize = GetValue$G(config, 'actionSize');
	                this.setActionSize(
	                    GetValue$G(config, 'actionWidth', actionSize),
	                    GetValue$G(config, 'actionHeight', actionSize)
	                );
	            }
	        }

	        this.setChildrenAlignMode(align);

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('icon', icon);
	        this.addChildrenMap('iconMask', iconMask);
	        this.addChildrenMap('text', text);
	        this.addChildrenMap('action', action);
	        this.addChildrenMap('actionMask', actionMask);
	    }
	}

	class SimpleLabel extends Label {
	    constructor(scene, config, creators) {
	        config = BuildLabelConfig$1(scene, config, creators);
	        super(scene, config);
	        this.type = 'rexSimpleLabel';
	    }

	    setActiveState(enable) {
	        RunMethod$1(this.getChildren(), 'setActiveState', enable);
	        return this;
	    }

	    setHoverState(enable) {
	        RunMethod$1(this.getChildren(), 'setHoverState', enable);
	        return this;
	    }

	    setDisableState(enable) {
	        RunMethod$1(this.getChildren(), 'setDisableState', enable);
	        return this;
	    }

	}

	var RunMethod$1 = function (children, methodName, enable) {
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var gameObject = children[i];
	        if (gameObject && gameObject[methodName]) {
	            gameObject[methodName](enable);
	        }
	    }
	};

	var SCROLLMODE = {
	    v: 0,
	    vertical: 0,
	    y: 0,

	    h: 1,
	    horizontal: 1,
	    x: 1,

	    xy: 2,
	    vh: 2,
	};

	var GetScrollMode = function (config, key) {
	    if (key === undefined) {
	        key = 'scrollMode';
	    }

	    if (!config.hasOwnProperty(key)) {
	        config[key] = GetDefaultScrollMode(config);
	    }

	    var scrollMode = config[key];
	    if (typeof (scrollMode) === 'string') {
	        scrollMode = SCROLLMODE[scrollMode];
	    }

	    return scrollMode;
	};

	var GetDefaultScrollMode = function (config) {
	    var hasSliderY = (!!config.sliderY) || (!!config.scrollerY);
	    var hasSliderX = (!!config.sliderX) || (!!config.scrollerX);
	    var scrollMode;
	    if (hasSliderY && hasSliderX) {
	        scrollMode = 2;
	    } else if (hasSliderY) {
	        scrollMode = 0;
	    } else if (hasSliderX) {
	        scrollMode = 1;
	    } else {
	        scrollMode = 0;
	    }
	    return scrollMode;
	};

	var Sum = function () {
	    return Array.prototype.reduce.call(arguments, Add$5, 0);
	};

	var Add$5 = function (a, b) {
	    return a + b;
	};

	var GetChildrenWidth$2 = function (minimumMode) {
	    if (this.rexSizer.hidden) {
	        return 0;
	    }

	    if (minimumMode === undefined) {
	        minimumMode = true;
	    }

	    var result = 0,
	        columnWidth;
	    var children = this.sizerChildren;
	    var child, padding, childWidth, proportion;
	    var hasUnknownChildWidth = false;
	    this.totalColumnProportions;  // To update this.hasColumnProportion0Child member

	    for (var i = 0; i < this.columnCount; i++) {
	        proportion = this.columnProportions[i];
	        columnWidth = 0;
	        if ((proportion === 0) || minimumMode) {
	            for (var j = 0; j < this.rowCount; j++) {
	                child = children[(j * this.columnCount) + i];
	                if (!child) {
	                    continue;
	                }
	                if (child.rexSizer.hidden) {
	                    continue;
	                }

	                childWidth = this.getChildWidth(child);
	                if (childWidth === undefined) {
	                    if ((proportion !== 0) && (!this.hasColumnProportion0Child)) {
	                        childWidth = 0;
	                    } else {
	                        hasUnknownChildWidth = true;
	                    }
	                }

	                if (hasUnknownChildWidth) {
	                    continue;
	                }

	                padding = child.rexSizer.padding;
	                childWidth += (padding.left + padding.right) * this.scaleX;
	                columnWidth = Math.max(columnWidth, childWidth);
	            }

	            if (!hasUnknownChildWidth) {
	                result += columnWidth;
	            }

	        }

	        // else,(proportion > 0) : columnWidth is 0
	        if (!hasUnknownChildWidth) {
	            if (minimumMode) {
	                this.columnWidth[i] = columnWidth;
	            }
	        }
	    }

	    if (hasUnknownChildWidth) {
	        return undefined;
	    }

	    var indentLeft = Math.max(this.space.indentLeftOdd, this.space.indentLeftEven);
	    var totalSpace = Sum(this.space.left, indentLeft, ...this.space.column, this.space.right);
	    return result + (totalSpace * this.scaleX);
	};

	var GetChildrenHeight$2 = function (minimumMode) {
	    if (this.rexSizer.hidden) {
	        return 0;
	    }

	    if (minimumMode === undefined) {
	        minimumMode = true;
	    }

	    var result = 0,
	        rowHeight;
	    var children = this.sizerChildren;
	    var child, padding, childHeight, proportion;
	    var hasUnknownChildHeight = false;
	    this.totalRowProportions;  // To update this.hasColumnProportion0Child member

	    for (var i = 0; i < this.rowCount; i++) {
	        proportion = this.rowProportions[i];
	        rowHeight = 0;
	        if ((proportion === 0) || minimumMode) {
	            for (var j = 0; j < this.columnCount; j++) {
	                child = children[(i * this.columnCount) + j];
	                if (!child) {
	                    continue;
	                }
	                if (child.rexSizer.hidden) {
	                    continue;
	                }

	                childHeight = this.getChildHeight(child);
	                if (childHeight === undefined) {
	                    if ((proportion !== 0) && (!this.hasRowProportion0Child)) {
	                        childHeight = 0;
	                    } else {
	                        hasUnknownChildHeight = true;
	                    }
	                }

	                if (hasUnknownChildHeight) {
	                    continue;
	                }

	                padding = child.rexSizer.padding;
	                childHeight += (padding.top + padding.bottom) * this.scaleY;
	                rowHeight = Math.max(rowHeight, childHeight);
	            }

	            if (!hasUnknownChildHeight) {
	                result += rowHeight;
	            }

	        }
	        // else,(proportion > 0) : rowHeight is 0

	        if (!hasUnknownChildHeight) {
	            if (minimumMode) {
	                this.rowHeight[i] = rowHeight;
	            }
	        }

	    }

	    if (hasUnknownChildHeight) {
	        return undefined;
	    }

	    var indentTop = Math.max(this.space.indentTopOdd, this.space.indentTopEven);
	    var totalSpace = Sum(this.space.top, indentTop, ...this.space.row, this.space.bottom);
	    return result + (totalSpace * this.scaleY);
	};

	var GetExpandedChildWidth$2 = function (child, colWidth) {
	    var childWidth;
	    var childConfig = child.rexSizer;
	    if (childConfig.expandWidth) {
	        var padding = childConfig.padding;
	        childWidth = colWidth - ((padding.left + padding.right) * this.scaleX);
	    }
	    return childWidth;
	};

	var GetExpandedChildHeight$2 = function (child, rowHeight) {
	    var childHeight;
	    var childConfig = child.rexSizer;
	    if (childConfig.expandHeight) {
	        var padding = childConfig.padding;
	        childHeight = rowHeight - ((padding.top + padding.bottom) * this.scaleY);
	    }
	    return childHeight;
	};

	var GetChildrenSizers$2 = function (out) {
	    if (out === undefined) {
	        out = [];
	    }
	    var children = this.sizerChildren,
	        child;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        if (child && child.isRexSizer) {
	            out.push(child);
	        }
	    }
	    return out;
	};

	var PreLayout$2 = function () {
	    this._totalColumnProportions = undefined;
	    this._totalRowProportions = undefined;
	    this.hasColumnProportion0Child = false;
	    this.hasRowProportion0Child = false;
	    this.proportionWidthLength = undefined;  // Display proportion-length, contains scale
	    this.proportionHeightLength = undefined; // Display proportion-length, contains scale
	    PreLayout$4.call(this);
	    return this;
	};

	var LayoutChildren$3 = function () {
	    var child, childConfig, padding;
	    var startX = this.innerLeft,
	        startY = this.innerTop;
	    var itemX,
	        itemY = startY;
	    var x, y, width, height, alignOffsetX, alignOffsetY; // Align zone
	    var childWidth, childHeight;
	    // Layout grid children
	    var colWidth, rowHeight;
	    var indentLeft, indentTop;
	    for (var rowIndex = 0; rowIndex < this.rowCount; rowIndex++) {
	        rowHeight = this.getRowHeight(rowIndex);

	        indentLeft = (rowIndex % 2) ? this.space.indentLeftEven : this.space.indentLeftOdd;
	        itemX = startX + (indentLeft * this.scaleX);
	        for (var columnIndex = 0; columnIndex < this.columnCount; columnIndex++) {
	            colWidth = this.getColumnWidth(columnIndex);

	            child = this.getChildAt(columnIndex, rowIndex);
	            if ((!child) || (child.rexSizer.hidden)) {
	                itemX += colWidth + (this.space.column[columnIndex] * this.scaleX);
	                continue;
	            }

	            PreLayoutChild.call(this, child);

	            childWidth = this.getExpandedChildWidth(child, colWidth);
	            childHeight = this.getExpandedChildHeight(child, rowHeight);
	            if (child.isRexSizer) {
	                child.runLayout(this, childWidth, childHeight);
	                CheckSize(child, this);
	            } else {
	                ResizeGameObject(child, childWidth, childHeight);
	            }

	            childConfig = child.rexSizer;
	            padding = childConfig.padding;

	            x = itemX + (padding.left * this.scaleX);
	            width = colWidth - ((padding.left + padding.right) * this.scaleX);

	            indentTop = (columnIndex % 2) ? this.space.indentTopEven : this.space.indentTopOdd;
	            y = itemY + (indentTop * this.scaleY) + (padding.top * this.scaleY);
	            height = rowHeight - ((padding.top + padding.bottom) * this.scaleY);

	            if (childWidth === undefined) {
	                childWidth = GetDisplayWidth(child);
	            }
	            if (childHeight === undefined) {
	                childHeight = GetDisplayHeight(child);
	            }
	            alignOffsetX = (childConfig.alignOffsetX + (childConfig.alignOffsetOriginX * childWidth)) * this.scaleX;
	            alignOffsetY = (childConfig.alignOffsetY + (childConfig.alignOffsetOriginY * childHeight)) * this.scaleY;

	            LayoutChild.call(this,
	                child, x, y, width, height, childConfig.align,
	                alignOffsetX, alignOffsetY
	            );

	            itemX += colWidth + (this.space.column[columnIndex] * this.scaleX);
	        }

	        itemY += rowHeight + (this.space.row[rowIndex] * this.scaleY);
	    }
	};

	var ResolveWidth = function (width) {
	    var width = ResolveWidth$3.call(this, width);

	    // Calculate proportionLength
	    if ((width !== undefined) && (this.proportionWidthLength === undefined)) {
	        var totalColumnProportions = this.totalColumnProportions;
	        if (totalColumnProportions > 0) {
	            var remainder = width - this.getChildrenWidth(false);
	            if (remainder >= 0) {
	                this.proportionWidthLength = remainder / totalColumnProportions;
	            }
	        } else {
	            this.proportionWidthLength = 0;
	        }
	    }

	    return width;
	};

	var ResolveHeight = function (height) {
	    var height = ResolveHeight$3.call(this, height);

	    // Get proportionLength    
	    if ((height !== undefined) && (this.proportionHeightLength === undefined)) {
	        var totalRowProportions = this.totalRowProportions;
	        if (totalRowProportions > 0) {
	            var remainder = height - this.getChildrenHeight(false);
	            if (remainder >= 0) {
	                this.proportionHeightLength = remainder / totalRowProportions;
	            }
	        } else {
	            this.proportionHeightLength = 0;
	        }
	    }

	    return height;
	};

	var ResolveChildrenWidth = function (parentWidth) {
	    // Resolve width of sizer children
	    var child, expandedChildWidth, childWidth;
	    var colWidth;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (child && child.isRexSizer && !child.ignoreLayout) {
	            colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
	            expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
	            childWidth = child.resolveWidth(expandedChildWidth);
	            if (childWidth === undefined) {
	                childWidth = expandedChildWidth;
	            }
	            child.resolveChildrenWidth(childWidth);
	        }
	    }
	};

	var ResolveChildrenHeight = function (parentHeight) {
	    // Resolve width of sizer children
	    var child, expandedChildHeight, childHeight;
	    var rowHeight;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (child && child.isRexSizer && !child.ignoreLayout) {
	            rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
	            expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
	            childHeight = child.resolveHeight(expandedChildHeight);
	            if (childHeight === undefined) {
	                childHeight = expandedChildHeight;
	            }
	            child.resolveChildrenHeight(childHeight);
	        }
	    }
	};

	var RunWidthWrap$1 = function (width) {
	    var child, expandedChildWidth, childWidth;
	    var colWidth;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (
	            (!child) ||
	            (child.isRexSizer && child.ignoreLayout) ||
	            (!child.runWidthWrap)
	        ) {
	            continue;
	        }

	        colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
	        expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
	        if (child.isRexSizer) {
	            childWidth = child.resolveWidth(expandedChildWidth);
	            if (childWidth === undefined) {
	                childWidth = expandedChildWidth;
	            }
	        }
	        child.runWidthWrap(childWidth);
	    }
	    return this;
	};

	var RunHeightWrap$1 = function (height) {
	    var child, expandedChildHeight, childHeight;
	    var rowHeight;
	    for (var i in this.sizerChildren) {
	        child = this.sizerChildren[i];
	        if (
	            (!child) ||
	            (child.isRexSizer && child.ignoreLayout) ||
	            (!child.runHeightWrap)
	        ) {
	            continue;
	        }

	        rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
	        expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
	        if (child.isRexSizer) {
	            childHeight = child.resolveHeight(expandedChildHeight);
	            if (childHeight === undefined) {
	                childHeight = expandedChildHeight;
	            }
	        }
	        child.runHeightWrap(childHeight);
	    }
	    return this;
	};

	const IsPlainObject$c = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$F = Phaser.Utils.Objects.GetValue;
	const ALIGN_CENTER$2 = Phaser.Display.Align.CENTER;


	var GetEmptyCellIndex = function (columnIndex, rowIndex, cells, columnCount, rowCount) {
	    if ((typeof (columnIndex) === 'number') || (typeof (rowIndex) === 'number')) {
	        if (columnIndex === undefined) {
	            var idx;
	            for (var i = 0; i < columnCount; i++) {
	                idx = (rowIndex * columnCount) + i;
	                if (!cells[idx]) {
	                    return idx;
	                }
	            }
	        } else if (rowIndex === undefined) {
	            var idx;
	            for (var i = 0; i < rowCount; i++) {
	                idx = (i * columnCount) + columnIndex;
	                if (!cells[idx]) {
	                    return idx;
	                }
	            }
	        } else {
	            var idx = (rowIndex * columnCount) + columnIndex;
	            if (!cells[idx]) {
	                return idx;
	            }
	        }

	    } else if (rowIndex === true) {
	        var idx;
	        for (var i = 0; i < columnCount; i++) {
	            for (var j = 0; j < rowCount; j++) {
	                idx = (j * columnCount) + i;
	                if (!cells[idx]) {
	                    return idx;
	                }
	            }
	        }
	    } else {
	        for (var i = 0, cnt = cells.length; i < cnt; i++) {
	            if (!cells[i]) {
	                return i;
	            }
	        }
	    }
	    return null;
	};

	var Add$4 = function (gameObject, columnIndex, rowIndex, align, paddingConfig, expand, childKey) {
	    var offsetX, offsetY;
	    var offsetOriginX, offsetOriginY;

	    AddChild$2.call(this, gameObject);
	    if (IsPlainObject$c(columnIndex)) {
	        var config = columnIndex;
	        columnIndex = GetValue$F(config, 'column', undefined);
	        rowIndex = GetValue$F(config, 'row', undefined);
	        align = GetValue$F(config, 'align', ALIGN_CENTER$2);
	        paddingConfig = GetValue$F(config, 'padding', 0);
	        expand = GetValue$F(config, 'expand', false);
	        childKey = GetValue$F(config, 'key', undefined);

	        offsetX = GetValue$F(config, 'offsetX', 0);
	        offsetY = GetValue$F(config, 'offsetY', 0);
	        offsetOriginX = GetValue$F(config, 'offsetOriginX', 0);
	        offsetOriginY = GetValue$F(config, 'offsetOriginY', 0);
	    }

	    // Get insert index
	    var itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
	    if (itemIndex === null) {
	        // Specific index mode
	        if ((typeof (columnIndex) === 'number') && (typeof (rowIndex) === 'number')) {
	            return this;
	        }

	        if ((rowIndex === true) || (typeof (rowIndex) === 'number')) {
	            this.addEmptyColumn();
	        } else {
	            this.addEmptyRow();
	        }

	        // Get insert index again
	        itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
	    }

	    if (typeof (align) === 'string') {
	        align = AlignConst[align];
	    }
	    if (align === undefined) {
	        align = ALIGN_CENTER$2;
	    }
	    if (paddingConfig === undefined) {
	        paddingConfig = 0;
	    }
	    if (expand === undefined) {
	        expand = true;
	    }

	    if (offsetX === undefined) {
	        offsetX = 0;
	    }
	    if (offsetY === undefined) {
	        offsetY = 0;
	    }
	    if (offsetOriginX === undefined) {
	        offsetOriginX = 0;
	    }
	    if (offsetOriginY === undefined) {
	        offsetOriginY = 0;
	    }

	    var config = this.getSizerConfig(gameObject);
	    config.align = align;
	    config.padding = GetBoundsConfig$1(paddingConfig);

	    if (IsPlainObject$c(expand)) {
	        config.expandWidth = GetValue$F(expand, 'width', false);
	        config.expandHeight = GetValue$F(expand, 'height', false);
	    } else {
	        config.expandWidth = expand;
	        config.expandHeight = expand;
	    }

	    config.alignOffsetX = offsetX;
	    config.alignOffsetY = offsetY;
	    config.alignOffsetOriginX = offsetOriginX;
	    config.alignOffsetOriginY = offsetOriginY;

	    this.sizerChildren[itemIndex] = gameObject;

	    if (childKey !== undefined) {
	        this.addChildrenMap(childKey, gameObject);
	    }
	    return this;
	};

	var AddChildMethods$5 = {
	    add: Add$4
	};

	var Fill = function (arr, value, startIdx, endIdx) {
	    if (startIdx === undefined) {
	        startIdx = 0;
	    }
	    if (endIdx === undefined) {
	        endIdx = arr.length - 1;
	    }
	    for (var i = startIdx; i <= endIdx; i++) {
	        arr[i] = value;
	    }
	    return arr;
	};

	var RemoveChildMethods$5 = {
	    remove(gameObject, destroyChild) {
	        if (this.getParentSizer(gameObject) !== this) {
	            return this;
	        }

	        var idx = this.sizerChildren.indexOf(gameObject);
	        if (idx !== -1) {
	            this.sizerChildren[idx] = null;
	        }

	        RemoveChild$1.call(this, gameObject, destroyChild);
	        return this;
	    },

	    removeAt(columnIndex, rowIndex, destroyChild) {
	        var child = this.getChildAt(columnIndex, rowIndex);
	        if (child) {
	            this.remove(child, destroyChild);
	        }
	        return this;
	    },

	    removeAll(destroyChild) {
	        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
	            var child = this.sizerChildren[i];
	            if (!child) {
	                continue;
	            }

	            this.remove(child, destroyChild);
	        }
	        return this;
	    },

	    clear(destroyChild) {
	        Fill(this.sizerChildren, null);
	        ClearChildren.call(this, destroyChild);
	        return this;
	    }
	};

	var SetSpaceMethods = {
	    setColumnSpace(columnSpace) {
	        if (!this.space.column) {
	            this.space.column = [];
	        }

	        this.space.column.length = this.columnCount - 1;
	        if (typeof (columnSpace) === 'number') {
	            this.space.column0 = columnSpace;
	            Fill(this.space.column, columnSpace);
	        } else {
	            this.space.column0 = columnSpace[0];
	            for (var i = 0, cnt = this.columnCount - 1; i < cnt; i++) {
	                this.space.column[i] = columnSpace[i] || 0;
	            }
	        }
	        return this;
	    },

	    setRowSpace(rowSpace) {
	        if (!this.space.row) {
	            this.space.row = [];
	        }

	        this.space.row.length = this.rowCount - 1;
	        if (typeof (rowSpace) === 'number') {
	            this.space.row0 = rowSpace;
	            Fill(this.space.row, rowSpace);
	        } else {
	            this.space.row0 = rowSpace[i];
	            for (var i = 0, cnt = this.rowCount - 1; i < cnt; i++) {
	                this.space.row[i] = rowSpace[i] || 0;
	            }
	        }

	        return this;
	    },

	    setIndentLeft(odd, even) {
	        this.space.indentLeftOdd = odd;
	        this.space.indentLeftEven = even;
	        return this;
	    },

	    setIndentTop(odd, even) {
	        this.space.indentTopOdd = odd;
	        this.space.indentTopEven = even;
	        return this;
	    }
	};

	const GetValue$E = Phaser.Utils.Objects.GetValue;

	var ResetGrid = function (
	    columnCount, rowCount,
	    columnProportions, rowProportions,
	    space
	) {
	    if (columnCount === undefined) { columnCount = 0; }
	    if (rowCount === undefined) { rowCount = 0; }
	    if (columnProportions === undefined) { columnProportions = 0; }
	    if (rowProportions === undefined) { rowProportions = 0; }

	    this.columnCount = columnCount;
	    this.rowCount = rowCount;
	    this.gridCount = columnCount * rowCount;

	    // children
	    this.removeAll();
	    this.sizerChildren.length = columnCount * rowCount;
	    Fill(this.sizerChildren, null);

	    // proportions
	    this.columnProportions = [];
	    this.columnProportions.length = columnCount;
	    if (typeof (columnProportions) === 'number') {
	        Fill(this.columnProportions, columnProportions);
	    } else {
	        for (var i = 0; i < columnCount; i++) {
	            this.columnProportions[i] = columnProportions[i] || 0;
	        }
	    }
	    this.rowProportions = [];
	    this.rowProportions.length = rowCount;
	    if (typeof (rowProportions) === 'number') {
	        Fill(this.rowProportions, rowProportions);
	    } else {
	        for (var i = 0; i < rowCount; i++) {
	            this.rowProportions[i] = rowProportions[i] || 0;
	        }
	    }

	    // width & height
	    this.columnWidth = [];
	    this.columnWidth.length = columnCount;
	    this.rowHeight = [];
	    this.rowHeight.length = rowCount;

	    // space
	    this.setColumnSpace(GetValue$E(space, 'column', 0));
	    this.setRowSpace(GetValue$E(space, 'row', 0));

	    var scene = this.scene;
	    var createCellContainerCallback = this.createCellContainerCallback;
	    if (createCellContainerCallback) {
	        for (var y = 0, ycnt = this.rowCount; y < ycnt; y++) {
	            for (var x = 0, xcnt = this.columnCount; x < xcnt; x++) {
	                var addConfig = { column: x, row: y };
	                var child = createCellContainerCallback(scene, x, y, addConfig);
	                if (child) {
	                    this.add(child, addConfig);
	                }
	            }
	        }
	    }

	    return this;
	};

	var InsertEmptyRow = function (rowIndex, proportion, space) {
	    if (proportion === undefined) {
	        proportion = this.rowProportions[0] || 0;
	    }
	    if (space === undefined) {
	        space = this.space.row0 || 0;
	    }

	    this.rowCount += 1;
	    this.gridCount += this.columnCount;

	    var args = [rowIndex * this.columnCount, 0];
	    for (var i = 0; i < this.columnCount; i++) {
	        args.push(null);
	    }
	    this.sizerChildren.splice.apply(this.sizerChildren, args);

	    this.rowProportions.push(proportion);

	    this.rowHeight.length += 1;  // this.rowHeight will be recalculated when layout()    

	    this.space.row.splice(rowIndex, 0, space);

	    return this;
	};

	var AddEmptyRow = function (proportion, space) {
	    InsertEmptyRow.call(this, this.rowCount, proportion, space);
	    return this;
	};

	var InsertEmptyColumn = function (colIndex, proportion, space) {
	    if (proportion === undefined) {
	        proportion = this.columnProportions[0] || 0;
	    }
	    if (space === undefined) {
	        space = this.space.column0 || 0;
	    }

	    this.columnCount += 1;
	    this.gridCount += this.rowCount;

	    for (var i = this.rowCount - 1; i >= 0; i--) {
	        var insertIndex = (i * this.columnCount) + colIndex;
	        this.sizerChildren.splice(insertIndex, 0, null);
	    }

	    this.columnProportions.push(proportion);

	    this.columnWidth.length += 1;  // this.columnWidth will be recalculated when layout()    

	    this.space.column.splice(colIndex, 0, space);

	    return this;
	};

	var AddEmptyColumn = function (proportion, space) {
	    InsertEmptyColumn.call(this, this.columnCount, proportion, space);
	    return this;
	};

	var methods$5 = {
	    getChildrenWidth: GetChildrenWidth$2,
	    getChildrenHeight: GetChildrenHeight$2,
	    getExpandedChildWidth: GetExpandedChildWidth$2,
	    getExpandedChildHeight: GetExpandedChildHeight$2,
	    getChildrenSizers: GetChildrenSizers$2,
	    preLayout: PreLayout$2,
	    layoutChildren: LayoutChildren$3,
	    resolveWidth: ResolveWidth,
	    resolveHeight: ResolveHeight,
	    resolveChildrenWidth: ResolveChildrenWidth,
	    resolveChildrenHeight: ResolveChildrenHeight,
	    runWidthWrap: RunWidthWrap$1,
	    runHeightWrap: RunHeightWrap$1,

	    resetGrid: ResetGrid,
	    insertEmptyRow: InsertEmptyRow,
	    addEmptyRow: AddEmptyRow,
	    insertEmptyColumn: InsertEmptyColumn,
	    addEmptyColumn: AddEmptyColumn,
	};

	Object.assign(
	    methods$5,
	    AddChildMethods$5,
	    RemoveChildMethods$5,
	    SetSpaceMethods,
	    SortChildrenMethods
	);

	var GetTotalColumnProportions = function () {
	    var result = 0,
	        proportion;
	    for (var i = 0; i < this.columnCount; i++) {
	        proportion = this.columnProportions[i];
	        if (proportion > 0) {
	            result += proportion;
	        } else if (proportion === 0) {
	            this.hasColumnProportion0Child = true;
	        }
	    }
	    return result;
	};

	var GetTotalRowProportions = function () {
	    var result = 0,
	        proportion;
	    for (var i = 0; i < this.rowCount; i++) {
	        proportion = this.rowProportions[i];
	        if (proportion > 0) {
	            result += proportion;
	        } else if (proportion === 0) {
	            this.hasRowProportion0Child = true;
	        }
	    }
	    return result;
	};

	const IsPlainObject$b = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$D = Phaser.Utils.Objects.GetValue;

	class GridSizer extends Base$2 {
	    constructor(scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportions, config) {
	        if (IsPlainObject$b(x)) {
	            config = x;
	            x = GetValue$D(config, 'x', 0);
	            y = GetValue$D(config, 'y', 0);
	            minWidth = GetValue$D(config, 'width', undefined);
	            minHeight = GetValue$D(config, 'height', undefined);
	            columnCount = GetValue$D(config, 'column', (config.col || 0));
	            rowCount = GetValue$D(config, 'row', 0);
	            columnProportions = GetValue$D(config, 'columnProportions', 0);
	            rowProportions = GetValue$D(config, 'rowProportions', 0);
	        } else if (IsPlainObject$b(minWidth)) {
	            config = minWidth;
	            minWidth = GetValue$D(config, 'width', undefined);
	            minHeight = GetValue$D(config, 'height', undefined);
	            columnCount = GetValue$D(config, 'column', (config.col || 0));
	            rowCount = GetValue$D(config, 'row', 0);
	            columnProportions = GetValue$D(config, 'columnProportions', 0);
	            rowProportions = GetValue$D(config, 'rowProportions', 0);
	        } else if (IsPlainObject$b(columnCount)) {
	            config = columnCount;
	            columnCount = GetValue$D(config, 'column', (config.col || 0));
	            rowCount = GetValue$D(config, 'row', 0);
	            columnProportions = GetValue$D(config, 'columnProportions', 0);
	            rowProportions = GetValue$D(config, 'rowProportions', 0);
	        } else if (IsPlainObject$b(columnProportions)) {
	            config = columnProportions;
	            columnProportions = GetValue$D(config, 'columnProportions', 0);
	            rowProportions = GetValue$D(config, 'rowProportions', 0);
	        }
	        super(scene, x, y, minWidth, minHeight, config);

	        this.type = 'rexGridSizer';
	        this.sizerChildren = [];
	        this.addChildrenMap('items', this.sizerChildren);
	        this.setCreateCellContainerCallback(GetValue$D(config, 'createCellContainerCallback'));

	        this.setIndentLeft(
	            GetValue$D(config, 'space.indentLeftOdd', 0),
	            GetValue$D(config, 'space.indentLeftEven', 0)
	        );
	        this.setIndentTop(
	            GetValue$D(config, 'space.indentTopOdd', 0),
	            GetValue$D(config, 'space.indentTopEven', 0)
	        );

	        this.resetGrid(
	            columnCount, rowCount,
	            columnProportions, rowProportions,
	            GetValue$D(config, 'space', undefined)
	        );

	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        super.destroy(fromScene);

	        // More free resources
	        this.columnProportions = undefined;
	        this.rowProportions = undefined;
	        this.columnWidth = undefined;
	        this.rowHeight = undefined;
	        this.createCellContainerCallback = undefined;
	    }

	    setColumnProportion(columnIndex, proportion) {
	        if (columnIndex >= this.columnProportions.length) {
	            return this;
	        }
	        this.columnProportions[columnIndex] = proportion;
	        return this;
	    }

	    setRowProportion(rowIndex, proportion) {
	        if (rowIndex >= this.rowProportions.length) {
	            return this;
	        }
	        this.rowProportions[rowIndex] = proportion;
	        return this;
	    }

	    get totalColumnProportions() {
	        if (this._totalColumnProportions === undefined) {
	            this._totalColumnProportions = GetTotalColumnProportions.call(this);
	        }
	        return this._totalColumnProportions;
	    }

	    get totalRowProportions() {
	        if (this._totalRowProportions === undefined) {
	            this._totalRowProportions = GetTotalRowProportions.call(this);
	        }
	        return this._totalRowProportions;
	    }

	    getChildAt(columnIndex, rowIndex) {
	        return this.sizerChildren[(rowIndex * this.columnCount) + columnIndex];
	    }

	    childToGridIndex(child, out) {
	        if (!child) {
	            return null;
	        }

	        var index = this.sizerChildren.indexOf(child);
	        if (index === -1) {
	            return null;
	        }

	        if (out === undefined) {
	            out = {};
	        }
	        out.x = index % this.columnCount;
	        out.y = Math.floor(index / this.columnCount);
	        return out;
	    }

	    getColumnWidth(columnIndex) {
	        var colProportion = this.columnProportions[columnIndex];
	        var colWidth = (colProportion === 0) ? this.columnWidth[columnIndex] : (colProportion * this.proportionWidthLength);
	        return colWidth;
	    }

	    getRowHeight(rowIndex) {
	        var rowProportion = this.rowProportions[rowIndex];
	        var rowHeight = (rowProportion === 0) ? this.rowHeight[rowIndex] : (rowProportion * this.proportionHeightLength);
	        return rowHeight;
	    }

	    setCreateCellContainerCallback(callback) {
	        this.createCellContainerCallback = callback;
	        return this;
	    }
	}

	Object.assign(
	    GridSizer.prototype,
	    methods$5
	);

	const GetValue$C = Phaser.Utils.Objects.GetValue;

	var AddChild = function (topPatent, childParent, config) {
	    var childConfig = GetValue$C(config, 'child');
	    var child = GetValue$C(childConfig, 'gameObject', undefined);
	    if (child) {
	        var childSpace = GetValue$C(config, 'space.child', 0);
	        topPatent.childMargin = {};
	        var childMargin = topPatent.childMargin;
	        var childPadding = {};

	        if (typeof (childSpace) === 'number') {
	            // Legacy, add childSpace to slider
	            switch (topPatent.scrollMode) {
	                case 0:
	                case 1:
	                    childMargin.top = 0;
	                    childMargin.bottom = 0;
	                    childMargin.left = 0;
	                    childMargin.right = 0;
	                    break;

	                default:
	                    childMargin.top = childSpace;
	                    childMargin.bottom = childSpace;
	                    childMargin.left = childSpace;
	                    childMargin.right = childSpace;
	                    break;
	            }
	        } else {
	            switch (topPatent.scrollMode) {
	                case 0:
	                    childMargin.top = GetValue$C(childSpace, 'top', 0);
	                    childMargin.bottom = GetValue$C(childSpace, 'bottom', 0);

	                    childPadding.left = GetValue$C(childSpace, 'left', 0);
	                    childPadding.right = GetValue$C(childSpace, 'right', 0);
	                    break;

	                case 1:
	                    childMargin.top = GetValue$C(childSpace, 'left', 0);
	                    childMargin.bottom = GetValue$C(childSpace, 'right', 0);

	                    childPadding.top = GetValue$C(childSpace, 'top', 0);
	                    childPadding.bottom = GetValue$C(childSpace, 'bottom', 0);
	                    break;

	                default: // 2
	                    childMargin.top = GetValue$C(childSpace, 'top', 0);
	                    childMargin.bottom = GetValue$C(childSpace, 'bottom', 0);
	                    childMargin.left = GetValue$C(childSpace, 'left', 0);
	                    childMargin.right = GetValue$C(childSpace, 'right', 0);
	                    break;

	            }
	        }

	        childParent.add(child,
	            {
	                column: 1,
	                row: 1,
	                align: GetValue$C(childConfig, 'align', 'center'),
	                padding: childPadding,
	                expand: {
	                    width: GetValue$C(childConfig, 'expandWidth', true),  // Private
	                    height: GetValue$C(childConfig, 'expandHeight', true) // Private
	                }
	            }
	        );
	    }

	    topPatent.addChildrenMap('child', child);

	};

	const Percent = Phaser.Math.Percent;

	var PositionToPercent = function (startPoint, endPoint, currentPoint) {
	    var value;
	    if (startPoint.y === endPoint.y) {
	        value = Percent(currentPoint.x, startPoint.x, endPoint.x);
	    } else if (startPoint.x === endPoint.x) {
	        value = Percent(currentPoint.y, startPoint.y, endPoint.y);
	    }
	    return value
	};

	var OnDragThumb = function (pointer, dragX, dragY) {
	    if (!this.enable) {
	        return;
	    }
	    tmpPoint$4.x = dragX;
	    tmpPoint$4.y = dragY;

	    var startPoint, endPoint;
	    if (!this.reverseAxis) {
	        startPoint = this.getStartPoint();
	        endPoint = this.getEndPoint();
	    } else {
	        startPoint = this.getEndPoint();
	        endPoint = this.getStartPoint();
	    }
	    this.value = PositionToPercent(startPoint, endPoint, tmpPoint$4);
	};
	var tmpPoint$4 = {};

	var OnTouchTrack = function (pointer, localX, localY) {
	    if (!this.enable) {
	        return;
	    }
	    if (!pointer.isDown) {
	        return;
	    }

	    tmpPoint$3.x = pointer.worldX;
	    tmpPoint$3.y = pointer.worldY;

	    var startPoint, endPoint;
	    if (!this.reverseAxis) {
	        startPoint = this.getStartPoint();
	        endPoint = this.getEndPoint();
	    } else {
	        startPoint = this.getEndPoint();
	        endPoint = this.getStartPoint();
	    }
	    var value = PositionToPercent(startPoint, endPoint, tmpPoint$3);

	    this.stopEaseValue();
	    if ((this.easeValueDuration === 0) || (Math.abs(this.value - value) < 0.1)) {
	        this.value = value;
	    } else {
	        this.easeValueTo(value);
	    }
	};
	var tmpPoint$3 = {};

	var GetThumbAlignPoint = function (align, out) {
	    if (out === undefined) {
	        out = tmpPoint$2;
	    }
	    var thumb = this.childrenMap.thumb;
	    var currentX = thumb.x;
	    var currentY = thumb.y;

	    AlignIn(thumb, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, align);
	    out.x = thumb.x;
	    out.y = thumb.y;

	    thumb.x = currentX;
	    thumb.y = currentY;

	    return out;
	};

	var tmpPoint$2 = {};

	const AlignLeft$1 = Phaser.Display.Align.LEFT_CENTER;
	const AlignTop$1 = Phaser.Display.Align.TOP_CENTER;

	var GetStartPoint = function (out) {
	    if (out === undefined) {
	        out = tmpPoint$1;
	    }
	    if (this.childrenMap.thumb) {
	        var align = (this.orientation === 0) ? AlignLeft$1 : AlignTop$1;
	        GetThumbAlignPoint.call(this, align, out);
	    } else {
	        if (this.orientation === 0) {
	            out.x = this.innerLeft + 1; // Add 1 pixel margin
	            out.y = this.centerY;
	        } else {
	            out.x = this.centerX;
	            out.y = this.innerTop + 1; // Add 1 pixel margin
	        }
	    }
	    return out;
	};

	var tmpPoint$1 = {};

	const AlignRight$1 = Phaser.Display.Align.RIGHT_CENTER;
	const AlignBottom$1 = Phaser.Display.Align.BOTTOM_CENTER;

	var GetEndoint = function (out) {
	    if (out === undefined) {
	        out = tmpPoint;
	    }
	    if (this.childrenMap.thumb) {
	        var align = (this.orientation === 0) ? AlignRight$1 : AlignBottom$1;
	        GetThumbAlignPoint.call(this, align, out);
	    } else {
	        if (this.orientation === 0) {
	            out.x = this.innerRight - 1; // Add 1 pixel margin
	            out.y = this.centerY;
	        } else {
	            out.x = this.centerX;
	            out.y = this.innerBottom - 1; // Add 1 pixel margin
	        }
	    }
	    return out;
	};

	var tmpPoint = {};

	const Linear$b = Phaser.Math.Linear;

	var PercentToPosition = function (t, startPoint, endPoint, out) {
	    if (out === undefined) {
	        out = tmpOut;
	    }
	    out.x = Linear$b(startPoint.x, endPoint.x, t);
	    out.y = Linear$b(startPoint.y, endPoint.y, t);
	    return out;
	};
	var tmpOut = {};

	var UpdateThumb = function (t) {
	    var thumb = this.childrenMap.thumb;
	    if (thumb === undefined) {
	        return this;
	    }

	    if (t === undefined) {
	        t = this.value;
	    }

	    var startPoint, endPoint;
	    if (!this.reverseAxis) {
	        startPoint = this.getStartPoint();
	        endPoint = this.getEndPoint();
	    } else {
	        startPoint = this.getEndPoint();
	        endPoint = this.getStartPoint();
	    }
	    PercentToPosition(t, startPoint, endPoint, thumb);
	    thumb.x += this.thumbOffsetX;
	    thumb.y += this.thumbOffsetY;
	    this.resetChildPositionState(thumb);
	    return this;
	};

	const AlignLeft = Phaser.Display.Align.LEFT_CENTER;
	const AlignTop = Phaser.Display.Align.TOP_CENTER;
	const AlignRight = Phaser.Display.Align.RIGHT_CENTER;
	const AlignBottom = Phaser.Display.Align.BOTTOM_CENTER;

	var UpdateIndicator = function (t) {
	    var indicator = this.childrenMap.indicator;
	    if (indicator === undefined) {
	        return this;
	    }

	    if (t === undefined) {
	        t = this.value;
	    }

	    var reverseAxis = this.reverseAxis;
	    var newWidth, newHeight;
	    var thumb = this.childrenMap.thumb;
	    if (thumb) {
	        if (this.orientation === 0) { // x, extend width
	            var thumbWidth = GetDisplayWidth(thumb);

	            if (!reverseAxis) {
	                var thumbLeft = thumb.x - (thumbWidth * thumb.originX);
	                var thumbRight = thumbLeft + thumbWidth;
	                newWidth = thumbRight - this.left;
	            } else {
	                var thumbLeft = thumb.x - (thumbWidth * thumb.originX);
	                newWidth = this.right - thumbLeft;
	            }
	        } else { // y, extend height
	            var thumbHeight = GetDisplayHeight(thumb);

	            if (!reverseAxis) {
	                var thumbTop = thumb.y - (thumbHeight * thumb.originY);
	                var thumbBottom = thumbTop + thumbHeight;
	                newHeight = thumbBottom - this.top;
	            } else {
	                var thumbTop = thumb.y - (thumbHeight * thumb.originY);
	                newHeight = this.bottom - thumbTop;
	            }
	        }
	    } else {
	        if (this.orientation === 0) { // x, extend width
	            newWidth = this.width * t;
	        } else { // y, extend eight
	            newHeight = this.height * t;
	        }
	    }
	    ResizeGameObject(indicator, newWidth, newHeight);

	    var align;
	    if (!reverseAxis) {
	        align = (this.orientation === 0) ? AlignLeft : AlignTop;
	    } else {
	        align = (this.orientation === 0) ? AlignRight : AlignBottom;
	    }
	    QuickSet(indicator, this, align);

	    this.resetChildPositionState(indicator);
	};

	const GetValue$B = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$a = Phaser.Utils.Objects.IsPlainObject;
	const Clamp$3 = Phaser.Math.Clamp;
	const SnapTo = Phaser.Math.Snap.To;

	class Slider extends ProgressBase(Sizer) {
	    constructor(scene, config) {
	        // Create sizer
	        super(scene, config);
	        this.type = 'rexSlider';

	        this.bootProgressBase(config);

	        this.reverseAxis = GetValue$B(config, 'reverseAxis', false);

	        // Add elements
	        var background = GetValue$B(config, 'background', undefined);
	        var track = GetValue$B(config, 'track', undefined);
	        var indicator = GetValue$B(config, 'indicator', undefined);
	        var thumb = GetValue$B(config, 'thumb', undefined);

	        if (background) {
	            if (IsPlainObject$a(background)) {
	                background = CreateBackground(scene, background);
	            }
	            this.addBackground(background);
	        }

	        if (track) {
	            if (IsPlainObject$a(track)) {
	                track = CreateBackground(scene, track);
	            }
	            this.add(track,
	                {
	                    proportion: 1,
	                    expand: true,
	                    minWidth: ((this.orientation === 0) ? 0 : undefined),
	                    minHeight: ((this.orientation === 1) ? 0 : undefined)
	                }
	            );
	        }

	        if (indicator) {
	            if (IsPlainObject$a(indicator)) {
	                indicator = CreateBackground(scene, indicator);
	            }
	            this.pin(indicator); // Put into container but not layout it
	        }

	        if (thumb) {
	            if (IsPlainObject$a(thumb)) {
	                thumb = CreateBackground(scene, thumb);
	            }
	            this.pin(thumb); // Put into container but not layout it

	            var thumbOffsetX = GetValue$B(config, 'thumbOffsetX', 0);
	            var thumbOffsetY = GetValue$B(config, 'thumbOffsetY', 0);
	            this.setThumbOffset(thumbOffsetX, thumbOffsetY);
	        }

	        // Input
	        var inputMode = GetValue$B(config, 'input', 0);
	        if (typeof (inputMode) === 'string') {
	            inputMode = INPUTMODE[inputMode];
	        }
	        switch (inputMode) {
	            case 0: // 'drag'
	                if (thumb) {
	                    thumb.setInteractive();
	                    this.scene.input.setDraggable(thumb);
	                    thumb
	                        .on('drag', OnDragThumb, this)
	                        .on('dragstart', function (pointer) {
	                            this.eventEmitter.emit('inputstart', pointer);
	                        }, this)
	                        .on('dragend', function (pointer) {
	                            this.eventEmitter.emit('inputend', pointer);
	                        }, this);

	                }
	                break;
	            case 1: // 'click'
	                this
	                    .on('pointerdown', OnTouchTrack, this)
	                    .on('pointermove', OnTouchTrack, this)
	                    .on('pointerdown', function (pointer) {
	                        this.eventEmitter.emit('inputstart', pointer);
	                    }, this)
	                    .on('pointerup', function (pointer) {
	                        this.eventEmitter.emit('inputend', pointer);
	                    }, this)
	                    .on('pointerover', function (pointer) {
	                        if (pointer.isDown) {
	                            this.eventEmitter.emit('inputstart', pointer);
	                        }
	                    }, this)
	                    .on('pointerout', function (pointer) {
	                        if (pointer.isDown) {
	                            this.eventEmitter.emit('inputend', pointer);
	                        }
	                    }, this)
	                    .setInteractive();

	                break;
	        }

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('track', track);
	        this.addChildrenMap('indicator', indicator);
	        this.addChildrenMap('thumb', thumb);

	        this.setEnable(GetValue$B(config, 'enable', undefined));

	        var gap = GetValue$B(config, 'tick', undefined);
	        if (gap === undefined) {
	            gap = GetValue$B(config, 'gap', undefined);
	        }
	        this.setGap(gap);

	        this.setValue(GetValue$B(config, 'value', 0), GetValue$B(config, 'min', undefined), GetValue$B(config, 'max', undefined));

	    }

	    setEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.enable = enable;
	        return this;
	    }

	    setGap(gap, min, max) {
	        if (gap && (min !== undefined)) {
	            gap = gap / (max - min);
	        }

	        this.gap = gap;
	        return this;
	    }

	    setTick(tick, min, max) {
	        this.setGap(tick, min, max);
	        return this;
	    }

	    get tick() {
	        return this.gap;
	    }

	    set tick(value) {
	        this.gap = value;
	    }

	    setThumbOffset(x, y) {
	        this.thumbOffsetX = x;
	        this.thumbOffsetY = y;
	        return this;
	    }

	    // Override
	    get value() {
	        return this._value;
	    }

	    // Override
	    set value(value) {
	        if (this.gap !== undefined) {
	            value = SnapTo(value, this.gap);
	        }
	        var oldValue = this._value;
	        this._value = Clamp$3(value, 0, 1);

	        if (oldValue !== this._value) {
	            this.updateThumb(this._value);
	            this.updateIndicator(this._value);
	            this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
	        }
	    }

	    postLayout(parent, newWidth, newHeight) {
	        this.updateThumb();
	        this.updateIndicator();
	        super.postLayout(parent, newWidth, newHeight);
	        return this;
	    }
	}

	const INPUTMODE = {
	    pan: 0,
	    drag: 0,
	    click: 1,
	    none: -1,
	};

	var methods$4 = {
	    getStartPoint: GetStartPoint,
	    getEndPoint: GetEndoint,
	    updateThumb: UpdateThumb,
	    updateIndicator: UpdateIndicator,
	};

	Object.assign(
	    Slider.prototype,
	    methods$4,
	);

	const GetValue$A = Phaser.Utils.Objects.GetValue;

	class ScrollBar extends Sizer {
	    constructor(scene, config) {
	        // Create sizer
	        super(scene, config);
	        this.type = 'rexScrollBar';

	        // Add elements
	        var background = GetValue$A(config, 'background', undefined);

	        var buttonsConfig = GetValue$A(config, 'buttons', undefined);
	        var button0 = GetValue$A(buttonsConfig, 'top', GetValue$A(buttonsConfig, 'left', undefined));
	        var button1 = GetValue$A(buttonsConfig, 'bottom', GetValue$A(buttonsConfig, 'right', undefined));

	        var slider,
	            sliderConfig = GetValue$A(config, 'slider', undefined);

	        if (background) {
	            this.addBackground(background);
	        }

	        if (button0) {
	            this.add(button0);

	            var inTouching = new InTouching(button0);
	            inTouching
	                .on('intouch', function () {
	                    if (!this.enable) {
	                        return;
	                    }
	                    var step = (!slider.reverseAxis) ? -this.scrollStep : this.scrollStep;
	                    this.value += step;
	                }, this);
	        }

	        if (sliderConfig) {
	            sliderConfig.orientation = this.orientation;
	            sliderConfig.eventEmitter = this;
	            sliderConfig.value = null;

	            var proportion;
	            if (this.orientation === 0) {
	                var sliderWidth = GetValue$A(sliderConfig, 'width', undefined);
	                proportion = (sliderWidth === undefined) ? 1 : 0;
	            } else {
	                var sliderHeight = GetValue$A(sliderConfig, 'height', undefined);
	                proportion = (sliderHeight === undefined) ? 1 : 0;
	            }

	            slider = new Slider(scene, sliderConfig);
	            scene.add.existing(slider);
	            this.add(
	                slider,
	                {
	                    proportion: proportion,
	                }
	            );
	        }

	        if (button1) {
	            this.add(button1);

	            var inTouching = new InTouching(button1);
	            inTouching
	                .on('intouch', function () {
	                    if (!this.enable) {
	                        return;
	                    }
	                    var step = (!slider.reverseAxis) ? this.scrollStep : -this.scrollStep;
	                    this.value += step;
	                }, this);
	        }

	        var buttons = [button0, button1];

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('slider', slider);
	        this.addChildrenMap('buttons', buttons);

	        var callback = GetValue$A(config, 'valuechangeCallback', null);
	        if (callback !== null) {
	            var scope = GetValue$A(config, 'valuechangeCallbackScope', undefined);
	            this.on('valuechange', callback, scope);
	        }
	        this.setEnable(GetValue$A(config, 'enable', undefined));
	        this.setValue(GetValue$A(config, 'value', 0));
	        this.setScrollStep(GetValue$A(buttonsConfig, 'step', 0.01));
	    }

	    setScrollStep(value) {
	        this.scrollStep = value;
	        return this;
	    }

	    get enable() {
	        if (this.childrenMap.slider) {
	            return this.childrenMap.slider.enable;
	        } else {
	            return false;
	        }
	    }

	    set enable(value) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.setEnable(value);
	        }
	    }

	    setEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.enable = enable;
	        return this;
	    }

	    get value() {
	        if (this.childrenMap.slider) {
	            return this.childrenMap.slider.value;
	        } else {
	            return 0;
	        }
	    }

	    set value(value) {
	        if (!this.childrenMap.slider) {
	            return;
	        }
	        this.childrenMap.slider.value = value;
	    }

	    setValue(value, min, max) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.setValue(value, min, max);
	        }
	        return this;
	    }

	    addValue(inc, min, max) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.addValue(inc, min, max);
	        }
	        return this;
	    }

	    getValue(min, max) {
	        if (this.childrenMap.slider) {
	            return this.childrenMap.slider.getValue(min, max);
	        } else {
	            return 0;
	        }
	    }

	    easeValueTo(value, min, max) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.easeValueTo(value, min, max);
	        }
	        return this;
	    }

	    stopEaseValue() {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.stopEaseValue();
	        }
	        return this;
	    }

	    setEaseValueDuration(duration) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.setEaseValueDuration(duration);
	        }
	        return this;
	    }

	    setEaseValueFunction(ease) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.setEaseValueFunction(ease);
	        }
	        return this;
	    }

	    setGap(gap, min, max) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.setGap(gap, min, max);
	        }
	        return this;
	    }

	    get gap() {
	        if (this.childrenMap.slider) {
	            return this.childrenMap.slider.gap;
	        }
	        return undefined;
	    }

	    set gap(value) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.gap = value;
	        }
	    }

	    setTick(tick, min, max) {
	        this.setGap(tick, min, max);
	        return this;
	    }

	    get tick() {
	        if (this.childrenMap.slider) {
	            return this.childrenMap.slider.tick;
	        }
	        return undefined;
	    }

	    set tick(value) {
	        if (this.childrenMap.slider) {
	            this.childrenMap.slider.tick = value;
	        }
	    }

	}

	var CreateScrollbar = function (scene, config) {
	    if (config === undefined) {
	        config = {};
	    }

	    var sliderConfig = Clone(config);
	    config = {
	        slider: sliderConfig
	    };

	    // Move orientation parameter from sliderConfig to config
	    config.orientation = sliderConfig.orientation;
	    delete sliderConfig.orientation;

	    // Move background parameter from sliderConfig to config
	    config.background = sliderConfig.background;
	    delete sliderConfig.background;

	    // Move buttons parameter from sliderConfig to config
	    config.buttons = sliderConfig.buttons;
	    delete sliderConfig.buttons;

	    config.value = null;  // Don't assign initial value (0)

	    var scrollBar = new ScrollBar(scene, config);
	    scene.add.existing(scrollBar);

	    var slider = scrollBar.childrenMap.slider;
	    scrollBar.addChildrenMap('track', slider.childrenMap.track);
	    scrollBar.addChildrenMap('indicator', slider.childrenMap.indicator);
	    scrollBar.addChildrenMap('thumb', slider.childrenMap.thumb);

	    return scrollBar;
	};

	class State extends FSM {
	    constructor(parent, config) {
	        super(config);
	        this.parent = parent;
	        this.init();
	    }

	    init() {
	        this.start('IDLE');
	    }

	    // IDLE -> DRAGBEGIN|DRAG
	    next_IDLE() {
	        var nextState,
	            parent = this.parent,
	            dragState = parent.dragState;
	        if (dragState.isDown) {
	            nextState = (parent.dragThreshold === 0) ? 'DRAG' : 'DRAGBEGIN';
	        }
	        return nextState;
	    }
	    update_IDLE(time, delta) {
	        this.next();
	    }
	    // IDLE

	    // DRAGBEGIN -> DRAG|IDLE
	    next_DRAGBEGIN() {
	        var nextState,
	            parent = this.parent,
	            dragState = parent.dragState;
	        if (dragState.isDown) {
	            nextState = (dragState.pointer.getDistance() >= parent.dragThreshold) ? 'DRAG' : 'DRAGBEGIN';
	        } else { // dragState.isUp
	            nextState = 'IDLE';
	        }
	        return nextState;
	    }
	    update_DRAGBEGIN(time, delta) {
	        this.next();
	    }
	    // DRAGBEGIN

	    // DRAG -> BACK|SLIDE|IDLE
	    next_DRAG() {
	        var nextState,
	            parent = this.parent,
	            dragState = parent.dragState;
	        if (dragState.isUp) {
	            if (parent.outOfBounds) {
	                nextState = 'BACK';
	            } else if (parent.slidingEnable) {
	                nextState = 'SLIDE';
	            } else {
	                nextState = 'IDLE';
	            }
	        }
	        return nextState;
	    }
	    update_DRAG(time, delta) {
	        var parent = this.parent,
	            dragState = parent.dragState;
	        if (dragState.justMoved) {
	            parent.dragging();
	        }
	        this.next();
	    }
	    enter_DRAG() {
	        this.parent.onDragStart();
	    }
	    exit_DRAG() {
	        this.parent.onDragEnd();
	    }
	    // DRAG    

	    // SLIDE -> DRAG|IDLE
	    next_SLIDE() {
	        var nextState,
	            parent = this.parent,
	            dragState = parent.dragState;
	        if (dragState.isDown) {
	            nextState = 'DRAG';
	        } else if (!parent.isSliding) {
	            nextState = 'IDLE';
	        }
	        return nextState;
	    }
	    enter_SLIDE() {
	        this.parent.onSliding();
	    }
	    exit_SLIDE() {
	        this.parent.stop();
	    }
	    update_SLIDE(time, delta) {
	        this.parent.sliding(time, delta);
	        this.next();
	    }
	    // SLIDE    

	    // BACK -> DRAG|IDLE
	    next_BACK() {
	        var nextState,
	            parent = this.parent,
	            dragState = parent.dragState;
	        if (dragState.isDown) {
	            nextState = 'DRAG';
	        } else if (!parent.isPullBack) {
	            nextState = 'IDLE';
	        }
	        return nextState;
	    }
	    enter_BACK() {
	        this.parent.onPullBack();
	    }
	    exit_BACK() {
	        this.parent.stop();
	    }
	    update_BACK(time, delta) {
	        this.parent.pullBack(time, delta);
	        this.next();
	    }
	    // BACK
	}

	const GetValue$z = Phaser.Utils.Objects.GetValue;
	const DistanceBetween$1 = Phaser.Math.Distance.Between;

	class DragSpeed extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        this._enable = undefined;

	        this.rectBoundsInteractive = GetValue$z(config, 'rectBoundsInteractive', false);

	        if (!this.rectBoundsInteractive) {
	            gameObject.setInteractive(GetValue$z(config, "inputConfig", undefined));
	        }

	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.pointer = undefined;
	        this.isInTouched = false;
	        this.holdStartTime = undefined;
	        this.x = undefined;
	        this.y = undefined;
	        this.preX = undefined;
	        this.preY = undefined;
	        this.localX = undefined;
	        this.localY = undefined;
	        this.justMoved = false;
	        this.setEnable(GetValue$z(o, 'enable', true));
	        this.holdThreshold = GetValue$z(o, 'holdThreshold', 50); // ms
	        this.pointerOutReleaseEnable = GetValue$z(o, 'pointerOutRelease', true);
	        return this;
	    }

	    boot() {
	        var scene = this.scene;
	        var gameObject = this.parent;

	        if (!this.rectBoundsInteractive) {
	            // Drag start only when pointer down
	            gameObject.on('pointerdown', this.onPointIn, this);

	            gameObject.on('pointerup', this.onPointOut, this);

	            if (this.pointerOutReleaseEnable) {
	                gameObject.on('pointerout', this.onPointOut, this);
	            }

	            gameObject.on('pointermove', this.onPointerMove, this);

	        } else {
	            scene.input.on('pointerdown', this.onPointIn, this);

	            scene.input.on('pointerup', this.onPointOut, this);

	            scene.input.on('pointermove', this.onPointerMove, this);
	        }

	        scene.sys.events.on('preupdate', this.preupdate, this);
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        var scene = this.scene;
	        this.parent;

	        if (!this.rectBoundsInteractive) ; else {
	            scene.input.off('pointerdown', this.onPointIn, this);

	            scene.input.off('pointerup', this.onPointOut, this);

	            scene.input.off('pointermove', this.onPointerMove, this);
	        }

	        scene.sys.events.off('preupdate', this.preupdate, this);

	        this.pointer = undefined;

	        super.shutdown(fromScene);
	    }

	    get enable() {
	        return this._enable;
	    }

	    set enable(e) {
	        if (this._enable === e) {
	            return;
	        }

	        if (!e) {
	            this.isInTouched = false;
	            this.pointer = undefined;
	        }
	        this._enable = e;
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        this.enable = e;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }

	    setPointerOutReleaseEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.pointerOutReleaseEnable = enable;
	        return this;
	    }

	    get isDown() {
	        return this.pointer && this.pointer.isDown;
	    }

	    get isUp() {
	        return !this.isDown;
	    }

	    get dx() {
	        return this.x - this.preX;
	    }

	    get dy() {
	        return this.y - this.preY;
	    }

	    get dt() {
	        var delta = GetTickDelta(this.scene);
	        return delta;
	    }

	    get speed() {
	        if ((this.x === this.preX) && (this.y === this.preY)) {
	            return 0;
	        }
	        var d = DistanceBetween$1(this.preX, this.preY, this.x, this.y);
	        var speed = d / (this.dt * 0.001);
	        return speed;
	    }

	    get speedX() {
	        return this.dx / (this.dt * 0.001);
	    }

	    get speedY() {
	        return this.dy / (this.dt * 0.001);
	    }

	    // internal
	    onPointIn(pointer, localX, localY) {
	        if ((!this.enable) ||
	            (!pointer.isDown) ||
	            (this.pointer !== undefined)) {
	            return;
	        }

	        if (
	            this.rectBoundsInteractive &&
	            !IsPointerInBounds(this.parent, pointer)
	        ) {
	            return;
	        }

	        this.pointer = pointer;
	        this.localX = localX;
	        this.localY = localY;
	    }

	    onPointOut(pointer) {
	        if ((!this.enable) ||
	            (this.pointer !== pointer)) {
	            return;
	        }
	        this.pointer = undefined;
	    }

	    onPointerMove(pointer, localX, localY) {
	        if ((!this.enable) ||
	            (!pointer.isDown) ||
	            (this.pointer !== pointer)) {
	            return;
	        }

	        if (
	            this.rectBoundsInteractive &&
	            this.pointerOutReleaseEnable &&
	            !IsPointerInBounds(this.parent, pointer)
	        ) {
	            this.onPointOut(pointer);
	            return;
	        }

	        this.localX = localX;
	        this.localY = localY;
	    }

	    preupdate(time, delta) {
	        if (!this.enable) {
	            return;
	        }

	        var pointer = this.pointer;
	        this.justMoved = false;
	        if (pointer && (!this.isInTouched)) {
	            // Touch start
	            this.x = pointer.worldX;
	            this.y = pointer.worldY;
	            this.preX = pointer.worldX;
	            this.preY = pointer.worldY;
	            this.isInTouched = true;
	            this.holdStartTime = undefined;
	            this.emit('touchstart', pointer, this.localX, this.localY);

	        } else if (pointer && this.isInTouched) {
	            // In touch
	            if ((this.x === pointer.x) && (this.y === pointer.y)) {
	                // Hold
	                if (this.holdStartTime === undefined) {
	                    this.holdStartTime = time;
	                } else if (time - this.holdStartTime > this.holdThreshold) {
	                    this.preX = this.x;
	                    this.preY = this.y;
	                }
	            } else {
	                // Move
	                this.preX = this.x;
	                this.preY = this.y;
	                this.x = pointer.worldX;
	                this.y = pointer.worldY;
	                this.holdStartTime = undefined;
	                this.justMoved = true;
	                this.emit('touchmove', pointer, this.localX, this.localY);
	            }

	        } else if ((!pointer) && this.isInTouched) {
	            // Touch end
	            this.isInTouched = false;
	            this.holdStartTime = undefined;
	            this.emit('touchend', pointer);

	        }
	    }
	}

	const GetValue$y = Phaser.Utils.Objects.GetValue;

	class Movement {
	    constructor(config) {
	        this.resetFromJSON(config);
	    }

	    resetFromJSON(o) {
	        this.setValue(GetValue$y(o, 'value', 0));
	        this.setSpeed(GetValue$y(o, 'speed', 0));
	        this.setAcceleration(GetValue$y(o, 'acceleration', 0));
	        return this;
	    }

	    reset() {
	        this.setValue(0);
	        this.setSpeed(0);
	        this.setAcceleration(0);
	    }

	    setValue(value) {
	        this.value = value;
	        return this;
	    }

	    setSpeed(speed) {
	        // speed == 0 : stop
	        // speed  > 0 : move
	        this.speed = speed;
	        return this;        
	    }

	    setAcceleration(acc) {
	        // acc == 0 : constant speed
	        // acc  > 0 : acceleration
	        // acc  < 0 : deceleration
	        this.acceleration = acc;
	        return this;
	    }

	    updateSpeed(delta) {
	        // delta in sec
	        if (this.acceleration !== 0) {
	            this.speed += (this.acceleration * delta);
	            if (this.speed < 0) {
	                this.speed = 0;
	            }
	        }
	        return this;
	    }

	    getDeltaValue(delta) {
	        // delta in sec
	        this.updateSpeed(delta);
	        if (this.speed <= 0) {
	            return 0;
	        }
	        return (this.speed * delta);
	    }

	    update(delta) {
	        // delta in sec
	        this.updateSpeed(delta);
	        if (this.speed > 0) {
	            this.value += this.getDeltaValue(delta);
	        }
	        return this;
	    }

	    get isMoving() {
	        return (this.speed > 0);
	    }
	}

	class SlowDown {
	    constructor() {
	        this.value;
	        this.dir; // true:+, false:-
	        this.movement = new Movement();
	    }

	    init(start, dir, speed, dec, end) {
	        this.value = start;
	        this.end = end;
	        if (end !== undefined) {
	            this.dir = (start < end);
	        } else {
	            this.dir = dir;
	        }

	        this.movement
	            .setSpeed(speed)
	            .setAcceleration(-dec);
	        return this;
	    }

	    stop() {
	        this.movement.reset();
	    }

	    update(delta) {
	        // delta in sec
	        var d = this.movement.getDeltaValue(delta);
	        if (!this.dir) {
	            d = -d;
	        }

	        if (this.end === undefined) {
	            this.value += d;
	        } else {
	            if (d === 0) {
	                this.value = this.end;
	            } else {
	                this.value += d;
	                if (this.dir) { // +
	                    if (this.value > this.end) {
	                        this.value = this.end;
	                    }
	                } else { // -
	                    if (this.value < this.end) {
	                        this.value = this.end;
	                    }
	                }
	            }
	        }
	        return this;
	    }

	    get isMoving() {
	        return this.movement.isMoving;
	    }
	}

	const GetValue$x = Phaser.Utils.Objects.GetValue;
	const Clamp$2 = Phaser.Math.Clamp;

	class Scroller extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        var enable = GetValue$x(config, 'enable', true);
	        this._state = new State(this, {
	            enable: enable,
	            eventEmitter: false,
	        });

	        var drapSpeedConfig = {
	            rectBoundsInteractive: GetValue$x(config, 'rectBoundsInteractive', false),
	            inputConfig: GetValue$x(config, 'inputConfig', undefined),
	            enable: enable,
	            pointerOutRelease: GetValue$x(config, 'pointerOutRelease', true),
	            eventEmitter: false,
	        };
	        this.dragState = new DragSpeed(gameObject, drapSpeedConfig);

	        this._enable = undefined;
	        this._value = undefined;
	        this._slowDown = new SlowDown();

	        var callback = GetValue$x(config, 'valuechangeCallback', null);
	        if (callback !== null) {
	            var scope = GetValue$x(config, 'valuechangeCallbackScope', undefined);
	            this.on('valuechange', callback, scope);
	        }
	        callback = GetValue$x(config, 'overmaxCallback', null);
	        if (callback !== null) {
	            var scope = GetValue$x(config, 'overmaxCallbackScope', undefined);
	            this.on('overmax', callback, scope);
	        }
	        callback = GetValue$x(config, 'overminCallback', null);
	        if (callback !== null) {
	            var scope = GetValue$x(config, 'overminCallbackScope', undefined);
	            this.on('overmin', callback, scope);
	        }

	        this.resetFromJSON(config);
	        this.boot();
	    }

	    resetFromJSON(o) {
	        this.setOrientationMode(GetValue$x(o, 'orientation', 0));
	        this.setDragThreshold(GetValue$x(o, 'threshold', 10));
	        this.setSlidingDeceleration(GetValue$x(o, 'slidingDeceleration', 5000));
	        this.setBackDeceleration(GetValue$x(o, 'backDeceleration', 2000));

	        var dragRate = GetValue$x(o, 'dragRate', 1);
	        dragRate = dragRate * (GetValue$x(o, 'dragReverse', false) ? -1 : 1);
	        this.setDragRate(dragRate);

	        var bounds = GetValue$x(o, 'bounds', undefined);
	        if (bounds) {
	            this.setBounds(bounds);
	        } else {
	            this.setBounds(GetValue$x(o, 'max', 0), GetValue$x(o, 'min', 0));
	        }
	        this.setValue(GetValue$x(o, 'value', this.maxValue || 0));
	        this.setEnable(GetValue$x(o, "enable", true));
	        return this;
	    }

	    boot() {
	        this.scene.sys.events.on('preupdate', this._state.update, this._state);
	    }

	    shutdown(fromScene) {
	        // Already shutdown
	        if (this.isShutdown) {
	            return;
	        }

	        this.scene.sys.events.off('preupdate', this._state.update, this._state);
	        this._state.destroy(fromScene);
	        this.dragState.destroy(fromScene);
	        this._state = undefined;
	        this.dragState = undefined;

	        super.shutdown(fromScene);
	    }

	    get enable() {
	        return this._enable;
	    }

	    set enable(e) {
	        if (this._enable === e) {
	            return;
	        }

	        this._enable = e;
	        this._state.setEnable(e);
	        this.dragState.setEnable(e);

	        return this;
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        this.enable = e;
	        return this;
	    }

	    toggleEnable() {
	        this.setEnable(!this.enable);
	        return this;
	    }

	    setOrientationMode(m) {
	        if (typeof (m) === 'string') {
	            m = ORIENTATIONMODE[m];
	        }
	        this.orientationMode = m;
	        return this;
	    }

	    setDragThreshold(distance) {
	        this.dragThreshold = distance;
	        return this;
	    }

	    setSlidingDeceleration(dec) {
	        this.slidingDeceleration = dec;
	        return this;
	    }

	    setBackDeceleration(dec) {
	        this.backDeceleration = dec;
	        return this;
	    }

	    setDragRate(ratio) {
	        this.dragRate = ratio;
	        return this;
	    }

	    setBounds(value0, value1) {
	        if (Array.isArray(value0)) {
	            var bounds = value0;
	            value0 = bounds[0];
	            value1 = bounds[1];
	        }
	        if (value0 < value1) {
	            this.minValue = value0;
	            this.maxValue = value1;
	        } else {
	            this.minValue = value1;
	            this.maxValue = value0;
	        }
	        return this;
	    }

	    get value() {
	        return this._value;
	    }

	    set value(value) {
	        if (value === this._value) {
	            return;
	        }

	        var oldValue = this._value;
	        var isOverMax = this.overMax(value);
	        var isOverMin = this.overMin(value);
	        if (isOverMax) {
	            this.emit('overmax', value, oldValue);
	        }
	        if (isOverMin) {
	            this.emit('overmin', value, oldValue);
	        }
	        if (!this.backEnable) {
	            if (isOverMax) {
	                value = this.maxValue;
	            }
	            if (isOverMin) {
	                value = this.minValue;
	            }
	        }

	        this._value = value;
	        this.emit('valuechange', value, oldValue);
	    }

	    setValue(value, clamp) {
	        if (clamp === undefined) {
	            clamp = false;
	        }

	        if (clamp) {
	            value = Clamp$2(value, this.minValue, this.maxValue);
	        }

	        this.value = value;
	        return this;
	    }

	    addValue(inc, clamp) {
	        this.setValue(this.value + inc, clamp);
	        return this;
	    }

	    get state() {
	        return this._state.state;
	    }

	    get isDragging() {
	        return this.dragState.isInTouched;
	    }

	    get outOfMaxBound() {
	        return this.overMax(this.value);
	    }

	    get outOfMinBound() {
	        return this.overMin(this.value);
	    }

	    get outOfBounds() {
	        return this.outOfMinBound || this.outOfMaxBound;
	    }

	    // internal
	    overMax(value) {
	        return (this.maxValue != null) && (value > this.maxValue);
	    }

	    overMin(value) {
	        return (this.minValue != null) && (value < this.minValue);
	    }

	    get backEnable() {
	        return (typeof (this.backDeceleration) === 'number');
	    }

	    get isPullBack() {
	        return this._slowDown.isMoving;
	    }

	    get slidingEnable() {
	        return (typeof (this.slidingDeceleration) === 'number');
	    }

	    get isSliding() {
	        return this._slowDown.isMoving;
	    }

	    get dragDelta() {
	        var delta;
	        if (this.orientationMode === 0) { // y
	            delta = this.dragState.dy;
	        } else if (this.orientationMode === 1) { // x
	            delta = this.dragState.dx;
	        } else {
	            delta = 0;
	        }
	        delta *= this.dragRate;
	        return delta;
	    }

	    get dragSpeed() {
	        var speed;
	        if (this.orientationMode === 0) { // y
	            speed = this.dragState.speedY;
	        } else if (this.orientationMode === 1) { // x
	            speed = this.dragState.speedX;
	        } else {
	            speed = 0;
	        }
	        speed *= this.dragRate;
	        return speed;
	    }

	    // enter_DRAG
	    onDragStart() {
	        this.emit('dragstart');
	    }

	    // exit_DRAG
	    onDragEnd() {
	        this.emit('dragend');
	    }

	    // everyTick_DRAG
	    dragging() {
	        this.value += this.dragDelta;
	    }

	    // enter_SLIDE 
	    onSliding() {
	        var start = this.value;
	        var speed = this.dragSpeed;
	        if (speed === 0) {
	            this._slowDown.stop();
	            this._state.next();
	            return;
	        }
	        var dec = this.slidingDeceleration;
	        this._slowDown.init(start, (speed > 0), Math.abs(speed), dec);
	    }

	    // everyTick_SLIDE
	    sliding(time, delta) {
	        delta *= 0.001;
	        var newValue = this._slowDown.update(delta).value;
	        if (this.overMax(newValue)) {
	            this.value = this.maxValue;
	            this._slowDown.stop();
	        } else if (this.overMin(newValue)) {
	            this.value = this.minValue;
	            this._slowDown.stop();
	        } else {
	            this.value = newValue;
	        }
	    }

	    // enter_BACK
	    onPullBack() {
	        var start = this.value;
	        var end = (this.outOfMinBound) ? this.minValue : this.maxValue;
	        var dist = Math.abs(end - start);
	        var dec = this.backDeceleration;
	        var speed = Math.sqrt(2 * dec * dist);
	        this._slowDown.init(start, undefined, speed, dec, end);
	    }

	    // everyTick_BACK
	    pullBack(time, delta) {
	        delta *= 0.001;
	        this.value = this._slowDown.update(delta).value;

	        if (!this._slowDown.isMoving) {
	            this._state.next();
	        }
	    }

	    // exit_SLIDE, exit_BACK
	    stop() {
	        this._slowDown.stop();
	    }

	}

	const ORIENTATIONMODE = {
	    y: 0,
	    v: 0,
	    vertical: 0,
	    x: 1,
	    h: 1,
	    horizontal: 1,
	};

	const GetValue$w = Phaser.Utils.Objects.GetValue;

	class MouseWheelScroller extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        if (this.parent !== this.scene) {
	            this.focusMode = GetValue$w(config, 'focus', true);
	        } else {
	            this.focusMode = false;
	        }

	        if (typeof (this.focusMode) === 'boolean') {
	            this.focusMode = (this.focusMode) ? 1 : 0;
	        }

	        this.setSpeed(GetValue$w(config, 'speed', 0.1));
	        this.setEnable(GetValue$w(config, 'enable', true));

	        switch (this.focusMode) {
	            case 0:
	            case 2:
	                this.scene.input.on('wheel', this.onSceneScroll, this);
	                break;

	            default:  // case 1
	                gameObject
	                    .setInteractive(GetValue$w(config, "inputConfig", undefined))
	                    .on('wheel', function (pointer, dx, dy, dz, event) {
	                        this.tryScroll(dy);
	                    }, this);
	                break;
	        }
	    }

	    destroy() {
	        switch (this.focusMode) {
	            case 0:
	            case 2:
	                this.scene.input.off('wheel', this.onSceneScroll, this);
	                break;
	        }
	    }

	    onSceneScroll(pointer, currentlyOver, dx, dy, dz, event) {
	        if (this.focusMode === 2) {
	            if (!IsPointerInBounds(this.parent, pointer)) {
	                return;
	            }
	        }

	        this.tryScroll(dy);
	    }

	    setEnable(e) {
	        if (e === undefined) {
	            e = true;
	        }

	        this.enable = e;
	        return this;
	    }

	    setSpeed(speed) {
	        this.speed = speed;
	        return this;
	    }

	    tryScroll(dy) {
	        if (!this.enable) {
	            return;
	        }
	        this.scroll(dy);
	        return this;
	    }

	    scroll(dy) {
	        dy *= this.speed;
	        this.emit('scroll', dy, this.parent, this);
	        return this;
	    }
	}

	const GetValue$v = Phaser.Utils.Objects.GetValue;

	var AddSlider = function (topPatent, sliderParent, axis, config) {
	    axis = axis.toUpperCase();
	    var isAxisY = (axis === 'Y');
	    var isScrollXYMode = (topPatent.scrollMode === 2);
	    var child = topPatent.childrenMap.child;

	    var sliderConfig, slider;
	    var sliderConfigKey = `slider${axis}`;
	    if (isScrollXYMode) {
	        sliderConfig = GetValue$v(config, sliderConfigKey, undefined);
	    } else {
	        if (config.hasOwnProperty(sliderConfigKey)) {
	            sliderConfig = GetValue$v(config, sliderConfigKey, undefined);
	        } else {
	            sliderConfig = GetValue$v(config, 'slider', undefined);
	        }
	    }

	    if (sliderConfig) {
	        if (sliderConfig === true) {
	            sliderConfig = {};
	        }

	        sliderConfig.orientation = (isAxisY) ? 1 : 0;
	        slider = CreateScrollbar(topPatent.scene, sliderConfig);

	        slider.tickLength = GetValue$v(sliderConfig, 'tickLength', undefined);

	        var column, row, padding;

	        var sliderPosition = GetValue$v(sliderConfig, 'position', 0);
	        if (typeof (sliderPosition) === 'string') {
	            sliderPosition = SLIDER_POSITION_MAP[sliderPosition];
	        }

	        /*
	        1. space.sliderX, space.sliderY
	        2. space.slider
	        3. space.child
	        */
	        var sliderPadding = GetValue$v(config, `space.slider${axis}`, undefined);
	        var childPadding;  // Legacy
	        if (sliderPadding === undefined) {
	            sliderPadding = GetValue$v(config, 'space.slider', undefined);
	            if (sliderPadding === undefined) {
	                if (isScrollXYMode) {
	                    sliderPadding = 0;
	                } else {
	                    childPadding = GetValue$v(config, 'space.child', 0);
	                }
	            }
	        }

	        var isNumberSliderPadding;
	        if (childPadding === undefined) {
	            isNumberSliderPadding = (typeof (sliderPadding) === 'number');
	        } else {
	            isNumberSliderPadding = (typeof (childPadding) === 'number');
	        }

	        if (isAxisY) {
	            if (sliderPosition === 0) { // right
	                column = 2;
	                row = 1;

	                if (childPadding === undefined) {
	                    padding = (isNumberSliderPadding) ? { left: sliderPadding } : sliderPadding;
	                } else {
	                    padding = { left: GetValue$v(childPadding, 'right', childPadding) };
	                }

	            } else { // left
	                column = 0;
	                row = 1;

	                if (childPadding === undefined) {
	                    padding = (isNumberSliderPadding) ? { right: sliderPadding } : sliderPadding;
	                } else {
	                    padding = { right: GetValue$v(childPadding, 'left', childPadding) };
	                }
	            }

	        } else {
	            if (sliderPosition === 0) { // bottom
	                column = 1;
	                row = 2;

	                if (childPadding === undefined) {
	                    padding = (isNumberSliderPadding) ? { top: sliderPadding } : sliderPadding;
	                } else {
	                    padding = { top: GetValue$v(childPadding, 'bottom', childPadding) };
	                }

	            } else { // top
	                column = 1;
	                row = 0;

	                if (childPadding === undefined) {
	                    padding = (isNumberSliderPadding) ? { bottom: sliderPadding } : sliderPadding;
	                } else {
	                    padding = { bottom: GetValue$v(childPadding, 'top', childPadding) };
	                }
	            }
	        }

	        sliderParent.add(slider,
	            {
	                column: column,
	                row: row,
	                align: 'center',
	                padding: padding,
	                expand: true,
	            }
	        );

	        topPatent[`hideUnscrollableSlider${axis}`] = GetValue$v(sliderConfig, 'hideUnscrollableSlider', false);
	        topPatent[`disableUnscrollableDrag${axis}`] = GetValue$v(sliderConfig, 'disableUnscrollableDrag', false);
	        topPatent[`adaptThumb${axis}SizeMode`] = GetValue$v(sliderConfig, 'adaptThumbSize', false);
	        topPatent[`minThumb${axis}Size`] = GetValue$v(sliderConfig, 'minThumbSize', undefined);

	    } else {
	        topPatent[`hideUnscrollableSlider${axis}`] = false;
	        topPatent[`disableUnscrollableDrag${axis}`] = false;
	        topPatent[`adaptThumb${axis}SizeMode`] = false;
	        topPatent[`minThumb${axis}Size`] = undefined;
	    }

	    // 0=gameObject, 1=rectBounds
	    var scrollDetectionMode = GetValue$v(config, 'scrollDetectionMode');
	    if (typeof (scrollDetectionMode) === 'string') {
	        scrollDetectionMode = SCROLLDECTIONMODE_MAP[scrollDetectionMode];
	    }

	    var scrollerConfig, scroller;
	    var scrollerConfigKey = `scroller${axis}`;
	    if (isScrollXYMode) {
	        scrollerConfig = GetValue$v(config, scrollerConfigKey, true);
	    } else {
	        if (config.hasOwnProperty(scrollerConfigKey)) {
	            scrollerConfig = GetValue$v(config, scrollerConfigKey, true);
	        } else {
	            scrollerConfig = GetValue$v(config, 'scroller', true);
	        }
	    }

	    if (scrollerConfig && child) {
	        if (scrollerConfig === true) {
	            scrollerConfig = {};
	        }

	        scrollerConfig.orientation = (isAxisY) ? 0 : 1;

	        if (scrollDetectionMode !== undefined) {
	            scrollerConfig.rectBoundsInteractive = (scrollDetectionMode === 1);
	        }

	        scroller = new Scroller(child, scrollerConfig);

	        if (child.isRexContainerLite) {
	            // Send touch detection sensor to back
	            child.sendChildToBack(child);
	        }
	    }

	    var mouseWheelScrollerConfig = GetValue$v(config, ((isScrollXYMode) ? `mouseWheelScroller${axis}` : 'mouseWheelScroller'), false),
	        mouseWheelScroller;
	    if (mouseWheelScrollerConfig && child) {
	        if (scrollDetectionMode !== undefined) {
	            mouseWheelScrollerConfig.focus = (scrollDetectionMode === 1) ? 2 : 0;
	        }

	        mouseWheelScroller = new MouseWheelScroller(child, mouseWheelScrollerConfig);
	    }

	    topPatent.addChildrenMap(`slider${axis}`, slider);
	    topPatent.addChildrenMap(`scroller${axis}`, scroller);
	    topPatent.addChildrenMap(`mouseWheelScroller${axis}`, mouseWheelScroller);

	    if ((!isScrollXYMode) || (isAxisY)) {
	        topPatent['hideUnscrollableSlider'] = topPatent[`hideUnscrollableSlider${axis}`];
	        topPatent['disableUnscrollableDrag'] = topPatent[`disableUnscrollableDrag${axis}`];
	        topPatent['adaptThumbSizeMode'] = topPatent[`adaptThumb${axis}SizeMode`];
	        topPatent['minThumbSize'] = topPatent[`minThumb${axis}Size`];

	        topPatent.addChildrenMap('slider', slider);
	        topPatent.addChildrenMap('scroller', scroller);
	        topPatent.addChildrenMap('mouseWheelScroller', mouseWheelScroller);
	    }


	    // Control
	    if (slider) {
	        var keyST, eventName;
	        if (isScrollXYMode) {
	            keyST = (isAxisY) ? 't' : 's';
	            eventName = `scroll${axis}`;
	        } else {
	            keyST = 't';
	            eventName = 'scroll';
	        }
	        slider
	            .on('valuechange', function (newValue) {
	                topPatent[keyST] = newValue;
	                topPatent.emit(eventName, topPatent);
	            });
	    }

	    if (scroller) {
	        var keyChildOXY, eventName;
	        if (isScrollXYMode) {
	            keyChildOXY = `childO${axis}`;
	            eventName = `scroll${axis}`;
	        } else {
	            keyChildOXY = 'childOY';
	            eventName = 'scroll';
	        }
	        scroller
	            .on('valuechange', function (newValue) {
	                topPatent[keyChildOXY] = newValue;
	                topPatent.emit(eventName, topPatent);
	            });
	    }

	    if (mouseWheelScroller) {
	        var methodAddChildOXY;
	        if (isScrollXYMode) {
	            methodAddChildOXY = `addChildO${axis}`;
	        } else {
	            methodAddChildOXY = 'addChildOY';
	        }
	        mouseWheelScroller
	            .on('scroll', function (incValue) {
	                topPatent[methodAddChildOXY](-incValue, true);
	            });
	    }
	};

	const SLIDER_POSITION_MAP = {
	    right: 0,
	    left: 1,
	    bottom: 0,
	    top: 1,
	};

	const SCROLLDECTIONMODE_MAP = {
	    gameObject: 0,
	    rectBounds: 1,
	};

	const GetValue$u = Phaser.Utils.Objects.GetValue;

	var CreateScrollableSizer = function (parent, config) {
	    var scene = parent.scene;

	    var columnProportions = [0, 1, 0],
	        rowProportions = [0, 1, 0];
	    var parentMinWidth = GetValue$u(config, 'width');
	    var parentMinHeight = GetValue$u(config, 'height');
	    if (!parentMinWidth) {
	        var expandChildWidth = GetValue$u(config, 'child.expandWidth', true);
	        if (!expandChildWidth) {
	            columnProportions[1] = 0;  // Calculate parent's width by child's width
	        }
	    }
	    if (!parentMinHeight) {
	        var expandChildHeight = GetValue$u(config, 'child.expandHeight', true);
	        if (!expandChildHeight) {
	            rowProportions[1] = 0;    // Calculate parent's height by child's height
	        }
	    }

	    var scrollableSizer = new GridSizer(scene, {
	        column: 3, row: 3,
	        columnProportions: columnProportions,
	        rowProportions: rowProportions
	    });

	    AddChild(parent, scrollableSizer, config);

	    switch (parent.scrollMode) {
	        case 0:  // y
	            AddSlider(parent, scrollableSizer, 'y', config);
	            break;
	        case 1:  // x
	            AddSlider(parent, scrollableSizer, 'x', config);
	            break;

	        default: // xy
	            AddSlider(parent, scrollableSizer, 'y', config);
	            AddSlider(parent, scrollableSizer, 'x', config);
	            break;
	    }

	    return scrollableSizer;
	};

	var ResizeController = function () {
	    switch (this.scrollMode) {
	        case 0:
	        case 1:
	            SetControllerBounds.call(this);

	            this.updateController();

	            HideUnscrollableSlider.call(this);

	            AdaptThumbSize.call(this);

	            break;

	        default: // 2
	            SetControllerBounds.call(this, 'y');
	            SetControllerBounds.call(this, 'x');

	            this.updateController();

	            HideUnscrollableSlider.call(this, 'y');
	            HideUnscrollableSlider.call(this, 'x');

	            AdaptThumbSize.call(this, 'y');
	            AdaptThumbSize.call(this, 'x');
	            break;
	    }

	    return this;
	};


	var SetControllerBounds = function (axis) {
	    // Scale will force to 1
	    var bound0, bound1;
	    var scroller, slider;
	    switch (this.scrollMode) {
	        case 0:
	        case 1:
	            bound0 = this.topChildOY;
	            bound1 = this.bottomChildOY;
	            scroller = this.childrenMap.scroller;
	            slider = this.childrenMap.slider;
	            axis = (this.scrollMode === 0) ? 'Y' : 'X';
	            break;

	        default:  // 2
	            axis = axis.toUpperCase();
	            if (axis === 'Y') {
	                bound0 = this.topChildOY;
	                bound1 = this.bottomChildOY;
	            } else {
	                bound0 = this.leftChildOX;
	                bound1 = this.rightChildOX;
	            }
	            scroller = this.childrenMap[`scroller${axis}`];
	            slider = this.childrenMap[`slider${axis}`];
	    }

	    var scale = (axis === 'Y') ? this.scaleY : this.scaleX;
	    bound1 *= scale;

	    if (scroller) {
	        scroller.setBounds(bound0, bound1);
	    }
	    if (slider) {
	        slider.setEnable(bound0 !== bound1);

	        if (slider.tickLength) {
	            slider.setTick(slider.tickLength, bound0, bound1);
	        }
	    }
	};

	var HideUnscrollableSlider = function (axis) {
	    switch (this.scrollMode) {
	        case 0:
	        case 1:
	            var slider = this.childrenMap.slider;
	            if (slider && this.hideUnscrollableSlider) {
	                this.setChildVisible(slider, this.isOverflow);
	            }

	            var scroller = this.childrenMap.scroller;
	            if (scroller && this.disableUnscrollableDrag) {
	                scroller.setEnable(this.isOverflow);
	            }

	            break;

	        default:
	            axis = axis.toUpperCase();
	            var isOverflow = this[`isOverflow${axis}`];

	            var slider = this.childrenMap[`slider${axis}`];
	            var hideUnscrollableSlider = this[`hideUnscrollableSlider${axis}`];
	            if (slider && hideUnscrollableSlider) {
	                this.setChildVisible(slider, isOverflow);
	            }

	            var scroller = this.childrenMap.scroller;
	            var disableUnscrollableDrag = this[`disableUnscrollableDrag${axis}`];
	            if (scroller && disableUnscrollableDrag) {
	                scroller.setEnable(isOverflow);
	            }
	            break;
	    }
	};

	var AdaptThumbSize = function (axis) {
	    switch (this.scrollMode) {
	        case 0:
	        case 1:
	            if (!this.adaptThumbSizeMode) {
	                return;
	            }
	            var slider = this.childrenMap.slider;
	            if (!slider) {
	                return;
	            }

	            // Change slider size according to visible ratio
	            var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
	            var track = slider.childrenMap.track;
	            var thumb = slider.childrenMap.thumb;
	            var minThumbSize = this.minThumbSize;
	            if (this.scrollMode === 0) {
	                var newHeight = track.displayHeight * ratio;
	                if ((minThumbSize !== undefined) && (newHeight < minThumbSize)) {
	                    newHeight = minThumbSize;
	                }
	                ResizeGameObject(thumb, undefined, newHeight);
	            } else {
	                var newWidth = track.displayWidth * ratio;
	                if ((minThumbSize !== undefined) && (newWidth < minThumbSize)) {
	                    newWidth = minThumbSize;
	                }
	                ResizeGameObject(thumb, newWidth, undefined);

	            }
	            LayoutSlider(slider);
	            break;

	        default:
	            // TODO
	            axis = axis.toUpperCase();
	            var adaptThumbSizeMode = this[`adaptThumb${axis}SizeMode`];
	            if (!adaptThumbSizeMode) {
	                return;
	            }
	            var slider = this.childrenMap[`slider${axis}`];
	            if (!slider) {
	                return;
	            }

	            // Change slider size according to visible ratio            
	            var track = slider.childrenMap.track;
	            var thumb = slider.childrenMap.thumb;
	            var minThumbSize = this[`minThumb${axis}Size`];
	            if (axis === 'Y') {
	                var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
	                var newHeight = track.displayHeight * ratio;
	                if ((minThumbSize !== undefined) && (newHeight < minThumbSize)) {
	                    newHeight = minThumbSize;
	                }
	                ResizeGameObject(thumb, undefined, newHeight);
	            } else {
	                var ratio = Math.min(this.childVisibleWidth / this.childWidth, 1);
	                var newWidth = track.displayWidth * ratio;
	                if ((minThumbSize !== undefined) && (newWidth < minThumbSize)) {
	                    newWidth = minThumbSize;
	                }
	                ResizeGameObject(thumb, newWidth, undefined);

	            }
	            LayoutSlider(slider);
	            break;

	    }


	};

	var LayoutSlider = function (slider) {
	    // Save minSize
	    var minWidthSave = slider.minWidth;
	    var minHeightSave = slider.minHeight;
	    // Set minSize to current size
	    slider.minWidth = slider.width;
	    slider.minHeight = slider.height;
	    // Layout slider
	    slider.layout();
	    // Restore minSize
	    slider.minWidth = minWidthSave;
	    slider.minHeight = minHeightSave;
	};

	var UpdateController = function () {
	    switch (this.scrollMode) {
	        case 0:
	        case 1:
	            var scroller = this.childrenMap.scroller;
	            var slider = this.childrenMap.slider;
	            if (scroller) {
	                scroller.setValue(this.childOY);
	            }
	            if (slider) {
	                slider.setValue(this.t);
	            }
	            break;

	        default:
	            var scrollerY = this.childrenMap.scrollerY;
	            var sliderY = this.childrenMap.sliderY;
	            var scrollerX = this.childrenMap.scrollerX;
	            var sliderX = this.childrenMap.sliderX;

	            if (scrollerY) {
	                scrollerY.setValue(this.childOY);
	            }
	            if (sliderY) {
	                sliderY.setValue(this.t);
	            }
	            if (scrollerX) {
	                scrollerX.setValue(this.childOX);
	            }
	            if (sliderX) {
	                sliderX.setValue(this.s);
	            }
	            break;
	    }

	};

	const GetValue$t = Phaser.Utils.Objects.GetValue;
	const Clamp$1 = Phaser.Math.Clamp;

	class Scrollable extends Sizer {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var scrollMode = GetScrollMode(config); // 0:y, 1:x, 2:xy
	        // Create sizer
	        var isRevererXY = (scrollMode === 1);
	        config.orientation = (!isRevererXY) ? 1 : 0;
	        super(scene, config);
	        this.type = GetValue$t(config, 'type', 'rexScrollable');
	        this.scrollMode = scrollMode;

	        // Add elements
	        // Background
	        var background = GetValue$t(config, 'background', undefined);
	        if (background) {
	            this.addBackground(background);
	        }

	        var header = GetValue$t(config, 'header', undefined);
	        if (header) {
	            var align = GetValue$t(config, 'align.header', 'center');
	            var headerSpace = GetValue$t(config, 'space.header', 0);
	            var padding;
	            if (!isRevererXY) {
	                padding = { bottom: headerSpace };
	            } else {
	                padding = { right: headerSpace };
	            }
	            this.add(header,
	                {
	                    proportion: 0,
	                    align: align,
	                    padding: padding,
	                    expand: GetValue$t(config, 'expand.header', true)
	                }
	            );
	        }

	        var scrollableSizer = CreateScrollableSizer(this, config);
	        if (scrollableSizer) {
	            this.add(scrollableSizer,
	                {
	                    proportion: 1,
	                    align: 'center',
	                    padding: 0,
	                    expand: true
	                }
	            );
	        }

	        var footer = GetValue$t(config, 'footer', undefined);
	        if (footer) {
	            var align = GetValue$t(config, 'align.footer', 'center');
	            var footerSpace = GetValue$t(config, 'space.footer', 0);
	            var padding;
	            if (!isRevererXY) {
	                padding = { top: footerSpace };
	            } else {
	                padding = { left: footerSpace };
	            }
	            this.add(footer,
	                {
	                    proportion: 0,
	                    align: align,
	                    padding: padding,
	                    expand: GetValue$t(config, 'expand.footer', true)
	                }
	            );
	        }

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('header', header);
	        this.addChildrenMap('footer', footer);

	        this.runLayoutFlag = false;

	        /* 
	        Necessary properties of child object :

	        - child.t (RW), 
	        - child.childOY (RW)        
	        - child.topChildOY (R)
	        - child.bottomChildOY (R)
	        - child.childVisibleHeight (R)
	        - child.childHeight (R)

	        - child.s (RW), 
	        - child.childOX (RW)
	        - child.leftChildOX (R)
	        - child.rightChildOX (R)
	        - child.childVisibleWidth (R)
	        - child.childWidth (R)        
	        */
	    }

	    postLayout(parent, newWidth, newHeight) {
	        var s = 0, t = 0;
	        if (!this.runLayoutFlag) {
	            this.runLayoutFlag = true;
	        } else {
	            t = this.t;

	            if (this.scrollMode === 2) {
	                s = this.s;
	            }
	        }

	        this.resizeController();

	        this.setT(t);
	        if (this.scrollMode === 2) {
	            this.setS(s);
	        }

	        super.postLayout(parent, newWidth, newHeight);

	        return this;
	    }

	    set t(value) {
	        // Get inner childT
	        var childMargin = this.childMargin;
	        if ((childMargin.top !== 0) || (childMargin.bottom !== 0)) {
	            var child = this.childrenMap.child;
	            var innerHeight = (child.topChildOY - child.bottomChildOY);
	            var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
	            var innerChildOY = (outerHeight * value) - childMargin.top;
	            value = (innerHeight !== 0) ? (innerChildOY / innerHeight) : 0;
	        }

	        this.childrenMap.child.t = value;
	        this.updateController();
	    }

	    get t() {
	        var t = this.childrenMap.child.t;

	        // Get outer childT
	        var childMargin = this.childMargin;
	        if ((childMargin.top !== 0) || (childMargin.bottom !== 0)) {
	            var child = this.childrenMap.child;
	            var innerHeight = (child.topChildOY - child.bottomChildOY);
	            var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
	            var outerChildOY = (innerHeight * t) + childMargin.top;
	            t = (outerHeight !== 0) ? (outerChildOY / outerHeight) : 0;
	        }
	        return t;
	    }

	    set s(value) {
	        // Get inner childS
	        var childMargin = this.childMargin;
	        if ((childMargin.left !== 0) || (childMargin.right !== 0)) {
	            var child = this.childrenMap.child;
	            var innerWidth = (child.leftChildOX - child.rightChildOX);
	            var outerWidth = innerWidth + childMargin.left + childMargin.right;
	            var innerChildOX = (outerWidth * value) - childMargin.left;
	            value = (innerWidth !== 0) ? (innerChildOX / innerWidth) : 0;
	        }

	        this.childrenMap.child.s = value;
	        this.updateController();
	    }

	    get s() {
	        var s = this.childrenMap.child.s;

	        // Get outer childT
	        var childMargin = this.childMargin;
	        if ((childMargin.left !== 0) || (childMargin.right !== 0)) {
	            var child = this.childrenMap.child;
	            var innerWidth = (child.leftChildOX - child.rightChildOX);
	            var outerWidth = innerWidth + childMargin.left + childMargin.right;
	            var outerChildOX = (innerWidth * s) + childMargin.left;
	            s = (outerWidth !== 0) ? (outerChildOX / outerWidth) : 0;
	        }
	        return s;
	    }

	    set childOY(value) {
	        this.childrenMap.child.childOY = value;
	        this.updateController();
	    }

	    get childOY() {
	        return this.childrenMap.child.childOY;
	    }

	    set childOX(value) {
	        this.childrenMap.child.childOX = value;
	        this.updateController();
	    }

	    get childOX() {
	        return this.childrenMap.child.childOX;
	    }

	    get topChildOY() {
	        return this.childrenMap.child.topChildOY + this.childMargin.top;
	    }

	    get bottomChildOY() {
	        return this.childrenMap.child.bottomChildOY - this.childMargin.bottom;
	    }

	    get leftChildOX() {
	        return this.childrenMap.child.leftChildOX + this.childMargin.left;
	    }

	    get rightChildOX() {
	        return this.childrenMap.child.rightChildOX - this.childMargin.right;
	    }

	    get childVisibleHeight() {
	        return this.childrenMap.child.childVisibleHeight;
	    }

	    get childHeight() {
	        return this.childrenMap.child.childHeight;
	    }

	    get childVisibleWidth() {
	        return this.childrenMap.child.childVisibleWidth;
	    }

	    get childWidth() {
	        return this.childrenMap.child.childWidth;
	    }

	    get isOverflow() {
	        var child = this.childrenMap.child;
	        return child.topChildOY !== child.bottomChildOY;
	    }

	    get isOverflowY() {
	        return this.isOverflow;
	    }

	    get isOverflowX() {
	        var child = this.childrenMap.child;
	        return child.leftChildOX !== child.rightChildOX;
	    }

	    setChildOY(value, clamp) {
	        if (clamp === undefined) {
	            clamp = false;
	        }
	        if (clamp) {
	            value = Clamp$1(value, this.bottomChildOY, this.topChildOY);
	        }
	        this.childOY = value;
	        return this;
	    }

	    addChildOY(inc, clamp) {
	        this.setChildOY(this.childOY + inc, clamp);
	        return this;
	    }

	    setT(value, clamp) {
	        if (clamp === undefined) {
	            clamp = false;
	        }
	        if (clamp) {
	            value = Clamp$1(value, 0, 1);
	        }
	        this.t = value;
	        return this;
	    }

	    addT(inc, clamp) {
	        this.setT(this.t + inc, clamp);
	        return this;
	    }

	    scrollToTop() {
	        this.t = 0;
	        return this;
	    }

	    scrollToBottom() {
	        this.t = 1;
	        // t will be 0 if panel/table does not exceed visible area
	        if (this.t === 0) {
	            return this;
	        }

	        // Panel/Table height might be expanded while cells are visible        
	        do {
	            this.t = 1;
	        } while (this.t !== 1)

	        return this;
	    }

	    setChildOX(value, clamp) {
	        if (clamp === undefined) {
	            clamp = false;
	        }
	        if (clamp) {
	            value = Clamp$1(value, this.leftChildOX, this.rightChildOX);
	        }
	        this.childOX = value;
	        return this;
	    }

	    addChildOX(inc, clamp) {
	        this.setChildOX(this.childOX + inc, clamp);
	        return this;
	    }

	    setS(value, clamp) {
	        if (clamp === undefined) {
	            clamp = false;
	        }
	        if (clamp) {
	            value = Clamp$1(value, 0, 1);
	        }
	        this.s = value;
	        return this;
	    }

	    addS(inc, clamp) {
	        this.setS(this.s + inc, clamp);
	        return this;
	    }

	    scrollToLeft() {
	        this.s = 0;
	        return this;
	    }

	    scrollToRight() {
	        this.s = 1;
	        // s will be 0 if panel/table does not exceed visible area
	        if (this.s === 0) {
	            return this;
	        }

	        // Panel/Table height might be expanded while cells are visible        
	        do {
	            this.s = 1;
	        } while (this.s !== 1)

	        return this;
	    }

	    get sliderEnable() {
	        var slider = this.childrenMap.slider;
	        if (!slider) {
	            return false;
	        }

	        return slider.enable;
	    }

	    set sliderEnable(value) {
	        var slider = this.childrenMap.slider;
	        if (!slider) {
	            return;
	        }
	        slider.setEnable(value);
	    }

	    setSliderEnable(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.sliderEnable = enabled;
	        return this;
	    }

	    get sliderYEnable() {
	        return this.sliderEnable
	    }

	    set sliderYEnable(value) {
	        this.sliderEnable = value;
	    }

	    setSliderYEnable(enabled) {
	        this.setSliderEnable(enabled);
	        return this;
	    }

	    get sliderXEnable() {
	        var slider = this.childrenMap.sliderX;
	        if (!slider) {
	            return false;
	        }

	        return slider.enable;
	    }

	    set sliderXEnable(value) {
	        var slider = this.childrenMap.sliderX;
	        if (!slider) {
	            return;
	        }
	        slider.setEnable(value);
	    }

	    setSliderXEnable(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.sliderXEnable = enabled;
	        return this;
	    }

	    get scrollerEnable() {
	        var scroller = this.childrenMap.scroller;
	        if (!scroller) {
	            return false;
	        }

	        return scroller.enable;
	    }

	    set scrollerEnable(value) {
	        var scroller = this.childrenMap.scroller;
	        if (!scroller) {
	            return;
	        }
	        scroller.setEnable(value);
	    }

	    setScrollerEnable(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.scrollerEnable = enabled;
	        return this;
	    }

	    get scrollerYEnable() {
	        return this.scrollerEnable;
	    }

	    set scrollerYEnable(value) {
	        this.scrollerEnable = value;
	    }

	    setScrollerYEnable(enabled) {
	        this.setScrollerEnable(enabled);
	        return this;
	    }

	    get scrollerXEnable() {
	        var scroller = this.childrenMap.scrollerX;
	        if (!scroller) {
	            return false;
	        }

	        return scroller.enable;
	    }

	    set scrollerXEnable(value) {
	        var scroller = this.childrenMap.scrollerX;
	        if (!scroller) {
	            return;
	        }
	        scroller.setEnable(value);
	    }

	    setScrollerXEnable(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.scrollerXEnable = enabled;
	        return this;
	    }

	    get scrollerXEnable() {
	        var scroller = this.childrenMap.scrollerX;
	        if (!scroller) {
	            return false;
	        }

	        return scroller.enable;
	    }

	    set scrollerXEnable(value) {
	        var scroller = this.childrenMap.scrollerX;
	        if (!scroller) {
	            return;
	        }
	        scroller.setEnable(value);
	    }

	    setScrollerXEnable(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.scrollerXEnable = enabled;
	        return this;
	    }

	    get mouseWheelScrollerEnable() {
	        var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
	        if (!mouseWheelScroller) {
	            return false;
	        }

	        return mouseWheelScroller.enable;
	    }

	    set mouseWheelScrollerEnable(value) {
	        var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
	        if (!mouseWheelScroller) {
	            return;
	        }
	        mouseWheelScroller.setEnable(value);
	    }

	    setMouseWheelScrollerEnable(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.mouseWheelScrollerEnable = enabled;
	        return this;
	    }

	    get mouseWheelScrollerYEnable() {
	        return this.mouseWheelScrollerEnable;
	    }

	    set mouseWheelScrollerYEnable(value) {
	        this.mouseWheelScrollerEnable = value;
	    }

	    setMouseWheelScrollerYEnable(enabled) {
	        this.setMouseWheelScrollerEnable(enabled);
	        return this;
	    }

	    get mouseWheelScrollerXEnable() {
	        var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
	        if (!mouseWheelScroller) {
	            return false;
	        }

	        return mouseWheelScroller.enable;
	    }

	    set mouseWheelScrollerXEnable(value) {
	        var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
	        if (!mouseWheelScroller) {
	            return;
	        }
	        mouseWheelScroller.setEnable(value);
	    }

	    setMouseWheelScrollerXEnable(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.mouseWheelScrollerXEnable = enabled;
	        return this;
	    }

	    setDropZoneEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }

	        var child = this.childrenMap.child;
	        child.setInteractive();
	        child.input.dropZone = enable;
	        return this;
	    }

	}

	var Methods$4 = {
	    resizeController: ResizeController,
	    updateController: UpdateController
	};

	// mixin
	Object.assign(
	    Scrollable.prototype,
	    Methods$4
	);

	var SetText$2 = function (text) {
	    if (text !== undefined) {
	        this.text = text;
	    }

	    // Wrap content in lines
	    this.lines = TextToLines(this.textObject, this.text, this.lines);

	    // Get lines count
	    this.linesCount = this.lines.length;

	    // Re-calculate these values later
	    this._textHeight = undefined;
	    this._textVisibleHeight = undefined;

	    this.updateTextObject();
	    return this;
	};

	var TextHeightToLinesCount = function (height) {
	    // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
	    return (height - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing);
	};

	var LinesCountToTextHeight = function (linesCount) {
	    // height = (linesCount * (lineHeight + lineSpacing)) - lineSpacing
	    return (linesCount * (this.textLineHeight + this.textLineSpacing)) - this.textLineSpacing;
	};

	var GetLines = function (startLineIdx) {
	    var endLineIdx = startLineIdx + this.visibleLinesCount + 1;
	    var text;
	    switch (this.textObjectType) {
	        case TextType:
	            text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
	            break;
	        case TagTextType:
	            var startIdx = this.lines.getLineStartIndex(startLineIdx);
	            var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
	            text = this.lines.getSliceTagText(startIdx, endIdx, true);
	            break;
	        case BitmapTextType:
	            text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
	            break;
	    }
	    return text;
	};

	var ResetTextObjectPosition = function () {
	    var config = this.textObject.rexSizer;
	    this.textObject.y += (config.offsetY - config.preOffsetY);
	    config.preOffsetY = config.offsetY;
	    this.resetChildPositionState(this.textObject);

	    if (this.textCropEnable) {
	        CropTextObject.call(this);
	    }
	};

	var CropTextObject = function () {
	    // Don't have setCrop method, return
	    if (!this.textObject.setCrop) {
	        return;
	    }

	    var offsetY = this.textObject.rexSizer.offsetY;
	    var cropY, cropHeight;
	    if (offsetY <= 0) {
	        cropY = -offsetY;
	        cropHeight = this.height;
	    } else {
	        cropY = 0;
	        cropHeight = this.height - offsetY;
	    }
	    this.textObject.setCrop(
	        0,
	        cropY,
	        this.width,
	        cropHeight
	    );
	};

	var UpdateTextObject = function () {
	    var startLineIndex = Math.max(Math.floor(TextHeightToLinesCount.call(this, -this.textOY)), 0);
	    var textOffset = LinesCountToTextHeight.call(this, startLineIndex) + this.textOY;

	    // Grab visible lines
	    var text = GetLines.call(this, startLineIndex);

	    // Display visible content
	    SetNoWrapText(this.textObject, text);

	    this.textObject.rexSizer.offsetY = textOffset;
	    ResetTextObjectPosition.call(this);
	    return this;
	};

	var PreLayout$1 = function () {
	    // Style of text
	    this._textLineHeight = undefined;
	    this._textLineSpacing = undefined;
	    // Style of text, width of text
	    this._visibleLinesCount = undefined;
	    // Style of text, total lines of content
	    this._textHeight = undefined;
	    this._textVisibleHeight = undefined;

	    PreLayout$4.call(this);
	    return this;
	};

	var ResizeText = function (textObject, width, height) {
	    height += (this.textLineHeight + this.textLineSpacing); // Add 1 line
	    if ((this.textObjectWidth === width) && (this._textObjectRealHeight === height)) {
	        return;
	    }
	    this.textObjectWidth = width;
	    this._textObjectRealHeight = height;

	    switch (this.textObjectType) {
	        case TextType:
	        case TagTextType:
	            textObject.setFixedSize(width, height);

	            var style = textObject.style;
	            var wrapWidth = Math.max(width, 0);
	            if (this.textObjectType === TextType) {  // Built-in text
	                style.wordWrapWidth = wrapWidth;
	            } else {  // BBCode text, Tag text
	                if (style.wrapMode === 0) { // Turn no-wrap to word-wrap
	                    style.wrapMode = 1;
	                }
	                style.wrapWidth = wrapWidth;
	            }
	            break;
	        case BitmapTextType:
	            textObject.setMaxWidth(width);
	            break;
	    }

	    // Render content again
	    this.setText();
	};

	var LayoutChildren$2 = function () {
	    var child, childConfig, padding;
	    var startX = this.left,
	        startY = this.top;
	    var x, y, width, height; // Align zone

	    // LayoutChildren text child
	    // Skip invisible child
	    child = this.textObject;
	    if (!child.rexSizer.hidden) {
	        childConfig = child.rexSizer;
	        padding = childConfig.padding;
	        x = startX + (padding.left * this.scaleX);
	        y = startY + (padding.top * this.scaleY);
	        width = (this.width * this.scaleX) - ((padding.left + padding.right) * this.scaleX);
	        height = (this.height * this.scaleY) - ((padding.top + padding.bottom) * this.scaleY);
	        ResizeText.call(this, child, width, height);

	        AlignIn(child, x, y, width, height, childConfig.align);

	        childConfig.preOffsetY = 0; // Clear preOffsetY
	        ResetTextObjectPosition.call(this);

	        if (this.textMask) {
	            this.textMask.setPosition().resize();
	            this.resetChildPositionState(this.textMask);
	        }

	    }
	};

	var Methods$3 = {
	    setText: SetText$2,
	    updateTextObject: UpdateTextObject,
	    preLayout: PreLayout$1,
	    layoutChildren: LayoutChildren$2,
	};

	const IsPlainObject$9 = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$s = Phaser.Utils.Objects.GetValue;
	const ALIGN_LEFTTOP = Phaser.Display.Align.TOP_LEFT;

	class TextBlock extends Base$2 {
	    constructor(scene, x, y, minWidth, minHeight, config) {
	        if (IsPlainObject$9(x)) {
	            config = x;
	            x = GetValue$s(config, 'x', 0);
	            y = GetValue$s(config, 'y', 0);
	            minWidth = GetValue$s(config, 'width', undefined);
	            minHeight = GetValue$s(config, 'height', undefined);
	        } else if (IsPlainObject$9(minWidth)) {
	            config = minWidth;
	            minWidth = GetValue$s(config, 'width', undefined);
	            minHeight = GetValue$s(config, 'height', undefined);
	        }

	        super(scene, x, y, minWidth, minHeight, config);

	        this.type = 'rexTextBlock';
	        this.textObject = undefined;
	        this.linesCount = 0;
	        this.textMask = undefined;
	        this.textObjectType = undefined;
	        this._textLineHeight = undefined;
	        this._textLineSpacing = undefined;
	        this._visibleLinesCount = undefined;
	        this._textHeight = undefined;
	        this._textVisibleHeight = undefined;
	        this._textObjectRealHeight = 0;

	        this.lines = undefined;
	        // Text object : array of string
	        // Tag text object : pens-manager
	        // Bitmap text object : array of string

	        this.text = GetValue$s(config, 'content', '');
	        this._textOY = 0;
	        this.execeedTopState = false;
	        this.execeedBottomState = false;

	        this.setClampMode(GetValue$s(config, 'clampTextOY', true));

	        this.alwaysScrollable = GetValue$s(config, 'alwaysScrollable', false);

	        // Add elements
	        var background = GetValue$s(config, 'background', undefined);
	        var textObject = GetValue$s(config, 'text', undefined);
	        if (textObject === undefined) {
	            textObject = CreateDefaultTextObject(scene);
	        }
	        this.textCropEnable = GetValue$s(config, 'textCrop', !!textObject.setCrop);
	        var textMaskEnable = GetValue$s(config, 'textMask', !this.textCropEnable);

	        if (background) {
	            this.addBackground(background);
	        }

	        this.add(textObject);
	        this.sizerChildren = [textObject];

	        var sizerConfig = this.getSizerConfig(textObject);
	        sizerConfig.align = ALIGN_LEFTTOP;
	        sizerConfig.padding = GetBoundsConfig$1(0);
	        sizerConfig.expand = true;
	        this.textObject = textObject;

	        this.textObjectType = GetTextObjectType(textObject);

	        // Add more variables
	        sizerConfig.preOffsetY = 0;
	        sizerConfig.offsetY = 0;

	        // Create mask of text object
	        if (textMaskEnable) {
	            this.textMask = AddChildMask.call(this, this.textObject, this);
	        }

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('text', textObject);
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        this.textObject = undefined;
	        this.textMask = undefined;
	        if (this.lines) {
	            switch (this.textObjectType) {
	                case TextType:
	                    this.lines.length = 0;
	                    break;
	                case TagTextType:
	                    this.lines.destroy();
	                    break;
	                case BitmapTextType:
	                    this.lines.length = 0;
	                    break;
	            }
	            this.lines = undefined;
	        }

	        super.destroy(fromScene);
	    }

	    setClampMode(mode) {
	        if (mode === undefined) {
	            mode = true;
	        }
	        this.clampTextOY = mode;
	        return this;
	    }

	    get textLineHeight() {
	        if (this._textLineHeight === undefined) {
	            var lineHeight;
	            switch (this.textObjectType) {
	                case TextType:
	                case TagTextType:
	                    var style = this.textObject.style;
	                    lineHeight = style.metrics.fontSize + style.strokeThickness;
	                    break;
	                case BitmapTextType:
	                    var scale = (this.textObject.fontSize / this.textObject.fontData.size);
	                    lineHeight = this.textObject.fontData.lineHeight * scale;
	                    break;

	            }
	            this._textLineHeight = lineHeight;
	        }
	        return this._textLineHeight;
	    }

	    get textLineSpacing() {
	        if (this._textLineSpacing === undefined) {
	            var lineSpacing;
	            switch (this.textObjectType) {
	                case TextType:
	                case TagTextType:
	                    lineSpacing = this.textObject.lineSpacing;
	                    break;
	                case BitmapTextType:
	                    lineSpacing = 0;
	                    break;
	            }
	            this._textLineSpacing = lineSpacing;
	        }
	        return this._textLineSpacing;
	    }

	    get visibleLinesCount() {
	        if (this._visibleLinesCount === undefined) {
	            this._visibleLinesCount = Math.floor(TextHeightToLinesCount.call(this, this._textObjectRealHeight));
	        }
	        return this._visibleLinesCount;
	    }

	    get topTextOY() {
	        return 0;
	    }

	    get bottomTextOY() {
	        return -this.textVisibleHeight;
	    }

	    get textHeight() {
	        if (this._textHeight === undefined) {
	            this._textHeight = LinesCountToTextHeight.call(this, this.linesCount);
	        }
	        return this._textHeight;
	    }

	    get textObjectHeight() {
	        return this._textObjectRealHeight - (this.textLineHeight + this.textLineSpacing);  // Remove 1 text line
	    }

	    get textVisibleHeight() {
	        if (this._textVisibleHeight === undefined) {
	            var h = this.textHeight - this.textObjectHeight;
	            if (!this.alwaysScrollable && (h < 0)) {
	                h = 0;
	            }
	            this._textVisibleHeight = h;
	        }
	        return this._textVisibleHeight;
	    }

	    textOYExceedTop(oy) {
	        if (oy === undefined) {
	            oy = this.textOY;
	        }
	        return (oy > this.topTextOY);
	    }

	    textOYExeceedBottom(oy) {
	        if (oy === undefined) {
	            oy = this.textOY;
	        }
	        return (oy < this.bottomTextOY);
	    }

	    get textOY() {
	        return this._textOY;
	    }

	    set textOY(oy) {
	        var topTextOY = this.topTextOY;
	        var bottomTextOY = this.bottomTextOY;
	        var textOYExceedTop = this.textOYExceedTop(oy);
	        var textOYExeceedBottom = this.textOYExeceedBottom(oy);

	        if (this.clampTextOY) {
	            if (this.visibleLinesCount > this.linesCount) {
	                oy = 0;
	            } else if (textOYExceedTop) {
	                oy = topTextOY;
	            } else if (textOYExeceedBottom) {
	                oy = bottomTextOY;
	            }
	        }

	        if (this._textOY !== oy) {
	            this._textOY = oy;
	            this.updateTextObject();
	        }

	        if (textOYExceedTop) {
	            if (!this.execeedTopState) {
	                this.emit('execeedtop', this, oy, topTextOY);
	            }
	        }
	        this.execeedTopState = textOYExceedTop;

	        if (textOYExeceedBottom) {
	            if (!this.execeedBottomState) {
	                this.emit('execeedbottom', this, oy, bottomTextOY);
	            }
	        }
	        this.execeedBottomState = textOYExeceedBottom;
	    }

	    setTextOY(oy) {
	        this.textOY = oy;
	        return this;
	    }

	    set t(value) {
	        this.textOY = -this.textVisibleHeight * value;
	    }

	    get t() {
	        var textVisibleHeight = this.textVisibleHeight;
	        if (textVisibleHeight === 0) {
	            return 0;
	        }
	        return (this.textOY / -textVisibleHeight);
	    }

	    setTextOYByPercentage(percentage) {
	        this.t = percentage;
	        return this;
	    }
	}

	var CreateDefaultTextObject = function (scene) {
	    return scene.add.text(0, 0, '');
	};

	Object.assign(
	    TextBlock.prototype,
	    Methods$3
	);

	var InjectProperties = function (textBlock) {
	    Object.defineProperty(textBlock, 'childOY', {
	        configurable: true,
	        get: function () {
	            return textBlock.textOY;
	        },
	        set: function (value) {
	            textBlock.textOY = value;
	        }
	    });
	    Object.defineProperty(textBlock, 'topChildOY', {
	        get: function () {
	            return textBlock.topTextOY;
	        }
	    });
	    Object.defineProperty(textBlock, 'bottomChildOY', {
	        get: function () {
	            return textBlock.bottomTextOY;
	        }
	    });
	    Object.defineProperty(textBlock, 'childVisibleHeight', {
	        get: function () {
	            return textBlock.textObjectHeight;
	        }
	    });
	    Object.defineProperty(textBlock, 'childHeight', {
	        get: function () {
	            return textBlock.textHeight;
	        }
	    });
	};

	var SetTextMethods = {
	    setText(text) {
	        var textBlock = this.childrenMap.child;
	        textBlock.setText(text);

	        this.resizeController();
	        return this;
	    },

	    appendText(text) {
	        this.setText(this.text + text);
	        return this;
	    }
	};

	var ScrollMethods = {
	    scrollToLine(lineIndex) {
	        this.setChildOY(-this.lineHeight * lineIndex);
	        return this;
	    },

	    scrollToNextLine(lineCount) {
	        if (lineCount === undefined) {
	            lineCount = 1;
	        }

	        var lineIndex = this.lineIndex + lineCount;
	        this.scrollToLine(lineIndex);
	        return this;
	    }
	};

	const GetValue$r = Phaser.Utils.Objects.GetValue;

	class TextArea extends Scrollable {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        // Create text-block
	        var textObject = GetValue$r(config, 'text', undefined);
	        var textWidth = GetValue$r(config, 'textWidth', undefined);
	        var textHeight = GetValue$r(config, 'textHeight', undefined);
	        var textCrop = GetValue$r(config, 'textCrop', !!textObject.setCrop);
	        var textMask = GetValue$r(config, 'textMask', !textCrop);
	        var content = GetValue$r(config, 'content', '');
	        var textBlock = new TextBlock(scene, {
	            width: textWidth,
	            height: textHeight,
	            text: textObject,
	            textMask: textMask,
	            textCrop: textCrop && !textMask,
	            content: content,
	            clampTextOY: GetValue$r(config, 'clampChildOY', false),
	            alwaysScrollable: GetValue$r(config, 'alwaysScrollable', false),
	        });
	        scene.add.existing(textBlock); // Important: Add to display list for touch detecting
	        // Inject properties for scrollable interface
	        InjectProperties(textBlock);

	        // Fill config of scrollable
	        config.scrollMode = 0; // Vertical
	        config.type = 'rexTextArea';
	        config.child = {
	            gameObject: textBlock,
	            expandWidth: (textWidth === undefined),
	            expandHeight: (textHeight === undefined),
	        };
	        var spaceConfig = GetValue$r(config, 'space', undefined);
	        if (spaceConfig) {
	            spaceConfig.child = GetValue$r(spaceConfig, 'text', 0);
	        }

	        super(scene, config);

	        this.addChildrenMap('text', textObject);
	    }

	    get text() {
	        return this.childrenMap.child.text;
	    }

	    get lineHeight() {
	        var textBlock = this.childrenMap.child;
	        return textBlock.textLineHeight + textBlock.textLineSpacing;
	    }

	    get lineIndex() {
	        return Math.floor(-this.childOY / this.lineHeight);
	    }

	    get linesCount() {
	        var textBlock = this.childrenMap.child;
	        return textBlock.linesCount;
	    }

	    get contentHeight() {
	        var textBlock = this.childrenMap.child;
	        return textBlock.textHeight;
	    }
	}

	Object.assign(
	    TextArea.prototype,
	    SetTextMethods,
	    ScrollMethods,
	);

	const GetValue$q = Phaser.Utils.Objects.GetValue;

	var CreateTextArea = function (scene, config, creators) {
	    config = (config) ? DeepClone(config) : {};

	    var createBackground = GetValue$q(creators, 'background', CreateBackground);
	    var createText = GetValue$q(creators, 'text', CreateText);
	    var createTrack = GetValue$q(creators, 'track', CreateBackground);
	    var createThumb = GetValue$q(creators, 'thumb', CreateBackground);

	    if (createBackground) {
	        config.background = createBackground(scene, config.background);
	    } else {
	        delete config.background;
	    }

	    if (createText) {
	        config.text = createText(scene, config.text);
	    } else {
	        delete config.text;
	    }

	    var sliderConfig = config.slider;
	    if ((sliderConfig !== false) && (sliderConfig !== null)) {
	        if (sliderConfig === undefined) {
	            sliderConfig = {};
	        }

	        if (createTrack) {
	            sliderConfig.track = createTrack(scene, sliderConfig.track);
	        } else {
	            delete sliderConfig.track;
	        }

	        if (createThumb) {
	            sliderConfig.thumb = createThumb(scene, sliderConfig.thumb);
	        } else {
	            delete sliderConfig.thumb;
	        }

	        config.slider = sliderConfig;
	    }

	    // No header
	    // No footer

	    var gameObject = new TextArea(scene, config);
	    scene.add.existing(gameObject);
	    return gameObject;
	};

	var CreateText = function (scene, config) {
	    var gameObjectType;
	    if (config) {
	        if (config.hasOwnProperty('$type')) {
	            gameObjectType = config.$type;
	        } else {
	            if (config.hasOwnProperty('key')) {
	                gameObjectType = 'bitmaptext';
	                config.font = config.key;
	            }
	        }
	    }

	    var gameObject;
	    switch (gameObjectType) {
	        case 'bitmaptext':
	        case 'bitmap':
	            gameObject = new StatesBitmapText(scene, config);
	            break;

	        case 'bbcodetext':
	        case 'bbcode':
	            gameObject = new BBCodeText(scene, 0, 0, '', config);
	            break;

	        case 'label':
	            gameObject = new SimpleLabel(scene, config);
	            break;

	        case 'textarea':
	            gameObject = CreateTextArea(scene, config);
	            break;

	        default:
	            gameObject = new StatesText(scene, config);
	            break;
	    }

	    DecorateGameObject(gameObject, config);
	    scene.add.existing(gameObject);
	    return gameObject;
	};

	var CreateImage = function (scene, config) {
	    var gameObjectType;
	    if (config) {
	        if (config.hasOwnProperty('$type')) {
	            gameObjectType = config.$type;
	        } else {
	            if (config.hasOwnProperty('leftWidth')) {
	                gameObjectType = 'nineSlice';
	            } else if (config.hasOwnProperty('color') || config.hasOwnProperty('strokeColor')) {
	                gameObjectType = 'roundRectangle';
	            }
	        }
	    }

	    var gameObject;
	    switch (gameObjectType) {
	        case 'nineSlice':
	            if (!config.hasOwnProperty('stretchMode')) {
	                gameObject = new StatesNineSlice(scene, config);
	            } else {
	                gameObject = new StatesNinePatch(scene, config);
	            }
	            break;

	        case 'roundRectangle':
	            gameObject = new StatesRoundRectangle(scene, config);
	            break;

	        default:
	            gameObject = new StatesImage(scene, config);
	            break;
	    }

	    DecorateGameObject(gameObject, config);
	    scene.add.existing(gameObject);
	    return gameObject;
	};

	const GetValue$p = Phaser.Utils.Objects.GetValue;

	var BuildLabelConfig = function (scene, config, creators) {
	    config = (config) ? DeepClone(config) : {};

	    var createBackground = GetValue$p(creators, 'background', CreateBackground);
	    var createText = GetValue$p(creators, 'text', CreateText);
	    var createIcon = GetValue$p(creators, 'icon', CreateImage);
	    var createAction = GetValue$p(creators, 'action', CreateImage);

	    if ((config.background !== null) && createBackground) {
	        config.background = createBackground(scene, config.background);
	    } else {
	        delete config.background;
	    }

	    if ((config.text !== null) && createText) {
	        config.text = createText(scene, config.text);
	    } else {
	        delete config.text;
	    }

	    if ((config.icon !== null) && createIcon) {
	        config.icon = createIcon(scene, config.icon);
	    } else {
	        delete config.icon;
	    }

	    if ((config.action !== null) && createAction) {
	        config.action = createAction(scene, config.action);
	    } else {
	        delete config.action;
	    }

	    return config;
	};

	var BuildLabelConfig$1 = BuildLabelConfig;

	const GetValue$o = Phaser.Utils.Objects.GetValue;

	var BuildTitleLabelConfig = function (scene, config, creators) {
	    var createInnerBackground = GetValue$o(creators, 'innerBackground', CreateBackground);
	    var createSeparator = GetValue$o(creators, 'separator', CreateBackground);
	    var createTitle = GetValue$o(creators, 'title', CreateText);

	    var innerBackground, separator;

	    // Create innerBackground before background
	    if ((config.innerBackground !== null) && createInnerBackground) {
	        innerBackground = createInnerBackground(scene, config.innerBackground);
	    }

	    // Create separator before background
	    if ((config.separator !== null) && createSeparator) {
	        separator = createSeparator(scene, config.separator);
	    }

	    config = BuildLabelConfig$1(scene, config, creators);

	    if (innerBackground) {
	        config.innerBackground = innerBackground;
	    } else {
	        delete config.innerBackground;
	    }

	    if (separator) {
	        config.separator = separator;
	    } else {
	        delete config.separator;
	    }

	    if ((config.title !== null) && createTitle) {
	        config.title = createTitle(scene, config.title);
	    } else {
	        delete config.title;
	    }

	    // Keep background as the bottom element
	    var background = config.background;
	    if (background) {
	        if (innerBackground) {
	            scene.children.moveBelow(background, innerBackground);  // Move child1 below child2
	        } else if (separator) {
	            scene.children.moveBelow(background, separator);  // Move child1 below child2
	        }
	    }

	    return config;
	};

	class SimpleTextBox extends TextBox {
	    constructor(scene, config, creators) {
	        config = BuildTitleLabelConfig(scene, config, creators);
	        super(scene, config);
	    }
	}

	var Start = function (duration) {
	    if (!this.easeValueTask) {
	        this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
	    }

	    if (duration !== undefined) {
	        this.duration = duration;
	        this.easeValueTask.stop();  // Will restart with new duration
	    }

	    // Won't restart if easeValueTask is running
	    if (this.easeValueTask.isRunning) {
	        return this;
	    }

	    // Start easeValueTask
	    this.easeValueTask.restart({
	        key: 'value',
	        from: 0, to: 1,
	        duration: this.duration,
	        ease: this.ease,
	        repeat: -1,  // -1: infinity

	        delay: this.delay,
	        repeatDelay: this.repeatDelay
	    });

	    this.setDirty();

	    return this;
	};

	var Stop = function () {
	    if (!this.easeValueTask) {
	        return this;
	    }
	    this.easeValueTask.stop();
	    this.setDirty();
	    return this;
	};

	var Pause = function () {
	    if (!this.easeValueTask) {
	        return this;
	    }
	    this.easeValueTask.pause();
	    this.setDirty();
	    return this;
	};

	var Resume = function () {
	    if (!this.easeValueTask) {
	        return this;
	    }
	    this.easeValueTask.pause();
	    this.setDirty();
	    return this;
	};

	var EaseValueMethods = {
	    start: Start,
	    stop: Stop,
	    pause: Pause,
	    resume: Resume
	};

	const GetValue$n = Phaser.Utils.Objects.GetValue;

	class Base extends BaseShapes {
	    constructor(scene, config) {
	        var x = GetValue$n(config, 'x', 0);
	        var y = GetValue$n(config, 'y', 0);
	        var width = GetValue$n(config, 'width', 64);
	        var height = GetValue$n(config, 'height', 64);

	        super(scene, x, y, width, height);

	        this.resetFromConfig(config, true);

	        this.buildShapes(config);

	        if (GetValue$n(config, 'start', true)) {
	            this.start();
	        }
	    }

	    resetFromConfig(config, setDefaults) {
	        if (setDefaults === undefined) {
	            setDefaults = false;
	        }

	        var defaultValue;

	        defaultValue = (setDefaults) ? 1000 : this.duration;
	        this.setDuration(GetValue$n(config, 'duration', defaultValue));

	        defaultValue = (setDefaults) ? 'Linear' : this.ease;
	        this.setEase(GetValue$n(config, 'ease', defaultValue));

	        defaultValue = (setDefaults) ? 0 : this.delay;
	        this.setDelay(GetValue$n(config, 'delay', defaultValue));

	        defaultValue = (setDefaults) ? 0 : this.repeatDelay;
	        this.setRepeatDelay(GetValue$n(config, 'repeatDelay', defaultValue));

	        defaultValue = (setDefaults) ? 0xffffff : this.color;
	        this.setColor(GetValue$n(config, 'color', defaultValue));

	        defaultValue = (setDefaults) ? 0 : this.value;
	        this.setValue(GetValue$n(config, 'value', defaultValue));

	        return this;
	    }

	    buildShapes() {
	    }

	    get centerX() {
	        return this.width / 2;    }

	    get centerY() {
	        return this.height / 2;
	    }

	    get radius() {
	        return Math.min(this.centerX, this.centerY);
	    }

	    get color() {
	        return this._color;
	    }

	    set color(value) {
	        this.isColorChanged = this.isColorChanged || (this._color !== value);
	        this.dirty = this.dirty || this.isColorChanged;
	        this._color = value;
	        this.setShapesColor(value);
	    }

	    setColor(color) {
	        this.color = color;
	        return this;
	    }

	    setShapesColor(color) {

	    }

	    get value() {
	        return this._value;
	    }

	    set value(value) {
	        value = Phaser.Math.Clamp(value, 0, 1);
	        this.dirty = this.dirty || (this._value != value);
	        this._value = value;
	    }

	    setValue(value) {
	        this.value = value;
	        return this;
	    }

	    setDuration(duration) {
	        this.duration = duration;
	        return this;
	    }

	    setDelay(delay) {
	        this.delay = delay;
	        return this;
	    }

	    setRepeatDelay(repeatDelay) {
	        this.repeatDelay = repeatDelay;
	        return this;
	    }

	    setEase(ease) {
	        this.ease = ease;
	        return this;
	    }

	    get isRunning() {
	        return (this.tweenTask) ? this.tweenTask.isRunning : false;
	    }
	}

	Object.assign(
	    Base.prototype,
	    EaseValueMethods
	);

	const DegToRad$1 = Phaser.Math.DegToRad;
	const Linear$a = Phaser.Math.Linear;
	const ExpoIn$4 = Phaser.Math.Easing.Expo.In;

	const DIRMAP = {
	    right: 0,
	    down: 1,
	    left: 2,
	    up: 3
	};

	var ArrowPolygon = function (polygon, innerX, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d) {
	    var p0 = Transform(innerX, 0, gridWidth, gridHeight, x0, y0, a, b, c, d);
	    polygon.startAt(p0.x, p0.y);
	    var p1 = Transform(outerX, 0, gridWidth, gridHeight, x0, y0, a, b, c, d);
	    polygon.lineTo(p1.x, p1.y);
	    var p2 = Transform(outerX, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
	    polygon.lineTo(p2.x, p2.y);
	    var p3 = Transform(0, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
	    polygon.lineTo(p3.x, p3.y);
	    var p4 = Transform(0, innerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
	    polygon.lineTo(p4.x, p4.y);
	    var p5 = Transform(innerX, innerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
	    polygon.lineTo(p5.x, p5.y);
	    polygon.close();
	};

	var GlobPoint = {};
	var Transform = function (gridX, gridY, gridWidth, gridHeight, x0, y0, a, b, c, d) {
	    var x = gridX * gridWidth;
	    var y = gridY * gridHeight;
	    GlobPoint.x = a * x + b * y + x0;
	    GlobPoint.y = c * x + d * y + y0;
	    return GlobPoint;
	};

	var ArrowUpdateShapesMethods = {
	    setDirection(direction) {
	        if (typeof (direction) === 'string') {
	            direction = DIRMAP[direction];
	        }
	        this.direction = direction;
	        return this;
	    },

	    buildShapes() {
	        for (var i = 0; i < 3; i++) {
	            this.addShape(new Lines());
	        }
	    },

	    updateShapes() {
	        var x0, y0, a, b, c, d;
	        switch (this.direction) {
	            case 1:
	                x0 = this.centerX;
	                y0 = this.centerY - this.radius;
	                // xt = a*x + b*y
	                var radX = DegToRad$1(315);
	                a = Math.cos(radX);
	                b = Math.sin(radX);
	                // yt = c*x + d*y
	                var radY = DegToRad$1(45);
	                c = Math.cos(radY);
	                d = Math.sin(radY);
	                break;

	            case 3:
	                x0 = this.centerX;
	                y0 = this.centerY + this.radius;
	                // xt = a*x + b*y
	                var radX = DegToRad$1(135);
	                a = Math.cos(radX);
	                b = Math.sin(radX);
	                // yt = c*x + d*y
	                var radY = DegToRad$1(225);
	                c = Math.cos(radY);
	                d = Math.sin(radY);
	                break;

	            case 2:
	                x0 = this.centerX + this.radius;
	                y0 = this.centerY;
	                // xt = a*x + b*y
	                var radX = DegToRad$1(225);
	                a = Math.cos(radX);
	                b = Math.sin(radX);
	                // yt = c*x + d*y
	                var radY = DegToRad$1(315);
	                c = Math.cos(radY);
	                d = Math.sin(radY);
	                break;

	            default:
	                x0 = this.centerX - this.radius;
	                y0 = this.centerY;
	                // xt = a*x + b*y
	                var radX = DegToRad$1(45);
	                a = Math.cos(radX);
	                b = Math.sin(radX);
	                // yt = c*x + d*y
	                var radY = DegToRad$1(135);
	                c = Math.cos(radY);
	                d = Math.sin(radY);
	                break;
	        }

	        var gridSize = this.radius / 7;

	        var shapes = this.getShapes();
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var shape = shapes[i];

	            var t = (this.value + ((cnt - i) * 0.1)) % 1;
	            t = ExpoIn$4(Yoyo$1(t));
	            var alpha = Linear$a(0.25, 1, t);

	            shape.fillStyle(this.color, alpha);

	            var innerX = (i * 3) + 1;
	            var outerX = innerX + 2;
	            ArrowPolygon(shape, innerX, outerX, gridSize, gridSize, x0, y0, a, b, c, d);
	        }
	    }
	};

	const Linear$9 = Phaser.Math.Linear;

	var AudioUpdateShapeMethods = {
	    buildShapes() {
	        for (var i = 0; i < 4; i++) {
	            this.addShape(new Line());
	        }
	        this.prevValue = undefined;
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var leftBound = centerX - radius;
	        var bottomBound = centerY + radius;
	        var maxLineHeight = radius * 2;

	        var shapes = this.getShapes(),
	            cnt = shapes.length;
	        var cellWidth = (radius * 2) / cnt;
	        var lineWidth = cellWidth * 0.7;

	        // Reset range of value
	        if ((this.prevValue === undefined) || (this.prevValue > this.value)) {
	            for (var i = 0; i < cnt; i++) {
	                var line = shapes[i];
	                var from = (this.prevValue === undefined) ? Math.random() : line.getData('to');
	                line
	                    .setData('from', from)
	                    .setData('to', Math.random());
	            }
	        }
	        this.prevValue = this.value;

	        for (var i = 0; i < cnt; i++) {
	            var line = shapes[i];
	            var from = line.getData('from'),
	                to = line.getData('to'),
	                current = Linear$9(from, to, this.value);
	            var lineHeight = current * maxLineHeight;
	            var x = leftBound + (cellWidth * (i + 0.5));

	            line
	                .lineStyle(lineWidth, this.color, 1)
	                .setP0(x, bottomBound)
	                .setP1(x, (bottomBound - lineHeight));

	        }
	    }
	};

	const Linear$8 = Phaser.Math.Linear;

	var BallUpdateShapeMethods = {
	    buildShapes() {
	        for (var i = 0; i < 3; i++) {
	            this.addShape(new Circle());
	        }
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var ballRadius = radius * 0.1;
	        var lineWidth = Math.ceil(ballRadius * 0.25);

	        var t = 1 - Yoyo$1(this.value);
	        var trackRadius = Linear$8(0.3, 0.9, t) * radius;

	        var shapes = this.getShapes();
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var ball = shapes[i];
	            var t = (this.value + (i / cnt)) % 1;
	            var angle = Math.PI * 2 * t;
	            ball
	                .lineStyle(lineWidth, this.color)
	                .setRadius(ballRadius)
	                .setCenterPosition(
	                    centerX + Math.cos(angle) * trackRadius,
	                    centerY + Math.sin(angle) * trackRadius
	                );
	        }
	    }
	};

	const Linear$7 = Phaser.Math.Linear;
	const ExpoIn$3 = Phaser.Math.Easing.Expo.In;

	var BarsUpdateShapeMethods = {
	    buildShapes() {
	        var cnt = 5;
	        for (var i = 0; i < cnt; i++) {
	            var line = new Line();
	            this.addShape(line);
	            var offset = Yoyo$1(i / (cnt - 1)) / 2;
	            line.setData('offset', offset);
	        }
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var leftBound = centerX - radius;
	        var maxLineHeight = radius * 2;

	        var shapes = this.getShapes(),
	            cnt = shapes.length;
	        var cellWidth = (radius * 2) / cnt;
	        var lineWidth = cellWidth * 0.7;


	        for (var i = 0; i < cnt; i++) {
	            var line = shapes[i];
	            var t = (this.value + line.getData('offset')) % 1;
	            t = ExpoIn$3(Yoyo$1(t));

	            var lineHeight = Linear$7(0.4, 1, t) * maxLineHeight;
	            var x = leftBound + (cellWidth * (i + 0.5));

	            line
	                .lineStyle(lineWidth, this.color, 1)
	                .setP0(x, (centerY - (lineHeight / 2)))
	                .setP1(x, (centerY + (lineHeight / 2)));

	        }
	    }
	};

	var BoxUpdateShapeMethods = {
	    buildShapes() {
	        this.addShape((new Lines()).setName('border'));
	        this.addShape((new Lines()).setName('fill'));
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;

	        var halfWidth = radius * 0.7;
	        var left = centerX - halfWidth,
	            top = centerY - halfWidth,
	            width = halfWidth * 2;

	        this.getShape('border')
	            .lineStyle(2, this.color, 1)
	            .startAt(left, top).lineTo(width, 0, true)
	            .lineTo(0, width, true).lineTo(-width, 0, true)
	            .lineTo(0, -width, true).close();

	        if (this.value < 0.5) {
	            var t = (0.5 - this.value) * 2;
	            var height = width * t;
	            this.getShape('fill')
	                .fillStyle(this.color, 1)
	                .startAt(left, top).lineTo(width, 0, true)
	                .lineTo(0, height, true).lineTo(-width, 0, true)
	                .lineTo(0, -height, true).close();

	        } else { // Rotate
	            var t = (this.value - 0.5) * 2;
	            var angle = 180 * t;

	            this.getShape('border').rotateAround(centerX, centerY, angle);
	            this.getShape('fill').fillStyle().lineStyle();
	        }
	    }
	};

	const RadToDeg = Phaser.Math.RadToDeg;
	const WrapDegrees = Phaser.Math.Angle.WrapDegrees;
	const WrapRad = Phaser.Math.Angle.Wrap;
	const ShortestBetween = Phaser.Math.Angle.ShortestBetween;
	const DegToRad = Phaser.Math.DegToRad;
	const Rad270 = Phaser.Math.DegToRad(270);

	var ClockUpdateShapeMethods = {
	    buildShapes() {
	        this.addShape((new Circle()).setName('border'));
	        this.addShape((new Line()).setName('minuteHand'));
	        this.addShape((new Line()).setName('hourHand'));

	        this.minuteHandAngle = 0;
	        this.hourHandAngle = 0;
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var lineWidth = Math.ceil(radius / 25);
	        var borderRadius = radius - (lineWidth / 2);
	        var minuteHandLength = radius * 0.8;
	        var hourHandLength = radius * 0.5;

	        var prevMinuteHandAngle = this.minuteHandAngle;
	        this.minuteHandAngle = Math.PI * 2 * this.value;
	        var angle0 = WrapDegrees(RadToDeg(prevMinuteHandAngle));
	        var angle1 = WrapDegrees(RadToDeg(this.minuteHandAngle));
	        var deltaAngle = ShortestBetween(angle0, angle1);
	        this.hourHandAngle = WrapRad(this.hourHandAngle + (DegToRad(deltaAngle) / 12));

	        this.getShape('border')
	            .lineStyle(lineWidth, this.color)
	            .setRadius(borderRadius)
	            .setCenterPosition(centerX, centerY);

	        var angle = this.minuteHandAngle + Rad270;
	        this.getShape('minuteHand')
	            .lineStyle(lineWidth, this.color)
	            .setP0(centerX, centerY)
	            .setP1(
	                centerX + (Math.cos(angle) * minuteHandLength),
	                centerY + (Math.sin(angle) * minuteHandLength)
	            );

	        var angle = this.hourHandAngle + Rad270;
	        this.getShape('hourHand')
	            .lineStyle(lineWidth, this.color)
	            .setP0(centerX, centerY)
	            .setP1(
	                centerX + (Math.cos(angle) * hourHandLength),
	                centerY + (Math.sin(angle) * hourHandLength)
	            );
	    }
	};

	const Linear$6 = Phaser.Math.Linear;
	const ExpoIn$2 = Phaser.Math.Easing.Expo.In;
	const RowNum$1 = 2;
	const ColNum$1 = 2;

	var CubeUpdateShapeMethods = {
	    buildShapes() {
	        var cnt = RowNum$1 * ColNum$1;
	        for (var i = 0; i < cnt; i++) {
	            var line = new Line();
	            this.addShape(line);
	        }
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var leftBound = centerX - radius;
	        var topBound = centerY - radius;
	        var cellWidth = (radius * 2) / ColNum$1;
	        var cellHeight = (radius * 2) / RowNum$1;

	        var shapes = this.getShapes(),
	            cnt = shapes.length;
	        for (var i = 0; i < cnt; i++) {
	            var colIdx = (i % ColNum$1);
	            var rowIdx = Math.floor(i / RowNum$1);
	            var x = leftBound + (cellWidth * (colIdx + 0.5));
	            var y = topBound + (cellHeight * (rowIdx + 0.5));

	            var line = shapes[i];
	            var t = (this.value + ((cnt - i) * 0.1)) % 1;
	            t = ExpoIn$2(Yoyo$1(t));

	            var lineAlpha = (cnt - i) / cnt;
	            var lineHeight = Linear$6(0.7, 1, t) * cellHeight;
	            var lineWidth = Linear$6(0.7, 1, t) * cellWidth;

	            line
	                .lineStyle(lineWidth, this.color, lineAlpha)
	                .setP0(x - (lineHeight / 2), y)
	                .setP1(x + (lineHeight / 2), y);
	        }
	    }
	};

	const Linear$5 = Phaser.Math.Linear;

	var DotsUpdateShapeMethods = {
	    buildShapes() {
	        var cnt = 3;
	        for (var i = 0; i < cnt; i++) {
	            var dot = new Circle();
	            this.addShape(dot);

	            var offset = Yoyo$1(i / (cnt - 1)) / 2;
	            dot.setData('offset', offset);
	        }
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var leftBound = centerX - radius;

	        var shapes = this.getShapes(),
	            cnt = shapes.length;
	        var cellWidth = (radius * 2) / cnt;
	        var maxDotRadius = cellWidth / 2;

	        for (var i = 0; i < cnt; i++) {
	            var dot = shapes[i];
	            var t = (this.value + dot.getData('offset')) % 1;
	            t = Yoyo$1(t);

	            var dotAlpha = Linear$5(0.25, 1, t);
	            var dotRadius = Linear$5(0.5, 1, t) * maxDotRadius;
	            dot
	                .fillStyle(this.color, dotAlpha)
	                .setRadius(dotRadius)
	                .setCenterPosition(
	                    leftBound + (cellWidth * (i + 0.5)),
	                    centerY
	                );
	        }
	    }
	};

	const Linear$4 = Phaser.Math.Linear;
	const ExpoIn$1 = Phaser.Math.Easing.Expo.In;

	var FacebookUpdateShapeMethods = {
	    buildShapes() {
	        for (var i = 0; i < 3; i++) {
	            var shape = new Line();
	            this.addShape(shape);
	        }
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var leftBound = centerX - radius;

	        var shapes = this.getShapes(),
	            cnt = shapes.length;
	        var cellWidth = (radius * 2) / cnt;
	        var cellHeight = radius * 2;

	        for (var i = 0; i < cnt; i++) {
	            var line = shapes[i];
	            var t = (this.value + ((cnt - i) * 0.1)) % 1;
	            t = ExpoIn$1(Yoyo$1(t));

	            var lineAlpha = (i + 1) / cnt;
	            var lineHeight = Linear$4(0.7, 1, t) * cellHeight;
	            var lineWidth = Linear$4(0.7, 1, t) * cellWidth;
	            var x = leftBound + (cellWidth * (i + 0.5));

	            line
	                .lineStyle(lineWidth, this.color, lineAlpha)
	                .setP0(x, centerY - (lineHeight / 2))
	                .setP1(x, centerY + (lineHeight / 2));
	        }
	    }
	};

	const Linear$3 = Phaser.Math.Linear;
	const RowNum = 3;
	const ColNum = 3;

	var GridUpdateShapeMethods = {
	    buildShapes() {
	        var cnt = RowNum * ColNum;
	        for (var i = 0; i < cnt; i++) {
	            var dot = new Circle();
	            this.addShape(dot);

	            dot.setData('offset', Math.random());
	        }
	        this.isInitialize = true;
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var needLayout = this.isInitialize || this.isSizeChanged;

	        var leftBound = centerX - radius;
	        var topBound = centerY - radius;
	        var cellWidth = (radius * 2) / ColNum;
	        var cellHeight = (radius * 2) / RowNum;
	        var maxDotRadius = (Math.min(cellWidth, cellHeight) / 2) * 0.8;


	        var shapes = this.getShapes();
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var colIdx = (i % ColNum);
	            var rowIdx = Math.floor(i / RowNum);
	            var x = leftBound + cellWidth * (colIdx + 0.5);
	            var y = topBound + cellHeight * (rowIdx + 0.5);

	            var dot = shapes[i];
	            var t = (this.value + dot.getData('offset')) % 1;
	            t = Yoyo$1(t);
	            dot.fillStyle(this.color, Linear$3(0.25, 1, t));

	            if (needLayout) {
	                dot
	                    .setRadius(maxDotRadius)
	                    .setCenterPosition(x, y);
	            }
	        }

	        this.isInitialize = false;
	    }
	};

	var HeartsUpdateShapeMethods = {
	    buildShapes() {
	        for (var i = 0; i < 2; i++) {
	            this.addShape(new Lines());
	        }
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var lineWidth = Math.ceil(radius / 25);
	        var maxW50 = radius - lineWidth,
	            maxW30 = maxW50 * 0.6,
	            maxW35 = maxW50 * 0.7,
	            maxW60 = maxW50 * 1.2;


	        var shapes = this.getShapes();
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var heart = shapes[i];
	            var t = (this.value + (i / cnt)) % 1;
	            var alpha = Yoyo$1(t);
	            var x = centerX,
	                y = centerY - (15 * t);
	            var w50 = maxW50 * t,
	                w30 = maxW30 * t,
	                w35 = maxW35 * t,
	                w60 = maxW60 * t;

	            heart
	                .lineStyle(lineWidth, this.color, alpha)
	                .startAt(
	                    x, y
	                )
	                .cubicBezierTo(
	                    x, y - w30,
	                    x - w50, y - w30,
	                    x - w50, y
	                )
	                .cubicBezierTo(
	                    x - w50, y + w30,
	                    x, y + w35,
	                    x, y + w60
	                )
	                .cubicBezierTo(
	                    x, y + w35,
	                    x + w50, y + w30,
	                    x + w50, y
	                )
	                .cubicBezierTo(
	                    x + w50, y - w30,
	                    x, y - w30,
	                    x, y
	                )
	                .close();
	        }
	    }
	};

	const Linear$2 = Phaser.Math.Linear;

	var IosUpdateShapeMethods = {
	    buildShapes() {
	        for (var i = 0; i < 12; i++) {
	            this.addShape(new Line());
	        }
	        this.isInitialize = true;
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var needLayout = this.isInitialize || this.isSizeChanged;

	        var radius = this.radius;
	        var startRadius = radius / 2;
	        var lineWidth = Math.ceil(radius / 20);
	        var shapes = this.getShapes();
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var line = shapes[i];
	            var t = i / cnt;
	            var angle = Math.PI * 2 * t;
	            var alpha = Linear$2(0.25, 1, (1 - this.value + t) % 1);
	            line.lineStyle(lineWidth, this.color, alpha);

	            if (needLayout) {
	                line
	                    .setP0(
	                        centerX + Math.cos(angle) * startRadius,
	                        centerY + Math.sin(angle) * startRadius
	                    )
	                    .setP1(
	                        centerX + Math.cos(angle) * radius,
	                        centerY + Math.sin(angle) * radius
	                    );
	            }
	        }

	        this.isInitialize = false;
	    }
	};

	var OribitUpdateShapeMethods = {
	    buildShapes() {
	        this.addShape((new Circle()).setName('track'));
	        this.addShape((new Circle()).setName('thumb'));
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var trackRadius = radius * 0.9;
	        var trackThickness = Math.ceil(trackRadius / 25);
	        var thumbRadius = radius * 0.1;
	        var thumbAngle = Math.PI * 2 * this.value;

	        this.getShape('track')
	            .lineStyle(trackThickness, this.color, 0.7)
	            .setRadius(trackRadius)
	            .setCenterPosition(centerX, centerY);

	        this.getShape('thumb')
	            .fillStyle(this.color)
	            .setRadius(thumbRadius)
	            .setCenterPosition(
	                centerX + Math.cos(thumbAngle) * trackRadius,
	                centerY + Math.sin(thumbAngle) * trackRadius
	            );
	    }
	};

	var OvalUpdateShapeMethods = {
	    buildShapes() {
	        this.addShape((new Circle()).setName('track'));
	        this.addShape((new Arc()).setName('arc'));
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var lineWidth = Math.ceil(radius / 25);
	        var maxRadius = radius - (lineWidth / 2);

	        this.getShape('track')
	            .lineStyle(lineWidth, this.color, 0.5)
	            .setRadius(maxRadius)
	            .setCenterPosition(centerX, centerY);

	        var startAngle = this.value * 360;
	        var endAngle = startAngle + 60;
	        this.getShape('arc')
	            .lineStyle(lineWidth, this.color, 1)
	            .setRadius(maxRadius)
	            .setCenterPosition(centerX, centerY)
	            .setAngle(startAngle, endAngle);

	    }
	};

	const Linear$1 = Phaser.Math.Linear;

	var PieUpdateShapeMethods = {
	    buildShapes() {
	        for (var i = 0; i < 4; i++) {
	            var pie = (new Arc()).setPie();
	            this.addShape(pie);

	            pie.setData('speed', Linear$1(180, 360, Math.random()));
	        }
	        this.prevValue = undefined;
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;

	        var deltaValue;
	        if (this.prevValue !== undefined) {
	            deltaValue = this.value - this.prevValue;
	            if (this.prevValue > this.value) {
	                deltaValue += 1;
	            }
	        }

	        var shapes = this.getShapes();
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var pie = shapes[i];
	            var pieAlpha = (i + 1) / cnt;

	            if (this.prevValue === undefined) {
	                var startAngle = (i / cnt) * 360;
	                var endAngle = startAngle + 90;
	                pie
	                    .fillStyle(this.color, pieAlpha)
	                    .setRadius(radius)
	                    .setCenterPosition(centerX, centerY)
	                    .setAngle(startAngle, endAngle)
	                    .setData('angle', startAngle);
	            } else {
	                var startAngle = pie.getData('angle') + pie.getData('speed') * deltaValue;
	                startAngle = startAngle % 360;
	                var endAngle = startAngle + 90;
	                pie
	                    .fillStyle(this.color, pieAlpha)
	                    .setRadius(radius)
	                    .setCenterPosition(centerX, centerY)
	                    .setAngle(startAngle, endAngle)
	                    .setData('angle', startAngle);

	            }

	        }

	        this.prevValue = this.value;

	    }
	};

	var PuffUpdateShapeMethods = {
	    buildShapes() {
	        this.addShape(new Circle());
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var puffRadius = radius * this.value;
	        var lineWidth = Math.ceil(radius / 25);
	        var alpha = Yoyo$1(this.value);

	        this.getShapes()[0]
	            .lineStyle(lineWidth, this.color, alpha)
	            .setRadius(puffRadius)
	            .setCenterPosition(centerX, centerY);
	    }
	};

	const Linear = Phaser.Math.Linear;
	const ExpoIn = Phaser.Math.Easing.Expo.In;

	var RadioUpdateShapeMethods = {
	    buildShapes() {
	        this.addShape((new Circle()).setName('center'));
	        this.addShape((new Lines()).setName('arc0'));
	        this.addShape((new Lines()).setName('arc1'));
	        this.isInitialize = true;
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var needLayout = this.isInitialize || this.isSizeChanged;

	        var centerRadius = (radius * 2) / 6;
	        var x = centerX - radius + centerRadius;
	        var y = centerY + radius - centerRadius;

	        var shapes = this.getShapes();
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var shape = shapes[i];

	            var t = (this.value + ((cnt - i) * 0.1)) % 1;
	            t = ExpoIn(Yoyo$1(t));
	            var alpha = Linear(0.25, 1, t);

	            switch (shape.name) {
	                case 'center':
	                    shape.fillStyle(this.color, alpha);

	                    if (needLayout) {
	                        shape
	                            .setRadius(centerRadius)
	                            .setCenterPosition(x, y);
	                    }
	                    break;
	                case 'arc0':
	                    shape.fillStyle(this.color, alpha);

	                    if (needLayout) {
	                        var radius0 = centerRadius * 2,
	                            radius1 = centerRadius * 3;
	                        shape
	                            .startAt(x, y - radius0)
	                            .lineTo(x, y - radius1)
	                            .setIterations(8).arc(x, y, radius1, 270, 360)
	                            .lineTo(x + radius0, y)
	                            .setIterations(6).arc(x, y, radius0, 360, 270, true)
	                            .close();
	                    }
	                    break;
	                case 'arc1':
	                    shape.fillStyle(this.color, alpha);

	                    if (needLayout) {
	                        var radius0 = centerRadius * 4,
	                            radius1 = centerRadius * 5;
	                        shape
	                            .startAt(x, y - radius0)
	                            .lineTo(x, y - radius1)
	                            .setIterations(8).arc(x, y, radius1, 270, 360)
	                            .lineTo(x + radius0, y)
	                            .setIterations(6).arc(x, y, radius0, 360, 270, true)
	                            .close();
	                    }
	                    break;
	            }
	        }

	        this.isInitialize = false;
	    }
	};

	var RingsUpdateShapeMethods = {
	    buildShapes() {
	        for (var i = 0; i < 2; i++) {
	            this.addShape(new Circle());
	        }
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var lineWidth = Math.ceil(radius / 25);
	        var maxRingRadius = radius - lineWidth;

	        var shapes = this.getShapes();
	        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
	            var ring = shapes[i];
	            var t = (this.value + (i / cnt)) % 1;
	            var alpha = Yoyo$1(t);
	            ring
	                .lineStyle(lineWidth, this.color, alpha)
	                .setRadius(t * maxRingRadius)
	                .setCenterPosition(centerX, centerY);
	        }
	    }
	};

	var SpinnerUpdateShapeMethods = {
	    buildShapes() {
	        this.addShape((new Arc()).setName('arc'));
	    },

	    updateShapes() {
	        var centerX = this.centerX;
	        var centerY = this.centerY;
	        var radius = this.radius;
	        var lineWidth = Math.ceil(radius / 10);
	        var maxRadius = radius - lineWidth;

	        var endAngle = this.value * 720;
	        var arcAngle = Yoyo$1(this.value) * 180;
	        var startAngle = endAngle - arcAngle;
	        this.getShape('arc')
	            .lineStyle(lineWidth, this.color, 1)
	            .setRadius(maxRadius)
	            .setCenterPosition(centerX, centerY)
	            .setAngle(startAngle + 315, endAngle + 315);

	    }
	};

	Phaser.Utils.Objects.GetValue;

	const AnimationModeMap = {
	    leftArrow: ArrowUpdateShapesMethods,
	    rightArrow: ArrowUpdateShapesMethods,
	    upArrow: ArrowUpdateShapesMethods,
	    downArrow: ArrowUpdateShapesMethods,
	    audio: AudioUpdateShapeMethods,
	    ball: BallUpdateShapeMethods,
	    bars: BarsUpdateShapeMethods,
	    box: BoxUpdateShapeMethods,
	    clock: ClockUpdateShapeMethods,
	    cube: CubeUpdateShapeMethods,
	    dots: DotsUpdateShapeMethods,
	    facebook: FacebookUpdateShapeMethods,
	    grid: GridUpdateShapeMethods,
	    hearts: HeartsUpdateShapeMethods,
	    ios: IosUpdateShapeMethods,
	    oribit: OribitUpdateShapeMethods,
	    oval: OvalUpdateShapeMethods,
	    pie: PieUpdateShapeMethods,
	    puff: PuffUpdateShapeMethods,
	    radio: RadioUpdateShapeMethods,
	    rings: RingsUpdateShapeMethods,
	    spinner: SpinnerUpdateShapeMethods
	};

	const AnimationModeList = [];
	for (var name in AnimationModeMap) {
	    AnimationModeList.push(name);
	}

	const GetRandomItem = Phaser.Utils.Array.GetRandom;

	var UpdateShapeMethods = {
	    setAnimationMode(mode, config) {
	        if (!AnimationModeMap.hasOwnProperty(mode)) {
	            mode = GetRandomItem(AnimationModeList);
	        }
	        this.animationMode = mode;
	        var updateMethods = AnimationModeMap[mode];

	        if (config) {
	            this.resetFromConfig(config);
	        }

	        switch (mode) {
	            case 'leftArrow':
	                // ArrowUpdateShapesMethods
	                updateMethods.setDirection.call(this, 'left');
	                break;

	            case 'rightArrow':
	                // ArrowUpdateShapesMethods
	                updateMethods.setDirection.call(this, 'right');
	                break;

	            case 'upArrow':
	                // ArrowUpdateShapesMethods
	                updateMethods.setDirection.call(this, 'up');
	                break;

	            case 'downArrow':
	                // ArrowUpdateShapesMethods
	                updateMethods.setDirection.call(this, 'down');
	                break;
	        }

	        this.clear();
	        updateMethods.buildShapes.call(this);
	        this.updateShapes = updateMethods.updateShapes.bind(this);

	        this.stop().start();

	        return this;
	    },

	    setRandomAnimationMode(config) {
	        var mode = GetRandomItem(AnimationModeList);
	        this.setAnimationMode(mode, config);
	        return this;
	    }
	};

	const GetValue$m = Phaser.Utils.Objects.GetValue;

	class AIO extends Base {
	    constructor(scene, config) {
	        super(scene, config);
	        this.type = 'rexSpinnerAIO';

	        this.setAnimationMode(GetValue$m(config, 'animationMode'));
	    }
	}

	Object.assign(
	    AIO.prototype,
	    UpdateShapeMethods,
	);

	// KeyCodes : Key (string) to KeyCode (number)
	const KeyCodes = Phaser.Input.Keyboard.KeyCodes;

	var KeyMap = {};
	for (var key$1 in KeyCodes) {
	    KeyMap[KeyCodes[key$1]] = key$1;
	}

	var GenerateDefaultCreateGameObjectCallback$3 = function (
	    style,
	    {
	        viewport
	    } = {},
	    creators
	) {

	    var defaultFrameDelimiter = style.frameDelimiter || '-';

	    return function (
	        scene,
	        {
	            vpw, vph,
	            width = 0, height = 0,
	            vpx = 0.5, vpy = 1,

	            frameDelimiter = defaultFrameDelimiter,

	            clickTarget,
	            clickShortcutKeys,
	            fastTypingShortcutKeys,

	            commandExecutor, eventSheetManager, eventsheet,
	        } = {},
	    ) {

	        if (vpw !== undefined) {
	            width = viewport.width * vpw;
	        }

	        if (vph !== undefined) {
	            height = viewport.height * vph;
	        }

	        if (width > 0) {
	            SetValue(style, 'expandTextWidth', true);
	        }
	        if (height > 0) {
	            SetValue(style, 'expandTextHeight', true);
	        }

	        if (creators === undefined) {
	            creators = {};
	        }

	        if (!creators.hasOwnProperty('icon')) {
	            creators.icon = function (scene, config) {
	                var gameObject = new TransitionImagePack(scene, config);
	                DecorateGameObject(gameObject, config);
	                gameObject.setOrigin(0.5, 1);

	                scene.add.existing(gameObject);
	                return gameObject;
	            };
	        }

	        var useDefaultWaitIcon = false;
	        if (!creators.hasOwnProperty('action')) {
	            creators.action = function (scene, config) {
	                if (config === undefined) {
	                    config = {};
	                }
	                var gameObject = new AIO(scene, config);
	                DecorateGameObject(gameObject, config);

	                scene.add.existing(gameObject);
	                return gameObject;
	            };

	            useDefaultWaitIcon = true;
	        }

	        var gameObject = new SimpleTextBox(scene, style, creators);

	        gameObject
	            .setMinSize(width, height)
	            .setOrigin(0.5, 1)  // Align to bottom
	            .layout();

	        scene.add.existing(gameObject);

	        AddViewportCoordinateProperties(gameObject, viewport);

	        gameObject.vpx = vpx;
	        gameObject.vpy = vpy;

	        gameObject.frameDelimiter = frameDelimiter;

	        var waitIcon;
	        if (useDefaultWaitIcon) {
	            waitIcon = gameObject.getElement('action');
	            gameObject.setChildVisible(waitIcon, false);
	        }

	        AddShakeBehavior(gameObject);

	        /*
	        Fire textbox's 'click' event when
	        - Pointer-down on clickTarget (screen or this textbox) 
	        - Press keyboard's key
	        
	        !!! note
	            Since 'click' event might fire during typing, don't use *wait pointerdown|keydown*
	        */

	        gameObject.emitClick = function () {
	            gameObject.emit('click');
	        };

	        var touchEE;
	        if (clickTarget === undefined) {
	            clickTarget = eventSheetManager.getData('$clickTarget');
	        }
	        if (clickTarget === null) ; else if (clickTarget.toLowerCase() === 'screen') {
	            touchEE = commandExecutor.sys.anyTouchDetector;
	        } else {
	            touchEE = gameObject.setInteractive();
	        }

	        if (touchEE) {
	            gameObject.bindEvent(
	                touchEE,               // eventEmitter, 
	                'pointerdown',         // eventName
	                function () {          // callback
	                    gameObject.emitClick();
	                }
	            );
	        }

	        gameObject.bindEvent(
	            scene.input.keyboard,      // eventEmitter
	            'keydown',                 // eventName
	            function (event) {         // callback
	                if (clickShortcutKeys === undefined) {
	                    clickShortcutKeys = eventSheetManager.getData('$clickShortcutKeys');
	                }
	                if (!clickShortcutKeys) {
	                    return;
	                }

	                var keys = clickShortcutKeys.split('|');
	                var inputKey = KeyMap[event.keyCode];
	                if (keys.indexOf(inputKey) !== -1) {
	                    gameObject.emitClick();
	                }
	            }
	        );

	        // On click
	        var OnClick = function () {
	            if (gameObject.isTyping) {
	                // Wait clicking for typing next page, 
	                // or emitting 'complete2' event
	                gameObject
	                    .once('click', OnClick)
	                    .stop(true);

	            } else if (!gameObject.isLastPage) {
	                // !gameObject.isLastPage && !gameObject.isTyping
	                // Typing next page, interrupted by click event
	                gameObject
	                    .once('click', OnClick)
	                    .typeNextPage();

	            } else if (!gameObject.complete2Flag) {
	                gameObject.complete2Flag = true;
	                gameObject.emit('complete2');

	            }
	        };

	        /*
	        PageEnd0 -> click -> PageEnd1
	        PageEnd0 -> fastTyping|autoNextPage -> PageEnd1
	        */
	        // on 'pageend', wait click
	        var PageEnd0 = function () {
	            if (useDefaultWaitIcon) {
	                waitIcon.start();
	                gameObject.setChildVisible(waitIcon, true);
	            }

	            gameObject.once('click', PageEnd1);

	            // $fastTyping has higher priority than $autoNextPage
	            let fastTyping = eventSheetManager.getData('$fastTyping');
	            let autoNextPage = eventSheetManager.getData('$autoNextPage');
	            if (fastTyping || autoNextPage) {
	                var autoNextPageDelay;
	                if (fastTyping) {
	                    autoNextPageDelay = 0;
	                } else {
	                    autoNextPageDelay = eventSheetManager.getData('$autoNextPageDelay');
	                }

	                commandExecutor.sys.timeline.delayCall(autoNextPageDelay, gameObject.emitClick);
	            }

	            eventSheetManager.emit('pause.input');
	        };

	        // on 'pageend', on 'click'
	        var PageEnd1 = function () {
	            if (!gameObject.isPageEnd) {
	                return;
	            }

	            gameObject.off('click', PageEnd1);

	            if (useDefaultWaitIcon) {
	                waitIcon.stop();
	                gameObject.setChildVisible(waitIcon, false);
	            }

	            eventSheetManager.emit('resume.input');
	        };
	        gameObject._typeNextPage = PageEnd1;

	        gameObject
	            .on('pageend', PageEnd0)
	            .on('start', function () {
	                // Remove pending callback, add new one
	                gameObject
	                    .off('click', OnClick)
	                    .once('click', OnClick);
	            });

	        // Change typing speed if $fastTyping is changed
	        var fastTypingSave = eventSheetManager.getData('$fastTyping');
	        var autoNextPageSave = eventSheetManager.getData('$autoNextPage');
	        gameObject.bindScenePreupdateEvent(function () {
	            let fastTyping = eventSheetManager.getData('$fastTyping');
	            let autoNextPage = eventSheetManager.getData('$autoNextPage');

	            if (fastTyping !== fastTypingSave) {
	                if (gameObject.isTyping) {
	                    // Change typing speed
	                    let typingSpeed;
	                    if (fastTyping) {
	                        typingSpeed = eventSheetManager.getData('$fastTypingSpeed');
	                    } else if (typingSpeed === undefined) {
	                        typingSpeed = gameObject.normalTypingSpeed;
	                    }
	                    gameObject.setTypingSpeed(typingSpeed);
	                } else {
	                    if (fastTyping) {
	                        // Start typing next 
	                        gameObject.emitClick();
	                    }
	                }
	            } else if ((autoNextPage !== autoNextPageSave) && !fastTyping) {  // $fastTyping has higher priority than $autoNextPage
	                if (gameObject.isTyping) ; else {
	                    if (autoNextPage) {
	                        // Start typing next page
	                        gameObject.emitClick();
	                    }
	                }
	            }

	            fastTypingSave = fastTyping;
	            autoNextPageSave = autoNextPage;
	        });


	        // Set $fastTyping to true/false if any fastTypingShortcutKeys is down/up
	        var SetFastTypingVariableByKeyboard = function (event, fastTypingValue) {
	            if (fastTypingShortcutKeys === undefined) {
	                fastTypingShortcutKeys = eventSheetManager.getData('$fastTypingShortcutKeys');
	            }
	            if (!fastTypingShortcutKeys) {
	                return;
	            }

	            var keys = fastTypingShortcutKeys.split('|');
	            var inputKey = KeyMap[event.keyCode];
	            if (keys.indexOf(inputKey) !== -1) {
	                eventSheetManager.setData('$fastTyping', fastTypingValue);
	            }
	        };

	        gameObject.bindEvent(
	            scene.input.keyboard,      // eventEmitter
	            'keydown',                 // eventName
	            function (event) {         // callback
	                SetFastTypingVariableByKeyboard(event, true);
	            }
	        );
	        gameObject.bindEvent(
	            scene.input.keyboard,      // eventEmitter
	            'keyup',                   // eventName
	            function (event) {         // callback
	                SetFastTypingVariableByKeyboard(event, false);
	            }
	        );

	        return gameObject;
	    }
	};

	const GetValue$l = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$8 = Phaser.Utils.Objects.IsPlainObject;

	var RegisterTextboxType = function (commandExecutor, config) {
	    var { viewport } = config;
	    var createGameObjectCallback = GetValue$l(config, `creators.${TEXTBOX}`, undefined);
	    if (createGameObjectCallback === false) {
	        return;
	    }

	    var creators;
	    if (IsPlainObject$8(createGameObjectCallback)) {
	        creators = createGameObjectCallback;
	        createGameObjectCallback = undefined;
	    }

	    if (createGameObjectCallback === undefined) {
	        var style = GetValue$l(config, `styles.${TEXTBOX}`, {});
	        createGameObjectCallback = GenerateDefaultCreateGameObjectCallback$3(
	            style,
	            {
	                viewport
	            },
	            creators
	        );
	    }

	    commandExecutor.addGameObjectManager({
	        name: TEXTBOX,
	        createGameObject: createGameObjectCallback,
	        fade: 0,  // No fade-in when creating/destroying gameobject
	        viewportCoordinate: { viewport },
	        defaultLayer: UILayer,

	        commands: {
	            typing: Typing,
	            shake: Shake,
	        }
	    });
	};

	class SimpleTitleLabel extends TitleLabel {
	    constructor(scene, config, creators) {
	        config = BuildTitleLabelConfig(scene, config, creators);
	        super(scene, config);
	        this.type = 'rexSimpleTitleLabel';
	    }

	    setActiveState(enable) {
	        RunMethod(this.getChildren(), 'setActiveState', enable);
	        return this;
	    }

	    setHoverState(enable) {
	        RunMethod(this.getChildren(), 'setHoverState', enable);
	        return this;
	    }

	    setDisableState(enable) {
	        RunMethod(this.getChildren(), 'setDisableState', enable);
	        return this;
	    }

	}

	var RunMethod = function (children, methodName, enable) {
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var gameObject = children[i];
	        if (gameObject && gameObject[methodName]) {
	            gameObject[methodName](enable);
	        }
	    }
	};

	var GenerateDefaultCreateGameObjectCallback$2 = function (
	    style,
	    {
	        viewport
	    } = {},
	    creators
	) {

	    return function (
	        scene,
	        {
	            vpw, vph,
	            width = 0, height = 0,
	            vpx = 1, vpy = 0,
	            alignLeft = false,
	            alignRight = true,
	            alignTop = true,
	            alignBottom = false,
	            text0, text1,

	            commandExecutor, eventSheetManager, eventsheet,
	        } = {},
	    ) {

	        if (vpw !== undefined) {
	            width = viewport.width * vpw;
	        }

	        if (vph !== undefined) {
	            height = viewport.height * vph;
	        }

	        if (creators === undefined) {
	            creators = {};
	        }

	        if (!creators.hasOwnProperty('icon')) {
	            creators.icon = function (scene, config) {
	                var gameObject = new TransitionImagePack(scene, config);
	                DecorateGameObject(gameObject, config);
	                gameObject.setOrigin(0.5, 1);

	                scene.add.existing(gameObject);
	                return gameObject;
	            };
	        }

	        var gameObject = new SimpleTitleLabel(scene, style, creators);

	        if (text0) {
	            gameObject.setTitle(text0);
	        }
	        if (text1) {
	            gameObject.setText(text1);
	        }

	        var originX;
	        if (alignLeft) {
	            originX = 0;
	        } else if (alignRight) {
	            originX = 1;
	        } else {
	            originX = 0.5;
	        }
	        var originY;
	        if (alignTop) {
	            originY = 0;
	        } else if (alignBottom) {
	            originY = 1;
	        } else {
	            originY = 0.5;
	        }


	        gameObject
	            .setMinSize(width, height)
	            .setOrigin(originX, originY)
	            .layout();

	        scene.add.existing(gameObject);

	        AddViewportCoordinateProperties(gameObject, viewport);

	        gameObject.vpx = vpx;
	        gameObject.vpy = vpy;

	        AddShakeBehavior(gameObject);

	        return gameObject;
	    }
	};

	var SetText$1 = function (
	    gameObject,
	    {
	        text0, text1
	    } = {},
	    commandExecutor, eventSheetManager, eventSheet
	) {

	    if (text0) {
	        gameObject.setTitle(text0);
	    }
	    if (text1) {
	        gameObject.setText(text1);
	    }

	    gameObject.layout();
	};

	var PopUp = function (
	    gameObject,
	    {
	        text0, text1,
	        separatorDir = 'right',
	        text0Dir = 'up',
	        text1Dir = 'down',
	        separatorThenText = true,
	        duration,
	        wait = true,
	    } = {},
	    commandExecutor,
	    eventSheetManager, eventSheet
	) {

	    var separatorGameObject = gameObject.childrenMap.separator;
	    if (separatorGameObject) {
	        var origin = DirToOriginMap[separatorDir];
	        if (!origin) {
	            origin = DefaultOrigin;
	        }
	        separatorGameObject.setOrigin(origin.x, origin.y);
	    } else {
	        separatorThenText = false;
	    }

	    var text0GameObject = gameObject.childrenMap.title;
	    if (text0GameObject) {
	        var origin = DirToOriginMap[text0Dir];
	        if (!origin) {
	            origin = DefaultOrigin;
	        }
	        text0GameObject.setOrigin(origin.x, origin.y);
	    }

	    var text1GameObject = gameObject.childrenMap.text;
	    if (text1GameObject) {
	        var origin = DirToOriginMap[text1Dir];
	        if (!origin) {
	            origin = DefaultOrigin;
	        }
	        text1GameObject.setOrigin(origin.x, origin.y);
	    }

	    if (text0) {
	        gameObject.setTitle(text0);
	    }
	    if (text1) {
	        gameObject.setText(text1);
	    }

	    gameObject.layout();

	    if (duration === undefined) {
	        duration = eventSheetManager.getData('$transitionDuration');
	    }

	    var onCompleteCallback;
	    if (wait) {
	        onCompleteCallback = eventSheetManager.pauseEventSheet();
	    }

	    var delay;
	    if (separatorThenText) {
	        duration /= 2;
	        delay = duration;
	    } else {
	        delay = 0;
	    }

	    var bob = gameObject.bob;
	    if (separatorGameObject) {
	        var config = {
	            targets: separatorGameObject,
	            duration: duration,
	        };
	        SetScaleConfig(config, separatorDir);
	        bob.addTweenTask('separator.popup', config);
	    }

	    if (text0GameObject) {
	        var config = {
	            targets: text0GameObject,
	            delay: delay,
	            duration: duration,
	            onComplete: onCompleteCallback,
	        };
	        SetScaleConfig(config, text0Dir);
	        bob.addTweenTask('title.popup', config);
	    }
	    if (text1GameObject) {
	        var config = {
	            targets: text1GameObject,
	            delay: delay,
	            duration: duration,
	            onComplete: onCompleteCallback,
	        };
	        SetScaleConfig(config, text1Dir);
	        bob.addTweenTask('text.popup', config);
	    }

	};

	const DirToOriginMap = {
	    right: { x: 0, y: 0.5 },
	    left: { x: 1, y: 0.5 },
	    up: { x: 0.5, y: 1 },
	    down: { x: 0.5, y: 0 },
	};

	const DefaultOrigin = { x: 0.5, y: 0.5 };

	var SetScaleConfig = function (config, dir) {
	    switch (dir) {
	        case 'up':
	        case 'down':
	            config.scaleY = { start: 0, to: 1 };
	            break;
	        case 'left':
	        case 'right':
	            config.scaleX = { start: 0, to: 1 };
	            break;

	        default:
	            config.scaleX = { start: 0, to: 1 };
	            config.scaleY = { start: 0, to: 1 };
	            break;
	    }

	    return config;
	};

	const GetValue$k = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$7 = Phaser.Utils.Objects.IsPlainObject;

	var RegisterTitleType = function (commandExecutor, config) {
	    var { viewport } = config;
	    var createGameObjectCallback = GetValue$k(config, `creators.${TITLE}`, undefined);
	    if (createGameObjectCallback === false) {
	        return;
	    }

	    var creators;
	    if (IsPlainObject$7(createGameObjectCallback)) {
	        creators = createGameObjectCallback;
	        createGameObjectCallback = undefined;
	    }

	    if (createGameObjectCallback === undefined) {
	        var style = GetValue$k(config, `styles.${TITLE}`, {});
	        createGameObjectCallback = GenerateDefaultCreateGameObjectCallback$2(
	            style,
	            {
	                viewport
	            },
	            creators
	        );
	    }

	    commandExecutor.addGameObjectManager({
	        name: TITLE,
	        createGameObject: createGameObjectCallback,
	        fade: 0,  // No fade-in when creating/destroying gameobject
	        viewportCoordinate: { viewport },
	        defaultLayer: UILayer,

	        commands: {
	            setText: SetText$1,
	            popUp: PopUp,
	            shake: Shake,
	        }
	    });
	};

	var GetChildrenWidth$1 = function () {
	    if (this.rexSizer.hidden) {
	        return 0;
	    }

	    var result = 0;
	    var children = this.sizerChildren;
	    var child, padding, childWidth;
	    var hasUnknownChildWidth = false;

	    for (var key in children) {
	        child = children[key];

	        childWidth = this.getChildWidth(child);
	        if (childWidth === undefined) {
	            hasUnknownChildWidth = true;
	        }

	        if (hasUnknownChildWidth) {
	            continue;
	        }

	        padding = child.rexSizer.padding;
	        childWidth += (padding.left + padding.right) * this.scaleX;
	        result = Math.max(childWidth, result);
	    }

	    if (hasUnknownChildWidth) {
	        return undefined;
	    }

	    return result + ((this.space.left + this.space.right) * this.scaleX);
	};

	var GetChildrenHeight$1 = function () {
	    if (this.rexSizer.hidden) {
	        return 0;
	    }

	    var result = 0;
	    var children = this.sizerChildren;
	    var child, padding, childHeight;
	    var hasUnknownChildHeight = false;

	    for (var key in children) {
	        child = children[key];

	        childHeight = this.getChildHeight(child);
	        if (childHeight === undefined) {
	            hasUnknownChildHeight = true;
	        }

	        if (hasUnknownChildHeight) {
	            continue;
	        }

	        padding = child.rexSizer.padding;
	        childHeight += (padding.top + padding.bottom) * this.scaleY;
	        result = Math.max(childHeight, result);
	    }

	    if (hasUnknownChildHeight) {
	        return undefined;
	    }

	    return result + ((this.space.top + this.space.bottom) * this.scaleY);
	};

	var GetExpandedChildWidth$1 = function (child, parentWidth) {
	    if (parentWidth === undefined) {
	        parentWidth = this.width * this.scaleX;
	    }

	    var childWidth;
	    var childConfig = child.rexSizer;
	    if (childConfig.expandWidth) {
	        var innerWidth = parentWidth - ((this.space.left + this.space.right) * this.scaleX);
	        var padding = childConfig.padding;
	        childWidth = innerWidth - ((padding.left + padding.right) * this.scaleX);
	    }
	    return childWidth;
	};

	var GetExpandedChildHeight$1 = function (child, parentHeight) {
	    if (parentHeight === undefined) {
	        parentHeight = this.height;
	    }

	    var childHeight;
	    var childConfig = child.rexSizer;
	    if (childConfig.expandHeight) {
	        var innerHeight = parentHeight - ((this.space.top + this.space.bottom) * this.scaleY);
	        var padding = childConfig.padding;
	        childHeight = innerHeight - ((padding.top + padding.bottom) * this.scaleY);
	    }
	    return childHeight;
	};

	var GetChildrenSizers$1 = function (out) {
	    if (out === undefined) {
	        out = [];
	    }
	    var children = this.sizerChildren,
	        child;
	    for (var key in children) {
	        child = children[key];
	        if (child.isRexSizer) {
	            out.push(child);
	        }
	    }
	    return out;
	};

	var LayoutChildren$1 = function () {
	    var child, childConfig, padding;
	    var startX = this.innerLeft,
	        startY = this.innerTop;
	    var innerWidth = this.innerWidth,
	        innerHeight = this.innerHeight;
	    var x, y, width, height, alignOffsetX, alignOffsetY; // Align zone
	    var childWidth, childHeight, childSize;
	    // Layout current page
	    var children = this.sizerChildren;
	    for (var key in children) {
	        child = children[key];
	        if (child.rexSizer.hidden) {
	            continue;
	        }

	        childConfig = child.rexSizer;
	        padding = childConfig.padding;

	        PreLayoutChild.call(this, child);

	        childWidth = this.getExpandedChildWidth(child);
	        childHeight = this.getExpandedChildHeight(child);

	        if (childConfig.aspectRatio > 0) {
	            sourceSize.width = childConfig.aspectRatio;
	            sourceSize.height = 1;
	            targetSize.width = childWidth;
	            targetSize.height = childHeight;

	            childSize = FitTo(sourceSize, targetSize, 'FIT', true);

	            childWidth = childSize.width;
	            childHeight = childSize.height;
	        }

	        // Set size
	        if (child.isRexSizer) {
	            child.runLayout(this, childWidth, childHeight);
	            CheckSize(child, this);
	        } else {
	            ResizeGameObject(child, childWidth, childHeight);
	        }

	        // Set position
	        x = startX + (padding.left * this.scaleX);
	        width = innerWidth - ((padding.left + padding.right) * this.scaleX);
	        y = startY + (padding.top * this.scaleY);
	        height = innerHeight - ((padding.top + padding.bottom) * this.scaleY);

	        if (childWidth === undefined) {
	            childWidth = GetDisplayWidth(child);
	        }
	        if (childHeight === undefined) {
	            childHeight = GetDisplayHeight(child);
	        }
	        alignOffsetX = (childConfig.alignOffsetX + (childConfig.alignOffsetOriginX * childWidth)) * this.scaleX;
	        alignOffsetY = (childConfig.alignOffsetY + (childConfig.alignOffsetOriginY * childHeight)) * this.scaleY;

	        LayoutChild.call(this,
	            child, x, y, width, height, childConfig.align,
	            alignOffsetX, alignOffsetY
	        );
	    }
	};

	var sourceSize = {};
	var targetSize = {};

	const IsPlainObject$6 = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$j = Phaser.Utils.Objects.GetValue;
	const ALIGN_CENTER$1 = Phaser.Display.Align.CENTER;
	const UUID = Phaser.Utils.String.UUID;

	var Add$3 = function (gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY, aspectRatio) {
	    var offsetOriginX, offsetOriginY;

	    AddChild$2.call(this, gameObject);

	    if (IsPlainObject$6(childKey)) {
	        var config = childKey;
	        childKey = GetValue$j(config, 'key', undefined);
	        align = GetValue$j(config, 'align', ALIGN_CENTER$1);
	        padding = GetValue$j(config, 'padding', 0);
	        expand = GetValue$j(config, 'expand', true);

	        if (!gameObject.isRexSizer) {
	            // Get minWidth,minHeight from config
	            minWidth = GetValue$j(config, 'minWidth', gameObject._minWidth);
	            minHeight = GetValue$j(config, 'minHeight', gameObject._minHeighted);
	        }

	        offsetX = GetValue$j(config, 'offsetX', 0);
	        offsetY = GetValue$j(config, 'offsetY', 0);
	        offsetOriginX = GetValue$j(config, 'offsetOriginX', 0);
	        offsetOriginY = GetValue$j(config, 'offsetOriginY', 0);

	        aspectRatio = GetValue$j(config, 'aspectRatio', 0);
	    }

	    var hasValidKey = (childKey !== undefined);
	    if (!hasValidKey) {
	        childKey = UUID();
	    }

	    if (typeof (align) === 'string') {
	        align = AlignConst[align];
	    }

	    if (align === undefined) {
	        align = ALIGN_CENTER$1;
	    }
	    if (padding === undefined) {
	        padding = 0;
	    }
	    if (expand === undefined) {
	        expand = true;
	    }
	    if (!gameObject.isRexSizer) {
	        // Get minWidth,minHeight from game object
	        if (minWidth === undefined) {
	            minWidth = gameObject._minWidth;
	        }
	        if (minHeight === undefined) {
	            minHeight = gameObject._minHeight;
	        }
	    }

	    if (offsetX === undefined) {
	        offsetX = 0;
	    }
	    if (offsetY === undefined) {
	        offsetY = 0;
	    }
	    if (offsetOriginX === undefined) {
	        offsetOriginX = 0;
	    }
	    if (offsetOriginY === undefined) {
	        offsetOriginY = 0;
	    }

	    if (aspectRatio === undefined) {
	        aspectRatio = 0;
	    } else if (aspectRatio === true) {
	        aspectRatio = GetDisplayWidth(gameObject) / GetDisplayHeight(gameObject);
	    }
	    if (aspectRatio > 0) {
	        expand = true;

	        if (minWidth === undefined) {
	            minWidth = 0;
	        }
	        if (minHeight === undefined) {
	            minHeight = 0;
	        }
	    }

	    var config = this.getSizerConfig(gameObject);

	    config.align = align;

	    config.padding = GetBoundsConfig$1(padding);

	    if (IsPlainObject$6(expand)) {
	        config.expandWidth = GetValue$j(expand, 'width', false);
	        config.expandHeight = GetValue$j(expand, 'height', false);
	    } else {
	        config.expandWidth = expand;
	        config.expandHeight = expand;
	    }

	    if (!gameObject.isRexSizer) {  // Expand normal game object
	        if (config.expandWidth) {
	            // minWidth is still undefined, uses current display width
	            gameObject.minWidth = (minWidth === undefined) ? GetDisplayWidth(gameObject) : minWidth;
	        }
	        if (config.expandHeight) {
	            // minHeight is still undefined, uses current display height
	            gameObject.minHeight = (minHeight === undefined) ? GetDisplayHeight(gameObject) : minHeight;
	        }
	    }

	    config.alignOffsetX = offsetX;
	    config.alignOffsetY = offsetY;
	    config.alignOffsetOriginX = offsetOriginX;
	    config.alignOffsetOriginY = offsetOriginY;

	    config.aspectRatio = aspectRatio;

	    if (this.sizerChildren.hasOwnProperty(childKey)) {
	        this.sizerChildren[childKey].destroy();
	    }
	    this.sizerChildren[childKey] = gameObject;

	    if (hasValidKey) {
	        this.addChildrenMap(childKey, gameObject);
	    }
	    return this;
	};

	var AddChildMethods$4 = {
	    add: Add$3
	};

	var RemoveChildMethods$4 = {
	    remove(gameObject, destroyChild) {
	        var key;
	        if (typeof (gameObject) === 'string') {
	            key = gameObject;
	            gameObject = this.sizerChildren[key];
	            if (!gameObject) {
	                return this;
	            }
	        } else if (this.getParentSizer(gameObject) !== this) {
	            return this;
	        } else {
	            key = this.childToKey(gameObject);
	        }

	        if (key) {
	            delete this.sizerChildren[key];
	            if (this.childrenMap.hasOwnProperty(key)) {
	                delete this.childrenMap[key];
	            }
	        }
	        RemoveChild$1.call(this, gameObject, destroyChild);
	        return this;
	    },

	    removeAll(destroyChild) {
	        for (var key in this.sizerChildren) {
	            this.remove(key, destroyChild);
	        }
	        return this;
	    },

	    clear(destroyChild) {
	        for (var key in this.sizerChildren) {
	            delete this.sizerChildren[key];
	            if (this.childrenMap.hasOwnProperty(key)) {
	                delete this.childrenMap[key];
	            }
	        }
	        ClearChildren.call(this, destroyChild);
	        return this;
	    }
	};

	var methods$3 = {
	    getChildrenWidth: GetChildrenWidth$1,
	    getChildrenHeight: GetChildrenHeight$1,
	    getExpandedChildWidth: GetExpandedChildWidth$1,
	    getExpandedChildHeight: GetExpandedChildHeight$1,
	    getChildrenSizers: GetChildrenSizers$1,
	    layoutChildren: LayoutChildren$1,
	};

	Object.assign(
	    methods$3,
	    AddChildMethods$4,
	    RemoveChildMethods$4
	);

	var IndexOf = function (obj, child) {
	    if (Array.isArray(obj)) {
	        return obj.indexOf(child);
	    } else {
	        for (var key in obj) {
	            if (obj[key] === child) {
	                return key;
	            }
	        }
	        return null;
	    }
	};

	const IsPlainObject$5 = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$i = Phaser.Utils.Objects.GetValue;

	class OverlapSizer extends Base$2 {
	    constructor(scene, x, y, minWidth, minHeight, config) {
	        if (IsPlainObject$5(x)) {
	            config = x;
	            x = GetValue$i(config, 'x', 0);
	            y = GetValue$i(config, 'y', 0);
	            minWidth = GetValue$i(config, 'width', undefined);
	            minHeight = GetValue$i(config, 'height', undefined);
	        } else if (IsPlainObject$5(minWidth)) {
	            config = minWidth;
	            minWidth = GetValue$i(config, 'width', undefined);
	            minHeight = GetValue$i(config, 'height', undefined);
	        }

	        super(scene, x, y, minWidth, minHeight, config);

	        this.type = 'rexOverlapSizer';
	        this.sizerChildren = {};

	        this.addChildrenMap('items', this.sizerChildren);
	    }

	    childToKey(gameObject) {
	        if (typeof (gameObject) === 'string') {
	            var key = gameObject;
	            if (this.sizerChildren.hasOwnPropery(key)) {
	                return key;
	            }
	        } else {
	            return IndexOf(this.sizerChildren, gameObject);
	        }
	        return null;
	    }
	}

	Object.assign(
	    OverlapSizer.prototype,
	    methods$3
	);

	const SizerAdd$2 = Sizer.prototype.add;
	const SizerAddSpace = Sizer.prototype.addSpace;

	var Add$2 = function (gameObject) {
	    var isNormalGameObject = !gameObject.isRexSpace;
	    var proportion = (!isNormalGameObject || this.buttonsExpand) ? 1 : 0;

	    if (this.sizerChildren.length === 0) {  // First element
	        if (isNormalGameObject) {
	            // Add space at head
	            var hasHeadSpace = (!this.buttonsExpand) &&
	                ((this.buttonsAlign === 'right') || (this.buttonsAlign === 'center') || (this.buttonsAlign === 'bottom'));
	            if (hasHeadSpace) {
	                SizerAddSpace.call(this);
	            }

	            SizerAdd$2.call(this,
	                gameObject,
	                { proportion: proportion, expand: true }
	            );

	            // Add space at tail
	            var hasTailSpace = (!this.buttonsExpand) && (this.buttonsAlign === 'center');
	            if (hasTailSpace) {
	                SizerAddSpace.call(this);
	            }
	            this.hasTailSpace = hasTailSpace;

	        } else { // A space
	            SizerAdd$2.call(this,
	                gameObject,
	                { proportion: proportion, expand: true }
	            );
	            this.hasTailSpace = false;

	        }

	    } else {   // Others
	        if (this.hasTailSpace) {
	            var lastIndex = this.sizerChildren.length - 1;
	            SizerAdd$2.call(this,
	                gameObject,
	                { index: lastIndex, proportion: proportion, expand: true }
	            );

	        } else {
	            SizerAdd$2.call(this,
	                gameObject,
	                { proportion: proportion, expand: true }
	            );
	        }

	    }

	    // Space or other game object as button
	    if (isNormalGameObject) {
	        this.buttonGroup.add(gameObject);
	    }

	    return this;
	};

	var AddChildMethods$3 = {
	    addButton(gameObject) {
	        if (IsArray(gameObject)) {
	            var gameObjects = gameObject;
	            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	                Add$2.call(this, gameObjects[i]);
	            }
	        } else {
	            Add$2.call(this, gameObject);
	        }
	        return this;
	    },

	    addButtons(gameObjects) {
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            Add$2.call(this, gameObjects[i]);
	        }
	        return this;
	    }
	};

	const SizerRmove$2 = Sizer.prototype.remove;
	const SizerClear$2 = Sizer.prototype.clear;

	var Remove$2 = function (gameObject, destroyChild) {
	    if (this.getParentSizer(gameObject) !== this) {
	        return this;
	    }

	    this.buttonGroup.remove(gameObject);
	    SizerRmove$2.call(this, gameObject, destroyChild);
	    return this;
	};

	var RemoveChildMethods$3 = {
	    remove(gameObject, destroyChild) {
	        // Remove gameObject no matter it is a button or not
	        if (IsArray(gameObject)) {
	            var gameObjects = gameObject;
	            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	                Remove$2.call(this, gameObjects[i], destroyChild);
	            }
	        } else {
	            Remove$2.call(this, gameObject, destroyChild);
	        }
	        return this;
	    },

	    clear(destroyChild) {
	        var buttons = this.buttonGroup.buttons;
	        buttons.length = 0;
	        SizerClear$2.call(this, destroyChild);
	        return this;
	    },

	    removeButton(gameObject, destroyChild) {
	        var gameObject = this.getButton(gameObject);
	        // Don't remove this gameObject, it is not a button
	        if (!gameObject) {
	            return this;
	        }
	        this.remove(gameObject, destroyChild);
	        return this;
	    },

	    clearButtons(destroyChild) {
	        var buttons = this.buttonGroup.buttons;
	        for (var i = buttons.length - 1; i >= 0; i--) {
	            Remove$2.call(this, buttons[i], destroyChild);
	        }
	        return this;
	    }
	};

	var OnButtonStateChange = function (button, value, previousValue) {
	    if (!button) {
	        return;
	    }

	    var callback = this.setValueCallback;
	    var scope = this.setValueCallbackScope;
	    if (callback) {
	        if (scope) {
	            callback.call(scope, button, value, previousValue);
	        } else {
	            callback(button, value, previousValue);
	        }
	    }

	    this.fireEvent('button.statechange', button, value, previousValue);
	};

	var InjectSelectedProperty = function (gameObject) {
	    var self = this;

	    gameObject._selected = undefined;
	    Object.defineProperty(gameObject, 'selected', {
	        get: function () {
	            return gameObject._selected;
	        },
	        set: function (newValue) {
	            if (gameObject._selected === newValue) {
	                return;
	            }
	            var previousValue = gameObject._selected;
	            gameObject._selected = newValue;

	            OnButtonStateChange.call(self, gameObject, newValue, previousValue);
	        },
	        enumerable: true,
	        configurable: true
	    });

	    gameObject.selected = false;
	};

	var AddMethods = {
	    add(gameObject) {
	        this.buttons.push(gameObject);

	        //Default: Fire 'click' event when touch released after pressed.
	        if (!gameObject._click) {
	            gameObject._click = new Button(gameObject, this.clickConfig);

	            gameObject._click
	                .on('click', function (buttonBehavior, gameObject, pointer, event) {
	                    this.fireEvent('button.click', gameObject, pointer, event);
	                }, this)
	                .on('enable', function (buttonBehavior, gameObject) {
	                    this.fireEvent('button.enable', gameObject);
	                }, this)
	                .on('disable', function (buttonBehavior, gameObject) {
	                    this.fireEvent('button.disable', gameObject);
	                }, this)


	                .on('over', function (buttonBehavior, gameObject, pointer, event) {
	                    this.fireEvent('button.over', gameObject, pointer, event);
	                }, this)
	                .on('out', function (buttonBehavior, gameObject, pointer, event) {
	                    this.fireEvent('button.out', gameObject, pointer, event);
	                }, this)

	                .on('down', function (buttonBehavior, gameObject, pointer, event) {
	                    this.fireEvent('button.down', gameObject, pointer, event);
	                }, this)
	                .on('up', function (buttonBehavior, gameObject, pointer, event) {
	                    this.fireEvent('button.up', gameObject, pointer, event);
	                }, this);

	            if (gameObject.isRexContainerLite) {
	                // Send touch detection sensor to back
	                gameObject.sendChildToBack(gameObject);
	            }
	        }

	        if (this.buttonsType) {
	            if (gameObject.name === undefined) {
	                console.error(`${this.parent.constructor.name}: Option button miss value`);
	            }

	            InjectSelectedProperty.call(this, gameObject);
	        }


	        return this;
	    },

	    addMultiple(gameObjects) {
	        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	            this.add(gameObjects[i]);
	        }
	        return this;
	    }
	};

	const RemoveItem$2 = Phaser.Utils.Array.Remove;

	var RemoveMethods = {
	    remove(gameObject) {
	        if (this.buttonsType) {
	            delete gameObject.selected;
	        }

	        RemoveItem$2(this.buttons, gameObject);

	        return this;
	    },

	    clear() {
	        if (this.buttonsType) {
	            var buttons = this.buttons;
	            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	                delete buttons[i].selected;
	            }
	        }

	        this.buttons.length = 0;

	        return this;
	    }
	};

	var FireEvent = function (eventName, button, ...args) {
	    if(!this.buttons) {
	        // ButtonGroup has been destroyed
	        return;
	    }

	    var index;
	    if (typeof (button) === 'number') {
	        index = button;
	        button = this.buttons[index];
	        if (!button) {
	            return;
	        }
	    } else {
	        index = this.buttons.indexOf(button);
	        if (index === -1) {
	            return;
	        }
	    }

	    // Buttons is a child. Fire internal events.
	    if (this.eventEmitter !== this.parent) {
	        this.parent.emit(eventName, button, index, ...args);
	    }

	    if (this.groupName !== undefined) {
	        this.eventEmitter.emit(eventName, button, this.groupName, index, ...args);
	    } else {
	        this.eventEmitter.emit(eventName, button, index, ...args);
	    }
	};

	const GetValue$h = Phaser.Utils.Objects.GetValue;

	var ButtonsTypeMethods = {
	    setButtonsType(config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var buttonsType = GetValue$h(config, 'buttonsType', config.type);
	        this.buttonsType = buttonsType;

	        if (!this.buttonsType) {
	            return this;
	        }

	        // Assign this.setValueCallback, this.setValueCallbackScope
	        var setValueCallback, setValueCallbackScope;
	        setValueCallback = GetValue$h(config, 'setValueCallback', undefined);
	        setValueCallbackScope = GetValue$h(config, 'setValueCallbackScope', undefined);
	        if (setValueCallback === undefined) {
	            setValueCallback = GetValue$h(config, 'setButtonStateCallback', undefined);
	            setValueCallbackScope = GetValue$h(config, 'setButtonStateCallbackScope', undefined);
	        }
	        this.setValueCallback = setValueCallback;
	        this.setValueCallbackScope = setValueCallbackScope;

	        switch (buttonsType) {
	            case 'radio':
	                this.setRadioType();
	                break;
	            case 'checkboxes':
	                this.setCheckboxesType();
	                break;
	        }

	        return this;
	    },

	    setRadioType() {
	        var parent = this.parent,
	            buttons = this.buttons;
	        parent._value = undefined;
	        var selectedIndex = undefined;
	        Object.defineProperty(parent, 'value', {
	            get: function () {
	                return parent._value;
	            },
	            set: function (newValue) {
	                if (parent._value === newValue) {
	                    return;
	                }

	                parent._value = newValue;

	                for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	                    var button = buttons[i];
	                    if (button.rexSizer.hidden) {
	                        continue;
	                    }

	                    if (selectedIndex === undefined) {
	                        if (button.name === newValue) {
	                            button.selected = true;
	                        } else {
	                            button.selected = false;
	                        }
	                    } else {
	                        if (selectedIndex === i) {
	                            button.selected = true;
	                        } else {
	                            button.selected = false;
	                        }
	                    }
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });

	        parent.on('button.click', function (button) {
	            selectedIndex = this.buttons.indexOf(button);
	            parent.value = button.name;
	            selectedIndex = undefined;
	        }, this);

	        return this;
	    },

	    setCheckboxesType() {
	        var parent = this.parent;
	        parent.on('button.click', function (button) {
	            button.selected = !button.selected;
	        });

	        return this;
	    },

	    // Common
	    clearAllButtonsState() {
	        var buttons = this.buttons;
	        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	            var button = buttons[i];
	            button.selected = false;
	        }
	        return this;
	    },

	    getAllButtonsState() {
	        var states = {};
	        var buttons = this.buttons;
	        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	            var button = buttons[i];
	            if (button.rexSizer.hidden) {
	                continue;
	            }
	            states[button.name] = button.selected;
	        }
	        return states;
	    },

	    // For radio
	    setSelectedButtonName(name) {
	        this.parent.value = name;
	        return this;
	    },

	    getSelectedButtonName() {
	        return this.parent.value;
	    },

	    // For checkboxes
	    setButtonState(name, state) {
	        if (state === undefined) {
	            state = true;
	        }

	        var buttons = this.buttons;
	        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	            var button = buttons[i];
	            if (button.rexSizer.hidden) {
	                continue;
	            }
	            if (button.name === name) {
	                button.selected = state;
	                break;
	            }
	        }
	        return this;
	    },

	    getButtonState(name) {
	        var buttons = this.buttons;
	        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	            var button = buttons[i];
	            if (button.rexSizer.hidden) {
	                continue;
	            }
	            if (button.name === name) {
	                return button.selected;
	            }
	        }
	        return undefined;
	    }
	};

	var GetGameObjectByName = function (children, name) {
	    if (!children) {
	        return null;

	    } else if (IsArray(children)) {
	        var child;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = TestName(children[i], name);
	            if (child) {
	                return child;
	            }
	        }

	    } else { // Is plain object
	        var child;
	        for (var key in children) {
	            child = TestName(children[key], name);
	            if (child) {
	                return child;
	            }
	        }

	    }
	};

	var TestName = function (gameObject, name) {
	    if (!gameObject) {
	        return null;
	    } else if (gameObject.hasOwnProperty('name')) {
	        return (gameObject.name === name) ? gameObject : null;
	    } else { // Array, or plain object
	        return GetElementByName(gameObject, name);
	    }
	};

	// Include in ButtonGroup class and Buttons/GridButtons/FixedWidthButtons class


	var ButtonMethods$1 = {
	    getButton(index) {
	        // buttonGroup and button-sizer have *buttons* member both
	        var buttons = this.buttons,
	            button;
	        var indexType = typeof (index);
	        switch (indexType) {
	            case 'number':
	                button = buttons[index];
	                break;
	            case 'string':
	                button = GetGameObjectByName(buttons, index);
	                break;
	            default:
	                button = index;
	                if (buttons.indexOf(button) === -1) {
	                    button = undefined;
	                }
	                break;
	        }
	        return button;
	    },

	    getButtons() {
	        return this.buttons;
	    },

	    hasAnyButton() {
	        return this.buttons.length > 0;
	    },

	    setButtonEnable(index, enabled) {
	        // buttonGroup and button-sizer have *buttons* member both
	        var buttons = this.buttons;
	        if ((index === undefined) || (typeof (index) === 'boolean')) {
	            enabled = index;
	            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	                buttons[i]._click.setEnable(enabled);
	            }
	        } else {
	            this.getButton(index)._click.setEnable(enabled);
	        }
	        return this;
	    },

	    toggleButtonEnable(index) {
	        // buttonGroup and button-sizer have *buttons* member both
	        var buttons = this.buttons;
	        if ((index === undefined) || (typeof (index) === 'boolean')) {
	            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	                buttons[i]._click.toggleEnable();
	            }
	        } else {
	            this.getButton(index)._click.toggleEnable();
	        }
	        return this;
	    },

	    getButtonEnable(index) {
	        if (index === undefined) {
	            index = 0;
	        }
	        return this.getButton(index)._click.enable;
	    },

	    emitButtonClick(index) {
	        // index or button game object
	        // this: buttonGroup or button-sizer
	        var buttonGroup = (this.buttonGroup) ? this.buttonGroup : this;
	        buttonGroup.fireEvent('button.click', index);
	        return this;
	    },

	    emitButtonOver(index) {
	        // this: buttonGroup or button-sizer
	        var buttonGroup = (this.buttonGroup) ? this.buttonGroup : this;

	        var buttons = this.buttons;

	        // Fire 'button.out' of overed button(s)
	        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	            var button = buttons[i];
	            if (!button._click.isOver) {
	                continue;
	            }
	            button._click.isOver = false;
	            buttonGroup.fireEvent('button.out', button);
	        }

	        // Fire 'button.over'
	        var button = this.getButton(index);
	        if (button) {
	            button._click.isOver = true;
	            buttonGroup.fireEvent('button.over', button);
	        }

	        return this;
	    },

	    showButton(index) {
	        Show(this.getButton(index));
	        return this;
	    },

	    hideButton(index) {
	        Hide(this.getButton(index));
	        return this;
	    },

	    isButtonShown(index) {
	        IsShown(this.getButton(index));
	        return this;
	    },

	    forEachButtton(callback, scope) {
	        // buttonGroup and button-sizer have *buttons* member both
	        var buttons = this.buttons;
	        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	            if (scope) {
	                callback.call(scope, buttons[i], i, buttons);
	            } else {
	                callback(buttons[i], i, buttons);
	            }
	        }
	        return this;
	    },


	};

	class ButtonGroup {
	    constructor(config) {
	        this.parent = config.parent;
	        this.eventEmitter = config.eventEmitter;
	        this.groupName = config.groupName;
	        this.clickConfig = config.clickConfig;

	        this.buttonsType = undefined;
	        this.buttons = [];
	    }

	    destroy() {
	        this.parent = undefined;
	        this.eventEmitter = undefined;
	        this.clickConfig = undefined;
	        this.buttons = undefined; // GameObjects will be destroyed outside
	    }
	}

	var methods$2 = {
	    fireEvent: FireEvent
	};

	Object.assign(
	    ButtonGroup.prototype,
	    AddMethods,
	    RemoveMethods,
	    ButtonsTypeMethods,
	    ButtonMethods$1,
	    methods$2
	);

	// Include in Buttons/GridButtons/FixedWidthButtons class

	var ButtonStateMethods = {
	    // Common
	    clearAllButtonsState() {
	        this.buttonGroup.clearAllButtonsState();
	        return this;
	    },

	    getAllButtonsState() {
	        return this.buttonGroup.getAllButtonsState();
	    },

	    // For radio
	    setSelectedButtonName(name) {
	        this.buttonGroup.setSelectedButtonName(name);
	        return this;
	    },

	    getSelectedButtonName() {
	        return this.buttonGroup.getSelectedButtonName();
	    },

	    // For checkboxes
	    setButtonState(name, state) {
	        this.buttonGroup.setButtonState(name, state);
	        return this;
	    },

	    getButtonState(name) {
	        return this.buttonGroup.getButtonState(name);
	    }
	};

	const GetValue$g = Phaser.Utils.Objects.GetValue;

	let Buttons$1 = class Buttons extends Sizer {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var buttonSpace = config.space;
	        if (typeof (buttonSpace) === 'number') {
	            config.space = { item: buttonSpace };
	        }

	        // Create
	        super(scene, config);
	        this.type = 'rexButtons';
	        this.buttonGroup = new ButtonGroup({
	            parent: this,
	            eventEmitter: GetValue$g(config, 'eventEmitter', this),
	            groupName: GetValue$g(config, 'groupName', undefined),
	            clickConfig: GetValue$g(config, 'click', undefined)
	        })
	            .setButtonsType(config);

	        // Add elements
	        var background = GetValue$g(config, 'background', undefined);
	        var buttons = GetValue$g(config, 'buttons', undefined);

	        // Buttons properties
	        this.buttonsExpand = GetValue$g(config, 'expand', false);
	        this.buttonsAlign = GetValue$g(config, 'align', undefined); // undefined/left/top: no space                

	        if (background) {
	            this.addBackground(background);
	        }

	        if (buttons) {
	            this.addButtons(buttons);
	        }

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('buttons', this.buttonGroup.buttons);
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        super.destroy(fromScene);
	        this.buttonGroup.destroy();
	        this.buttonGroup = undefined;
	    }

	    get buttons() {
	        return this.buttonGroup.buttons;
	    }

	    get groupName() {
	        return this.buttonGroup.groupName;
	    }

	    set groupName(value) {
	        this.buttonGroup.groupName = value;
	    }

	    get eventEmitter() {
	        return this.buttonGroup.eventEmitter;
	    }
	};

	Object.assign(
	    Buttons$1.prototype,
	    AddChildMethods$3,
	    RemoveChildMethods$3,
	    ButtonMethods$1,
	    ButtonStateMethods
	);

	var GetChildrenWidth = function (minimumMode) {
	    if (this.rexSizer.hidden) {
	        return 0;
	    }

	    if (minimumMode === undefined) {
	        minimumMode = true;
	    }

	    var childrenWidth;
	    if (this.orientation === 0) {
	        if (minimumMode) {
	            childrenWidth = this.maxChildWidth;
	        } else {
	            childrenWidth = (this.rexSizer.resolved) ? this.wrapResult.width : undefined;
	        }
	    } else {
	        childrenWidth = (this.rexSizer.resolved) ? this.wrapResult.width : undefined;
	    }

	    if (childrenWidth === undefined) {
	        return undefined;
	    }

	    return childrenWidth + ((this.space.left + this.space.right) * this.scaleX);
	};

	var GetChildrenHeight = function (minimumMode) {
	    if (this.rexSizer.hidden) {
	        return 0;
	    }

	    if (minimumMode === undefined) {
	        minimumMode = true;
	    }

	    var childrenHeight;
	    if (this.orientation === 1) {
	        if (minimumMode) {
	            childrenHeight = this.maxChildHeight;
	        } else {
	            childrenHeight = (this.rexSizer.resolved) ? this.wrapResult.height : undefined;
	        }
	    } else {
	        childrenHeight = (this.rexSizer.resolved) ? this.wrapResult.height : undefined;
	    }

	    if (childrenHeight === undefined) {
	        return undefined;
	    }

	    return childrenHeight + ((this.space.top + this.space.bottom) * this.scaleY);
	};

	var GetChildrenSizers = function (out) {
	    if (out === undefined) {
	        out = [];
	    }
	    var children = this.sizerChildren, child;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        if (child === '\n') {
	            continue;
	        }
	        if (child.isRexSizer) {
	            out.push(child);
	        }
	    }
	    return out;
	};

	var PreLayout = function () {
	    this._maxChildWidth = undefined;
	    this._maxChildHeight = undefined;
	    this.wrapResult = undefined;
	    this.rexSizer.resolved = false;
	    PreLayout$4.call(this);
	    return this;
	};

	var LayoutChildren = function () {
	    var horizontalWrap = (this.orientation === 0);

	    var innerLineWidth = (horizontalWrap) ? this.innerWidth : this.innerHeight;
	    var child, childConfig, padding, justifySpace = 0, indentLeft, indentTop;
	    var startX = this.innerLeft,
	        startY = this.innerTop;
	    var x, y, width, height, alignOffsetX, alignOffsetY; // Align zone
	    var lines = this.wrapResult.lines;  // Get this.wrapResult from RunChildrenWrap()
	    var line, lineChlidren, remainderLineWidth;

	    var itemX = startX,
	        itemY = startY;
	    for (var i = 0, icnt = lines.length; i < icnt; i++) {
	        // Layout this line
	        line = lines[i];
	        lineChlidren = line.children;
	        if (this.rtl) {
	            lineChlidren.reverse();
	        }

	        if (horizontalWrap) {
	            indentLeft = (i % 2) ? this.space.indentLeftEven : this.space.indentLeftOdd;
	            itemX = startX + (indentLeft * this.scaleX);
	        } else {
	            indentTop = (i % 2) ? this.space.indentTopEven : this.space.indentTopOdd;
	            itemY = startY + (indentTop * this.scaleY);
	        }

	        remainderLineWidth = innerLineWidth - ((horizontalWrap) ? line.width : line.height);

	        switch (this.align) {
	            case 0: // left
	                break;

	            case 1: // right
	                if (horizontalWrap) {
	                    itemX += remainderLineWidth;
	                } else {
	                    itemY += remainderLineWidth;
	                }
	                break;

	            case 2: // center
	                if (horizontalWrap) {
	                    itemX += remainderLineWidth / 2;
	                } else {
	                    itemY += remainderLineWidth / 2;
	                }
	                break;

	            case 3: // justify-left            
	                justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
	                break;

	            case 4: // justify-right
	                justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
	                if (justifySpace === 0) {
	                    // Align right
	                    if (horizontalWrap) {
	                        itemX += remainderLineWidth;
	                    } else {
	                        itemY += remainderLineWidth;
	                    }
	                }
	                break;

	            case 5: // justify-center
	                justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
	                if (justifySpace === 0) {
	                    // Align center
	                    if (horizontalWrap) {
	                        itemX += remainderLineWidth / 2;
	                    } else {
	                        itemY += remainderLineWidth / 2;
	                    }
	                }
	                break;
	        }

	        var isFirstChild = true;
	        for (var j = 0, jcnt = lineChlidren.length; j < jcnt; j++) {
	            child = lineChlidren[j];
	            if (child.rexSizer.hidden) {
	                continue;
	            }

	            childConfig = child.rexSizer;
	            padding = childConfig.padding;

	            PreLayoutChild.call(this, child);

	            if (horizontalWrap) {
	                x = itemX + (padding.left * this.scaleX);
	            } else {
	                y = itemY + (padding.top * this.scaleY);
	            }

	            if (isFirstChild) {
	                isFirstChild = false;
	            } else {
	                if (horizontalWrap) {
	                    x += (this.space.item * this.scaleX);
	                } else {
	                    y += (this.space.item * this.scaleY);
	                }
	            }

	            width = GetDisplayWidth(child);
	            height = GetDisplayHeight(child);

	            if (horizontalWrap) {
	                indentTop = (j % 2) ? this.space.indentTopEven : this.space.indentTopOdd;
	                y = itemY + (indentTop * this.scaleY) + (padding.top * this.scaleY);
	                itemX = x + width + (padding.right * this.scaleX) + justifySpace;
	            } else {
	                indentLeft = (j % 2) ? this.space.indentLeftEven : this.space.indentLeftOdd;
	                x = itemX + (indentLeft * this.scaleX) + (padding.left * this.scaleX);
	                itemY = y + height + (padding.top * this.scaleY) + justifySpace;
	            }

	            alignOffsetX = (childConfig.alignOffsetX + (childConfig.alignOffsetOriginX * width)) * this.scaleX;
	            alignOffsetY = (childConfig.alignOffsetY + (childConfig.alignOffsetOriginY * height)) * this.scaleY;

	            LayoutChild.call(this,
	                child, x, y, width, height, childConfig.align,
	                alignOffsetX, alignOffsetY
	            );
	        }

	        if (horizontalWrap) {
	            itemY += line.height + (this.space.line * this.scaleY);
	        } else {
	            itemX += line.width + (this.space.line * this.scaleX);
	        }
	    }
	};

	var GetJustifySpace = function (total, remainder, justifyPercentage, childCount) {
	    return ((remainder / total) <= justifyPercentage) ? (remainder / (childCount - 1)) : 0;
	};

	var HasWidthWrap = function () {
	    if (this.orientation === 0) {
	        return true;
	    }

	    return HasWidthWrap$2.call(this);
	};

	var RunChildrenWrap = function (lineWidth) {
	    var out = {
	        lines: [],
	        width: 0,
	        height: 0
	    };

	    var children = this.sizerChildren;
	    var child, padding, childWidth, childHeight, remainder = 0, indentLeft, indentTop;
	    var lines = out.lines,
	        lastLine = undefined,
	        newLine;

	    if (this.orientation === 0) { // x
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = children[i];
	            if (child === '\n') {
	                child = undefined;
	                childWidth = 0;
	                newLine = true;
	            } else {
	                if (child.rexSizer.hidden) {
	                    continue;
	                }

	                if (child.isRexSizer) {
	                    child.runLayout(this);
	                }

	                childWidth = this.getChildWidth(child);
	                padding = child.rexSizer.padding;
	                childWidth += ((padding.left + padding.right) * this.scaleX);

	                newLine = (remainder < childWidth) || (lastLine === undefined);
	            }
	            // New line
	            if (newLine) {
	                if (lastLine) {
	                    lastLine.width = lineWidth - (remainder + (this.space.item * this.scaleX));
	                    out.width = Math.max(out.width, lastLine.width);
	                    out.height += lastLine.height + (this.space.line * this.scaleY);
	                }

	                lastLine = {
	                    children: [],
	                    width: 0,
	                    height: 0
	                };
	                lines.push(lastLine);

	                indentLeft = (lines.length % 2) ? this.space.indentLeftOdd : this.space.indentLeftEven;
	                remainder = lineWidth - (indentLeft * this.scaleX);
	            }

	            remainder -= childWidth + (this.space.item * this.scaleX);
	            if (child) {
	                lastLine.children.push(child);

	                childHeight = this.getChildHeight(child);
	                padding = child.rexSizer.padding;
	                childHeight += (padding.top + padding.bottom) * this.scaleY;

	                lastLine.height = Math.max(lastLine.height, childHeight);
	            }
	        }

	        if (lastLine) {
	            lastLine.width = lineWidth - (remainder + (this.space.item * this.scaleX));
	            out.width = Math.max(out.width, lastLine.width);
	            out.height += lastLine.height;
	        }

	        out.height += Math.max(this.space.indentTopOdd, this.space.indentTopEven) * this.scaleY;
	    } else {

	        var lineHeight = lineWidth;
	        for (var i = 0, cnt = children.length; i < cnt; i++) {
	            child = children[i];
	            if (child === '\n') {
	                child = undefined;
	                childWidth = 0;
	                newLine = true;
	            } else {
	                if (child.rexSizer.hidden) {
	                    continue;
	                }

	                if (child.isRexSizer) {
	                    child.layout(); // Use original size
	                }

	                childHeight = this.getChildHeight(child);
	                padding = child.rexSizer.padding;
	                childHeight += (padding.top + padding.bottom) * this.scaleY;

	                newLine = (remainder < childHeight) || (lastLine === undefined);
	            }
	            // New line
	            if (newLine) {
	                if (lastLine) {
	                    lastLine.height = lineHeight - (remainder + (this.space.item * this.scaleY));
	                    out.height = Math.max(out.height, lastLine.height);
	                    out.width += lastLine.width + (this.space.line * this.scaleX);
	                }

	                lastLine = {
	                    children: [],
	                    width: 0,
	                    height: 0
	                };
	                lines.push(lastLine);

	                indentTop = (lines.length % 2) ? this.space.indentTopOdd : this.space.indentTopEven;
	                remainder = lineHeight - (indentTop * this.scaleY);
	            }

	            remainder -= childHeight + (this.space.item * this.scaleY);
	            if (child) {
	                lastLine.children.push(child);

	                childWidth = this.getChildWidth(child);
	                padding = child.rexSizer.padding;
	                childWidth += (padding.left + padding.right) * this.scaleX;

	                lastLine.width = Math.max(lastLine.width, childWidth);
	            }
	        }

	        if (lastLine) {
	            lastLine.height = lineHeight - (remainder + (this.space.item * this.scaleY));
	            out.height = Math.max(out.height, lastLine.height);
	            out.width += lastLine.width;
	        }

	        out.width += Math.max(this.space.indentLeftOdd, this.space.indentLeftEven) * this.scaleX;
	    }

	    return out;
	};

	var RunWidthWrap = function (width) {
	    if (this.wrapResult) {
	        // Already got wrapResult
	        return;
	    }

	    if (this.orientation === 0) {
	        var innerWidth = width - ((this.space.left + this.space.right) * this.scaleX);
	        this.wrapResult = RunChildrenWrap.call(this, innerWidth);
	        this.rexSizer.resolved = true;
	        RunWidthWrap$3.call(this, width);
	    }
	};

	var HasHeightWrap = function () {
	    if (this.orientation === 1) {
	        return true;
	    }

	    return HasHeightWrap$2.call(this);
	};

	var RunHeightWrap = function (height) {
	    if (this.wrapResult) {
	        // Already got wrapResult
	        return;
	    }

	    if (this.orientation === 1) {
	        var innerHeight = height - ((this.space.top + this.space.bottom) * this.scaleY);
	        this.wrapResult = RunChildrenWrap.call(this, innerHeight);
	        this.rexSizer.resolved = true;
	        RunHeightWrap$3.call(this, height);
	    }
	};

	// Override
	var GetExpandedChildWidth = function (child, parentWidth) {
	    return undefined;
	};

	// Override
	var GetExpandedChildHeight = function (child, parentHeight) {
	    return undefined;
	};

	const DistanceBetween = Phaser.Math.Distance.Between;

	var GetNearestChildIndex = function (x, y) {
	    var children = this.sizerChildren;
	    if (children.length === 0) {
	        return -1;
	    }

	    var nearestIndex = -1,
	        minDistance = Infinity;
	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        var child = children[i];
	        // position is not at this line
	        if (Math.abs(child.centerY - y) > (child.height / 2)) {
	            continue;
	        }

	        // Check left bound
	        var distance = DistanceBetween(child.left, child.centerY, x, y);
	        if (minDistance > distance) {
	            minDistance = distance;
	            nearestIndex = i;
	        }

	        // Is last child of this line
	        var nextChild = children[i + 1];
	        if (nextChild && (nextChild.y === child.y)) {
	            continue;
	        }

	        var distance = DistanceBetween(child.right, child.centerY, x, y);
	        if (minDistance > distance) {
	            minDistance = distance;
	            nearestIndex = i + 1;
	        }
	    }

	    return nearestIndex;
	};

	const IsPlainObject$4 = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$f = Phaser.Utils.Objects.GetValue;
	const ALIGN_CENTER = Phaser.Display.Align.CENTER;

	var Add$1 = function (gameObject, paddingConfig, childKey, index) {
	    if (gameObject === '\n') {
	        this.addNewLine();
	        return this;
	    }

	    var offsetX, offsetY;
	    var offsetOriginX, offsetOriginY;

	    AddChild$2.call(this, gameObject);

	    if (IsPlainObject$4(paddingConfig)) {
	        var config = paddingConfig;
	        paddingConfig = GetValue$f(config, 'padding', 0);
	        childKey = GetValue$f(config, 'key', undefined);
	        index = GetValue$f(config, 'index', undefined);

	        offsetX = GetValue$f(config, 'offsetX', 0);
	        offsetY = GetValue$f(config, 'offsetY', 0);
	        offsetOriginX = GetValue$f(config, 'offsetOriginX', 0);
	        offsetOriginY = GetValue$f(config, 'offsetOriginY', 0);
	    }
	    if (paddingConfig === undefined) {
	        paddingConfig = 0;
	    }

	    if (offsetX === undefined) {
	        offsetX = 0;
	    }
	    if (offsetY === undefined) {
	        offsetY = 0;
	    }
	    if (offsetOriginX === undefined) {
	        offsetOriginX = 0;
	    }
	    if (offsetOriginY === undefined) {
	        offsetOriginY = 0;
	    }

	    var config = this.getSizerConfig(gameObject);
	    config.align = ALIGN_CENTER;
	    config.padding = GetBoundsConfig$1(paddingConfig);
	    config.alignOffsetX = offsetX;
	    config.alignOffsetY = offsetY;
	    config.alignOffsetOriginX = offsetOriginX;
	    config.alignOffsetOriginY = offsetOriginY;

	    if ((index === undefined) || (index >= this.sizerChildren.length)) {
	        this.sizerChildren.push(gameObject);
	    } else {
	        this.sizerChildren.splice(index, 0, gameObject);
	    }

	    if (childKey !== undefined) {
	        this.addChildrenMap(childKey, gameObject);
	    }
	    return this;
	};

	var AddChildMethods$2 = {
	    add(gameObject, paddingConfig, childKey) {
	        if (IsArray(gameObject)) {
	            var gameObjects = gameObject;
	            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	                Add$1.call(this, gameObjects[i], paddingConfig);
	            }
	        } else {
	            Add$1.call(this, gameObject, paddingConfig, childKey);
	        }
	        return this;
	    },

	    addNewLine() {
	        this.sizerChildren.push('\n');
	        return this;
	    },

	    insert(index, gameObject, paddingConfig, childKey) {
	        Add$1.call(this, gameObject, paddingConfig, childKey, index);
	        return this;
	    },

	    insertAtPosition(x, y, gameObject, paddingConfig, childKey) {
	        var index = GetNearestChildIndex.call(this, x, y);
	        if (index === -1) {
	            index = undefined;
	        }
	        this.insert(index, gameObject, paddingConfig, childKey);
	        return this;
	    }
	};

	const RemoveItem$1 = Phaser.Utils.Array.Remove;

	var RemoveChildMethods$2 = {
	    remove(gameObject, destroyChild) {
	        if (this.getParentSizer(gameObject) !== this) {
	            return this;
	        }
	        RemoveItem$1(this.sizerChildren, gameObject);
	        RemoveChild$1.call(this, gameObject, destroyChild);
	        return this;
	    },

	    removeAll(destroyChild) {
	        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
	            this.remove(this.sizerChildren[i], destroyChild);
	        }
	        return this;
	    },

	    clear(destroyChild) {
	        this.sizerChildren.length = 0;
	        ClearChildren.call(this, destroyChild);
	        return this;
	    }
	};

	var methods$1 = {
	    getChildrenWidth: GetChildrenWidth,
	    getChildrenHeight: GetChildrenHeight,
	    getChildrenSizers: GetChildrenSizers,
	    preLayout: PreLayout,
	    layoutChildren: LayoutChildren,
	    hasWidthWrap: HasWidthWrap,
	    runWidthWrap: RunWidthWrap,
	    hasHeightWrap: HasHeightWrap,
	    runHeightWrap: RunHeightWrap,
	    getExpandedChildWidth: GetExpandedChildWidth,
	    getExpandedChildHeight: GetExpandedChildHeight,

	};

	Object.assign(
	    methods$1,
	    AddChildMethods$2,
	    RemoveChildMethods$2,
	    SortChildrenMethods
	);

	var GetMaxChildWidth = function (children) {
	    if (children === undefined) {
	        children = this.sizerChildren;
	    }
	    var result = 0;
	    var child, childWidth;
	    var hasUnknownChildWidth = false;

	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        if (child === '\n') {
	            continue;
	        }

	        childWidth = this.getChildWidth(child);
	        if (childWidth === undefined) {
	            hasUnknownChildWidth = true;
	        }

	        if (hasUnknownChildWidth) {
	            continue;
	        }

	        result = Math.max(childWidth, result);
	    }
	    
	    if (hasUnknownChildWidth) {
	        return undefined;
	    }

	    return result;
	};

	var GetMaxChildHeight = function (children) {
	    if (children === undefined) {
	        children = this.sizerChildren;
	    }
	    var result = 0;
	    var child, childHeight;
	    var hasUnknownChildHeight = false;

	    for (var i = 0, cnt = children.length; i < cnt; i++) {
	        child = children[i];
	        if (child === '\n') {
	            continue;
	        }

	        childHeight = this.getChildHeight(child);
	        if (childHeight === undefined) {
	            hasUnknownChildHeight = true;
	        }

	        if (hasUnknownChildHeight) {
	            continue;
	        }

	        result = Math.max(childHeight, result);
	    }

	    if (hasUnknownChildHeight) {
	        return undefined;
	    }

	    return result;
	};

	const IsPlainObject$3 = Phaser.Utils.Objects.IsPlainObject;
	const GetValue$e = Phaser.Utils.Objects.GetValue;

	class FixWidthSizer extends Base$2 {
	    constructor(scene, x, y, minWidth, minHeight, config) {
	        if (IsPlainObject$3(x)) {
	            config = x;
	            x = GetValue$e(config, 'x', 0);
	            y = GetValue$e(config, 'y', 0);
	            minWidth = GetValue$e(config, 'width', undefined);
	            minHeight = GetValue$e(config, 'height', undefined);
	        } else if (IsPlainObject$3(minWidth)) {
	            config = minWidth;
	            minWidth = GetValue$e(config, 'width', undefined);
	            minHeight = GetValue$e(config, 'height', undefined);
	        }

	        super(scene, x, y, minWidth, minHeight, config);
	        this.type = 'rexFixWidthSizer';
	        this.sizerChildren = [];

	        this.runChildrenWrapFlag = true;

	        this.setOrientation(GetValue$e(config, 'orientation', 0));
	        this.setItemSpacing(GetValue$e(config, 'space.item', 0));
	        this.setLineSpacing(GetValue$e(config, 'space.line', 0));
	        this.setIntentLeft(
	            GetValue$e(config, 'space.indentLeftOdd', 0),
	            GetValue$e(config, 'space.indentLeftEven', 0)
	        );
	        this.setIntentTop(
	            GetValue$e(config, 'space.indentTopOdd', 0),
	            GetValue$e(config, 'space.indentTopEven', 0)
	        );
	        this.setAlign(GetValue$e(config, 'align', 0));
	        this.setJustifyPercentage(GetValue$e(config, 'justifyPercentage', 0.25));
	        this.setRTL(GetValue$e(config, 'rtl', false));

	        this.wrapResult = undefined;  // {lines, width, height}

	        this.addChildrenMap('items', this.sizerChildren);
	    }

	    setOrientation(orientation) {
	        this.orientation = GetOrientationMode(orientation);
	        return this;
	    }

	    setItemSpacing(space) {
	        this.space.item = space;
	        return this;
	    }

	    setLineSpacing(space) {
	        this.space.line = space;
	        return this;
	    }

	    setIntentLeft(odd, even) {
	        this.space.indentLeftOdd = odd;
	        this.space.indentLeftEven = even;
	        return this;
	    }

	    setIntentTop(odd, even) {
	        this.space.indentTopOdd = odd;
	        this.space.indentTopEven = even;
	        return this;
	    }

	    setAlign(align) {
	        if (typeof (align) === 'string') {
	            align = ALIGN[align];
	        }
	        this.align = align;
	        return this;
	    }

	    setJustifyPercentage(value) {
	        this.justifyPercentage = value;
	        return this;
	    }

	    setRTL(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.rtl = enabled;
	        return this;
	    }

	    get maxChildWidth() {
	        if (this._maxChildWidth === undefined) {
	            this._maxChildWidth = GetMaxChildWidth.call(this);
	        }
	        return this._maxChildWidth;
	    }

	    get maxChildHeight() {
	        if (this._maxChildHeight === undefined) {
	            this._maxChildHeight = GetMaxChildHeight.call(this);
	        }
	        return this._maxChildHeight;
	    }
	}

	const ALIGN = {
	    left: 0, top: 0,
	    right: 1, bottom: 1,
	    center: 2,
	    justify: 3,
	    'justify-left': 3, 'justify-top': 3,
	    'justify-right': 4, 'justify-bottom': 4,
	    'justify-center': 5
	};

	Object.assign(
	    FixWidthSizer.prototype,
	    methods$1
	);

	const SizerAdd$1 = FixWidthSizer.prototype.add;

	var Add = function (gameObject) {
	    SizerAdd$1.call(this, gameObject);
	    this.buttonGroup.add(gameObject);
	    return this;
	};

	var AddChildMethods$1 = {
	    addButton(gameObject) {
	        if (IsArray(gameObject)) {
	            var gameObjects = gameObject;
	            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	                Add.call(this, gameObjects[i]);
	            }
	        } else {
	            Add.call(this, gameObject);
	        }
	        return this;
	    },

	    addButtons(gameObjects) {
	        if (IsArray(gameObjects[0])) {
	            // 2d array
	            var lines = gameObjects, line;
	            for (var lineIdx = 0, lastLineIdx = (lines.length - 1); lineIdx <= lastLineIdx; lineIdx++) {
	                line = lines[lineIdx];
	                for (var i = 0, cnt = line.length; i < cnt; i++) {
	                    Add.call(this, line[i]);
	                }
	                if (lineIdx > lastLineIdx) {
	                    SizerAdd$1.addNewLine(this);
	                }
	            }
	        } else {
	            // 1d array
	            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	                Add.call(this, gameObjects[i]);
	            }
	        }
	        return this;
	    }
	};

	const SizerRmove$1 = FixWidthSizer.prototype.remove;
	const SizerClear$1 = FixWidthSizer.prototype.clear;

	var Remove$1 = function (gameObject, destroyChild) {
	    var gameObject = this.getButton(gameObject);
	    if (!gameObject) {
	        return this;
	    }

	    this.buttonGroup.remove(gameObject);    
	    SizerRmove$1.call(this, gameObject, destroyChild);
	    return this;
	};

	var RemoveChildMethods$1 = {
	    remove(gameObject, destroyChild) {
	        if (IsArray(gameObject)) {
	            var gameObjects = gameObject;
	            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	                Remove$1.call(this, gameObjects[i], destroyChild);
	            }
	        } else {
	            Remove$1.call(this, gameObject, destroyChild);
	        }
	        return this;
	    },

	    clear(destroyChild) {
	        var buttons = this.buttonGroup.buttons;
	        buttons.length = 0;
	        SizerClear$1.call(this, destroyChild);
	        return this;
	    },

	    removeButton(gameObject, destroyChild) {
	        this.remove(gameObject, destroyChild);
	        return this;
	    },

	    clearButtons(destroyChild) {
	        var buttons = this.buttonGroup.buttons;
	        for (var i = buttons.length - 1; i >= 0; i--) {
	            Remove$1.call(this, buttons[i], destroyChild);
	        }
	        return this;
	    }
	};

	const GetValue$d = Phaser.Utils.Objects.GetValue;

	class Buttons extends FixWidthSizer {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }

	        var buttonSpace = config.space;
	        if (typeof (buttonSpace) === 'number') {
	            config.space = { item: buttonSpace, line: buttonSpace };
	        }

	        // Create
	        super(scene, config);
	        this.type = 'rexFixWidthButtons';
	        this.buttonGroup = new ButtonGroup({
	            parent: this,
	            eventEmitter: GetValue$d(config, 'eventEmitter', this),
	            groupName: GetValue$d(config, 'groupName', undefined),
	            clickConfig: GetValue$d(config, 'click', undefined)
	        })
	            .setButtonsType(config);

	        // Add elements
	        var background = GetValue$d(config, 'background', undefined);
	        var buttons = GetValue$d(config, 'buttons', undefined);

	        // Buttons properties
	        this.buttonsAlign = GetValue$d(config, 'align', undefined);

	        if (background) {
	            this.addBackground(background);
	        }

	        if (buttons) {
	            this.addButtons(buttons);
	        }

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('buttons', this.buttonGroup.buttons);
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        super.destroy(fromScene);
	        this.buttonGroup.destroy();
	        this.buttonGroup = undefined;
	    }

	    get buttons() {
	        return this.buttonGroup.buttons;
	    }

	    get groupName() {
	        return this.buttonGroup.groupName;
	    }

	    set groupName(value) {
	        this.buttonGroup.groupName = value;
	    }

	    get eventEmitter() {
	        return this.buttonGroup.eventEmitter;
	    }
	}

	Object.assign(
	    Buttons.prototype,
	    AddChildMethods$1,
	    RemoveChildMethods$1,
	    ButtonMethods$1,
	    ButtonStateMethods
	);

	const SizerAdd = GridSizer.prototype.add;

	var AddChildMethods = {
	    addButton(gameObject, columnIndex, rowIndex) {
	        SizerAdd.call(this, gameObject, columnIndex, rowIndex, undefined, 0, this.buttonsExpand);
	        this.buttonGroup.add(gameObject);
	        return this;
	    },

	    addButtons(gameObjects, rowThenColumn) {
	        for (var i = 0, cnt = gameObjects; i < cnt; i++) {
	            this.addButton(gameObjects[i], undefined, rowThenColumn);
	        }
	        return this;
	    }
	};

	const SizerRmove = GridSizer.prototype.remove;
	const SizerClear = GridSizer.prototype.clear;

	var Remove = function (gameObject, destroyChild) {
	    var gameObject = this.getButton(gameObject);
	    if (!gameObject) {
	        return this;
	    }

	    this.buttonGroup.remove(gameObject);
	    SizerRmove.call(this, gameObject, destroyChild);
	    return this;
	};

	var RemoveChildMethods = {
	    remove(gameObject, destroyChild) {
	        if (IsArray(gameObject)) {
	            var gameObjects = gameObject;
	            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
	                Remove.call(this, gameObjects[i], destroyChild);
	            }
	        } else {
	            Remove.call(this, gameObject, destroyChild);
	        }
	        return this;
	    },

	    clear(destroyChild) {
	        var buttons = this.buttonGroup.buttons;
	        buttons.length = 0;
	        SizerClear.call(this, destroyChild);
	        return this;
	    },

	    removeButton(gameObject, destroyChild) {
	        this.remove(gameObject, destroyChild);
	        return this;
	    },

	    clearButtons(destroyChild) {
	        var buttons = this.buttonGroup.buttons;
	        for (var i = buttons.length - 1; i >= 0; i--) {
	            Remove.call(this, buttons[i], destroyChild);
	        }
	        return this;
	    }
	};

	const GetValue$c = Phaser.Utils.Objects.GetValue;

	class GridButtons extends GridSizer {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }
	        var rowCount = GetValue$c(config, 'row', 0);
	        var columnCount = GetValue$c(config, 'column', (config.col || 0));
	        var createCellContainerCallback = GetValue$c(config, 'createCellContainerCallback');
	        var buttons = GetValue$c(config, 'buttons', undefined);
	        var buttonsExpand = GetValue$c(config, 'expand', true);
	        var buttonProportion = (buttonsExpand) ? 1 : 0;

	        if (createCellContainerCallback) {
	            config.createCellContainerCallback = undefined;
	        }
	        if (buttons !== undefined) {
	            rowCount = Math.max(rowCount, buttons.length);
	            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
	                columnCount = Math.max(columnCount, buttons[i].length);
	            }
	        }

	        config.row = rowCount;
	        config.column = columnCount;
	        config.columnProportions = buttonProportion;
	        config.rowProportions = buttonProportion;

	        // Create
	        super(scene, config);
	        this.type = 'rexGridButtons';
	        this.buttonGroup = new ButtonGroup({
	            parent: this,
	            eventEmitter: GetValue$c(config, 'eventEmitter', this),
	            groupName: GetValue$c(config, 'groupName', undefined),
	            clickConfig: GetValue$c(config, 'click', undefined)
	        })
	            .setButtonsType(config);

	        // Add elements
	        var background = GetValue$c(config, 'background', undefined);

	        // Buttons properties
	        this.buttonsExpand = buttonsExpand;
	        GetValue$c(config, 'space', undefined);

	        if (background) {
	            this.addBackground(background);
	        }

	        if (buttons) {
	            var rowButtons, button;
	            for (var r = 0, rcnt = buttons.length; r < rcnt; r++) { // row
	                rowButtons = buttons[r];
	                for (var c = 0, ccnt = rowButtons.length; c < ccnt; c++) { // col
	                    button = rowButtons[c];
	                    if (button) {
	                        this.addButton(button, c, r);
	                    }
	                }
	            }
	        } else if (createCellContainerCallback) {
	            for (var y = 0; y < rowCount; y++) {
	                for (var x = 0; x < columnCount; x++) {
	                    var button = createCellContainerCallback(scene, x, y);
	                    if (button) {
	                        this.addButton(button, x, y);
	                    }
	                }
	            }
	        }

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('buttons', this.buttonGroup.buttons);
	    }

	    destroy(fromScene) {
	        //  This Game Object has already been destroyed
	        if (!this.scene || this.ignoreDestroy) {
	            return;
	        }

	        super.destroy(fromScene);
	        this.buttonGroup.destroy();
	        this.buttonGroup = undefined;
	    }

	    get buttons() {
	        return this.buttonGroup.buttons;
	    }

	    get groupName() {
	        return this.buttonGroup.groupName;
	    }

	    set groupName(value) {
	        this.buttonGroup.groupName = value;
	    }

	    get eventEmitter() {
	        return this.buttonGroup.eventEmitter;
	    }
	}

	Object.assign(
	    GridButtons.prototype,
	    AddChildMethods,
	    RemoveChildMethods,
	    ButtonMethods$1,
	    ButtonStateMethods
	);

	var ButtonMethods = {
	    getChoice(index) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            return choicesSizer.getButton(index);
	        } else {
	            return undefined;
	        }
	    },

	    getAction(index) {
	        return this.childrenMap.actionsSizer.getButton(index);
	    },

	    getToolbar(index) {
	        return this.childrenMap.toolbarSizer.getButton(index);
	    },

	    getLeftToolbar(index) {
	        return this.childrenMap.leftToolbarSizer.getButton(index);
	    },

	    setChoiceEnable(index, enabled) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.setButtonEnable(index, enabled);
	        }
	        return this;
	    },

	    setActionEnable(index, enabled) {
	        this.childrenMap.actionsSizer.setButtonEnable(index, enabled);
	        return this;
	    },

	    setToolbarEnable(index, enabled) {
	        this.childrenMap.toolbarSizer.setButtonEnable(index, enabled);
	        return this;
	    },

	    setLeftToolbarEnable(index, enabled) {
	        this.childrenMap.leftToolbarSizer.setButtonEnable(index, enabled);
	        return this;
	    },

	    toggleChoiceEnable(index) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.toggleButtonEnable(index);
	        }
	        return this;
	    },

	    toggleActionEnable(index) {
	        this.childrenMap.actionsSizer.toggleButtonEnable(index);
	        return this;
	    },

	    toggleToolbarEnable(index) {
	        this.childrenMap.toolbarSizer.toggleButtonEnable(index);
	        return this;
	    },

	    toggleLeftToolbarEnable(index) {
	        this.childrenMap.leftToolbarSizer.toggleButtonEnable(index);
	        return this;
	    },

	    getChoiceEnable(index) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            return choicesSizer.getButtonEnable(index);
	        } else {
	            return false;
	        }
	    },

	    getActionEnable(index) {
	        return this.childrenMap.actionsSizer.getButtonEnable(index);
	    },

	    getToolbarEnable(index) {
	        return this.childrenMap.toolbarSizer.getButtonEnable(index);
	    },

	    getLeftToolbarEnable(index) {
	        return this.childrenMap.leftToolbarSizer.getButtonEnable(index);
	    },

	    emitChoiceClick(index) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.emitButtonClick(index);
	        }
	        return this;
	    },

	    emitActionClick(index) {
	        this.childrenMap.actionsSizer.emitButtonClick(index);
	        return this;
	    },

	    emitToolbarClick(index) {
	        this.childrenMap.toolbarSizer.emitButtonClick(index);
	        return this;
	    },

	    emitLeftToolbarClick(index) {
	        this.childrenMap.leftToolbarSizer.emitButtonClick(index);
	        return this;
	    },

	    showChoice(index) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.showButton(index);
	        }
	        return this;
	    },

	    showAction(index) {
	        this.childrenMap.actionsSizer.showButton(index);
	        return this;
	    },

	    showToolbar(index) {
	        this.childrenMap.toolbarSizer.showButton(index);
	        return this;
	    },

	    showLeftToolbar(index) {
	        this.childrenMap.leftToolbarSizer.showButton(index);
	        return this;
	    },

	    hideChoice(index) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.hideButton(index);
	        }
	        return this;
	    },

	    hideAction(index) {
	        this.childrenMap.actionsSizer.hideButton(index);
	        return this;
	    },

	    hideToolbar(index) {
	        this.childrenMap.toolbarSizer.hideButton(index);
	        return this;
	    },

	    hideLeftToolbar(index) {
	        this.childrenMap.leftToolbarSizer.hideButton(index);
	        return this;
	    },

	    addChoice(gameObject) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.addButton(gameObject);
	        }
	        return this;
	    },

	    addAction(gameObject) {
	        this.childrenMap.actionsSizer.addButton(gameObject);
	        return this;
	    },

	    addToolbar(gameObject) {
	        this.childrenMap.toolbarSizer.addButton(gameObject);
	        return this;
	    },

	    addLeftToolbar(gameObject) {
	        this.childrenMap.leftToolbarSizer.addButton(gameObject);
	        return this;
	    },

	    removeChoice(index, destroyChild) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.removeButton(index, destroyChild);
	        }
	        return this;
	    },

	    removeAction(index, destroyChild) {
	        this.childrenMap.actionsSizer.removeButton(index, destroyChild);
	        return this;
	    },

	    removeToolbar(index, destroyChild) {
	        this.childrenMap.toolbarSizer.removeButton(index, destroyChild);
	        return this;
	    },

	    removeLeftToolbar(index, destroyChild) {
	        this.childrenMap.leftToolbarSizer.removeButton(index, destroyChild);
	        return this;
	    },

	    clearChoices(destroyChild) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.clearButtons(destroyChild);
	        }
	        return this;
	    },

	    clearActions(destroyChild) {
	        this.childrenMap.actionsSizer.clearButtons(destroyChild);
	        return this;
	    },

	    clearToolbar(destroyChild) {
	        this.childrenMap.toolbarSizer.clearButtons(destroyChild);
	        return this;
	    },

	    clearLeftToolbar(destroyChild) {
	        this.childrenMap.leftToolbarSizer.clearButtons(destroyChild);
	        return this;
	    },

	    forEachChoice(callback, scope) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.forEachButtton(callback, scope);
	        }
	        return this;
	    },

	    forEachAction(callback, scope) {
	        this.childrenMap.actionsSizer.forEachButtton(callback, scope);
	        return this;
	    },

	    forEachToolbar(callback, scope) {
	        this.childrenMap.toolbarSizer.forEachButtton(callback, scope);
	        return this;
	    },

	    forEachLeftToolbar(callback, scope) {
	        this.childrenMap.leftToolbarSizer.forEachButtton(callback, scope);
	        return this;
	    },

	    setAllButtonsEnable(enabled) {
	        if (enabled === undefined) {
	            enabled = true;
	        }

	        if (this.childrenMap.toolbarSizer) {
	            this.setToolbarEnable(enabled);
	        }
	        if (this.childrenMap.leftToolbarSizer) {
	            this.setLeftToolbarEnable(enabled);
	        }
	        if (this.childrenMap.actionsSizer) {
	            this.setActionEnable(enabled);
	        }
	        if (this.childrenMap.choicesSizer) {
	            this.setChoiceEnable(enabled);
	        }

	        return this;
	    },

	    // Checkboxes
	    getChoicesButtonStates() {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            return choicesSizer.getAllButtonsState();
	        } else {
	            return {};
	        }
	    },

	    getChoicesButtonState(name) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (name === undefined) {
	            if (choicesSizer) {
	                return choicesSizer.getAllButtonsState();
	            } else {
	                return {}
	            }
	        } else {
	            if (choicesSizer) {
	                return choicesSizer.getButtonState(name);
	            } else {
	                return false;
	            }
	        }
	    },

	    setChoicesButtonState(name, state) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.setButtonState(name, state);
	        }
	        return this;
	    },

	    clearChoicesButtonStates() {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.clearAllButtonsState();
	        }
	        return this;
	    },

	    // Radio buttons
	    getChoicesSelectedButtonName() {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            return choicesSizer.getSelectedButtonName();
	        } else {
	            return '';
	        }
	    },

	    setChoicesSelectedButtonName(name) {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            choicesSizer.setSelectedButtonName(name);
	        }
	        return this;
	    },

	    hasAnyChoice() {
	        var choicesSizer = this.childrenMap.choicesSizer;
	        if (choicesSizer) {
	            return choicesSizer.hasAnyButton();
	        }
	        return false;
	    },

	    hasAnyAction() {
	        var actionsSizer = this.childrenMap.actionsSizer;
	        if (actionsSizer) {
	            return actionsSizer.hasAnyButton();
	        }
	        return false;
	    },

	    hasAnyToolbar() {
	        var toolbarSizer = this.childrenMap.toolbarSizer;
	        if (toolbarSizer) {
	            return toolbarSizer.hasAnyButton();
	        }
	        return false;
	    },

	    hasAnyLeftToolbar() {
	        var leftToolbarSizer = this.childrenMap.leftToolbarSizer;
	        if (leftToolbarSizer) {
	            return leftToolbarSizer.hasAnyButton();
	        }
	        return false;
	    },
	};

	var ModalMethods = {
	    onCreateModalBehavior(self) {
	        self.on('button.click', function (button, groupName, index, pointer, event) {
	            var canClose = false;
	            switch (groupName) {
	                case 'actions':
	                    // Click any action button
	                    canClose = true;
	                    break;

	                case 'choices':
	                    // Click any choice button, and no action button in this dialog
	                    if (!self.hasAnyAction()) {
	                        canClose = true;
	                    }
	                    break;
	            }
	            if (!canClose) {
	                return;
	            }

	            var closeEventData = {
	                index: index,
	                text: button.text,
	                button: button,
	                dialog: self
	            };


	            switch (self.buttonsType) {
	                case 'radio':
	                    closeEventData.value = self.getChoicesSelectedButtonName();
	                    break;
	                case 'checkboxes':
	                    closeEventData.value = self.getChoicesButtonStates();
	                    break;
	                default:
	                    closeEventData.value = undefined;
	            }

	            self.modalClose(closeEventData);
	        });
	    },

	    modal(config, onClose) {
	        if (config && (config.defaultBehavior === false)) {
	            this.onCreateModalBehavior = false;
	        } else {
	            delete this.onCreateModalBehavior;
	        }

	        ModalMethods$1.modal.call(this, config, onClose);
	        return this;
	    }
	};

	var Methods$2 = {};

	Object.assign(
	    Methods$2,
	    ButtonMethods,
	    ModalMethods,
	);

	const GetValue$b = Phaser.Utils.Objects.GetValue;

	class Dialog extends Sizer {
	    constructor(scene, config) {
	        if (config === undefined) {
	            config = {};
	        }
	        // Create sizer        
	        config.orientation = 1; // Top to bottom
	        super(scene, config);
	        this.type = 'rexDialog';
	        this.eventEmitter = GetValue$b(config, 'eventEmitter', this);

	        // Add elements
	        var background = GetValue$b(config, 'background', undefined);
	        var title = GetValue$b(config, 'title', undefined);
	        var toolbar = GetValue$b(config, 'toolbar', undefined);
	        var toolbarBackground = GetValue$b(config, 'toolbarBackground', undefined);
	        var leftToolbar = GetValue$b(config, 'leftToolbar', undefined);
	        var leftToolbarBackground = GetValue$b(config, 'leftToolbarBackground', undefined);
	        var content = GetValue$b(config, 'content', undefined);
	        var description = GetValue$b(config, 'description', undefined);
	        var choicesSizer;
	        var choices = GetValue$b(config, 'choices', undefined);
	        var choicesBackground = GetValue$b(config, 'choicesBackground', undefined);
	        var actionsSizer;
	        var actions = GetValue$b(config, 'actions', undefined);
	        var actionsBackground = GetValue$b(config, 'actionsBackground', undefined);
	        var clickConfig = GetValue$b(config, 'click', undefined);

	        if (background) {
	            this.addBackground(background);
	        }

	        var toolbarSizer;
	        if (toolbar) {
	            toolbarSizer = new Buttons$1(scene, {
	                groupName: 'toolbar',
	                background: toolbarBackground,
	                buttons: toolbar,
	                orientation: 0, // Left-right
	                space: { item: GetValue$b(config, 'space.toolbarItem', 0) },
	                click: clickConfig,
	                eventEmitter: this.eventEmitter,
	            });
	            scene.add.existing(toolbarSizer);
	        }

	        var leftToolbarSizer;
	        if (leftToolbar) {
	            leftToolbarSizer = new Buttons$1(scene, {
	                groupName: 'leftToolbar',
	                background: leftToolbarBackground,
	                buttons: leftToolbar,
	                orientation: 0, // Left-right
	                space: { item: GetValue$b(config, 'space.leftToolbarItem', 0) },
	                click: clickConfig,
	                eventEmitter: this.eventEmitter,
	            });
	            scene.add.existing(leftToolbarSizer);
	        }

	        // title or toolbar or leftToolbar
	        if (title || toolbar || leftToolbar) {
	            var titleExpandWidth = !!title && GetValue$b(config, 'expand.title', true);
	            var titleAlign = GetValue$b(config, 'align.title', 'center');
	            var useOverlapSizer =
	                // Has title, title is not exapnd-width, title align to center
	                (title && !titleExpandWidth && (titleAlign === 'center')) ||
	                // No title
	                (!title && (toolbar || leftToolbar));
	            var useSizer = !useOverlapSizer;

	            var titleSizer;
	            if (useSizer) {
	                titleSizer = new Sizer(scene, { orientation: 0 });
	            } else {
	                titleSizer = new OverlapSizer(scene);
	            }
	            scene.add.existing(titleSizer);

	            var titleChildExpand = (useSizer) ? true : { height: true };

	            // Add leftToolbar
	            if (leftToolbarSizer) {
	                titleSizer.add(
	                    leftToolbarSizer,
	                    { align: 'left', expand: titleChildExpand }
	                );
	            }

	            // Add title
	            if (title) {
	                // Add space if not expand, align to right
	                if (useSizer && !titleExpandWidth && (titleAlign === 'right')) {
	                    titleSizer.addSpace();
	                }

	                var padding = {
	                    left: GetValue$b(config, 'space.titleLeft', 0),
	                    right: GetValue$b(config, 'space.titleRight', 0)
	                };
	                var proportion = (titleExpandWidth) ? 1 : 0;
	                titleSizer.add(
	                    title,
	                    { align: titleAlign, proportion: proportion, expand: titleChildExpand, padding: padding }
	                );

	                // Add space if not expand, align to left
	                if (useSizer && !titleExpandWidth && (titleAlign === 'left')) {
	                    titleSizer.addSpace();
	                }
	            }

	            // Add toolbar
	            if (toolbarSizer) {
	                // Add space if not title
	                if (useSizer && !title) {
	                    titleSizer.addSpace();
	                }
	                titleSizer.add(
	                    toolbarSizer,
	                    { align: 'right', expand: titleChildExpand }
	                );
	            }

	            // Add sizer to dialog
	            var padding;
	            if (content || description || choices || actions) {
	                padding = {
	                    bottom: GetValue$b(config, 'space.title', 0),
	                    top: GetValue$b(config, 'space.titleTop', 0)
	                };
	            }
	            var proportion = GetValue$b(config, 'proportion.title', 0);
	            this.add(
	                titleSizer,
	                { padding: padding, proportion: proportion, expand: true }
	            );
	        }

	        if (content) {
	            var align = GetValue$b(config, 'align.content', 'center');
	            var contentSpace = GetValue$b(config, 'space.content', 0);
	            var padding = {
	                left: GetValue$b(config, 'space.contentLeft', 0),
	                right: GetValue$b(config, 'space.contentRight', 0),
	                bottom: ((description || choices || actions) ? contentSpace : 0)
	            };
	            var proportion = GetValue$b(config, 'proportion.content', 0);
	            var expand = GetValue$b(config, 'expand.content', true);
	            this.add(
	                content,
	                { align: align, padding: padding, proportion: proportion, expand: expand }
	            );
	        }

	        if (description) {
	            var align = GetValue$b(config, 'align.description', 'center');
	            var descriptionSpace = GetValue$b(config, 'space.description', 0);
	            var padding = {
	                left: GetValue$b(config, 'space.descriptionLeft', 0),
	                right: GetValue$b(config, 'space.descriptionRight', 0),
	                bottom: ((choices || actions) ? descriptionSpace : 0)
	            };
	            var proportion = GetValue$b(config, 'proportion.description', 0);
	            var expand = GetValue$b(config, 'expand.description', true);
	            this.add(
	                description,
	                { align: align, padding: padding, proportion: proportion, expand: expand }
	            );
	        }

	        if (choices) {
	            var choicesType = GetValue$b(config, 'choicesType', '').split('-');
	            var ButtonsClass = Contains(choicesType, 'wrap') ? Buttons :
	                Contains(choicesType, 'grid') ? GridButtons :
	                    Buttons$1;
	            var buttonsType = Contains(choicesType, 'radio') ? 'radio' :
	                Contains(choicesType, 'checkboxes') ? 'checkboxes' : undefined;

	            var space = {
	                left: GetValue$b(config, 'space.choicesBackgroundLeft', 0),
	                right: GetValue$b(config, 'space.choicesBackgroundRight', 0),
	                top: GetValue$b(config, 'space.choicesBackgroundTop', 0),
	                bottom: GetValue$b(config, 'space.choicesBackgroundBottom', 0),
	            };
	            var itemSpace = GetValue$b(config, 'space.choice', 0);
	            if (ButtonsClass === Buttons$1) {
	                space.item = itemSpace;
	            } else if (ButtonsClass === Buttons) {
	                space.item = itemSpace;
	                space.line = GetValue$b(config, 'space.choiceLine', itemSpace);
	            } else {  // GridButtons
	                space.column = GetValue$b(config, 'space.choiceColumn', itemSpace);
	                space.row = GetValue$b(config, 'space.choiceRow', itemSpace);
	            }

	            var choicesConfig = {
	                width: GetValue$b(config, 'choicesWidth', undefined),
	                height: GetValue$b(config, 'choicesHeight', undefined),
	                groupName: 'choices',
	                buttonsType: buttonsType,
	                background: choicesBackground,
	                buttons: choices,
	                space: space,
	                click: clickConfig,
	                eventEmitter: this.eventEmitter,
	                setValueCallback: GetValue$b(config, 'choicesSetValueCallback', undefined),
	                setValueCallbackScope: GetValue$b(config, 'choicesSetValueCallbackScope', undefined)
	            };

	            if (ButtonsClass === Buttons$1) {
	                choicesConfig.orientation = Contains(choicesType, 'x') ? 0 : 1;
	            }

	            choicesSizer = new ButtonsClass(scene, choicesConfig);
	            scene.add.existing(choicesSizer);
	            var choicesSpace = GetValue$b(config, 'space.choices', 0);
	            var padding = {
	                left: GetValue$b(config, 'space.choicesLeft', 0),
	                right: GetValue$b(config, 'space.choicesRight', 0),
	                bottom: ((actions) ? choicesSpace : 0)
	            };
	            var align = GetValue$b(config, 'align.choices', 'center');
	            var proportion = GetValue$b(config, 'proportion.choices', 0);
	            var expand = GetValue$b(config, 'expand.choices', true);
	            this.add(
	                choicesSizer,
	                { align: align, padding: padding, proportion: proportion, expand: expand }
	            );

	            this.buttonsType = buttonsType;
	        }

	        if (actions) {
	            actionsSizer = new Buttons$1(scene, {
	                groupName: 'actions',
	                background: actionsBackground,
	                buttons: actions,
	                orientation: 0, // Left-right
	                space: { item: GetValue$b(config, 'space.action', 0) },
	                expand: GetValue$b(config, 'expand.actions', false),
	                align: GetValue$b(config, 'align.actions', 'center'),
	                click: clickConfig,
	                eventEmitter: this.eventEmitter,
	            });
	            scene.add.existing(actionsSizer);
	            var padding = {
	                left: GetValue$b(config, 'space.actionsLeft', 0),
	                right: GetValue$b(config, 'space.actionsRight', 0),
	                bottom: GetValue$b(config, 'space.actionsBottom', 0),
	            };
	            var proportion = GetValue$b(config, 'proportion.action', 0);
	            this.add(
	                actionsSizer,
	                { align: 'center', padding: padding, proportion: proportion, expand: true }
	            );
	        }

	        EmitButtonEvent(this, 'click');
	        EmitButtonEvent(this, 'over');
	        EmitButtonEvent(this, 'out');
	        EmitButtonEvent(this, 'enable');
	        EmitButtonEvent(this, 'disable');

	        this.addChildrenMap('background', background);
	        this.addChildrenMap('title', title);
	        this.addChildrenMap('toolbar', toolbar);
	        this.addChildrenMap('leftToolbar', leftToolbar);
	        this.addChildrenMap('content', content);
	        this.addChildrenMap('description', description);
	        this.addChildrenMap('choices', (choicesSizer) ? choicesSizer.buttons : undefined);
	        this.addChildrenMap('actions', (actionsSizer) ? actionsSizer.buttons : undefined);
	        this.addChildrenMap('choicesSizer', choicesSizer);
	        this.addChildrenMap('actionsSizer', actionsSizer);
	        this.addChildrenMap('toolbarSizer', toolbarSizer);
	        this.addChildrenMap('leftToolbarSizer', leftToolbarSizer);
	    }
	}

	var Contains = function (arr, item) {
	    return arr.indexOf(item) !== -1;
	};

	var ButtonsGroupEventNameMap = {
	    actions: 'action',
	    choices: 'choice',
	    toolbar: 'toolbar',
	    leftToolbar: 'leftToolbar'
	};

	var EmitButtonEvent = function (dialog, postEventName) {
	    dialog.on(`button.${postEventName}`, function (button, groupName, index, pointer, event) {
	        if (!ButtonsGroupEventNameMap.hasOwnProperty(groupName)) {
	            return
	        }
	        dialog.emit(`${ButtonsGroupEventNameMap[groupName]}.${postEventName}`, button, index, pointer, event);
	    });
	};

	Object.assign(
	    Dialog.prototype,
	    Methods$2
	);

	var CreateLabel = function (scene, config, creators) {
	    var gameObject = new SimpleLabel(scene, config, creators);
	    scene.add.existing(gameObject);
	    return gameObject;
	};

	var ResetDisplayContent$1 = function (config) {
	    if (config === undefined) {
	        config = {};
	    }

	    ResetTitle$1.call(this, config);
	    ResetContent$1.call(this, config);
	    ResetActions$1.call(this, config);
	    ResetChoices.call(this, config);

	    return this;
	};

	var ResetTitle$1 = function (config) {
	    var title = this.childrenMap.title;
	    config = config.title;
	    if (config === null) {
	        title.hide();
	    } else {
	        title.show();

	        title.resetDisplayContent(config);
	    }
	};

	var ResetContent$1 = function (config) {
	    var content = this.childrenMap.content;
	    config = config.content;
	    if (config === null) {
	        content.hide();
	    } else {
	        content.show();

	        if (content.resetDisplayContent) {
	            // Label
	            content.resetDisplayContent(config);
	        } else {
	            // TextArea
	            var text = config || '';
	            content.setText(text);
	        }
	    }

	};

	var ResetActions$1 = function (config) {
	    var actionButtons = this.childrenMap.actions;
	    if (!actionButtons) {
	        return;
	    }

	    var buttonContentArray = config.buttons;
	    if (!buttonContentArray) {
	        var buttonA = actionButtons[0];
	        if (buttonA) {
	            if (config.buttonA === null) {
	                buttonA.hide();
	            } else {
	                buttonA.show();
	                buttonA.resetDisplayContent(config.buttonA);
	            }
	        }

	        var buttonB = actionButtons[1];
	        if (buttonB) {
	            if (config.buttonB === null) {
	                buttonB.hide();
	            } else {
	                buttonB.show();
	                buttonB.resetDisplayContent(config.buttonB);
	            }
	        }

	    } else {
	        var scene = this.scene;
	        var defaultActionConfig = this.defaultActionConfig;
	        var defaultActionButtonCreator = this.defaultActionButtonCreator;
	        for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
	            var buttonContent = buttonContentArray[i];
	            var button = actionButtons[i];
	            if (!button) {
	                button = CreateLabel(scene, defaultActionConfig, defaultActionButtonCreator);
	                this.addAction(button);
	            }
	            button.show().resetDisplayContent(buttonContent);
	        }

	        this.buttonMode = buttonContentArray.length;

	        for (var i = buttonContentArray.length, cnt = actionButtons.length; i < cnt; i++) {
	            actionButtons[i].hide();
	        }
	    }
	};

	var ResetChoices = function (config) {
	    var choices = this.childrenMap.choices;
	    if (!choices) {
	        return;
	    }

	    var buttonContentArray = config.choices;
	    if (!buttonContentArray) {
	        buttonContentArray = [];
	    }

	    var scene = this.scene;
	    var defaultChoiceConfig = this.defaultChoiceConfig;
	    var defaultActionButtonCreator = this.defaultActionButtonCreator;
	    for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
	        var buttonContent = buttonContentArray[i];
	        if (typeof (buttonContent) === 'string') {
	            buttonContent = { text: buttonContent };
	        }

	        var button = choices[i];
	        if (!button) {
	            button = CreateLabel(scene, defaultChoiceConfig, defaultActionButtonCreator);
	            this.addChoice(button);
	        }

	        button.show().resetDisplayContent(buttonContent);

	        var optionValue;
	        if (buttonContent.hasOwnProperty('value')) {
	            optionValue = buttonContent.value;
	        } else {
	            optionValue = buttonContent.text;
	        }
	        button.setName(optionValue);
	    }

	    for (var i = buttonContentArray.length, cnt = choices.length; i < cnt; i++) {
	        choices[i].hide();
	    }
	};

	const Merge$2 = Phaser.Utils.Objects.Merge;

	var Modal$1 = function (config, onClose) {
	    if (IsFunction(config)) {
	        onClose = config;
	        config = undefined;
	    }

	    if (config === undefined) {
	        config = {};
	    }

	    config = Merge$2(config, this.modalStyle);

	    var zeroButtonMode;
	    if (this.buttonMode === 0) {
	        if (this.hasAnyChoice()) {
	            zeroButtonMode = false;
	        } else {
	            zeroButtonMode = true;
	        }
	    } else {
	        zeroButtonMode = false;
	    }

	    if (!config.hasOwnProperty('anyTouchClose')) {
	        config.anyTouchClose = zeroButtonMode;
	    }

	    if (!config.hasOwnProperty('manualClose')) {
	        config.manualClose = !zeroButtonMode;
	    }

	    var self = this;
	    var onCloseWrap = function (data) {
	        var buttonIndex = data.index;
	        if (buttonIndex === self.confirmButtonIndex) {
	            self.emit('confirm', data);
	        } else if (buttonIndex === self.cancelButtonIndex) {
	            self.emit('cancel', data);
	        }

	        if (onClose) {
	            onClose(data);
	        }
	    };

	    ModalMethods$1.modal.call(this, config, onCloseWrap);

	    return this;
	};

	var SetButtonIndexMethods = {
	    setConfirmButtonIndex(index) {
	        this.confirmButtonIndex = index;
	        return this;
	    },

	    setCancelButtonIndex(index) {
	        this.cancelButtonIndex = index;
	        return this;
	    },
	};

	var Methods$1 = {
	    resetDisplayContent: ResetDisplayContent$1,
	    modal: Modal$1,
	};

	Object.assign(
	    Methods$1,
	    SetButtonIndexMethods,
	);

	var OnPointerOverCallback = function (button) {
	    if (button.setHoverState) {
	        button.setHoverState(true);
	    }
	};

	var OnPointerOutCallback = function (button) {
	    if (button.setHoverState) {
	        button.setHoverState(false);
	    }
	};

	var OnChoiceButtonStateChange = function (button, groupName, index, value) {
	    if (button.setActiveState) {
	        button.setActiveState(value);
	    }
	};

	var OnButtonEnable = function (button) {
	    if (button.setDisableState) {
	        button.setDisableState(false);
	    }
	};

	var OnButtonDisable = function (button) {
	    if (button.setDisableState) {
	        button.setDisableState(true);
	    }
	};

	var RegisterEvents = function () {
	    this
	        .on('button.over', OnPointerOverCallback)
	        .on('button.out', OnPointerOutCallback)
	        .on('button.enable', OnButtonEnable)
	        .on('button.disable', OnButtonDisable)
	        .on('button.statechange', OnChoiceButtonStateChange);

	};

	const GetValue$a = Phaser.Utils.Objects.GetValue;

	var CreateContent$1 = function (scene, config, creators) {
	    var type = GetValue$a(config, '$type');
	    if (type === undefined) {
	        if (config &&
	            (config.hasOwnProperty('slider') || config.hasOwnProperty('scroller'))
	        ) {
	            type = 'textarea';
	        }
	    }


	    var gameObject;
	    switch (type) {
	        case 'textarea':
	            gameObject = new CreateTextArea(scene, config, creators);
	            break;

	        default:
	            gameObject = new CreateLabel(scene, config, creators);
	            break;
	    }

	    scene.add.existing(gameObject);
	    return gameObject;
	};

	const GetValue$9 = Phaser.Utils.Objects.GetValue;

	class ConfirmDialog extends Dialog {
	    constructor(scene, config, creators) {
	        config = (config) ? DeepClone(config) : {};

	        if (creators === undefined) {
	            creators = {};
	        }

	        var createBackground = GetValue$9(creators, 'background', CreateBackground);
	        config.background = createBackground(scene, config.background);

	        config.title = CreateLabel(scene, config.title, creators.title);

	        config.content = CreateContent$1(scene, config.content, creators.content);
	        if (config.content instanceof TextArea) {
	            if (HasValue(config, 'height') && !HasValue(config, 'proportion.content')) {
	                SetValue(config, 'proportion.content', 1);
	            }
	        }

	        var defaultButtonConfig = config.button;
	        var buttonAConfig = config.buttonA || defaultButtonConfig;
	        var buttonBConfig = config.buttonB || defaultButtonConfig;
	        var buttonMode = config.buttonMode;
	        if (buttonMode === undefined) {
	            buttonMode = (!!buttonAConfig && !!buttonBConfig) ? 2 :
	                (!!buttonAConfig) ? 1 :
	                    0;
	        }

	        var defaultButtonCreator = creators.button;
	        var buttonACreators = creators.buttonA || defaultButtonCreator;
	        var buttonBCreators = creators.buttonB || defaultButtonCreator;
	        switch (buttonMode) {
	            case 2:
	                config.actions = [
	                    CreateLabel(scene, buttonAConfig, buttonACreators),
	                    CreateLabel(scene, buttonBConfig, buttonBCreators),
	                ];
	                break;

	            case 1:
	                config.actions = [
	                    CreateLabel(scene, buttonAConfig, buttonACreators),
	                ];
	                break;

	            case 0:
	                break;

	            default:
	                config.actions = [];
	                break;
	        }

	        var defaultChoiceConfig = config.choice;
	        if (defaultChoiceConfig) {
	            config.choices = [];
	        }

	        super(scene, config);
	        this.type = 'rexConfirmDialog';

	        this.buttonMode = buttonMode;

	        this.defaultActionConfig = defaultButtonConfig;
	        this.defaultActionButtonCreator = defaultButtonCreator;

	        this.defaultChoiceConfig = defaultChoiceConfig;
	        this.defaultChoiceCreator = creators.choice;

	        var buttons = this.childrenMap.actions;
	        this.addChildrenMap('buttonA', (buttons) ? buttons[0] : null);
	        this.addChildrenMap('buttonB', (buttons) ? buttons[1] : null);

	        // Interactive
	        RegisterEvents.call(this);

	        // Assign button index for comfirm, cancel events
	        this.setConfirmButtonIndex(GetValue$9(config, 'confirmButtonIndex', 0));
	        this.setCancelButtonIndex(GetValue$9(config, 'cancelButtonIndex', 1));

	        this.modalStyle = config.modal || {};
	    }
	}

	Object.assign(
	    ConfirmDialog.prototype,
	    Methods$1
	);

	var GenerateDefaultCreateGameObjectCallback$1 = function (
	    style,
	    {
	        viewport
	    } = {},
	    creators
	) {

	    return function (
	        scene,
	        {
	            vpw, vph,
	            width = 0, height = 0,
	            vpx = 0.5, vpy = 0.5,
	        } = {}
	    ) {

	        if (vpw !== undefined) {
	            width = viewport.width * vpw;
	        }

	        if (vph !== undefined) {
	            height = viewport.height * vph;
	        }

	        var gameObject = new ConfirmDialog(scene, style, creators);

	        gameObject
	            .setMinSize(width, height)
	            .setVisible(false);

	        scene.add.existing(gameObject);
	        AddViewportCoordinateProperties(gameObject, viewport);

	        gameObject.vpx = vpx;
	        gameObject.vpy = vpy;

	        AddShakeBehavior(gameObject);

	        return gameObject;
	    }
	};

	var Choice = function (
	    gameObject,
	    {
	        title = null,
	        content = null,
	        option1, option2, option3,
	        resultKey = 'choiceIndex'
	    } = {},

	    commandExecutor, eventSheetManager, eventSheet
	) {

	    var choices = [];
	    if (option1) { choices.push({ text: option1, value: 1 }); }
	    if (option2) { choices.push({ text: option2, value: 2 }); }
	    if (option3) { choices.push({ text: option3, value: 3 }); }

	    gameObject
	        .setVisible(true)
	        .resetDisplayContent({
	            title,
	            content,
	            choices,
	        })
	        .layout();

	    commandExecutor.waitEvent(gameObject, 'complete');

	    gameObject
	        .modalPromise({ destroy: false })
	        .then(function (data) {
	            eventSheetManager.setData(resultKey, data.value);
	            gameObject.emit('complete');
	        });

	};

	const GetValue$8 = Phaser.Utils.Objects.GetValue;
	const IsPlainObject$2 = Phaser.Utils.Objects.IsPlainObject;

	var RegisterChoiceDialogType = function (commandExecutor, config) {
	    var { viewport } = config;
	    var createGameObjectCallback = GetValue$8(config, `creators.${CHOICE}`, undefined);
	    if (createGameObjectCallback === false) {
	        return;
	    }

	    var creators;
	    if (IsPlainObject$2(createGameObjectCallback)) {
	        creators = createGameObjectCallback;
	        createGameObjectCallback = undefined;
	    }

	    if (createGameObjectCallback === undefined) {
	        var style = GetValue$8(config, `styles.${CHOICE}`, {});
	        createGameObjectCallback = GenerateDefaultCreateGameObjectCallback$1(
	            style,
	            {
	                viewport
	            },
	            creators
	        );
	    }

	    commandExecutor.addGameObjectManager({
	        name: CHOICE,
	        createGameObject: createGameObjectCallback,
	        fade: 0,  // No fade-in when creating/destroying gameobject
	        viewportCoordinate: { viewport },
	        defaultLayer: UILayer,

	        commands: {
	            choice: Choice,
	            shake: Shake,
	        }
	    });
	};

	var ResetDisplayContent = function (config) {
	    if (config === undefined) {
	        config = {};
	    }

	    ResetTitle.call(this, config);
	    ResetContent.call(this, config);
	    ResetActions.call(this, config);

	    return this;
	};

	var ResetTitle = function (config) {
	    var title = this.childrenMap.title;
	    if (config.title === null) {
	        this.hide(title);
	    } else {
	        this.show(title);

	        title.resetDisplayContent(config.title);
	    }
	};

	var ResetContent = function (config) {
	    var firstNameTitle = this.childrenMap.firstNameTitle;
	    if (config.firstNameTitle === null) {
	        this.hide(firstNameTitle);
	    } else {
	        this.show(firstNameTitle);

	        // Label
	        var firstNameTitleConfig = config.firstNameTitle || '';
	        firstNameTitle.resetDisplayContent(firstNameTitleConfig);
	    }

	    var firstNameInput = this.childrenMap.firstNameInput;
	    if (config.firstName === null) {
	        this.hide(firstNameInput);
	    } else {
	        this.show(firstNameInput);

	        // Text
	        var firstName = config.firstName || '';
	        firstNameInput.setText(firstName);
	    }

	    var lastNameTitle = this.childrenMap.lastNameTitle;
	    if (config.lastNameTitle === null) {
	        this.hide(lastNameTitle);
	    } else {
	        this.show(lastNameTitle);

	        // Label
	        var lastNameTitleConfig = config.lastNameTitle || '';
	        lastNameTitle.resetDisplayContent(lastNameTitleConfig);
	    }

	    var lastNameInput = this.childrenMap.lastNameInput;
	    if (config.lastName === null) {
	        this.hide(lastNameInput);
	    } else {
	        this.show(lastNameInput);

	        // Text
	        var lastName = config.lastName || '';
	        lastNameInput.setText(lastName);
	    }
	};

	var ResetActions = function (config) {
	    var action = this.childrenMap.actions[0];
	    if (config.button === null) {
	        this.hide(action);
	    } else {
	        this.show(action);
	        action.resetDisplayContent(config.button);
	    }
	};

	const Merge$1 = Phaser.Utils.Objects.Merge;

	var Modal = function (config, onClose) {
	    if (IsFunction(config)) {
	        onClose = config;
	        config = undefined;
	    }

	    if (config === undefined) {
	        config = {};
	    }

	    config = Merge$1(config, this.modalStyle);
	    config.anyTouchClose = false;
	    config.manualClose = false;

	    var self = this;
	    var onCloseWrap = function (data) {
	        data.firstName = self.firstName;
	        data.lastName = self.lastName;

	        self.emit('confirm', data);
	        if (onClose) {
	            onClose(data);
	        }
	    };

	    ModalMethods$1.modal.call(this, config, onCloseWrap);

	    return this;
	};

	var methods = {
	    resetDisplayContent: ResetDisplayContent,
	    modal: Modal,
	};

	const ElementProperties = {
	    maxLength: ['maxLength', undefined],
	    minLength: ['minLength', undefined],
	    readOnly: ['readOnly', false],
	};

	const StyleProperties = {
	    direction: ['direction', undefined]
	};

	var CopyProperty = function (from, to, key) {
	    if (typeof (key) === 'string') {
	        if (from.hasOwnProperty(key)) {
	            to[key] = from[key];
	        }
	    } else {
	        var keys = key;
	        if (Array.isArray(keys)) {
	            for (var i = 0, cnt = keys.length; i < cnt; i++) {
	                CopyProperty(from, to, keys[i]);
	            }
	        } else {
	            for (var key in keys) {
	                CopyProperty(from, to, key);
	            }
	        }
	    }
	};

	var CopyElementConfig = function (from) {
	    if (from === undefined) {
	        from = {};
	    }
	    var to = {};

	    CopyProperty(from, to, 'inputType');
	    CopyProperty(from, to, 'type');
	    CopyProperty(from, to, 'style');
	    CopyProperty(from, to, StyleProperties);
	    CopyProperty(from, to, ElementProperties);

	    return to;
	};

	var LastOpenedEditor = undefined;

	var SetLastOpenedEditor = function (editor) {
	    if (editor === LastOpenedEditor) {
	        return;
	    }

	    if (LastOpenedEditor !== undefined) {
	        LastOpenedEditor.close();
	    }

	    LastOpenedEditor = editor;
	};

	var CloseLastOpenEditor = function (editor) {
	    if (editor !== LastOpenedEditor) {
	        return;
	    }

	    // Don't call `LastOpenedEditor.close()`
	    LastOpenedEditor = undefined;
	};

	const GetValue$7 = Phaser.Utils.Objects.GetValue;

	var SetProperties = function (properties, config, out) {
	    if (out === undefined) {
	        out = {};
	    }

	    var property, value;
	    for (var key in properties) {
	        property = properties[key];  // [propName, defaultValue]
	        value = GetValue$7(config, key, property[1]);
	        if (value !== undefined) {
	            out[property[0]] = value;
	        }
	    }

	    return out;
	};

	var StopPropagationTouchEvents = function (element) {
	    // Don't propagate touch/mouse events to parent(game canvas)
	    element.addEventListener('touchstart', callback, false);
	    element.addEventListener('touchmove', callback, false);
	    element.addEventListener('touchend', callback, false);
	    element.addEventListener('mousedown', callback, false);
	    element.addEventListener('mouseup', callback, false);
	    element.addEventListener('mousemove', callback, false);
	};

	var callback = function (e) {
	    e.stopPropagation();
	};

	var EnterClose = function () {
	    this.close();
	    this.emit('keydown-ENTER', this.parent, this);
	    return this;
	};

	var OnOpen = function () {
	    this.isOpened = true;

	    this.initText();

	    if (this.enterCloseEnable) {
	        this.scene.input.keyboard.once('keydown-ENTER', EnterClose, this);
	    }

	    // There is no cursor-position-change event, 
	    // so updating cursor position every tick
	    this.scene.sys.events.on('postupdate', this.updateText, this);

	    if (this.clickOutSideTarget) {
	        MoveMyDepthAbove.call(this.clickOutSideTarget, this.parent);
	        MoveMyDepthBelow.call(this.clickOutSideTarget, this.parent);

	        this.clickOutSideTarget
	            .setInteractive()
	            .on('pointerdown', this.onClickOutside, this);

	    } else {
	        this.scene.input.on('pointerdown', this.onClickOutside, this);
	    }

	    if (this.onOpenCallback) {
	        this.onOpenCallback(this.parent, this);
	    }

	    this.emit('open', this);
	};

	var RemoveElement = function (element) {
	    if (!element) {
	        return;
	    }

	    var parentElement = element.parentElement;
	    if (parentElement) {
	        parentElement.removeChild(element);
	    }
	};

	var OnClose = function () {

	    this.isOpened = false;

	    this.updateText();

	    if (this.enterCloseEnable) {
	        this.scene.input.keyboard.off('keydown-ENTER', EnterClose, this);
	    }

	    this.scene.sys.events.off('postupdate', this.updateText, this);

	    if (this.clickOutSideTarget) {
	        this.clickOutSideTarget
	            .disableInteractive()
	            .off('pointerdown', this.onClickOutside, this);

	    } else {
	        this.scene.input.off('pointerdown', this.onClickOutside, this);

	    }

	    if (this.onCloseCallback) {
	        this.onCloseCallback(this.parent, this);
	    }

	    // Remove input text element when closing editor
	    RemoveElement(this.node);
	    this.node = undefined;

	    this.emit('close', this);

	};

	const GetValue$6 = Phaser.Utils.Objects.GetValue;

	var CreateElement = function (parent, config) {
	    var element;
	    var textType = GetValue$6(config, 'inputType', undefined);
	    if (textType === undefined) {
	        textType = GetValue$6(config, 'type', 'text');
	    }
	    if (textType === 'textarea') {
	        element = document.createElement('textarea');
	        element.style.resize = 'none';
	    } else {
	        element = document.createElement('input');
	        element.type = textType;
	    }

	    var style = GetValue$6(config, 'style', undefined);
	    // Apply other style properties
	    var elementStyle = element.style;
	    SetProperties(StyleProperties, style, elementStyle);
	    // Set style
	    elementStyle.position = 'absolute';
	    elementStyle.opacity = 0;
	    elementStyle.pointerEvents = 'none';
	    elementStyle.zIndex = 0;
	    // hide native blue text cursor on iOS
	    elementStyle.transform = 'scale(0)';

	    SetProperties(ElementProperties, config, element);

	    // Don't propagate touch/mouse events to parent(game canvas)
	    StopPropagationTouchEvents(element);

	    // Attach element to fullscreenTarget in full screen mode
	    var scaleManager = parent.scene.sys.scale;
	    var parentElement = (scaleManager.isFullscreen) ? scaleManager.fullscreenTarget : document.body;
	    parentElement.appendChild(element);

	    // open() -> 'focus' -> OnOpen
	    element.addEventListener('focus', function (e) {
	        OnOpen.call(parent);
	    });

	    // close() -> 'blur' -> OnClose
	    element.addEventListener('blur', function (e) {
	        OnClose.call(parent);
	    });

	    return element;
	};

	var Open = function () {
	    // Already opened
	    if (this.isOpened) {
	        return this;
	    }
	    // Read only
	    if (this.readOnly) {
	        return this;
	    }

	    SetLastOpenedEditor(this);

	    if (!this.node) {
	        // Create input text element when opening editor
	        this.node = CreateElement(this, this.nodeConfig);
	        // Register 'focus', 'blur' events
	    }

	    this.setFocus();

	    // 'focus' event -> OnOpen

	    return this;
	};

	var Close = function () {
	    // Already closed
	    if (!this.isOpened) {
	        return this;
	    }

	    CloseLastOpenEditor(this);

	    this.setBlur();

	    // 'blur' event -> OnOpen

	    return this;
	};

	var Methods = {
	    open: Open,
	    close: Close,
	};

	const GetValue$5 = Phaser.Utils.Objects.GetValue;

	class HiddenTextEditBase extends ComponentBase {
	    constructor(gameObject, config) {
	        super(gameObject);
	        // this.parent = gameObject;

	        var textType = GetValue$5(config, 'inputType', undefined);
	        if (textType === undefined) {
	            textType = GetValue$5(config, 'type', 'text');
	        }

	        this.setEnterCloseEnable(GetValue$5(config, 'enterClose', (textType !== 'textarea')));

	        var onOpen = GetValue$5(config, 'onOpen', undefined);
	        if (!onOpen) {
	            onOpen = GetValue$5(config, 'onFocus', undefined);
	        }
	        this.onOpenCallback = onOpen;

	        this.clickOutSideTarget = GetValue$5(config, 'clickOutSideTarget', undefined);

	        var onClose = GetValue$5(config, 'onClose', undefined);
	        if (!onClose) {
	            onClose = GetValue$5(config, 'onBlur', undefined);
	        }
	        this.onCloseCallback = onClose;

	        this.onUpdateCallback = GetValue$5(config, 'onUpdate', undefined);

	        this.isOpened = false;

	        gameObject
	            .on('pointerdown', function () {
	                this.open();
	            }, this)
	            .setInteractive();

	        this.nodeConfig = CopyElementConfig(config);
	        // Create/remove input text element when opening/closing editor
	        this.node = undefined;
	    }

	    destroy() {
	        // this.parent.off('pointerdown', this.open, this);

	        this.close();

	        if (this.clickOutSideTarget) {
	            this.clickOutSideTarget.destroy();
	        }

	        super.destroy();
	    }

	    onClickOutside(pointer) {
	        if (!IsPointerInHitArea(this.parent, pointer)) {
	            this.close();
	        }
	    }

	    setEnterCloseEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }
	        this.enterCloseEnable = enable;
	        return this;
	    }

	    // Override
	    initText() {
	    }

	    // Override, invoking under 'postupdate' event of scene
	    updateText() {
	    }

	    // Copy from InputText class
	    get text() {
	        if (!this.node) {
	            return '';
	        }
	        return this.node.value;
	    }

	    set text(value) {
	        if (!this.node) {
	            return;
	        }
	        this.node.value = value;
	    }

	    setText(value) { // Override
	        this.text = value;
	        return this;
	    }

	    get maxLength() {
	        return this.nodeConfig.maxLength;
	    }

	    set maxLength(value) {
	        this.nodeConfig.maxLength = value;

	        if (this.node) {
	            this.node.maxLength = value;
	        }
	    }

	    setMaxLength(value) {
	        this.maxLength = value;
	        return this;
	    }

	    get minLength() {
	        return this.nodeConfig.minLength;
	    }

	    set minLength(value) {
	        this.nodeConfig.minLength = value;

	        if (this.node) {
	            this.node.minLength = value;
	        }
	    }

	    setMinLength(value) {
	        this.minLength = value;
	        return this;
	    }

	    get placeholder() {
	        return this.node.placeholder;
	    }

	    set placeholder(value) {
	        if (!this.node) {
	            return;
	        }
	        this.node.placeholder = value;
	    }

	    setPlaceholder(value) {
	        this.placeholder = value;
	        return this;
	    }

	    selectText(selectionStart, selectionEnd) {
	        if (!this.node) {
	            return this;
	        }
	        if (selectionStart === undefined) {
	            this.node.select();
	        } else {
	            this.node.setSelectionRange(selectionStart, selectionEnd);
	        }
	        return this;
	    }

	    selectAll() {
	        this.selectText();
	        return this;
	    }

	    get selectionStart() {
	        if (!this.node) {
	            return 0;
	        }
	        return this.node.selectionStart;
	    }

	    get selectionEnd() {
	        if (!this.node) {
	            return 0;
	        }
	        return this.node.selectionEnd;
	    }

	    get selectedText() {
	        if (!this.node) {
	            return '';
	        }
	        var node = this.node;
	        return node.value.substring(node.selectionStart, node.selectionEnd);
	    }

	    get cursorPosition() {
	        if (!this.node) {
	            return 0;
	        }
	        return this.node.selectionStart;
	    }

	    set cursorPosition(value) {
	        if (!this.node) {
	            return;
	        }
	        this.node.setSelectionRange(value, value);
	    }

	    setCursorPosition(value) {
	        if (value === undefined) {
	            value = this.text.length;
	        } else if (value < 0) {
	            value = this.text.length + value;
	        }

	        this.cursorPosition = value;
	        return this;
	    }

	    get tooltip() {
	        if (!this.node) {
	            return '';
	        }
	        return this.node.title;
	    }

	    set tooltip(value) {
	        if (!this.node) {
	            return this;
	        }
	        this.node.title = value;
	    }

	    setTooltip(value) {
	        this.tooltip = value;
	        return this;
	    }

	    setTextChangedCallback(callback) {
	        this.onTextChanged = callback;
	        return this;
	    }

	    get readOnly() {
	        return this.nodeConfig.readOnly;
	    }

	    set readOnly(value) {
	        this.nodeConfig.readOnly = value;

	        if (this.node) {
	            this.node.readOnly = value;
	        }
	    }

	    setReadOnly(value) {
	        if (value === undefined) {
	            value = true;
	        }
	        this.readOnly = value;
	        return this;
	    }

	    get spellCheck() {
	        if (!this.node) {
	            return '';
	        }
	        return this.node.spellcheck;
	    }

	    set spellCheck(value) {
	        if (!this.node) {
	            return;
	        }
	        this.node.spellcheck = value;
	    }

	    setSpellCheck(value) {
	        this.spellCheck = value;
	        return this;
	    }

	    get fontColor() {
	        if (!this.node) {
	            return undefined;
	        }
	        return this.node.style.color;
	    }

	    set fontColor(value) {
	        if (!this.node) {
	            return;
	        }
	        this.node.style.color = value;
	    }

	    setFontColor(value) {
	        this.fontColor = value;
	        return this;
	    }

	    setStyle(key, value) {
	        if (!this.node) {
	            return this;
	        }
	        this.node.style[key] = value;
	        return this;
	    }

	    getStyle(key) {
	        if (!this.node) {
	            return undefined;
	        }
	        return this.node.style[key];
	    }

	    scrollToBottom() {
	        if (!this.node) {
	            return this;
	        }
	        this.node.scrollTop = this.node.scrollHeight;
	        return this;
	    }

	    setEnabled(enabled) {
	        if (!this.node) {
	            return this;
	        }
	        if (enabled === undefined) {
	            enabled = true;
	        }
	        this.node.disabled = !enabled;
	        return this;
	    }

	    setBlur() {
	        if (!this.node) {
	            return this;
	        }
	        this.node.blur();
	        return this;
	    }

	    setFocus() {
	        if (!this.node) {
	            return this;
	        }
	        this.node.focus();
	        return this;
	    }

	    get isFocused() {
	        return this.isOpened;
	    }
	}

	Object.assign(
	    HiddenTextEditBase.prototype,
	    Methods,
	);

	var NumberInputUpdateCallback = function (text, textObject, hiddenInputText) {
	    text = text.replace(' ', '');
	    var previousText = hiddenInputText.previousText;
	    if (text === previousText) {
	        return text;
	    }

	    if (isNaN(text)) {
	        // Enter a NaN character, back to previous text
	        hiddenInputText.emit('nan', text, hiddenInputText);

	        text = previousText;
	        var cursorPosition = hiddenInputText.cursorPosition - 1;
	        hiddenInputText.setText(text);
	        hiddenInputText.setCursorPosition(cursorPosition);
	    } else {
	        // New number text, update previous texr
	        hiddenInputText.previousText = text;
	    }

	    return text;
	};

	var SelectRange = function (hiddenTextEdit) {
	    var textObject = hiddenTextEdit.parent;
	    // var text = textObject.text;
	    var selectionStart = (hiddenTextEdit.isOpened) ? hiddenTextEdit.selectionStart : null;
	    var selectionEnd = (hiddenTextEdit.isOpened) ? hiddenTextEdit.selectionEnd : null;
	    var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
	    var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;

	    if ((prevSelectionStart === selectionStart) && (prevSelectionEnd === selectionEnd)) {
	        return;
	    }

	    var min, max;
	    if (prevSelectionStart === null) {
	        min = selectionStart;
	        max = selectionEnd;
	    } else if (selectionStart === null) {
	        min = prevSelectionStart;
	        max = prevSelectionEnd;
	    } else {
	        min = Math.min(prevSelectionStart, selectionStart);
	        max = Math.max(prevSelectionEnd, selectionEnd);
	    }

	    for (var i = min; i < max; i++) {
	        var inPrevSelectionRange;
	        if (prevSelectionStart === null) {
	            inPrevSelectionRange = false;
	        } else {
	            inPrevSelectionRange = (i >= prevSelectionStart) && (i < prevSelectionEnd);
	        }

	        var inSelectionRange;
	        if (selectionStart === null) {
	            inSelectionRange = false;
	        } else {
	            inSelectionRange = (i >= selectionStart) && (i < selectionEnd);
	        }

	        if (inPrevSelectionRange === inSelectionRange) {
	            continue;
	        }

	        var child = textObject.getCharChild(i);
	        if (child) {
	            var eventName = (inPrevSelectionRange) ? 'rangeout' : 'rangein';
	            textObject.emit(eventName, child, i, textObject);
	        }
	    }

	    hiddenTextEdit.prevSelectionStart = selectionStart;
	    hiddenTextEdit.prevSelectionEnd = selectionEnd;
	};

	var ScrollToBob = function (bob) {
	    var textObject = bob.parent;
	    var textObjectLeftX = 0,
	        textObjectRightX = textObject.width,
	        textObjectTopY = 0,
	        textObjectBottomY = textObject.height;

	    var childX = bob.drawX,
	        childY = bob.drawY;
	    var childLeftX = childX + bob.drawTLX,
	        childRightX = childX + bob.drawTRX,
	        childTopY = childY + bob.drawTLY,
	        childBottomY = childY + bob.drawBLY;

	    var dx;
	    if (childLeftX < textObjectLeftX) {
	        dx = textObjectLeftX - childLeftX;
	    } else if (childRightX > textObjectRightX) {
	        dx = textObjectRightX - childRightX;
	    } else {
	        dx = 0;
	    }

	    var dy;
	    if (childTopY < textObjectTopY) {
	        dy = textObjectTopY - childTopY;
	    } else if (childBottomY > textObjectBottomY) {
	        dy = textObjectBottomY - childBottomY;
	    } else {
	        dy = 0;
	    }

	    textObject._textOX += dx;
	    textObject._textOY += dy;

	};

	var MoveCursor = function (hiddenTextEdit) {
	    var textObject = hiddenTextEdit.parent;
	    var text = textObject.text;

	    if (hiddenTextEdit.requestCursorPosition !== null) {
	        hiddenTextEdit.setCursorPosition(hiddenTextEdit.requestCursorPosition);
	        hiddenTextEdit.requestCursorPosition = null;
	    }

	    var cursorPosition = hiddenTextEdit.cursorPosition;
	    if (hiddenTextEdit.prevCursorPosition === cursorPosition) {
	        return;
	    }

	    if (hiddenTextEdit.prevCursorPosition !== null) {
	        if (hiddenTextEdit.prevCursorPosition > text.length) {
	            hiddenTextEdit.prevCursorPosition = null;
	        }
	    }

	    if (hiddenTextEdit.prevCursorPosition !== null) {
	        var child = textObject.getCharChild(hiddenTextEdit.prevCursorPosition);
	        if (child) {
	            // Rollback size of new line child
	            if (child.text === '\n') {
	                child.clearTextSize();
	            }
	            textObject.emit('cursorout', child, hiddenTextEdit.prevCursorPosition, textObject);
	        }
	    }
	    if (cursorPosition != null) {
	        var child = textObject.getCharChild(cursorPosition);
	        if (child) {
	            // Display new line child
	            if (child.text === '\n') {
	                child.copyTextSize(textObject.lastInsertCursor);
	            }

	            ScrollToBob(child);

	            textObject.emit('cursorin', child, cursorPosition, textObject);
	        }
	    }
	    textObject.emit('movecursor', cursorPosition, hiddenTextEdit.prevCursorPosition, textObject);

	    hiddenTextEdit.prevCursorPosition = cursorPosition;
	};

	var ClearSelectRange = function (hiddenTextEdit) {
	    var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
	    if (prevSelectionStart === null) {
	        return;
	    }

	    var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;

	    var textObject = hiddenTextEdit.parent;
	    for (var i = prevSelectionStart; i < prevSelectionEnd; i++) {
	        var child = textObject.getCharChild(i);
	        if (child) {
	            textObject.emit('cursorout', child, i, textObject);
	        }
	    }

	    hiddenTextEdit.prevSelectionStart = null;
	    hiddenTextEdit.prevSelectionEnd = null;
	};

	var ClearCursor = function (hiddenTextEdit) {
	    var prevCursorPosition = hiddenTextEdit.prevCursorPosition;
	    if (prevCursorPosition === null) {
	        return;
	    }

	    var textObject = hiddenTextEdit.parent;

	    var child = textObject.getCharChild(prevCursorPosition);
	    if (child) {
	        textObject.emit('cursorout', child, prevCursorPosition, textObject);
	    }

	    hiddenTextEdit.prevCursorPosition = null;
	};

	const GetValue$4 = Phaser.Utils.Objects.GetValue;

	class HiddenTextEdit extends HiddenTextEditBase {
	    constructor(gameObject, config) {
	        super(gameObject, config);
	        // this.parent = gameObject;

	        this.setSelectAllWhenFocusEnable(GetValue$4(config, 'selectAll', false));

	        this.cursorMoveStartIndex = null;
	        this.prevCursorPosition = null;
	        this.prevSelectionStart = null;
	        this.prevSelectionEnd = null;
	        this.firstClickAfterOpen = false;
	        this.requestCursorPosition = null;


	        gameObject
	            // Open editor by 'pointerdown' event
	            // Then set cursor position to nearest char
	            .on('pointerdown', function (pointer, localX, localY, event) {
	                var child = gameObject.getNearestChild(localX, localY);
	                var charIndex = gameObject.getCharIndex(child);

	                if (!this.selectAllWhenFocus || !this.firstClickAfterOpen) {
	                    this.setCursorPosition(charIndex);
	                }

	                this.cursorMoveStartIndex = charIndex;
	                this.firstClickAfterOpen = false;
	            }, this)
	            .on('pointermove', function (pointer, localX, localY, event) {
	                if (!pointer.isDown) {
	                    return;
	                }
	                var child = gameObject.getNearestChild(localX, localY);
	                var charIndex = gameObject.getCharIndex(child);
	                if (this.cursorMoveStartIndex < charIndex) {
	                    this.selectText(this.cursorMoveStartIndex, charIndex + 1);
	                } else {
	                    this.selectText(charIndex, this.cursorMoveStartIndex + 1);
	                }
	            }, this);

	        this
	            .on('open', function () {
	                if (this.selectAllWhenFocus) {
	                    this.selectAll();
	                }
	                this.firstClickAfterOpen = true;

	                gameObject.emit('open');
	            }, this)
	            .on('close', function () {
	                // Route 'close' event
	                gameObject.emit('close');
	            })
	            .on('keydown-ENTER', function () {
	                // Route 'keydown-ENTER' event
	                gameObject.emit('keydown-ENTER');
	            });

	    }

	    initText() {
	        var textObject = this.parent;
	        this.prevCursorPosition = null;
	        this.setText(textObject.text);
	        return this;
	    }

	    updateText() {
	        var textObject = this.parent;

	        var text = this.text;
	        if (this.onUpdateCallback) {
	            var newText = this.onUpdateCallback(text, textObject, this);
	            if (newText != null) {
	                text = newText;
	            }
	        }

	        if (textObject.text !== text) {
	            textObject.setText(text);
	        }

	        if (this.isOpened) {
	            if (this.selectionStart !== this.selectionEnd) {
	                ClearCursor(this);
	                SelectRange(this);
	            } else {
	                ClearSelectRange(this);
	                MoveCursor(this);
	            }
	        } else {
	            ClearSelectRange(this);
	            ClearCursor(this);
	        }

	        return this;
	    }

	    setNumberInput() {
	        this.onUpdateCallback = NumberInputUpdateCallback;
	        return this;
	    }

	    setSelectAllWhenFocusEnable(enable) {
	        if (enable === undefined) {
	            enable = true;
	        }

	        this.selectAllWhenFocus = enable;
	        return this;
	    }

	    setRequestCursorPosition(value) {
	        if (!this.isOpened) {
	            return this;
	        }

	        this.requestCursorPosition = value;
	        return this;
	    }
	}

	const GetValue$3 = Phaser.Utils.Objects.GetValue;
	const PropertiesList = [
	    'inputType',
	    'onOpen', 'clickOutSideTarget', 'onFocus', 'onClose', 'onBlur', 'onUpdate',
	    'enterClose',
	    'readOnly', 'maxLength', 'minLength', 'selectAll'
	];

	var CreateHiddenTextEdit = function (parent, parentConfig) {
	    var config = GetValue$3(parentConfig, 'edit');
	    if (config === undefined) {
	        config = {};
	    }

	    CopyProperty(parentConfig, config, PropertiesList);

	    return new HiddenTextEdit(parent, config);
	};

	var InjectDefaultConfig = function (scene, config) {
	    var isSingleLineMode = !config.textArea;

	    if (!HasValue(config, 'wrap.vAlign')) {
	        var defaultValue = (isSingleLineMode) ? 'center' : 'top';
	        SetValue(config, 'wrap.vAlign', defaultValue);
	    }

	    if (!HasValue(config, 'wrap.wrapMode')) {
	        SetValue(config, 'wrap.wrapMode', 'char');
	    }

	    if (!HasValue(config, 'wrap.maxLines')) {
	        var defaultValue = (isSingleLineMode) ? 1 : undefined;
	        SetValue(config, 'wrap.maxLines', defaultValue);
	    }

	    if (isSingleLineMode) {
	        SetValue(config, 'wrap.wrapWidth', Infinity);
	    }

	    if (!HasValue(config, 'wrap.useDefaultTextHeight')) {
	        SetValue(config, 'wrap.useDefaultTextHeight', true);
	    }

	    if (!config.edit) {
	        config.edit = {};
	    }
	    if (!HasValue(config.edit, 'inputType')) {
	        var defaultValue = (isSingleLineMode) ? 'text' : 'textarea';
	        SetValue(config.edit, 'inputType', defaultValue);
	    }

	    if (config.clickOutSideTarget === true) {
	        var clickOutSideTarget = new FullWindowRectangle$1(scene);
	        scene.add.existing(clickOutSideTarget);

	        config.clickOutSideTarget = clickOutSideTarget;
	    }

	    return config;
	};

	var RegisterArrowKeysEvent = function () {
	    var keyEventManager = this.scene.input.keyboard;
	    this.textEdit
	        .on('open', function () {
	            keyEventManager
	                .on('keydown-UP', this.cursorMoveUp, this)
	                .on('keydown-DOWN', this.cursorMoveDown, this);
	        }, this)
	        .on('close', function () {
	            keyEventManager
	                .off('keydown-UP', this.cursorMoveUp, this)
	                .off('keydown-DOWN', this.cursorMoveDown, this);
	        }, this);

	};

	var RegisterCursorStyle = function (cursorStyle) {
	    if (IsEmpty(cursorStyle)) {
	        return;
	    }

	    this
	        .setCursorStyle(cursorStyle)
	        .on('cursorin', function (child) {
	            var cursorStyle = this.cursorStyle;
	            var styleSave = GetPartialData(child.style, cursorStyle);
	            if (IsKeyValueEqual(cursorStyle, styleSave)) {
	                return;
	            }

	            child.styleSave = styleSave;
	            child.modifyStyle(cursorStyle);
	        }, this)
	        .on('cursorout', function (child) {
	            if (!child.styleSave) {
	                return;
	            }

	            child.modifyStyle(child.styleSave);
	            child.styleSave = undefined;
	        }, this);
	};

	var RegisterRangeStyle = function (rangeStyle) {
	    if (IsEmpty(rangeStyle)) {
	        return;
	    }

	    this
	        .setRangeStyle(rangeStyle)
	        .on('rangein', function (child) {
	            var rangeStyle = this.rangeStyle;
	            var styleSave = GetPartialData(child.style, rangeStyle);
	            if (IsKeyValueEqual(rangeStyle, styleSave)) {
	                return;
	            }

	            child.styleSave = styleSave;
	            child.modifyStyle(rangeStyle);
	        }, this)
	        .on('rangeout', function (child) {
	            if (!child.styleSave) {
	                return;
	            }

	            child.modifyStyle(child.styleSave);
	            child.styleSave = undefined;
	        }, this);
	};

	var RegisterFocusStyle = function (focusStyle) {
	    if (IsEmpty(focusStyle)) {
	        return;
	    }

	    this
	        .setFocusStyle(focusStyle)
	        .on('open', function () {
	            var child = this.background;
	            var focusStyle = this.focusStyle;
	            var styleSave = GetPartialData(child, focusStyle);
	            if (IsKeyValueEqual(focusStyle, styleSave)) {
	                return;
	            }

	            child.styleSave = styleSave;
	            child.modifyStyle(focusStyle);
	        }, this)
	        .on('close', function () {
	            var child = this.background;

	            if (!child.styleSave) {
	                return;
	            }

	            child.modifyStyle(child.styleSave);
	            child.styleSave = undefined;
	        }, this);
	};

	var CreateInsertCursorChild = function (textObject) {
	    var child = textObject.createCharChild('|');  // Use '|' to update render size
	    child.text = '';  // Render empty string ''

	    return child;
	};

	function Diff() {}

	Diff.prototype = {
	  diff(oldString, newString, options = {}) {
	    let callback = options.callback;
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }
	    this.options = options;

	    let self = this;

	    function done(value) {
	      if (callback) {
	        setTimeout(function() { callback(undefined, value); }, 0);
	        return true;
	      } else {
	        return value;
	      }
	    }

	    // Allow subclasses to massage the input prior to running
	    oldString = this.castInput(oldString);
	    newString = this.castInput(newString);

	    oldString = this.removeEmpty(this.tokenize(oldString));
	    newString = this.removeEmpty(this.tokenize(newString));

	    let newLen = newString.length, oldLen = oldString.length;
	    let editLength = 1;
	    let maxEditLength = newLen + oldLen;
	    if(options.maxEditLength) {
	      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
	    }

	    let bestPath = [{ newPos: -1, components: [] }];

	    // Seed editLength = 0, i.e. the content starts with the same values
	    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
	    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
	      // Identity per the equality and tokenizer
	      return done([{value: this.join(newString), count: newString.length}]);
	    }

	    // Main worker method. checks all permutations of a given edit length for acceptance.
	    function execEditLength() {
	      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
	        let basePath;
	        let addPath = bestPath[diagonalPath - 1],
	            removePath = bestPath[diagonalPath + 1],
	            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
	        if (addPath) {
	          // No one else is going to attempt to use this value, clear it
	          bestPath[diagonalPath - 1] = undefined;
	        }

	        let canAdd = addPath && addPath.newPos + 1 < newLen,
	            canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
	        if (!canAdd && !canRemove) {
	          // If this path is a terminal then prune
	          bestPath[diagonalPath] = undefined;
	          continue;
	        }

	        // Select the diagonal that we want to branch from. We select the prior
	        // path whose position in the new string is the farthest from the origin
	        // and does not pass the bounds of the diff graph
	        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
	          basePath = clonePath(removePath);
	          self.pushComponent(basePath.components, undefined, true);
	        } else {
	          basePath = addPath; // No need to clone, we've pulled it from the list
	          basePath.newPos++;
	          self.pushComponent(basePath.components, true, undefined);
	        }

	        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

	        // If we have hit the end of both strings, then we are done
	        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
	          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
	        } else {
	          // Otherwise track this path as a potential candidate and continue.
	          bestPath[diagonalPath] = basePath;
	        }
	      }

	      editLength++;
	    }

	    // Performs the length of edit iteration. Is a bit fugly as this has to support the
	    // sync and async mode which is never fun. Loops over execEditLength until a value
	    // is produced, or until the edit length exceeds options.maxEditLength (if given),
	    // in which case it will return undefined.
	    if (callback) {
	      (function exec() {
	        setTimeout(function() {
	          if (editLength > maxEditLength) {
	            return callback();
	          }

	          if (!execEditLength()) {
	            exec();
	          }
	        }, 0);
	      }());
	    } else {
	      while (editLength <= maxEditLength) {
	        let ret = execEditLength();
	        if (ret) {
	          return ret;
	        }
	      }
	    }
	  },

	  pushComponent(components, added, removed) {
	    let last = components[components.length - 1];
	    if (last && last.added === added && last.removed === removed) {
	      // We need to clone here as the component clone operation is just
	      // as shallow array clone
	      components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };
	    } else {
	      components.push({count: 1, added: added, removed: removed });
	    }
	  },
	  extractCommon(basePath, newString, oldString, diagonalPath) {
	    let newLen = newString.length,
	        oldLen = oldString.length,
	        newPos = basePath.newPos,
	        oldPos = newPos - diagonalPath,

	        commonCount = 0;
	    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
	      newPos++;
	      oldPos++;
	      commonCount++;
	    }

	    if (commonCount) {
	      basePath.components.push({count: commonCount});
	    }

	    basePath.newPos = newPos;
	    return oldPos;
	  },

	  equals(left, right) {
	    if (this.options.comparator) {
	      return this.options.comparator(left, right);
	    } else {
	      return left === right
	        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());
	    }
	  },
	  removeEmpty(array) {
	    let ret = [];
	    for (let i = 0; i < array.length; i++) {
	      if (array[i]) {
	        ret.push(array[i]);
	      }
	    }
	    return ret;
	  },
	  castInput(value) {
	    return value;
	  },
	  tokenize(value) {
	    return value.split('');
	  },
	  join(chars) {
	    return chars.join('');
	  }
	};

	function buildValues(diff, components, newString, oldString, useLongestToken) {
	  let componentPos = 0,
	      componentLen = components.length,
	      newPos = 0,
	      oldPos = 0;

	  for (; componentPos < componentLen; componentPos++) {
	    let component = components[componentPos];
	    if (!component.removed) {
	      if (!component.added && useLongestToken) {
	        let value = newString.slice(newPos, newPos + component.count);
	        value = value.map(function(value, i) {
	          let oldValue = oldString[oldPos + i];
	          return oldValue.length > value.length ? oldValue : value;
	        });

	        component.value = diff.join(value);
	      } else {
	        component.value = diff.join(newString.slice(newPos, newPos + component.count));
	      }
	      newPos += component.count;

	      // Common case
	      if (!component.added) {
	        oldPos += component.count;
	      }
	    } else {
	      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
	      oldPos += component.count;

	      // Reverse add and remove so removes are output first to match common convention
	      // The diffing algorithm is tied to add then remove output and this is the simplest
	      // route to get the desired output with minimal overhead.
	      if (componentPos && components[componentPos - 1].added) {
	        let tmp = components[componentPos - 1];
	        components[componentPos - 1] = components[componentPos];
	        components[componentPos] = tmp;
	      }
	    }
	  }

	  // Special case handle for when one terminal is ignored (i.e. whitespace).
	  // For this case we merge the terminal into the prior string and drop the change.
	  // This is only available for string mode.
	  let lastComponent = components[componentLen - 1];
	  if (componentLen > 1
	      && typeof lastComponent.value === 'string'
	      && (lastComponent.added || lastComponent.removed)
	      && diff.equals('', lastComponent.value)) {
	    components[componentLen - 2].value += lastComponent.value;
	    components.pop();
	  }

	  return components;
	}

	function clonePath(path) {
	  return { newPos: path.newPos, components: path.components.slice(0) };
	}

	const characterDiff = new Diff();
	function diffChars(oldStr, newStr, options) { return characterDiff.diff(oldStr, newStr, options); }

	// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
	//
	// Ranges and exceptions:
	// Latin-1 Supplement, 0080–00FF
	//  - U+00D7  × Multiplication sign
	//  - U+00F7  ÷ Division sign
	// Latin Extended-A, 0100–017F
	// Latin Extended-B, 0180–024F
	// IPA Extensions, 0250–02AF
	// Spacing Modifier Letters, 02B0–02FF
	//  - U+02C7  ˇ &#711;  Caron
	//  - U+02D8  ˘ &#728;  Breve
	//  - U+02D9  ˙ &#729;  Dot Above
	//  - U+02DA  ˚ &#730;  Ring Above
	//  - U+02DB  ˛ &#731;  Ogonek
	//  - U+02DC  ˜ &#732;  Small Tilde
	//  - U+02DD  ˝ &#733;  Double Acute Accent
	// Latin Extended Additional, 1E00–1EFF
	const extendedWordChars = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;

	const reWhitespace = /\S/;

	const wordDiff = new Diff();
	wordDiff.equals = function(left, right) {
	  if (this.options.ignoreCase) {
	    left = left.toLowerCase();
	    right = right.toLowerCase();
	  }
	  return left === right || (this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));
	};
	wordDiff.tokenize = function(value) {
	  // All whitespace symbols except newline group into one token, each newline - in separate token
	  let tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);

	  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
	  for (let i = 0; i < tokens.length - 1; i++) {
	    // If we have an empty string in the next field and we have only word chars before and after, merge
	    if (!tokens[i + 1] && tokens[i + 2]
	          && extendedWordChars.test(tokens[i])
	          && extendedWordChars.test(tokens[i + 2])) {
	      tokens[i] += tokens[i + 2];
	      tokens.splice(i + 1, 2);
	      i--;
	    }
	  }

	  return tokens;
	};

	const lineDiff = new Diff();
	lineDiff.tokenize = function(value) {
	  let retLines = [],
	      linesAndNewlines = value.split(/(\n|\r\n)/);

	  // Ignore the final empty token that occurs if the string ends with a new line
	  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
	    linesAndNewlines.pop();
	  }

	  // Merge the content and line separators into single tokens
	  for (let i = 0; i < linesAndNewlines.length; i++) {
	    let line = linesAndNewlines[i];

	    if (i % 2 && !this.options.newlineIsToken) {
	      retLines[retLines.length - 1] += line;
	    } else {
	      if (this.options.ignoreWhitespace) {
	        line = line.trim();
	      }
	      retLines.push(line);
	    }
	  }

	  return retLines;
	};

	const sentenceDiff = new Diff();
	sentenceDiff.tokenize = function(value) {
	  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
	};

	const cssDiff = new Diff();
	cssDiff.tokenize = function(value) {
	  return value.split(/([{}:;,]|\s+)/);
	};

	const objectPrototypeToString = Object.prototype.toString;


	const jsonDiff = new Diff();
	// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
	// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
	jsonDiff.useLongestToken = true;

	jsonDiff.tokenize = lineDiff.tokenize;
	jsonDiff.castInput = function(value) {
	  const {undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v} = this.options;

	  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
	};
	jsonDiff.equals = function(left, right) {
	  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
	};

	// This function handles the presence of circular references by bailing out when encountering an
	// object that is already on the "stack" of items being processed. Accepts an optional replacer
	function canonicalize(obj, stack, replacementStack, replacer, key) {
	  stack = stack || [];
	  replacementStack = replacementStack || [];

	  if (replacer) {
	    obj = replacer(key, obj);
	  }

	  let i;

	  for (i = 0; i < stack.length; i += 1) {
	    if (stack[i] === obj) {
	      return replacementStack[i];
	    }
	  }

	  let canonicalizedObj;

	  if ('[object Array]' === objectPrototypeToString.call(obj)) {
	    stack.push(obj);
	    canonicalizedObj = new Array(obj.length);
	    replacementStack.push(canonicalizedObj);
	    for (i = 0; i < obj.length; i += 1) {
	      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
	    }
	    stack.pop();
	    replacementStack.pop();
	    return canonicalizedObj;
	  }

	  if (obj && obj.toJSON) {
	    obj = obj.toJSON();
	  }

	  if (typeof obj === 'object' && obj !== null) {
	    stack.push(obj);
	    canonicalizedObj = {};
	    replacementStack.push(canonicalizedObj);
	    let sortedKeys = [],
	        key;
	    for (key in obj) {
	      /* istanbul ignore else */
	      if (obj.hasOwnProperty(key)) {
	        sortedKeys.push(key);
	      }
	    }
	    sortedKeys.sort();
	    for (i = 0; i < sortedKeys.length; i += 1) {
	      key = sortedKeys[i];
	      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);
	    }
	    stack.pop();
	    replacementStack.pop();
	  } else {
	    canonicalizedObj = obj;
	  }
	  return canonicalizedObj;
	}

	const arrayDiff = new Diff();
	arrayDiff.tokenize = function(value) {
	  return value.slice();
	};
	arrayDiff.join = arrayDiff.removeEmpty = function(value) {
	  return value;
	};

	const RemoveItem = Phaser.Utils.Array.Remove;

	var SetText = function (textObject, newText) {
	    var text = textObject.text;
	    if (newText === text) {
	        return;
	    }

	    if (text == null) {
	        text = '';
	    }

	    // textObject.setText(newText);

	    // Remove lastInsertCursor directly 
	    RemoveItem(textObject.children, textObject.lastInsertCursor);

	    if (newText === '') {
	        textObject.removeChildren();
	    } else {
	        var results = diffChars(text, newText);
	        var charIndex = 0;
	        for (var i = 0, cnt = results.length; i < cnt; i++) {
	            var result = results[i];
	            if (result.removed) {
	                // Remove character at charIndex
	                textObject.removeText(charIndex, result.count);
	            } else if (result.added) {
	                textObject.insertText(charIndex, result.value);
	                charIndex += result.count;
	            } else {
	                charIndex += result.count;
	            }
	        }
	    }

	    // Push back lastInsertCursor directly
	    textObject.children.push(textObject.lastInsertCursor);

	    textObject.runWrap();

	    if (textObject.isOpened) {
	        textObject.textEdit.setText(newText);
	    }

	    textObject.emit('textchange', newText, textObject);

	};

	var SetTextOXYMethods = {
	    setTextOYByPercentage(percentage) {
	        this.setTextOY(-this.textVisibleHeight * percentage);
	        return this;
	    },

	    getTextOYPercentage() {
	        var textVisibleHeight = this.textVisibleHeight;
	        if (textVisibleHeight === 0) {
	            return 0;
	        }
	        return (this._textOY / -textVisibleHeight);
	    },

	    setTextOXByPercentage(percentage) {
	        this.setTextOX(-this.textVisibleWidth * percentage);
	        return this;
	    },

	    getTextOXPercentage() {
	        var textVisibleWidth = this.textVisibleWidth;
	        if (textVisibleWidth === 0) {
	            return 0;
	        }
	        return (this._textOX / -textVisibleWidth);
	    }

	};

	const Clamp = Phaser.Math.Clamp;

	var GetIndex = function (characterCountOfLines, position) {
	    var result = { lineIndex: 0, position: 0 };

	    if (position < 0) {
	        return result;
	    }

	    for (var li = 0, lcnt = characterCountOfLines.length; li < lcnt; li++) {
	        var characterCount = characterCountOfLines[li];
	        if (position <= characterCount) {
	            result.lineIndex = li;
	            break;
	        }
	        position -= characterCount;
	    }
	    result.position = position;

	    return result;
	};

	var GetPosition = function (characterCountOfLines, index) {
	    var position = 0;
	    var lineIndex = index.lineIndex;
	    if (lineIndex < 0) {
	        return position;
	    }

	    for (var li = 0, lcnt = characterCountOfLines.length; li < lcnt; li++) {
	        var characterCount = characterCountOfLines[li];
	        if (lineIndex > li) {
	            position += characterCount;
	        } else if (lineIndex === li) {
	            position += Math.min(index.position, characterCount);
	        } else {
	            break;
	        }
	    }

	    return position;
	};

	var MoveCursorMethods = {
	    cursorMoveLeft() {
	        if (!this.isOpened) {
	            return this;
	        }

	        // Move cursor to previous character
	        var position = Clamp(this.cursorPosition - 1, 0, this.inputText.length);
	        this.setCursorPosition(position);

	        return this;
	    },

	    cursorMoveRight() {
	        if (!this.isOpened) {
	            return this;
	        }

	        // Move cursor to next character
	        var position = Clamp(this.cursorPosition + 1, 0, this.inputText.length);
	        this.setCursorPosition(position);

	        return this;
	    },

	    cursorMoveUp() {
	        if (!this.isOpened) {
	            return this;
	        }

	        var result = GetIndex(this.characterCountOfLines, this.cursorPosition);
	        result.lineIndex -= 1;

	        var position = Clamp(GetPosition(this.characterCountOfLines, result), 0, this.inputText.length);
	        this.setCursorPosition(position);

	        return this;
	    },

	    cursorMoveDown() {
	        if (!this.isOpened) {
	            return this;
	        }

	        var result = GetIndex(this.characterCountOfLines, this.cursorPosition);
	        result.lineIndex += 1;

	        var position = Clamp(GetPosition(this.characterCountOfLines, result), 0, this.inputText.length);
	        this.setCursorPosition(position);

	        return this;
	    },
	};

	const IsPlainObject$1 = Phaser.Utils.Objects.IsPlainObject;

	class CanvasInput extends DynamicText {
	    constructor(scene, x, y, fixedWidth, fixedHeight, config) {
	        if (IsPlainObject$1(x)) {
	            config = x;
	        } else if (IsPlainObject$1(fixedWidth)) {
	            config = fixedWidth;
	        }

	        if (config === undefined) {
	            config = {};
	        }

	        InjectDefaultConfig(scene, config);

	        // Set text later
	        var text = config.text;
	        if (text) {
	            delete config.text;
	        }

	        var focusStyle = ExtractByPrefix(config.background, 'focus');
	        var cursorStyle = ExtractByPrefix(config.style, 'cursor');
	        var rangeStyle = ExtractByPrefix(config.style, 'range');

	        super(scene, x, y, fixedWidth, fixedHeight, config);
	        this.type = 'rexCanvasInput';

	        // readonly
	        this.contentWidth = undefined;
	        this.contentHeight = undefined;
	        this.lineHeight = undefined;
	        this.linesCount = undefined;
	        this.characterCountOfLines = [];

	        this._text;

	        this.textEdit = CreateHiddenTextEdit(this, config);

	        RegisterArrowKeysEvent.call(this);

	        if (config.focusStyle) {
	            Object.assign(focusStyle, config.focusStyle);
	        }
	        RegisterFocusStyle.call(this, focusStyle);

	        if (config.cursorStyle) {
	            Object.assign(cursorStyle, config.cursorStyle);
	        }
	        RegisterCursorStyle.call(this, cursorStyle);

	        if (config.rangeStyle) {
	            Object.assign(rangeStyle, config.rangeStyle);
	        }
	        if (IsEmpty(rangeStyle)) {
	            Object.assign(rangeStyle, cursorStyle);
	        }
	        RegisterRangeStyle.call(this, rangeStyle);


	        var addCharCallback = config.onAddChar;
	        if (addCharCallback) {
	            this.on('addchar', addCharCallback);
	        }

	        var cursorInCallback = config.onCursorIn;
	        if (cursorInCallback) {
	            this.on('cursorin', cursorInCallback);
	        }

	        var cursorOutCallback = config.onCursorOut;
	        if (cursorOutCallback) {
	            this.on('cursorout', cursorOutCallback);
	        }

	        var useCursorCallback = !config.onRangeIn && !config.onRangeOut;
	        var rangeInCallback = (!useCursorCallback) ? config.onRangeIn : config.onCursorIn;
	        if (rangeInCallback) {
	            this.on('rangein', rangeInCallback);
	        }

	        var rangeOutCallback = (!useCursorCallback) ? config.onRangeOut : config.onCursorOut;
	        if (rangeOutCallback) {
	            this.on('rangeout', rangeOutCallback);
	        }

	        var moveCursorCallback = config.onMoveCursor;
	        if (moveCursorCallback) {
	            this.on('movecursor', moveCursorCallback);
	        }

	        this.setParseTextCallback(config.parseTextCallback);

	        this.lastInsertCursor = CreateInsertCursorChild(this);

	        if (!text) {
	            text = '';
	        }
	        this.setText(text);
	    }

	    addChild(child, index) {
	        super.addChild(child, index);

	        if (Array.isArray(child)) {
	            var children = child;
	            for (var i = 0, cnt = children.length; i < cnt; i++) {
	                var child = children[i];
	                if (IsChar(child)) {
	                    this.emit('addchar', child, index + i, this);
	                }
	            }
	        } else {
	            if (IsChar(child)) {
	                this.emit('addchar', child, index, this);
	            }
	        }

	        return this;
	    }

	    get text() {
	        return this._text;
	    }

	    set text(value) {
	        if (value == null) {
	            value = '';
	        } else {
	            value = value.toString();
	        }
	        if (this._text === value) {
	            return;
	        }

	        SetText(this, value);

	        this._text = value;
	    }

	    setText(text) {
	        this.text = text;
	        return this;
	    }

	    appendText(text) {
	        this.setText(this.text + text);
	        return this;
	    }

	    runWrap(config) {
	        var result = super.runWrap(config);
	        // Save content size
	        this.contentWidth = result.maxLineWidth;
	        this.contentHeight = result.linesHeight;
	        this.lineHeight = result.lineHeight;
	        this.linesCount = result.lines.length;

	        this.characterCountOfLines.length = 0;
	        var wrapLines = result.lines;
	        for (var li = 0, lcnt = wrapLines.length; li < lcnt; li++) {
	            var line = wrapLines[li].children;
	            var characterCount = 0;
	            for (var ci = 0, ccnt = line.length; ci < ccnt; ci++) {
	                var child = line[ci];
	                if (child.active && !child.removed && IsChar(child)) {
	                    characterCount++;
	                }
	            }

	            this.characterCountOfLines.push(characterCount);
	        }

	        return result;
	    }

	    setSize(width, height) {
	        if ((this.width === width) && (this.height === height)) {
	            return this;
	        }

	        super.setSize(width, height);

	        // Run wrap again since fixedWidth and fixedHeight are changed
	        this.runWrap();

	        return this;
	    }

	    get displayText() {
	        return this.text;
	    }

	    set displayText(value) {
	        this.text = value;
	    }

	    setDisplayText(value) {
	        this.displayText = value;
	        return this;
	    }

	    get inputText() {
	        return this.textEdit.text;
	    }

	    set inputText(value) {
	        this.textEdit.text = value;
	    }

	    setInputText(value) {
	        this.inputText = value;
	        return this;
	    }

	    setParseTextCallback(callback) {
	        if (!callback) {
	            callback = DefaultParseTextCallback;
	        }
	        this.parseTextCallback = callback;
	        return this;
	    }

	    get value() {
	        return this.parseTextCallback(this.text);
	    }

	    set value(value) {
	        this.setText(value);
	    }

	    getValue() {
	        return this.value;
	    }

	    setValue(value) {
	        this.value = value;
	        return this;
	    }

	    get readOnly() {
	        return this.textEdit.readOnly;
	    }

	    set readOnly(value) {
	        this.textEdit.readOnly = value;
	    }

	    setReadOnly(value) {
	        this.textEdit.setReadOnly(value);
	        return this;
	    }

	    open(onCloseCallback) {
	        if (onCloseCallback) {
	            this.textEdit.once('close', onCloseCallback);
	        }
	        this.textEdit.open();
	        return this;
	    }

	    close() {
	        this.textEdit.close();
	        return this;
	    }

	    get isOpened() {
	        return this.textEdit.isOpened;
	    }

	    setFocusStyle(style) {
	        this.focusStyle = style;
	        return this;
	    }

	    setCursorStyle(style) {
	        this.cursorStyle = style;
	        return this;
	    }

	    setRangeStyle(style) {
	        this.rangeStyle = style;
	        return this;
	    }

	    setNumberInput() {
	        this.textEdit
	            .setNumberInput()
	            .setSelectAllWhenFocusEnable();

	        this.parseTextCallback = Number;
	        return this;
	    }

	    get maxLength() {
	        return this.textEdit.maxLength;
	    }

	    set maxLength(value) {
	        this.textEdit.maxLength = value;
	    }

	    setMaxLength(value) {
	        this.maxLength = value;
	        return this;
	    }

	    get minLength() {
	        return this.textEdit.minLength;
	    }

	    set minLength(value) {
	        this.textEdit.minLength = value;
	    }

	    setMinLength(value) {
	        this.minLength = value;
	        return this;
	    }

	    get cursorPosition() {
	        return this.textEdit.cursorPosition;
	    }

	    set cursorPosition(value) {
	        if (!this.isOpened) {
	            return;
	        }

	        this.textEdit.cursorPosition = value;
	        this.textEdit.requestCursorPosition = value;
	    }

	    setCursorPosition(value) {
	        this.cursorPosition = value;
	        return this;
	    }

	    get topTextOY() {
	        return 0;
	    }

	    get bottomTextOY() {
	        return -this.tableVisibleHeight;
	    }

	    get leftTextOX() {
	        return 0;
	    }

	    get rightTextOX() {
	        return -this.textVisibleWidth;
	    }

	    get textVisibleHeight() {
	        var h = this.contentHeight - this.height;
	        if (h < 0) {
	            h = 0;
	        }
	        return h;
	    }

	    get textVisibleWidth() {
	        var w = this.contentWidth - this.width;
	        if (w < 0) {
	            w = 0;
	        }
	        return w;
	    }

	    set t(value) {
	        this.setTextOYByPercentage(value).updateTexture();
	    }

	    get t() {
	        return this.getTextOYPercentage();
	    }

	    set s(value) {
	        this.setTextOXByPercentage(value).updateTexture();
	    }

	    get s() {
	        return this.getTextOXPercentage();
	    }

	}

	var DefaultParseTextCallback = function (text) {
	    return text;
	};

	Object.assign(
	    CanvasInput.prototype,
	    SetTextOXYMethods,
	    MoveCursorMethods,
	);

	var CreateInputText = function (scene, config, deepCloneConfig) {
	    if (deepCloneConfig === undefined) {
	        deepCloneConfig = true;
	    }

	    if (deepCloneConfig) {
	        config = (config) ? DeepClone(config) : {};
	    } else if (!config) {
	        config = {};
	    }


	    var inputText = new CanvasInput(scene, config);
	    scene.add.existing(inputText);
	    return inputText;
	};

	const GetValue$2 = Phaser.Utils.Objects.GetValue;

	var CreateContent = function (scene, config, creators) {
	    // Names-sizer as content
	    var layoutMode = GetOrientationMode(GetValue$2(config, 'layoutMode', 0));
	    var isHorizontalLayout = layoutMode === 0;
	    var nameSizer = new Sizer(scene, {
	        orientation: layoutMode,
	        space: {
	            item: GetValue$2(config, 'space.firstName', 0)
	        }
	    });
	    scene.add.existing(nameSizer);

	    // First name
	    var firstNameSizer = new Sizer(scene, { orientation: 'x' });
	    scene.add.existing(firstNameSizer);

	    var firstNameTitleConfig = GetValue$2(config, 'firstNameTitle', config.nameTitle);
	    var firstNameTitle = CreateLabel(scene, firstNameTitleConfig, creators.firstNameTitle || creators.nameTitle);
	    firstNameSizer.add(
	        firstNameTitle,
	        {
	            expand: true,
	            proportion: GetValue$2(config, 'proportion.firstNameTitle', 0),
	            padding: {
	                right: GetValue$2(config, 'space.firstNameTitle', 0)
	            },
	        }
	    );

	    var defaultNameInputConfig = config.nameInput || {};
	    var firstNameInputConfig = GetValue$2(config, 'firstNameInput', defaultNameInputConfig);
	    var firstNameInput = CreateInputText(scene, firstNameInputConfig, creators.firstNameInput || creators.nameInput);
	    var expandFirstNameSizer = !firstNameInputConfig.hasOwnProperty('width');
	    firstNameSizer.add(
	        firstNameInput,
	        {
	            expand: true,
	            proportion: (expandFirstNameSizer) ? 1 : 0,
	        }
	    );

	    // Last name
	    var lastNameSizer = new Sizer(scene, { orientation: 'x' });
	    scene.add.existing(lastNameSizer);

	    var lastNameTitleConfig = GetValue$2(config, 'lastNameTitle', config.nameTitle);
	    var lastNameTitle = CreateLabel(scene, lastNameTitleConfig, creators.lastNameTitle || creators.nameTitle);
	    lastNameSizer.add(
	        lastNameTitle,
	        {
	            expand: true,
	            proportion: GetValue$2(config, 'proportion.lastNameTitle', 0),
	            padding: {
	                right: GetValue$2(config, 'space.lastNameTitle', 0)
	            }
	        }
	    );

	    var lastNameInputConfig = GetValue$2(config, 'firstNameInput', defaultNameInputConfig);
	    var lastNameInput = CreateInputText(scene, lastNameInputConfig, creators.lastNameInput || creators.nameInput);
	    var expandLastNameSizer = !lastNameInputConfig.hasOwnProperty('width');
	    lastNameSizer.add(
	        lastNameInput,
	        {
	            expand: true,
	            proportion: (expandLastNameSizer) ? 1 : 0,
	        }
	    );


	    if (isHorizontalLayout) {
	        // First | Last

	        var defaultFirstNameProportion = (expandFirstNameSizer) ? 1 : 0;
	        var firstNameProportion = GetValue$2(config, 'proportion.firstName', defaultFirstNameProportion);
	        nameSizer.add(
	            firstNameSizer,
	            {
	                expand: true,
	                proportion: firstNameProportion,
	            }
	        );

	        var defaultLastNameProportion = (expandLastNameSizer) ? 1 : 0;
	        var lastNameProportion = GetValue$2(config, 'proportion.lastName', defaultLastNameProportion);
	        nameSizer.add(
	            lastNameSizer,
	            {
	                expand: true,
	                proportion: lastNameProportion,
	            }
	        );
	    } else {
	        // First        
	        // Last
	        nameSizer.add(
	            firstNameSizer,
	            {
	                expand: expandFirstNameSizer,
	                proportion: 0,
	            }
	        );
	        nameSizer.add(
	            lastNameSizer,
	            {
	                expand: expandLastNameSizer,
	                proportion: 0,
	            }
	        );
	    }

	    nameSizer.addChildrenMap('firstNameTitle', firstNameTitle);
	    nameSizer.addChildrenMap('firstNameInput', firstNameInput);
	    nameSizer.addChildrenMap('lastNameTitle', lastNameTitle);
	    nameSizer.addChildrenMap('lastNameInput', lastNameInput);

	    return nameSizer;
	};

	const GetValue$1 = Phaser.Utils.Objects.GetValue;

	class NameInputDialog extends Dialog {
	    constructor(scene, config, creators) {
	        if (config === undefined) {
	            config = {};
	        }

	        if (creators === undefined) {
	            creators = {};
	        }

	        config.orientation = 'y';

	        var spaceConfig = config.space;
	        if (spaceConfig) {
	            if (spaceConfig.hasOwnProperty('names')) {
	                spaceConfig.content = spaceConfig.names;
	            }
	            if (spaceConfig.hasOwnProperty('namesLeft')) {
	                spaceConfig.contentLeft = spaceConfig.namesLeft;
	            }
	            if (spaceConfig.hasOwnProperty('namesRight')) {
	                spaceConfig.contentRight = spaceConfig.namesRight;
	            }
	        }


	        // Background
	        var createBackground = GetValue$1(creators, 'background', CreateBackground);
	        config.background = createBackground(scene, config.background);

	        // Title
	        config.title = CreateLabel(scene, config.title, creators.title);

	        // Content
	        config.content = CreateContent(scene, config, creators);

	        // Actions
	        config.actions = [
	            CreateLabel(scene, config.button, creators.button)
	        ];

	        super(scene, config);
	        this.type = 'rexNameInputDialog';

	        var namesSizerChildrenMap = config.content.childrenMap;
	        this.addChildrenMap('firstNameTitle', namesSizerChildrenMap.firstNameTitle);
	        this.addChildrenMap('firstNameInput', namesSizerChildrenMap.firstNameInput);
	        this.addChildrenMap('lastNameTitle', namesSizerChildrenMap.lastNameTitle);
	        this.addChildrenMap('lastNameInput', namesSizerChildrenMap.lastNameInput);

	        this.addChildrenMap('button', config.actions[0]);

	        // Interactive
	        RegisterEvents.call(this);

	        this.modalStyle = config.modal || {};
	    }

	    get firstName() {
	        return this.childrenMap.firstNameInput.text;
	    }

	    set firstName(value) {
	        this.childrenMap.firstNameInput.setText(value);
	    }

	    setFirstName(value) {
	        this.firstName = value;
	        return this;
	    }

	    get lastName() {
	        return this.childrenMap.lastNameInput.text;
	    }

	    set lastName(value) {
	        this.childrenMap.lastNameInput.setText(value);
	    }

	    setLastName(value) {
	        this.lastName = value;
	        return this;
	    }

	}


	Object.assign(
	    NameInputDialog.prototype,
	    methods
	);

	var GenerateDefaultCreateGameObjectCallback = function (
	    style,
	    {
	        viewport
	    } = {},
	    creators
	) {

	    return function (
	        scene,
	        {
	            vpw, vph,
	            width = 0, height = 0,
	            vpx = 0.5, vpy = 0.5,
	        } = {}
	    ) {

	        if (vpw !== undefined) {
	            width = viewport.width * vpw;
	        }

	        if (vph !== undefined) {
	            height = viewport.height * vph;
	        }

	        var gameObject = new NameInputDialog(scene, style, creators);

	        gameObject
	            .setMinSize(width, height)
	            .setVisible(false);

	        scene.add.existing(gameObject);
	        AddViewportCoordinateProperties(gameObject, viewport);

	        gameObject.vpx = vpx;
	        gameObject.vpy = vpy;

	        AddShakeBehavior(gameObject);

	        return gameObject;
	    }
	};

	var NameInput = function (
	    gameObject,
	    {
	        title = null,
	        firstNameTitle = null, lastNameTitle = null,
	        button = 'OK',
	        firstName = '', lastName = '',
	        firstNameKey = 'firstName', lastNameKey = 'lastName'
	    } = {},

	    commandExecutor, eventSheetManager, eventSheet
	) {

	    gameObject
	        .setVisible(true)
	        .resetDisplayContent({
	            title,
	            firstNameTitle,
	            lastNameTitle,
	            button,
	            firstName,
	            lastName
	        })
	        .layout();

	    commandExecutor.waitEvent(gameObject, 'complete');

	    gameObject
	        .modalPromise({ destroy: false })
	        .then(function (data) {
	            eventSheetManager
	                .setData(firstNameKey, data.firstName)
	                .setData(lastNameKey, data.lastName);
	            gameObject.emit('complete');
	        });

	};

	const GetValue = Phaser.Utils.Objects.GetValue;
	const IsPlainObject = Phaser.Utils.Objects.IsPlainObject;

	var RegisterNameInputDialogType = function (commandExecutor, config) {
	    var { viewport } = config;
	    var createGameObjectCallback = GetValue(config, `creators.${NAMEINPUT}`, undefined);
	    if (createGameObjectCallback === false) {
	        return;
	    }

	    var creators;
	    if (IsPlainObject(createGameObjectCallback)) {
	        creators = createGameObjectCallback;
	        createGameObjectCallback = undefined;
	    }

	    if (createGameObjectCallback === undefined) {
	        var style = GetValue(config, `styles.${NAMEINPUT}`, {});
	        createGameObjectCallback = GenerateDefaultCreateGameObjectCallback(
	            style,
	            {
	                viewport
	            },
	            creators
	        );
	    }

	    commandExecutor.addGameObjectManager({
	        name: NAMEINPUT,
	        createGameObject: createGameObjectCallback,
	        fade: 0,  // No fade-in when creating/destroying gameobject
	        viewportCoordinate: { viewport },
	        defaultLayer: UILayer,

	        commands: {
	            input: NameInput,
	            shake: Shake,
	        }
	    });
	};

	const RegisterHandlers$1 = [
	    RegisterSpriteType,
	    RegisterTextboxType,
	    RegisterBackgroundType,
	    RegisterChoiceDialogType,
	    RegisterNameInputDialogType,
	    RegisterTitleType,
	];


	var CreateCommandExecutor = function (scene, config) {
	    var {
	        layerDepth,
	        rootLayer,
	        multipleCamerasEnable = false,
	        viewport
	    } = config;

	    if (viewport === undefined) {
	        config.viewport = GetViewport(scene, scene.cameras.main);
	    }

	    var commandExecutor = new CommandExecutor(scene, {
	        layers: (multipleCamerasEnable) ? LayerConfigMultipleCamras : LayerConfigSingleCamera,
	        layerDepth,
	        rootLayer,
	    });

	    for (var i = 0, cnt = RegisterHandlers$1.length; i < cnt; i++) {
	        RegisterHandlers$1[i](commandExecutor, config);
	    }

	    // Add anyTouchDetector to bottomLayer
	    var anyTouchDetector = new FullWindowRectangle$1(scene).setInteractive();
	    scene.add.existing(anyTouchDetector);
	    commandExecutor.sys.layerManager.addToBottomLayer(anyTouchDetector);
	    commandExecutor.sys.anyTouchDetector = anyTouchDetector;

	    return commandExecutor;
	};

	var RegisterRandomExpression = function (eventSheetManager) {
	    eventSheetManager.addExpression('random', function (a, b) {
	        if ((a === undefined) && (b === undefined)) {
	            a = 0;
	            b = 1;
	        } else if (b === undefined) {
	            b = a;
	            a = 0;
	        }
	        return a + Math.random() * (b - a);
	    });
	};

	var RegisterRandomIntExpression = function (eventSheetManager) {
	    eventSheetManager.addExpression('randomInt', function (a, b) {
	        return Math.floor(a + Math.random() * (b - a + 1));
	    });
	};

	var RegisterHandlers = [
	    RegisterRandomExpression,
	    RegisterRandomIntExpression,
	];

	var RegisterExpressions = function (eventSheetManager, config) {
	    for (var i = 0, cnt = RegisterHandlers.length; i < cnt; i++) {
	        RegisterHandlers[i](eventSheetManager);
	    }
	};

	var DefaultVariables = {
	    $typingSpeed: 100,                  // TEXTBOX.typing
	    $autoNextPage: false,               // TEXTBOX.typing
	    $autoNextPageDelay: 500,            // TEXTBOX.typing
	    $fastTyping: false,                 // TEXTBOX.typing
	    $fastTypingSpeed: 20,               // TEXTBOX.typing
	    $clickShortcutKeys: 'SPACE|ENTER',  // TEXTBOX.typing
	    $fastTypingShortcutKeys: 'CTRL',    // TEXTBOX.typing
	    $clickTarget: 'screen',             // TEXTBOX

	    $transitionDuration: 500,           // SPRITE.cross, BG.cross
	    $tintOthers: 0x333333,              // SPRITE.focus
	    $shakeDuration: 500,                // SPRITE.shake, BG.shake, TEXTBOX.shake, TITLE.shake, CHOICE.shake
	    $shakeMagnitude: 50,                // SPRITE.shake, BG.shake, TEXTBOX.shake, TITLE.shake, CHOICE.shake
	};

	/**
	 * @author       Richard Davey <rich@photonstorm.com>
	 * @copyright    2019 Photon Storm Ltd.
	 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
	 */


	/**
	 * Creates a new Object using all values from obj1 and obj2.
	 * If a value exists in both obj1 and obj2, the value in obj1 is used.
	 * 
	 * This is only a shallow copy. Deeply nested objects are not cloned, so be sure to only use this
	 * function on shallow objects.
	 *
	 * @function Phaser.Utils.Objects.Merge
	 * @since 3.0.0
	 *
	 * @param {object} obj1 - The first object.
	 * @param {object} obj2 - The second object.
	 *
	 * @return {object} A new object containing the union of obj1's and obj2's properties.
	 */
	var Merge = function (obj1, obj2)
	{
	    var clone = Clone(obj1);

	    for (var key in obj2)
	    {
	        if (!clone.hasOwnProperty(key))
	        {
	            clone[key] = obj2[key];
	        }
	    }

	    return clone;
	};

	var RegisterDefaultVariables = function (eventSheetManager, config) {
	    var { defaultVariables } = config;
	    defaultVariables = Merge(defaultVariables, DefaultVariables);

	    for (var key in defaultVariables) {
	        eventSheetManager.setData(key, defaultVariables[key]);
	    }
	};

	class MDScenario extends MarkedEventSheets {
	    constructor(scene, config = {}) {
	        config.commandExecutor = CreateCommandExecutor(scene, config);
	        super(config);

	        // this.commandExecutor;

	        RegisterExpressions(this);

	        RegisterDefaultVariables(this, config);
	    }
	}

	return MDScenario;

}));
